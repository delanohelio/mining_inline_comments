{"pr_number": 1533, "pr_title": "Windchild's Personnel Improvements", "pr_createdAt": "2020-02-29T04:11:35Z", "pr_url": "https://github.com/MegaMek/mekhq/pull/1533", "timeline": [{"oid": "70848389b7df9b6d749ad9a4d4a9fa843ba134c9", "url": "https://github.com/MegaMek/mekhq/commit/70848389b7df9b6d749ad9a4d4a9fa843ba134c9", "message": "Fixing surname generation for clanner personnel", "committedDate": "2020-02-26T16:17:24Z", "type": "commit"}, {"oid": "72545b20cc5c70482539ce09033930182d378ec0", "url": "https://github.com/MegaMek/mekhq/commit/72545b20cc5c70482539ce09033930182d378ec0", "message": "Fixing utilities name and gender migration for all crew", "committedDate": "2020-02-26T17:06:10Z", "type": "commit"}, {"oid": "5a6f563bf77f1cbff1818676fa3b7d864d8d2f98", "url": "https://github.com/MegaMek/mekhq/commit/5a6f563bf77f1cbff1818676fa3b7d864d8d2f98", "message": "Expanding upon the TODO statements", "committedDate": "2020-02-26T17:19:04Z", "type": "commit"}, {"oid": "c2933cd684103958ad82c21528098039bbfb4f80", "url": "https://github.com/MegaMek/mekhq/commit/c2933cd684103958ad82c21528098039bbfb4f80", "message": "Fixing Bloodname manual generation for clanners in IS forces", "committedDate": "2020-02-26T19:20:22Z", "type": "commit"}, {"oid": "1c682f6e005b193ea1cf7763487d07620be5555e", "url": "https://github.com/MegaMek/mekhq/commit/1c682f6e005b193ea1cf7763487d07620be5555e", "message": "Little bit of last minute refactoring and fixes in Person and Utilities", "committedDate": "2020-02-26T19:25:05Z", "type": "commit"}, {"oid": "ea753ea5d9de670869c0ba856185c2f1a843eed3", "url": "https://github.com/MegaMek/mekhq/commit/ea753ea5d9de670869c0ba856185c2f1a843eed3", "message": "Refactoring in Utilities.java", "committedDate": "2020-02-26T19:34:27Z", "type": "commit"}, {"oid": "9e2f60917efbcb94b5d500b0854246e1b336cd2a", "url": "https://github.com/MegaMek/mekhq/commit/9e2f60917efbcb94b5d500b0854246e1b336cd2a", "message": "Changing name generation to use the person's origin faction", "committedDate": "2020-02-26T19:42:22Z", "type": "commit"}, {"oid": "f0c58c0cff8f55d414927f2e297dd340acf4ef2a", "url": "https://github.com/MegaMek/mekhq/commit/f0c58c0cff8f55d414927f2e297dd340acf4ef2a", "message": "Refactoring in CustomizePersonDialog", "committedDate": "2020-02-26T20:03:53Z", "type": "commit"}, {"oid": "a28e8e44117f77d271a2d1f9cd4bb5d834c3108f", "url": "https://github.com/MegaMek/mekhq/commit/a28e8e44117f77d271a2d1f9cd4bb5d834c3108f", "message": "Fixing merge conflicts", "committedDate": "2020-02-26T20:13:10Z", "type": "commit"}, {"oid": "8c5787605a8df4876314d9b800a0ea9e9a359559", "url": "https://github.com/MegaMek/mekhq/commit/8c5787605a8df4876314d9b800a0ea9e9a359559", "message": "Removing bandaid solution following name generation fixes", "committedDate": "2020-02-26T20:24:42Z", "type": "commit"}, {"oid": "3543e6bcce16609bd8c8e45567671484a854d042", "url": "https://github.com/MegaMek/mekhq/commit/3543e6bcce16609bd8c8e45567671484a854d042", "message": "Fixing issue with options display", "committedDate": "2020-02-26T20:55:53Z", "type": "commit"}, {"oid": "56fbd65bb4573e0d86b00bd207507a07da47cdfd", "url": "https://github.com/MegaMek/mekhq/commit/56fbd65bb4573e0d86b00bd207507a07da47cdfd", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-28T22:40:21Z", "type": "commit"}, {"oid": "614b3b292f4f7205a257034ae1ca886e29a87d5d", "url": "https://github.com/MegaMek/mekhq/commit/614b3b292f4f7205a257034ae1ca886e29a87d5d", "message": "Switching Gender constants to crew, and gender strings to use a single output statement", "committedDate": "2020-02-29T00:00:39Z", "type": "commit"}, {"oid": "09aefee1e6ac2348b291dca18318f54fb7565504", "url": "https://github.com/MegaMek/mekhq/commit/09aefee1e6ac2348b291dca18318f54fb7565504", "message": "Removing unused injury methods", "committedDate": "2020-02-29T00:05:44Z", "type": "commit"}, {"oid": "82d37aac4e7725f4de576b87a09d717f69dea824", "url": "https://github.com/MegaMek/mekhq/commit/82d37aac4e7725f4de576b87a09d717f69dea824", "message": "Filling in Person Javadoc comments", "committedDate": "2020-02-29T00:07:52Z", "type": "commit"}, {"oid": "f580469ddc656c51f23c793b3e2eb2e1eba464de", "url": "https://github.com/MegaMek/mekhq/commit/f580469ddc656c51f23c793b3e2eb2e1eba464de", "message": "Removing old and unused methods from Person.java", "committedDate": "2020-02-29T00:16:25Z", "type": "commit"}, {"oid": "fe751f4575f10cc182ea663898509f05990c1e5a", "url": "https://github.com/MegaMek/mekhq/commit/fe751f4575f10cc182ea663898509f05990c1e5a", "message": "Removing unused constant in Person", "committedDate": "2020-02-29T00:17:00Z", "type": "commit"}, {"oid": "1ed2715899db1ab60a79298ca96618689816018a", "url": "https://github.com/MegaMek/mekhq/commit/1ed2715899db1ab60a79298ca96618689816018a", "message": "Fixing minor issues in CampaignOptions.java", "committedDate": "2020-02-29T00:27:52Z", "type": "commit"}, {"oid": "0864ba8953719594f5c833c57aeba90aac4833e2", "url": "https://github.com/MegaMek/mekhq/commit/0864ba8953719594f5c833c57aeba90aac4833e2", "message": "Refactoring doMaintenance in Campaign", "committedDate": "2020-02-29T00:47:30Z", "type": "commit"}, {"oid": "93512ea5dd8101dc85c6e4a7c5ea31378bc36f32", "url": "https://github.com/MegaMek/mekhq/commit/93512ea5dd8101dc85c6e4a7c5ea31378bc36f32", "message": "Elaborating in Person TODO comment", "committedDate": "2020-02-29T00:51:17Z", "type": "commit"}, {"oid": "951fecb76587eb821aa3df3636d40a50a5f4ca6b", "url": "https://github.com/MegaMek/mekhq/commit/951fecb76587eb821aa3df3636d40a50a5f4ca6b", "message": "Fixing bloodname comment for wave 2", "committedDate": "2020-02-29T00:52:08Z", "type": "commit"}, {"oid": "cfb4e410ad6545f693e9279e179b87aa8abee397", "url": "https://github.com/MegaMek/mekhq/commit/cfb4e410ad6545f693e9279e179b87aa8abee397", "message": "Switching Person gender references to Crew", "committedDate": "2020-02-29T03:41:03Z", "type": "commit"}, {"oid": "d59fa1f85b3fb673cbb0b766be34a28409c24bc7", "url": "https://github.com/MegaMek/mekhq/commit/d59fa1f85b3fb673cbb0b766be34a28409c24bc7", "message": "Reordering and Refactoring Person saving to decrease save size", "committedDate": "2020-02-29T03:42:06Z", "type": "commit"}, {"oid": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "url": "https://github.com/MegaMek/mekhq/commit/0097883e28e931dc8b135ef875b0d6c5e34f94b4", "message": "Cleaning up Person xml export", "committedDate": "2020-02-29T04:07:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzNzMxMA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386137310", "bodyText": "Is this to help remember these values?", "author": "sixlettervariables", "createdAt": "2020-03-01T20:20:07Z", "path": "MekHQ/src/mekhq/campaign/personnel/Bloodname.java", "diffHunk": "@@ -64,7 +64,16 @@\n \tpublic static final int P_PROTOMECH = 4;\n \tpublic static final int P_NAVAL = 5;\n \tpublic static final int P_NUM = 6;\n-\n+/*", "originalCommit": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0Mjc1Nw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386142757", "bodyText": "This is for my bloodname merge, as we've currently got two different lists, one in person and one in Bloodname. I was going to do it now, but wanted to cut down on the scope creep a bit. I've added a TODO message to remind myself.", "author": "Windchild292", "createdAt": "2020-03-01T21:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzNzMxMA=="}], "type": "inlineReview", "revised_code": {"commit": "192cc2f278116b48f4d7fa89ddf0b2764ad7ec39", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/personnel/Bloodname.java b/MekHQ/src/mekhq/campaign/personnel/Bloodname.java\nindex b882c20a5..59eb118ce 100644\n--- a/MekHQ/src/mekhq/campaign/personnel/Bloodname.java\n+++ b/MekHQ/src/mekhq/campaign/personnel/Bloodname.java\n\n@@ -50,225 +46,226 @@ import mekhq.MekHqXmlUtil;\n  *\n  */\n public class Bloodname implements Serializable {\n-\t/**\n-\t *\n-\t */\n-\tprivate static final long serialVersionUID = 3958964485520416824L;\n-\n-\tprivate static ArrayList<Bloodname> bloodnames;\n-\n-\tpublic static final int P_GENERAL = 0;\n-\tpublic static final int P_MECHWARRIOR = 1;\n-\tpublic static final int P_AEROSPACE = 2;\n-\tpublic static final int P_ELEMENTAL = 3;\n-\tpublic static final int P_PROTOMECH = 4;\n-\tpublic static final int P_NAVAL = 5;\n-\tpublic static final int P_NUM = 6;\n+    /**\n+     *\n+     */\n+    private static final long serialVersionUID = 3958964485520416824L;\n+\n+    private static ArrayList<Bloodname> bloodnames;\n+\n+    public static final int P_GENERAL = 0;\n+    public static final int P_MECHWARRIOR = 1;\n+    public static final int P_AEROSPACE = 2;\n+    public static final int P_ELEMENTAL = 3;\n+    public static final int P_PROTOMECH = 4;\n+    public static final int P_NAVAL = 5;\n+    public static final int P_NUM = 6;\n /*\n-\tpublic static final int P_NONE = 0;\n-\tpublic static final int P_GENERAL = 1;\n-\tpublic static final int P_MECHWARRIOR = 2;\n-\tpublic static final int P_AEROSPACE = 3;\n-\tpublic static final int P_ELEMENTAL = 4;\n-\tpublic static final int P_PROTOMECH = 5;\n-\tpublic static final int P_NAVAL = 6;\n-\tpublic static final int P_NUM = 7;\n+    // TODO : Windchild merge these two lists\n+    public static final int P_NONE = 0;\n+    public static final int P_GENERAL = 1;\n+    public static final int P_MECHWARRIOR = 2;\n+    public static final int P_AEROSPACE = 3;\n+    public static final int P_ELEMENTAL = 4;\n+    public static final int P_PROTOMECH = 5;\n+    public static final int P_NAVAL = 6;\n+    public static final int P_NUM = 7;\n */\n-\tpublic static final String[] phenotypeNames = {\n-\t\t\"General\", \"MechWarrior\", \"Aerospace Pilot\", \"Elemental\",\n-\t\t\"ProtoMech Pilot\", \"Naval Commander\"\n-\t};\n-\n-\tprivate String name;\n-\tprivate String founder;\n-\tprivate Clan origClan;\n-\tprivate boolean exclusive;\n-\tprivate boolean limited;\n-\tprivate int inactive;\n-\tprivate int abjured;\n-\tprivate int reactivated;\n-\tprivate int startDate;\n-\tprivate int phenotype;\n-\tArrayList<Clan> postReavingClans;\n-\tArrayList<NameAcquired> acquiringClans;\n-\tNameAcquired absorbed;\n-\n-\tpublic Bloodname() {\n-\t\tname = \"\";\n-\t\tfounder = \"\";\n-\t\texclusive = false;\n-\t\tlimited = false;\n-\t\tinactive = 0;\n-\t\tabjured = 0;\n-\t\treactivated = 0;\n-\t\tstartDate = 2807;\n-\t\tphenotype = P_GENERAL;\n-\t\tpostReavingClans = new ArrayList<>();\n-\t\tacquiringClans = new ArrayList<>();\n-\t\tabsorbed = null;\n-\t}\n-\n-\tpublic String getName() {\n-\t\treturn name;\n-\t}\n-\n-\tpublic String getFounder() {\n-\t\treturn founder;\n-\t}\n-\n-\tpublic String getOrigClan() {\n-\t\treturn origClan.getCode();\n-\t}\n-\n-\tpublic boolean isExclusive() {\n-\t\treturn exclusive;\n-\t}\n-\n-\tpublic boolean isLimited() {\n-\t\treturn limited;\n-\t}\n-\n-\tpublic boolean isInactive(int year) {\n-\t\treturn year < startDate || (inactive > 0 && inactive < year &&\n-\t\t\t\t!(reactivated > 0 && reactivated <= year));\n-\t}\n-\n-\tpublic boolean isAbjured(int year) {\n-\t\treturn ((abjured > 0) && (abjured < year));\n-\t}\n-\n-\tpublic int getPhenotype() {\n-\t\treturn phenotype;\n-\t}\n-\n-\tpublic ArrayList<Clan> getPostReavingClans() {\n-\t\treturn postReavingClans;\n-\t}\n-\n-\tpublic ArrayList<NameAcquired> getAcquiringClans() {\n-\t\treturn acquiringClans;\n-\t}\n-\n-\tpublic NameAcquired getAbsorbed() {\n-\t\treturn absorbed;\n-\t}\n-\n-\t/**\n-\t *\n-\t * @param warriorType A Person.PHENOTYPE_* constant\n-\t * @param year The current year of the campaign setting\n-\t * @return An adjustment to the frequency of this name for the phenotype.\n-\t *\n-\t * A warrior is three times as likely to have a Bloodname associated with the\n-\t * same phenotype as a general name (which is split among the three types).\n-\t * Elemental names are treated as general prior to 2870. The names that later\n-\t * became associated with ProtoMech pilots (identified in WoR) are assumed\n-\t * to have been poor performers and have a lower frequency even before the\n-\t * invention of the PM, though have a higher frequency for PM pilots than other\n-\t * aerospace names.\n-\t */\n-\tpublic int phenotypeMultiplier(int warriorType, int year) {\n-\t\tswitch (phenotype) {\n-\t\tcase P_MECHWARRIOR:\n-\t\t\treturn (warriorType == P_MECHWARRIOR) ? 3 : 0;\n-\t\tcase P_AEROSPACE:\n-\t\t\treturn (warriorType == P_AEROSPACE || warriorType == P_PROTOMECH) ? 3 : 0;\n-\t\tcase P_ELEMENTAL:\n-\t\t\tif (year < 2870) {\n-\t\t\t\treturn 1;\n-\t\t\t}\n-\t\t\treturn (warriorType == P_ELEMENTAL)?3:0;\n-\t\tcase P_PROTOMECH:\n-\t\t\tswitch (warriorType) {\n-\t\t\tcase P_PROTOMECH:\n-\t\t\t    return 9;\n-\t\t\tcase P_AEROSPACE:\n-\t\t\t    return 1;\n-\t\t\tdefault:\n-\t\t\t    return 0;\n-\t\t\t}\n-\t\tcase P_NAVAL:\n-\t\t\treturn (warriorType == P_NAVAL) ? 3 : 0;\n-\t\tcase P_GENERAL:\n-\t\tdefault:\n-\t\t    return 1;\n-\t\t}\n-\t}\n-\n-\tpublic static int determinePhenotype(Person person) {\n-\t    return 0; // TODO : Windchild Fix Me During Personnel Wave 2\n-    }\n-\n-\tpublic static Bloodname loadFromXml(Node node) {\n-\t\tBloodname retVal = new Bloodname();\n-\t\tNodeList nl = node.getChildNodes();\n-\t\tfor (int i = 0; i < nl.getLength(); i++) {\n-\t\t\tNode wn = nl.item(i);\n-\n-\t\t\tif (wn.getNodeName().equalsIgnoreCase(\"name\")) {\n-\t\t\t\tretVal.name = wn.getTextContent().trim();\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"founder\")) {\n-\t\t\t\tretVal.founder = wn.getTextContent().trim();\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"clan\")) {\n-\t\t\t\tretVal.origClan = Clan.getClan(wn.getTextContent().trim());\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"exclusive\")) {\n-\t\t\t\tretVal.exclusive = true;\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"reaved\")) {\n-\t\t\t\tretVal.inactive = Integer.parseInt(wn.getTextContent().trim());\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"dormant\")) {\n-\t\t\t\tretVal.inactive = Integer.parseInt(wn.getTextContent().trim()) + 10;\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"abjured\")) {\n-\t\t\t\tretVal.abjured = Integer.parseInt(wn.getTextContent().trim());\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"reactivated\")) {\n-\t\t\t\tretVal.reactivated = Integer.parseInt(wn.getTextContent().trim() + 20);\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"phenotype\")) {\n-\t\t\t\tswitch (wn.getTextContent().trim()) {\n-\t\t\t\tcase \"General\":\n-\t\t\t\t\tretVal.phenotype = P_GENERAL;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase \"MechWarrior\":\n-\t\t\t\t\tretVal.phenotype = P_MECHWARRIOR;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase \"Aerospace\":\n-\t\t\t\t\tretVal.phenotype = P_AEROSPACE;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase \"Elemental\":\n-\t\t\t\t\tretVal.phenotype = P_ELEMENTAL;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase \"ProtoMech\":\n-\t\t\t\t\tretVal.phenotype = P_PROTOMECH;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase \"Naval\":\n-\t\t\t\t\tretVal.phenotype = P_NAVAL;\n-\t\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t\tSystem.err.println(\"Unknown phenotype \" +\n-\t\t\t\t\t\t\twn.getTextContent() + \" in \" + retVal.name);\n-\t\t\t\t}\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"postReaving\")) {\n-\t\t\t\tString[] clans = wn.getTextContent().trim().split(\",\");\n-\t\t\t\tfor (String c : clans) {\n-\t\t\t\t\tretVal.postReavingClans.add(Clan.getClan(c));\n-\t\t\t\t}\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"acquired\")) {\n-\t\t\t\tretVal.acquiringClans.add(new NameAcquired(\n+    public static final String[] phenotypeNames = {\n+        \"General\", \"MechWarrior\", \"Aerospace Pilot\", \"Elemental\",\n+        \"ProtoMech Pilot\", \"Naval Commander\"\n+    };\n+\n+    private String name;\n+    private String founder;\n+    private Clan origClan;\n+    private boolean exclusive;\n+    private boolean limited;\n+    private int inactive;\n+    private int abjured;\n+    private int reactivated;\n+    private int startDate;\n+    private int phenotype;\n+    ArrayList<Clan> postReavingClans;\n+    ArrayList<NameAcquired> acquiringClans;\n+    NameAcquired absorbed;\n+\n+    public Bloodname() {\n+        name = \"\";\n+        founder = \"\";\n+        exclusive = false;\n+        limited = false;\n+        inactive = 0;\n+        abjured = 0;\n+        reactivated = 0;\n+        startDate = 2807;\n+        phenotype = P_GENERAL;\n+        postReavingClans = new ArrayList<>();\n+        acquiringClans = new ArrayList<>();\n+        absorbed = null;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getFounder() {\n+        return founder;\n+    }\n+\n+    public String getOrigClan() {\n+        return origClan.getCode();\n+    }\n+\n+    public boolean isExclusive() {\n+        return exclusive;\n+    }\n+\n+    public boolean isLimited() {\n+        return limited;\n+    }\n+\n+    public boolean isInactive(int year) {\n+        return year < startDate || (inactive > 0 && inactive < year &&\n+                !(reactivated > 0 && reactivated <= year));\n+    }\n+\n+    public boolean isAbjured(int year) {\n+        return ((abjured > 0) && (abjured < year));\n+    }\n+\n+    public int getPhenotype() {\n+        return phenotype;\n+    }\n+\n+    public ArrayList<Clan> getPostReavingClans() {\n+        return postReavingClans;\n+    }\n+\n+    public ArrayList<NameAcquired> getAcquiringClans() {\n+        return acquiringClans;\n+    }\n+\n+    public NameAcquired getAbsorbed() {\n+        return absorbed;\n+    }\n+\n+    /**\n+     *\n+     * @param warriorType A Person.PHENOTYPE_* constant\n+     * @param year The current year of the campaign setting\n+     * @return An adjustment to the frequency of this name for the phenotype.\n+     *\n+     * A warrior is three times as likely to have a Bloodname associated with the\n+     * same phenotype as a general name (which is split among the three types).\n+     * Elemental names are treated as general prior to 2870. The names that later\n+     * became associated with ProtoMech pilots (identified in WoR) are assumed\n+     * to have been poor performers and have a lower frequency even before the\n+     * invention of the PM, though have a higher frequency for PM pilots than other\n+     * aerospace names.\n+     */\n+    public int phenotypeMultiplier(int warriorType, int year) {\n+        switch (phenotype) {\n+            case P_MECHWARRIOR:\n+                return (warriorType == P_MECHWARRIOR) ? 3 : 0;\n+            case P_AEROSPACE:\n+                return (warriorType == P_AEROSPACE || warriorType == P_PROTOMECH) ? 3 : 0;\n+            case P_ELEMENTAL:\n+                if (year < 2870) {\n+                    return 1;\n+                }\n+                return (warriorType == P_ELEMENTAL) ? 3 : 0;\n+            case P_PROTOMECH:\n+                switch (warriorType) {\n+                    case P_PROTOMECH:\n+                        return 9;\n+                    case P_AEROSPACE:\n+                        return 1;\n+                    default:\n+                        return 0;\n+                }\n+            case P_NAVAL:\n+                return (warriorType == P_NAVAL) ? 3 : 0;\n+            case P_GENERAL:\n+            default:\n+                return 1;\n+        }\n+    }\n+\n+    public static int determinePhenotype(Person person) {\n+        return 0; // TODO : Windchild Fix Me During Personnel Wave 2\n+    }\n+\n+    public static Bloodname loadFromXml(Node node) {\n+        Bloodname retVal = new Bloodname();\n+        NodeList nl = node.getChildNodes();\n+        for (int i = 0; i < nl.getLength(); i++) {\n+            Node wn = nl.item(i);\n+\n+            if (wn.getNodeName().equalsIgnoreCase(\"name\")) {\n+                retVal.name = wn.getTextContent().trim();\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"founder\")) {\n+                retVal.founder = wn.getTextContent().trim();\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"clan\")) {\n+                retVal.origClan = Clan.getClan(wn.getTextContent().trim());\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"exclusive\")) {\n+                retVal.exclusive = true;\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"reaved\")) {\n+                retVal.inactive = Integer.parseInt(wn.getTextContent().trim());\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"dormant\")) {\n+                retVal.inactive = Integer.parseInt(wn.getTextContent().trim()) + 10;\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"abjured\")) {\n+                retVal.abjured = Integer.parseInt(wn.getTextContent().trim());\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"reactivated\")) {\n+                retVal.reactivated = Integer.parseInt(wn.getTextContent().trim() + 20);\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"phenotype\")) {\n+                switch (wn.getTextContent().trim()) {\n+                case \"General\":\n+                    retVal.phenotype = P_GENERAL;\n+                    break;\n+                case \"MechWarrior\":\n+                    retVal.phenotype = P_MECHWARRIOR;\n+                    break;\n+                case \"Aerospace\":\n+                    retVal.phenotype = P_AEROSPACE;\n+                    break;\n+                case \"Elemental\":\n+                    retVal.phenotype = P_ELEMENTAL;\n+                    break;\n+                case \"ProtoMech\":\n+                    retVal.phenotype = P_PROTOMECH;\n+                    break;\n+                case \"Naval\":\n+                    retVal.phenotype = P_NAVAL;\n+                    break;\n+                default:\n+                    System.err.println(\"Unknown phenotype \" +\n+                            wn.getTextContent() + \" in \" + retVal.name);\n+                }\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"postReaving\")) {\n+                String[] clans = wn.getTextContent().trim().split(\",\");\n+                for (String c : clans) {\n+                    retVal.postReavingClans.add(Clan.getClan(c));\n+                }\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"acquired\")) {\n+                retVal.acquiringClans.add(new NameAcquired(\n                         Integer.parseInt(wn.getAttributes().getNamedItem(\"date\").getTextContent()) + 10,\n                         wn.getTextContent().trim()));\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"shared\")) {\n-\t\t\t\tretVal.acquiringClans.add(new NameAcquired(\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"shared\")) {\n+                retVal.acquiringClans.add(new NameAcquired(\n                         Integer.parseInt(wn.getAttributes().getNamedItem(\"date\").getTextContent()),\n                         wn.getTextContent().trim()));\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"absorbed\")) {\n-\t\t\t\tretVal.absorbed = new NameAcquired(\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"absorbed\")) {\n+                retVal.absorbed = new NameAcquired(\n                         Integer.parseInt(wn.getAttributes().getNamedItem(\"date\").getTextContent()),\n                         wn.getTextContent().trim());\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"created\")) {\n-\t\t\t\tretVal.startDate = Integer.parseInt(wn.getTextContent().trim()) + 20;\n-\t\t\t}\n-\t\t}\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"created\")) {\n+                retVal.startDate = Integer.parseInt(wn.getTextContent().trim()) + 20;\n+            }\n+        }\n \n-\t\treturn retVal;\n-\t}\n+        return retVal;\n+    }\n \n     /**\n      * Determines a likely Bloodname based on Clan, person, and year.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzNzMzNQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386137335", "bodyText": "indentation is off", "author": "sixlettervariables", "createdAt": "2020-03-01T20:20:33Z", "path": "MekHQ/src/mekhq/campaign/personnel/Bloodname.java", "diffHunk": "@@ -161,28 +170,35 @@ public NameAcquired getAbsorbed() {\n \tpublic int phenotypeMultiplier(int warriorType, int year) {\n \t\tswitch (phenotype) {\n \t\tcase P_MECHWARRIOR:\n-\t\t\treturn (warriorType == P_MECHWARRIOR)?3:0;\n+\t\t\treturn (warriorType == P_MECHWARRIOR) ? 3 : 0;\n \t\tcase P_AEROSPACE:\n-\t\t\treturn (warriorType == P_AEROSPACE || warriorType == P_PROTOMECH)?3:0;\n+\t\t\treturn (warriorType == P_AEROSPACE || warriorType == P_PROTOMECH) ? 3 : 0;\n \t\tcase P_ELEMENTAL:\n \t\t\tif (year < 2870) {\n \t\t\t\treturn 1;\n \t\t\t}\n \t\t\treturn (warriorType == P_ELEMENTAL)?3:0;\n \t\tcase P_PROTOMECH:\n \t\t\tswitch (warriorType) {\n-\t\t\tcase P_PROTOMECH:return 9;\n-\t\t\tcase P_AEROSPACE:return 1;\n-\t\t\tdefault:return 0;\n+\t\t\tcase P_PROTOMECH:\n+\t\t\t    return 9;\n+\t\t\tcase P_AEROSPACE:\n+\t\t\t    return 1;\n+\t\t\tdefault:\n+\t\t\t    return 0;\n \t\t\t}\n \t\tcase P_NAVAL:\n-\t\t\treturn (warriorType == P_NAVAL)?3:0;\n+\t\t\treturn (warriorType == P_NAVAL) ? 3 : 0;\n \t\tcase P_GENERAL:\n \t\tdefault:\n-\t\t\treturn 1;\n+\t\t    return 1;\n \t\t}\n \t}\n \n+\tpublic static int determinePhenotype(Person person) {\n+\t    return 0; // TODO : Windchild Fix Me During Personnel Wave 2\n+    }", "originalCommit": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MjYzNA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386142634", "bodyText": "The whole file is tab spaced, fixing", "author": "Windchild292", "createdAt": "2020-03-01T21:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzNzMzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "192cc2f278116b48f4d7fa89ddf0b2764ad7ec39", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/personnel/Bloodname.java b/MekHQ/src/mekhq/campaign/personnel/Bloodname.java\nindex b882c20a5..59eb118ce 100644\n--- a/MekHQ/src/mekhq/campaign/personnel/Bloodname.java\n+++ b/MekHQ/src/mekhq/campaign/personnel/Bloodname.java\n\n@@ -50,225 +46,226 @@ import mekhq.MekHqXmlUtil;\n  *\n  */\n public class Bloodname implements Serializable {\n-\t/**\n-\t *\n-\t */\n-\tprivate static final long serialVersionUID = 3958964485520416824L;\n-\n-\tprivate static ArrayList<Bloodname> bloodnames;\n-\n-\tpublic static final int P_GENERAL = 0;\n-\tpublic static final int P_MECHWARRIOR = 1;\n-\tpublic static final int P_AEROSPACE = 2;\n-\tpublic static final int P_ELEMENTAL = 3;\n-\tpublic static final int P_PROTOMECH = 4;\n-\tpublic static final int P_NAVAL = 5;\n-\tpublic static final int P_NUM = 6;\n+    /**\n+     *\n+     */\n+    private static final long serialVersionUID = 3958964485520416824L;\n+\n+    private static ArrayList<Bloodname> bloodnames;\n+\n+    public static final int P_GENERAL = 0;\n+    public static final int P_MECHWARRIOR = 1;\n+    public static final int P_AEROSPACE = 2;\n+    public static final int P_ELEMENTAL = 3;\n+    public static final int P_PROTOMECH = 4;\n+    public static final int P_NAVAL = 5;\n+    public static final int P_NUM = 6;\n /*\n-\tpublic static final int P_NONE = 0;\n-\tpublic static final int P_GENERAL = 1;\n-\tpublic static final int P_MECHWARRIOR = 2;\n-\tpublic static final int P_AEROSPACE = 3;\n-\tpublic static final int P_ELEMENTAL = 4;\n-\tpublic static final int P_PROTOMECH = 5;\n-\tpublic static final int P_NAVAL = 6;\n-\tpublic static final int P_NUM = 7;\n+    // TODO : Windchild merge these two lists\n+    public static final int P_NONE = 0;\n+    public static final int P_GENERAL = 1;\n+    public static final int P_MECHWARRIOR = 2;\n+    public static final int P_AEROSPACE = 3;\n+    public static final int P_ELEMENTAL = 4;\n+    public static final int P_PROTOMECH = 5;\n+    public static final int P_NAVAL = 6;\n+    public static final int P_NUM = 7;\n */\n-\tpublic static final String[] phenotypeNames = {\n-\t\t\"General\", \"MechWarrior\", \"Aerospace Pilot\", \"Elemental\",\n-\t\t\"ProtoMech Pilot\", \"Naval Commander\"\n-\t};\n-\n-\tprivate String name;\n-\tprivate String founder;\n-\tprivate Clan origClan;\n-\tprivate boolean exclusive;\n-\tprivate boolean limited;\n-\tprivate int inactive;\n-\tprivate int abjured;\n-\tprivate int reactivated;\n-\tprivate int startDate;\n-\tprivate int phenotype;\n-\tArrayList<Clan> postReavingClans;\n-\tArrayList<NameAcquired> acquiringClans;\n-\tNameAcquired absorbed;\n-\n-\tpublic Bloodname() {\n-\t\tname = \"\";\n-\t\tfounder = \"\";\n-\t\texclusive = false;\n-\t\tlimited = false;\n-\t\tinactive = 0;\n-\t\tabjured = 0;\n-\t\treactivated = 0;\n-\t\tstartDate = 2807;\n-\t\tphenotype = P_GENERAL;\n-\t\tpostReavingClans = new ArrayList<>();\n-\t\tacquiringClans = new ArrayList<>();\n-\t\tabsorbed = null;\n-\t}\n-\n-\tpublic String getName() {\n-\t\treturn name;\n-\t}\n-\n-\tpublic String getFounder() {\n-\t\treturn founder;\n-\t}\n-\n-\tpublic String getOrigClan() {\n-\t\treturn origClan.getCode();\n-\t}\n-\n-\tpublic boolean isExclusive() {\n-\t\treturn exclusive;\n-\t}\n-\n-\tpublic boolean isLimited() {\n-\t\treturn limited;\n-\t}\n-\n-\tpublic boolean isInactive(int year) {\n-\t\treturn year < startDate || (inactive > 0 && inactive < year &&\n-\t\t\t\t!(reactivated > 0 && reactivated <= year));\n-\t}\n-\n-\tpublic boolean isAbjured(int year) {\n-\t\treturn ((abjured > 0) && (abjured < year));\n-\t}\n-\n-\tpublic int getPhenotype() {\n-\t\treturn phenotype;\n-\t}\n-\n-\tpublic ArrayList<Clan> getPostReavingClans() {\n-\t\treturn postReavingClans;\n-\t}\n-\n-\tpublic ArrayList<NameAcquired> getAcquiringClans() {\n-\t\treturn acquiringClans;\n-\t}\n-\n-\tpublic NameAcquired getAbsorbed() {\n-\t\treturn absorbed;\n-\t}\n-\n-\t/**\n-\t *\n-\t * @param warriorType A Person.PHENOTYPE_* constant\n-\t * @param year The current year of the campaign setting\n-\t * @return An adjustment to the frequency of this name for the phenotype.\n-\t *\n-\t * A warrior is three times as likely to have a Bloodname associated with the\n-\t * same phenotype as a general name (which is split among the three types).\n-\t * Elemental names are treated as general prior to 2870. The names that later\n-\t * became associated with ProtoMech pilots (identified in WoR) are assumed\n-\t * to have been poor performers and have a lower frequency even before the\n-\t * invention of the PM, though have a higher frequency for PM pilots than other\n-\t * aerospace names.\n-\t */\n-\tpublic int phenotypeMultiplier(int warriorType, int year) {\n-\t\tswitch (phenotype) {\n-\t\tcase P_MECHWARRIOR:\n-\t\t\treturn (warriorType == P_MECHWARRIOR) ? 3 : 0;\n-\t\tcase P_AEROSPACE:\n-\t\t\treturn (warriorType == P_AEROSPACE || warriorType == P_PROTOMECH) ? 3 : 0;\n-\t\tcase P_ELEMENTAL:\n-\t\t\tif (year < 2870) {\n-\t\t\t\treturn 1;\n-\t\t\t}\n-\t\t\treturn (warriorType == P_ELEMENTAL)?3:0;\n-\t\tcase P_PROTOMECH:\n-\t\t\tswitch (warriorType) {\n-\t\t\tcase P_PROTOMECH:\n-\t\t\t    return 9;\n-\t\t\tcase P_AEROSPACE:\n-\t\t\t    return 1;\n-\t\t\tdefault:\n-\t\t\t    return 0;\n-\t\t\t}\n-\t\tcase P_NAVAL:\n-\t\t\treturn (warriorType == P_NAVAL) ? 3 : 0;\n-\t\tcase P_GENERAL:\n-\t\tdefault:\n-\t\t    return 1;\n-\t\t}\n-\t}\n-\n-\tpublic static int determinePhenotype(Person person) {\n-\t    return 0; // TODO : Windchild Fix Me During Personnel Wave 2\n-    }\n-\n-\tpublic static Bloodname loadFromXml(Node node) {\n-\t\tBloodname retVal = new Bloodname();\n-\t\tNodeList nl = node.getChildNodes();\n-\t\tfor (int i = 0; i < nl.getLength(); i++) {\n-\t\t\tNode wn = nl.item(i);\n-\n-\t\t\tif (wn.getNodeName().equalsIgnoreCase(\"name\")) {\n-\t\t\t\tretVal.name = wn.getTextContent().trim();\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"founder\")) {\n-\t\t\t\tretVal.founder = wn.getTextContent().trim();\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"clan\")) {\n-\t\t\t\tretVal.origClan = Clan.getClan(wn.getTextContent().trim());\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"exclusive\")) {\n-\t\t\t\tretVal.exclusive = true;\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"reaved\")) {\n-\t\t\t\tretVal.inactive = Integer.parseInt(wn.getTextContent().trim());\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"dormant\")) {\n-\t\t\t\tretVal.inactive = Integer.parseInt(wn.getTextContent().trim()) + 10;\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"abjured\")) {\n-\t\t\t\tretVal.abjured = Integer.parseInt(wn.getTextContent().trim());\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"reactivated\")) {\n-\t\t\t\tretVal.reactivated = Integer.parseInt(wn.getTextContent().trim() + 20);\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"phenotype\")) {\n-\t\t\t\tswitch (wn.getTextContent().trim()) {\n-\t\t\t\tcase \"General\":\n-\t\t\t\t\tretVal.phenotype = P_GENERAL;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase \"MechWarrior\":\n-\t\t\t\t\tretVal.phenotype = P_MECHWARRIOR;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase \"Aerospace\":\n-\t\t\t\t\tretVal.phenotype = P_AEROSPACE;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase \"Elemental\":\n-\t\t\t\t\tretVal.phenotype = P_ELEMENTAL;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase \"ProtoMech\":\n-\t\t\t\t\tretVal.phenotype = P_PROTOMECH;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase \"Naval\":\n-\t\t\t\t\tretVal.phenotype = P_NAVAL;\n-\t\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t\tSystem.err.println(\"Unknown phenotype \" +\n-\t\t\t\t\t\t\twn.getTextContent() + \" in \" + retVal.name);\n-\t\t\t\t}\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"postReaving\")) {\n-\t\t\t\tString[] clans = wn.getTextContent().trim().split(\",\");\n-\t\t\t\tfor (String c : clans) {\n-\t\t\t\t\tretVal.postReavingClans.add(Clan.getClan(c));\n-\t\t\t\t}\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"acquired\")) {\n-\t\t\t\tretVal.acquiringClans.add(new NameAcquired(\n+    public static final String[] phenotypeNames = {\n+        \"General\", \"MechWarrior\", \"Aerospace Pilot\", \"Elemental\",\n+        \"ProtoMech Pilot\", \"Naval Commander\"\n+    };\n+\n+    private String name;\n+    private String founder;\n+    private Clan origClan;\n+    private boolean exclusive;\n+    private boolean limited;\n+    private int inactive;\n+    private int abjured;\n+    private int reactivated;\n+    private int startDate;\n+    private int phenotype;\n+    ArrayList<Clan> postReavingClans;\n+    ArrayList<NameAcquired> acquiringClans;\n+    NameAcquired absorbed;\n+\n+    public Bloodname() {\n+        name = \"\";\n+        founder = \"\";\n+        exclusive = false;\n+        limited = false;\n+        inactive = 0;\n+        abjured = 0;\n+        reactivated = 0;\n+        startDate = 2807;\n+        phenotype = P_GENERAL;\n+        postReavingClans = new ArrayList<>();\n+        acquiringClans = new ArrayList<>();\n+        absorbed = null;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getFounder() {\n+        return founder;\n+    }\n+\n+    public String getOrigClan() {\n+        return origClan.getCode();\n+    }\n+\n+    public boolean isExclusive() {\n+        return exclusive;\n+    }\n+\n+    public boolean isLimited() {\n+        return limited;\n+    }\n+\n+    public boolean isInactive(int year) {\n+        return year < startDate || (inactive > 0 && inactive < year &&\n+                !(reactivated > 0 && reactivated <= year));\n+    }\n+\n+    public boolean isAbjured(int year) {\n+        return ((abjured > 0) && (abjured < year));\n+    }\n+\n+    public int getPhenotype() {\n+        return phenotype;\n+    }\n+\n+    public ArrayList<Clan> getPostReavingClans() {\n+        return postReavingClans;\n+    }\n+\n+    public ArrayList<NameAcquired> getAcquiringClans() {\n+        return acquiringClans;\n+    }\n+\n+    public NameAcquired getAbsorbed() {\n+        return absorbed;\n+    }\n+\n+    /**\n+     *\n+     * @param warriorType A Person.PHENOTYPE_* constant\n+     * @param year The current year of the campaign setting\n+     * @return An adjustment to the frequency of this name for the phenotype.\n+     *\n+     * A warrior is three times as likely to have a Bloodname associated with the\n+     * same phenotype as a general name (which is split among the three types).\n+     * Elemental names are treated as general prior to 2870. The names that later\n+     * became associated with ProtoMech pilots (identified in WoR) are assumed\n+     * to have been poor performers and have a lower frequency even before the\n+     * invention of the PM, though have a higher frequency for PM pilots than other\n+     * aerospace names.\n+     */\n+    public int phenotypeMultiplier(int warriorType, int year) {\n+        switch (phenotype) {\n+            case P_MECHWARRIOR:\n+                return (warriorType == P_MECHWARRIOR) ? 3 : 0;\n+            case P_AEROSPACE:\n+                return (warriorType == P_AEROSPACE || warriorType == P_PROTOMECH) ? 3 : 0;\n+            case P_ELEMENTAL:\n+                if (year < 2870) {\n+                    return 1;\n+                }\n+                return (warriorType == P_ELEMENTAL) ? 3 : 0;\n+            case P_PROTOMECH:\n+                switch (warriorType) {\n+                    case P_PROTOMECH:\n+                        return 9;\n+                    case P_AEROSPACE:\n+                        return 1;\n+                    default:\n+                        return 0;\n+                }\n+            case P_NAVAL:\n+                return (warriorType == P_NAVAL) ? 3 : 0;\n+            case P_GENERAL:\n+            default:\n+                return 1;\n+        }\n+    }\n+\n+    public static int determinePhenotype(Person person) {\n+        return 0; // TODO : Windchild Fix Me During Personnel Wave 2\n+    }\n+\n+    public static Bloodname loadFromXml(Node node) {\n+        Bloodname retVal = new Bloodname();\n+        NodeList nl = node.getChildNodes();\n+        for (int i = 0; i < nl.getLength(); i++) {\n+            Node wn = nl.item(i);\n+\n+            if (wn.getNodeName().equalsIgnoreCase(\"name\")) {\n+                retVal.name = wn.getTextContent().trim();\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"founder\")) {\n+                retVal.founder = wn.getTextContent().trim();\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"clan\")) {\n+                retVal.origClan = Clan.getClan(wn.getTextContent().trim());\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"exclusive\")) {\n+                retVal.exclusive = true;\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"reaved\")) {\n+                retVal.inactive = Integer.parseInt(wn.getTextContent().trim());\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"dormant\")) {\n+                retVal.inactive = Integer.parseInt(wn.getTextContent().trim()) + 10;\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"abjured\")) {\n+                retVal.abjured = Integer.parseInt(wn.getTextContent().trim());\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"reactivated\")) {\n+                retVal.reactivated = Integer.parseInt(wn.getTextContent().trim() + 20);\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"phenotype\")) {\n+                switch (wn.getTextContent().trim()) {\n+                case \"General\":\n+                    retVal.phenotype = P_GENERAL;\n+                    break;\n+                case \"MechWarrior\":\n+                    retVal.phenotype = P_MECHWARRIOR;\n+                    break;\n+                case \"Aerospace\":\n+                    retVal.phenotype = P_AEROSPACE;\n+                    break;\n+                case \"Elemental\":\n+                    retVal.phenotype = P_ELEMENTAL;\n+                    break;\n+                case \"ProtoMech\":\n+                    retVal.phenotype = P_PROTOMECH;\n+                    break;\n+                case \"Naval\":\n+                    retVal.phenotype = P_NAVAL;\n+                    break;\n+                default:\n+                    System.err.println(\"Unknown phenotype \" +\n+                            wn.getTextContent() + \" in \" + retVal.name);\n+                }\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"postReaving\")) {\n+                String[] clans = wn.getTextContent().trim().split(\",\");\n+                for (String c : clans) {\n+                    retVal.postReavingClans.add(Clan.getClan(c));\n+                }\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"acquired\")) {\n+                retVal.acquiringClans.add(new NameAcquired(\n                         Integer.parseInt(wn.getAttributes().getNamedItem(\"date\").getTextContent()) + 10,\n                         wn.getTextContent().trim()));\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"shared\")) {\n-\t\t\t\tretVal.acquiringClans.add(new NameAcquired(\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"shared\")) {\n+                retVal.acquiringClans.add(new NameAcquired(\n                         Integer.parseInt(wn.getAttributes().getNamedItem(\"date\").getTextContent()),\n                         wn.getTextContent().trim()));\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"absorbed\")) {\n-\t\t\t\tretVal.absorbed = new NameAcquired(\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"absorbed\")) {\n+                retVal.absorbed = new NameAcquired(\n                         Integer.parseInt(wn.getAttributes().getNamedItem(\"date\").getTextContent()),\n                         wn.getTextContent().trim());\n-\t\t\t} else if (wn.getNodeName().equalsIgnoreCase(\"created\")) {\n-\t\t\t\tretVal.startDate = Integer.parseInt(wn.getTextContent().trim()) + 20;\n-\t\t\t}\n-\t\t}\n+            } else if (wn.getNodeName().equalsIgnoreCase(\"created\")) {\n+                retVal.startDate = Integer.parseInt(wn.getTextContent().trim()) + 20;\n+            }\n+        }\n \n-\t\treturn retVal;\n-\t}\n+        return retVal;\n+    }\n \n     /**\n      * Determines a likely Bloodname based on Clan, person, and year.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzNzY5MA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386137690", "bodyText": "Looks like mixed tabs/spaces in this file", "author": "sixlettervariables", "createdAt": "2020-03-01T20:25:33Z", "path": "MekHQ/src/mekhq/service/MassRepairService.java", "diffHunk": "@@ -805,11 +805,7 @@ private static MassRepairPartAction repairPart(CampaignGUI campaignGUI, IPartWor\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \n-\t\t\t\tif (configuredOptions.isOptimizeToCompleteToday()) {\n-\t\t\t\t\tisSameDayTech = false;\n-\t\t\t\t} else {\n-\t\t\t\t\tisSameDayTech = true;\n-\t\t\t\t}\n+                isSameDayTech = !configuredOptions.isOptimizeToCompleteToday();", "originalCommit": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0Mjg5Nw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386142897", "bodyText": "Yep, pretty much the whole file was tab spaced. Fixed", "author": "Windchild292", "createdAt": "2020-03-01T21:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzNzY5MA=="}], "type": "inlineReview", "revised_code": {"commit": "3bfcbea0f0bb9989d393c05b4609fb74a0c60ddd", "chunk": "diff --git a/MekHQ/src/mekhq/service/MassRepairService.java b/MekHQ/src/mekhq/service/MassRepairService.java\nindex 036b24a4f..88ef1df3a 100644\n--- a/MekHQ/src/mekhq/service/MassRepairService.java\n+++ b/MekHQ/src/mekhq/service/MassRepairService.java\n\n@@ -38,1503 +38,1503 @@ import mekhq.gui.dialog.MassRepairSalvageDialog;\n import mekhq.gui.sorter.UnitStatusSorter;\n \n public class MassRepairService {\n-\tprivate MassRepairService() {\n-\t}\n+    private MassRepairService() {\n+    }\n \n-\tpublic static boolean isValidMRMSUnit(Unit unit) {\n-\t\tif (unit.isSelfCrewed() || !unit.isAvailable()) {\n-\t\t\treturn false;\n-\t\t}\n+    public static boolean isValidMRMSUnit(Unit unit) {\n+        if (unit.isSelfCrewed() || !unit.isAvailable()) {\n+            return false;\n+        }\n \n-\t\tif (unit.isDeployed()) {\n-\t\t\treturn false;\n-\t\t}\n+        if (unit.isDeployed()) {\n+            return false;\n+        }\n \n-\t\treturn (unit.getEntity() instanceof Tank) || (unit.getEntity() instanceof Aero)\n-\t\t\t\t|| (unit.getEntity() instanceof Mech) || (unit.getEntity() instanceof BattleArmor);\n-\t}\n+        return (unit.getEntity() instanceof Tank) || (unit.getEntity() instanceof Aero)\n+                || (unit.getEntity() instanceof Mech) || (unit.getEntity() instanceof BattleArmor);\n+    }\n \n-\tprivate static List<MassRepairOption> createActiveMROsFromConfiguration(CampaignGUI campaignGUI) {\n-\t\tList<MassRepairOption> activeMROs = new ArrayList<MassRepairOption>();\n-\t\tList<MassRepairOption> mroList = campaignGUI.getCampaign().getCampaignOptions().getMassRepairOptions();\n+    private static List<MassRepairOption> createActiveMROsFromConfiguration(CampaignGUI campaignGUI) {\n+        List<MassRepairOption> activeMROs = new ArrayList<>();\n+        List<MassRepairOption> mroList = campaignGUI.getCampaign().getCampaignOptions().getMassRepairOptions();\n \n-\t\tif (null != mroList) {\n-\t\t\tfor (int i = 0; i < mroList.size(); i++) {\n-\t\t\t\tMassRepairOption mro = mroList.get(i);\n+        if (null != mroList) {\n+            for (int i = 0; i < mroList.size(); i++) {\n+                MassRepairOption mro = mroList.get(i);\n \n-\t\t\t\tif (mro.isActive()) {\n-\t\t\t\t\tactiveMROs.add(mro);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+                if (mro.isActive()) {\n+                    activeMROs.add(mro);\n+                }\n+            }\n+        }\n \n-\t\treturn activeMROs;\n-\t}\n+        return activeMROs;\n+    }\n \n-\tpublic static MassRepairPartSet performWarehouseMassRepair(List<IPartWork> selectedParts,\n-\t\t\tList<MassRepairOption> mroList, MassRepairConfiguredOptions configuredOptions, CampaignGUI campaignGUI) {\n-\t\tCampaign campaign = campaignGUI.getCampaign();\n+    public static MassRepairPartSet performWarehouseMassRepair(List<IPartWork> selectedParts,\n+            List<MassRepairOption> mroList, MassRepairConfiguredOptions configuredOptions, CampaignGUI campaignGUI) {\n+        Campaign campaign = campaignGUI.getCampaign();\n \n-\t\tcampaign.addReport(\"Beginning mass warehouse repair.\");\n+        campaign.addReport(\"Beginning mass warehouse repair.\");\n \n-\t\tList<Person> techs = campaign.getTechs(true);\n-\n-\t\tMassRepairPartSet partSet = new MassRepairPartSet();\n-\n-\t\tif (techs.isEmpty()) {\n-\t\t\tcampaign.addReport(\"No available techs to repairs parts.\");\n-\t\t} else {\n-\t\t\tMap<Integer, MassRepairOption> mroByTypeMap = new HashMap<Integer, MassRepairOption>();\n-\n-\t\t\tfor (int i = 0; i < mroList.size(); i++) {\n-\t\t\t\tmroByTypeMap.put(mroList.get(i).getType(), mroList.get(i));\n-\t\t\t}\n-\n-\t\t\t/*\n-\t\t\t * Filter our parts list to only those that aren't being worked on\n-\t\t\t * or those that meet our criteria as defined in the campaign\n-\t\t\t * configurations\n-\t\t\t */\n-\t\t\tList<IPartWork> parts = filterParts(selectedParts, mroByTypeMap, techs, campaign);\n-\n-\t\t\tif (!parts.isEmpty()) {\n-\t\t\t\tfor (IPartWork partWork : parts) {\n-\t\t\t\t\tPart part = (Part) partWork;\n-\t\t\t\t\tpart.resetModeToNormal();\n-\n-\t\t\t\t\tList<Person> validTechs = filterTechs(partWork, techs, mroByTypeMap, true, campaignGUI);\n-\n-\t\t\t\t\tif (validTechs.isEmpty()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tint originalQuantity = part.getQuantity();\n-\n-\t\t\t\t\tfor (int i = 0; i < originalQuantity; i++) {\n-\t\t\t\t\t\tpartSet.addPartAction(\n-\t\t\t\t\t\t\t\trepairPart(campaignGUI, part, null, validTechs, mroByTypeMap, configuredOptions, true));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn partSet;\n-\t}\n-\n-\tpublic static void performSingleUnitMassRepairOrSalvage(CampaignGUI campaignGUI, Unit unit) {\n-\t\tCampaignOptions options = campaignGUI.getCampaign().getCampaignOptions();\n-\t\tList<MassRepairOption> activeMROs = createActiveMROsFromConfiguration(campaignGUI);\n-\n-\t\tMassRepairConfiguredOptions configuredOptions = new MassRepairConfiguredOptions();\n-\t\tconfiguredOptions.setup(options);\n-\n-\t\tMassRepairUnitAction unitAction = performUnitMassRepairOrSalvage(campaignGUI, unit, unit.isSalvage(),\n-\t\t\t\tactiveMROs, configuredOptions);\n-\n-\t\tString actionDescriptor = unit.isSalvage() ? \"Salvage\" : \"Repair\";\n-\t\tString msg = String.format(\"<font color='green'>Mass %s complete on %s.</font>\", actionDescriptor,\n-\t\t\t\tunit.getName());\n+        List<Person> techs = campaign.getTechs(true);\n+\n+        MassRepairPartSet partSet = new MassRepairPartSet();\n+\n+        if (techs.isEmpty()) {\n+            campaign.addReport(\"No available techs to repairs parts.\");\n+        } else {\n+            Map<Integer, MassRepairOption> mroByTypeMap = new HashMap<Integer, MassRepairOption>();\n+\n+            for (int i = 0; i < mroList.size(); i++) {\n+                mroByTypeMap.put(mroList.get(i).getType(), mroList.get(i));\n+            }\n+\n+            /*\n+             * Filter our parts list to only those that aren't being worked on\n+             * or those that meet our criteria as defined in the campaign\n+             * configurations\n+             */\n+            List<IPartWork> parts = filterParts(selectedParts, mroByTypeMap, techs, campaign);\n+\n+            if (!parts.isEmpty()) {\n+                for (IPartWork partWork : parts) {\n+                    Part part = (Part) partWork;\n+                    part.resetModeToNormal();\n+\n+                    List<Person> validTechs = filterTechs(partWork, techs, mroByTypeMap, true, campaignGUI);\n+\n+                    if (validTechs.isEmpty()) {\n+                        continue;\n+                    }\n+\n+                    int originalQuantity = part.getQuantity();\n+\n+                    for (int i = 0; i < originalQuantity; i++) {\n+                        partSet.addPartAction(\n+                                repairPart(campaignGUI, part, null, validTechs, mroByTypeMap, configuredOptions, true));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return partSet;\n+    }\n+\n+    public static void performSingleUnitMassRepairOrSalvage(CampaignGUI campaignGUI, Unit unit) {\n+        CampaignOptions options = campaignGUI.getCampaign().getCampaignOptions();\n+        List<MassRepairOption> activeMROs = createActiveMROsFromConfiguration(campaignGUI);\n+\n+        MassRepairConfiguredOptions configuredOptions = new MassRepairConfiguredOptions();\n+        configuredOptions.setup(options);\n+\n+        MassRepairUnitAction unitAction = performUnitMassRepairOrSalvage(campaignGUI, unit, unit.isSalvage(),\n+                activeMROs, configuredOptions);\n+\n+        String actionDescriptor = unit.isSalvage() ? \"Salvage\" : \"Repair\";\n+        String msg = String.format(\"<font color='green'>Mass %s complete on %s.</font>\", actionDescriptor,\n+                unit.getName());\n \n-\t\tswitch (unitAction.getStatus()) {\n-\t\tcase ACTIONS_PERFORMED:\n-\t\t\tint count = unitAction.getPartSet().countRepairs();\n-\t\t\tmsg += String.format(\" There were %s action%s performed.\", count, (count == 1 ? \"\" : \"s\"));\n-\t\t\tbreak;\n+        switch (unitAction.getStatus()) {\n+        case ACTIONS_PERFORMED:\n+            int count = unitAction.getPartSet().countRepairs();\n+            msg += String.format(\" There were %s action%s performed.\", count, (count == 1 ? \"\" : \"s\"));\n+            break;\n \n-\t\tcase NO_PARTS:\n-\t\t\tmsg += \" No actions were performed because there are currently no valid parts.\";\n-\t\t\tbreak;\n+        case NO_PARTS:\n+            msg += \" No actions were performed because there are currently no valid parts.\";\n+            break;\n \n-\t\tcase ALL_PARTS_IN_PROCESS:\n-\t\t\tmsg += \" No actions were performed because all parts are being worked on.\";\n-\t\t\tbreak;\n+        case ALL_PARTS_IN_PROCESS:\n+            msg += \" No actions were performed because all parts are being worked on.\";\n+            break;\n \n-\t\tcase NO_TECHS:\n-\t\t\tmsg += \" No actions were performed because there are currently no valid techs.\";\n-\t\t\tbreak;\n-\n-\t\tcase UNFIXABLE_LIMB:\n-\t\t\tmsg += \" No actions were performed because there is at least one unfixable limb and configured settings do not allow location repairs.\";\n-\t\t\tbreak;\n+        case NO_TECHS:\n+            msg += \" No actions were performed because there are currently no valid techs.\";\n+            break;\n+\n+        case UNFIXABLE_LIMB:\n+            msg += \" No actions were performed because there is at least one unfixable limb and configured settings do not allow location repairs.\";\n+            break;\n \n-\t\tcase NO_ACTIONS:\n-\t\tdefault:\n-\t\t\tbreak;\n-\t\t}\n+        case NO_ACTIONS:\n+        default:\n+            break;\n+        }\n \n-\t\tcampaignGUI.getCampaign().addReport(msg);\n-\n-\t\tList<Person> techs = campaignGUI.getCampaign().getTechs(false);\n+        campaignGUI.getCampaign().addReport(msg);\n+\n+        List<Person> techs = campaignGUI.getCampaign().getTechs(false);\n \n-\t\tif (!techs.isEmpty()) {\n-\t\t\tList<IPartWork> parts = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), true);\n-\t\t\tparts = filterParts(parts, null, techs, campaignGUI.getCampaign());\n+        if (!techs.isEmpty()) {\n+            List<IPartWork> parts = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), true);\n+            parts = filterParts(parts, null, techs, campaignGUI.getCampaign());\n \n-\t\t\tif (!parts.isEmpty()) {\n-\t\t\t\tif (parts.size() == 1) {\n-\t\t\t\t\tcampaignGUI.getCampaign()\n-\t\t\t\t\t\t\t.addReport(\"<font color='red'>There in still 1 part that in not being worked on.</font>\");\n-\t\t\t\t} else {\n-\t\t\t\t\tcampaignGUI.getCampaign()\n-\t\t\t\t\t\t\t.addReport(String.format(\n-\t\t\t\t\t\t\t\t\t\"<font color='red'>There are still %s parts that are not being worked on.</font>\",\n-\t\t\t\t\t\t\t\t\tparts.size()));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tJOptionPane.showMessageDialog(campaignGUI.getFrame(),\n-\t\t\t\tString.format(\"Mass %s complete on %s.\", actionDescriptor, unit.getName()), \"Complete\",\n-\t\t\t\tJOptionPane.INFORMATION_MESSAGE);\n-\t}\n-\n-\tpublic static void massRepairSalvageAllUnits(CampaignGUI campaignGUI) {\n-\t\tList<Unit> units = new ArrayList<Unit>();\n-\n-\t\tfor (Unit unit : campaignGUI.getCampaign().getServiceableUnits()) {\n-\t\t\tif (!isValidMRMSUnit(unit)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tunits.add(unit);\n-\t\t}\n-\n-\t\t// Sort the list status fixing the least damaged first\n-\t\tCollections.sort(units, new Comparator<Unit>() {\n-\t\t\t@Override\n-\t\t\tpublic int compare(Unit o1, Unit o2) {\n-\t\t\t\tint damageIdx1 = UnitStatusSorter.getDamageStateIndex(Unit.getDamageStateName(o1.getDamageState()));\n-\t\t\t\tint damageIdx2 = UnitStatusSorter.getDamageStateIndex(Unit.getDamageStateName(o2.getDamageState()));\n-\n-\t\t\t\tif (damageIdx2 == damageIdx1) {\n-\t\t\t\t\treturn 0;\n-\t\t\t\t} else if (damageIdx2 < damageIdx1) {\n-\t\t\t\t\treturn -1;\n-\t\t\t\t}\n-\n-\t\t\t\treturn 1;\n-\t\t\t}\n-\t\t});\n-\n-\t\tList<MassRepairOption> activeMROs = createActiveMROsFromConfiguration(campaignGUI);\n-\n-\t\tmassRepairSalvageUnits(campaignGUI, units, activeMROs);\n-\t}\n-\n-\tpublic static void massRepairSalvageUnits(CampaignGUI campaignGUI, List<Unit> units, List<MassRepairOption> activeMROs) {\n-\t\tCampaignOptions options = campaignGUI.getCampaign().getCampaignOptions();\n-\n-\t\tMap<MassRepairUnitAction.STATUS, List<MassRepairUnitAction>> unitActionsByStatus = new HashMap<MassRepairUnitAction.STATUS, List<MassRepairUnitAction>>();\n-\n-\t\tMassRepairConfiguredOptions configuredOptions = new MassRepairConfiguredOptions();\n-\t\tconfiguredOptions.setup(options);\n-\n-\t\tfor (Unit unit : units) {\n-\t\t\tMassRepairUnitAction unitAction = performUnitMassRepairOrSalvage(campaignGUI, unit, unit.isSalvage(),\n-\t\t\t\t\tactiveMROs, configuredOptions);\n-\n-\t\t\tList<MassRepairUnitAction> list = unitActionsByStatus.get(unitAction.getStatus());\n-\n-\t\t\tif (null == list) {\n-\t\t\t\tlist = new ArrayList<MassRepairUnitAction>();\n-\t\t\t\tunitActionsByStatus.put(unitAction.getStatus(), list);\n-\t\t\t}\n-\n-\t\t\tlist.add(unitAction);\n-\t\t}\n-\n-\t\tif (unitActionsByStatus.isEmpty()) {\n-\t\t\tcampaignGUI.getCampaign().addReport(\"Mass Repair/Salvage complete. There were no units worked on.\");\n-\t\t} else {\n-\t\t\tint totalCount = 0;\n-\t\t\tint actionsPerformed = 0;\n-\n-\t\t\tfor (MassRepairUnitAction.STATUS key : unitActionsByStatus.keySet()) {\n-\t\t\t\tif (key == MassRepairUnitAction.STATUS.ALL_PARTS_IN_PROCESS) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\n-\t\t\t\ttotalCount += unitActionsByStatus.get(key).size();\n-\t\t\t}\n-\n-\t\t\tif (unitActionsByStatus.containsKey(MassRepairUnitAction.STATUS.ACTIONS_PERFORMED)) {\n-\t\t\t\tList<MassRepairUnitAction> unitsByStatus = unitActionsByStatus\n-\t\t\t\t\t\t.get(MassRepairUnitAction.STATUS.ACTIONS_PERFORMED);\n-\n-\t\t\t\tfor (MassRepairUnitAction mrua : unitsByStatus) {\n-\t\t\t\t\tactionsPerformed += mrua.getPartSet().countRepairs();\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tStringBuilder sb = new StringBuilder(\n-\t\t\t\t\tString.format(\"<font color='green'>Mass Repair/Salvage complete for %s units.</font>\", totalCount));\n-\n-\t\t\tif (actionsPerformed > 0) {\n-\t\t\t\tsb.append(String.format(\" %s repair/salvage action%s performed.\", actionsPerformed,\n-\t\t\t\t\t\t(actionsPerformed == 1 ? \"\" : \"s\")));\n-\t\t\t}\n-\n-\t\t\tsb.append(generateUnitRepairSummary(\"<br/>- %s unit%s had repairs/parts salvaged.\", unitActionsByStatus,\n-\t\t\t\t\tMassRepairUnitAction.STATUS.ACTIONS_PERFORMED));\n-\t\t\tsb.append(generateUnitRepairSummary(\n-\t\t\t\t\t\"<br/>- %s unit%s had no actions performed because there were no valid parts.\", unitActionsByStatus,\n-\t\t\t\t\tMassRepairUnitAction.STATUS.NO_PARTS));\n-\t\t\tsb.append(generateUnitRepairSummary(\n-\t\t\t\t\t\"<br/>- %s unit%s had no actions performed because there were no valid techs.\", unitActionsByStatus,\n-\t\t\t\t\tMassRepairUnitAction.STATUS.NO_TECHS));\n-\t\t\tsb.append(generateUnitRepairSummary(\n-\t\t\t\t\t\"<br/>- %s unit%s had no actions performed because there were unfixable limbs and configured settings do not allow location repairs.\",\n-\t\t\t\t\tunitActionsByStatus, MassRepairUnitAction.STATUS.UNFIXABLE_LIMB));\n-\n-\t\t\tcampaignGUI.getCampaign().addReport(sb.toString());\n-\t\t}\n-\n-\t\tgenerateCampaignLogForUnitStatus(unitActionsByStatus, MassRepairUnitAction.STATUS.NO_PARTS,\n-\t\t\t\t\"Units with no valid parts:\", campaignGUI);\n-\t\tgenerateCampaignLogForUnitStatus(unitActionsByStatus, MassRepairUnitAction.STATUS.NO_TECHS,\n-\t\t\t\t\"Units with no valid techs:\", campaignGUI);\n-\t\tgenerateCampaignLogForUnitStatus(unitActionsByStatus, MassRepairUnitAction.STATUS.UNFIXABLE_LIMB,\n-\t\t\t\t\"Units with unfixable limbs:\", campaignGUI);\n-\n-\t\tif (!unitActionsByStatus.isEmpty()) {\n-\t\t\tList<Person> techs = campaignGUI.getCampaign().getTechs(false);\n-\n-\t\t\tif (!techs.isEmpty()) {\n-\t\t\t\tint count = 0;\n-\t\t\t\tint unitCount = 0;\n-\n-\t\t\t\tfor (List<MassRepairUnitAction> list : unitActionsByStatus.values()) {\n-\t\t\t\t\tfor (MassRepairUnitAction mrua : list) {\n-\t\t\t\t\t\tList<IPartWork> parts = campaignGUI.getCampaign()\n-\t\t\t\t\t\t\t\t.getPartsNeedingServiceFor(mrua.getUnit().getId(), true);\n-\t\t\t\t\t\tint tempCount = filterParts(parts, null, techs, campaignGUI.getCampaign()).size();\n-\n-\t\t\t\t\t\tif (tempCount > 0) {\n-\t\t\t\t\t\t\tunitCount++;\n-\t\t\t\t\t\t\tcount += tempCount;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (count > 0) {\n-\t\t\t\t\tif (count == 1) {\n-\t\t\t\t\t\tcampaignGUI.getCampaign().addReport(\n-\t\t\t\t\t\t\t\t\"<font color='red'>There in still 1 part that in not being worked on.</font>\");\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tcampaignGUI.getCampaign()\n-\t\t\t\t\t\t\t\t.addReport(String.format(\n-\t\t\t\t\t\t\t\t\t\t\"<font color='red'>There are still %s parts that are not being worked on %s unit%s.</font>\",\n-\t\t\t\t\t\t\t\t\t\tcount, unitCount, (unitCount == 1 ? \"\" : \"s\")));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Remove any units which after mass repair/salvage are no longer\n-\t\t// useable.\n-\t\tfor (Unit u : units) {\n-\t\t\tif (!u.isRepairable() && !u.hasSalvageableParts()) {\n-\t\t\t\tcampaignGUI.getCampaign().removeUnit(u.getId());\n-\t\t\t}\n-\t\t}\n-\n-\t\tJOptionPane.showMessageDialog(campaignGUI.getFrame(), \"Mass Repair/Salvage complete.\", \"Complete\",\n-\t\t\t\tJOptionPane.INFORMATION_MESSAGE);\n-\t}\n-\n-\tprivate static String generateUnitRepairSummary(String baseDescription,\n-\t\t\tMap<MassRepairUnitAction.STATUS, List<MassRepairUnitAction>> unitActionsByStatus,\n-\t\t\tMassRepairUnitAction.STATUS status) {\n-\n-\t\tif (!unitActionsByStatus.containsKey(status)) {\n-\t\t\treturn \"\";\n-\t\t}\n-\n-\t\tint count = unitActionsByStatus.get(status).size();\n-\n-\t\treturn String.format(baseDescription, count, count == 1 ? \"\" : \"s\");\n-\t}\n-\n-\tprivate static void generateCampaignLogForUnitStatus(\n-\t\t\tMap<MassRepairUnitAction.STATUS, List<MassRepairUnitAction>> unitActionsByStatus,\n-\t\t\tMassRepairUnitAction.STATUS status, String statusDesc, CampaignGUI campaignGUI) {\n-\t\tif (!unitActionsByStatus.containsKey(status) || unitActionsByStatus.get(status).isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tStringBuilder sbMsg = new StringBuilder();\n-\t\tsbMsg.append(statusDesc);\n-\n-\t\tList<MassRepairUnitAction> unitsByStatus = unitActionsByStatus.get(status);\n-\n-\t\tfor (MassRepairUnitAction mrua : unitsByStatus) {\n-\t\t\tsbMsg.append(\"<br/>- \" + mrua.getUnit().getName());\n-\t\t}\n-\n-\t\tcampaignGUI.getCampaign().addReport(sbMsg.toString());\n-\t}\n-\n-\tpublic static MassRepairUnitAction performUnitMassRepairOrSalvage(CampaignGUI campaignGUI, Unit unit,\n-\t\t\tboolean isSalvage, List<MassRepairOption> mroList, MassRepairConfiguredOptions configuredOptions) {\n-\t\tCampaign campaign = campaignGUI.getCampaign();\n-\n-\t\tList<Person> techs = campaign.getTechs(true);\n-\n-\t\tif (techs.isEmpty()) {\n-\t\t\treturn new MassRepairUnitAction(unit, isSalvage, MassRepairUnitAction.STATUS.NO_TECHS);\n-\t\t}\n-\n-\t\tMassRepairUnitAction unitAction = new MassRepairUnitAction(unit, isSalvage,\n-\t\t\t\tMassRepairUnitAction.STATUS.NO_ACTIONS);\n-\n-\t\t// Filter our tech list to only our techs that can work on this unit\n-\t\tfor (int i = techs.size() - 1; i >= 0; i--) {\n-\t\t\tPerson tech = techs.get(i);\n-\n-\t\t\tif (!tech.canTech(unit.getEntity())) {\n-\t\t\t\ttechs.remove(i);\n-\t\t\t}\n-\t\t}\n-\n-\t\tMap<Integer, MassRepairOption> mroByTypeMap = new HashMap<Integer, MassRepairOption>();\n-\n-\t\tfor (int i = 0; i < mroList.size(); i++) {\n-\t\t\tmroByTypeMap.put(mroList.get(i).getType(), mroList.get(i));\n-\t\t}\n-\n-\t\t/*\n-\t\t * Possibly call this multiple times. Sometimes some actions are first\n-\t\t * dependent upon others being finished, also failed actions can be\n-\t\t * performed again by a tech with a higher skill.\n-\t\t */\n-\t\tboolean performMoreRepairs = true;\n-\n-\t\tlong time = System.nanoTime();\n-\n-\t\twhile (performMoreRepairs) {\n-\t\t\tMassRepairUnitAction currentUnitAction = performUnitMassTechAction(campaignGUI, unit, techs, mroByTypeMap,\n-\t\t\t\t\tisSalvage, configuredOptions);\n-\n-\t\t\tperformMoreRepairs = currentUnitAction.getPartSet().isHasRepairs();\n-\t\t\tunitAction.merge(currentUnitAction);\n-\n-\t\t\tif (unitAction.isStatusNoActions()) {\n-\t\t\t\tunitAction.setStatus(currentUnitAction.getStatus());\n-\t\t\t}\n-\t\t}\n-\n-\t\tdebugLog(\"Finished fixing %s in %s ns\", \"performUnitMassRepairOrSalvage\", unit.getName(), System.nanoTime() - time);\n-\n-\t\treturn unitAction;\n-\t}\n-\n-\tprivate static MassRepairUnitAction performUnitMassTechAction(CampaignGUI campaignGUI, Unit unit,\n-\t\t\tList<Person> techs, Map<Integer, MassRepairOption> mroByTypeMap, boolean salvaging,\n-\t\t\tMassRepairConfiguredOptions configuredOptions) {\n-\t\tCampaign campaign = campaignGUI.getCampaign();\n-\n-\t\tList<IPartWork> parts = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), true);\n-\n-\t\tif (parts.isEmpty()) {\n-\t\t\tparts = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), false);\n-\n-\t\t\tif (!parts.isEmpty()) {\n-\t\t\t\treturn new MassRepairUnitAction(unit, salvaging, MassRepairUnitAction.STATUS.ALL_PARTS_IN_PROCESS);\n-\t\t\t}\n-\n-\t\t\treturn new MassRepairUnitAction(unit, salvaging, MassRepairUnitAction.STATUS.NO_PARTS);\n-\t\t}\n-\n-\t\tfor (IPartWork partWork : parts) {\n-\t\t\tif (partWork instanceof Part) {\n-\t\t\t\tPart part = (Part) partWork;\n-\t\t\t\tpart.resetModeToNormal();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/*\n-\t\t * If we're performing an action on a unit and we allow auto-scrapping\n-\t\t * of parts that can't be fixed by an elite tech, let's first get rid of\n-\t\t * those parts and start with a cleaner slate\n-\t\t */\n-\t\tif (configuredOptions.isScrapImpossible()) {\n-\t\t\tboolean refreshParts = false;\n-\n-\t\t\tfor (IPartWork partWork : parts) {\n-\t\t\t\tif (partWork instanceof Part && partWork.getSkillMin() > SkillType.EXP_ELITE) {\n-\t\t\t\t\tcampaign.addReport(((Part) partWork).scrap());\n-\t\t\t\t\trefreshParts = true;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (refreshParts) {\n-\t\t\t\tparts = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), true);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (unit.getEntity().isOmni() && !unit.isSalvage()) {\n-\t\t\tfor (PodSpace ps : unit.getPodSpace()) {\n-\t\t\t\tps.setRepairInPlace(!configuredOptions.isReplacePodParts());\n-\t\t\t}\n-\n-\t\t\t// If we're replacing damaged parts, we want to remove any that have\n-\t\t\t// an available replacement\n-\t\t\t// from the list since the pod space repair will cover it.\n-\n-\t\t\tList<IPartWork> temp = new ArrayList<>();\n-\n-\t\t\tfor (IPartWork p : parts) {\n-\t\t\t\tif ((p instanceof Part) && ((Part) p).isOmniPodded()) {\n-\t\t\t\t\tif (!(p instanceof AmmoBin) || ((p instanceof AmmoBin) && salvaging)) {\n-\t\t\t\t\t\tMissingPart m = ((Part) p).getMissingPart();\n-\n-\t\t\t\t\t\tif (m != null && m.isReplacementAvailable()) {\n-\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\ttemp.add(p);\n-\t\t\t}\n-\n-\t\t\tparts = temp;\n-\t\t}\n-\n-\t\tif (techs.isEmpty()) {\n-\t\t\treturn new MassRepairUnitAction(unit, salvaging, MassRepairUnitAction.STATUS.NO_TECHS);\n-\t\t}\n-\n-\t\t/*\n-\t\t * If we're a mek and we have a limb with a bad shoulder/hip, we're\n-\t\t * going to try to flip it to salvageable and remove all the parts so\n-\t\t * that we can nuke the limb. If we do this, when we're finally done we\n-\t\t * need to flip the mek back to repairable so that we don't accidentally\n-\t\t * strip everything off it.\n-\t\t */\n-\t\tboolean scrappingLimbMode = false;\n-\n-\t\t/*\n-\t\t * Pre checking for hips/shoulders on repairable meks. If we have a bad\n-\t\t * hip or shoulder, we're not going to do anything until we get those\n-\t\t * parts out of the location and scrap it. Once we're at a happy place,\n-\t\t * we'll proceed.\n-\t\t */\n-\n-\t\tif ((unit.getEntity() instanceof Mech)) {\n-\t\t\tMap<Integer, Part> locationMap = new HashMap<Integer, Part>();\n-\n-\t\t\tfor (IPartWork partWork : parts) {\n-\t\t\t\tif ((partWork instanceof MekLocation) && ((MekLocation) partWork).onBadHipOrShoulder()) {\n-\t\t\t\t\tlocationMap.put(((MekLocation) partWork).getLoc(), (MekLocation) partWork);\n-\t\t\t\t} else if (partWork instanceof MissingMekLocation) {\n-\t\t\t\t\tlocationMap.put(partWork.getLocation(), (MissingMekLocation) partWork);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (!locationMap.isEmpty()) {\n-\t\t\t\tMassRepairOption mro = mroByTypeMap.get(Part.REPAIR_PART_TYPE.GENERAL_LOCATION);\n-\n-\t\t\t\tif ((null == mro) || !mro.isActive()) {\n-\t\t\t\t\treturn new MassRepairUnitAction(unit, salvaging, MassRepairUnitAction.STATUS.UNFIXABLE_LIMB);\n-\t\t\t\t}\n-\n-\t\t\t\t/*\n-\t\t\t\t * Find our parts in our bad locations. If we don't actually\n-\t\t\t\t * have, just scrap the limbs and move on with our normal work\n-\t\t\t\t */\n-\n-\t\t\t\tscrappingLimbMode = true;\n-\n-\t\t\t\tif (!salvaging) {\n-\t\t\t\t\tunit.setSalvage(true);\n-\t\t\t\t}\n-\n-\t\t\t\tList<IPartWork> partsTemp = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), true);\n-\t\t\t\tList<IPartWork> partsToBeRemoved = new ArrayList<IPartWork>();\n-\t\t\t\tMap<Integer, Integer> countOfPartsPerLocation = new HashMap<Integer, Integer>();\n-\n-\t\t\t\tfor (IPartWork partWork : partsTemp) {\n-\t\t\t\t\tif (!(partWork instanceof MekLocation) && !(partWork instanceof MissingMekLocation)\n-\t\t\t\t\t\t\t&& locationMap.containsKey(partWork.getLocation()) && partWork.isSalvaging()) {\n-\t\t\t\t\t\tpartsToBeRemoved.add(partWork);\n-\n-\t\t\t\t\t\tint count = 0;\n-\n-\t\t\t\t\t\tif (countOfPartsPerLocation.containsKey(partWork.getLocation())) {\n-\t\t\t\t\t\t\tcount = countOfPartsPerLocation.get(partWork.getLocation());\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tcount++;\n-\n-\t\t\t\t\t\tcountOfPartsPerLocation.put(partWork.getLocation(), count);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (partsToBeRemoved.isEmpty()) {\n-\t\t\t\t\t/*\n-\t\t\t\t\t * We have no parts left on our unfixable locations, so\n-\t\t\t\t\t * we'll just scrap those locations and rebuild the parts\n-\t\t\t\t\t * list and reset back our normal repair mode\n-\t\t\t\t\t */\n-\n-\t\t\t\t\tfor (Part part : locationMap.values()) {\n-\t\t\t\t\t\tif (part instanceof MekLocation) {\n-\t\t\t\t\t\t\tcampaign.addReport(part.scrap());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tscrappingLimbMode = false;\n-\n-\t\t\t\t\tif (!salvaging) {\n-\t\t\t\t\t\tunit.setSalvage(false);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tparts = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), true);\n-\t\t\t\t} else {\n-\t\t\t\t\tfor (int locId : countOfPartsPerLocation.keySet()) {\n-\t\t\t\t\t\tboolean unfixable = false;\n-\t\t\t\t\t\tPart loc = null;\n-\n-\t\t\t\t\t\tif (locationMap.containsKey(locId)) {\n-\t\t\t\t\t\t\tloc = locationMap.get(locId);\n-\t\t\t\t\t\t\tunfixable = (loc instanceof MekLocation);\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (unfixable) {\n-\t\t\t\t\t\t\tcampaign.addReport(String.format(\n-\t\t\t\t\t\t\t\t\t\"<font color='orange'>Found an unfixable limb (%s) on %s which contains %s parts. Going to remove all parts and scrap the limb before proceeding with other repairs.</font>\",\n-\t\t\t\t\t\t\t\t\tloc != null ? loc.getName() : Integer.toString(locId), unit.getName(), countOfPartsPerLocation.get(locId)));\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tcampaign.addReport(String.format(\n-\t\t\t\t\t\t\t\t\t\"<font color='orange'>Found missing location (%s) on %s which contains %s parts. Going to remove all parts before proceeding with other repairs.</font>\",\n-\t\t\t\t\t\t\t\t\tloc != null ? loc.getName() : Integer.toString(locId), unit.getName(), countOfPartsPerLocation.get(locId)));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tparts = partsToBeRemoved;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tboolean originalAllowCarryover = configuredOptions.isAllowCarryover();\n-\n-\t\t/*\n-\t\t * If we're scrapping limbs, we don't want salvage repairs to go into a\n-\t\t * new day otherwise it can be confusing when trying to figure why a\n-\t\t * unit can't be repaired because 'salvage' repairs don't show up on the\n-\t\t * task list as scheduled if we're in 'repair' mode.\n-\t\t */\n-\t\tif (scrappingLimbMode) {\n-\t\t\tconfiguredOptions.setAllowCarryover(false);\n-\t\t}\n-\n-\t\t/*\n-\t\t * Filter our parts list to only those that aren't being worked on or\n-\t\t * those that meet our criteria as defined in the campaign\n-\t\t * configurations\n-\t\t */\n-\t\tparts = filterParts(parts, mroByTypeMap, techs, campaignGUI.getCampaign());\n-\n-\t\tif (parts.isEmpty()) {\n-\t\t\tif (scrappingLimbMode) {\n-\t\t\t\tunit.setSalvage(false);\n-\t\t\t}\n-\n-\t\t\treturn new MassRepairUnitAction(unit, salvaging, MassRepairUnitAction.STATUS.NO_PARTS);\n-\t\t}\n-\n-\t\tMassRepairUnitAction unitAction = new MassRepairUnitAction(unit, salvaging,\n-\t\t\t\tMassRepairUnitAction.STATUS.ACTIONS_PERFORMED);\n-\n-\t\tfor (IPartWork partWork : parts) {\n-\t\t\tif (partWork instanceof Part) {\n-\t\t\t\t((Part) partWork).resetModeToNormal();\n-\t\t\t}\n-\n-\t\t\tList<Person> validTechs = filterTechs(partWork, techs, mroByTypeMap, false, campaignGUI);\n-\n-\t\t\tif (validTechs.isEmpty()) {\n-\t\t\t\tMassRepairPartAction mrpa = MassRepairPartAction.createNoTechs(partWork);\n-\t\t\t\tunitAction.addPartAction(mrpa);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tMassRepairPartAction mrpa = repairPart(campaignGUI, partWork, unit, validTechs, mroByTypeMap,\n-\t\t\t\t\tconfiguredOptions, false);\n-\t\t\tunitAction.addPartAction(mrpa);\n-\t\t}\n-\n-\t\tif (scrappingLimbMode) {\n-\t\t\tunit.setSalvage(false);\n-\t\t\tconfiguredOptions.setAllowCarryover(originalAllowCarryover);\n-\t\t}\n-\n-\t\tif (unitAction.getPartSet().isOnlyNoTechs()) {\n-\t\t\tunitAction.resetPartSet();\n-\t\t\tunitAction.setStatus(MassRepairUnitAction.STATUS.NO_TECHS);\n-\t\t}\n-\n-\t\treturn unitAction;\n-\t}\n-\n-\tprivate static MassRepairPartAction repairPart(CampaignGUI campaignGUI, IPartWork partWork, Unit unit,\n-\t\t\tList<Person> techs, Map<Integer, MassRepairOption> mroByTypeMap,\n-\t\t\tMassRepairConfiguredOptions configuredOptions, boolean warehouseMode) {\n-\n-\t\t// We were doing this check for every tech, that's unnecessary as it\n-\t\t// doesn't change from tech to tech\n-\t\tMassRepairOption mro = mroByTypeMap.get(IPartWork.findCorrectMassRepairType(partWork));\n-\n-\t\tif (null == mro) {\n-\t\t\treturn MassRepairPartAction.createOptionDisabled(partWork);\n-\t\t}\n-\n-\t\tlong repairPartTime = System.nanoTime();\n-\n-\t\tCampaign campaign = campaignGUI.getCampaign();\n-\t\tTechSorter sorter = new TechSorter(partWork);\n-\t\tMap<String, WorkTime> techSkillToWorktimeMap = new HashMap<>();\n-\t\tList<Person> sameDayTechs = new ArrayList<>();\n-\t\tList<Person> overflowDayTechs = new ArrayList<>();\n-\t\tList<Person> sameDayAssignedTechs = new ArrayList<>();\n-\t\tList<Person> overflowDayAssignedTechs = new ArrayList<>();\n-\t\tint highestAvailableTechSkill = -1;\n-\n-\t\tfor (Person tech : techs) {\n-\t\t\tSkill skill = tech.getSkillForWorkingOn(partWork);\n-\n-\t\t\tif (skill.getExperienceLevel() > highestAvailableTechSkill) {\n-\t\t\t\thighestAvailableTechSkill = skill.getExperienceLevel();\n-\t\t\t}\n-\n-\t\t\tif (highestAvailableTechSkill == SkillType.EXP_ELITE) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\n-\t\tdebugLog(\"Starting with %s techs on %s\", \"repairPart\", techs.size(), partWork.getPartName());\n-\n-\t\tboolean canChangeWorkTime = (partWork instanceof Part) && ((Part) partWork).canChangeWorkMode();\n-\n-\t\tfor (int i = techs.size() - 1; i >= 0; i--) {\n-\t\t\tlong time = System.nanoTime();\n-\n-\t\t\tPerson tech = techs.get(i);\n-\n-\t\t\tdebugLog(\"Checking tech %s\", \"repairPart\", tech.getFullName());\n-\n-\t\t\tSkill skill = tech.getSkillForWorkingOn(partWork);\n-\n-\t\t\tif (partWork instanceof Part) {\n-\t\t\t    ((Part) partWork).resetModeToNormal();\n-\t\t\t}\n-\n-\t\t\t// We really only have to check one tech of each skill level\n-\t\t\tif (!techSkillToWorktimeMap.containsKey(skill.getType().getName() + \"-\" + skill.getLevel())) {\n-\t\t\t\tTargetRoll targetRoll = campaign.getTargetFor(partWork, tech);\n-\t\t\t\tWorkTime selectedWorktime = null;\n+            if (!parts.isEmpty()) {\n+                if (parts.size() == 1) {\n+                    campaignGUI.getCampaign()\n+                            .addReport(\"<font color='red'>There in still 1 part that in not being worked on.</font>\");\n+                } else {\n+                    campaignGUI.getCampaign()\n+                            .addReport(String.format(\n+                                    \"<font color='red'>There are still %s parts that are not being worked on.</font>\",\n+                                    parts.size()));\n+                }\n+            }\n+        }\n+\n+        JOptionPane.showMessageDialog(campaignGUI.getFrame(),\n+                String.format(\"Mass %s complete on %s.\", actionDescriptor, unit.getName()), \"Complete\",\n+                JOptionPane.INFORMATION_MESSAGE);\n+    }\n+\n+    public static void massRepairSalvageAllUnits(CampaignGUI campaignGUI) {\n+        List<Unit> units = new ArrayList<Unit>();\n+\n+        for (Unit unit : campaignGUI.getCampaign().getServiceableUnits()) {\n+            if (!isValidMRMSUnit(unit)) {\n+                continue;\n+            }\n+\n+            units.add(unit);\n+        }\n+\n+        // Sort the list status fixing the least damaged first\n+        Collections.sort(units, new Comparator<Unit>() {\n+            @Override\n+            public int compare(Unit o1, Unit o2) {\n+                int damageIdx1 = UnitStatusSorter.getDamageStateIndex(Unit.getDamageStateName(o1.getDamageState()));\n+                int damageIdx2 = UnitStatusSorter.getDamageStateIndex(Unit.getDamageStateName(o2.getDamageState()));\n+\n+                if (damageIdx2 == damageIdx1) {\n+                    return 0;\n+                } else if (damageIdx2 < damageIdx1) {\n+                    return -1;\n+                }\n+\n+                return 1;\n+            }\n+        });\n+\n+        List<MassRepairOption> activeMROs = createActiveMROsFromConfiguration(campaignGUI);\n+\n+        massRepairSalvageUnits(campaignGUI, units, activeMROs);\n+    }\n+\n+    public static void massRepairSalvageUnits(CampaignGUI campaignGUI, List<Unit> units, List<MassRepairOption> activeMROs) {\n+        CampaignOptions options = campaignGUI.getCampaign().getCampaignOptions();\n+\n+        Map<MassRepairUnitAction.STATUS, List<MassRepairUnitAction>> unitActionsByStatus = new HashMap<MassRepairUnitAction.STATUS, List<MassRepairUnitAction>>();\n+\n+        MassRepairConfiguredOptions configuredOptions = new MassRepairConfiguredOptions();\n+        configuredOptions.setup(options);\n+\n+        for (Unit unit : units) {\n+            MassRepairUnitAction unitAction = performUnitMassRepairOrSalvage(campaignGUI, unit, unit.isSalvage(),\n+                    activeMROs, configuredOptions);\n+\n+            List<MassRepairUnitAction> list = unitActionsByStatus.get(unitAction.getStatus());\n+\n+            if (null == list) {\n+                list = new ArrayList<MassRepairUnitAction>();\n+                unitActionsByStatus.put(unitAction.getStatus(), list);\n+            }\n+\n+            list.add(unitAction);\n+        }\n+\n+        if (unitActionsByStatus.isEmpty()) {\n+            campaignGUI.getCampaign().addReport(\"Mass Repair/Salvage complete. There were no units worked on.\");\n+        } else {\n+            int totalCount = 0;\n+            int actionsPerformed = 0;\n+\n+            for (MassRepairUnitAction.STATUS key : unitActionsByStatus.keySet()) {\n+                if (key == MassRepairUnitAction.STATUS.ALL_PARTS_IN_PROCESS) {\n+                    continue;\n+                }\n+\n+                totalCount += unitActionsByStatus.get(key).size();\n+            }\n+\n+            if (unitActionsByStatus.containsKey(MassRepairUnitAction.STATUS.ACTIONS_PERFORMED)) {\n+                List<MassRepairUnitAction> unitsByStatus = unitActionsByStatus\n+                        .get(MassRepairUnitAction.STATUS.ACTIONS_PERFORMED);\n+\n+                for (MassRepairUnitAction mrua : unitsByStatus) {\n+                    actionsPerformed += mrua.getPartSet().countRepairs();\n+                }\n+            }\n+\n+            StringBuilder sb = new StringBuilder(\n+                    String.format(\"<font color='green'>Mass Repair/Salvage complete for %s units.</font>\", totalCount));\n+\n+            if (actionsPerformed > 0) {\n+                sb.append(String.format(\" %s repair/salvage action%s performed.\", actionsPerformed,\n+                        (actionsPerformed == 1 ? \"\" : \"s\")));\n+            }\n+\n+            sb.append(generateUnitRepairSummary(\"<br/>- %s unit%s had repairs/parts salvaged.\", unitActionsByStatus,\n+                    MassRepairUnitAction.STATUS.ACTIONS_PERFORMED));\n+            sb.append(generateUnitRepairSummary(\n+                    \"<br/>- %s unit%s had no actions performed because there were no valid parts.\", unitActionsByStatus,\n+                    MassRepairUnitAction.STATUS.NO_PARTS));\n+            sb.append(generateUnitRepairSummary(\n+                    \"<br/>- %s unit%s had no actions performed because there were no valid techs.\", unitActionsByStatus,\n+                    MassRepairUnitAction.STATUS.NO_TECHS));\n+            sb.append(generateUnitRepairSummary(\n+                    \"<br/>- %s unit%s had no actions performed because there were unfixable limbs and configured settings do not allow location repairs.\",\n+                    unitActionsByStatus, MassRepairUnitAction.STATUS.UNFIXABLE_LIMB));\n+\n+            campaignGUI.getCampaign().addReport(sb.toString());\n+        }\n+\n+        generateCampaignLogForUnitStatus(unitActionsByStatus, MassRepairUnitAction.STATUS.NO_PARTS,\n+                \"Units with no valid parts:\", campaignGUI);\n+        generateCampaignLogForUnitStatus(unitActionsByStatus, MassRepairUnitAction.STATUS.NO_TECHS,\n+                \"Units with no valid techs:\", campaignGUI);\n+        generateCampaignLogForUnitStatus(unitActionsByStatus, MassRepairUnitAction.STATUS.UNFIXABLE_LIMB,\n+                \"Units with unfixable limbs:\", campaignGUI);\n+\n+        if (!unitActionsByStatus.isEmpty()) {\n+            List<Person> techs = campaignGUI.getCampaign().getTechs(false);\n+\n+            if (!techs.isEmpty()) {\n+                int count = 0;\n+                int unitCount = 0;\n+\n+                for (List<MassRepairUnitAction> list : unitActionsByStatus.values()) {\n+                    for (MassRepairUnitAction mrua : list) {\n+                        List<IPartWork> parts = campaignGUI.getCampaign()\n+                                .getPartsNeedingServiceFor(mrua.getUnit().getId(), true);\n+                        int tempCount = filterParts(parts, null, techs, campaignGUI.getCampaign()).size();\n+\n+                        if (tempCount > 0) {\n+                            unitCount++;\n+                            count += tempCount;\n+                        }\n+                    }\n+                }\n+\n+                if (count > 0) {\n+                    if (count == 1) {\n+                        campaignGUI.getCampaign().addReport(\n+                                \"<font color='red'>There in still 1 part that in not being worked on.</font>\");\n+                    } else {\n+                        campaignGUI.getCampaign()\n+                                .addReport(String.format(\n+                                        \"<font color='red'>There are still %s parts that are not being worked on %s unit%s.</font>\",\n+                                        count, unitCount, (unitCount == 1 ? \"\" : \"s\")));\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Remove any units which after mass repair/salvage are no longer\n+        // useable.\n+        for (Unit u : units) {\n+            if (!u.isRepairable() && !u.hasSalvageableParts()) {\n+                campaignGUI.getCampaign().removeUnit(u.getId());\n+            }\n+        }\n+\n+        JOptionPane.showMessageDialog(campaignGUI.getFrame(), \"Mass Repair/Salvage complete.\", \"Complete\",\n+                JOptionPane.INFORMATION_MESSAGE);\n+    }\n+\n+    private static String generateUnitRepairSummary(String baseDescription,\n+            Map<MassRepairUnitAction.STATUS, List<MassRepairUnitAction>> unitActionsByStatus,\n+            MassRepairUnitAction.STATUS status) {\n+\n+        if (!unitActionsByStatus.containsKey(status)) {\n+            return \"\";\n+        }\n+\n+        int count = unitActionsByStatus.get(status).size();\n+\n+        return String.format(baseDescription, count, count == 1 ? \"\" : \"s\");\n+    }\n+\n+    private static void generateCampaignLogForUnitStatus(\n+            Map<MassRepairUnitAction.STATUS, List<MassRepairUnitAction>> unitActionsByStatus,\n+            MassRepairUnitAction.STATUS status, String statusDesc, CampaignGUI campaignGUI) {\n+        if (!unitActionsByStatus.containsKey(status) || unitActionsByStatus.get(status).isEmpty()) {\n+            return;\n+        }\n+\n+        StringBuilder sbMsg = new StringBuilder();\n+        sbMsg.append(statusDesc);\n+\n+        List<MassRepairUnitAction> unitsByStatus = unitActionsByStatus.get(status);\n+\n+        for (MassRepairUnitAction mrua : unitsByStatus) {\n+            sbMsg.append(\"<br/>- \" + mrua.getUnit().getName());\n+        }\n+\n+        campaignGUI.getCampaign().addReport(sbMsg.toString());\n+    }\n+\n+    public static MassRepairUnitAction performUnitMassRepairOrSalvage(CampaignGUI campaignGUI, Unit unit,\n+            boolean isSalvage, List<MassRepairOption> mroList, MassRepairConfiguredOptions configuredOptions) {\n+        Campaign campaign = campaignGUI.getCampaign();\n+\n+        List<Person> techs = campaign.getTechs(true);\n+\n+        if (techs.isEmpty()) {\n+            return new MassRepairUnitAction(unit, isSalvage, MassRepairUnitAction.STATUS.NO_TECHS);\n+        }\n+\n+        MassRepairUnitAction unitAction = new MassRepairUnitAction(unit, isSalvage,\n+                MassRepairUnitAction.STATUS.NO_ACTIONS);\n+\n+        // Filter our tech list to only our techs that can work on this unit\n+        for (int i = techs.size() - 1; i >= 0; i--) {\n+            Person tech = techs.get(i);\n+\n+            if (!tech.canTech(unit.getEntity())) {\n+                techs.remove(i);\n+            }\n+        }\n+\n+        Map<Integer, MassRepairOption> mroByTypeMap = new HashMap<Integer, MassRepairOption>();\n+\n+        for (int i = 0; i < mroList.size(); i++) {\n+            mroByTypeMap.put(mroList.get(i).getType(), mroList.get(i));\n+        }\n+\n+        /*\n+         * Possibly call this multiple times. Sometimes some actions are first\n+         * dependent upon others being finished, also failed actions can be\n+         * performed again by a tech with a higher skill.\n+         */\n+        boolean performMoreRepairs = true;\n+\n+        long time = System.nanoTime();\n+\n+        while (performMoreRepairs) {\n+            MassRepairUnitAction currentUnitAction = performUnitMassTechAction(campaignGUI, unit, techs, mroByTypeMap,\n+                    isSalvage, configuredOptions);\n+\n+            performMoreRepairs = currentUnitAction.getPartSet().isHasRepairs();\n+            unitAction.merge(currentUnitAction);\n+\n+            if (unitAction.isStatusNoActions()) {\n+                unitAction.setStatus(currentUnitAction.getStatus());\n+            }\n+        }\n+\n+        debugLog(\"Finished fixing %s in %s ns\", \"performUnitMassRepairOrSalvage\", unit.getName(), System.nanoTime() - time);\n+\n+        return unitAction;\n+    }\n+\n+    private static MassRepairUnitAction performUnitMassTechAction(CampaignGUI campaignGUI, Unit unit,\n+            List<Person> techs, Map<Integer, MassRepairOption> mroByTypeMap, boolean salvaging,\n+            MassRepairConfiguredOptions configuredOptions) {\n+        Campaign campaign = campaignGUI.getCampaign();\n+\n+        List<IPartWork> parts = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), true);\n+\n+        if (parts.isEmpty()) {\n+            parts = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), false);\n+\n+            if (!parts.isEmpty()) {\n+                return new MassRepairUnitAction(unit, salvaging, MassRepairUnitAction.STATUS.ALL_PARTS_IN_PROCESS);\n+            }\n+\n+            return new MassRepairUnitAction(unit, salvaging, MassRepairUnitAction.STATUS.NO_PARTS);\n+        }\n+\n+        for (IPartWork partWork : parts) {\n+            if (partWork instanceof Part) {\n+                Part part = (Part) partWork;\n+                part.resetModeToNormal();\n+            }\n+        }\n+\n+        /*\n+         * If we're performing an action on a unit and we allow auto-scrapping\n+         * of parts that can't be fixed by an elite tech, let's first get rid of\n+         * those parts and start with a cleaner slate\n+         */\n+        if (configuredOptions.isScrapImpossible()) {\n+            boolean refreshParts = false;\n+\n+            for (IPartWork partWork : parts) {\n+                if (partWork instanceof Part && partWork.getSkillMin() > SkillType.EXP_ELITE) {\n+                    campaign.addReport(((Part) partWork).scrap());\n+                    refreshParts = true;\n+                }\n+            }\n+\n+            if (refreshParts) {\n+                parts = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), true);\n+            }\n+        }\n+\n+        if (unit.getEntity().isOmni() && !unit.isSalvage()) {\n+            for (PodSpace ps : unit.getPodSpace()) {\n+                ps.setRepairInPlace(!configuredOptions.isReplacePodParts());\n+            }\n+\n+            // If we're replacing damaged parts, we want to remove any that have\n+            // an available replacement\n+            // from the list since the pod space repair will cover it.\n+\n+            List<IPartWork> temp = new ArrayList<>();\n+\n+            for (IPartWork p : parts) {\n+                if ((p instanceof Part) && ((Part) p).isOmniPodded()) {\n+                    if (!(p instanceof AmmoBin) || ((p instanceof AmmoBin) && salvaging)) {\n+                        MissingPart m = ((Part) p).getMissingPart();\n+\n+                        if (m != null && m.isReplacementAvailable()) {\n+                            continue;\n+                        }\n+                    }\n+                }\n+\n+                temp.add(p);\n+            }\n+\n+            parts = temp;\n+        }\n+\n+        if (techs.isEmpty()) {\n+            return new MassRepairUnitAction(unit, salvaging, MassRepairUnitAction.STATUS.NO_TECHS);\n+        }\n+\n+        /*\n+         * If we're a mek and we have a limb with a bad shoulder/hip, we're\n+         * going to try to flip it to salvageable and remove all the parts so\n+         * that we can nuke the limb. If we do this, when we're finally done we\n+         * need to flip the mek back to repairable so that we don't accidentally\n+         * strip everything off it.\n+         */\n+        boolean scrappingLimbMode = false;\n+\n+        /*\n+         * Pre checking for hips/shoulders on repairable meks. If we have a bad\n+         * hip or shoulder, we're not going to do anything until we get those\n+         * parts out of the location and scrap it. Once we're at a happy place,\n+         * we'll proceed.\n+         */\n+\n+        if ((unit.getEntity() instanceof Mech)) {\n+            Map<Integer, Part> locationMap = new HashMap<Integer, Part>();\n+\n+            for (IPartWork partWork : parts) {\n+                if ((partWork instanceof MekLocation) && ((MekLocation) partWork).onBadHipOrShoulder()) {\n+                    locationMap.put(((MekLocation) partWork).getLoc(), (MekLocation) partWork);\n+                } else if (partWork instanceof MissingMekLocation) {\n+                    locationMap.put(partWork.getLocation(), (MissingMekLocation) partWork);\n+                }\n+            }\n+\n+            if (!locationMap.isEmpty()) {\n+                MassRepairOption mro = mroByTypeMap.get(Part.REPAIR_PART_TYPE.GENERAL_LOCATION);\n+\n+                if ((null == mro) || !mro.isActive()) {\n+                    return new MassRepairUnitAction(unit, salvaging, MassRepairUnitAction.STATUS.UNFIXABLE_LIMB);\n+                }\n+\n+                /*\n+                 * Find our parts in our bad locations. If we don't actually\n+                 * have, just scrap the limbs and move on with our normal work\n+                 */\n+\n+                scrappingLimbMode = true;\n+\n+                if (!salvaging) {\n+                    unit.setSalvage(true);\n+                }\n+\n+                List<IPartWork> partsTemp = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), true);\n+                List<IPartWork> partsToBeRemoved = new ArrayList<IPartWork>();\n+                Map<Integer, Integer> countOfPartsPerLocation = new HashMap<Integer, Integer>();\n+\n+                for (IPartWork partWork : partsTemp) {\n+                    if (!(partWork instanceof MekLocation) && !(partWork instanceof MissingMekLocation)\n+                            && locationMap.containsKey(partWork.getLocation()) && partWork.isSalvaging()) {\n+                        partsToBeRemoved.add(partWork);\n+\n+                        int count = 0;\n+\n+                        if (countOfPartsPerLocation.containsKey(partWork.getLocation())) {\n+                            count = countOfPartsPerLocation.get(partWork.getLocation());\n+                        }\n+\n+                        count++;\n+\n+                        countOfPartsPerLocation.put(partWork.getLocation(), count);\n+                    }\n+                }\n+\n+                if (partsToBeRemoved.isEmpty()) {\n+                    /*\n+                     * We have no parts left on our unfixable locations, so\n+                     * we'll just scrap those locations and rebuild the parts\n+                     * list and reset back our normal repair mode\n+                     */\n+\n+                    for (Part part : locationMap.values()) {\n+                        if (part instanceof MekLocation) {\n+                            campaign.addReport(part.scrap());\n+                        }\n+                    }\n+\n+                    scrappingLimbMode = false;\n+\n+                    if (!salvaging) {\n+                        unit.setSalvage(false);\n+                    }\n+\n+                    parts = campaignGUI.getCampaign().getPartsNeedingServiceFor(unit.getId(), true);\n+                } else {\n+                    for (int locId : countOfPartsPerLocation.keySet()) {\n+                        boolean unfixable = false;\n+                        Part loc = null;\n+\n+                        if (locationMap.containsKey(locId)) {\n+                            loc = locationMap.get(locId);\n+                            unfixable = (loc instanceof MekLocation);\n+                        }\n+\n+                        if (unfixable) {\n+                            campaign.addReport(String.format(\n+                                    \"<font color='orange'>Found an unfixable limb (%s) on %s which contains %s parts. Going to remove all parts and scrap the limb before proceeding with other repairs.</font>\",\n+                                    loc != null ? loc.getName() : Integer.toString(locId), unit.getName(), countOfPartsPerLocation.get(locId)));\n+                        } else {\n+                            campaign.addReport(String.format(\n+                                    \"<font color='orange'>Found missing location (%s) on %s which contains %s parts. Going to remove all parts before proceeding with other repairs.</font>\",\n+                                    loc != null ? loc.getName() : Integer.toString(locId), unit.getName(), countOfPartsPerLocation.get(locId)));\n+                        }\n+                    }\n+\n+                    parts = partsToBeRemoved;\n+                }\n+            }\n+        }\n+\n+        boolean originalAllowCarryover = configuredOptions.isAllowCarryover();\n+\n+        /*\n+         * If we're scrapping limbs, we don't want salvage repairs to go into a\n+         * new day otherwise it can be confusing when trying to figure why a\n+         * unit can't be repaired because 'salvage' repairs don't show up on the\n+         * task list as scheduled if we're in 'repair' mode.\n+         */\n+        if (scrappingLimbMode) {\n+            configuredOptions.setAllowCarryover(false);\n+        }\n+\n+        /*\n+         * Filter our parts list to only those that aren't being worked on or\n+         * those that meet our criteria as defined in the campaign\n+         * configurations\n+         */\n+        parts = filterParts(parts, mroByTypeMap, techs, campaignGUI.getCampaign());\n+\n+        if (parts.isEmpty()) {\n+            if (scrappingLimbMode) {\n+                unit.setSalvage(false);\n+            }\n+\n+            return new MassRepairUnitAction(unit, salvaging, MassRepairUnitAction.STATUS.NO_PARTS);\n+        }\n+\n+        MassRepairUnitAction unitAction = new MassRepairUnitAction(unit, salvaging,\n+                MassRepairUnitAction.STATUS.ACTIONS_PERFORMED);\n+\n+        for (IPartWork partWork : parts) {\n+            if (partWork instanceof Part) {\n+                ((Part) partWork).resetModeToNormal();\n+            }\n+\n+            List<Person> validTechs = filterTechs(partWork, techs, mroByTypeMap, false, campaignGUI);\n+\n+            if (validTechs.isEmpty()) {\n+                MassRepairPartAction mrpa = MassRepairPartAction.createNoTechs(partWork);\n+                unitAction.addPartAction(mrpa);\n+                continue;\n+            }\n+\n+            MassRepairPartAction mrpa = repairPart(campaignGUI, partWork, unit, validTechs, mroByTypeMap,\n+                    configuredOptions, false);\n+            unitAction.addPartAction(mrpa);\n+        }\n+\n+        if (scrappingLimbMode) {\n+            unit.setSalvage(false);\n+            configuredOptions.setAllowCarryover(originalAllowCarryover);\n+        }\n+\n+        if (unitAction.getPartSet().isOnlyNoTechs()) {\n+            unitAction.resetPartSet();\n+            unitAction.setStatus(MassRepairUnitAction.STATUS.NO_TECHS);\n+        }\n+\n+        return unitAction;\n+    }\n+\n+    private static MassRepairPartAction repairPart(CampaignGUI campaignGUI, IPartWork partWork, Unit unit,\n+            List<Person> techs, Map<Integer, MassRepairOption> mroByTypeMap,\n+            MassRepairConfiguredOptions configuredOptions, boolean warehouseMode) {\n+\n+        // We were doing this check for every tech, that's unnecessary as it\n+        // doesn't change from tech to tech\n+        MassRepairOption mro = mroByTypeMap.get(IPartWork.findCorrectMassRepairType(partWork));\n+\n+        if (null == mro) {\n+            return MassRepairPartAction.createOptionDisabled(partWork);\n+        }\n+\n+        long repairPartTime = System.nanoTime();\n+\n+        Campaign campaign = campaignGUI.getCampaign();\n+        TechSorter sorter = new TechSorter(partWork);\n+        Map<String, WorkTime> techSkillToWorktimeMap = new HashMap<>();\n+        List<Person> sameDayTechs = new ArrayList<>();\n+        List<Person> overflowDayTechs = new ArrayList<>();\n+        List<Person> sameDayAssignedTechs = new ArrayList<>();\n+        List<Person> overflowDayAssignedTechs = new ArrayList<>();\n+        int highestAvailableTechSkill = -1;\n+\n+        for (Person tech : techs) {\n+            Skill skill = tech.getSkillForWorkingOn(partWork);\n+\n+            if (skill.getExperienceLevel() > highestAvailableTechSkill) {\n+                highestAvailableTechSkill = skill.getExperienceLevel();\n+            }\n+\n+            if (highestAvailableTechSkill == SkillType.EXP_ELITE) {\n+                break;\n+            }\n+        }\n+\n+        debugLog(\"Starting with %s techs on %s\", \"repairPart\", techs.size(), partWork.getPartName());\n+\n+        boolean canChangeWorkTime = (partWork instanceof Part) && ((Part) partWork).canChangeWorkMode();\n+\n+        for (int i = techs.size() - 1; i >= 0; i--) {\n+            long time = System.nanoTime();\n+\n+            Person tech = techs.get(i);\n+\n+            debugLog(\"Checking tech %s\", \"repairPart\", tech.getFullName());\n+\n+            Skill skill = tech.getSkillForWorkingOn(partWork);\n+\n+            if (partWork instanceof Part) {\n+                ((Part) partWork).resetModeToNormal();\n+            }\n+\n+            // We really only have to check one tech of each skill level\n+            if (!techSkillToWorktimeMap.containsKey(skill.getType().getName() + \"-\" + skill.getLevel())) {\n+                TargetRoll targetRoll = campaign.getTargetFor(partWork, tech);\n+                WorkTime selectedWorktime = null;\n \n-\t\t\t\t// Check if we need to increase the time to meet the min BTH\n-\t\t\t\tif (targetRoll.getValue() > mro.getBthMin()) {\n-\t\t\t\t\tif (!configuredOptions.isUseExtraTime()) {\n-\t\t\t\t\t\tdebugLog(\"... can't increase time to reach BTH due to configuration\", \"repairPart\");\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t} else if (!canChangeWorkTime) {\n-\t\t\t\t\t\tdebugLog(\"... can't increase time because this part can not have it's workMode changed\", \"repairPart\");\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n+                // Check if we need to increase the time to meet the min BTH\n+                if (targetRoll.getValue() > mro.getBthMin()) {\n+                    if (!configuredOptions.isUseExtraTime()) {\n+                        debugLog(\"... can't increase time to reach BTH due to configuration\", \"repairPart\");\n+                        continue;\n+                    } else if (!canChangeWorkTime) {\n+                        debugLog(\"... can't increase time because this part can not have it's workMode changed\", \"repairPart\");\n+                        continue;\n+                    }\n \n-\t\t\t\t\tWorkTimeCalculation workTimeCalc = calculateNewMassRepairWorktime(partWork, tech, mro, campaign,\n-\t\t\t\t\t\t\ttrue, highestAvailableTechSkill);\n+                    WorkTimeCalculation workTimeCalc = calculateNewMassRepairWorktime(partWork, tech, mro, campaign,\n+                            true, highestAvailableTechSkill);\n \n-\t\t\t\t\tif (null == workTimeCalc.getWorkTime()) {\n-\t\t\t\t\t\tif (workTimeCalc.isReachedMaxSkill()) {\n-\t\t\t\t\t\t\tdebugLog(\"... can't increase time enough to reach BTH with max available tech\", \"repairPart\");\n+                    if (null == workTimeCalc.getWorkTime()) {\n+                        if (workTimeCalc.isReachedMaxSkill()) {\n+                            debugLog(\"... can't increase time enough to reach BTH with max available tech\", \"repairPart\");\n \n-\t\t\t\t\t\t\treturn MassRepairPartAction.createMaxSkillReached(partWork, highestAvailableTechSkill,\n-\t\t\t\t\t\t\t\t\tmro.getBthMin());\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tdebugLog(\"... can't increase time enough to reach BTH\", \"repairPart\");\n+                            return MassRepairPartAction.createMaxSkillReached(partWork, highestAvailableTechSkill,\n+                                    mro.getBthMin());\n+                        } else {\n+                            debugLog(\"... can't increase time enough to reach BTH\", \"repairPart\");\n \n-\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+                            continue;\n+                        }\n+                    }\n \n-\t\t\t\t\tselectedWorktime = workTimeCalc.getWorkTime();\n-\t\t\t\t} else if (targetRoll.getValue() < mro.getBthMax()) {\n-\t\t\t\t\t// Or decrease the time to meet the max BTH\n-\t\t\t\t\tif (configuredOptions.isUseRushJob() && canChangeWorkTime) {\n-\t\t\t\t\t\tWorkTimeCalculation workTimeCalc = calculateNewMassRepairWorktime(partWork, tech, mro, campaign,\n-\t\t\t\t\t\t\t\tfalse, highestAvailableTechSkill);\n+                    selectedWorktime = workTimeCalc.getWorkTime();\n+                } else if (targetRoll.getValue() < mro.getBthMax()) {\n+                    // Or decrease the time to meet the max BTH\n+                    if (configuredOptions.isUseRushJob() && canChangeWorkTime) {\n+                        WorkTimeCalculation workTimeCalc = calculateNewMassRepairWorktime(partWork, tech, mro, campaign,\n+                                false, highestAvailableTechSkill);\n \n-\t\t\t\t\t\tif (null == workTimeCalc.getWorkTime()) {\n-\t\t\t\t\t\t\tselectedWorktime = WorkTime.NORMAL;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tselectedWorktime = workTimeCalc.getWorkTime();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n+                        if (null == workTimeCalc.getWorkTime()) {\n+                            selectedWorktime = WorkTime.NORMAL;\n+                        } else {\n+                            selectedWorktime = workTimeCalc.getWorkTime();\n+                        }\n+                    }\n+                }\n \n-\t\t\t\ttechSkillToWorktimeMap.put(skill.getType().getName() + \"-\" + skill.getLevel(), selectedWorktime);\n+                techSkillToWorktimeMap.put(skill.getType().getName() + \"-\" + skill.getLevel(), selectedWorktime);\n \n-\t\t\t\tif (partWork instanceof Part) {\n-\t\t\t\t\t((Part) partWork).resetModeToNormal();\n-\t\t\t\t}\n-\t\t\t}\n+                if (partWork instanceof Part) {\n+                    ((Part) partWork).resetModeToNormal();\n+                }\n+            }\n \n-\t\t\tboolean assigned = false;\n+            boolean assigned = false;\n \n-\t\t\tif ((null != unit) && configuredOptions.isUseAssignedTechsFirst()) {\n-\t\t\t\tForce force = campaign.getForce(unit.getForceId());\n+            if ((null != unit) && configuredOptions.isUseAssignedTechsFirst()) {\n+                Force force = campaign.getForce(unit.getForceId());\n \n-\t\t\t\tif ((null != force) && (null != force.getTechID())) {\n-\t\t\t\t\tassigned = force.getTechID().toString().equals(tech.getId().toString());\n-\t\t\t\t}\n+                if ((null != force) && (null != force.getTechID())) {\n+                    assigned = force.getTechID().toString().equals(tech.getId().toString());\n+                }\n \n-\t\t\t\tif (!assigned && (null != tech.getTechUnitIDs()) && !tech.getTechUnitIDs().isEmpty()) {\n-\t\t\t\t\tassigned = tech.getTechUnitIDs().contains(unit.getId());\n-\t\t\t\t}\n-\t\t\t}\n+                if (!assigned && (null != tech.getTechUnitIDs()) && !tech.getTechUnitIDs().isEmpty()) {\n+                    assigned = tech.getTechUnitIDs().contains(unit.getId());\n+                }\n+            }\n \n-\t\t\tboolean isSameDayTech;\n+            boolean isSameDayTech;\n \n-\t\t\tif ((tech.getMinutesLeft() < partWork.getActualTime())) {\n-\t\t\t\tif (!configuredOptions.isAllowCarryover()) {\n-\t\t\t\t\tdebugLog(\"... would carry over day and configuration doesn't allow\", \"repairPart\");\n+            if ((tech.getMinutesLeft() < partWork.getActualTime())) {\n+                if (!configuredOptions.isAllowCarryover()) {\n+                    debugLog(\"... would carry over day and configuration doesn't allow\", \"repairPart\");\n \n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n+                    continue;\n+                }\n \n                 isSameDayTech = !configuredOptions.isOptimizeToCompleteToday();\n-\t\t\t} else {\n-\t\t\t\tisSameDayTech = true;\n-\t\t\t}\n-\n-\t\t\tif (isSameDayTech) {\n-\t\t\t\tif (assigned) {\n-\t\t\t\t\tsameDayAssignedTechs.add(tech);\n-\t\t\t\t} else {\n-\t\t\t\t\tsameDayTechs.add(tech);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tif (assigned) {\n-\t\t\t\t\toverflowDayAssignedTechs.add(tech);\n-\t\t\t\t} else {\n-\t\t\t\t\toverflowDayTechs.add(tech);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tdebugLog(\"... time to check tech: %s ns\", \"repairPart\", (System.nanoTime() - time));\n-\t\t}\n-\n-\t\tList<Person> validTechs = new ArrayList<>();\n+            } else {\n+                isSameDayTech = true;\n+            }\n+\n+            if (isSameDayTech) {\n+                if (assigned) {\n+                    sameDayAssignedTechs.add(tech);\n+                } else {\n+                    sameDayTechs.add(tech);\n+                }\n+            } else {\n+                if (assigned) {\n+                    overflowDayAssignedTechs.add(tech);\n+                } else {\n+                    overflowDayTechs.add(tech);\n+                }\n+            }\n+\n+            debugLog(\"... time to check tech: %s ns\", \"repairPart\", (System.nanoTime() - time));\n+        }\n+\n+        List<Person> validTechs = new ArrayList<>();\n \n-\t\tif (!sameDayAssignedTechs.isEmpty()) {\n-\t\t\tsameDayAssignedTechs.sort(sorter);\n-\t\t\tvalidTechs.addAll(sameDayAssignedTechs);\n-\t\t}\n-\n-\t\tif (!sameDayTechs.isEmpty()) {\n-\t\t\tsameDayTechs.sort(sorter);\n-\t\t\tvalidTechs.addAll(sameDayTechs);\n-\t\t}\n-\n-\t\tif (!overflowDayAssignedTechs.isEmpty()) {\n-\t\t\toverflowDayAssignedTechs.sort(sorter);\n-\t\t\tvalidTechs.addAll(overflowDayAssignedTechs);\n-\t\t}\n+        if (!sameDayAssignedTechs.isEmpty()) {\n+            sameDayAssignedTechs.sort(sorter);\n+            validTechs.addAll(sameDayAssignedTechs);\n+        }\n+\n+        if (!sameDayTechs.isEmpty()) {\n+            sameDayTechs.sort(sorter);\n+            validTechs.addAll(sameDayTechs);\n+        }\n+\n+        if (!overflowDayAssignedTechs.isEmpty()) {\n+            overflowDayAssignedTechs.sort(sorter);\n+            validTechs.addAll(overflowDayAssignedTechs);\n+        }\n \n-\t\tif (!overflowDayTechs.isEmpty()) {\n-\t\t\toverflowDayTechs.sort(sorter);\n-\t\t\tvalidTechs.addAll(overflowDayTechs);\n-\t\t}\n+        if (!overflowDayTechs.isEmpty()) {\n+            overflowDayTechs.sort(sorter);\n+            validTechs.addAll(overflowDayTechs);\n+        }\n \n-\t\tif (validTechs.isEmpty()) {\n-\t\t\tdebugLog(\"Ending because there are no techs\", \"repairPart\");\n+        if (validTechs.isEmpty()) {\n+            debugLog(\"Ending because there are no techs\", \"repairPart\");\n \n-\t\t\treturn MassRepairPartAction.createNoTechs(partWork);\n-\t\t}\n+            return MassRepairPartAction.createNoTechs(partWork);\n+        }\n \n-\t\tPerson tech = validTechs.get(0);\n+        Person tech = validTechs.get(0);\n \n-\t\tif (partWork instanceof Part) {\n-\t\t\tSkill skill = tech.getSkillForWorkingOn(partWork);\n-\t\t\tWorkTime wt = techSkillToWorktimeMap.get(skill.getType().getName() + \"-\" + skill.getLevel());\n+        if (partWork instanceof Part) {\n+            Skill skill = tech.getSkillForWorkingOn(partWork);\n+            WorkTime wt = techSkillToWorktimeMap.get(skill.getType().getName() + \"-\" + skill.getLevel());\n \n-\t\t\tif (null == wt) {\n-\t\t\t\tdebugLog(\"[ERROR] Null work-time from techToWorktimeMap for %s\", \"repairPart\", tech.getFullName());\n-\t\t\t\twt = WorkTime.NORMAL;\n-\t\t\t}\n+            if (null == wt) {\n+                debugLog(\"[ERROR] Null work-time from techToWorktimeMap for %s\", \"repairPart\", tech.getFullName());\n+                wt = WorkTime.NORMAL;\n+            }\n \n-\t\t\t((Part) partWork).setMode(wt);\n-\t\t}\n+            ((Part) partWork).setMode(wt);\n+        }\n \n-\t\tif (warehouseMode) {\n-\t\t\tcampaign.fixWarehousePart((Part) partWork, tech);\n-\t\t} else {\n-\t\t\tcampaign.fixPart(partWork, tech);\n-\t\t}\n+        if (warehouseMode) {\n+            campaign.fixWarehousePart((Part) partWork, tech);\n+        } else {\n+            campaign.fixPart(partWork, tech);\n+        }\n \n-\t\t// If this tech has no time left, filter them out so we don't\n-\t\t// spend cycles on them in the future\n-\t\tif (tech.getMinutesLeft() <= 0) {\n-\t\t\ttechs.remove(tech);\n-\t\t}\n+        // If this tech has no time left, filter them out so we don't\n+        // spend cycles on them in the future\n+        if (tech.getMinutesLeft() <= 0) {\n+            techs.remove(tech);\n+        }\n \n-\t\tThread.yield();\n+        Thread.yield();\n \n-\t\tdebugLog(\"Ending after %s ns\", \"repairPart\", System.nanoTime() - repairPartTime);\n+        debugLog(\"Ending after %s ns\", \"repairPart\", System.nanoTime() - repairPartTime);\n \n-\t\treturn MassRepairPartAction.createRepaired(partWork);\n-\t}\n+        return MassRepairPartAction.createRepaired(partWork);\n+    }\n \n-\tprivate static List<IPartWork> filterParts(List<IPartWork> parts, Map<Integer, MassRepairOption> mroByTypeMap,\n-\t\t\tList<Person> techs, Campaign campaign) {\n-\t\tList<IPartWork> newParts = new ArrayList<IPartWork>();\n+    private static List<IPartWork> filterParts(List<IPartWork> parts, Map<Integer, MassRepairOption> mroByTypeMap,\n+            List<Person> techs, Campaign campaign) {\n+        List<IPartWork> newParts = new ArrayList<IPartWork>();\n \n-\t\tif (techs.isEmpty() || parts.isEmpty()) {\n-\t\t\treturn newParts;\n-\t\t}\n+        if (techs.isEmpty() || parts.isEmpty()) {\n+            return newParts;\n+        }\n \n-\t\tMap<String, Person> techCache = new HashMap<String, Person>();\n+        Map<String, Person> techCache = new HashMap<String, Person>();\n \n-\t\tfor (IPartWork partWork : parts) {\n-\t\t\tif (partWork.isBeingWorkedOn()) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+        for (IPartWork partWork : parts) {\n+            if (partWork.isBeingWorkedOn()) {\n+                continue;\n+            }\n \n-\t\t\tif (partWork instanceof MissingPart && !((MissingPart) partWork).isReplacementAvailable()) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+            if (partWork instanceof MissingPart && !((MissingPart) partWork).isReplacementAvailable()) {\n+                continue;\n+            }\n \n-\t\t\tif (null != mroByTypeMap) {\n-\t\t\t\tint repairType = IPartWork.findCorrectMassRepairType(partWork);\n+            if (null != mroByTypeMap) {\n+                int repairType = IPartWork.findCorrectMassRepairType(partWork);\n \n-\t\t\t\tMassRepairOption mro = mroByTypeMap.get(repairType);\n+                MassRepairOption mro = mroByTypeMap.get(repairType);\n \n-\t\t\t\tif ((null == mro) || !mro.isActive()) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n+                if ((null == mro) || !mro.isActive()) {\n+                    continue;\n+                }\n+            }\n \n-\t\t\tif (!checkArmorSupply(partWork)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+            if (!checkArmorSupply(partWork)) {\n+                continue;\n+            }\n \n-\t\t\t// See if this part is blocked or can be dealt with\n-\t\t\t// Find an appropriate tech and get their skill then create an\n-\t\t\t// elite tech with the same skill\n-\t\t\tSkill partSkill = null;\n+            // See if this part is blocked or can be dealt with\n+            // Find an appropriate tech and get their skill then create an\n+            // elite tech with the same skill\n+            Skill partSkill = null;\n \n-\t\t\tfor (Person techExisting : techs) {\n-\t\t\t\tpartSkill = techExisting.getSkillForWorkingOn(partWork);\n+            for (Person techExisting : techs) {\n+                partSkill = techExisting.getSkillForWorkingOn(partWork);\n \n-\t\t\t\tif (null != partSkill) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n+                if (null != partSkill) {\n+                    break;\n+                }\n+            }\n \n-\t\t\tif (null == partSkill) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+            if (null == partSkill) {\n+                continue;\n+            }\n \n-\t\t\tString skillName = partSkill.getType().getName();\n+            String skillName = partSkill.getType().getName();\n \n-\t\t\t// Find a tech in our placeholder cache\n-\t\t\tPerson tech = techCache.get(skillName);\n+            // Find a tech in our placeholder cache\n+            Person tech = techCache.get(skillName);\n \n-\t\t\tif (null == tech) {\n-\t\t\t\t// Create a dummy elite tech with the proper skill and 1\n-\t\t\t\t// minute and put it in our cache for later use\n+            if (null == tech) {\n+                // Create a dummy elite tech with the proper skill and 1\n+                // minute and put it in our cache for later use\n \n-\t\t\t\ttech = new Person(\"Temp\", String.format(\"Tech (%s)\", skillName), campaign);\n-\t\t\t\ttech.addSkill(skillName, partSkill.getType().getEliteLevel(), 1);\n-\t\t\t\ttech.setMinutesLeft(1);\n+                tech = new Person(\"Temp\", String.format(\"Tech (%s)\", skillName), campaign);\n+                tech.addSkill(skillName, partSkill.getType().getEliteLevel(), 1);\n+                tech.setMinutesLeft(1);\n \n-\t\t\t\ttechCache.put(skillName, tech);\n-\t\t\t}\n+                techCache.put(skillName, tech);\n+            }\n \n-\t\t\tTargetRoll roll = campaign.getTargetFor(partWork, tech);\n+            TargetRoll roll = campaign.getTargetFor(partWork, tech);\n \n-\t\t\tif ((roll.getValue() == TargetRoll.IMPOSSIBLE) || (roll.getValue() == TargetRoll.AUTOMATIC_FAIL)\n-\t\t\t\t\t|| (roll.getValue() == TargetRoll.CHECK_FALSE)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+            if ((roll.getValue() == TargetRoll.IMPOSSIBLE) || (roll.getValue() == TargetRoll.AUTOMATIC_FAIL)\n+                    || (roll.getValue() == TargetRoll.CHECK_FALSE)) {\n+                continue;\n+            }\n \n-\t\t\tnewParts.add(partWork);\n-\t\t}\n+            newParts.add(partWork);\n+        }\n \n-\t\treturn newParts;\n-\t}\n+        return newParts;\n+    }\n \n-\tprivate static List<Person> filterTechs(IPartWork partWork, List<Person> techs,\n-\t\t\tMap<Integer, MassRepairOption> mroByTypeMap, boolean warehouseMode, CampaignGUI campaignGUI) {\n-\t\tList<Person> validTechs = new ArrayList<Person>();\n+    private static List<Person> filterTechs(IPartWork partWork, List<Person> techs,\n+            Map<Integer, MassRepairOption> mroByTypeMap, boolean warehouseMode, CampaignGUI campaignGUI) {\n+        List<Person> validTechs = new ArrayList<Person>();\n \n-\t\tif (techs.isEmpty()) {\n-\t\t\treturn validTechs;\n-\t\t}\n+        if (techs.isEmpty()) {\n+            return validTechs;\n+        }\n \n-\t\tMassRepairOption mro = mroByTypeMap.get(IPartWork.findCorrectMassRepairType(partWork));\n+        MassRepairOption mro = mroByTypeMap.get(IPartWork.findCorrectMassRepairType(partWork));\n \n-\t\tif (null == mro) {\n-\t\t\treturn validTechs;\n-\t\t}\n+        if (null == mro) {\n+            return validTechs;\n+        }\n \n-\t\tCampaign campaign = campaignGUI.getCampaign();\n+        Campaign campaign = campaignGUI.getCampaign();\n \n-\t\tfor (int i = techs.size() - 1; i >= 0; i--) {\n-\t\t\tPerson tech = techs.get(i);\n+        for (int i = techs.size() - 1; i >= 0; i--) {\n+            Person tech = techs.get(i);\n \n-\t\t\tif (tech.getMinutesLeft() <= 0) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+            if (tech.getMinutesLeft() <= 0) {\n+                continue;\n+            }\n \n-\t\t\tif (warehouseMode && !tech.isRightTechTypeFor(partWork)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+            if (warehouseMode && !tech.isRightTechTypeFor(partWork)) {\n+                continue;\n+            }\n \n-\t\t\tSkill skill = tech.getSkillForWorkingOn(partWork);\n+            Skill skill = tech.getSkillForWorkingOn(partWork);\n \n-\t\t\tif (null == skill) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+            if (null == skill) {\n+                continue;\n+            }\n \n-\t\t\tif (mro.getSkillMin() > skill.getExperienceLevel()) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+            if (mro.getSkillMin() > skill.getExperienceLevel()) {\n+                continue;\n+            }\n \n-\t\t\tif (mro.getSkillMax() < skill.getExperienceLevel()) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+            if (mro.getSkillMax() < skill.getExperienceLevel()) {\n+                continue;\n+            }\n \n-\t\t\tif (partWork.getSkillMin() > skill.getExperienceLevel()) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+            if (partWork.getSkillMin() > skill.getExperienceLevel()) {\n+                continue;\n+            }\n \n-\t\t\t// Check if we can actually even repair this part\n-\t\t\tTargetRoll targetRoll = campaign.getTargetFor(partWork, tech);\n+            // Check if we can actually even repair this part\n+            TargetRoll targetRoll = campaign.getTargetFor(partWork, tech);\n \n-\t\t\tif ((targetRoll.getValue() == TargetRoll.IMPOSSIBLE) || (targetRoll.getValue() == TargetRoll.AUTOMATIC_FAIL)\n-\t\t\t\t\t|| (targetRoll.getValue() == TargetRoll.CHECK_FALSE)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+            if ((targetRoll.getValue() == TargetRoll.IMPOSSIBLE) || (targetRoll.getValue() == TargetRoll.AUTOMATIC_FAIL)\n+                    || (targetRoll.getValue() == TargetRoll.CHECK_FALSE)) {\n+                continue;\n+            }\n \n-\t\t\tvalidTechs.add(tech);\n-\t\t}\n+            validTechs.add(tech);\n+        }\n \n-\t\treturn validTechs;\n-\t}\n+        return validTechs;\n+    }\n \n-\tprivate static boolean checkArmorSupply(IPartWork part) {\n-\t\tif (part.isSalvaging()) {\n-\t\t\treturn true;\n-\t\t}\n+    private static boolean checkArmorSupply(IPartWork part) {\n+        if (part.isSalvaging()) {\n+            return true;\n+        }\n \n-\t\tif ((part instanceof Armor) && !((Armor) part).isInSupply()) {\n-\t\t\treturn false;\n-\t\t}\n+        if ((part instanceof Armor) && !((Armor) part).isInSupply()) {\n+            return false;\n+        }\n \n-\t\treturn true;\n-\t}\n+        return true;\n+    }\n \n-\tprivate static WorkTimeCalculation calculateNewMassRepairWorktime(IPartWork partWork, Person tech,\n-\t\t\tMassRepairOption mro, Campaign campaign, boolean increaseTime, int highestAvailableTechSkill) {\n-\t\tlong time = System.nanoTime();\n+    private static WorkTimeCalculation calculateNewMassRepairWorktime(IPartWork partWork, Person tech,\n+            MassRepairOption mro, Campaign campaign, boolean increaseTime, int highestAvailableTechSkill) {\n+        long time = System.nanoTime();\n \n-\t\tdebugLog(\"...... starting calculateNewMassRepairWorktime\", \"calculateNewMassRepairWorktime\");\n+        debugLog(\"...... starting calculateNewMassRepairWorktime\", \"calculateNewMassRepairWorktime\");\n \n-\t\tif (partWork instanceof Part) {\n-\t\t\t((Part) partWork).resetModeToNormal();\n-\t\t}\n+        if (partWork instanceof Part) {\n+            ((Part) partWork).resetModeToNormal();\n+        }\n \n-\t\tTargetRoll targetRoll = campaign.getTargetFor(partWork, tech);\n+        TargetRoll targetRoll = campaign.getTargetFor(partWork, tech);\n \n-\t\tif ((targetRoll.getValue() == TargetRoll.IMPOSSIBLE) || (targetRoll.getValue() == TargetRoll.AUTOMATIC_FAIL)\n-\t\t\t\t|| (targetRoll.getValue() == TargetRoll.CHECK_FALSE)) {\n-\t\t\tdebugLog(\"...... ending calculateNewMassRepairWorktime due to impossible role - %s ns\", \"calculateNewMassRepairWorktime\",\n-\t\t\t\t\tSystem.nanoTime() - time);\n+        if ((targetRoll.getValue() == TargetRoll.IMPOSSIBLE) || (targetRoll.getValue() == TargetRoll.AUTOMATIC_FAIL)\n+                || (targetRoll.getValue() == TargetRoll.CHECK_FALSE)) {\n+            debugLog(\"...... ending calculateNewMassRepairWorktime due to impossible role - %s ns\", \"calculateNewMassRepairWorktime\",\n+                    System.nanoTime() - time);\n \n-\t\t\treturn new WorkTimeCalculation();\n-\t\t}\n+            return new WorkTimeCalculation();\n+        }\n \n-\t\tWorkTime newWorkTime = partWork.getMode();\n-\t\tWorkTime previousNewWorkTime = newWorkTime;\n+        WorkTime newWorkTime = partWork.getMode();\n+        WorkTime previousNewWorkTime = newWorkTime;\n \n-\t\tSkill skill = tech.getSkillForWorkingOn(partWork);\n+        Skill skill = tech.getSkillForWorkingOn(partWork);\n \n-\t\twhile (null != newWorkTime) {\n-\t\t\tpreviousNewWorkTime = newWorkTime;\n-\t\t\tnewWorkTime = newWorkTime.moveTimeToNextLevel(increaseTime);\n+        while (null != newWorkTime) {\n+            previousNewWorkTime = newWorkTime;\n+            newWorkTime = newWorkTime.moveTimeToNextLevel(increaseTime);\n \n-\t\t\tdebugLog(\"...... looping workTime check. NewWorkTime: %s, PreviousWorkTime: %s\", \"calculateNewMassRepairWorktime\",\n-\t\t\t\t\t(null == newWorkTime ? \"NULL\" : newWorkTime.name()), previousNewWorkTime.name());\n+            debugLog(\"...... looping workTime check. NewWorkTime: %s, PreviousWorkTime: %s\", \"calculateNewMassRepairWorktime\",\n+                    (null == newWorkTime ? \"NULL\" : newWorkTime.name()), previousNewWorkTime.name());\n \n-\t\t\t// If we're trying to a rush a job, our effective skill goes down\n-\t\t\t// Let's make sure we don't put it so high that we can't fix it\n-\t\t\t// anymore\n-\t\t\tif (!increaseTime) {\n-\t\t\t\tint modePenalty = partWork.getMode().expReduction;\n+            // If we're trying to a rush a job, our effective skill goes down\n+            // Let's make sure we don't put it so high that we can't fix it\n+            // anymore\n+            if (!increaseTime) {\n+                int modePenalty = partWork.getMode().expReduction;\n \n-\t\t\t\tif (partWork.getSkillMin() > (skill.getExperienceLevel() - modePenalty)) {\n-\t\t\t\t\tdebugLog(\n-\t\t\t\t\t\t\t\"...... ending calculateNewMassRepairWorktime with previousWorkTime due time reduction skill mod now being less that required skill - %s ns\", \"calculateNewMassRepairWorktime\",\n-\t\t\t\t\t\t\tSystem.nanoTime() - time);\n+                if (partWork.getSkillMin() > (skill.getExperienceLevel() - modePenalty)) {\n+                    debugLog(\n+                            \"...... ending calculateNewMassRepairWorktime with previousWorkTime due time reduction skill mod now being less that required skill - %s ns\", \"calculateNewMassRepairWorktime\",\n+                            System.nanoTime() - time);\n \n-\t\t\t\t\treturn new WorkTimeCalculation(previousNewWorkTime);\n-\t\t\t\t}\n-\t\t\t}\n+                    return new WorkTimeCalculation(previousNewWorkTime);\n+                }\n+            }\n \n-\t\t\t// If we have a null newWorkTime, we're done. Use the previous one.\n-\t\t\tif (null == newWorkTime) {\n-\t\t\t\tdebugLog(\"...... ending calculateNewMassRepairWorktime because newWorkTime is null - %s ns\", \"calculateNewMassRepairWorktime\",\n-\t\t\t\t\t\tSystem.nanoTime() - time);\n+            // If we have a null newWorkTime, we're done. Use the previous one.\n+            if (null == newWorkTime) {\n+                debugLog(\"...... ending calculateNewMassRepairWorktime because newWorkTime is null - %s ns\", \"calculateNewMassRepairWorktime\",\n+                        System.nanoTime() - time);\n \n-\t\t\t\tif (!increaseTime) {\n-\t\t\t\t\treturn new WorkTimeCalculation(previousNewWorkTime);\n-\t\t\t\t}\n+                if (!increaseTime) {\n+                    return new WorkTimeCalculation(previousNewWorkTime);\n+                }\n \n-\t\t\t\tWorkTimeCalculation wtc = new WorkTimeCalculation(null);\n+                WorkTimeCalculation wtc = new WorkTimeCalculation(null);\n \n-\t\t\t\tif (skill.getExperienceLevel() >= highestAvailableTechSkill) {\n-\t\t\t\t\twtc.setReachedMaxSkill(true);\n-\t\t\t\t}\n+                if (skill.getExperienceLevel() >= highestAvailableTechSkill) {\n+                    wtc.setReachedMaxSkill(true);\n+                }\n \n-\t\t\t\treturn wtc;\n-\t\t\t}\n+                return wtc;\n+            }\n \n-\t\t\t// Set our new workTime and calculate the new targetRoll\n-\t\t\tif (partWork instanceof Part) {\n-\t\t\t\t((Part) partWork).setMode(newWorkTime);\n-\t\t\t}\n+            // Set our new workTime and calculate the new targetRoll\n+            if (partWork instanceof Part) {\n+                ((Part) partWork).setMode(newWorkTime);\n+            }\n \n-\t\t\ttargetRoll = campaign.getTargetFor(partWork, tech);\n+            targetRoll = campaign.getTargetFor(partWork, tech);\n \n-\t\t\t// If our roll is impossible, revert to the previous one\n-\t\t\tif ((targetRoll.getValue() == TargetRoll.IMPOSSIBLE) || (targetRoll.getValue() == TargetRoll.AUTOMATIC_FAIL)\n-\t\t\t\t\t|| (targetRoll.getValue() == TargetRoll.CHECK_FALSE)) {\n-\t\t\t\tdebugLog(\"...... ending calculateNewMassRepairWorktime due to impossible role - %s ns\", \"calculateNewMassRepairWorktime\",\n-\t\t\t\t\t\tSystem.nanoTime() - time);\n-\n-\t\t\t\treturn new WorkTimeCalculation(previousNewWorkTime);\n-\t\t\t}\n+            // If our roll is impossible, revert to the previous one\n+            if ((targetRoll.getValue() == TargetRoll.IMPOSSIBLE) || (targetRoll.getValue() == TargetRoll.AUTOMATIC_FAIL)\n+                    || (targetRoll.getValue() == TargetRoll.CHECK_FALSE)) {\n+                debugLog(\"...... ending calculateNewMassRepairWorktime due to impossible role - %s ns\", \"calculateNewMassRepairWorktime\",\n+                        System.nanoTime() - time);\n+\n+                return new WorkTimeCalculation(previousNewWorkTime);\n+            }\n \n-\t\t\tif (increaseTime) {\n-\t\t\t\t// If we've reached our BTH, kick out. Otherwise we'll loop\n-\t\t\t\t// around again\n-\t\t\t\tif (targetRoll.getValue() <= mro.getBthMin()) {\n-\t\t\t\t\tdebugLog(\n-\t\t\t\t\t\t\t\"...... ending calculateNewMassRepairWorktime because we have reached our BTH goal - %s ns\", \"calculateNewMassRepairWorktime\",\n-\t\t\t\t\t\t\tSystem.nanoTime() - time);\n-\n-\t\t\t\t\treturn new WorkTimeCalculation(newWorkTime);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tif (targetRoll.getValue() > mro.getBthMax()) {\n-\t\t\t\t\tdebugLog(\n-\t\t\t\t\t\t\t\"...... ending calculateNewMassRepairWorktime because we have reached our BTH goal - %s ns\", \"calculateNewMassRepairWorktime\",\n-\t\t\t\t\t\t\tSystem.nanoTime() - time);\n+            if (increaseTime) {\n+                // If we've reached our BTH, kick out. Otherwise we'll loop\n+                // around again\n+                if (targetRoll.getValue() <= mro.getBthMin()) {\n+                    debugLog(\n+                            \"...... ending calculateNewMassRepairWorktime because we have reached our BTH goal - %s ns\", \"calculateNewMassRepairWorktime\",\n+                            System.nanoTime() - time);\n+\n+                    return new WorkTimeCalculation(newWorkTime);\n+                }\n+            } else {\n+                if (targetRoll.getValue() > mro.getBthMax()) {\n+                    debugLog(\n+                            \"...... ending calculateNewMassRepairWorktime because we have reached our BTH goal - %s ns\", \"calculateNewMassRepairWorktime\",\n+                            System.nanoTime() - time);\n \n-\t\t\t\t\treturn new WorkTimeCalculation(previousNewWorkTime);\n-\t\t\t\t} else if (targetRoll.getValue() > mro.getBthMax()) {\n-\t\t\t\t\tdebugLog(\n-\t\t\t\t\t\t\t\"...... ending calculateNewMassRepairWorktime because we have reached our BTH goal - %s ns\", \"calculateNewMassRepairWorktime\",\n-\t\t\t\t\t\t\tSystem.nanoTime() - time);\n+                    return new WorkTimeCalculation(previousNewWorkTime);\n+                } else if (targetRoll.getValue() > mro.getBthMax()) {\n+                    debugLog(\n+                            \"...... ending calculateNewMassRepairWorktime because we have reached our BTH goal - %s ns\", \"calculateNewMassRepairWorktime\",\n+                            System.nanoTime() - time);\n \n-\t\t\t\t\treturn new WorkTimeCalculation(newWorkTime);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+                    return new WorkTimeCalculation(newWorkTime);\n+                }\n+            }\n+        }\n \n-\t\treturn new WorkTimeCalculation();\n-\t}\n-\n-\tprivate static void debugLog(String msg, String methodName, Object... replacements) {\n-\t\tif ((null != replacements) && (replacements.length > 0)) {\n-\t\t\tmsg = String.format(msg, replacements);\n-\t\t}\n+        return new WorkTimeCalculation();\n+    }\n+\n+    private static void debugLog(String msg, String methodName, Object... replacements) {\n+        if ((null != replacements) && (replacements.length > 0)) {\n+            msg = String.format(msg, replacements);\n+        }\n \n-\t\tMekHQ.getLogger().log(MassRepairService.class, methodName, LogLevel.DEBUG, msg);\n-\t}\n-\n-\tprivate static class WorkTimeCalculation {\n-\t\tprivate WorkTime workTime = WorkTime.NORMAL;\n-\t\tprivate boolean reachedMaxSkill = false;\n-\n-\t\tpublic WorkTimeCalculation() {\n-\n-\t\t}\n-\n-\t\tpublic WorkTimeCalculation(WorkTime workTime) {\n-\t\t\tthis.workTime = workTime;\n-\t\t}\n-\n-\t\tpublic WorkTime getWorkTime() {\n-\t\t\treturn workTime;\n-\t\t}\n-\n-\t\tpublic boolean isReachedMaxSkill() {\n-\t\t\treturn reachedMaxSkill;\n-\t\t}\n-\n-\t\tpublic void setReachedMaxSkill(boolean reachedMaxSkill) {\n-\t\t\tthis.reachedMaxSkill = reachedMaxSkill;\n-\t\t}\n-\t}\n-\n-\tprivate static class TechSorter implements Comparator<Person> {\n-\t\tprivate IPartWork partWork = null;\n-\n-\t\tpublic TechSorter(IPartWork _part) {\n-\t\t\tthis.partWork = _part;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int compare(Person tech1, Person tech2) {\n-\t\t\t/*\n-\t\t\t * Sort the valid techs by applicable skill. Let's start with the\n-\t\t\t * least experienced and work our way up until we find someone who\n-\t\t\t * can perform the work. If we have two techs with the same skill,\n-\t\t\t * put the one with the lesser XP in the front. If we have techs\n-\t\t\t * with the same XP, put the one with the more time ahead.\n-\t\t\t */\n-\n-\t\t\tSkill skill1 = tech1.getSkillForWorkingOn(partWork);\n-\t\t\tSkill skill2 = tech2.getSkillForWorkingOn(partWork);\n-\n-\t\t\tif (skill1.getExperienceLevel() == skill2.getExperienceLevel()) {\n-\t\t\t\tif ((tech1.getXp() == tech2.getXp()) || (skill1.getLevel() == SkillType.EXP_ELITE)) {\n-\t\t\t\t\treturn tech1.getMinutesLeft() - tech2.getMinutesLeft();\n-\t\t\t\t}\n-\n-\t\t\t\treturn tech1.getXp() < tech2.getXp() ? -1 : 1;\n-\t\t\t}\n-\n-\t\t\treturn skill1.getExperienceLevel() < skill2.getExperienceLevel() ? -1 : 1;\n-\t\t}\n-\t}\n-\n-\tpublic static class MassRepairPartAction {\n-\t\tpublic enum STATUS {\n-\t\t\tREPAIRED, MAX_SKILL_REACHED, MRO_DISABLED, NO_TECHS\n-\t\t}\n-\n-\t\tprivate IPartWork partWork;\n-\t\tprivate STATUS status;\n-\t\tprivate int maxTechSkill;\n-\t\tprivate int configuredBTHMin;\n-\n-\t\tpublic MassRepairPartAction() {\n+        MekHQ.getLogger().log(MassRepairService.class, methodName, LogLevel.DEBUG, msg);\n+    }\n+\n+    private static class WorkTimeCalculation {\n+        private WorkTime workTime = WorkTime.NORMAL;\n+        private boolean reachedMaxSkill = false;\n+\n+        public WorkTimeCalculation() {\n+\n+        }\n+\n+        public WorkTimeCalculation(WorkTime workTime) {\n+            this.workTime = workTime;\n+        }\n+\n+        public WorkTime getWorkTime() {\n+            return workTime;\n+        }\n+\n+        public boolean isReachedMaxSkill() {\n+            return reachedMaxSkill;\n+        }\n+\n+        public void setReachedMaxSkill(boolean reachedMaxSkill) {\n+            this.reachedMaxSkill = reachedMaxSkill;\n+        }\n+    }\n+\n+    private static class TechSorter implements Comparator<Person> {\n+        private IPartWork partWork = null;\n+\n+        public TechSorter(IPartWork _part) {\n+            this.partWork = _part;\n+        }\n+\n+        @Override\n+        public int compare(Person tech1, Person tech2) {\n+            /*\n+             * Sort the valid techs by applicable skill. Let's start with the\n+             * least experienced and work our way up until we find someone who\n+             * can perform the work. If we have two techs with the same skill,\n+             * put the one with the lesser XP in the front. If we have techs\n+             * with the same XP, put the one with the more time ahead.\n+             */\n+\n+            Skill skill1 = tech1.getSkillForWorkingOn(partWork);\n+            Skill skill2 = tech2.getSkillForWorkingOn(partWork);\n+\n+            if (skill1.getExperienceLevel() == skill2.getExperienceLevel()) {\n+                if ((tech1.getXp() == tech2.getXp()) || (skill1.getLevel() == SkillType.EXP_ELITE)) {\n+                    return tech1.getMinutesLeft() - tech2.getMinutesLeft();\n+                }\n+\n+                return tech1.getXp() < tech2.getXp() ? -1 : 1;\n+            }\n+\n+            return skill1.getExperienceLevel() < skill2.getExperienceLevel() ? -1 : 1;\n+        }\n+    }\n+\n+    public static class MassRepairPartAction {\n+        public enum STATUS {\n+            REPAIRED, MAX_SKILL_REACHED, MRO_DISABLED, NO_TECHS\n+        }\n+\n+        private IPartWork partWork;\n+        private STATUS status;\n+        private int maxTechSkill;\n+        private int configuredBTHMin;\n+\n+        public MassRepairPartAction() {\n \n-\t\t}\n-\n-\t\tpublic MassRepairPartAction(IPartWork partWork) {\n-\t\t\tthis.partWork = partWork;\n-\t\t}\n+        }\n+\n+        public MassRepairPartAction(IPartWork partWork) {\n+            this.partWork = partWork;\n+        }\n \n-\t\tpublic MassRepairPartAction(IPartWork partWork, STATUS status) {\n-\t\t\tthis(partWork);\n+        public MassRepairPartAction(IPartWork partWork, STATUS status) {\n+            this(partWork);\n \n-\t\t\tthis.status = status;\n-\t\t}\n+            this.status = status;\n+        }\n \n-\t\tpublic IPartWork getPartWork() {\n-\t\t\treturn partWork;\n-\t\t}\n+        public IPartWork getPartWork() {\n+            return partWork;\n+        }\n \n-\t\tpublic void setPartWork(IPartWork partWork) {\n-\t\t\tthis.partWork = partWork;\n-\t\t}\n+        public void setPartWork(IPartWork partWork) {\n+            this.partWork = partWork;\n+        }\n \n-\t\tpublic STATUS getStatus() {\n-\t\t\treturn status;\n-\t\t}\n+        public STATUS getStatus() {\n+            return status;\n+        }\n \n-\t\tpublic void setStatus(STATUS status) {\n-\t\t\tthis.status = status;\n-\t\t}\n+        public void setStatus(STATUS status) {\n+            this.status = status;\n+        }\n \n-\t\tpublic boolean isStatusRepaired() {\n-\t\t\treturn status == STATUS.REPAIRED;\n-\t\t}\n+        public boolean isStatusRepaired() {\n+            return status == STATUS.REPAIRED;\n+        }\n \n-\t\tpublic boolean isStatusMaxSkillReached() {\n-\t\t\treturn status == STATUS.MAX_SKILL_REACHED;\n-\t\t}\n+        public boolean isStatusMaxSkillReached() {\n+            return status == STATUS.MAX_SKILL_REACHED;\n+        }\n \n-\t\tpublic boolean isStatusOptionDisabled() {\n-\t\t\treturn status == STATUS.MRO_DISABLED;\n-\t\t}\n+        public boolean isStatusOptionDisabled() {\n+            return status == STATUS.MRO_DISABLED;\n+        }\n \n-\t\tpublic boolean isStatusNoTechs() {\n-\t\t\treturn status == STATUS.NO_TECHS;\n-\t\t}\n+        public boolean isStatusNoTechs() {\n+            return status == STATUS.NO_TECHS;\n+        }\n \n-\t\tpublic int getMaxTechSkill() {\n-\t\t\treturn maxTechSkill;\n-\t\t}\n+        public int getMaxTechSkill() {\n+            return maxTechSkill;\n+        }\n \n-\t\tpublic void setMaxTechSkill(int maxTechSkill) {\n-\t\t\tthis.maxTechSkill = maxTechSkill;\n-\t\t}\n+        public void setMaxTechSkill(int maxTechSkill) {\n+            this.maxTechSkill = maxTechSkill;\n+        }\n \n-\t\tpublic int getConfiguredBTHMin() {\n-\t\t\treturn configuredBTHMin;\n-\t\t}\n+        public int getConfiguredBTHMin() {\n+            return configuredBTHMin;\n+        }\n \n-\t\tpublic void setConfiguredBTHMin(int configuredBTHMin) {\n-\t\t\tthis.configuredBTHMin = configuredBTHMin;\n-\t\t}\n+        public void setConfiguredBTHMin(int configuredBTHMin) {\n+            this.configuredBTHMin = configuredBTHMin;\n+        }\n \n-\t\tpublic static MassRepairPartAction createRepaired(IPartWork partWork) {\n-\t\t\treturn new MassRepairPartAction(partWork, STATUS.REPAIRED);\n-\t\t}\n+        public static MassRepairPartAction createRepaired(IPartWork partWork) {\n+            return new MassRepairPartAction(partWork, STATUS.REPAIRED);\n+        }\n \n-\t\tpublic static MassRepairPartAction createMaxSkillReached(IPartWork partWork, int maxSkill, int bthMin) {\n-\t\t\tMassRepairPartAction mrpa = new MassRepairPartAction(partWork, STATUS.MAX_SKILL_REACHED);\n-\t\t\tmrpa.setMaxTechSkill(maxSkill);\n-\t\t\tmrpa.setConfiguredBTHMin(bthMin);\n+        public static MassRepairPartAction createMaxSkillReached(IPartWork partWork, int maxSkill, int bthMin) {\n+            MassRepairPartAction mrpa = new MassRepairPartAction(partWork, STATUS.MAX_SKILL_REACHED);\n+            mrpa.setMaxTechSkill(maxSkill);\n+            mrpa.setConfiguredBTHMin(bthMin);\n \n-\t\t\treturn mrpa;\n-\t\t}\n+            return mrpa;\n+        }\n \n-\t\tpublic static MassRepairPartAction createOptionDisabled(IPartWork partWork) {\n-\t\t\treturn new MassRepairPartAction(partWork, STATUS.MRO_DISABLED);\n-\t\t}\n+        public static MassRepairPartAction createOptionDisabled(IPartWork partWork) {\n+            return new MassRepairPartAction(partWork, STATUS.MRO_DISABLED);\n+        }\n \n-\t\tpublic static MassRepairPartAction createNoTechs(IPartWork partWork) {\n-\t\t\treturn new MassRepairPartAction(partWork, STATUS.NO_TECHS);\n-\t\t}\n-\t}\n+        public static MassRepairPartAction createNoTechs(IPartWork partWork) {\n+            return new MassRepairPartAction(partWork, STATUS.NO_TECHS);\n+        }\n+    }\n \n-\tpublic static class MassRepairPartSet {\n-\t\tprivate Map<MassRepairPartAction.STATUS, List<MassRepairPartAction>> partActionsByStatus = new HashMap<MassRepairPartAction.STATUS, List<MassRepairPartAction>>();\n+    public static class MassRepairPartSet {\n+        private Map<MassRepairPartAction.STATUS, List<MassRepairPartAction>> partActionsByStatus = new HashMap<MassRepairPartAction.STATUS, List<MassRepairPartAction>>();\n \n-\t\tpublic void addPartAction(MassRepairPartAction partAction) {\n-\t\t\tif (null == partAction) {\n-\t\t\t\treturn;\n-\t\t\t}\n+        public void addPartAction(MassRepairPartAction partAction) {\n+            if (null == partAction) {\n+                return;\n+            }\n \n-\t\t\tList<MassRepairPartAction> list = partActionsByStatus.get(partAction.getStatus());\n+            List<MassRepairPartAction> list = partActionsByStatus.get(partAction.getStatus());\n \n-\t\t\tif (null == list) {\n-\t\t\t\tlist = new ArrayList<MassRepairPartAction>();\n-\t\t\t\tpartActionsByStatus.put(partAction.getStatus(), list);\n-\t\t\t}\n+            if (null == list) {\n+                list = new ArrayList<MassRepairPartAction>();\n+                partActionsByStatus.put(partAction.getStatus(), list);\n+            }\n \n-\t\t\tlist.add(partAction);\n-\t\t}\n+            list.add(partAction);\n+        }\n \n-\t\tpublic Map<MassRepairPartAction.STATUS, List<MassRepairPartAction>> getPartActions() {\n-\t\t\treturn partActionsByStatus;\n-\t\t}\n+        public Map<MassRepairPartAction.STATUS, List<MassRepairPartAction>> getPartActions() {\n+            return partActionsByStatus;\n+        }\n \n-\t\tpublic boolean isHasRepairs() {\n-\t\t\treturn partActionsByStatus.containsKey(MassRepairPartAction.STATUS.REPAIRED);\n-\t\t}\n+        public boolean isHasRepairs() {\n+            return partActionsByStatus.containsKey(MassRepairPartAction.STATUS.REPAIRED);\n+        }\n \n-\t\tpublic int countRepairs() {\n-\t\t\tif (!isHasRepairs()) {\n-\t\t\t\treturn 0;\n-\t\t\t}\n+        public int countRepairs() {\n+            if (!isHasRepairs()) {\n+                return 0;\n+            }\n \n-\t\t\treturn partActionsByStatus.get(MassRepairPartAction.STATUS.REPAIRED).size();\n-\t\t}\n-\n-\t\tpublic boolean isOnlyNoTechs() {\n-\t\t\tif (!partActionsByStatus.containsKey(MassRepairPartAction.STATUS.NO_TECHS)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\tif (partActionsByStatus.size() > 1) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\tpublic static class MassRepairUnitAction {\n-\t\tpublic enum STATUS {\n-\t\t\tNO_ACTIONS, ACTIONS_PERFORMED, NO_TECHS, UNFIXABLE_LIMB, NO_PARTS, ALL_PARTS_IN_PROCESS\n-\t\t}\n-\n-\t\tprivate Unit unit;\n-\t\tprivate MassRepairPartSet partSet = new MassRepairPartSet();\n-\t\tprivate STATUS status;\n-\t\tprivate boolean salvaging;\n-\n-\t\tpublic MassRepairUnitAction() {\n-\n-\t\t}\n-\n-\t\tpublic MassRepairUnitAction(Unit unit, boolean salvaging, STATUS status) {\n-\t\t\tthis.unit = unit;\n-\t\t\tthis.salvaging = salvaging;\n-\t\t\tthis.status = status;\n-\t\t}\n-\n-\t\tpublic Unit getUnit() {\n-\t\t\treturn unit;\n-\t\t}\n-\n-\t\tpublic void setUnit(Unit unit) {\n-\t\t\tthis.unit = unit;\n-\t\t}\n-\n-\t\tpublic MassRepairPartSet getPartSet() {\n-\t\t\treturn partSet;\n-\t\t}\n-\n-\t\tpublic void setPartSet(MassRepairPartSet partSet) {\n-\t\t\tthis.partSet = partSet;\n-\t\t}\n-\n-\t\tpublic STATUS getStatus() {\n-\t\t\treturn status;\n-\t\t}\n-\n-\t\tpublic void setStatus(STATUS status) {\n-\t\t\tthis.status = status;\n-\t\t}\n-\n-\t\tpublic boolean isSalvaging() {\n-\t\t\treturn salvaging;\n-\t\t}\n-\n-\t\tpublic void setSalvaging(boolean salvaging) {\n-\t\t\tthis.salvaging = salvaging;\n-\t\t}\n-\n-\t\tpublic boolean isStatusNoActions() {\n-\t\t\treturn status == STATUS.NO_ACTIONS;\n-\t\t}\n-\n-\t\tpublic boolean isStatusActionsPerformed() {\n-\t\t\treturn status == STATUS.ACTIONS_PERFORMED;\n-\t\t}\n-\n-\t\tpublic boolean isStatusNoTechs() {\n-\t\t\treturn status == STATUS.NO_TECHS;\n-\t\t}\n-\n-\t\tpublic boolean isStatusUnfixableLimb() {\n-\t\t\treturn status == STATUS.UNFIXABLE_LIMB;\n-\t\t}\n-\n-\t\tpublic boolean isStatusNoParts() {\n-\t\t\treturn status == STATUS.NO_PARTS;\n-\t\t}\n-\n-\t\tpublic void addPartAction(MassRepairPartAction partAction) {\n-\t\t\tpartSet.addPartAction(partAction);\n-\t\t}\n-\n-\t\tpublic void resetPartSet() {\n-\t\t\tpartSet = new MassRepairPartSet();\n-\t\t}\n-\n-\t\tpublic void merge(MassRepairUnitAction currentUnitAction) {\n-\t\t\tfor (List<MassRepairPartAction> partActionList : currentUnitAction.getPartSet().getPartActions().values()) {\n-\t\t\t\tfor (MassRepairPartAction partAction : partActionList) {\n-\t\t\t\t\tgetPartSet().addPartAction(partAction);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic static class MassRepairConfiguredOptions {\n-\t\tprivate boolean useExtraTime;\n-\t\tprivate boolean useRushJob;\n-\t\tprivate boolean allowCarryover;\n-\t\tprivate boolean optimizeToCompleteToday;\n-\t\tprivate boolean useAssignedTechsFirst;\n-\t\tprivate boolean scrapImpossible;\n-\t\tprivate boolean replacePodParts;\n-\n-\t\tpublic boolean isUseExtraTime() {\n-\t\t\treturn useExtraTime;\n-\t\t}\n-\n-\t\tpublic void setUseExtraTime(boolean useExtraTime) {\n-\t\t\tthis.useExtraTime = useExtraTime;\n-\t\t}\n-\n-\t\tpublic boolean isUseRushJob() {\n-\t\t\treturn useRushJob;\n-\t\t}\n-\n-\t\tpublic void setUseRushJob(boolean useRushJob) {\n-\t\t\tthis.useRushJob = useRushJob;\n-\t\t}\n-\n-\t\tpublic boolean isAllowCarryover() {\n-\t\t\treturn allowCarryover;\n-\t\t}\n-\n-\t\tpublic void setAllowCarryover(boolean allowCarryover) {\n-\t\t\tthis.allowCarryover = allowCarryover;\n-\t\t}\n-\n-\t\tpublic boolean isOptimizeToCompleteToday() {\n-\t\t\treturn optimizeToCompleteToday;\n-\t\t}\n-\n-\t\tpublic void setOptimizeToCompleteToday(boolean optimizeToCompleteToday) {\n-\t\t\tthis.optimizeToCompleteToday = optimizeToCompleteToday;\n-\t\t}\n-\n-\t\tpublic boolean isUseAssignedTechsFirst() {\n-\t\t\treturn useAssignedTechsFirst;\n-\t\t}\n-\n-\t\tpublic void setUseAssignedTechsFirst(boolean useAssignedTechsFirst) {\n-\t\t\tthis.useAssignedTechsFirst = useAssignedTechsFirst;\n-\t\t}\n-\n-\t\tpublic boolean isScrapImpossible() {\n-\t\t\treturn scrapImpossible;\n-\t\t}\n-\n-\t\tpublic void setScrapImpossible(boolean scrapImpossible) {\n-\t\t\tthis.scrapImpossible = scrapImpossible;\n-\t\t}\n-\n-\t\tpublic boolean isReplacePodParts() {\n-\t\t\treturn replacePodParts;\n-\t\t}\n-\n-\t\tpublic void setReplacePodParts(boolean replacePodParts) {\n-\t\t\tthis.replacePodParts = replacePodParts;\n-\t\t}\n-\n-\t\tpublic void setup(CampaignOptions options) {\n-\t\t\tsetUseExtraTime(options.massRepairUseExtraTime());\n-\t\t\tsetUseRushJob(options.massRepairUseRushJob());\n-\t\t\tsetAllowCarryover(options.massRepairAllowCarryover());\n-\t\t\tsetOptimizeToCompleteToday(options.massRepairOptimizeToCompleteToday());\n-\t\t\tsetScrapImpossible(options.massRepairScrapImpossible());\n-\t\t\tsetUseAssignedTechsFirst(options.massRepairUseAssignedTechsFirst());\n-\t\t\tsetReplacePodParts(options.massRepairReplacePod());\n-\t\t}\n-\n-\t\tpublic void setup(MassRepairSalvageDialog dlg) {\n-\t\t\tsetUseExtraTime(dlg.getUseExtraTimeBox().isSelected());\n-\t\t\tsetUseRushJob(dlg.getUseRushJobBox().isSelected());\n-\t\t\tsetAllowCarryover(dlg.getAllowCarryoverBox().isSelected());\n-\t\t\tsetOptimizeToCompleteToday(dlg.getOptimizeToCompleteTodayBox().isSelected());\n-\n-\t\t\tif (null != dlg.getScrapImpossibleBox()) {\n-\t\t\t\tsetScrapImpossible(dlg.getScrapImpossibleBox().isSelected());\n-\t\t\t}\n-\n-\t\t\tif (null != dlg.getUseAssignedTechsFirstBox()) {\n-\t\t\t\tsetUseAssignedTechsFirst(dlg.getUseAssignedTechsFirstBox().isSelected());\n-\t\t\t}\n-\n-\t\t\tif (null != dlg.getReplacePodPartsBox()) {\n-\t\t\t\tsetReplacePodParts(dlg.getReplacePodPartsBox().isSelected());\n-\t\t\t}\n-\t\t}\n-\t}\n+            return partActionsByStatus.get(MassRepairPartAction.STATUS.REPAIRED).size();\n+        }\n+\n+        public boolean isOnlyNoTechs() {\n+            if (!partActionsByStatus.containsKey(MassRepairPartAction.STATUS.NO_TECHS)) {\n+                return false;\n+            }\n+\n+            if (partActionsByStatus.size() > 1) {\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    }\n+\n+    public static class MassRepairUnitAction {\n+        public enum STATUS {\n+            NO_ACTIONS, ACTIONS_PERFORMED, NO_TECHS, UNFIXABLE_LIMB, NO_PARTS, ALL_PARTS_IN_PROCESS\n+        }\n+\n+        private Unit unit;\n+        private MassRepairPartSet partSet = new MassRepairPartSet();\n+        private STATUS status;\n+        private boolean salvaging;\n+\n+        public MassRepairUnitAction() {\n+\n+        }\n+\n+        public MassRepairUnitAction(Unit unit, boolean salvaging, STATUS status) {\n+            this.unit = unit;\n+            this.salvaging = salvaging;\n+            this.status = status;\n+        }\n+\n+        public Unit getUnit() {\n+            return unit;\n+        }\n+\n+        public void setUnit(Unit unit) {\n+            this.unit = unit;\n+        }\n+\n+        public MassRepairPartSet getPartSet() {\n+            return partSet;\n+        }\n+\n+        public void setPartSet(MassRepairPartSet partSet) {\n+            this.partSet = partSet;\n+        }\n+\n+        public STATUS getStatus() {\n+            return status;\n+        }\n+\n+        public void setStatus(STATUS status) {\n+            this.status = status;\n+        }\n+\n+        public boolean isSalvaging() {\n+            return salvaging;\n+        }\n+\n+        public void setSalvaging(boolean salvaging) {\n+            this.salvaging = salvaging;\n+        }\n+\n+        public boolean isStatusNoActions() {\n+            return status == STATUS.NO_ACTIONS;\n+        }\n+\n+        public boolean isStatusActionsPerformed() {\n+            return status == STATUS.ACTIONS_PERFORMED;\n+        }\n+\n+        public boolean isStatusNoTechs() {\n+            return status == STATUS.NO_TECHS;\n+        }\n+\n+        public boolean isStatusUnfixableLimb() {\n+            return status == STATUS.UNFIXABLE_LIMB;\n+        }\n+\n+        public boolean isStatusNoParts() {\n+            return status == STATUS.NO_PARTS;\n+        }\n+\n+        public void addPartAction(MassRepairPartAction partAction) {\n+            partSet.addPartAction(partAction);\n+        }\n+\n+        public void resetPartSet() {\n+            partSet = new MassRepairPartSet();\n+        }\n+\n+        public void merge(MassRepairUnitAction currentUnitAction) {\n+            for (List<MassRepairPartAction> partActionList : currentUnitAction.getPartSet().getPartActions().values()) {\n+                for (MassRepairPartAction partAction : partActionList) {\n+                    getPartSet().addPartAction(partAction);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static class MassRepairConfiguredOptions {\n+        private boolean useExtraTime;\n+        private boolean useRushJob;\n+        private boolean allowCarryover;\n+        private boolean optimizeToCompleteToday;\n+        private boolean useAssignedTechsFirst;\n+        private boolean scrapImpossible;\n+        private boolean replacePodParts;\n+\n+        public boolean isUseExtraTime() {\n+            return useExtraTime;\n+        }\n+\n+        public void setUseExtraTime(boolean useExtraTime) {\n+            this.useExtraTime = useExtraTime;\n+        }\n+\n+        public boolean isUseRushJob() {\n+            return useRushJob;\n+        }\n+\n+        public void setUseRushJob(boolean useRushJob) {\n+            this.useRushJob = useRushJob;\n+        }\n+\n+        public boolean isAllowCarryover() {\n+            return allowCarryover;\n+        }\n+\n+        public void setAllowCarryover(boolean allowCarryover) {\n+            this.allowCarryover = allowCarryover;\n+        }\n+\n+        public boolean isOptimizeToCompleteToday() {\n+            return optimizeToCompleteToday;\n+        }\n+\n+        public void setOptimizeToCompleteToday(boolean optimizeToCompleteToday) {\n+            this.optimizeToCompleteToday = optimizeToCompleteToday;\n+        }\n+\n+        public boolean isUseAssignedTechsFirst() {\n+            return useAssignedTechsFirst;\n+        }\n+\n+        public void setUseAssignedTechsFirst(boolean useAssignedTechsFirst) {\n+            this.useAssignedTechsFirst = useAssignedTechsFirst;\n+        }\n+\n+        public boolean isScrapImpossible() {\n+            return scrapImpossible;\n+        }\n+\n+        public void setScrapImpossible(boolean scrapImpossible) {\n+            this.scrapImpossible = scrapImpossible;\n+        }\n+\n+        public boolean isReplacePodParts() {\n+            return replacePodParts;\n+        }\n+\n+        public void setReplacePodParts(boolean replacePodParts) {\n+            this.replacePodParts = replacePodParts;\n+        }\n+\n+        public void setup(CampaignOptions options) {\n+            setUseExtraTime(options.massRepairUseExtraTime());\n+            setUseRushJob(options.massRepairUseRushJob());\n+            setAllowCarryover(options.massRepairAllowCarryover());\n+            setOptimizeToCompleteToday(options.massRepairOptimizeToCompleteToday());\n+            setScrapImpossible(options.massRepairScrapImpossible());\n+            setUseAssignedTechsFirst(options.massRepairUseAssignedTechsFirst());\n+            setReplacePodParts(options.massRepairReplacePod());\n+        }\n+\n+        public void setup(MassRepairSalvageDialog dlg) {\n+            setUseExtraTime(dlg.getUseExtraTimeBox().isSelected());\n+            setUseRushJob(dlg.getUseRushJobBox().isSelected());\n+            setAllowCarryover(dlg.getAllowCarryoverBox().isSelected());\n+            setOptimizeToCompleteToday(dlg.getOptimizeToCompleteTodayBox().isSelected());\n+\n+            if (null != dlg.getScrapImpossibleBox()) {\n+                setScrapImpossible(dlg.getScrapImpossibleBox().isSelected());\n+            }\n+\n+            if (null != dlg.getUseAssignedTechsFirstBox()) {\n+                setUseAssignedTechsFirst(dlg.getUseAssignedTechsFirstBox().isSelected());\n+            }\n+\n+            if (null != dlg.getReplacePodPartsBox()) {\n+                setReplacePodParts(dlg.getReplacePodPartsBox().isSelected());\n+            }\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzNzgwMw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386137803", "bodyText": "Could this be loop local instead of an instance field?", "author": "sixlettervariables", "createdAt": "2020-03-01T20:26:59Z", "path": "MekHQ/src/mekhq/gui/view/PersonViewPanel.java", "diffHunk": "@@ -740,22 +760,52 @@ private JPanel fillFamily() {\n             lblSpouse2.addMouseListener(new MouseAdapter() {\n                 @Override\n                 public void mouseClicked(MouseEvent e) {\n-                    gui.getPersonnelTab().focusOnPerson(person.getSpouseID());\n+                    gui.getPersonnelTab().focusOnPerson(person.getSpouseId());\n                 }\n             });\n-            gridBagConstraints = new GridBagConstraints();\n             gridBagConstraints.gridx = 1;\n             gridBagConstraints.gridy = firsty;\n             gridBagConstraints.weightx = 1.0;\n             gridBagConstraints.insets = new Insets(0, 10, 0, 0);\n-            gridBagConstraints.fill = GridBagConstraints.NONE;\n-            gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;\n             pnlFamily.add(lblSpouse2, gridBagConstraints);\n             firsty++;\n         }\n \n+        if (person.hasFormerSpouse()) {\n+            lblFormerSpouses1.setName(\"lblFormerSpouses1\"); // NOI18N //$NON-NLS-1$\n+            lblFormerSpouses1.setText(resourceMap.getString(\"lblFormerSpouses1.text\")); //$NON-NLS-1$\n+            gridBagConstraints = new GridBagConstraints();\n+            gridBagConstraints.gridx = 0;\n+            gridBagConstraints.gridy = firsty;\n+            gridBagConstraints.fill = GridBagConstraints.NONE;\n+            gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;\n+            pnlFamily.add(lblFormerSpouses1, gridBagConstraints);\n+\n+            gridBagConstraints.gridx = 1;\n+            gridBagConstraints.weightx = 1.0;\n+            gridBagConstraints.insets = new Insets(0, 10, 0, 0);\n+\n+            for (FormerSpouse formerSpouse : person.getFormerSpouses()) {\n+                Person ex = campaign.getPerson(formerSpouse.getFormerSpouseId());\n+                gridBagConstraints.gridy = firsty;\n+                lblFormerSpouses2 = new JLabel();", "originalCommit": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MjkzNA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386142934", "bodyText": "It could be, I just find it cleaner listed above.", "author": "Windchild292", "createdAt": "2020-03-01T21:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzNzgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0NjgwMw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386546803", "bodyText": "I'm going to swap this out in Wave 2, and try to clean up the code here then.", "author": "Windchild292", "createdAt": "2020-03-02T17:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzNzgwMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODA0Ng==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386138046", "bodyText": "mixed tabs and spaces it appears", "author": "sixlettervariables", "createdAt": "2020-03-01T20:29:57Z", "path": "MekHQ/src/mekhq/gui/dialog/CustomizePersonDialog.java", "diffHunk": "@@ -985,14 +933,15 @@ private void randomBloodname() {\n \t\t\tphenotype = Bloodname.P_PROTOMECH;\n \t\t\tbreak;\n \t\t}\n-\t\ttextBloodname.setText(Bloodname.randomBloodname(campaign.getFactionCode(), phenotype,\n-\t\t\t\t\tcampaign.getCalendar().get(Calendar.YEAR)).getName());   \t\n+\t\ttextBloodname.setText(Bloodname.randomBloodname(campaign.getFaction().isClan()", "originalCommit": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MjI5OA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386142298", "bodyText": "Yeah, the whole file was that. Fixed now", "author": "Windchild292", "createdAt": "2020-03-01T21:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODA0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "03879772bf1717d91704f3c4d30ec875444c8dbd", "chunk": "diff --git a/MekHQ/src/mekhq/gui/dialog/CustomizePersonDialog.java b/MekHQ/src/mekhq/gui/dialog/CustomizePersonDialog.java\nindex 7ff28075a..11b350572 100644\n--- a/MekHQ/src/mekhq/gui/dialog/CustomizePersonDialog.java\n+++ b/MekHQ/src/mekhq/gui/dialog/CustomizePersonDialog.java\n\n@@ -908,47 +902,48 @@ public class CustomizePersonDialog extends javax.swing.JDialog implements Dialog\n                 person.isClanner(), person.getOriginFaction().getShortName());\n         textGivenName.setText(name[0]);\n         textSurname.setText(name[1]);\n-\t}\n+    }\n \n     private void randomBloodname() {\n-\t\tint phenotype = Bloodname.P_GENERAL;\n-\t\tswitch (person.getPrimaryRole()) {\n-\t\tcase Person.T_MECHWARRIOR:\n-\t\t\tphenotype = Bloodname.P_MECHWARRIOR;\n-\t\t\tbreak;\n-\t\tcase Person.T_BA:\n-\t\t\tphenotype = Bloodname.P_ELEMENTAL;\n-\t\t\tbreak;\n-\t\tcase Person.T_AERO_PILOT:\n-\t\tcase Person.T_CONV_PILOT:\n-\t\t\tphenotype = Bloodname.P_AEROSPACE;\n-\t\t\tbreak;\n-\t\tcase Person.T_SPACE_CREW:\n-\t\tcase Person.T_NAVIGATOR:\n-\t\tcase Person.T_SPACE_GUNNER:\n-\t\tcase Person.T_SPACE_PILOT:\n-\t\t\tphenotype = Bloodname.P_NAVAL;\n-\t\t\tbreak;\n-\t\tcase Person.T_PROTO_PILOT:\n-\t\t\tphenotype = Bloodname.P_PROTOMECH;\n-\t\t\tbreak;\n-\t\t}\n-\t\ttextBloodname.setText(Bloodname.randomBloodname(campaign.getFaction().isClan()\n+        int phenotype = Bloodname.P_GENERAL;\n+        switch (person.getPrimaryRole()) {\n+            case Person.T_MECHWARRIOR:\n+                phenotype = Bloodname.P_MECHWARRIOR;\n+                break;\n+            case Person.T_BA:\n+                phenotype = Bloodname.P_ELEMENTAL;\n+                break;\n+            case Person.T_AERO_PILOT:\n+            case Person.T_CONV_PILOT:\n+                phenotype = Bloodname.P_AEROSPACE;\n+                break;\n+            case Person.T_SPACE_CREW:\n+            case Person.T_NAVIGATOR:\n+            case Person.T_SPACE_GUNNER:\n+            case Person.T_SPACE_PILOT:\n+                phenotype = Bloodname.P_NAVAL;\n+                break;\n+            case Person.T_PROTO_PILOT:\n+                phenotype = Bloodname.P_PROTOMECH;\n+                break;\n+        }\n+        textBloodname.setText(Bloodname.randomBloodname(campaign.getFaction().isClan()\n                 ? campaign.getFactionCode() : person.getOriginFaction().getShortName(),\n                 phenotype, campaign.getCalendar().get(Calendar.YEAR)).getName());\n     }\n \n     public void refreshSkills() {\n-        ResourceBundle resourceMap = ResourceBundle.getBundle(\"mekhq.resources.CustomizePersonDialog\", new EncodeControl()); //$NON-NLS-1$\n+        ResourceBundle resourceMap = ResourceBundle.getBundle(\"mekhq.resources.CustomizePersonDialog\",\n+                new EncodeControl());\n         panSkills.removeAll();\n \n         JCheckBox chkSkill;\n         JLabel lblName;\n-\t    JLabel lblValue;\n-\t    JLabel lblLevel;\n-\t    JLabel lblBonus;\n-\t    JSpinner spnLevel;\n-\t    JSpinner spnBonus;\n+        JLabel lblValue;\n+        JLabel lblLevel;\n+        JLabel lblBonus;\n+        JSpinner spnLevel;\n+        JSpinner spnBonus;\n \n         GridBagLayout gridBag = new GridBagLayout();\n         GridBagConstraints c = new GridBagConstraints();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODE3MQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386138171", "bodyText": "What sort of exceptions are we trying to catch that we can't expect?", "author": "sixlettervariables", "createdAt": "2020-03-01T20:31:32Z", "path": "MekHQ/src/mekhq/gui/dialog/CampaignOptionsDialog.java", "diffHunk": "@@ -1588,385 +1544,471 @@ private void initComponents() {\n \n         tabOptions.addTab(resourceMap.getString(\"panTech.TabConstraints.tabTitle\"), panTech); // NOI18N\n \n-        panPersonnel.setName(\"panPersonnel\"); // NOI18N\n-        panPersonnel.setLayout(new java.awt.GridBagLayout());\n-\n-        useTacticsBox.setText(resourceMap.getString(\"useTacticsBox.text\")); // NOI18N\n-        useTacticsBox.setToolTipText(resourceMap.getString(\"useTacticsBox.toolTipText\")); // NOI18N\n-        useTacticsBox.setName(\"useTacticsBox\"); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 0;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useTacticsBox, gridBagConstraints);\n-\n-        useInitBonusBox.setText(resourceMap.getString(\"useInitBonusBox.text\")); // NOI18N\n-        useInitBonusBox.setToolTipText(resourceMap.getString(\"useInitBonusBox.toolTipText\")); // NOI18N\n-        useInitBonusBox.setName(\"useInitBonusBox\"); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 1;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useInitBonusBox, gridBagConstraints);\n-\n-        useToughnessBox.setText(resourceMap.getString(\"useToughnessBox.text\")); // NOI18N\n-        useToughnessBox.setToolTipText(resourceMap.getString(\"useToughnessBox.toolTipText\")); // NOI18N\n-        useToughnessBox.setName(\"useToughnessBox\"); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 2;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useToughnessBox, gridBagConstraints);\n-\n-        useArtilleryBox.setText(resourceMap.getString(\"useArtilleryBox.text\")); // NOI18N\n-        useArtilleryBox.setToolTipText(resourceMap.getString(\"useArtilleryBox.toolTipText\")); // NOI18N\n-        useArtilleryBox.setName(\"useArtilleryBox\"); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 3;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useArtilleryBox, gridBagConstraints);\n-\n-        useAbilitiesBox.setText(resourceMap.getString(\"useAbilitiesBox.text\")); // NOI18N\n-        useAbilitiesBox.setToolTipText(resourceMap.getString(\"useAbilitiesBox.toolTipText\")); // NOI18N\n-        useAbilitiesBox.setName(\"useAbilitiesBox\"); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 4;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useAbilitiesBox, gridBagConstraints);\n-\n-        useEdgeBox.setText(resourceMap.getString(\"useEdgeBox.text\")); // NOI18N\n-        useEdgeBox.setToolTipText(resourceMap.getString(\"useEdgeBox.toolTipText\")); // NOI18N\n-        useEdgeBox.setName(\"useEdgeBox\"); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 5;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useEdgeBox, gridBagConstraints);\n-\n-        useSupportEdgeBox.setText(resourceMap.getString(\"useSupportEdgeBox.text\")); // NOI18N\n-        useSupportEdgeBox.setToolTipText(resourceMap.getString(\"useSupportEdgeBox.toolTipText\")); // NOI18N\n-        useSupportEdgeBox.setName(\"useSupportEdgeBox\"); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 6;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useSupportEdgeBox, gridBagConstraints);\n-\n-        useImplantsBox.setText(resourceMap.getString(\"useImplantsBox.text\")); // NOI18N\n-        useImplantsBox.setToolTipText(resourceMap.getString(\"useImplantsBox.toolTipText\")); // NOI18N\n-        useImplantsBox.setName(\"useImplantsBox\"); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 7;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useImplantsBox, gridBagConstraints);\n-\n-        chkCapturePrisoners.setText(resourceMap.getString(\"chkCapturePrisoners.text\")); // NOI18N\n-        chkCapturePrisoners.setToolTipText(resourceMap.getString(\"chkCapturePrisoners.toolTipText\")); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 8;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(chkCapturePrisoners, gridBagConstraints);\n-\n-        DefaultComboBoxModel<String> prisonerStatusModel = new DefaultComboBoxModel<>();\n-        prisonerStatusModel.addElement(\"Prisoner\");\n-        prisonerStatusModel.addElement(\"Bondsman\");\n-        comboPrisonerStatus = new JComboBox<>(prisonerStatusModel);\n-        comboPrisonerStatus.setSelectedIndex(options.getDefaultPrisonerStatus());\n-        JPanel pnlPrisonerStatus = new JPanel();\n-        pnlPrisonerStatus.add(new JLabel(\"Default Prisoner Status:\"));\n-        pnlPrisonerStatus.add(comboPrisonerStatus);\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 9;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(pnlPrisonerStatus, gridBagConstraints);\n-\n-\t\taltQualityAveragingCheckBox.setText(resourceMap.getString(\"altQualityAveragingCheckBox.text\")); // NOI18N\n-        altQualityAveragingCheckBox.setToolTipText(resourceMap.getString(\"altQualityAveragingCheckBox.toolTipText\")); // NOI18N\n-        altQualityAveragingCheckBox.setName(\"altQualityAveragingCheckBox\"); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 10;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(altQualityAveragingCheckBox, gridBagConstraints);\n-\n-        useAdvancedMedicalBox.setText(resourceMap.getString(\"useAdvancedMedicalBox.text\")); // NOI18N\n-        useAdvancedMedicalBox.setToolTipText(resourceMap.getString(\"useAdvancedMedicalBox.toolTipText\")); // NOI18N\n-        useAdvancedMedicalBox.setName(\"useAdvancedMedicalBox\"); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 11;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useAdvancedMedicalBox, gridBagConstraints);\n-\n-        useDylansRandomXpBox.setText(resourceMap.getString(\"useDylansRandomXpBox.text\")); // NOI18N\n-        useDylansRandomXpBox.setToolTipText(resourceMap.getString(\"useDylansRandomXpBox.toolTipText\")); // NOI18N\n-        useDylansRandomXpBox.setName(\"useDylansRandomXpBox\"); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 12;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useDylansRandomXpBox, gridBagConstraints);\n-\n-        spnHealWaitingPeriod = new JSpinner(new SpinnerNumberModel(options.getHealingWaitingPeriod(), 1, 30, 1));\n-        ((JSpinner.DefaultEditor) spnHealWaitingPeriod.getEditor()).getTextField().setEditable(false);\n-        JPanel pnlHealWaitingPeriod = new JPanel();\n-        pnlHealWaitingPeriod.add(spnHealWaitingPeriod);\n-        pnlHealWaitingPeriod.add(new JLabel(\"Days to wait between healing checks by doctors\"));\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 13;\n-        gridBagConstraints.gridwidth = 2;\n-        //gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(pnlHealWaitingPeriod, gridBagConstraints);\n-\n-        spnNaturalHealWaitingPeriod = new JSpinner(new SpinnerNumberModel(options.getNaturalHealingWaitingPeriod(),\n-                                                                          1, 365, 1));\n-        ((JSpinner.DefaultEditor) spnNaturalHealWaitingPeriod.getEditor()).getTextField().setEditable(false);\n-        JPanel pnlNaturalHealWaitingPeriod = new JPanel();\n-        pnlNaturalHealWaitingPeriod.add(spnNaturalHealWaitingPeriod);\n-        pnlNaturalHealWaitingPeriod.add(new JLabel(\"Days to wait for natural healing\"));\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 14;\n-        gridBagConstraints.gridwidth = 2;\n-        //gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(pnlNaturalHealWaitingPeriod, gridBagConstraints);\n-\n-        spnMinimumHitsForVees = new JSpinner(new SpinnerNumberModel(options.getMinimumHitsForVees(), 1, 5, 1));\n-        ((JSpinner.DefaultEditor) spnMinimumHitsForVees.getEditor()).getTextField().setEditable(false);\n-        JPanel panMinimumHitsForVees = new JPanel();\n-        panMinimumHitsForVees.add(spnMinimumHitsForVees);\n-        panMinimumHitsForVees.add(new JLabel(\"Minimum number of hits for wounded crews and infantry\"));\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 15;\n-        gridBagConstraints.gridwidth = 2;\n-        //gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(panMinimumHitsForVees, gridBagConstraints);\n-\n-        useRandomHitsForVees = new JCheckBox();\n-        useRandomHitsForVees.setSelected(options.useRandomHitsForVees());\n-        useRandomHitsForVees.setText(resourceMap.getString(\"useRandomHitsForVees.text\")); // NOI18N\n-        useRandomHitsForVees.setToolTipText(resourceMap.getString(\"useRandomHitsForVees.toolTipText\")); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 16;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useRandomHitsForVees, gridBagConstraints);\n-\n-        useTougherHealing = new JCheckBox(resourceMap.getString(\"useTougherHealing.text\"));\n-        useTougherHealing.setSelected(options.useTougherHealing());\n-        useTougherHealing.setToolTipText(resourceMap.getString(\"useTougherHealing.toolTipText\")); // NOI18N\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 17;\n-        gridBagConstraints.gridwidth = 2;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(useTougherHealing, gridBagConstraints);\n-\n-        chkUseUnofficialProcreation = new JCheckBox(\"Use procreation (Unofficial)\"); // NOI18N\n-        chkUseUnofficialProcreation.setSelected(options.useUnofficialProcreation());\n-        //chkUseUnofficialProcreation.setToolTipText(resourceMap.getString(\"chkUseUnofficialProcreation.toolTipText\")); // NOI18N\n-        gridBagConstraints.gridy = 18;\n-        panPersonnel.add(chkUseUnofficialProcreation, gridBagConstraints);\n-\n-        chkUseUnofficialProcreationNoRelationship = new JCheckBox(\"Use procreation without a relationship (Unofficial)\"); // NOI18N\n-        chkUseUnofficialProcreationNoRelationship.setSelected(options.useUnofficialProcreationNoRelationship());\n-        //chkUseUnofficialProcreationNoRelationship.setToolTipText(resourceMap.getString(\"chkUseUnofficialProcreationNoRelationship.toolTipText\")); // NOI18N\n-        gridBagConstraints.gridy = 19;\n-        panPersonnel.add(chkUseUnofficialProcreationNoRelationship, gridBagConstraints);\n-\n-        chkUseParentage = new JCheckBox(\"Display children in the person panel\");\n-        chkUseParentage.setSelected(options.useParentage());\n-        gridBagConstraints.gridy = 20;\n-        panPersonnel.add(chkUseParentage, gridBagConstraints);\n-\n-        chkLogConception = new JCheckBox(\"Log Conception and Birth \");\n-        chkLogConception.setSelected(options.logConception());\n-        gridBagConstraints.gridy = 21;\n-        panPersonnel.add(chkLogConception, gridBagConstraints);\n-\n-        chkUseTransfers = new JCheckBox(\"Log Saver - Use Reassign instead of Remove/Assign\"); // NOI18N\n-        chkUseTransfers.setSelected(options.useTransfers());\n-        gridBagConstraints.gridy = 22;\n-        panPersonnel.add(chkUseTransfers, gridBagConstraints);\n-\n-        chkUseTimeInService = new JCheckBox(\"Track Time In Service\"); // NOI18N\n-        chkUseTimeInService.setSelected(options.getUseTimeInService());\n-        gridBagConstraints.gridy = 23;\n-        panPersonnel.add(chkUseTimeInService, gridBagConstraints);\n-\n-        chkShowOriginFaction = new JCheckBox(\"Show Origin Faction\"); // NOI18N\n-        chkShowOriginFaction.setSelected(options.showOriginFaction());\n-        gridBagConstraints.gridy = 24;\n-        panPersonnel.add(chkShowOriginFaction, gridBagConstraints);\n-\n-        chkRandomizeOrigin = new JCheckBox(\"Randomize Origin\"); // NOI18N\n-        chkRandomizeOrigin.setSelected(options.randomizeOrigin());\n-        gridBagConstraints.gridy = 25;\n-        panPersonnel.add(chkRandomizeOrigin, gridBagConstraints);\n-\n-        spnOriginSearchRadius = new JSpinner(new SpinnerNumberModel(options.getOriginSearchRadius(), 10, 250, 10));\n-        JPanel panOriginSearchRadius = new JPanel();\n-        panOriginSearchRadius.add(spnOriginSearchRadius);\n-        panOriginSearchRadius.add(new JLabel(\"Random Origin Search Radius\"));\n-        gridBagConstraints.gridy = 26;\n-        panPersonnel.add(panOriginSearchRadius, gridBagConstraints);\n-\n-        JPanel panSalary = new JPanel(new GridBagLayout());\n-        panSalary.setBorder(BorderFactory.createTitledBorder(\"Salary\"));\n-\n-        JPanel panMultiplier = new JPanel(new GridLayout(1, 3));\n-        panMultiplier.setBorder(BorderFactory.createTitledBorder(\"Multipliers\"));\n-        spnSalaryCommission = new JSpinner(new SpinnerNumberModel(options.getSalaryCommissionMultiplier(), 0, 10, 0.05));\n-        ((JSpinner.DefaultEditor) spnSalaryCommission.getEditor()).getTextField().setEditable(false);\n-        JPanel panSalaryCommission = new JPanel();\n-        panSalaryCommission.add(spnSalaryCommission);\n-        panSalaryCommission.add(new JLabel(\"Commissioned\"));\n-        panMultiplier.add(panSalaryCommission);\n-\n-        spnSalaryEnlisted = new JSpinner(new SpinnerNumberModel(options.getSalaryEnlistedMultiplier(), 0, 10, 0.05));\n-        ((JSpinner.DefaultEditor) spnSalaryEnlisted.getEditor()).getTextField().setEditable(false);\n-        JPanel panSalaryEnlisted = new JPanel();\n-        panSalaryEnlisted.add(spnSalaryEnlisted);\n-        panSalaryEnlisted.add(new JLabel(\"Enlisted\"));\n-        panMultiplier.add(panSalaryEnlisted);\n-\n-        spnSalaryAntiMek = new JSpinner(new SpinnerNumberModel(options.getSalaryAntiMekMultiplier(), 0, 10, 0.05));\n-        ((JSpinner.DefaultEditor) spnSalaryAntiMek.getEditor()).getTextField().setEditable(false);\n-        JPanel panSalaryAntiMek = new JPanel();\n-        panSalaryAntiMek.add(spnSalaryAntiMek);\n-        panSalaryAntiMek.add(new JLabel(\"Anti-Mek\"));\n-        panMultiplier.add(panSalaryAntiMek);\n-\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 0;\n-        gridBagConstraints.weightx = 1.0;\n-        gridBagConstraints.weighty = 0.0;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panSalary.add(panMultiplier, gridBagConstraints);\n+        //region Personnel Tab\n+        try {\n+            panPersonnel.setName(\"panPersonnel\");\n+            panPersonnel.setLayout(new java.awt.GridBagLayout());\n+            gridy = 0;\n \n-        JPanel panXpMultiplier = new JPanel(new GridLayout(2, 3));\n-        panXpMultiplier.setBorder(BorderFactory.createTitledBorder(\"Experience Multipliers\"));\n-        spnSalaryXp = new JSpinner[5];\n-        JSpinner spnXpSalary;\n-        JPanel panXpSalary;\n-        for (int i = 0; i < 5; i++) {\n-            spnXpSalary = new JSpinner(new SpinnerNumberModel(options.getSalaryXpMultiplier(i), 0, 10, 0.05));\n-            ((JSpinner.DefaultEditor) spnXpSalary.getEditor()).getTextField().setEditable(false);\n-            panXpSalary = new JPanel();\n-            panXpSalary.add(spnXpSalary);\n-            panXpSalary.add(new JLabel(SkillType.getExperienceLevelName(i)));\n-            panXpMultiplier.add(panXpSalary);\n-            spnSalaryXp[i] = spnXpSalary;\n-        }\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 1;\n-        gridBagConstraints.weightx = 1.0;\n-        gridBagConstraints.weighty = 0.0;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panSalary.add(panXpMultiplier, gridBagConstraints);\n+            useTacticsBox.setText(resourceMap.getString(\"useTacticsBox.text\"));\n+            useTacticsBox.setToolTipText(resourceMap.getString(\"useTacticsBox.toolTipText\"));\n+            useTacticsBox.setName(\"useTacticsBox\");\n+            gridBagConstraints = new java.awt.GridBagConstraints();\n+            gridBagConstraints.gridx = 0;\n+            gridBagConstraints.gridy = gridy;\n+            gridBagConstraints.gridwidth = 2;\n+            gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n+            gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n+            panPersonnel.add(useTacticsBox, gridBagConstraints);\n+\n+            useInitBonusBox.setText(resourceMap.getString(\"useInitBonusBox.text\"));\n+            useInitBonusBox.setToolTipText(resourceMap.getString(\"useInitBonusBox.toolTipText\"));\n+            useInitBonusBox.setName(\"useInitBonusBox\");\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(useInitBonusBox, gridBagConstraints);\n+\n+            useToughnessBox.setText(resourceMap.getString(\"useToughnessBox.text\"));\n+            useToughnessBox.setToolTipText(resourceMap.getString(\"useToughnessBox.toolTipText\"));\n+            useToughnessBox.setName(\"useToughnessBox\");\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(useToughnessBox, gridBagConstraints);\n+\n+            useArtilleryBox.setText(resourceMap.getString(\"useArtilleryBox.text\"));\n+            useArtilleryBox.setToolTipText(resourceMap.getString(\"useArtilleryBox.toolTipText\"));\n+            useArtilleryBox.setName(\"useArtilleryBox\");\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(useArtilleryBox, gridBagConstraints);\n+\n+            useAbilitiesBox.setText(resourceMap.getString(\"useAbilitiesBox.text\"));\n+            useAbilitiesBox.setToolTipText(resourceMap.getString(\"useAbilitiesBox.toolTipText\"));\n+            useAbilitiesBox.setName(\"useAbilitiesBox\");\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(useAbilitiesBox, gridBagConstraints);\n+\n+            useEdgeBox.setText(resourceMap.getString(\"useEdgeBox.text\"));\n+            useEdgeBox.setToolTipText(resourceMap.getString(\"useEdgeBox.toolTipText\"));\n+            useEdgeBox.setName(\"useEdgeBox\");\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(useEdgeBox, gridBagConstraints);\n+\n+            useSupportEdgeBox.setText(resourceMap.getString(\"useSupportEdgeBox.text\"));\n+            useSupportEdgeBox.setToolTipText(resourceMap.getString(\"useSupportEdgeBox.toolTipText\"));\n+            useSupportEdgeBox.setName(\"useSupportEdgeBox\");\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(useSupportEdgeBox, gridBagConstraints);\n+\n+            useImplantsBox.setText(resourceMap.getString(\"useImplantsBox.text\"));\n+            useImplantsBox.setToolTipText(resourceMap.getString(\"useImplantsBox.toolTipText\"));\n+            useImplantsBox.setName(\"useImplantsBox\");\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(useImplantsBox, gridBagConstraints);\n+\n+            chkCapturePrisoners.setText(resourceMap.getString(\"chkCapturePrisoners.text\"));\n+            chkCapturePrisoners.setToolTipText(resourceMap.getString(\"chkCapturePrisoners.toolTipText\"));\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(chkCapturePrisoners, gridBagConstraints);\n+\n+            DefaultComboBoxModel<String> prisonerStatusModel = new DefaultComboBoxModel<>();\n+            prisonerStatusModel.addElement(resourceMap.getString(\"prisonerStatus.Prisoner\"));\n+            prisonerStatusModel.addElement(resourceMap.getString(\"prisonerStatus.Bondsman\"));\n+            comboPrisonerStatus = new JComboBox<>(prisonerStatusModel);\n+            comboPrisonerStatus.setSelectedIndex(options.getDefaultPrisonerStatus());\n+            JPanel pnlPrisonerStatus = new JPanel();\n+            pnlPrisonerStatus.add(new JLabel(resourceMap.getString(\"prisonerStatus.text\")));\n+            pnlPrisonerStatus.add(comboPrisonerStatus);\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(pnlPrisonerStatus, gridBagConstraints);\n+\n+            altQualityAveragingCheckBox.setText(resourceMap.getString(\"altQualityAveragingCheckBox.text\"));\n+            altQualityAveragingCheckBox.setToolTipText(resourceMap.getString(\"altQualityAveragingCheckBox.toolTipText\"));\n+            altQualityAveragingCheckBox.setName(\"altQualityAveragingCheckBox\");\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(altQualityAveragingCheckBox, gridBagConstraints);\n+\n+            useAdvancedMedicalBox.setText(resourceMap.getString(\"useAdvancedMedicalBox.text\"));\n+            useAdvancedMedicalBox.setToolTipText(resourceMap.getString(\"useAdvancedMedicalBox.toolTipText\"));\n+            useAdvancedMedicalBox.setName(\"useAdvancedMedicalBox\");\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(useAdvancedMedicalBox, gridBagConstraints);\n+\n+            useDylansRandomXpBox.setText(resourceMap.getString(\"useDylansRandomXpBox.text\"));\n+            useDylansRandomXpBox.setToolTipText(resourceMap.getString(\"useDylansRandomXpBox.toolTipText\"));\n+            useDylansRandomXpBox.setName(\"useDylansRandomXpBox\");\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(useDylansRandomXpBox, gridBagConstraints);\n+\n+            spnHealWaitingPeriod = new JSpinner(new SpinnerNumberModel(options.getHealingWaitingPeriod(), 1, 30, 1));\n+            ((JSpinner.DefaultEditor) spnHealWaitingPeriod.getEditor()).getTextField().setEditable(false);\n+            JPanel pnlHealWaitingPeriod = new JPanel();\n+            pnlHealWaitingPeriod.add(spnHealWaitingPeriod);\n+            pnlHealWaitingPeriod.add(new JLabel(resourceMap.getString(\"healWaitingPeriod.text\")));\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(pnlHealWaitingPeriod, gridBagConstraints);\n+\n+            spnNaturalHealWaitingPeriod = new JSpinner(new SpinnerNumberModel(options.getNaturalHealingWaitingPeriod(),\n+                    1, 365, 1));\n+            ((JSpinner.DefaultEditor) spnNaturalHealWaitingPeriod.getEditor()).getTextField().setEditable(false);\n+            JPanel pnlNaturalHealWaitingPeriod = new JPanel();\n+            pnlNaturalHealWaitingPeriod.add(spnNaturalHealWaitingPeriod);\n+            pnlNaturalHealWaitingPeriod.add(new JLabel(resourceMap.getString(\"naturalHealWaitingPeriod.text\")));\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(pnlNaturalHealWaitingPeriod, gridBagConstraints);\n+\n+            spnMinimumHitsForVees = new JSpinner(new SpinnerNumberModel(options.getMinimumHitsForVees(), 1, 5, 1));\n+            ((JSpinner.DefaultEditor) spnMinimumHitsForVees.getEditor()).getTextField().setEditable(false);\n+            JPanel panMinimumHitsForVees = new JPanel();\n+            panMinimumHitsForVees.add(spnMinimumHitsForVees);\n+            panMinimumHitsForVees.add(new JLabel(resourceMap.getString(\"minimumHitsForVees.text\")));\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(panMinimumHitsForVees, gridBagConstraints);\n+\n+            useRandomHitsForVees = new JCheckBox();\n+            useRandomHitsForVees.setSelected(options.useRandomHitsForVees());\n+            useRandomHitsForVees.setText(resourceMap.getString(\"useRandomHitsForVees.text\"));\n+            useRandomHitsForVees.setToolTipText(resourceMap.getString(\"useRandomHitsForVees.toolTipText\"));\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(useRandomHitsForVees, gridBagConstraints);\n+\n+            useTougherHealing = new JCheckBox(resourceMap.getString(\"useTougherHealing.text\"));\n+            useTougherHealing.setSelected(options.useTougherHealing());\n+            useTougherHealing.setToolTipText(resourceMap.getString(\"useTougherHealing.toolTipText\"));\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(useTougherHealing, gridBagConstraints);\n+\n+            chkUseTransfers = new JCheckBox(resourceMap.getString(\"useTransfers.text\"));\n+            chkUseTransfers.setSelected(options.useTransfers());\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(chkUseTransfers, gridBagConstraints);\n+\n+            chkUseTimeInService = new JCheckBox(resourceMap.getString(\"useTimeInService.text\"));\n+            chkUseTimeInService.setSelected(options.getUseTimeInService());\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(chkUseTimeInService, gridBagConstraints);\n+\n+            chkShowOriginFaction = new JCheckBox(resourceMap.getString(\"showOriginFaction.text\"));\n+            chkShowOriginFaction.setSelected(options.showOriginFaction());\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(chkShowOriginFaction, gridBagConstraints);\n+\n+            chkRandomizeOrigin = new JCheckBox(resourceMap.getString(\"randomizeOrigin.text\"));\n+            chkRandomizeOrigin.setSelected(options.randomizeOrigin());\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(chkRandomizeOrigin, gridBagConstraints);\n+\n+            chkRandomizeDependentsOrigin = new JCheckBox(resourceMap.getString(\"randomizeDependentsOrigin.text\"));\n+            chkRandomizeDependentsOrigin.setSelected(options.getRandomizeDependentOrigin());\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(chkRandomizeDependentsOrigin, gridBagConstraints);\n+\n+            spnOriginSearchRadius = new JSpinner(new SpinnerNumberModel(options.getOriginSearchRadius(), 10, 250, 10));\n+            JPanel panOriginSearchRadius = new JPanel();\n+            panOriginSearchRadius.add(spnOriginSearchRadius);\n+            panOriginSearchRadius.add(new JLabel(resourceMap.getString(\"originSearchRadius.text\")));\n+            gridBagConstraints.gridy = ++gridy;\n+            panPersonnel.add(panOriginSearchRadius, gridBagConstraints);\n+\n+            //Family\n+            JPanel panFamily = new JPanel(new GridBagLayout());\n+            panFamily.setBorder(BorderFactory.createTitledBorder(resourceMap.getString(\"FamilyTab.text\")));\n+            int panFamilyGridY = ++gridy;\n+\n+            spnMinimumMarriageAge = new JSpinner(new SpinnerNumberModel(options.getMinimumMarriageAge(), 14, null, 1));\n+            Dimension dimensionMinimumMarriageAge = spnMinimumMarriageAge.getPreferredSize();\n+            dimensionMinimumMarriageAge.width = 40;\n+            spnMinimumMarriageAge.setPreferredSize(dimensionMinimumMarriageAge);\n+            JPanel panMinimumMarriageAge = new JPanel();\n+            panMinimumMarriageAge.add(new JLabel(resourceMap.getString(\"minimumMarriageAge.text\")));\n+            panMinimumMarriageAge.setToolTipText(resourceMap.getString(\"minimumMarriageAge.toolTipText\"));\n+            panMinimumMarriageAge.add(spnMinimumMarriageAge);\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(panMinimumMarriageAge, gridBagConstraints);\n+\n+            spnCheckMutualAncestorsDepth = new JSpinner(new SpinnerNumberModel(options.checkMutualAncestorsDepth(), 0, 20, 1));\n+            Dimension dimensionCheckMutualAncestorsDepth = spnCheckMutualAncestorsDepth.getPreferredSize();\n+            dimensionCheckMutualAncestorsDepth.width = 40;\n+            spnCheckMutualAncestorsDepth.setPreferredSize(dimensionCheckMutualAncestorsDepth);\n+            JPanel panCheckMutualAncestorsDepth = new JPanel();\n+            panCheckMutualAncestorsDepth.add(new JLabel(resourceMap.getString(\"checkMutualAncestorsDepth.text\")));\n+            panCheckMutualAncestorsDepth.setToolTipText(resourceMap.getString(\"checkMutualAncestorsDepth.toolTipText\"));\n+            panCheckMutualAncestorsDepth.add(spnCheckMutualAncestorsDepth);\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(panCheckMutualAncestorsDepth, gridBagConstraints);\n+\n+            chkUseRandomMarriages = new JCheckBox(resourceMap.getString(\"useRandomMarriages.text\"));\n+            chkUseRandomMarriages.setToolTipText(resourceMap.getString(\"useRandomMarriages.toolTipText\"));\n+            chkUseRandomMarriages.setSelected(options.useRandomMarriages());\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(chkUseRandomMarriages, gridBagConstraints);\n+\n+            spnChanceRandomMarriages = new JSpinner(new SpinnerNumberModel(options.getChanceRandomMarriages(), 0, 100, 0.001));\n+            Dimension dimensionChanceRandomMarriages = spnChanceRandomMarriages.getPreferredSize();\n+            dimensionChanceRandomMarriages.width = 50;\n+            spnChanceRandomMarriages.setPreferredSize(dimensionChanceRandomMarriages);\n+            JPanel panChanceRandomMarriages = new JPanel();\n+            panChanceRandomMarriages.add(new JLabel(resourceMap.getString(\"chanceRandomMarriages.text\")));\n+            panChanceRandomMarriages.setToolTipText(resourceMap.getString(\"chanceRandomMarriages.toolTipText\"));\n+            panChanceRandomMarriages.add(spnChanceRandomMarriages);\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(panChanceRandomMarriages, gridBagConstraints);\n+\n+            spnMarriageAgeRange = new JSpinner(new SpinnerNumberModel(options.getMarriageAgeRange(), 0, null, 1));\n+            Dimension dimensionMarriageAgeRange = spnMarriageAgeRange.getPreferredSize();\n+            dimensionMarriageAgeRange.width = 40;\n+            spnMarriageAgeRange.setPreferredSize(dimensionMarriageAgeRange);\n+            JPanel panMarriageAgeRange = new JPanel();\n+            panMarriageAgeRange.add(new JLabel(resourceMap.getString(\"marriageAgeRange.text\")));\n+            panMarriageAgeRange.setToolTipText(resourceMap.getString(\"marriageAgeRange.toolTipText\"));\n+            panMarriageAgeRange.add(spnMarriageAgeRange);\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(panMarriageAgeRange, gridBagConstraints);\n+\n+            JPanel panRandomMarriageSurnameWeights = new JPanel(new GridLayout((int) Math.ceil(Person.NUM_SURNAME / 3.0), 3));\n+            panRandomMarriageSurnameWeights.setBorder(BorderFactory.createTitledBorder(resourceMap.getString(\"randomMarriageSurnameWeights.text\")));\n+            panRandomMarriageSurnameWeights.setToolTipText(resourceMap.getString(\"randomMarriageSurnameWeights.toolTipText\"));\n+            spnRandomMarriageSurnameWeights = new JSpinner[Person.NUM_SURNAME];\n+            JSpinner spnRandomMarriageSurnameWeight;\n+            JPanel panRandomMarriageSurnameWeight;\n+            for (int i = 0; i < Person.NUM_SURNAME; i++) {\n+                spnRandomMarriageSurnameWeight = new JSpinner(new SpinnerNumberModel((options.getRandomMarriageSurnameWeights(i) / 10.0), 0, 100, 0.1));\n+                panRandomMarriageSurnameWeight = new JPanel();\n+                panRandomMarriageSurnameWeight.add(spnRandomMarriageSurnameWeight);\n+                panRandomMarriageSurnameWeight.add(new JLabel(Person.SURNAME_TYPE_NAMES[i]));\n+                panRandomMarriageSurnameWeights.add(panRandomMarriageSurnameWeight);\n+                spnRandomMarriageSurnameWeights[i] = spnRandomMarriageSurnameWeight;\n+            }\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(panRandomMarriageSurnameWeights, gridBagConstraints);\n+\n+            chkUseRandomSameSexMarriages = new JCheckBox(resourceMap.getString(\"useRandomSameSexMarriages.text\"));\n+            chkUseRandomSameSexMarriages.setToolTipText(resourceMap.getString(\"useRandomSameSexMarriages.toolTipText\"));\n+            chkUseRandomSameSexMarriages.setSelected(options.useRandomSameSexMarriages());\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(chkUseRandomSameSexMarriages, gridBagConstraints);\n+\n+            spnChanceRandomSameSexMarriages = new JSpinner(new SpinnerNumberModel(options.getChanceRandomSameSexMarriages(), 0, 100, 0.001));\n+            Dimension dimensionChanceRandomSameSexMarriages = spnChanceRandomSameSexMarriages.getPreferredSize();\n+            dimensionChanceRandomSameSexMarriages.width = 50;\n+            spnChanceRandomSameSexMarriages.setPreferredSize(dimensionChanceRandomSameSexMarriages);\n+            JPanel panChanceRandomSameSexMarriages = new JPanel();\n+            panChanceRandomSameSexMarriages.add(new JLabel(resourceMap.getString(\"chanceRandomSameSexMarriages.text\")));\n+            panChanceRandomSameSexMarriages.setToolTipText(resourceMap.getString(\"chanceRandomSameSexMarriages.toolTipText\"));\n+            panChanceRandomSameSexMarriages.add(spnChanceRandomSameSexMarriages);\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(panChanceRandomSameSexMarriages, gridBagConstraints);\n+\n+            chkUseUnofficialProcreation = new JCheckBox(resourceMap.getString(\"useUnofficialProcreation.text\"));\n+            chkUseUnofficialProcreation.setSelected(options.useUnofficialProcreation());\n+            chkUseUnofficialProcreation.setToolTipText(resourceMap.getString(\"useUnofficialProcreation.toolTipText\"));\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(chkUseUnofficialProcreation, gridBagConstraints);\n+\n+            spnChanceProcreation = new JSpinner(new SpinnerNumberModel(options.getChanceProcreation(), 0, 100, 0.001));\n+            Dimension dimensionChanceProcreation = spnChanceProcreation.getPreferredSize();\n+            dimensionChanceProcreation.width = 50;\n+            spnChanceProcreation.setPreferredSize(dimensionChanceProcreation);\n+            JPanel panChanceProcreation = new JPanel();\n+            panChanceProcreation.add(new JLabel(resourceMap.getString(\"chanceProcreation.text\")));\n+            panChanceProcreation.setToolTipText(resourceMap.getString(\"chanceProcreation.toolTipText\"));\n+            panChanceProcreation.add(spnChanceProcreation);\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(panChanceProcreation, gridBagConstraints);\n+\n+            chkUseUnofficialProcreationNoRelationship = new JCheckBox(resourceMap.getString(\"useUnofficialProcreationNoRelationship.text\"));\n+            chkUseUnofficialProcreationNoRelationship.setToolTipText(resourceMap.getString(\"useUnofficialProcreationNoRelationship.toolTipText\"));\n+            chkUseUnofficialProcreationNoRelationship.setSelected(options.useUnofficialProcreationNoRelationship());\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(chkUseUnofficialProcreationNoRelationship, gridBagConstraints);\n+\n+            spnChanceProcreationNoRelationship = new JSpinner(new SpinnerNumberModel(options.getChanceProcreationNoRelationship(), 0, 100, 0.001));\n+            Dimension dimensionChanceProcreationNoRelationship = spnChanceProcreationNoRelationship.getPreferredSize();\n+            dimensionChanceProcreationNoRelationship.width = 50;\n+            spnChanceProcreationNoRelationship.setPreferredSize(dimensionChanceProcreationNoRelationship);\n+            JPanel panChanceProcreationNoRelationship = new JPanel();\n+            panChanceProcreationNoRelationship.add(new JLabel(resourceMap.getString(\"chanceProcreationNoRelationship.text\")));\n+            panChanceProcreationNoRelationship.setToolTipText(resourceMap.getString(\"chanceProcreationNoRelationship.toolTipText\"));\n+            panChanceProcreationNoRelationship.add(spnChanceProcreationNoRelationship);\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(panChanceProcreationNoRelationship, gridBagConstraints);\n+\n+            chkDisplayTrueDueDate = new JCheckBox(resourceMap.getString(\"displayTrueDueDate.text\"));\n+            chkDisplayTrueDueDate.setToolTipText(resourceMap.getString(\"displayTrueDueDate.toolTipText\"));\n+            chkDisplayTrueDueDate.setSelected(options.getDisplayTrueDueDate());\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(chkDisplayTrueDueDate, gridBagConstraints);\n+\n+            chkLogConception = new JCheckBox(resourceMap.getString(\"logConception.text\"));\n+            chkLogConception.setSelected(options.logConception());\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(chkLogConception, gridBagConstraints);\n+\n+            DefaultComboBoxModel<String> babySurnameStyleModel = new DefaultComboBoxModel<>();\n+            babySurnameStyleModel.addElement(resourceMap.getString(\"babySurnameStyle.Mother\"));\n+            babySurnameStyleModel.addElement(resourceMap.getString(\"babySurnameStyle.Father\"));\n+            comboBabySurnameStyle = new JComboBox<>(babySurnameStyleModel);\n+            comboBabySurnameStyle.setSelectedIndex(options.getBabySurnameStyle());\n+            JPanel pnlBabySurnameStyle = new JPanel();\n+            pnlBabySurnameStyle.add(new JLabel(resourceMap.getString(\"babySurnameStyle.text\")));\n+            pnlBabySurnameStyle.setToolTipText(resourceMap.getString(\"babySurnameStyle.toolTipText\"));\n+            pnlBabySurnameStyle.add(comboBabySurnameStyle);\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(pnlBabySurnameStyle, gridBagConstraints);\n+\n+            chkUseParentage = new JCheckBox(resourceMap.getString(\"useParentage.text\"));\n+            chkUseParentage.setSelected(options.useParentage());\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(chkUseParentage, gridBagConstraints);\n+\n+            DefaultComboBoxModel<String> familyLevelStatusModel = new DefaultComboBoxModel<>();\n+            familyLevelStatusModel.addElement(resourceMap.getString(\"displayFamilyLevel.ParentsChildren\"));\n+            familyLevelStatusModel.addElement(resourceMap.getString(\"displayFamilyLevel.GrandparentsGrandchildren\"));\n+            familyLevelStatusModel.addElement(resourceMap.getString(\"displayFamilyLevel.AuntsUnclesCousins\"));\n+            comboDisplayFamilyLevel = new JComboBox<>(familyLevelStatusModel);\n+            comboDisplayFamilyLevel.setSelectedIndex(options.displayFamilyLevel());\n+            JPanel pnlDisplayFamilyLevel = new JPanel();\n+            pnlDisplayFamilyLevel.add(new JLabel(resourceMap.getString(\"displayFamilyLevel.text\")));\n+            pnlDisplayFamilyLevel.setToolTipText(resourceMap.getString(\"displayFamilyLevel.toolTipText\"));\n+            pnlDisplayFamilyLevel.add(comboDisplayFamilyLevel);\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(pnlDisplayFamilyLevel, gridBagConstraints);\n+\n+            chkUseRandomDeaths = new JCheckBox(resourceMap.getString(\"useRandomDeaths.text\"));\n+            chkUseRandomDeaths.setToolTipText(resourceMap.getString(\"useRandomDeaths.toolTipText\"));\n+            chkUseRandomDeaths.setSelected(options.useRandomDeaths());\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(chkUseRandomDeaths, gridBagConstraints);\n+\n+            chkKeepMarriedNameUponSpouseDeath = new JCheckBox(resourceMap.getString(\"keepMarriedNameUponSpouseDeath.text\"));\n+            chkKeepMarriedNameUponSpouseDeath.setSelected(options.getKeepMarriedNameUponSpouseDeath());\n+            gridBagConstraints.gridy = ++gridy;\n+            panFamily.add(chkKeepMarriedNameUponSpouseDeath, gridBagConstraints);\n+\n+            gridBagConstraints.gridy = panFamilyGridY;\n+            panPersonnel.add(panFamily, gridBagConstraints);\n+\n+            //Salary\n+            JPanel panSalary = new JPanel(new GridBagLayout());\n+            panSalary.setBorder(BorderFactory.createTitledBorder(resourceMap.getString(\"SalaryTab.text\")));\n+\n+            JPanel panMultiplier = new JPanel(new GridLayout(1, 3));\n+            panMultiplier.setBorder(BorderFactory.createTitledBorder(\"Multipliers\"));\n+            spnSalaryCommission = new JSpinner(new SpinnerNumberModel(options.getSalaryCommissionMultiplier(), 0, 10, 0.05));\n+            ((JSpinner.DefaultEditor) spnSalaryCommission.getEditor()).getTextField().setEditable(false);\n+            JPanel panSalaryCommission = new JPanel();\n+            panSalaryCommission.add(spnSalaryCommission);\n+            panSalaryCommission.add(new JLabel(\"Commissioned\"));\n+            panMultiplier.add(panSalaryCommission);\n+\n+            spnSalaryEnlisted = new JSpinner(new SpinnerNumberModel(options.getSalaryEnlistedMultiplier(), 0, 10, 0.05));\n+            ((JSpinner.DefaultEditor) spnSalaryEnlisted.getEditor()).getTextField().setEditable(false);\n+            JPanel panSalaryEnlisted = new JPanel();\n+            panSalaryEnlisted.add(spnSalaryEnlisted);\n+            panSalaryEnlisted.add(new JLabel(\"Enlisted\"));\n+            panMultiplier.add(panSalaryEnlisted);\n+\n+            spnSalaryAntiMek = new JSpinner(new SpinnerNumberModel(options.getSalaryAntiMekMultiplier(), 0, 10, 0.05));\n+            ((JSpinner.DefaultEditor) spnSalaryAntiMek.getEditor()).getTextField().setEditable(false);\n+            JPanel panSalaryAntiMek = new JPanel();\n+            panSalaryAntiMek.add(spnSalaryAntiMek);\n+            panSalaryAntiMek.add(new JLabel(\"Anti-Mek\"));\n+            panMultiplier.add(panSalaryAntiMek);\n \n-        JPanel panAllTypes = new JPanel(new GridLayout(Person.T_NUM / 2, 2));\n-        JMoneyTextField txtType;\n-        JPanel panType;\n-        // TODO: use JFormattedTextField with Numeric formatter\n-        txtSalaryBase = new JMoneyTextField[Person.T_NUM];\n-        for (int i = 1; i < Person.T_NUM; i++) {\n-            txtType = new JMoneyTextField();\n-            txtType.setMoney(options.getBaseSalary(i));\n-            txtType.setPreferredSize(new Dimension(75, 20));\n-            panType = new JPanel(new GridBagLayout());\n             gridBagConstraints = new java.awt.GridBagConstraints();\n             gridBagConstraints.gridx = 0;\n             gridBagConstraints.gridy = 0;\n             gridBagConstraints.weightx = 1.0;\n             gridBagConstraints.weighty = 0.0;\n             gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n             gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-            panType.add(new JLabel(Person.getRoleDesc(i, false)), gridBagConstraints);\n+            panSalary.add(panMultiplier, gridBagConstraints);\n+\n+            JPanel panXpMultiplier = new JPanel(new GridLayout(2, 3));\n+            panXpMultiplier.setBorder(BorderFactory.createTitledBorder(\"Experience Multipliers\"));\n+            spnSalaryXp = new JSpinner[5];\n+            JSpinner spnXpSalary;\n+            JPanel panXpSalary;\n+            for (int i = 0; i < 5; i++) {\n+                spnXpSalary = new JSpinner(new SpinnerNumberModel(options.getSalaryXpMultiplier(i), 0, 10, 0.05));\n+                ((JSpinner.DefaultEditor) spnXpSalary.getEditor()).getTextField().setEditable(false);\n+                panXpSalary = new JPanel();\n+                panXpSalary.add(spnXpSalary);\n+                panXpSalary.add(new JLabel(SkillType.getExperienceLevelName(i)));\n+                panXpMultiplier.add(panXpSalary);\n+                spnSalaryXp[i] = spnXpSalary;\n+            }\n             gridBagConstraints = new java.awt.GridBagConstraints();\n-            gridBagConstraints.gridx = 1;\n-            gridBagConstraints.gridy = 0;\n-            gridBagConstraints.weightx = 0.0;\n+            gridBagConstraints.gridx = 0;\n+            gridBagConstraints.gridy = 1;\n+            gridBagConstraints.weightx = 1.0;\n             gridBagConstraints.weighty = 0.0;\n-            gridBagConstraints.fill = java.awt.GridBagConstraints.NONE;\n+            gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n             gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-            panType.add(txtType, gridBagConstraints);\n-            txtSalaryBase[i] = txtType;\n-            panAllTypes.add(panType);\n-        }\n-        JScrollPane scrSalaryBase = new JScrollPane(panAllTypes);\n-        scrSalaryBase.setBorder(BorderFactory.createTitledBorder(\"Base Salaries\"));\n-        scrSalaryBase.setOpaque(false);\n-        scrSalaryBase.setPreferredSize(new Dimension(200, 200));\n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 0;\n-        gridBagConstraints.gridy = 2;\n-        gridBagConstraints.weightx = 1.0;\n-        gridBagConstraints.weighty = 1.0;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panSalary.add(scrSalaryBase, gridBagConstraints);\n+            panSalary.add(panXpMultiplier, gridBagConstraints);\n+\n+            JPanel panAllTypes = new JPanel(new GridLayout(Person.T_NUM / 2, 2));\n+            JMoneyTextField txtType;\n+            JPanel panType;\n+            // TODO: use JFormattedTextField with Numeric formatter\n+            txtSalaryBase = new JMoneyTextField[Person.T_NUM];\n+            for (int i = 1; i < Person.T_NUM; i++) {\n+                txtType = new JMoneyTextField();\n+                txtType.setMoney(options.getBaseSalary(i));\n+                txtType.setPreferredSize(new Dimension(75, 20));\n+                panType = new JPanel(new GridBagLayout());\n+                gridBagConstraints = new java.awt.GridBagConstraints();\n+                gridBagConstraints.gridx = 0;\n+                gridBagConstraints.gridy = 0;\n+                gridBagConstraints.weightx = 1.0;\n+                gridBagConstraints.weighty = 0.0;\n+                gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n+                gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n+                panType.add(new JLabel(Person.getRoleDesc(i, false)), gridBagConstraints);\n+                gridBagConstraints = new java.awt.GridBagConstraints();\n+                gridBagConstraints.gridx = 1;\n+                gridBagConstraints.gridy = 0;\n+                gridBagConstraints.weightx = 0.0;\n+                gridBagConstraints.weighty = 0.0;\n+                gridBagConstraints.fill = java.awt.GridBagConstraints.NONE;\n+                gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n+                panType.add(txtType, gridBagConstraints);\n+                txtSalaryBase[i] = txtType;\n+                panAllTypes.add(panType);\n+            }\n+            JScrollPane scrSalaryBase = new JScrollPane(panAllTypes);\n+            scrSalaryBase.setBorder(BorderFactory.createTitledBorder(\"Base Salaries\"));\n+            scrSalaryBase.setOpaque(false);\n+            scrSalaryBase.setPreferredSize(new Dimension(200, 200));\n+            gridBagConstraints = new java.awt.GridBagConstraints();\n+            gridBagConstraints.gridx = 0;\n+            gridBagConstraints.gridy = 2;\n+            gridBagConstraints.weightx = 1.0;\n+            gridBagConstraints.weighty = 1.0;\n+            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n+            gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n+            panSalary.add(scrSalaryBase, gridBagConstraints);\n \n-        gridBagConstraints = new java.awt.GridBagConstraints();\n-        gridBagConstraints.gridx = 3;\n-        gridBagConstraints.gridy = 0;\n-        gridBagConstraints.gridheight = 23;\n-        gridBagConstraints.weightx = 1.0;\n-        gridBagConstraints.weighty = 1.0;\n-        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n-        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n-        panPersonnel.add(panSalary, gridBagConstraints);\n+            gridBagConstraints = new java.awt.GridBagConstraints();\n+            gridBagConstraints.gridx = 3;\n+            gridBagConstraints.gridy = 0;\n+            gridBagConstraints.gridheight = 23;\n+            gridBagConstraints.weightx = 1.0;\n+            gridBagConstraints.weighty = 1.0;\n+            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n+            gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n+            panPersonnel.add(panSalary, gridBagConstraints);\n \n-        JScrollPane scrollPersonnel = new JScrollPane(panPersonnel);\n-        scrollPersonnel.setPreferredSize(new java.awt.Dimension(500, 400));\n+            JScrollPane scrollPersonnel = new JScrollPane(panPersonnel);\n+            scrollPersonnel.setPreferredSize(new java.awt.Dimension(500, 400));\n \n-        tabOptions.addTab(resourceMap.getString(\"panPersonnel.TabConstraints.tabTitle\"), scrollPersonnel); // NOI18N\n+            tabOptions.addTab(resourceMap.getString(\"panPersonnel.TabConstraints.tabTitle\"), scrollPersonnel);\n+        } catch (Exception e) {\n+            MekHQ.getLogger().error(getClass(), \"PersonnelTab\", e);", "originalCommit": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MjI4OQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386142289", "bodyText": "Found it super useful while testing, but forgot to remove it after. Removing", "author": "Windchild292", "createdAt": "2020-03-01T21:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODE3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "aaca153caa3426d265fc4419a2d14be934e468ee", "chunk": "diff --git a/MekHQ/src/mekhq/gui/dialog/CampaignOptionsDialog.java b/MekHQ/src/mekhq/gui/dialog/CampaignOptionsDialog.java\nindex d5f9ecf2c..aba1fbbb0 100644\n--- a/MekHQ/src/mekhq/gui/dialog/CampaignOptionsDialog.java\n+++ b/MekHQ/src/mekhq/gui/dialog/CampaignOptionsDialog.java\n\n@@ -1545,373 +1545,414 @@ public class CampaignOptionsDialog extends javax.swing.JDialog {\n         tabOptions.addTab(resourceMap.getString(\"panTech.TabConstraints.tabTitle\"), panTech); // NOI18N\n \n         //region Personnel Tab\n-        try {\n-            panPersonnel.setName(\"panPersonnel\");\n-            panPersonnel.setLayout(new java.awt.GridBagLayout());\n-            gridy = 0;\n+        panPersonnel.setName(\"panPersonnel\");\n+        panPersonnel.setLayout(new java.awt.GridBagLayout());\n+        gridy = 0;\n \n-            useTacticsBox.setText(resourceMap.getString(\"useTacticsBox.text\"));\n-            useTacticsBox.setToolTipText(resourceMap.getString(\"useTacticsBox.toolTipText\"));\n-            useTacticsBox.setName(\"useTacticsBox\");\n-            gridBagConstraints = new java.awt.GridBagConstraints();\n-            gridBagConstraints.gridx = 0;\n-            gridBagConstraints.gridy = gridy;\n-            gridBagConstraints.gridwidth = 2;\n-            gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n-            gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n-            panPersonnel.add(useTacticsBox, gridBagConstraints);\n-\n-            useInitBonusBox.setText(resourceMap.getString(\"useInitBonusBox.text\"));\n-            useInitBonusBox.setToolTipText(resourceMap.getString(\"useInitBonusBox.toolTipText\"));\n-            useInitBonusBox.setName(\"useInitBonusBox\");\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(useInitBonusBox, gridBagConstraints);\n-\n-            useToughnessBox.setText(resourceMap.getString(\"useToughnessBox.text\"));\n-            useToughnessBox.setToolTipText(resourceMap.getString(\"useToughnessBox.toolTipText\"));\n-            useToughnessBox.setName(\"useToughnessBox\");\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(useToughnessBox, gridBagConstraints);\n-\n-            useArtilleryBox.setText(resourceMap.getString(\"useArtilleryBox.text\"));\n-            useArtilleryBox.setToolTipText(resourceMap.getString(\"useArtilleryBox.toolTipText\"));\n-            useArtilleryBox.setName(\"useArtilleryBox\");\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(useArtilleryBox, gridBagConstraints);\n-\n-            useAbilitiesBox.setText(resourceMap.getString(\"useAbilitiesBox.text\"));\n-            useAbilitiesBox.setToolTipText(resourceMap.getString(\"useAbilitiesBox.toolTipText\"));\n-            useAbilitiesBox.setName(\"useAbilitiesBox\");\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(useAbilitiesBox, gridBagConstraints);\n-\n-            useEdgeBox.setText(resourceMap.getString(\"useEdgeBox.text\"));\n-            useEdgeBox.setToolTipText(resourceMap.getString(\"useEdgeBox.toolTipText\"));\n-            useEdgeBox.setName(\"useEdgeBox\");\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(useEdgeBox, gridBagConstraints);\n-\n-            useSupportEdgeBox.setText(resourceMap.getString(\"useSupportEdgeBox.text\"));\n-            useSupportEdgeBox.setToolTipText(resourceMap.getString(\"useSupportEdgeBox.toolTipText\"));\n-            useSupportEdgeBox.setName(\"useSupportEdgeBox\");\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(useSupportEdgeBox, gridBagConstraints);\n-\n-            useImplantsBox.setText(resourceMap.getString(\"useImplantsBox.text\"));\n-            useImplantsBox.setToolTipText(resourceMap.getString(\"useImplantsBox.toolTipText\"));\n-            useImplantsBox.setName(\"useImplantsBox\");\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(useImplantsBox, gridBagConstraints);\n-\n-            chkCapturePrisoners.setText(resourceMap.getString(\"chkCapturePrisoners.text\"));\n-            chkCapturePrisoners.setToolTipText(resourceMap.getString(\"chkCapturePrisoners.toolTipText\"));\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(chkCapturePrisoners, gridBagConstraints);\n-\n-            DefaultComboBoxModel<String> prisonerStatusModel = new DefaultComboBoxModel<>();\n-            prisonerStatusModel.addElement(resourceMap.getString(\"prisonerStatus.Prisoner\"));\n-            prisonerStatusModel.addElement(resourceMap.getString(\"prisonerStatus.Bondsman\"));\n-            comboPrisonerStatus = new JComboBox<>(prisonerStatusModel);\n-            comboPrisonerStatus.setSelectedIndex(options.getDefaultPrisonerStatus());\n-            JPanel pnlPrisonerStatus = new JPanel();\n-            pnlPrisonerStatus.add(new JLabel(resourceMap.getString(\"prisonerStatus.text\")));\n-            pnlPrisonerStatus.add(comboPrisonerStatus);\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(pnlPrisonerStatus, gridBagConstraints);\n-\n-            altQualityAveragingCheckBox.setText(resourceMap.getString(\"altQualityAveragingCheckBox.text\"));\n-            altQualityAveragingCheckBox.setToolTipText(resourceMap.getString(\"altQualityAveragingCheckBox.toolTipText\"));\n-            altQualityAveragingCheckBox.setName(\"altQualityAveragingCheckBox\");\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(altQualityAveragingCheckBox, gridBagConstraints);\n-\n-            useAdvancedMedicalBox.setText(resourceMap.getString(\"useAdvancedMedicalBox.text\"));\n-            useAdvancedMedicalBox.setToolTipText(resourceMap.getString(\"useAdvancedMedicalBox.toolTipText\"));\n-            useAdvancedMedicalBox.setName(\"useAdvancedMedicalBox\");\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(useAdvancedMedicalBox, gridBagConstraints);\n-\n-            useDylansRandomXpBox.setText(resourceMap.getString(\"useDylansRandomXpBox.text\"));\n-            useDylansRandomXpBox.setToolTipText(resourceMap.getString(\"useDylansRandomXpBox.toolTipText\"));\n-            useDylansRandomXpBox.setName(\"useDylansRandomXpBox\");\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(useDylansRandomXpBox, gridBagConstraints);\n-\n-            spnHealWaitingPeriod = new JSpinner(new SpinnerNumberModel(options.getHealingWaitingPeriod(), 1, 30, 1));\n-            ((JSpinner.DefaultEditor) spnHealWaitingPeriod.getEditor()).getTextField().setEditable(false);\n-            JPanel pnlHealWaitingPeriod = new JPanel();\n-            pnlHealWaitingPeriod.add(spnHealWaitingPeriod);\n-            pnlHealWaitingPeriod.add(new JLabel(resourceMap.getString(\"healWaitingPeriod.text\")));\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(pnlHealWaitingPeriod, gridBagConstraints);\n-\n-            spnNaturalHealWaitingPeriod = new JSpinner(new SpinnerNumberModel(options.getNaturalHealingWaitingPeriod(),\n-                    1, 365, 1));\n-            ((JSpinner.DefaultEditor) spnNaturalHealWaitingPeriod.getEditor()).getTextField().setEditable(false);\n-            JPanel pnlNaturalHealWaitingPeriod = new JPanel();\n-            pnlNaturalHealWaitingPeriod.add(spnNaturalHealWaitingPeriod);\n-            pnlNaturalHealWaitingPeriod.add(new JLabel(resourceMap.getString(\"naturalHealWaitingPeriod.text\")));\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(pnlNaturalHealWaitingPeriod, gridBagConstraints);\n-\n-            spnMinimumHitsForVees = new JSpinner(new SpinnerNumberModel(options.getMinimumHitsForVees(), 1, 5, 1));\n-            ((JSpinner.DefaultEditor) spnMinimumHitsForVees.getEditor()).getTextField().setEditable(false);\n-            JPanel panMinimumHitsForVees = new JPanel();\n-            panMinimumHitsForVees.add(spnMinimumHitsForVees);\n-            panMinimumHitsForVees.add(new JLabel(resourceMap.getString(\"minimumHitsForVees.text\")));\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(panMinimumHitsForVees, gridBagConstraints);\n-\n-            useRandomHitsForVees = new JCheckBox();\n-            useRandomHitsForVees.setSelected(options.useRandomHitsForVees());\n-            useRandomHitsForVees.setText(resourceMap.getString(\"useRandomHitsForVees.text\"));\n-            useRandomHitsForVees.setToolTipText(resourceMap.getString(\"useRandomHitsForVees.toolTipText\"));\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(useRandomHitsForVees, gridBagConstraints);\n-\n-            useTougherHealing = new JCheckBox(resourceMap.getString(\"useTougherHealing.text\"));\n-            useTougherHealing.setSelected(options.useTougherHealing());\n-            useTougherHealing.setToolTipText(resourceMap.getString(\"useTougherHealing.toolTipText\"));\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(useTougherHealing, gridBagConstraints);\n-\n-            chkUseTransfers = new JCheckBox(resourceMap.getString(\"useTransfers.text\"));\n-            chkUseTransfers.setSelected(options.useTransfers());\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(chkUseTransfers, gridBagConstraints);\n-\n-            chkUseTimeInService = new JCheckBox(resourceMap.getString(\"useTimeInService.text\"));\n-            chkUseTimeInService.setSelected(options.getUseTimeInService());\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(chkUseTimeInService, gridBagConstraints);\n-\n-            chkShowOriginFaction = new JCheckBox(resourceMap.getString(\"showOriginFaction.text\"));\n-            chkShowOriginFaction.setSelected(options.showOriginFaction());\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(chkShowOriginFaction, gridBagConstraints);\n-\n-            chkRandomizeOrigin = new JCheckBox(resourceMap.getString(\"randomizeOrigin.text\"));\n-            chkRandomizeOrigin.setSelected(options.randomizeOrigin());\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(chkRandomizeOrigin, gridBagConstraints);\n-\n-            chkRandomizeDependentsOrigin = new JCheckBox(resourceMap.getString(\"randomizeDependentsOrigin.text\"));\n-            chkRandomizeDependentsOrigin.setSelected(options.getRandomizeDependentOrigin());\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(chkRandomizeDependentsOrigin, gridBagConstraints);\n-\n-            spnOriginSearchRadius = new JSpinner(new SpinnerNumberModel(options.getOriginSearchRadius(), 10, 250, 10));\n-            JPanel panOriginSearchRadius = new JPanel();\n-            panOriginSearchRadius.add(spnOriginSearchRadius);\n-            panOriginSearchRadius.add(new JLabel(resourceMap.getString(\"originSearchRadius.text\")));\n-            gridBagConstraints.gridy = ++gridy;\n-            panPersonnel.add(panOriginSearchRadius, gridBagConstraints);\n-\n-            //Family\n-            JPanel panFamily = new JPanel(new GridBagLayout());\n-            panFamily.setBorder(BorderFactory.createTitledBorder(resourceMap.getString(\"FamilyTab.text\")));\n-            int panFamilyGridY = ++gridy;\n-\n-            spnMinimumMarriageAge = new JSpinner(new SpinnerNumberModel(options.getMinimumMarriageAge(), 14, null, 1));\n-            Dimension dimensionMinimumMarriageAge = spnMinimumMarriageAge.getPreferredSize();\n-            dimensionMinimumMarriageAge.width = 40;\n-            spnMinimumMarriageAge.setPreferredSize(dimensionMinimumMarriageAge);\n-            JPanel panMinimumMarriageAge = new JPanel();\n-            panMinimumMarriageAge.add(new JLabel(resourceMap.getString(\"minimumMarriageAge.text\")));\n-            panMinimumMarriageAge.setToolTipText(resourceMap.getString(\"minimumMarriageAge.toolTipText\"));\n-            panMinimumMarriageAge.add(spnMinimumMarriageAge);\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(panMinimumMarriageAge, gridBagConstraints);\n-\n-            spnCheckMutualAncestorsDepth = new JSpinner(new SpinnerNumberModel(options.checkMutualAncestorsDepth(), 0, 20, 1));\n-            Dimension dimensionCheckMutualAncestorsDepth = spnCheckMutualAncestorsDepth.getPreferredSize();\n-            dimensionCheckMutualAncestorsDepth.width = 40;\n-            spnCheckMutualAncestorsDepth.setPreferredSize(dimensionCheckMutualAncestorsDepth);\n-            JPanel panCheckMutualAncestorsDepth = new JPanel();\n-            panCheckMutualAncestorsDepth.add(new JLabel(resourceMap.getString(\"checkMutualAncestorsDepth.text\")));\n-            panCheckMutualAncestorsDepth.setToolTipText(resourceMap.getString(\"checkMutualAncestorsDepth.toolTipText\"));\n-            panCheckMutualAncestorsDepth.add(spnCheckMutualAncestorsDepth);\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(panCheckMutualAncestorsDepth, gridBagConstraints);\n-\n-            chkUseRandomMarriages = new JCheckBox(resourceMap.getString(\"useRandomMarriages.text\"));\n-            chkUseRandomMarriages.setToolTipText(resourceMap.getString(\"useRandomMarriages.toolTipText\"));\n-            chkUseRandomMarriages.setSelected(options.useRandomMarriages());\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(chkUseRandomMarriages, gridBagConstraints);\n-\n-            spnChanceRandomMarriages = new JSpinner(new SpinnerNumberModel(options.getChanceRandomMarriages(), 0, 100, 0.001));\n-            Dimension dimensionChanceRandomMarriages = spnChanceRandomMarriages.getPreferredSize();\n-            dimensionChanceRandomMarriages.width = 50;\n-            spnChanceRandomMarriages.setPreferredSize(dimensionChanceRandomMarriages);\n-            JPanel panChanceRandomMarriages = new JPanel();\n-            panChanceRandomMarriages.add(new JLabel(resourceMap.getString(\"chanceRandomMarriages.text\")));\n-            panChanceRandomMarriages.setToolTipText(resourceMap.getString(\"chanceRandomMarriages.toolTipText\"));\n-            panChanceRandomMarriages.add(spnChanceRandomMarriages);\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(panChanceRandomMarriages, gridBagConstraints);\n-\n-            spnMarriageAgeRange = new JSpinner(new SpinnerNumberModel(options.getMarriageAgeRange(), 0, null, 1));\n-            Dimension dimensionMarriageAgeRange = spnMarriageAgeRange.getPreferredSize();\n-            dimensionMarriageAgeRange.width = 40;\n-            spnMarriageAgeRange.setPreferredSize(dimensionMarriageAgeRange);\n-            JPanel panMarriageAgeRange = new JPanel();\n-            panMarriageAgeRange.add(new JLabel(resourceMap.getString(\"marriageAgeRange.text\")));\n-            panMarriageAgeRange.setToolTipText(resourceMap.getString(\"marriageAgeRange.toolTipText\"));\n-            panMarriageAgeRange.add(spnMarriageAgeRange);\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(panMarriageAgeRange, gridBagConstraints);\n-\n-            JPanel panRandomMarriageSurnameWeights = new JPanel(new GridLayout((int) Math.ceil(Person.NUM_SURNAME / 3.0), 3));\n-            panRandomMarriageSurnameWeights.setBorder(BorderFactory.createTitledBorder(resourceMap.getString(\"randomMarriageSurnameWeights.text\")));\n-            panRandomMarriageSurnameWeights.setToolTipText(resourceMap.getString(\"randomMarriageSurnameWeights.toolTipText\"));\n-            spnRandomMarriageSurnameWeights = new JSpinner[Person.NUM_SURNAME];\n-            JSpinner spnRandomMarriageSurnameWeight;\n-            JPanel panRandomMarriageSurnameWeight;\n-            for (int i = 0; i < Person.NUM_SURNAME; i++) {\n-                spnRandomMarriageSurnameWeight = new JSpinner(new SpinnerNumberModel((options.getRandomMarriageSurnameWeights(i) / 10.0), 0, 100, 0.1));\n-                panRandomMarriageSurnameWeight = new JPanel();\n-                panRandomMarriageSurnameWeight.add(spnRandomMarriageSurnameWeight);\n-                panRandomMarriageSurnameWeight.add(new JLabel(Person.SURNAME_TYPE_NAMES[i]));\n-                panRandomMarriageSurnameWeights.add(panRandomMarriageSurnameWeight);\n-                spnRandomMarriageSurnameWeights[i] = spnRandomMarriageSurnameWeight;\n-            }\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(panRandomMarriageSurnameWeights, gridBagConstraints);\n-\n-            chkUseRandomSameSexMarriages = new JCheckBox(resourceMap.getString(\"useRandomSameSexMarriages.text\"));\n-            chkUseRandomSameSexMarriages.setToolTipText(resourceMap.getString(\"useRandomSameSexMarriages.toolTipText\"));\n-            chkUseRandomSameSexMarriages.setSelected(options.useRandomSameSexMarriages());\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(chkUseRandomSameSexMarriages, gridBagConstraints);\n-\n-            spnChanceRandomSameSexMarriages = new JSpinner(new SpinnerNumberModel(options.getChanceRandomSameSexMarriages(), 0, 100, 0.001));\n-            Dimension dimensionChanceRandomSameSexMarriages = spnChanceRandomSameSexMarriages.getPreferredSize();\n-            dimensionChanceRandomSameSexMarriages.width = 50;\n-            spnChanceRandomSameSexMarriages.setPreferredSize(dimensionChanceRandomSameSexMarriages);\n-            JPanel panChanceRandomSameSexMarriages = new JPanel();\n-            panChanceRandomSameSexMarriages.add(new JLabel(resourceMap.getString(\"chanceRandomSameSexMarriages.text\")));\n-            panChanceRandomSameSexMarriages.setToolTipText(resourceMap.getString(\"chanceRandomSameSexMarriages.toolTipText\"));\n-            panChanceRandomSameSexMarriages.add(spnChanceRandomSameSexMarriages);\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(panChanceRandomSameSexMarriages, gridBagConstraints);\n-\n-            chkUseUnofficialProcreation = new JCheckBox(resourceMap.getString(\"useUnofficialProcreation.text\"));\n-            chkUseUnofficialProcreation.setSelected(options.useUnofficialProcreation());\n-            chkUseUnofficialProcreation.setToolTipText(resourceMap.getString(\"useUnofficialProcreation.toolTipText\"));\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(chkUseUnofficialProcreation, gridBagConstraints);\n-\n-            spnChanceProcreation = new JSpinner(new SpinnerNumberModel(options.getChanceProcreation(), 0, 100, 0.001));\n-            Dimension dimensionChanceProcreation = spnChanceProcreation.getPreferredSize();\n-            dimensionChanceProcreation.width = 50;\n-            spnChanceProcreation.setPreferredSize(dimensionChanceProcreation);\n-            JPanel panChanceProcreation = new JPanel();\n-            panChanceProcreation.add(new JLabel(resourceMap.getString(\"chanceProcreation.text\")));\n-            panChanceProcreation.setToolTipText(resourceMap.getString(\"chanceProcreation.toolTipText\"));\n-            panChanceProcreation.add(spnChanceProcreation);\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(panChanceProcreation, gridBagConstraints);\n-\n-            chkUseUnofficialProcreationNoRelationship = new JCheckBox(resourceMap.getString(\"useUnofficialProcreationNoRelationship.text\"));\n-            chkUseUnofficialProcreationNoRelationship.setToolTipText(resourceMap.getString(\"useUnofficialProcreationNoRelationship.toolTipText\"));\n-            chkUseUnofficialProcreationNoRelationship.setSelected(options.useUnofficialProcreationNoRelationship());\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(chkUseUnofficialProcreationNoRelationship, gridBagConstraints);\n-\n-            spnChanceProcreationNoRelationship = new JSpinner(new SpinnerNumberModel(options.getChanceProcreationNoRelationship(), 0, 100, 0.001));\n-            Dimension dimensionChanceProcreationNoRelationship = spnChanceProcreationNoRelationship.getPreferredSize();\n-            dimensionChanceProcreationNoRelationship.width = 50;\n-            spnChanceProcreationNoRelationship.setPreferredSize(dimensionChanceProcreationNoRelationship);\n-            JPanel panChanceProcreationNoRelationship = new JPanel();\n-            panChanceProcreationNoRelationship.add(new JLabel(resourceMap.getString(\"chanceProcreationNoRelationship.text\")));\n-            panChanceProcreationNoRelationship.setToolTipText(resourceMap.getString(\"chanceProcreationNoRelationship.toolTipText\"));\n-            panChanceProcreationNoRelationship.add(spnChanceProcreationNoRelationship);\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(panChanceProcreationNoRelationship, gridBagConstraints);\n-\n-            chkDisplayTrueDueDate = new JCheckBox(resourceMap.getString(\"displayTrueDueDate.text\"));\n-            chkDisplayTrueDueDate.setToolTipText(resourceMap.getString(\"displayTrueDueDate.toolTipText\"));\n-            chkDisplayTrueDueDate.setSelected(options.getDisplayTrueDueDate());\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(chkDisplayTrueDueDate, gridBagConstraints);\n-\n-            chkLogConception = new JCheckBox(resourceMap.getString(\"logConception.text\"));\n-            chkLogConception.setSelected(options.logConception());\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(chkLogConception, gridBagConstraints);\n-\n-            DefaultComboBoxModel<String> babySurnameStyleModel = new DefaultComboBoxModel<>();\n-            babySurnameStyleModel.addElement(resourceMap.getString(\"babySurnameStyle.Mother\"));\n-            babySurnameStyleModel.addElement(resourceMap.getString(\"babySurnameStyle.Father\"));\n-            comboBabySurnameStyle = new JComboBox<>(babySurnameStyleModel);\n-            comboBabySurnameStyle.setSelectedIndex(options.getBabySurnameStyle());\n-            JPanel pnlBabySurnameStyle = new JPanel();\n-            pnlBabySurnameStyle.add(new JLabel(resourceMap.getString(\"babySurnameStyle.text\")));\n-            pnlBabySurnameStyle.setToolTipText(resourceMap.getString(\"babySurnameStyle.toolTipText\"));\n-            pnlBabySurnameStyle.add(comboBabySurnameStyle);\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(pnlBabySurnameStyle, gridBagConstraints);\n-\n-            chkUseParentage = new JCheckBox(resourceMap.getString(\"useParentage.text\"));\n-            chkUseParentage.setSelected(options.useParentage());\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(chkUseParentage, gridBagConstraints);\n-\n-            DefaultComboBoxModel<String> familyLevelStatusModel = new DefaultComboBoxModel<>();\n-            familyLevelStatusModel.addElement(resourceMap.getString(\"displayFamilyLevel.ParentsChildren\"));\n-            familyLevelStatusModel.addElement(resourceMap.getString(\"displayFamilyLevel.GrandparentsGrandchildren\"));\n-            familyLevelStatusModel.addElement(resourceMap.getString(\"displayFamilyLevel.AuntsUnclesCousins\"));\n-            comboDisplayFamilyLevel = new JComboBox<>(familyLevelStatusModel);\n-            comboDisplayFamilyLevel.setSelectedIndex(options.displayFamilyLevel());\n-            JPanel pnlDisplayFamilyLevel = new JPanel();\n-            pnlDisplayFamilyLevel.add(new JLabel(resourceMap.getString(\"displayFamilyLevel.text\")));\n-            pnlDisplayFamilyLevel.setToolTipText(resourceMap.getString(\"displayFamilyLevel.toolTipText\"));\n-            pnlDisplayFamilyLevel.add(comboDisplayFamilyLevel);\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(pnlDisplayFamilyLevel, gridBagConstraints);\n-\n-            chkUseRandomDeaths = new JCheckBox(resourceMap.getString(\"useRandomDeaths.text\"));\n-            chkUseRandomDeaths.setToolTipText(resourceMap.getString(\"useRandomDeaths.toolTipText\"));\n-            chkUseRandomDeaths.setSelected(options.useRandomDeaths());\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(chkUseRandomDeaths, gridBagConstraints);\n-\n-            chkKeepMarriedNameUponSpouseDeath = new JCheckBox(resourceMap.getString(\"keepMarriedNameUponSpouseDeath.text\"));\n-            chkKeepMarriedNameUponSpouseDeath.setSelected(options.getKeepMarriedNameUponSpouseDeath());\n-            gridBagConstraints.gridy = ++gridy;\n-            panFamily.add(chkKeepMarriedNameUponSpouseDeath, gridBagConstraints);\n-\n-            gridBagConstraints.gridy = panFamilyGridY;\n-            panPersonnel.add(panFamily, gridBagConstraints);\n-\n-            //Salary\n-            JPanel panSalary = new JPanel(new GridBagLayout());\n-            panSalary.setBorder(BorderFactory.createTitledBorder(resourceMap.getString(\"SalaryTab.text\")));\n-\n-            JPanel panMultiplier = new JPanel(new GridLayout(1, 3));\n-            panMultiplier.setBorder(BorderFactory.createTitledBorder(\"Multipliers\"));\n-            spnSalaryCommission = new JSpinner(new SpinnerNumberModel(options.getSalaryCommissionMultiplier(), 0, 10, 0.05));\n-            ((JSpinner.DefaultEditor) spnSalaryCommission.getEditor()).getTextField().setEditable(false);\n-            JPanel panSalaryCommission = new JPanel();\n-            panSalaryCommission.add(spnSalaryCommission);\n-            panSalaryCommission.add(new JLabel(\"Commissioned\"));\n-            panMultiplier.add(panSalaryCommission);\n-\n-            spnSalaryEnlisted = new JSpinner(new SpinnerNumberModel(options.getSalaryEnlistedMultiplier(), 0, 10, 0.05));\n-            ((JSpinner.DefaultEditor) spnSalaryEnlisted.getEditor()).getTextField().setEditable(false);\n-            JPanel panSalaryEnlisted = new JPanel();\n-            panSalaryEnlisted.add(spnSalaryEnlisted);\n-            panSalaryEnlisted.add(new JLabel(\"Enlisted\"));\n-            panMultiplier.add(panSalaryEnlisted);\n-\n-            spnSalaryAntiMek = new JSpinner(new SpinnerNumberModel(options.getSalaryAntiMekMultiplier(), 0, 10, 0.05));\n-            ((JSpinner.DefaultEditor) spnSalaryAntiMek.getEditor()).getTextField().setEditable(false);\n-            JPanel panSalaryAntiMek = new JPanel();\n-            panSalaryAntiMek.add(spnSalaryAntiMek);\n-            panSalaryAntiMek.add(new JLabel(\"Anti-Mek\"));\n-            panMultiplier.add(panSalaryAntiMek);\n+        useTacticsBox.setText(resourceMap.getString(\"useTacticsBox.text\"));\n+        useTacticsBox.setToolTipText(resourceMap.getString(\"useTacticsBox.toolTipText\"));\n+        useTacticsBox.setName(\"useTacticsBox\");\n+        gridBagConstraints = new java.awt.GridBagConstraints();\n+        gridBagConstraints.gridx = 0;\n+        gridBagConstraints.gridy = gridy;\n+        gridBagConstraints.gridwidth = 2;\n+        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n+        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n+        panPersonnel.add(useTacticsBox, gridBagConstraints);\n+\n+        useInitBonusBox.setText(resourceMap.getString(\"useInitBonusBox.text\"));\n+        useInitBonusBox.setToolTipText(resourceMap.getString(\"useInitBonusBox.toolTipText\"));\n+        useInitBonusBox.setName(\"useInitBonusBox\");\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(useInitBonusBox, gridBagConstraints);\n+\n+        useToughnessBox.setText(resourceMap.getString(\"useToughnessBox.text\"));\n+        useToughnessBox.setToolTipText(resourceMap.getString(\"useToughnessBox.toolTipText\"));\n+        useToughnessBox.setName(\"useToughnessBox\");\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(useToughnessBox, gridBagConstraints);\n+\n+        useArtilleryBox.setText(resourceMap.getString(\"useArtilleryBox.text\"));\n+        useArtilleryBox.setToolTipText(resourceMap.getString(\"useArtilleryBox.toolTipText\"));\n+        useArtilleryBox.setName(\"useArtilleryBox\");\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(useArtilleryBox, gridBagConstraints);\n+\n+        useAbilitiesBox.setText(resourceMap.getString(\"useAbilitiesBox.text\"));\n+        useAbilitiesBox.setToolTipText(resourceMap.getString(\"useAbilitiesBox.toolTipText\"));\n+        useAbilitiesBox.setName(\"useAbilitiesBox\");\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(useAbilitiesBox, gridBagConstraints);\n+\n+        useEdgeBox.setText(resourceMap.getString(\"useEdgeBox.text\"));\n+        useEdgeBox.setToolTipText(resourceMap.getString(\"useEdgeBox.toolTipText\"));\n+        useEdgeBox.setName(\"useEdgeBox\");\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(useEdgeBox, gridBagConstraints);\n+\n+        useSupportEdgeBox.setText(resourceMap.getString(\"useSupportEdgeBox.text\"));\n+        useSupportEdgeBox.setToolTipText(resourceMap.getString(\"useSupportEdgeBox.toolTipText\"));\n+        useSupportEdgeBox.setName(\"useSupportEdgeBox\");\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(useSupportEdgeBox, gridBagConstraints);\n+\n+        useImplantsBox.setText(resourceMap.getString(\"useImplantsBox.text\"));\n+        useImplantsBox.setToolTipText(resourceMap.getString(\"useImplantsBox.toolTipText\"));\n+        useImplantsBox.setName(\"useImplantsBox\");\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(useImplantsBox, gridBagConstraints);\n+\n+        chkCapturePrisoners.setText(resourceMap.getString(\"chkCapturePrisoners.text\"));\n+        chkCapturePrisoners.setToolTipText(resourceMap.getString(\"chkCapturePrisoners.toolTipText\"));\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(chkCapturePrisoners, gridBagConstraints);\n+\n+        DefaultComboBoxModel<String> prisonerStatusModel = new DefaultComboBoxModel<>();\n+        prisonerStatusModel.addElement(resourceMap.getString(\"prisonerStatus.Prisoner\"));\n+        prisonerStatusModel.addElement(resourceMap.getString(\"prisonerStatus.Bondsman\"));\n+        comboPrisonerStatus = new JComboBox<>(prisonerStatusModel);\n+        comboPrisonerStatus.setSelectedIndex(options.getDefaultPrisonerStatus());\n+        JPanel pnlPrisonerStatus = new JPanel();\n+        pnlPrisonerStatus.add(new JLabel(resourceMap.getString(\"prisonerStatus.text\")));\n+        pnlPrisonerStatus.add(comboPrisonerStatus);\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(pnlPrisonerStatus, gridBagConstraints);\n+\n+        altQualityAveragingCheckBox.setText(resourceMap.getString(\"altQualityAveragingCheckBox.text\"));\n+        altQualityAveragingCheckBox.setToolTipText(resourceMap.getString(\"altQualityAveragingCheckBox.toolTipText\"));\n+        altQualityAveragingCheckBox.setName(\"altQualityAveragingCheckBox\");\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(altQualityAveragingCheckBox, gridBagConstraints);\n+\n+        useAdvancedMedicalBox.setText(resourceMap.getString(\"useAdvancedMedicalBox.text\"));\n+        useAdvancedMedicalBox.setToolTipText(resourceMap.getString(\"useAdvancedMedicalBox.toolTipText\"));\n+        useAdvancedMedicalBox.setName(\"useAdvancedMedicalBox\");\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(useAdvancedMedicalBox, gridBagConstraints);\n+\n+        useDylansRandomXpBox.setText(resourceMap.getString(\"useDylansRandomXpBox.text\"));\n+        useDylansRandomXpBox.setToolTipText(resourceMap.getString(\"useDylansRandomXpBox.toolTipText\"));\n+        useDylansRandomXpBox.setName(\"useDylansRandomXpBox\");\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(useDylansRandomXpBox, gridBagConstraints);\n+\n+        spnHealWaitingPeriod = new JSpinner(new SpinnerNumberModel(options.getHealingWaitingPeriod(), 1, 30, 1));\n+        ((JSpinner.DefaultEditor) spnHealWaitingPeriod.getEditor()).getTextField().setEditable(false);\n+        JPanel pnlHealWaitingPeriod = new JPanel();\n+        pnlHealWaitingPeriod.add(spnHealWaitingPeriod);\n+        pnlHealWaitingPeriod.add(new JLabel(resourceMap.getString(\"healWaitingPeriod.text\")));\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(pnlHealWaitingPeriod, gridBagConstraints);\n+\n+        spnNaturalHealWaitingPeriod = new JSpinner(new SpinnerNumberModel(options.getNaturalHealingWaitingPeriod(),\n+                1, 365, 1));\n+        ((JSpinner.DefaultEditor) spnNaturalHealWaitingPeriod.getEditor()).getTextField().setEditable(false);\n+        JPanel pnlNaturalHealWaitingPeriod = new JPanel();\n+        pnlNaturalHealWaitingPeriod.add(spnNaturalHealWaitingPeriod);\n+        pnlNaturalHealWaitingPeriod.add(new JLabel(resourceMap.getString(\"naturalHealWaitingPeriod.text\")));\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(pnlNaturalHealWaitingPeriod, gridBagConstraints);\n+\n+        spnMinimumHitsForVees = new JSpinner(new SpinnerNumberModel(options.getMinimumHitsForVees(), 1, 5, 1));\n+        ((JSpinner.DefaultEditor) spnMinimumHitsForVees.getEditor()).getTextField().setEditable(false);\n+        JPanel panMinimumHitsForVees = new JPanel();\n+        panMinimumHitsForVees.add(spnMinimumHitsForVees);\n+        panMinimumHitsForVees.add(new JLabel(resourceMap.getString(\"minimumHitsForVees.text\")));\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(panMinimumHitsForVees, gridBagConstraints);\n+\n+        useRandomHitsForVees = new JCheckBox();\n+        useRandomHitsForVees.setSelected(options.useRandomHitsForVees());\n+        useRandomHitsForVees.setText(resourceMap.getString(\"useRandomHitsForVees.text\"));\n+        useRandomHitsForVees.setToolTipText(resourceMap.getString(\"useRandomHitsForVees.toolTipText\"));\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(useRandomHitsForVees, gridBagConstraints);\n+\n+        useTougherHealing = new JCheckBox(resourceMap.getString(\"useTougherHealing.text\"));\n+        useTougherHealing.setSelected(options.useTougherHealing());\n+        useTougherHealing.setToolTipText(resourceMap.getString(\"useTougherHealing.toolTipText\"));\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(useTougherHealing, gridBagConstraints);\n+\n+        chkUseTransfers = new JCheckBox(resourceMap.getString(\"useTransfers.text\"));\n+        chkUseTransfers.setSelected(options.useTransfers());\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(chkUseTransfers, gridBagConstraints);\n+\n+        chkUseTimeInService = new JCheckBox(resourceMap.getString(\"useTimeInService.text\"));\n+        chkUseTimeInService.setSelected(options.getUseTimeInService());\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(chkUseTimeInService, gridBagConstraints);\n+\n+        chkShowOriginFaction = new JCheckBox(resourceMap.getString(\"showOriginFaction.text\"));\n+        chkShowOriginFaction.setSelected(options.showOriginFaction());\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(chkShowOriginFaction, gridBagConstraints);\n+\n+        chkRandomizeOrigin = new JCheckBox(resourceMap.getString(\"randomizeOrigin.text\"));\n+        chkRandomizeOrigin.setSelected(options.randomizeOrigin());\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(chkRandomizeOrigin, gridBagConstraints);\n+\n+        chkRandomizeDependentsOrigin = new JCheckBox(resourceMap.getString(\"randomizeDependentsOrigin.text\"));\n+        chkRandomizeDependentsOrigin.setSelected(options.getRandomizeDependentOrigin());\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(chkRandomizeDependentsOrigin, gridBagConstraints);\n+\n+        spnOriginSearchRadius = new JSpinner(new SpinnerNumberModel(options.getOriginSearchRadius(), 10, 250, 10));\n+        JPanel panOriginSearchRadius = new JPanel();\n+        panOriginSearchRadius.add(spnOriginSearchRadius);\n+        panOriginSearchRadius.add(new JLabel(resourceMap.getString(\"originSearchRadius.text\")));\n+        gridBagConstraints.gridy = ++gridy;\n+        panPersonnel.add(panOriginSearchRadius, gridBagConstraints);\n+\n+        //Family\n+        JPanel panFamily = new JPanel(new GridBagLayout());\n+        panFamily.setBorder(BorderFactory.createTitledBorder(resourceMap.getString(\"FamilyTab.text\")));\n+        int panFamilyGridY = ++gridy;\n+\n+        spnMinimumMarriageAge = new JSpinner(new SpinnerNumberModel(options.getMinimumMarriageAge(), 14, null, 1));\n+        Dimension dimensionMinimumMarriageAge = spnMinimumMarriageAge.getPreferredSize();\n+        dimensionMinimumMarriageAge.width = 40;\n+        spnMinimumMarriageAge.setPreferredSize(dimensionMinimumMarriageAge);\n+        JPanel panMinimumMarriageAge = new JPanel();\n+        panMinimumMarriageAge.add(new JLabel(resourceMap.getString(\"minimumMarriageAge.text\")));\n+        panMinimumMarriageAge.setToolTipText(resourceMap.getString(\"minimumMarriageAge.toolTipText\"));\n+        panMinimumMarriageAge.add(spnMinimumMarriageAge);\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(panMinimumMarriageAge, gridBagConstraints);\n+\n+        spnCheckMutualAncestorsDepth = new JSpinner(new SpinnerNumberModel(options.checkMutualAncestorsDepth(), 0, 20, 1));\n+        Dimension dimensionCheckMutualAncestorsDepth = spnCheckMutualAncestorsDepth.getPreferredSize();\n+        dimensionCheckMutualAncestorsDepth.width = 40;\n+        spnCheckMutualAncestorsDepth.setPreferredSize(dimensionCheckMutualAncestorsDepth);\n+        JPanel panCheckMutualAncestorsDepth = new JPanel();\n+        panCheckMutualAncestorsDepth.add(new JLabel(resourceMap.getString(\"checkMutualAncestorsDepth.text\")));\n+        panCheckMutualAncestorsDepth.setToolTipText(resourceMap.getString(\"checkMutualAncestorsDepth.toolTipText\"));\n+        panCheckMutualAncestorsDepth.add(spnCheckMutualAncestorsDepth);\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(panCheckMutualAncestorsDepth, gridBagConstraints);\n+\n+        chkUseRandomMarriages = new JCheckBox(resourceMap.getString(\"useRandomMarriages.text\"));\n+        chkUseRandomMarriages.setToolTipText(resourceMap.getString(\"useRandomMarriages.toolTipText\"));\n+        chkUseRandomMarriages.setSelected(options.useRandomMarriages());\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(chkUseRandomMarriages, gridBagConstraints);\n+\n+        spnChanceRandomMarriages = new JSpinner(new SpinnerNumberModel(options.getChanceRandomMarriages(), 0, 100, 0.001));\n+        Dimension dimensionChanceRandomMarriages = spnChanceRandomMarriages.getPreferredSize();\n+        dimensionChanceRandomMarriages.width = 50;\n+        spnChanceRandomMarriages.setPreferredSize(dimensionChanceRandomMarriages);\n+        JPanel panChanceRandomMarriages = new JPanel();\n+        panChanceRandomMarriages.add(new JLabel(resourceMap.getString(\"chanceRandomMarriages.text\")));\n+        panChanceRandomMarriages.setToolTipText(resourceMap.getString(\"chanceRandomMarriages.toolTipText\"));\n+        panChanceRandomMarriages.add(spnChanceRandomMarriages);\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(panChanceRandomMarriages, gridBagConstraints);\n+\n+        spnMarriageAgeRange = new JSpinner(new SpinnerNumberModel(options.getMarriageAgeRange(), 0, null, 1));\n+        Dimension dimensionMarriageAgeRange = spnMarriageAgeRange.getPreferredSize();\n+        dimensionMarriageAgeRange.width = 40;\n+        spnMarriageAgeRange.setPreferredSize(dimensionMarriageAgeRange);\n+        JPanel panMarriageAgeRange = new JPanel();\n+        panMarriageAgeRange.add(new JLabel(resourceMap.getString(\"marriageAgeRange.text\")));\n+        panMarriageAgeRange.setToolTipText(resourceMap.getString(\"marriageAgeRange.toolTipText\"));\n+        panMarriageAgeRange.add(spnMarriageAgeRange);\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(panMarriageAgeRange, gridBagConstraints);\n+\n+        JPanel panRandomMarriageSurnameWeights = new JPanel(new GridLayout((int) Math.ceil(Person.NUM_SURNAME / 3.0), 3));\n+        panRandomMarriageSurnameWeights.setBorder(BorderFactory.createTitledBorder(resourceMap.getString(\"randomMarriageSurnameWeights.text\")));\n+        panRandomMarriageSurnameWeights.setToolTipText(resourceMap.getString(\"randomMarriageSurnameWeights.toolTipText\"));\n+        spnRandomMarriageSurnameWeights = new JSpinner[Person.NUM_SURNAME];\n+        JSpinner spnRandomMarriageSurnameWeight;\n+        JPanel panRandomMarriageSurnameWeight;\n+        for (int i = 0; i < Person.NUM_SURNAME; i++) {\n+            spnRandomMarriageSurnameWeight = new JSpinner(new SpinnerNumberModel((options.getRandomMarriageSurnameWeights(i) / 10.0), 0, 100, 0.1));\n+            panRandomMarriageSurnameWeight = new JPanel();\n+            panRandomMarriageSurnameWeight.add(spnRandomMarriageSurnameWeight);\n+            panRandomMarriageSurnameWeight.add(new JLabel(Person.SURNAME_TYPE_NAMES[i]));\n+            panRandomMarriageSurnameWeights.add(panRandomMarriageSurnameWeight);\n+            spnRandomMarriageSurnameWeights[i] = spnRandomMarriageSurnameWeight;\n+        }\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(panRandomMarriageSurnameWeights, gridBagConstraints);\n+\n+        chkUseRandomSameSexMarriages = new JCheckBox(resourceMap.getString(\"useRandomSameSexMarriages.text\"));\n+        chkUseRandomSameSexMarriages.setToolTipText(resourceMap.getString(\"useRandomSameSexMarriages.toolTipText\"));\n+        chkUseRandomSameSexMarriages.setSelected(options.useRandomSameSexMarriages());\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(chkUseRandomSameSexMarriages, gridBagConstraints);\n+\n+        spnChanceRandomSameSexMarriages = new JSpinner(new SpinnerNumberModel(options.getChanceRandomSameSexMarriages(), 0, 100, 0.001));\n+        Dimension dimensionChanceRandomSameSexMarriages = spnChanceRandomSameSexMarriages.getPreferredSize();\n+        dimensionChanceRandomSameSexMarriages.width = 50;\n+        spnChanceRandomSameSexMarriages.setPreferredSize(dimensionChanceRandomSameSexMarriages);\n+        JPanel panChanceRandomSameSexMarriages = new JPanel();\n+        panChanceRandomSameSexMarriages.add(new JLabel(resourceMap.getString(\"chanceRandomSameSexMarriages.text\")));\n+        panChanceRandomSameSexMarriages.setToolTipText(resourceMap.getString(\"chanceRandomSameSexMarriages.toolTipText\"));\n+        panChanceRandomSameSexMarriages.add(spnChanceRandomSameSexMarriages);\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(panChanceRandomSameSexMarriages, gridBagConstraints);\n+\n+        chkUseUnofficialProcreation = new JCheckBox(resourceMap.getString(\"useUnofficialProcreation.text\"));\n+        chkUseUnofficialProcreation.setSelected(options.useUnofficialProcreation());\n+        chkUseUnofficialProcreation.setToolTipText(resourceMap.getString(\"useUnofficialProcreation.toolTipText\"));\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(chkUseUnofficialProcreation, gridBagConstraints);\n+\n+        spnChanceProcreation = new JSpinner(new SpinnerNumberModel(options.getChanceProcreation(), 0, 100, 0.001));\n+        Dimension dimensionChanceProcreation = spnChanceProcreation.getPreferredSize();\n+        dimensionChanceProcreation.width = 50;\n+        spnChanceProcreation.setPreferredSize(dimensionChanceProcreation);\n+        JPanel panChanceProcreation = new JPanel();\n+        panChanceProcreation.add(new JLabel(resourceMap.getString(\"chanceProcreation.text\")));\n+        panChanceProcreation.setToolTipText(resourceMap.getString(\"chanceProcreation.toolTipText\"));\n+        panChanceProcreation.add(spnChanceProcreation);\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(panChanceProcreation, gridBagConstraints);\n+\n+        chkUseUnofficialProcreationNoRelationship = new JCheckBox(resourceMap.getString(\"useUnofficialProcreationNoRelationship.text\"));\n+        chkUseUnofficialProcreationNoRelationship.setToolTipText(resourceMap.getString(\"useUnofficialProcreationNoRelationship.toolTipText\"));\n+        chkUseUnofficialProcreationNoRelationship.setSelected(options.useUnofficialProcreationNoRelationship());\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(chkUseUnofficialProcreationNoRelationship, gridBagConstraints);\n+\n+        spnChanceProcreationNoRelationship = new JSpinner(new SpinnerNumberModel(options.getChanceProcreationNoRelationship(), 0, 100, 0.001));\n+        Dimension dimensionChanceProcreationNoRelationship = spnChanceProcreationNoRelationship.getPreferredSize();\n+        dimensionChanceProcreationNoRelationship.width = 50;\n+        spnChanceProcreationNoRelationship.setPreferredSize(dimensionChanceProcreationNoRelationship);\n+        JPanel panChanceProcreationNoRelationship = new JPanel();\n+        panChanceProcreationNoRelationship.add(new JLabel(resourceMap.getString(\"chanceProcreationNoRelationship.text\")));\n+        panChanceProcreationNoRelationship.setToolTipText(resourceMap.getString(\"chanceProcreationNoRelationship.toolTipText\"));\n+        panChanceProcreationNoRelationship.add(spnChanceProcreationNoRelationship);\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(panChanceProcreationNoRelationship, gridBagConstraints);\n+\n+        chkDisplayTrueDueDate = new JCheckBox(resourceMap.getString(\"displayTrueDueDate.text\"));\n+        chkDisplayTrueDueDate.setToolTipText(resourceMap.getString(\"displayTrueDueDate.toolTipText\"));\n+        chkDisplayTrueDueDate.setSelected(options.getDisplayTrueDueDate());\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(chkDisplayTrueDueDate, gridBagConstraints);\n+\n+        chkLogConception = new JCheckBox(resourceMap.getString(\"logConception.text\"));\n+        chkLogConception.setSelected(options.logConception());\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(chkLogConception, gridBagConstraints);\n+\n+        DefaultComboBoxModel<String> babySurnameStyleModel = new DefaultComboBoxModel<>();\n+        babySurnameStyleModel.addElement(resourceMap.getString(\"babySurnameStyle.Mother\"));\n+        babySurnameStyleModel.addElement(resourceMap.getString(\"babySurnameStyle.Father\"));\n+        comboBabySurnameStyle = new JComboBox<>(babySurnameStyleModel);\n+        comboBabySurnameStyle.setSelectedIndex(options.getBabySurnameStyle());\n+        JPanel pnlBabySurnameStyle = new JPanel();\n+        pnlBabySurnameStyle.add(new JLabel(resourceMap.getString(\"babySurnameStyle.text\")));\n+        pnlBabySurnameStyle.setToolTipText(resourceMap.getString(\"babySurnameStyle.toolTipText\"));\n+        pnlBabySurnameStyle.add(comboBabySurnameStyle);\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(pnlBabySurnameStyle, gridBagConstraints);\n+\n+        chkUseParentage = new JCheckBox(resourceMap.getString(\"useParentage.text\"));\n+        chkUseParentage.setSelected(options.useParentage());\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(chkUseParentage, gridBagConstraints);\n+\n+        DefaultComboBoxModel<String> familyLevelStatusModel = new DefaultComboBoxModel<>();\n+        familyLevelStatusModel.addElement(resourceMap.getString(\"displayFamilyLevel.ParentsChildren\"));\n+        familyLevelStatusModel.addElement(resourceMap.getString(\"displayFamilyLevel.GrandparentsGrandchildren\"));\n+        familyLevelStatusModel.addElement(resourceMap.getString(\"displayFamilyLevel.AuntsUnclesCousins\"));\n+        comboDisplayFamilyLevel = new JComboBox<>(familyLevelStatusModel);\n+        comboDisplayFamilyLevel.setSelectedIndex(options.displayFamilyLevel());\n+        JPanel pnlDisplayFamilyLevel = new JPanel();\n+        pnlDisplayFamilyLevel.add(new JLabel(resourceMap.getString(\"displayFamilyLevel.text\")));\n+        pnlDisplayFamilyLevel.setToolTipText(resourceMap.getString(\"displayFamilyLevel.toolTipText\"));\n+        pnlDisplayFamilyLevel.add(comboDisplayFamilyLevel);\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(pnlDisplayFamilyLevel, gridBagConstraints);\n+\n+        chkUseRandomDeaths = new JCheckBox(resourceMap.getString(\"useRandomDeaths.text\"));\n+        chkUseRandomDeaths.setToolTipText(resourceMap.getString(\"useRandomDeaths.toolTipText\"));\n+        chkUseRandomDeaths.setSelected(options.useRandomDeaths());\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(chkUseRandomDeaths, gridBagConstraints);\n+\n+        chkKeepMarriedNameUponSpouseDeath = new JCheckBox(resourceMap.getString(\"keepMarriedNameUponSpouseDeath.text\"));\n+        chkKeepMarriedNameUponSpouseDeath.setSelected(options.getKeepMarriedNameUponSpouseDeath());\n+        gridBagConstraints.gridy = ++gridy;\n+        panFamily.add(chkKeepMarriedNameUponSpouseDeath, gridBagConstraints);\n+\n+        gridBagConstraints.gridy = panFamilyGridY;\n+        panPersonnel.add(panFamily, gridBagConstraints);\n+\n+        //Salary\n+        JPanel panSalary = new JPanel(new GridBagLayout());\n+        panSalary.setBorder(BorderFactory.createTitledBorder(resourceMap.getString(\"SalaryTab.text\")));\n+\n+        JPanel panMultiplier = new JPanel(new GridLayout(1, 3));\n+        panMultiplier.setBorder(BorderFactory.createTitledBorder(\"Multipliers\"));\n+        spnSalaryCommission = new JSpinner(new SpinnerNumberModel(options.getSalaryCommissionMultiplier(), 0, 10, 0.05));\n+        ((JSpinner.DefaultEditor) spnSalaryCommission.getEditor()).getTextField().setEditable(false);\n+        JPanel panSalaryCommission = new JPanel();\n+        panSalaryCommission.add(spnSalaryCommission);\n+        panSalaryCommission.add(new JLabel(\"Commissioned\"));\n+        panMultiplier.add(panSalaryCommission);\n+\n+        spnSalaryEnlisted = new JSpinner(new SpinnerNumberModel(options.getSalaryEnlistedMultiplier(), 0, 10, 0.05));\n+        ((JSpinner.DefaultEditor) spnSalaryEnlisted.getEditor()).getTextField().setEditable(false);\n+        JPanel panSalaryEnlisted = new JPanel();\n+        panSalaryEnlisted.add(spnSalaryEnlisted);\n+        panSalaryEnlisted.add(new JLabel(\"Enlisted\"));\n+        panMultiplier.add(panSalaryEnlisted);\n+\n+        spnSalaryAntiMek = new JSpinner(new SpinnerNumberModel(options.getSalaryAntiMekMultiplier(), 0, 10, 0.05));\n+        ((JSpinner.DefaultEditor) spnSalaryAntiMek.getEditor()).getTextField().setEditable(false);\n+        JPanel panSalaryAntiMek = new JPanel();\n+        panSalaryAntiMek.add(spnSalaryAntiMek);\n+        panSalaryAntiMek.add(new JLabel(\"Anti-Mek\"));\n+        panMultiplier.add(panSalaryAntiMek);\n+\n+        gridBagConstraints = new java.awt.GridBagConstraints();\n+        gridBagConstraints.gridx = 0;\n+        gridBagConstraints.gridy = 0;\n+        gridBagConstraints.weightx = 1.0;\n+        gridBagConstraints.weighty = 0.0;\n+        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n+        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n+        panSalary.add(panMultiplier, gridBagConstraints);\n+\n+        JPanel panXpMultiplier = new JPanel(new GridLayout(2, 3));\n+        panXpMultiplier.setBorder(BorderFactory.createTitledBorder(\"Experience Multipliers\"));\n+        spnSalaryXp = new JSpinner[5];\n+        JSpinner spnXpSalary;\n+        JPanel panXpSalary;\n+        for (int i = 0; i < 5; i++) {\n+            spnXpSalary = new JSpinner(new SpinnerNumberModel(options.getSalaryXpMultiplier(i), 0, 10, 0.05));\n+            ((JSpinner.DefaultEditor) spnXpSalary.getEditor()).getTextField().setEditable(false);\n+            panXpSalary = new JPanel();\n+            panXpSalary.add(spnXpSalary);\n+            panXpSalary.add(new JLabel(SkillType.getExperienceLevelName(i)));\n+            panXpMultiplier.add(panXpSalary);\n+            spnSalaryXp[i] = spnXpSalary;\n+        }\n+        gridBagConstraints = new java.awt.GridBagConstraints();\n+        gridBagConstraints.gridx = 0;\n+        gridBagConstraints.gridy = 1;\n+        gridBagConstraints.weightx = 1.0;\n+        gridBagConstraints.weighty = 0.0;\n+        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n+        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\n+        panSalary.add(panXpMultiplier, gridBagConstraints);\n \n+        JPanel panAllTypes = new JPanel(new GridLayout(Person.T_NUM / 2, 2));\n+        JMoneyTextField txtType;\n+        JPanel panType;\n+        // TODO: use JFormattedTextField with Numeric formatter\n+        txtSalaryBase = new JMoneyTextField[Person.T_NUM];\n+        for (int i = 1; i < Person.T_NUM; i++) {\n+            txtType = new JMoneyTextField();\n+            txtType.setMoney(options.getBaseSalary(i));\n+            txtType.setPreferredSize(new Dimension(75, 20));\n+            panType = new JPanel(new GridBagLayout());\n             gridBagConstraints = new java.awt.GridBagConstraints();\n             gridBagConstraints.gridx = 0;\n             gridBagConstraints.gridy = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODIxNg==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386138216", "bodyText": "Should this instead use spnSalaryXp.length()?", "author": "sixlettervariables", "createdAt": "2020-03-01T20:32:18Z", "path": "MekHQ/src/mekhq/gui/dialog/CampaignOptionsDialog.java", "diffHunk": "@@ -4786,22 +4787,75 @@ private void updateOptions() {\n         options.setProbPhenoBA((Integer) spnProbPhenoBA.getModel().getValue());\n         options.setProbPhenoVee((Integer) spnProbPhenoVee.getModel().getValue());\n \n-        //start salary\n-        for (int i = 1; i < Person.T_NUM; i++) {\n-            try {\n-                Money salary = txtSalaryBase[i].getMoney();\n-                options.setBaseSalary(salary, i);\n-            } catch (Exception ignored) {\n+        //region Personnel Tab\n \n-            }\n-        }\n-        for (int i = 0; i < 5; i++) {\n-            options.setSalaryXpMultiplier((Double) spnSalaryXp[i].getModel().getValue(), i);\n+        options.setInitBonus(useInitBonusBox.isSelected());\n+        campaign.getGameOptions().getOption(\"individual_initiative\").setValue(useInitBonusBox.isSelected());\n+        options.setToughness(useToughnessBox.isSelected());\n+        campaign.getGameOptions().getOption(\"toughness\").setValue(useToughnessBox.isSelected());\n+        options.setArtillery(useArtilleryBox.isSelected());\n+        campaign.getGameOptions().getOption(\"artillery_skill\").setValue(useArtilleryBox.isSelected());\n+        options.setAbilities(useAbilitiesBox.isSelected());\n+        campaign.getGameOptions().getOption(\"pilot_advantages\").setValue(useAbilitiesBox.isSelected());\n+        options.setEdge(useEdgeBox.isSelected());\n+        campaign.getGameOptions().getOption(\"edge\").setValue(useEdgeBox.isSelected());\n+        options.setSupportEdge(useSupportEdgeBox.isSelected());\n+        options.setImplants(useImplantsBox.isSelected());\n+        campaign.getGameOptions().getOption(\"manei_domini\").setValue(useImplantsBox.isSelected());\n+        options.setCapturePrisoners(chkCapturePrisoners.isSelected());\n+        options.setDefaultPrisonerStatus(comboPrisonerStatus.getSelectedIndex());\n+        options.setAltQualityAveraging(altQualityAveragingCheckBox.isSelected());\n+        options.setAdvancedMedical(useAdvancedMedicalBox.isSelected());\n+        options.setDylansRandomXp(useDylansRandomXpBox.isSelected());\n+        //we need to reset healing time options through the campaign because we may need to\n+        //loop through personnel to make adjustments\n+        campaign.setHealingTimeOptions((Integer) spnHealWaitingPeriod.getModel().getValue(),\n+                (Integer) spnNaturalHealWaitingPeriod.getModel().getValue());\n+        options.setMinimumHitsForVees((Integer) spnMinimumHitsForVees.getModel().getValue());\n+        options.setUseRandomHitsForVees(useRandomHitsForVees.isSelected());\n+        options.setTougherHealing(useTougherHealing.isSelected());\n+        options.setUseTransfers(chkUseTransfers.isSelected());\n+        options.setUseTimeInService(chkUseTimeInService.isSelected());\n+        options.setShowOriginFaction(chkShowOriginFaction.isSelected());\n+        options.setRandomizeOrigin(chkRandomizeOrigin.isSelected());\n+        options.setRandomizeDependentOrigin(chkRandomizeDependentsOrigin.isSelected());\n+        options.setOriginSearchRadius((Integer)spnOriginSearchRadius.getModel().getValue());\n+        //Family\n+        options.setMinimumMarriageAge((Integer) spnMinimumMarriageAge.getModel().getValue());\n+        options.setCheckMutualAncestorsDepth((Integer) spnCheckMutualAncestorsDepth.getModel().getValue());\n+        options.setUseRandomMarriages(chkUseRandomMarriages.isSelected());\n+        options.setChanceRandomMarriages((Double) spnChanceRandomMarriages.getModel().getValue());\n+        options.setMarriageAgeRange((Integer) spnMarriageAgeRange.getModel().getValue());\n+        for (int i = 0; i < Person.NUM_SURNAME; i++) {\n+            int val = (int) Math.round(((Double) spnRandomMarriageSurnameWeights[i].getModel().getValue()) * 10);\n+            options.setRandomMarriageSurnameWeight(i, val);\n         }\n+        options.setUseRandomSameSexMarriages(chkUseRandomSameSexMarriages.isSelected());\n+        options.setChanceRandomSameSexMarriages((Double) spnChanceRandomSameSexMarriages.getModel().getValue());\n+        options.setUseUnofficialProcreation(chkUseUnofficialProcreation.isSelected());\n+        options.setChanceProcreation((Double) spnChanceProcreation.getModel().getValue());\n+        options.setUseUnofficialProcreationNoRelationship(chkUseUnofficialProcreationNoRelationship.isSelected());\n+        options.setChanceProcreationNoRelationship((Double) spnChanceProcreationNoRelationship.getModel().getValue());\n+        options.setDisplayTrueDueDate(chkDisplayTrueDueDate.isSelected());\n+        options.setLogConception(chkLogConception.isSelected());\n+        options.setBabySurnameStyle(comboBabySurnameStyle.getSelectedIndex());\n+        options.setUseParentage(chkUseParentage.isSelected());\n+        options.setDisplayFamilyLevel(comboDisplayFamilyLevel.getSelectedIndex());\n+        options.setUseRandomDeaths(chkUseRandomDeaths.isSelected());\n+        options.setKeepMarriedNameUponSpouseDeath(chkKeepMarriedNameUponSpouseDeath.isSelected());\n+        //Salary\n         options.setSalaryCommissionMultiplier((Double) spnSalaryCommission.getModel().getValue());\n         options.setSalaryEnlistedMultiplier((Double) spnSalaryEnlisted.getModel().getValue());\n         options.setSalaryAntiMekMultiplier((Double) spnSalaryAntiMek.getModel().getValue());\n-        //end salary\n+        for (int i = 0; i < 5; i++) {", "originalCommit": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MzEyMQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386143121", "bodyText": "Yes, it should. Fixed.", "author": "Windchild292", "createdAt": "2020-03-01T21:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODIxNg=="}], "type": "inlineReview", "revised_code": {"commit": "aaca153caa3426d265fc4419a2d14be934e468ee", "chunk": "diff --git a/MekHQ/src/mekhq/gui/dialog/CampaignOptionsDialog.java b/MekHQ/src/mekhq/gui/dialog/CampaignOptionsDialog.java\nindex d5f9ecf2c..aba1fbbb0 100644\n--- a/MekHQ/src/mekhq/gui/dialog/CampaignOptionsDialog.java\n+++ b/MekHQ/src/mekhq/gui/dialog/CampaignOptionsDialog.java\n\n@@ -4847,7 +4843,7 @@ public class CampaignOptionsDialog extends javax.swing.JDialog {\n         options.setSalaryCommissionMultiplier((Double) spnSalaryCommission.getModel().getValue());\n         options.setSalaryEnlistedMultiplier((Double) spnSalaryEnlisted.getModel().getValue());\n         options.setSalaryAntiMekMultiplier((Double) spnSalaryAntiMek.getModel().getValue());\n-        for (int i = 0; i < 5; i++) {\n+        for (int i = 0; i < spnSalaryXp.length; i++) {\n             options.setSalaryXpMultiplier((Double) spnSalaryXp[i].getModel().getValue(), i);\n         }\n         for (int i = 1; i < Person.T_NUM; i++) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODM1NA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386138354", "bodyText": "Is reference equality what we want here?", "author": "sixlettervariables", "createdAt": "2020-03-01T20:33:53Z", "path": "MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java", "diffHunk": "@@ -1529,39 +1397,31 @@ private void maybeShowPopup(MouseEvent e) {\n             /*\n              * if(!person.isAssigned()) { cbMenuItem.setSelected(true); }\n              */\n-            if (oneSelected && person.isActive()\n-                    && !(person.isPrisoner() || person.isBondsman())) {\n+            if (oneSelected && person.isActive() && !(person.isPrisoner() || person.isBondsman())) {\n                 for (Unit unit : gui.getCampaign().getUnits()) {\n                     if (!unit.isAvailable()) {\n                         continue;\n                     }\n                     if (unit.usesSoloPilot()) {\n-                        if (unit.canTakeMoreDrivers()\n-                                && person.canDrive(unit.getEntity())\n+                        if (unit.canTakeMoreDrivers() && person.canDrive(unit.getEntity())\n                                 && person.canGun(unit.getEntity())) {\n-                            cbMenuItem = new JCheckBoxMenuItem(\n-                                    unit.getName());\n-                            // TODO: check the box\n+                            cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n                             cbMenuItem.setActionCommand(makeCommand(CMD_ADD_PILOT, unit.getId().toString()));\n                             cbMenuItem.addActionListener(this);\n                             pilotMenu.add(cbMenuItem);\n                         }\n                     } else if (unit.usesSoldiers()) {\n-                        if (unit.canTakeMoreGunners()\n-                                && person.canGun(unit.getEntity())) {\n-                            cbMenuItem = new JCheckBoxMenuItem(\n-                                    unit.getName());\n-                            // TODO: check the box\n+                        if (unit.canTakeMoreGunners() && person.canGun(unit.getEntity())) {\n+                            cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n+                            cbMenuItem.setSelected(person.getUnitId() == unit.getId());", "originalCommit": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MzM3Mg==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386143372", "bodyText": "If the person is assigned to this unit, we want it selected. A comparison of the unit id should do that perfectly. I'm pretty sure it is correct, unless I'm missing something both in code and testing.", "author": "Windchild292", "createdAt": "2020-03-01T21:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2OTYxMQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386169611", "bodyText": "You're currently testing if the person's unit ID points to the same location in memory as the unit's ID. You likely intended this to compare the value of the IDs, right? Outside of int, boolean, float, and other primitive types, you should be using a.equals(b) or Objects.equals(a, b).", "author": "sixlettervariables", "createdAt": "2020-03-02T02:06:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4OTUzMg==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386189532", "bodyText": "Fixed, and I always forget where the line is drawn for .equals instead of == comparisons", "author": "Windchild292", "createdAt": "2020-03-02T04:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODM1NA=="}], "type": "inlineReview", "revised_code": {"commit": "df4a73968754c16e9b671ff590163cb3d5764483", "chunk": "diff --git a/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java b/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\nindex eee67b090..b7f1b7f99 100644\n--- a/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\n+++ b/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\n\n@@ -1413,7 +1413,7 @@ public class PersonnelTableMouseAdapter extends MouseInputAdapter implements\n                     } else if (unit.usesSoldiers()) {\n                         if (unit.canTakeMoreGunners() && person.canGun(unit.getEntity())) {\n                             cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n-                            cbMenuItem.setSelected(person.getUnitId() == unit.getId());\n+                            cbMenuItem.setSelected(person.getUnitId().equals(unit.getId()));\n                             cbMenuItem.setActionCommand(makeCommand(CMD_ADD_SOLDIER, unit.getId().toString()));\n                             cbMenuItem.addActionListener(this);\n                             soldierMenu.add(cbMenuItem);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODM2OQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386138369", "bodyText": "Is reference equality what we want here?", "author": "sixlettervariables", "createdAt": "2020-03-01T20:34:12Z", "path": "MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java", "diffHunk": "@@ -1529,39 +1397,31 @@ private void maybeShowPopup(MouseEvent e) {\n             /*\n              * if(!person.isAssigned()) { cbMenuItem.setSelected(true); }\n              */\n-            if (oneSelected && person.isActive()\n-                    && !(person.isPrisoner() || person.isBondsman())) {\n+            if (oneSelected && person.isActive() && !(person.isPrisoner() || person.isBondsman())) {\n                 for (Unit unit : gui.getCampaign().getUnits()) {\n                     if (!unit.isAvailable()) {\n                         continue;\n                     }\n                     if (unit.usesSoloPilot()) {\n-                        if (unit.canTakeMoreDrivers()\n-                                && person.canDrive(unit.getEntity())\n+                        if (unit.canTakeMoreDrivers() && person.canDrive(unit.getEntity())\n                                 && person.canGun(unit.getEntity())) {\n-                            cbMenuItem = new JCheckBoxMenuItem(\n-                                    unit.getName());\n-                            // TODO: check the box\n+                            cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n                             cbMenuItem.setActionCommand(makeCommand(CMD_ADD_PILOT, unit.getId().toString()));\n                             cbMenuItem.addActionListener(this);\n                             pilotMenu.add(cbMenuItem);\n                         }\n                     } else if (unit.usesSoldiers()) {\n-                        if (unit.canTakeMoreGunners()\n-                                && person.canGun(unit.getEntity())) {\n-                            cbMenuItem = new JCheckBoxMenuItem(\n-                                    unit.getName());\n-                            // TODO: check the box\n+                        if (unit.canTakeMoreGunners() && person.canGun(unit.getEntity())) {\n+                            cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n+                            cbMenuItem.setSelected(person.getUnitId() == unit.getId());\n                             cbMenuItem.setActionCommand(makeCommand(CMD_ADD_SOLDIER, unit.getId().toString()));\n                             cbMenuItem.addActionListener(this);\n                             soldierMenu.add(cbMenuItem);\n                         }\n                     } else {\n-                        if (unit.canTakeMoreDrivers()\n-                                && person.canDrive(unit.getEntity())) {\n-                            cbMenuItem = new JCheckBoxMenuItem(\n-                                    unit.getName());\n-                            // TODO: check the box\n+                        if (unit.canTakeMoreDrivers() && person.canDrive(unit.getEntity())) {\n+                            cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n+                            cbMenuItem.setSelected(person.getUnitId() == unit.getId());", "originalCommit": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df4a73968754c16e9b671ff590163cb3d5764483", "chunk": "diff --git a/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java b/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\nindex eee67b090..b7f1b7f99 100644\n--- a/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\n+++ b/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\n\n@@ -1413,7 +1413,7 @@ public class PersonnelTableMouseAdapter extends MouseInputAdapter implements\n                     } else if (unit.usesSoldiers()) {\n                         if (unit.canTakeMoreGunners() && person.canGun(unit.getEntity())) {\n                             cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n-                            cbMenuItem.setSelected(person.getUnitId() == unit.getId());\n+                            cbMenuItem.setSelected(person.getUnitId().equals(unit.getId()));\n                             cbMenuItem.setActionCommand(makeCommand(CMD_ADD_SOLDIER, unit.getId().toString()));\n                             cbMenuItem.addActionListener(this);\n                             soldierMenu.add(cbMenuItem);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODM4Mw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386138383", "bodyText": "Is reference equality what we want here?", "author": "sixlettervariables", "createdAt": "2020-03-01T20:34:25Z", "path": "MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java", "diffHunk": "@@ -1570,30 +1430,25 @@ private void maybeShowPopup(MouseEvent e) {\n                                 driverMenu.add(cbMenuItem);\n                             }\n                         }\n-                        if (unit.canTakeMoreGunners()\n-                                && person.canGun(unit.getEntity())) {\n-                            cbMenuItem = new JCheckBoxMenuItem(\n-                                    unit.getName());\n-                            // TODO: check the box\n+                        if (unit.canTakeMoreGunners() && person.canGun(unit.getEntity())) {\n+                            cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n+                            cbMenuItem.setSelected(person.getUnitId() == unit.getId());", "originalCommit": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df4a73968754c16e9b671ff590163cb3d5764483", "chunk": "diff --git a/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java b/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\nindex eee67b090..b7f1b7f99 100644\n--- a/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\n+++ b/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\n\n@@ -1432,7 +1432,7 @@ public class PersonnelTableMouseAdapter extends MouseInputAdapter implements\n                         }\n                         if (unit.canTakeMoreGunners() && person.canGun(unit.getEntity())) {\n                             cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n-                            cbMenuItem.setSelected(person.getUnitId() == unit.getId());\n+                            cbMenuItem.setSelected(person.getUnitId().equals(unit.getId()));\n                             cbMenuItem.setActionCommand(makeCommand(CMD_ADD_GUNNER, unit.getId().toString()));\n                             cbMenuItem.addActionListener(this);\n                             gunnerMenu.add(cbMenuItem);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODQwOQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386138409", "bodyText": "I'll stop asking about that reference equality, but there's more of these.", "author": "sixlettervariables", "createdAt": "2020-03-01T20:34:56Z", "path": "MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java", "diffHunk": "@@ -1570,30 +1430,25 @@ private void maybeShowPopup(MouseEvent e) {\n                                 driverMenu.add(cbMenuItem);\n                             }\n                         }\n-                        if (unit.canTakeMoreGunners()\n-                                && person.canGun(unit.getEntity())) {\n-                            cbMenuItem = new JCheckBoxMenuItem(\n-                                    unit.getName());\n-                            // TODO: check the box\n+                        if (unit.canTakeMoreGunners() && person.canGun(unit.getEntity())) {\n+                            cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n+                            cbMenuItem.setSelected(person.getUnitId() == unit.getId());\n                             cbMenuItem.setActionCommand(makeCommand(CMD_ADD_GUNNER, unit.getId().toString()));\n                             cbMenuItem.addActionListener(this);\n                             gunnerMenu.add(cbMenuItem);\n                         }\n                         if (unit.canTakeMoreVesselCrew()\n                                 && ((unit.getEntity().isAero() && person.hasSkill(SkillType.S_TECH_VESSEL))\n                                     || ((unit.getEntity().isSupportVehicle() && person.hasSkill(SkillType.S_TECH_MECHANIC))))){\n-                            cbMenuItem = new JCheckBoxMenuItem(\n-                                    unit.getName());\n-                            // TODO: check the box\n+                            cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n+                            cbMenuItem.setSelected(person.getUnitId() == unit.getId());", "originalCommit": "0097883e28e931dc8b135ef875b0d6c5e34f94b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MzQ3Mw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386143473", "bodyText": "Fourteen in total.", "author": "Windchild292", "createdAt": "2020-03-01T21:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "df4a73968754c16e9b671ff590163cb3d5764483", "chunk": "diff --git a/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java b/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\nindex eee67b090..b7f1b7f99 100644\n--- a/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\n+++ b/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\n\n@@ -1432,7 +1432,7 @@ public class PersonnelTableMouseAdapter extends MouseInputAdapter implements\n                         }\n                         if (unit.canTakeMoreGunners() && person.canGun(unit.getEntity())) {\n                             cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n-                            cbMenuItem.setSelected(person.getUnitId() == unit.getId());\n+                            cbMenuItem.setSelected(person.getUnitId().equals(unit.getId()));\n                             cbMenuItem.setActionCommand(makeCommand(CMD_ADD_GUNNER, unit.getId().toString()));\n                             cbMenuItem.addActionListener(this);\n                             gunnerMenu.add(cbMenuItem);\n"}}, {"oid": "03879772bf1717d91704f3c4d30ec875444c8dbd", "url": "https://github.com/MegaMek/mekhq/commit/03879772bf1717d91704f3c4d30ec875444c8dbd", "message": "Fixing whitespace issues in CustomizePersonDialog", "committedDate": "2020-03-01T21:24:15Z", "type": "commit"}, {"oid": "192cc2f278116b48f4d7fa89ddf0b2764ad7ec39", "url": "https://github.com/MegaMek/mekhq/commit/192cc2f278116b48f4d7fa89ddf0b2764ad7ec39", "message": "Fixing tad spaced file", "committedDate": "2020-03-01T21:33:04Z", "type": "commit"}, {"oid": "3bfcbea0f0bb9989d393c05b4609fb74a0c60ddd", "url": "https://github.com/MegaMek/mekhq/commit/3bfcbea0f0bb9989d393c05b4609fb74a0c60ddd", "message": "Fixing whitespace issues in MassRepairService", "committedDate": "2020-03-01T21:34:08Z", "type": "commit"}, {"oid": "aaca153caa3426d265fc4419a2d14be934e468ee", "url": "https://github.com/MegaMek/mekhq/commit/aaca153caa3426d265fc4419a2d14be934e468ee", "message": "Changes in Campaign options from review", "committedDate": "2020-03-01T21:38:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0NDcxNw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386144717", "bodyText": "I'll take a look at moving this into Person later tonight, as it really should just use the divorce method.", "author": "Windchild292", "createdAt": "2020-03-01T22:00:46Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -6027,8 +5959,19 @@ public void changeStatus(Person person, int status) {\n             // Don't forget to tell the spouse\n             if (person.hasSpouse()) {\n                 Person spouse = person.getSpouse();\n+\n+                spouse.addFormerSpouse(new FormerSpouse(person.getId(),\n+                        FormerSpouse.convertDateTimeToLocalDate(getDateTime()), FormerSpouse.REASON_WIDOWED));\n+                person.addFormerSpouse(new FormerSpouse(spouse.getId(),\n+                        FormerSpouse.convertDateTimeToLocalDate(getDateTime()), FormerSpouse.REASON_WIDOWED));\n+\n+                if (!getCampaignOptions().getKeepMarriedNameUponSpouseDeath() && (spouse.getMaidenName() != null)) {\n+                    spouse.setSurname(spouse.getMaidenName());\n+                }\n+\n                 PersonalLogger.spouseKia(spouse, person, getDate());\n-                spouse.setSpouseID(null);\n+                spouse.setSpouseId(null);\n+                spouse.setMaidenName(null);\n             }", "originalCommit": "aaca153caa3426d265fc4419a2d14be934e468ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0NzI2Mg==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386147262", "bodyText": "Moved and fixed a bug in the divorce code.", "author": "Windchild292", "createdAt": "2020-03-01T22:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0NDcxNw=="}], "type": "inlineReview", "revised_code": {"commit": "a378aabe9b7933431f1909179fb90ebfd3e8f8c6", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/Campaign.java b/MekHQ/src/mekhq/campaign/Campaign.java\nindex cfced19a4..1842fda30 100644\n--- a/MekHQ/src/mekhq/campaign/Campaign.java\n+++ b/MekHQ/src/mekhq/campaign/Campaign.java\n\n@@ -5956,25 +5955,13 @@ public class Campaign implements Serializable, ITechManager {\n         Unit u = getUnit(person.getUnitId());\n         if (status == Person.S_KIA) {\n             ServiceLogger.kia(person, getDate());\n+            // set the date of death\n+            person.setDateOfDeath((GregorianCalendar) calendar.clone());\n             // Don't forget to tell the spouse\n             if (person.hasSpouse()) {\n-                Person spouse = person.getSpouse();\n-\n-                spouse.addFormerSpouse(new FormerSpouse(person.getId(),\n-                        FormerSpouse.convertDateTimeToLocalDate(getDateTime()), FormerSpouse.REASON_WIDOWED));\n-                person.addFormerSpouse(new FormerSpouse(spouse.getId(),\n-                        FormerSpouse.convertDateTimeToLocalDate(getDateTime()), FormerSpouse.REASON_WIDOWED));\n-\n-                if (!getCampaignOptions().getKeepMarriedNameUponSpouseDeath() && (spouse.getMaidenName() != null)) {\n-                    spouse.setSurname(spouse.getMaidenName());\n-                }\n-\n-                PersonalLogger.spouseKia(spouse, person, getDate());\n-                spouse.setSpouseId(null);\n-                spouse.setMaidenName(null);\n+                person.divorce(getCampaignOptions().getKeepMarriedNameUponSpouseDeath()\n+                        ? Person.OPT_KEEP_SURNAME : Person.OPT_SPOUSE_CHANGE_SURNAME);\n             }\n-            // set the date of death\n-            person.setDateOfDeath((GregorianCalendar) calendar.clone());\n         } else if (person.getStatus() == Person.S_KIA) {\n             // remove date of death for resurrection\n             person.setDateOfDeath(null);\n"}}, {"oid": "a378aabe9b7933431f1909179fb90ebfd3e8f8c6", "url": "https://github.com/MegaMek/mekhq/commit/a378aabe9b7933431f1909179fb90ebfd3e8f8c6", "message": "Moving spouse KIA from campaign to person", "committedDate": "2020-03-01T22:35:01Z", "type": "commit"}, {"oid": "fa59bb1d507e258d665e784f933633588c567942", "url": "https://github.com/MegaMek/mekhq/commit/fa59bb1d507e258d665e784f933633588c567942", "message": "Fixing merge conflicts", "committedDate": "2020-03-02T03:32:48Z", "type": "commit"}, {"oid": "df4a73968754c16e9b671ff590163cb3d5764483", "url": "https://github.com/MegaMek/mekhq/commit/df4a73968754c16e9b671ff590163cb3d5764483", "message": "Changing from == to .equals for uuid comparisons", "committedDate": "2020-03-02T03:57:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NTYwMg==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386365602", "bodyText": "Can person.getUnitId be null? If so you should swap the order as unit.getId() will always be non-null.", "author": "sixlettervariables", "createdAt": "2020-03-02T12:32:56Z", "path": "MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java", "diffHunk": "@@ -1413,15 +1413,15 @@ private void maybeShowPopup(MouseEvent e) {\n                     } else if (unit.usesSoldiers()) {\n                         if (unit.canTakeMoreGunners() && person.canGun(unit.getEntity())) {\n                             cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n-                            cbMenuItem.setSelected(person.getUnitId() == unit.getId());\n+                            cbMenuItem.setSelected(person.getUnitId().equals(unit.getId()));", "originalCommit": "df4a73968754c16e9b671ff590163cb3d5764483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwNjY1NQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386406655", "bodyText": "Yeah, that's a dumb tired programmer mistake.", "author": "Windchild292", "createdAt": "2020-03-02T13:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NTYwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0NjU1MA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r386546550", "bodyText": "Fixed", "author": "Windchild292", "createdAt": "2020-03-02T17:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NTYwMg=="}], "type": "inlineReview", "revised_code": {"commit": "7d25ea878b22f0dd083780ff013ac3ecbcb3aca8", "chunk": "diff --git a/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java b/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\nindex b7f1b7f99..df299bb6e 100644\n--- a/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\n+++ b/MekHQ/src/mekhq/gui/adapter/PersonnelTableMouseAdapter.java\n\n@@ -1413,7 +1413,7 @@ public class PersonnelTableMouseAdapter extends MouseInputAdapter implements\n                     } else if (unit.usesSoldiers()) {\n                         if (unit.canTakeMoreGunners() && person.canGun(unit.getEntity())) {\n                             cbMenuItem = new JCheckBoxMenuItem(unit.getName());\n-                            cbMenuItem.setSelected(person.getUnitId().equals(unit.getId()));\n+                            cbMenuItem.setSelected(unit.getId().equals(person.getUnitId()));\n                             cbMenuItem.setActionCommand(makeCommand(CMD_ADD_SOLDIER, unit.getId().toString()));\n                             cbMenuItem.addActionListener(this);\n                             soldierMenu.add(cbMenuItem);\n"}}, {"oid": "7d25ea878b22f0dd083780ff013ac3ecbcb3aca8", "url": "https://github.com/MegaMek/mekhq/commit/7d25ea878b22f0dd083780ff013ac3ecbcb3aca8", "message": "Fixing order of .equals statement", "committedDate": "2020-03-02T16:44:28Z", "type": "commit"}, {"oid": "6a109fff63fe4ce91e27d1ced80a62b58da4f331", "url": "https://github.com/MegaMek/mekhq/commit/6a109fff63fe4ce91e27d1ced80a62b58da4f331", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-03-02T16:50:42Z", "type": "commit"}, {"oid": "4ec3af332bc87f0b6edf62087751a9a867370ee4", "url": "https://github.com/MegaMek/mekhq/commit/4ec3af332bc87f0b6edf62087751a9a867370ee4", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-03-08T02:58:11Z", "type": "commit"}, {"oid": "7ef6226553ee151ddefa937ce20d883e2a8e9c23", "url": "https://github.com/MegaMek/mekhq/commit/7ef6226553ee151ddefa937ce20d883e2a8e9c23", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-03-09T17:33:17Z", "type": "commit"}, {"oid": "106ed2739d3941e172f9ec5ab83d301febb1770c", "url": "https://github.com/MegaMek/mekhq/commit/106ed2739d3941e172f9ec5ab83d301febb1770c", "message": "Fixing ArrayList declaration bugs", "committedDate": "2020-03-09T19:53:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyODc0MA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392528740", "bodyText": "Is this null safe?", "author": "sixlettervariables", "createdAt": "2020-03-13T23:38:07Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -1318,154 +1382,210 @@ public boolean recruitPerson(Person p, boolean prisoner, boolean dependent, bool\n         MekHQ.triggerEvent(new PersonNewEvent(p));\n         return true;\n     }\n+    //endregion Personnel Recruitment\n \n-    /** Adds a person to the campaign unconditionally, without paying for the person. */\n-    @Deprecated // as part of the personnel changes, 23-Feb-2020\n-    public void addPerson(Person p) {\n-        if (p == null) {\n-            return;\n-        }\n-\n-        UUID id = UUID.randomUUID();\n-        while (null != personnel.get(id)) {\n-            id = UUID.randomUUID();\n-        }\n-        p.setId(id);\n-        personnel.put(id, p);\n-\n-        //TODO: implement a boolean check based on campaign options\n-        addReport(p.getHyperlinkedName() + \" has been added to the personnel roster.\");\n-        if (p.getPrimaryRole() == Person.T_ASTECH) {\n-            astechPoolMinutes += 480;\n-            astechPoolOvertime += 240;\n-        }\n-        if (p.getSecondaryRole() == Person.T_ASTECH) {\n-            astechPoolMinutes += 240;\n-            astechPoolOvertime += 120;\n-        }\n-        String rankEntry = LogEntryController.generateRankEntryString(p);\n-\n-        p.setFreeMan();\n-        ServiceLogger.joined(p, getDate(), getName(), rankEntry);\n-        MekHQ.triggerEvent(new PersonNewEvent(p));\n-    }\n-\n+    //region Bloodnames\n     /**\n-     * Imports a {@link Person} into a campaign.\n-     * @param p A {@link Person} to import into the campaign.\n+     * If the person does not already have a bloodname, assigns a chance of having one based on\n+     * skill and rank. If the roll indicates there should be a bloodname, one is assigned as\n+     * appropriate to the person's phenotype and the player's faction.\n+     *\n+     * @param person       The Bloodname candidate\n+     * @param type         The phenotype index\n      */\n-    @Deprecated // as part of the personnel changes, 23-Feb-2020\n-    public void importPerson(Person p) {\n-        addPersonWithoutId(p);\n-    }\n-\n-    @Deprecated // as part of the personnel changes, 23-Feb-2020\n-    private void addPersonWithoutId(Person p) {\n-        personnel.put(p.getId(), p);\n-        MekHQ.triggerEvent(new PersonNewEvent(p));\n+    public void checkBloodnameAdd(Person person, int type) {\n+        checkBloodnameAdd(person, type, false, this.factionCode);\n     }\n \n     /**\n-     * Imports an {@link Ancestors} into a campaign.\n-     * @param a An {@link Ancestors} to import into the campaign.\n+     * If the person does not already have a bloodname, assigns a chance of having one based on\n+     * skill and rank. If the roll indicates there should be a bloodname, one is assigned as\n+     * appropriate to Clan and phenotype.\n+     *\n+     * @param person       The Bloodname candidate\n+     * @param type         The phenotype index\n+     * @param factionCode  The shortName of the faction the person belongs to. Note that there\n+     *                     is a chance of having a Bloodname that is unique to a different Clan\n+     *                     as this person could have been captured.\n      */\n-    public void importAncestors(Ancestors a) {\n-        addAncestorsWithoutId(a);\n-    }\n-\n-    private void addAncestorsWithoutId(Ancestors a) {\n-        ancestors.put(a.getId(), a);\n-    }\n-\n-    public void addPersonWithoutId(Person p, boolean log) {\n-        while((null == p.getId()) || (null != personnel.get(p.getId()))) {\n-            p.setId(UUID.randomUUID());\n-        }\n-        addPersonWithoutId(p);\n-        if (log) {\n-            addReport(p.getHyperlinkedName() + \" has been added to the personnel roster.\");\n-        }\n-        if (p.getPrimaryRole() == Person.T_ASTECH) {\n-            astechPoolMinutes += 480;\n-            astechPoolOvertime += 240;\n-        }\n-        if (p.getSecondaryRole() == Person.T_ASTECH) {\n-            astechPoolMinutes += 240;\n-            astechPoolOvertime += 120;\n-        }\n-        String rankEntry = LogEntryController.generateRankEntryString(p);\n-        ServiceLogger.joined(p, getDate(), getName(), rankEntry);\n-    }\n-\n-    @Deprecated\n-    public Date getDate() {\n-        return calendar.getTime();\n-    }\n-\n-    public DateTime getDateTime() {\n-        return currentDateTime;\n-    }\n-\n-    public Collection<Person> getPersonnel() {\n-        return personnel.values();\n+    public void checkBloodnameAdd(Person person, int type, String factionCode) {\n+        checkBloodnameAdd(person, type, false, factionCode);\n     }\n \n     /**\n-     * Provides a filtered list of personnel including only active Persons.\n-     * @return ArrayList<Person>\n+     * If the person does not already have a bloodname, assigns a chance of having one based on\n+     * skill and rank. If the roll indicates there should be a bloodname, one is assigned as\n+     * appropriate to the person's phenotype and the player's faction.\n+     *\n+     * @param person       The Bloodname candidate\n+     * @param type         The phenotype index\n+     * @param ignoreDice   If true, skips the random roll and assigns a Bloodname automatically\n      */\n-    public ArrayList<Person> getActivePersonnel() {\n-        ArrayList<Person> activePersonnel = new ArrayList<>();\n-        for (Person p : getPersonnel()) {\n-            if (p.isActive()) {activePersonnel.add(p);}\n-        }\n-        return activePersonnel;\n-    }\n-\n-    public Iterable<Ancestors> getAncestors() {\n-        return ancestors.values();\n-    }\n-\n-    /** @return a matching ancestors entry for the arguments, or null if there isn't any */\n-    public Ancestors getAncestors(UUID fatherId, UUID motherId) {\n-        for(Map.Entry<UUID, Ancestors> m : ancestors.entrySet()) {\n-            Ancestors a = m.getValue();\n-            if(Objects.equals(fatherId, a.getFatherId()) && Objects.equals(motherId, a.getMotherId())) {\n-                return a;\n-            }\n-        }\n-        return null;\n+    public void checkBloodnameAdd(Person person, int type, boolean ignoreDice) {\n+        checkBloodnameAdd(person, type, ignoreDice, this.factionCode);\n     }\n \n-    public ArrayList<Person> getPatients() {\n-        ArrayList<Person> patients = new ArrayList<>();\n-        for (Person p : getPersonnel()) {\n-            if (p.needsFixing()\n-                    || (getCampaignOptions().useAdvancedMedical() && p.hasInjuries(true) && p.isActive())) {\n-                patients.add(p);\n+    /**\n+     * If the person does not already have a bloodname, assigns a chance of having one based on\n+     * skill and rank. If the roll indicates there should be a bloodname, one is assigned as\n+     * appropriate to Clan and phenotype.\n+     *\n+     * @param person       The Bloodname candidate\n+     * @param type         The phenotype index\n+     * @param ignoreDice   If true, skips the random roll and assigns a Bloodname automatically\n+     * @param factionCode  The shortName of the faction the person belongs to. Note that there\n+     *                     is a chance of having a Bloodname that is unique to a different Clan\n+     *                     as this person could have been captured.\n+     */\n+    public void checkBloodnameAdd(Person person, int type, boolean ignoreDice, String factionCode) {\n+        // Person already has a bloodname?\n+        if (person.getBloodname().length() > 0) {", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNjI4Nw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392536287", "bodyText": "Bloodname defaults to \"\", so it does not need to be.", "author": "Windchild292", "createdAt": "2020-03-14T00:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyODc0MA=="}], "type": "inlineReview", "revised_code": {"commit": "a281a777e4e195487cad182fca2e5db0fe348e43", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/Campaign.java b/MekHQ/src/mekhq/campaign/Campaign.java\nindex 4d2923457..705f2a9a2 100644\n--- a/MekHQ/src/mekhq/campaign/Campaign.java\n+++ b/MekHQ/src/mekhq/campaign/Campaign.java\n\n@@ -1456,50 +1456,50 @@ public class Campaign implements Serializable, ITechManager {\n                 case Person.PHENOTYPE_MW:\n                     bloodnameTarget += person.hasSkill(SkillType.S_GUN_MECH)\n                             ? person.getSkill(SkillType.S_GUN_MECH).getFinalSkillValue()\n-                            : 13;\n+                            : TargetRoll.AUTOMATIC_FAIL;\n                     bloodnameTarget += person.hasSkill(SkillType.S_PILOT_MECH)\n                             ? person.getSkill(SkillType.S_PILOT_MECH).getFinalSkillValue()\n-                            : 13;\n+                            : TargetRoll.AUTOMATIC_FAIL;\n                     break;\n                 case Person.PHENOTYPE_AERO:\n                     if (type == Person.T_PROTO_PILOT) {\n                         bloodnameTarget += 2 * (person.hasSkill(SkillType.S_GUN_PROTO)\n                                 ? person.getSkill(SkillType.S_GUN_PROTO).getFinalSkillValue()\n-                                : 13);\n+                                : TargetRoll.AUTOMATIC_FAIL);\n \n                     } else {\n                         bloodnameTarget += person.hasSkill(SkillType.S_GUN_AERO)\n                                 ? person.getSkill(SkillType.S_GUN_AERO).getFinalSkillValue()\n-                                : 13;\n+                                : TargetRoll.AUTOMATIC_FAIL;\n                         bloodnameTarget += person.hasSkill(SkillType.S_PILOT_AERO)\n                                 ? person.getSkill(SkillType.S_PILOT_AERO).getFinalSkillValue()\n-                                : 13;\n+                                : TargetRoll.AUTOMATIC_FAIL;\n                     }\n                     break;\n                 case Person.PHENOTYPE_BA:\n                     bloodnameTarget += person.hasSkill(SkillType.S_GUN_BA)\n                             ? person.getSkill(SkillType.S_GUN_BA).getFinalSkillValue()\n-                            : 13;\n+                            : TargetRoll.AUTOMATIC_FAIL;\n                     bloodnameTarget += person.hasSkill(SkillType.S_ANTI_MECH)\n                             ? person.getSkill(SkillType.S_ANTI_MECH).getFinalSkillValue()\n-                            : 13;\n+                            : TargetRoll.AUTOMATIC_FAIL;\n                     break;\n                 case Person.PHENOTYPE_VEE:\n                     bloodnameTarget += person.hasSkill(SkillType.S_GUN_VEE)\n                             ? person.getSkill(SkillType.S_GUN_VEE).getFinalSkillValue()\n-                            : 13;\n+                            : TargetRoll.AUTOMATIC_FAIL;\n                     if (type == Person.T_VTOL_PILOT) {\n                         bloodnameTarget += person.hasSkill(SkillType.S_PILOT_VTOL)\n                                 ? person.getSkill(SkillType.S_PILOT_VTOL).getFinalSkillValue()\n-                                : 13;\n+                                : TargetRoll.AUTOMATIC_FAIL;\n                     } else if (type == Person.T_NVEE_DRIVER) {\n                         bloodnameTarget += person.hasSkill(SkillType.S_PILOT_NVEE)\n                                 ? person.getSkill(SkillType.S_PILOT_NVEE).getFinalSkillValue()\n-                                : 13;\n+                                : TargetRoll.AUTOMATIC_FAIL;\n                     } else {\n                         bloodnameTarget += person.hasSkill(SkillType.S_PILOT_GVEE)\n                                 ? person.getSkill(SkillType.S_PILOT_GVEE).getFinalSkillValue()\n-                                : 13;\n+                                : TargetRoll.AUTOMATIC_FAIL;\n                     }\n                     break;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyODc5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392528795", "bodyText": "Should these be AUTOMATIC_FAIL?", "author": "sixlettervariables", "createdAt": "2020-03-13T23:38:29Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -1318,154 +1382,210 @@ public boolean recruitPerson(Person p, boolean prisoner, boolean dependent, bool\n         MekHQ.triggerEvent(new PersonNewEvent(p));\n         return true;\n     }\n+    //endregion Personnel Recruitment\n \n-    /** Adds a person to the campaign unconditionally, without paying for the person. */\n-    @Deprecated // as part of the personnel changes, 23-Feb-2020\n-    public void addPerson(Person p) {\n-        if (p == null) {\n-            return;\n-        }\n-\n-        UUID id = UUID.randomUUID();\n-        while (null != personnel.get(id)) {\n-            id = UUID.randomUUID();\n-        }\n-        p.setId(id);\n-        personnel.put(id, p);\n-\n-        //TODO: implement a boolean check based on campaign options\n-        addReport(p.getHyperlinkedName() + \" has been added to the personnel roster.\");\n-        if (p.getPrimaryRole() == Person.T_ASTECH) {\n-            astechPoolMinutes += 480;\n-            astechPoolOvertime += 240;\n-        }\n-        if (p.getSecondaryRole() == Person.T_ASTECH) {\n-            astechPoolMinutes += 240;\n-            astechPoolOvertime += 120;\n-        }\n-        String rankEntry = LogEntryController.generateRankEntryString(p);\n-\n-        p.setFreeMan();\n-        ServiceLogger.joined(p, getDate(), getName(), rankEntry);\n-        MekHQ.triggerEvent(new PersonNewEvent(p));\n-    }\n-\n+    //region Bloodnames\n     /**\n-     * Imports a {@link Person} into a campaign.\n-     * @param p A {@link Person} to import into the campaign.\n+     * If the person does not already have a bloodname, assigns a chance of having one based on\n+     * skill and rank. If the roll indicates there should be a bloodname, one is assigned as\n+     * appropriate to the person's phenotype and the player's faction.\n+     *\n+     * @param person       The Bloodname candidate\n+     * @param type         The phenotype index\n      */\n-    @Deprecated // as part of the personnel changes, 23-Feb-2020\n-    public void importPerson(Person p) {\n-        addPersonWithoutId(p);\n-    }\n-\n-    @Deprecated // as part of the personnel changes, 23-Feb-2020\n-    private void addPersonWithoutId(Person p) {\n-        personnel.put(p.getId(), p);\n-        MekHQ.triggerEvent(new PersonNewEvent(p));\n+    public void checkBloodnameAdd(Person person, int type) {\n+        checkBloodnameAdd(person, type, false, this.factionCode);\n     }\n \n     /**\n-     * Imports an {@link Ancestors} into a campaign.\n-     * @param a An {@link Ancestors} to import into the campaign.\n+     * If the person does not already have a bloodname, assigns a chance of having one based on\n+     * skill and rank. If the roll indicates there should be a bloodname, one is assigned as\n+     * appropriate to Clan and phenotype.\n+     *\n+     * @param person       The Bloodname candidate\n+     * @param type         The phenotype index\n+     * @param factionCode  The shortName of the faction the person belongs to. Note that there\n+     *                     is a chance of having a Bloodname that is unique to a different Clan\n+     *                     as this person could have been captured.\n      */\n-    public void importAncestors(Ancestors a) {\n-        addAncestorsWithoutId(a);\n-    }\n-\n-    private void addAncestorsWithoutId(Ancestors a) {\n-        ancestors.put(a.getId(), a);\n-    }\n-\n-    public void addPersonWithoutId(Person p, boolean log) {\n-        while((null == p.getId()) || (null != personnel.get(p.getId()))) {\n-            p.setId(UUID.randomUUID());\n-        }\n-        addPersonWithoutId(p);\n-        if (log) {\n-            addReport(p.getHyperlinkedName() + \" has been added to the personnel roster.\");\n-        }\n-        if (p.getPrimaryRole() == Person.T_ASTECH) {\n-            astechPoolMinutes += 480;\n-            astechPoolOvertime += 240;\n-        }\n-        if (p.getSecondaryRole() == Person.T_ASTECH) {\n-            astechPoolMinutes += 240;\n-            astechPoolOvertime += 120;\n-        }\n-        String rankEntry = LogEntryController.generateRankEntryString(p);\n-        ServiceLogger.joined(p, getDate(), getName(), rankEntry);\n-    }\n-\n-    @Deprecated\n-    public Date getDate() {\n-        return calendar.getTime();\n-    }\n-\n-    public DateTime getDateTime() {\n-        return currentDateTime;\n-    }\n-\n-    public Collection<Person> getPersonnel() {\n-        return personnel.values();\n+    public void checkBloodnameAdd(Person person, int type, String factionCode) {\n+        checkBloodnameAdd(person, type, false, factionCode);\n     }\n \n     /**\n-     * Provides a filtered list of personnel including only active Persons.\n-     * @return ArrayList<Person>\n+     * If the person does not already have a bloodname, assigns a chance of having one based on\n+     * skill and rank. If the roll indicates there should be a bloodname, one is assigned as\n+     * appropriate to the person's phenotype and the player's faction.\n+     *\n+     * @param person       The Bloodname candidate\n+     * @param type         The phenotype index\n+     * @param ignoreDice   If true, skips the random roll and assigns a Bloodname automatically\n      */\n-    public ArrayList<Person> getActivePersonnel() {\n-        ArrayList<Person> activePersonnel = new ArrayList<>();\n-        for (Person p : getPersonnel()) {\n-            if (p.isActive()) {activePersonnel.add(p);}\n-        }\n-        return activePersonnel;\n-    }\n-\n-    public Iterable<Ancestors> getAncestors() {\n-        return ancestors.values();\n-    }\n-\n-    /** @return a matching ancestors entry for the arguments, or null if there isn't any */\n-    public Ancestors getAncestors(UUID fatherId, UUID motherId) {\n-        for(Map.Entry<UUID, Ancestors> m : ancestors.entrySet()) {\n-            Ancestors a = m.getValue();\n-            if(Objects.equals(fatherId, a.getFatherId()) && Objects.equals(motherId, a.getMotherId())) {\n-                return a;\n-            }\n-        }\n-        return null;\n+    public void checkBloodnameAdd(Person person, int type, boolean ignoreDice) {\n+        checkBloodnameAdd(person, type, ignoreDice, this.factionCode);\n     }\n \n-    public ArrayList<Person> getPatients() {\n-        ArrayList<Person> patients = new ArrayList<>();\n-        for (Person p : getPersonnel()) {\n-            if (p.needsFixing()\n-                    || (getCampaignOptions().useAdvancedMedical() && p.hasInjuries(true) && p.isActive())) {\n-                patients.add(p);\n+    /**\n+     * If the person does not already have a bloodname, assigns a chance of having one based on\n+     * skill and rank. If the roll indicates there should be a bloodname, one is assigned as\n+     * appropriate to Clan and phenotype.\n+     *\n+     * @param person       The Bloodname candidate\n+     * @param type         The phenotype index\n+     * @param ignoreDice   If true, skips the random roll and assigns a Bloodname automatically\n+     * @param factionCode  The shortName of the faction the person belongs to. Note that there\n+     *                     is a chance of having a Bloodname that is unique to a different Clan\n+     *                     as this person could have been captured.\n+     */\n+    public void checkBloodnameAdd(Person person, int type, boolean ignoreDice, String factionCode) {\n+        // Person already has a bloodname?\n+        if (person.getBloodname().length() > 0) {\n+            int result = JOptionPane.showConfirmDialog(null,\n+                    person.getFullName() + \" already has the bloodname \" + person.getBloodname()\n+                            + \"\\nDo you wish to remove that bloodname and generate a new one?\",\n+                    \"Already Has Bloodname\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);\n+            if (result == JOptionPane.NO_OPTION) {\n+                return;\n             }\n         }\n-        return patients;\n-    }\n \n-    public ArrayList<Unit> getServiceableUnits() {\n-        ArrayList<Unit> service = new ArrayList<>();\n-        for (Unit u : getUnits()) {\n-            if (!u.isAvailable()) {\n-                continue;\n-            }\n-            if (u.isServiceable()) {\n-                service.add(u);\n-            }\n-        }\n-        return service;\n-    }\n+        // Go ahead and generate a new bloodname\n+        if (person.isClanner() && person.getPhenotype() != Person.PHENOTYPE_NONE) {\n+            int bloodnameTarget = 6;\n+            switch (person.getPhenotype()) {\n+                case Person.PHENOTYPE_MW:\n+                    bloodnameTarget += person.hasSkill(SkillType.S_GUN_MECH)\n+                            ? person.getSkill(SkillType.S_GUN_MECH).getFinalSkillValue()\n+                            : 13;", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNjg0OA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392536848", "bodyText": "No, because of modifiers these can be pushed below 13. It just makes it very rare, which I believe is the point. IIRC, @neoancient added this and should be able to comment?", "author": "Windchild292", "createdAt": "2020-03-14T00:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyODc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwMDYzNw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392600637", "bodyText": "I wrote the bloodname generation code, but I didn't write this part, and I can't say for sure what the intention was. I'm not sure how we would end up in a situation where somebody was generated with a certain phenotypes and doesn't have the skills that go with the role, but I would say it should be automatic fail.", "author": "neoancient", "createdAt": "2020-03-14T16:29:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyODc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwMTYzOA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392601638", "bodyText": "Sounds good, will have that updated shortly", "author": "Windchild292", "createdAt": "2020-03-14T16:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyODc5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "a281a777e4e195487cad182fca2e5db0fe348e43", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/Campaign.java b/MekHQ/src/mekhq/campaign/Campaign.java\nindex 4d2923457..705f2a9a2 100644\n--- a/MekHQ/src/mekhq/campaign/Campaign.java\n+++ b/MekHQ/src/mekhq/campaign/Campaign.java\n\n@@ -1456,50 +1456,50 @@ public class Campaign implements Serializable, ITechManager {\n                 case Person.PHENOTYPE_MW:\n                     bloodnameTarget += person.hasSkill(SkillType.S_GUN_MECH)\n                             ? person.getSkill(SkillType.S_GUN_MECH).getFinalSkillValue()\n-                            : 13;\n+                            : TargetRoll.AUTOMATIC_FAIL;\n                     bloodnameTarget += person.hasSkill(SkillType.S_PILOT_MECH)\n                             ? person.getSkill(SkillType.S_PILOT_MECH).getFinalSkillValue()\n-                            : 13;\n+                            : TargetRoll.AUTOMATIC_FAIL;\n                     break;\n                 case Person.PHENOTYPE_AERO:\n                     if (type == Person.T_PROTO_PILOT) {\n                         bloodnameTarget += 2 * (person.hasSkill(SkillType.S_GUN_PROTO)\n                                 ? person.getSkill(SkillType.S_GUN_PROTO).getFinalSkillValue()\n-                                : 13);\n+                                : TargetRoll.AUTOMATIC_FAIL);\n \n                     } else {\n                         bloodnameTarget += person.hasSkill(SkillType.S_GUN_AERO)\n                                 ? person.getSkill(SkillType.S_GUN_AERO).getFinalSkillValue()\n-                                : 13;\n+                                : TargetRoll.AUTOMATIC_FAIL;\n                         bloodnameTarget += person.hasSkill(SkillType.S_PILOT_AERO)\n                                 ? person.getSkill(SkillType.S_PILOT_AERO).getFinalSkillValue()\n-                                : 13;\n+                                : TargetRoll.AUTOMATIC_FAIL;\n                     }\n                     break;\n                 case Person.PHENOTYPE_BA:\n                     bloodnameTarget += person.hasSkill(SkillType.S_GUN_BA)\n                             ? person.getSkill(SkillType.S_GUN_BA).getFinalSkillValue()\n-                            : 13;\n+                            : TargetRoll.AUTOMATIC_FAIL;\n                     bloodnameTarget += person.hasSkill(SkillType.S_ANTI_MECH)\n                             ? person.getSkill(SkillType.S_ANTI_MECH).getFinalSkillValue()\n-                            : 13;\n+                            : TargetRoll.AUTOMATIC_FAIL;\n                     break;\n                 case Person.PHENOTYPE_VEE:\n                     bloodnameTarget += person.hasSkill(SkillType.S_GUN_VEE)\n                             ? person.getSkill(SkillType.S_GUN_VEE).getFinalSkillValue()\n-                            : 13;\n+                            : TargetRoll.AUTOMATIC_FAIL;\n                     if (type == Person.T_VTOL_PILOT) {\n                         bloodnameTarget += person.hasSkill(SkillType.S_PILOT_VTOL)\n                                 ? person.getSkill(SkillType.S_PILOT_VTOL).getFinalSkillValue()\n-                                : 13;\n+                                : TargetRoll.AUTOMATIC_FAIL;\n                     } else if (type == Person.T_NVEE_DRIVER) {\n                         bloodnameTarget += person.hasSkill(SkillType.S_PILOT_NVEE)\n                                 ? person.getSkill(SkillType.S_PILOT_NVEE).getFinalSkillValue()\n-                                : 13;\n+                                : TargetRoll.AUTOMATIC_FAIL;\n                     } else {\n                         bloodnameTarget += person.hasSkill(SkillType.S_PILOT_GVEE)\n                                 ? person.getSkill(SkillType.S_PILOT_GVEE).getFinalSkillValue()\n-                                : 13;\n+                                : TargetRoll.AUTOMATIC_FAIL;\n                     }\n                     break;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyOTI5Mw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392529293", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (p.isActive()) {activePersonnel.add(p);}\n          \n          \n            \n                        if (p.isActive()) {\n          \n          \n            \n                            activePersonnel.add(p);\n          \n          \n            \n                        }", "author": "sixlettervariables", "createdAt": "2020-03-13T23:40:54Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -1480,6 +1600,120 @@ public Ancestors createAncestors(UUID father, UUID mother) {\n         ancestors.put(na.getId(), na);\n         return na;\n     }\n+    //endregion Ancestors\n+\n+    //region Other Personnel Methods\n+    /**\n+     * Imports a {@link Person} into a campaign.\n+     * @param p A {@link Person} to import into the campaign.\n+     */\n+    public void importPerson(Person p) {\n+        personnel.put(p.getId(), p);\n+        MekHQ.triggerEvent(new PersonNewEvent(p));\n+    }\n+\n+    public Person getPerson(UUID id) {\n+        if (id == null) {\n+            return null;\n+        }\n+        return personnel.get(id);\n+    }\n+\n+    public Collection<Person> getPersonnel() {\n+        return personnel.values();\n+    }\n+\n+    /**\n+     * Provides a filtered list of personnel including only active Persons.\n+     * @return List<Person>\n+     */\n+    public List<Person> getActivePersonnel() {\n+        List<Person> activePersonnel = new ArrayList<>();\n+        for (Person p : getPersonnel()) {\n+            if (p.isActive()) {activePersonnel.add(p);}", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0f073e3a7e2c11b039283ba4f3d2241a8bdbcd1e", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/Campaign.java b/MekHQ/src/mekhq/campaign/Campaign.java\nindex 4d2923457..e0997c009 100644\n--- a/MekHQ/src/mekhq/campaign/Campaign.java\n+++ b/MekHQ/src/mekhq/campaign/Campaign.java\n\n@@ -1630,7 +1630,9 @@ public class Campaign implements Serializable, ITechManager {\n     public List<Person> getActivePersonnel() {\n         List<Person> activePersonnel = new ArrayList<>();\n         for (Person p : getPersonnel()) {\n-            if (p.isActive()) {activePersonnel.add(p);}\n+            if (p.isActive()) {\n+                activePersonnel.add(p);\n+            }\n         }\n         return activePersonnel;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMDAzNA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392530034", "bodyText": "These all need documentation.", "author": "sixlettervariables", "createdAt": "2020-03-13T23:45:15Z", "path": "MekHQ/src/mekhq/campaign/CampaignOptions.java", "diffHunk": "@@ -792,28 +712,549 @@ public void setImplants(boolean b) {\n         this.useImplants = b;\n     }\n \n-\tpublic boolean useAltQualityAveraging() {\n-\t\treturn altQualityAveraging;\n-\t}\n+    public boolean capturePrisoners() {\n+        return capturePrisoners;\n+    }\n \n-\tpublic void setAltQualityAveraging(boolean altQualityAveraging) {\n-\t\tthis.altQualityAveraging = altQualityAveraging;\n-\t}\n+    public void setCapturePrisoners(boolean b) {\n+        capturePrisoners = b;\n+    }\n+\n+    public int getDefaultPrisonerStatus() {\n+        return defaultPrisonerStatus;\n+    }\n+\n+    public void setDefaultPrisonerStatus(int d) {\n+        defaultPrisonerStatus = d;\n+    }\n+\n+    public boolean useAltQualityAveraging() {\n+        return altQualityAveraging;\n+    }\n+\n+    public void setAltQualityAveraging(boolean altQualityAveraging) {\n+        this.altQualityAveraging = altQualityAveraging;\n+    }\n \n     public boolean useAdvancedMedical() {\n         return useAdvancedMedical;\n     }\n \n-    public void setAdvancedMedical(boolean b) {\n-        this.useAdvancedMedical = b;\n+    public void setAdvancedMedical(boolean b) {\n+        this.useAdvancedMedical = b;\n+    }\n+\n+    public boolean useDylansRandomXp() {\n+        return useDylansRandomXp;\n+    }\n+\n+    public void setDylansRandomXp(boolean b) {\n+        this.useDylansRandomXp = b;\n+    }\n+\n+    public int getHealingWaitingPeriod() {\n+        return healWaitingPeriod;\n+    }\n+\n+    public void setHealingWaitingPeriod(int d) {\n+        healWaitingPeriod = d;\n+    }\n+\n+    public int getNaturalHealingWaitingPeriod() {\n+        return naturalHealingWaitingPeriod;\n+    }\n+\n+    public void setNaturalHealingWaitingPeriod(int d) {\n+        naturalHealingWaitingPeriod = d;\n+    }\n+\n+    public int getMinimumHitsForVees() {\n+        return minimumHitsForVees;\n+    }\n+\n+    public void setMinimumHitsForVees(int d) {\n+        minimumHitsForVees = d;\n+    }\n+\n+    public boolean useRandomHitsForVees() {\n+        return useRandomHitsForVees;\n+    }\n+\n+    public void setUseRandomHitsForVees(boolean b) {\n+        useRandomHitsForVees = b;\n+    }\n+\n+    public boolean useTougherHealing() {\n+        return tougherHealing;\n+    }\n+\n+    public void setTougherHealing(boolean b) {\n+        tougherHealing = b;\n+    }\n+\n+    public boolean useTransfers() {\n+        return useTransfers;\n+    }\n+\n+    public void setUseTransfers(boolean b) {\n+        useTransfers = b;\n+    }\n+\n+    public boolean getUseTimeInService() {\n+        return useTimeInService;\n+    }\n+\n+    public void setUseTimeInService(boolean b) {\n+        useTimeInService = b;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether or not to show a person's\n+     * origin faction when displaying their details.\n+     */\n+    public boolean showOriginFaction() {\n+        return showOriginFaction;\n+    }\n+\n+    /**\n+     * Sets a value indicating whether or not to show a person's\n+     * origin faction when displaying their details.\n+     */\n+    public void setShowOriginFaction(boolean b) {\n+        showOriginFaction = b;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether or not to randomize the\n+     * origin of personnel.\n+     */\n+    public boolean randomizeOrigin() {\n+        return randomizeOrigin;\n+    }\n+\n+    /**\n+     * Sets a value indicating whether or not to randomize\n+     * the origin of personnel.\n+     * @param b true for randomize, otherwise false\n+     */\n+    public void setRandomizeOrigin(boolean b) {\n+        randomizeOrigin = b;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether or not to randomize the origin of dependents\n+     */\n+    public boolean getRandomizeDependentOrigin() {\n+        return randomizeDependentOrigin;\n+    }\n+\n+    /**\n+     * Sets a value indicating whether or not to randomize the origin of dependents\n+     * @param b true for randomize, otherwise false\n+     */\n+    public void setRandomizeDependentOrigin(boolean b) {\n+        randomizeDependentOrigin = b;\n+    }\n+\n+    /**\n+     * Gets the search radius to use for randomizing\n+     * personnel origins.\n+     */\n+    public int getOriginSearchRadius() {\n+        return originSearchRadius;\n+    }\n+\n+    /**\n+     * Sets the search radius to use for randomizing\n+     * personnel origins.\n+     * @param r The search radius.\n+     */\n+    public void setOriginSearchRadius(int r) {\n+        originSearchRadius = r;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether or not to randomize\n+     * origin to the planetary level, rather than just the\n+     * system level.\n+     */\n+    public boolean isOriginExtraRandom() {\n+        return isOriginExtraRandom;\n+    }\n+\n+    /**\n+     * Sets a value indicating whether or not to randomize\n+     * origin to the planetary level, rather than just the\n+     * system level.\n+     */\n+    public void setOriginExtraRandom(boolean b) {\n+        isOriginExtraRandom = b;\n+    }\n+\n+    /**\n+     * Gets the distance scale factor to apply when weighting\n+     * random origin planets.\n+     */\n+    public double getOriginDistanceScale() {\n+        return originDistanceScale;\n+    }\n+\n+    /**\n+     * Sets the distance scale factor to apply when weighting\n+     * random origin planets (should be between 0.1 and 2).\n+     */\n+    public void setOriginDistanceScale(double v) {\n+        originDistanceScale = v;\n+    }\n+\n+    //region family\n+    public int getMinimumMarriageAge() {", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MjQxNw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392542417", "bodyText": "What do you mean by that? Javadoc style?", "author": "Windchild292", "createdAt": "2020-03-14T01:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMDAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwMTgyMw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392601823", "bodyText": "Ah, the options... do we have an options documentation? Irregardless, I'll create a story to do options documentation for that as it is going to take me a bit of time to think and explain it well.", "author": "Windchild292", "createdAt": "2020-03-14T16:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMDAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwNDI4Mw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392604283", "bodyText": "JavaDoc", "author": "sixlettervariables", "createdAt": "2020-03-14T17:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMDAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwNzI2NA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392607264", "bodyText": "Implemented JavaDoc comments that help with explaining them. The ones in person will come in wave 2, as I've got quite a few more ideas to implement there and find JavaDoc comments slow me down.", "author": "Windchild292", "createdAt": "2020-03-14T18:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMDAzNA=="}], "type": "inlineReview", "revised_code": {"commit": "54b0e55928cce7b86a440231a1c6a708385a7e47", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/CampaignOptions.java b/MekHQ/src/mekhq/campaign/CampaignOptions.java\nindex fa79fc7e1..bb2847e51 100644\n--- a/MekHQ/src/mekhq/campaign/CampaignOptions.java\n+++ b/MekHQ/src/mekhq/campaign/CampaignOptions.java\n\n@@ -908,158 +907,293 @@ public class CampaignOptions implements Serializable {\n     }\n \n     //region family\n+    /**\n+     * @return the minimum age a person can get married at\n+     */\n     public int getMinimumMarriageAge() {\n         return minimumMarriageAge;\n     }\n \n+    /**\n+     * @param b the minimum age a person can get married at\n+     */\n     public void setMinimumMarriageAge(int b) {\n         minimumMarriageAge = b;\n     }\n \n+    /**\n+     * This gets the number of recursions to use when checking mutual ancestors between two personnel\n+     * @return the number of recursions to use\n+     */\n     public int checkMutualAncestorsDepth() {\n         return checkMutualAncestorsDepth;\n     }\n \n+    /**\n+     * This sets the number of recursions to use when checking mutual ancestors between two personnel\n+     * @param b the number of recursions\n+     */\n     public void setCheckMutualAncestorsDepth(int b) {\n         checkMutualAncestorsDepth = b;\n     }\n \n+    /**\n+     * @return whether or not to use random marriages\n+     */\n     public boolean useRandomMarriages() {\n         return useRandomMarriages;\n     }\n \n+    /**\n+     * @param b whether or not to use random marriages\n+     */\n     public void setUseRandomMarriages(boolean b) {\n         useRandomMarriages = b;\n     }\n \n+    /**\n+     * This gets the decimal chance (between 0 and 1) of a random marriage occurring\n+     * @return the chance, with a value between 0 and 1\n+     */\n     public double getChanceRandomMarriages() {\n         return chanceRandomMarriages;\n     }\n \n+    /**\n+     * This sets the decimal chance (between 0 and 1) of a random marriage occurring\n+     * @param b the chance, with a value between 0 and 1\n+     */\n     public void setChanceRandomMarriages(double b) {\n         chanceRandomMarriages = b;\n     }\n \n+    /**\n+     * A random marriage can only happen between two people whose ages differ (+/-) by the returned value\n+     * @return the age range ages can differ (+/-)\n+     */\n     public int getMarriageAgeRange() {\n         return marriageAgeRange;\n     }\n \n+    /**\n+     * A random marriage can only happen between two people whose ages differ (+/-) by this value\n+     * @param b the maximum age range\n+     */\n     public void setMarriageAgeRange(int b) {\n         marriageAgeRange = b;\n     }\n \n+    /**\n+     * @return the array of weights of potential surname changes for weighted marriage surname generation\n+     */\n     public int[] getRandomMarriageSurnameWeights() {\n         return randomMarriageSurnameWeights;\n     }\n \n+    /**\n+     * This gets one of the values in the array of weights of potential surname changes for weighted marriage surname generation\n+     * @param pos the position in the array to set\n+     * @return the weight at index pos\n+     */\n     public int getRandomMarriageSurnameWeights(int pos) {\n         return randomMarriageSurnameWeights[pos];\n     }\n \n+    /**\n+     * This sets one of the values in the array of weights of potential surname changes for weighted marriage surname generation\n+     * @param pos the position in the array to set\n+     * @param b the weight to use\n+     */\n     public void setRandomMarriageSurnameWeight(int pos, int b) {\n         randomMarriageSurnameWeights[pos] = b;\n     }\n \n+    /**\n+     * @return whether or not to use random same sex marriages\n+     */\n     public boolean useRandomSameSexMarriages() {\n         return useRandomSameSexMarriages;\n     }\n \n+    /**\n+     * @param b whether or not to use random same sex marriages\n+     */\n     public void setUseRandomSameSexMarriages(boolean b) {\n         useRandomSameSexMarriages = b;\n     }\n \n+    /**\n+     * This gets the decimal chance (between 0 and 1) of a random same sex marriage occurring\n+     * @return the chance, with a value between 0 and 1\n+     */\n     public double getChanceRandomSameSexMarriages() {\n         return chanceRandomSameSexMarriages;\n     }\n \n+    /**\n+     * This sets the decimal chance (between 0 and 1) of a random same sex marriage occurring\n+     * @param b the chance, with a value between 0 and 1\n+     */\n     public void setChanceRandomSameSexMarriages(double b) {\n         chanceRandomSameSexMarriages = b;\n     }\n \n+    /**\n+     * @return whether or not to use unofficial procreation\n+     */\n     public boolean useUnofficialProcreation() {\n         return useUnofficialProcreation;\n     }\n \n+    /**\n+     * @param b  whether or not to use unofficial procreation\n+     */\n     public void setUseUnofficialProcreation(boolean b) {\n         useUnofficialProcreation = b;\n     }\n \n+    /**\n+     * This gets the decimal chance (between 0 and 1) of random procreation occurring\n+     * @return the chance, with a value between 0 and 1\n+     */\n     public double getChanceProcreation() {\n         return chanceProcreation;\n     }\n \n+    /**\n+     * This sets the decimal chance (between 0 and 1) of random procreation occurring\n+     * @param b the chance, with a value between 0 and 1\n+     */\n     public void setChanceProcreation(double b) {\n         chanceProcreation = b;\n     }\n \n+    /**\n+     * @return whether or not to use unofficial procreation without a relationship\n+     */\n     public boolean useUnofficialProcreationNoRelationship() {\n         return useUnofficialProcreationNoRelationship;\n     }\n \n+    /**\n+     * @param b whether or not to use unofficial procreation without a relationship\n+     */\n     public void setUseUnofficialProcreationNoRelationship(boolean b) {\n         useUnofficialProcreationNoRelationship = b;\n     }\n \n+    /**\n+     * This gets the decimal chance (between 0 and 1) of random procreation occurring without a relationship\n+     * @return the chance, with a value between 0 and 1\n+     */\n     public double getChanceProcreationNoRelationship() {\n         return chanceProcreationNoRelationship;\n     }\n \n+    /**\n+     * This sets the decimal chance (between 0 and 1) of random procreation occurring without a relationship\n+     * @param b the chance, with a value between 0 and 1\n+     */\n     public void setChanceProcreationNoRelationship(double b) {\n         chanceProcreationNoRelationship = b;\n     }\n \n+    /**\n+     * @return whether to show the expected or actual due date for personnel\n+     */\n     public boolean getDisplayTrueDueDate() {\n         return displayTrueDueDate;\n     }\n \n+    /**\n+     * @param b whether to show the expected or actual due date for personnel\n+     */\n     public void setDisplayTrueDueDate(boolean b) {\n         displayTrueDueDate = b;\n     }\n \n+    /**\n+     * @return whether to log conception\n+     */\n     public boolean logConception() {\n         return logConception;\n     }\n \n+    /**\n+     * @param b whether to log conception\n+     */\n     public void setLogConception(boolean b) {\n         logConception = b;\n     }\n \n+    /**\n+     * @return what style of surname to use for a baby\n+     */\n     public int getBabySurnameStyle() {\n         return babySurnameStyle;\n     }\n \n+    /**\n+     * @param b the style of surname to use for a baby\n+     */\n     public void setBabySurnameStyle(int b) {\n         babySurnameStyle = b;\n     }\n \n+    /**\n+     * @return whether or not to display parentage for personnel\n+     */\n     public boolean useParentage() {\n         return useParentage;\n     }\n \n+    /**\n+     * @param b whether or not to display parentage for personnel\n+     */\n     public void setUseParentage(boolean b) {\n         useParentage = b;\n     }\n \n+    /**\n+     * @return the level of familial relation to display\n+     */\n     public int displayFamilyLevel() {\n         return displayFamilyLevel;\n     }\n \n+    /**\n+     * @param b the level of familial relation to display\n+     */\n     public void setDisplayFamilyLevel(int b) {\n         displayFamilyLevel = b;\n     }\n \n+    /**\n+     * TODO : Finish implementing me\n+     * @return whether or not to use random deaths\n+     */\n     public boolean useRandomDeaths() {\n         return useRandomDeaths;\n     }\n \n+    /**\n+     * TODO : Finish implementing me\n+     * @param b whether or not to use random deaths\n+     */\n     public void setUseRandomDeaths(boolean b) {\n-        useRandomMarriages = b;\n+        useRandomDeaths = b;\n     }\n \n+    /**\n+     * @return whether to keep ones married name upon spouse death or not\n+     */\n     public boolean getKeepMarriedNameUponSpouseDeath() {\n         return keepMarriedNameUponSpouseDeath;\n     }\n \n+    /**\n+     * @param b whether to keep ones married name upon spouse death or not\n+     */\n     public void setKeepMarriedNameUponSpouseDeath(boolean b) {\n         keepMarriedNameUponSpouseDeath = b;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMDcxNg==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392530716", "bodyText": "?", "author": "sixlettervariables", "createdAt": "2020-03-13T23:48:55Z", "path": "MekHQ/src/mekhq/campaign/personnel/Person.java", "diffHunk": "@@ -165,31 +148,73 @@\n \n     public PersonAwardController awardController;\n \n-    private static final IntSupplier PREGNANCY_DURATION = () -> {\n+    //region Family Variables\n+    // Lineage\n+    protected UUID ancestorsId;\n+    protected UUID spouse;\n+    protected List<FormerSpouse> formerSpouses;\n+\n+    //region Procreation\n+    protected GregorianCalendar dueDate;\n+    protected GregorianCalendar expectedDueDate;\n+\n+    private static final int PREGNANCY_STANDARD_DURATION = 268; //standard duration of a pregnancy in days\n+\n+    // This creates a random range of approximately six weeks with which to modify the standard pregnancy duration\n+    // To create randomized pregnancy duration\n+    private static final IntSupplier PREGNANCY_MODIFY_DURATION = () -> {\n         double gaussian = Math.sqrt(-2 * Math.log(Math.nextUp(Math.random())))\n             * Math.cos(2.0 * Math.PI * Math.random());\n         // To not get weird results, we limit the values to +/- 4.0 (almost 6 weeks)\n-        gaussian = Math.max(-4.0, Math.min(4.0, gaussian));\n-        return (int) Math.round(gaussian * 10 + 38 * 7);\n+        return (int) Math.round(Math.max(-4.0, Math.min(4.0, gaussian)) * 10);\n     };\n+\n     private static final IntSupplier PREGNANCY_SIZE = () -> {\n         int children = 1;\n         // Hellin's law says it's 1:89 chance, to not make it appear too seldom, we use 1:50\n         while(Compute.randomInt(50) == 0) {\n             ++ children;\n         }\n-        return Math.min(children, 8); // Limit to octuplets, for the sake of sanity\n+        return Math.min(children, 10); // Limit to decuplets, for the sake of sanity", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzMyMg==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392537322", "bodyText": "The odds are insane, but if we've got the base code to support it why not (1 / 50^10, IIRC)", "author": "Windchild292", "createdAt": "2020-03-14T00:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMDcxNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMTIzMw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392531233", "bodyText": "It would be best if the less specific constructors delegated to this, the most specific constructor.", "author": "sixlettervariables", "createdAt": "2020-03-13T23:51:36Z", "path": "MekHQ/src/mekhq/campaign/personnel/Person.java", "diffHunk": "@@ -355,62 +370,115 @@ private static String getMissionParticipatedString() {\n         OTHER_RANSOM_VALUES.put(SkillType.EXP_ELITE, Money.of(50000));\n     }\n \n+    //region Reverse Compatibility\n+    // TODO : Move these so their migration is handled locally, to free the memory space (as minimal it might be)\n+    private int oldUnitId = -1;\n+    private int oldDoctorId = -1;\n+    //v0.1.8 and earlier\n+    protected int teamId = -1;\n+    //endregion Reverse Compatibility\n+    //endregion Variable Declarations\n+\n+    //region Constructors\n     //default constructor\n-    public Person(Campaign c) {\n-        this(\"Biff the Understudy\", c);\n+    public Person(Campaign campaign) {\n+        this(Crew.UNNAMED, Crew.UNNAMED_SURNAME, campaign);\n     }\n \n-    public Person(Campaign c, String factionCode) {\n-        this(\"Biff the Understudy\", c, factionCode);\n+    public Person(Campaign campaign, String factionCode) {\n+        this(Crew.UNNAMED, Crew.UNNAMED_SURNAME, campaign, factionCode);\n     }\n \n-    public Person(String name, Campaign c) {\n-        this(name, c, c.getFactionCode());\n+    public Person(String givenName, String surname, Campaign campaign) {\n+        this(givenName, surname, campaign, campaign.getFactionCode());\n     }\n \n-    public Person(String name, Campaign c, String factionCode) {\n-        this.name = name;\n+    /**\n+     * Primary Person constructor, variables are initialized in the exact same order as they are\n+     * saved to the XML file\n+     * @param givenName     the person's given name\n+     * @param surname       the person's surname\n+     * @param campaign      the campaign this person is a part of\n+     * @param factionCode   the faction this person was borne into\n+     */\n+    public Person(String givenName, String surname, Campaign campaign, String factionCode) {\n+        // First, we assign campaign\n+        this.campaign = campaign;\n+\n+        // Then, we assign the variables in XML file order\n+        id = null;\n+        this.givenName = givenName;\n+        this.surname = surname;\n+        honorific = \"\";\n+        maidenName = null; // this is set to null to handle divorce cases\n         callsign = \"\";\n+        primaryRole = T_NONE;\n+        secondaryRole = T_NONE;\n+        primaryDesignator = DESIG_NONE;\n+        secondaryDesignator = DESIG_NONE;\n+        commander = false;\n+        dependent = false;\n+        originFaction = Faction.getFaction(factionCode);\n+        originPlanet = null;\n+        clan = originFaction.isClan();\n+        phenotype = PHENOTYPE_NONE;\n+        bloodname = \"\";\n+        biography = \"\";\n+        idleMonths = -1;\n+        ancestorsId = null;\n+        spouse = null;\n+        formerSpouses = new ArrayList<>();\n+        dueDate = null;\n+        expectedDueDate = null;\n         portraitCategory = Crew.ROOT_PORTRAIT;\n         portraitFile = Crew.PORTRAIT_NONE;\n-        portraitCategoryOverride = null;\n-        portraitFileOverride = null;\n         xp = 0;\n-        acquisitions = 0;\n-        gender = G_MALE;\n-        birthday = new GregorianCalendar(3042, Calendar.JANUARY, 1);\n+        daysToWaitForHealing = 0;\n+        gender = Crew.G_MALE;\n         rank = 0;\n         rankLevel = 0;\n-        status = S_ACTIVE;\n-        hits = 0;\n-        salary = Money.of(-1);\n-        campaign = c;\n+        rankSystem = -1;\n+        maneiDominiRank = Rank.MD_RANK_NONE;\n+        maneiDominiClass = MD_NONE;\n+        nTasks = 0;\n         doctorId = null;\n         unitId = null;\n-        oldDoctorId = -1;\n-        oldUnitId = -1;\n+        salary = Money.of(-1);\n+        status = S_ACTIVE;\n+        prisonerStatus = PRISONER_NOT;\n+        willingToDefect = false;\n+        hits = 0;\n         toughness = 0;\n-        biography = \"\";\n-        nTasks = 0;\n+        resetMinutesLeft(); // this assigns minutesLeft and overtimeLeft\n+        birthday = null;\n+        dateOfDeath = null;\n+        recruitment = null;\n+        skills = new Skills();\n+        options = new PersonnelOptions();\n+        currentEdge = 0;\n+        techUnitIds = new ArrayList<>();\n         personnelLog = new ArrayList<>();\n         missionLog = new ArrayList<>();\n-        idleMonths = -1;\n-        daysToWaitForHealing = 15;\n-        resetMinutesLeft();\n-        prisonerStatus = PRISONER_NOT;\n-        dependent = false;\n-        commander = false;\n-        isClanTech = false;\n-        techUnitIds = new ArrayList<>();\n-        phenotype = PHENOTYPE_NONE;\n-        originFaction = Faction.getFaction(factionCode);\n-        clan = originFaction.isClan();\n-        bloodname = \"\";\n-        primaryDesignator = DESIG_NONE;\n-        secondaryDesignator = DESIG_NONE;\n         awardController = new PersonAwardController(this);\n+        injuries = new ArrayList<>();\n+        founder = false;\n+        originalUnitWeight = EntityWeightClass.WEIGHT_ULTRA_LIGHT;\n+        originalUnitTech = TECH_IS1;\n+        originalUnitId = null;\n+        acquisitions = 0;\n+        extraData = null;\n+\n+        // Initialize Data based on these settings\n+        setFullName();\n     }\n \n+    public Person(String givenName, String surname, String honorific, Campaign c, String factionCode) {", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzY3OQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392537679", "bodyText": "Good point, I'll swap that over", "author": "Windchild292", "createdAt": "2020-03-14T00:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMTIzMw=="}], "type": "inlineReview", "revised_code": {"commit": "7a5e8d00fe66db92cc5c89c6cb8e24bd9663d6a1", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/personnel/Person.java b/MekHQ/src/mekhq/campaign/personnel/Person.java\nindex c0ecbf61c..28568c3ae 100644\n--- a/MekHQ/src/mekhq/campaign/personnel/Person.java\n+++ b/MekHQ/src/mekhq/campaign/personnel/Person.java\n\n@@ -393,15 +393,21 @@ public class Person implements Serializable, MekHqXmlSerializable {\n         this(givenName, surname, campaign, campaign.getFactionCode());\n     }\n \n+    public Person(String givenName, String surname, Campaign campaign, String factionCode) {\n+        this(givenName, surname, \"\", campaign, factionCode);\n+    }\n+\n     /**\n      * Primary Person constructor, variables are initialized in the exact same order as they are\n      * saved to the XML file\n      * @param givenName     the person's given name\n      * @param surname       the person's surname\n+     * @param honorific     the person's honorific\n      * @param campaign      the campaign this person is a part of\n      * @param factionCode   the faction this person was borne into\n      */\n-    public Person(String givenName, String surname, Campaign campaign, String factionCode) {\n+    public Person(String givenName, String surname, String honorific, Campaign campaign,\n+                  String factionCode) {\n         // First, we assign campaign\n         this.campaign = campaign;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMTM2Nw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392531367", "bodyText": "Is there a particular reason the variant can't be an Enum?", "author": "sixlettervariables", "createdAt": "2020-03-13T23:52:23Z", "path": "MekHQ/src/mekhq/campaign/personnel/Person.java", "diffHunk": "@@ -529,80 +582,96 @@ public void setWillingToDefect(boolean willingToDefect) {\n         this.willingToDefect = willingToDefect && (prisonerStatus == PRISONER_YES);\n     }\n \n-    public String getGenderName() {\n-        return getGenderName(gender);\n-    }\n-\n-    public static String getGenderName(int gender) {\n-        switch (gender) {\n-            case G_MALE:\n-                return \"Male\";\n-            case G_FEMALE:\n-                return \"Female\";\n-            default:\n-                return \"?\";\n-        }\n-    }\n-\n-    public String getChildGenderName() {\n-        return getChildGenderName(gender);\n-    }\n-\n-    public static String getChildGenderName(int gender) {\n-        switch (gender) {\n-            case G_MALE:\n-                return \"boy\";\n-            case G_FEMALE:\n-                return \"girl\";\n-            default:\n-                return \"?\";\n+    //region Text Getters\n+    //TODO : Rename and Localize region\n+    public String getGenderString(int variant) {\n+        return getGenderString(gender, variant);\n+    }\n+\n+    public static String getGenderString(int gender, int variant) {", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MjMyNQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392542325", "bodyText": "Nope, switched it to an enum.", "author": "Windchild292", "createdAt": "2020-03-14T01:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMTM2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "93180719e581b28c7f49738bfc1bf8b88f83cbc1", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/personnel/Person.java b/MekHQ/src/mekhq/campaign/personnel/Person.java\nindex c0ecbf61c..d922b4e89 100644\n--- a/MekHQ/src/mekhq/campaign/personnel/Person.java\n+++ b/MekHQ/src/mekhq/campaign/personnel/Person.java\n\n@@ -584,13 +587,13 @@ public class Person implements Serializable, MekHqXmlSerializable {\n \n     //region Text Getters\n     //TODO : Rename and Localize region\n-    public String getGenderString(int variant) {\n+    public String getGenderString(GENDER_DESCRIPTOR variant) {\n         return getGenderString(gender, variant);\n     }\n \n-    public static String getGenderString(int gender, int variant) {\n+    public static String getGenderString(int gender, GENDER_DESCRIPTOR variant) {\n         switch (variant) {\n-            case G_DESCRIPTION_MALE_FEMALE: {\n+            case MALE_FEMALE: {\n                 switch (gender) {\n                     case Crew.G_MALE:\n                         return \"Male\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMTc1NA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392531754", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String space = \" \";\n          \n          \n            \n                    final String space = \" \";", "author": "sixlettervariables", "createdAt": "2020-03-13T23:54:36Z", "path": "MekHQ/src/mekhq/campaign/personnel/Person.java", "diffHunk": "@@ -701,13 +783,103 @@ public void setMaidenName(String n) {\n     }\n \n     public String getFullName() {\n-        if (bloodname.length() > 0) {\n-            return name + \" \" + bloodname;\n+        return fullName;\n+    }\n+\n+    public void setFullName() {\n+        if (!StringUtil.isNullOrEmpty(givenName)) {\n+            if (isClanner()) {\n+                if (!StringUtil.isNullOrEmpty(bloodname)) {\n+                    fullName = givenName + \" \" + bloodname;\n+                } else {\n+                    fullName = givenName;\n+                }\n+            } else {\n+                if (!StringUtil.isNullOrEmpty(surname)) {\n+                    fullName = givenName + \" \" + surname;\n+                } else {\n+                    fullName = givenName;\n+                }\n+            }\n+\n+            if (!StringUtil.isNullOrEmpty(honorific)) {\n+                fullName += \" \" + honorific;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is used to migrate names from being a joined name to split between given name and surname,\n+     * as part of the Personnel changes in MekHQ 0.47.4.\n+     * @param n the name to be migrated\n+     */\n+    public void migrateName(String n) {\n+        // How this works:\n+        // Takes the input name, and splits it into individual parts.\n+        // Then, it depends on whether the person is a Clanner or not.\n+        // For Clan names:\n+        // Takes the input name, and assumes that person does not have a surname\n+        // Bloodnames are assumed to have been assigned either through the\n+        // For Inner Sphere names:\n+        // Depending on the length of the resulting array, the name is processed differently\n+        // Array of length 1: the name is assumed to not have a surname, just a given name\n+        // Array of length 2: the name is assumed to be a given name and a surname\n+        // Array of length 3: the name is assumed to be a given name and two surnames\n+        // Array of length 4+: the name is assumed to be as many given names as possible and two surnames\n+        //\n+        // Then, the full name is set\n+        String space = \" \";", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "13693ac94adbdff28e62d1272c354cb37a869c2b", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/personnel/Person.java b/MekHQ/src/mekhq/campaign/personnel/Person.java\nindex c0ecbf61c..bc39dc13b 100644\n--- a/MekHQ/src/mekhq/campaign/personnel/Person.java\n+++ b/MekHQ/src/mekhq/campaign/personnel/Person.java\n\n@@ -828,7 +828,7 @@ public class Person implements Serializable, MekHqXmlSerializable {\n         // Array of length 4+: the name is assumed to be as many given names as possible and two surnames\n         //\n         // Then, the full name is set\n-        String space = \" \";\n+        final String space = \" \";\n         String[] name = n.split(space);\n \n         if (isClanner()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMTg3OA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392531878", "bodyText": "Can we get an example name for this area that this handles?", "author": "sixlettervariables", "createdAt": "2020-03-13T23:55:19Z", "path": "MekHQ/src/mekhq/campaign/personnel/Person.java", "diffHunk": "@@ -701,13 +783,103 @@ public void setMaidenName(String n) {\n     }\n \n     public String getFullName() {\n-        if (bloodname.length() > 0) {\n-            return name + \" \" + bloodname;\n+        return fullName;\n+    }\n+\n+    public void setFullName() {\n+        if (!StringUtil.isNullOrEmpty(givenName)) {\n+            if (isClanner()) {\n+                if (!StringUtil.isNullOrEmpty(bloodname)) {\n+                    fullName = givenName + \" \" + bloodname;\n+                } else {\n+                    fullName = givenName;\n+                }\n+            } else {\n+                if (!StringUtil.isNullOrEmpty(surname)) {\n+                    fullName = givenName + \" \" + surname;\n+                } else {\n+                    fullName = givenName;\n+                }\n+            }\n+\n+            if (!StringUtil.isNullOrEmpty(honorific)) {\n+                fullName += \" \" + honorific;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is used to migrate names from being a joined name to split between given name and surname,\n+     * as part of the Personnel changes in MekHQ 0.47.4.\n+     * @param n the name to be migrated\n+     */\n+    public void migrateName(String n) {\n+        // How this works:\n+        // Takes the input name, and splits it into individual parts.\n+        // Then, it depends on whether the person is a Clanner or not.\n+        // For Clan names:\n+        // Takes the input name, and assumes that person does not have a surname\n+        // Bloodnames are assumed to have been assigned either through the\n+        // For Inner Sphere names:\n+        // Depending on the length of the resulting array, the name is processed differently\n+        // Array of length 1: the name is assumed to not have a surname, just a given name\n+        // Array of length 2: the name is assumed to be a given name and a surname\n+        // Array of length 3: the name is assumed to be a given name and two surnames\n+        // Array of length 4+: the name is assumed to be as many given names as possible and two surnames\n+        //\n+        // Then, the full name is set\n+        String space = \" \";\n+        String[] name = n.split(space);\n+\n+        if (isClanner()) {\n+            int i = 0;\n+            givenName = name[i];\n+            for (i = 1; i < name.length - 1; i++) {\n+                if (!name[i].equals(space)) {\n+                    givenName += space + name[i];\n+                }\n+            }\n+\n+            if (!(!StringUtil.isNullOrEmpty(getBloodname()) && getBloodname().equals(name[i]))) {\n+                givenName += space + name[i];\n+            }\n+\n+            surname = null;\n+        } else {\n+            if (name.length == 1) {\n+                givenName = name[0];\n+                surname = null;\n+            } else if (name.length == 2) {\n+                givenName = name[0];\n+                surname = name[1];\n+            } else if (name.length == 3) {\n+                givenName = name[0];\n+                if (name[1].equals(space)) {\n+                    surname = name[2];\n+                } else {\n+                    surname = name[1] + space + name[2];\n+                }\n+            } else if (name.length > 3) {\n+                int i = 0;", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzOTYwNg==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392539606", "bodyText": "One potential case from our own random generation is:\nChan Juan St. Albans\nOne reason I'm adding this is to handle one of my D&D character's names:\nThe Right Honourable Terrwyn Owain ap Gwythyr Aberdinas von Hofen Penderyn III", "author": "Windchild292", "createdAt": "2020-03-14T00:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMTg3OA=="}], "type": "inlineReview", "revised_code": {"commit": "13693ac94adbdff28e62d1272c354cb37a869c2b", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/personnel/Person.java b/MekHQ/src/mekhq/campaign/personnel/Person.java\nindex c0ecbf61c..bc39dc13b 100644\n--- a/MekHQ/src/mekhq/campaign/personnel/Person.java\n+++ b/MekHQ/src/mekhq/campaign/personnel/Person.java\n\n@@ -828,7 +828,7 @@ public class Person implements Serializable, MekHqXmlSerializable {\n         // Array of length 4+: the name is assumed to be as many given names as possible and two surnames\n         //\n         // Then, the full name is set\n-        String space = \" \";\n+        final String space = \" \";\n         String[] name = n.split(space);\n \n         if (isClanner()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMjA1OQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392532059", "bodyText": "Any reason this can't be an Enum? I loathe all of our random integers.", "author": "sixlettervariables", "createdAt": "2020-03-13T23:56:13Z", "path": "MekHQ/src/mekhq/campaign/personnel/Person.java", "diffHunk": "@@ -1034,24 +1207,67 @@ public UUID getId() {\n         return id;\n     }\n \n-    @Nullable\n-    public UUID getSpouseID() {\n-        return spouse;\n-    }\n+    public boolean isChild() {\n+        return (getAge(campaign.getCalendar()) <= 13);\n+    }\n+\n+    //region Age Range Identification\n+    // TODO : Windchild Implement Me fully - Either add or remove in Personnel Wave 2\n+    // idea : have a method that allows you to determine what a person's age range would be, as this could be useful\n+    // in implementing a way to display ages instead of unknown for children\n+    public static final int AGE_BABY = 0;", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzOTg1NQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392539855", "bodyText": "This is unimplemented (code that I'm thinking about for wave 2), but I'll add a note to myself to swap it to an enum (I personally like the integers instead of enums, but I know that's not a common view)", "author": "Windchild292", "createdAt": "2020-03-14T00:44:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMjA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MTI0Nw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392541247", "bodyText": "I've removed the code from this PR", "author": "Windchild292", "createdAt": "2020-03-14T00:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMjA1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "93180719e581b28c7f49738bfc1bf8b88f83cbc1", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/personnel/Person.java b/MekHQ/src/mekhq/campaign/personnel/Person.java\nindex c0ecbf61c..d922b4e89 100644\n--- a/MekHQ/src/mekhq/campaign/personnel/Person.java\n+++ b/MekHQ/src/mekhq/campaign/personnel/Person.java\n\n@@ -1211,62 +1214,6 @@ public class Person implements Serializable, MekHqXmlSerializable {\n         return (getAge(campaign.getCalendar()) <= 13);\n     }\n \n-    //region Age Range Identification\n-    // TODO : Windchild Implement Me fully - Either add or remove in Personnel Wave 2\n-    // idea : have a method that allows you to determine what a person's age range would be, as this could be useful\n-    // in implementing a way to display ages instead of unknown for children\n-    public static final int AGE_BABY = 0;\n-    public static final int AGE_TODDLER = 1;\n-    public static final int AGE_CHILD = 2;\n-    public static final int AGE_PRETEEN = 3;\n-    public static final int AGE_TEENAGER = 4;\n-    public static final int AGE_ADULT = 5;\n-    public static final int AGE_ELDER = 6;\n-    public static final int AGE_NUM = 7;\n-\n-    public static final String[] AGE_NAMES = {\n-        \"Baby\",\n-        \"Toddler\",\n-        \"Child\",\n-        \"Pre-teen\",\n-        \"Teenager\",\n-        \"Adult\",\n-        \"Elder\"\n-    };\n-\n-    public String getAgeRangeName() {\n-        return getAgeRangeName(determineAgeRangeIndex());\n-    }\n-\n-    public String getAgeRangeName(int ageRangeIndex) {\n-        if (ageRangeIndex < AGE_NUM) {\n-            return AGE_NAMES[ageRangeIndex];\n-        } else {\n-            return String.format(\"Error In Age Range - Illegal Index %d\", ageRangeIndex);\n-        }\n-    }\n-\n-    public int determineAgeRangeIndex() {\n-        int age = getAge(campaign.getCalendar());\n-\n-        if (age >= 65) {\n-            return AGE_ELDER;\n-        } else if (age >= 20) {\n-            return AGE_ADULT;\n-        } else if (age >= 13) {\n-            return AGE_TEENAGER;\n-        } else if (age >= 10) {\n-            return AGE_PRETEEN;\n-        } else if (age >= 3) {\n-            return AGE_CHILD;\n-        } else if (age >= 1) {\n-            return AGE_TODDLER;\n-        } else {\n-            return AGE_BABY;\n-        }\n-    }\n-    //endregion Age Range Identification\n-\n     //region Pregnancy\n     public GregorianCalendar getDueDate() {\n         return dueDate;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMjU5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392532595", "bodyText": "Based on this comment then is CampaignOptions storing the fraction or percentage? If Percentage that should be called out in the documentation for the option. Would be more obvious given the name \"chance\" to store it as a fraction and convert to a percentage when displaying.", "author": "sixlettervariables", "createdAt": "2020-03-13T23:59:39Z", "path": "MekHQ/src/mekhq/campaign/personnel/Person.java", "diffHunk": "@@ -1060,166 +1276,420 @@ public void setDueDate(GregorianCalendar dueDate) {\n         this.dueDate = dueDate;\n     }\n \n-    public boolean isPregnant() {\n-        return dueDate != null;\n+    public GregorianCalendar getExpectedDueDate() {\n+        return expectedDueDate;\n     }\n \n-    public UUID getAncestorsId() {\n-        return ancestorsId;\n+    public void setExpectedDueDate(GregorianCalendar expectedDueDate) {\n+        this.expectedDueDate = expectedDueDate;\n     }\n \n-    public void setAncestorsId(UUID id) {\n-        ancestorsId = id;\n+    public boolean isPregnant() {\n+        return dueDate != null;\n     }\n \n-    public Ancestors getAncestors() {\n-        return campaign.getAncestors(ancestorsId);\n-    }\n+    public void procreate() {\n+        if (!isFemale() || isPregnant() || isDeployed()) {\n+            return;\n+        }\n \n-    public Person getMother() {\n-        Ancestors a = getAncestors();\n+        // Age limitations...\n+        if (!isChild() && getAge(campaign.getCalendar()) < 51) {\n+            boolean conceived = false;\n+            if (hasSpouse()) {\n+                if (!getSpouse().isDeployed() && !getSpouse().isDeadOrMIA() && !getSpouse().isChild()\n+                        && !(getSpouse().getGender() == getGender())) {\n+                    // setting is the chance that this procreation attempt will create a child, base is 0.05%\n+                    // the setting is divided by 100 because we are running a float from 0 to 1 instead of 0 to 100\n+                    conceived = (Compute.randomFloat() < (campaign.getCampaignOptions().getChanceProcreation() / 100));\n+                }\n+            } else if (campaign.getCampaignOptions().useUnofficialProcreationNoRelationship()) {\n+                // setting is the chance that this procreation attempt will create a child, base is 0.005%\n+                // the setting is divided by 100 because we are running a float from 0 to 1 instead of 0 to 100\n+                conceived = (Compute.randomFloat() < (campaign.getCampaignOptions().getChanceProcreationNoRelationship() / 100));\n+            }\n \n-        if (a != null) {\n-            return campaign.getPerson(a.getMotherId());\n+            if (conceived) {\n+                addPregnancy();\n+            }\n         }\n-        return null;\n     }\n \n-    public Person getFather() {\n-        Ancestors a = getAncestors();\n+    public void addPregnancy() {\n+        GregorianCalendar tCal = (GregorianCalendar) campaign.getCalendar().clone();\n \n-        if (a != null) {\n-            return campaign.getPerson(a.getFatherId());\n+        tCal.add(GregorianCalendar.DAY_OF_YEAR, PREGNANCY_STANDARD_DURATION);\n+        setExpectedDueDate(tCal);\n+        tCal = (GregorianCalendar) tCal.clone();\n+        tCal.add(GregorianCalendar.DAY_OF_YEAR, PREGNANCY_MODIFY_DURATION.getAsInt());\n+        setDueDate(tCal);\n+\n+        int size = PREGNANCY_SIZE.getAsInt();\n+        if (extraData == null) {\n+            extraData = new ExtraData();\n         }\n-        return null;\n+        extraData.set(PREGNANCY_CHILDREN_DATA, size);\n+        extraData.set(PREGNANCY_FATHER_DATA, (hasSpouse()) ? getSpouseId().toString() : null);\n+\n+        String sizeString = (size < PREGNANCY_MULTIPLE_NAMES.length) ? PREGNANCY_MULTIPLE_NAMES[size] : null;\n+\n+        campaign.addReport(getHyperlinkedName() + \" has conceived\" + (sizeString == null ? \"\" : (\" \" + sizeString)));\n+        if (campaign.getCampaignOptions().logConception()) {\n+            MedicalLogger.hasConceived(this, campaign.getDate(), sizeString);\n+            if (hasSpouse()) {\n+                PersonalLogger.spouseConceived(getSpouse(), getFullName(), campaign.getDate(), sizeString);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Removes a pregnancy and clears all related data from the current person\n+     */\n+    public void removePregnancy() {\n+        setDueDate(null);\n+        setExpectedDueDate(null);\n+        extraData.set(PREGNANCY_CHILDREN_DATA, null);\n+        extraData.set(PREGNANCY_FATHER_DATA, null);\n     }\n \n     public Collection<Person> birth() {\n         int size = extraData.get(PREGNANCY_CHILDREN_DATA, 1);\n         String fatherIdString = extraData.get(PREGNANCY_FATHER_DATA);\n-        UUID fatherId = (null != fatherIdString) ? UUID.fromString(fatherIdString) : getSpouseID();\n+        UUID fatherId = (fatherIdString != null) ? UUID.fromString(fatherIdString) : null;\n         Ancestors anc = campaign.getAncestors(fatherId, id);\n-        if(null == anc) {\n+        if (null == anc) {\n             anc = campaign.createAncestors(fatherId, id);\n         }\n         final UUID ancId = anc.getId();\n-        final String surname = getName().contains(\" \") ? getName().split(\" \", 2)[1] : \"\";\n+\n+        final String surname = generateBabySurname(fatherId);\n \n         // Cleanup\n-        setDueDate(null);\n-        extraData.set(PREGNANCY_CHILDREN_DATA, 0);\n-        extraData.set(PREGNANCY_FATHER_DATA, null);\n+        removePregnancy();\n \n         return IntStream.range(0, size).mapToObj(i -> {\n-            Person baby = campaign.newDependent(T_NONE);\n-            baby.setName(baby.getName().split(\" \", 2)[0] + \" \" + surname);\n+            Person baby = campaign.newDependent(T_NONE, true);\n+            baby.setSurname(surname);\n             baby.setBirthday((GregorianCalendar) campaign.getCalendar().clone());\n             UUID babyId = UUID.randomUUID();\n-            while (null != campaign.getPerson(babyId)) {\n-                babyId = UUID.randomUUID();\n-            }\n+\n             baby.setId(babyId);\n             baby.setAncestorsId(ancId);\n-            campaign.addReport(getHyperlinkedName() + \" has given birth to \" + baby.getHyperlinkedName()\n-                    + \", a baby \" + baby.getChildGenderName());\n+\n+            campaign.addReport(String.format(\"%s has given birth to %s, a baby %s!\", getHyperlinkedName(),\n+                    baby.getHyperlinkedName(), baby.getGenderString(Person.G_DESCRIPTION_BOY_GIRL)));\n             if (campaign.getCampaignOptions().logConception()) {\n                 MedicalLogger.deliveredBaby(this, baby, campaign.getDate());\n+                if (fatherId != null) {\n+                    PersonalLogger.ourChildBorn(campaign.getPerson(fatherId), baby, getFullName(), campaign.getDate());\n+                }\n             }\n             return baby;\n         }).collect(Collectors.toList());\n     }\n \n-    public void procreate() {\n-        if(!isFemale() || isPregnant()) {\n-            return;\n+    private String generateBabySurname(UUID fatherId) {\n+        if (campaign.getCampaignOptions().getBabySurnameStyle() == CampaignOptions.BABY_SURNAME_SPOUSE) {\n+            if (fatherId != null) {\n+                return campaign.getPerson(fatherId).getSurname();\n+            }\n         }\n+        return surname = getSurname();\n+    }\n+    //endregion Pregnancy\n \n-        if (!isDeployed()) {\n-            // Age limitations...\n-            if (getAge(campaign.getCalendar()) > 13 && getAge(campaign.getCalendar()) < 51) {\n-                boolean concieved = false;\n-                if (!hasSpouse() && campaign.getCampaignOptions().useUnofficialProcreationNoRelationship()) {\n-                    // 0.005% chance that this procreation attempt will create a child\n-                    concieved = (Compute.randomInt(100000) < 2);\n-                } else if (hasSpouse()) {\n-                    if (getSpouse().isActive() && !getSpouse().isDeployed() && getSpouse().getAge(campaign.getCalendar()) > 13) {\n-                        // 0.05% chance that this procreation attempt will create a child\n-                        concieved = (Compute.randomInt(10000) < 2);\n-                    }\n-                }\n+    //region Marriage\n+    /**\n+     * Determines if another person is a safe spouse for the current person\n+     * @param p the person to determine if they are a safe spouse\n+     */\n+    public boolean safeSpouse(Person p) {\n+        // Huge convoluted return statement, with the following restrictions\n+        // can't marry yourself\n+        // can't marry someone who is already married\n+        // can't marry a prisoner, unless you are also a prisoner (this is purposely left open for prisoners to marry who they want)\n+        // can't marry a person who is dead or MIA\n+        // can't marry inactive personnel (this is to show how they aren't part of the force anymore)\n+        // can't marry a close relative\n+        return (\n+                !this.equals(p)\n+                && !p.hasSpouse()\n+                && p.oldEnoughToMarry()\n+                && (!p.isPrisoner() || (p.isPrisoner() && isPrisoner()))\n+                && !p.isDeadOrMIA()\n+                && p.isActive()\n+                && ((getAncestorsId() == null)\n+                    || !campaign.getAncestors(getAncestorsId()).checkMutualAncestors(campaign.getAncestors(p.getAncestorsId())))\n+        );\n+    }\n \n-                if(concieved) {\n-                    GregorianCalendar tCal = (GregorianCalendar) campaign.getCalendar().clone();\n-                    tCal.add(GregorianCalendar.DAY_OF_YEAR, PREGNANCY_DURATION.getAsInt());\n-                    setDueDate(tCal);\n-                    int size = PREGNANCY_SIZE.getAsInt();\n-                    extraData.set(PREGNANCY_CHILDREN_DATA, size);\n-                    extraData.set(PREGNANCY_FATHER_DATA,\n-                        (hasSpouse()) ? getSpouseID().toString() : null);\n+    public boolean oldEnoughToMarry() {\n+        return (getAge(campaign.getCalendar()) >= campaign.getCampaignOptions().getMinimumMarriageAge());\n+    }\n \n-                    String sizeString = (size < PREGNANCY_MULTIPLE_NAMES.length) ? PREGNANCY_MULTIPLE_NAMES[size] : null;\n-                    if(null == sizeString) {\n-                        campaign.addReport(getHyperlinkedName()+\" has conceived\");\n-                    } else {\n-                        campaign.addReport(getHyperlinkedName()+\" has conceived \" + sizeString);\n-                    }\n-                    if (campaign.getCampaignOptions().logConception()) {\n-                        MedicalLogger.hasConceived(this, campaign.getDate(), sizeString);\n-                    }\n-                }\n+    public void randomMarriage() {\n+        // Don't attempt to generate is someone has a spouse, isn't old enough to marry,\n+        // is actively deployed, or is currently a prisoner\n+        if (hasSpouse() || !oldEnoughToMarry() || isDeployed() || isPrisoner()) {\n+            return;\n+        }\n+\n+        // setting is the chance that this attempt at finding a marriage will result in one\n+        // the setting is divided by 100 because we are running a float from 0 to 1 instead of 0 to 100\n+        if (Compute.randomFloat() < (campaign.getCampaignOptions().getChanceRandomMarriages() / 100)) {", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MDA0Mw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392540043", "bodyText": "It is saving as a percentage, we divide by 100 here for the fraction.", "author": "Windchild292", "createdAt": "2020-03-14T00:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMjU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MjQ5OQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392542499", "bodyText": "Would you prefer switching to saving it divided by 100 @sixlettervariables?", "author": "Windchild292", "createdAt": "2020-03-14T01:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMjU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwNDI2OQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392604269", "bodyText": "I would find storing a fraction to be less confusing.\nThat being said, JavaDoc for the methods would provide those details and hopefully answer those questions.", "author": "sixlettervariables", "createdAt": "2020-03-14T17:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMjU5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "93180719e581b28c7f49738bfc1bf8b88f83cbc1", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/personnel/Person.java b/MekHQ/src/mekhq/campaign/personnel/Person.java\nindex c0ecbf61c..d922b4e89 100644\n--- a/MekHQ/src/mekhq/campaign/personnel/Person.java\n+++ b/MekHQ/src/mekhq/campaign/personnel/Person.java\n\n@@ -1377,7 +1324,7 @@ public class Person implements Serializable, MekHqXmlSerializable {\n             baby.setAncestorsId(ancId);\n \n             campaign.addReport(String.format(\"%s has given birth to %s, a baby %s!\", getHyperlinkedName(),\n-                    baby.getHyperlinkedName(), baby.getGenderString(Person.G_DESCRIPTION_BOY_GIRL)));\n+                    baby.getHyperlinkedName(), baby.getGenderString(GENDER_DESCRIPTOR.BOY_GIRL)));\n             if (campaign.getCampaignOptions().logConception()) {\n                 MedicalLogger.deliveredBaby(this, baby, campaign.getDate());\n                 if (fatherId != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMzY4Mw==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392533683", "bodyText": "I'm not so sure that'll help. I went through and rewrote this to use equals (as case is important in XML) and also a trie, the node name matching did not end up being a significant part of the work.", "author": "sixlettervariables", "createdAt": "2020-03-14T00:06:05Z", "path": "MekHQ/src/mekhq/campaign/personnel/Person.java", "diffHunk": "@@ -1628,8 +2190,15 @@ public static Person generateInstanceFromXML(Node wn, Campaign c, Version versio\n             for (int x = 0; x < nl.getLength(); x++) {\n                 Node wn2 = nl.item(x);\n \n-                if (wn2.getNodeName().equalsIgnoreCase(\"name\")) {\n-                    retVal.name = wn2.getTextContent();\n+                // TODO : reorder these based on what is most likely to show up, to improve load speed", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MDcwMQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392540701", "bodyText": "Just one of the performance ideas I was working on, I also found it didn't amount to much, but forgot to remove. Removed.", "author": "Windchild292", "createdAt": "2020-03-14T00:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMzY4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "93180719e581b28c7f49738bfc1bf8b88f83cbc1", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/personnel/Person.java b/MekHQ/src/mekhq/campaign/personnel/Person.java\nindex c0ecbf61c..d922b4e89 100644\n--- a/MekHQ/src/mekhq/campaign/personnel/Person.java\n+++ b/MekHQ/src/mekhq/campaign/personnel/Person.java\n\n@@ -2190,15 +2137,14 @@ public class Person implements Serializable, MekHqXmlSerializable {\n             for (int x = 0; x < nl.getLength(); x++) {\n                 Node wn2 = nl.item(x);\n \n-                // TODO : reorder these based on what is most likely to show up, to improve load speed\n                 if (wn2.getNodeName().equalsIgnoreCase(\"name\")) { //included for backwards compatibility\n                     retVal.migrateName(wn2.getTextContent());\n                 } else if (wn2.getNodeName().equalsIgnoreCase(\"givenName\")) {\n-                    retVal.setGivenName(wn2.getTextContent());\n+                    retVal.givenName = wn2.getTextContent();\n                 } else if (wn2.getNodeName().equalsIgnoreCase(\"surname\")) {\n-                    retVal.setSurname(wn2.getTextContent());\n+                    retVal.surname = wn2.getTextContent();\n                 } else if (wn2.getNodeName().equalsIgnoreCase(\"honorific\")) {\n-                    retVal.setHonorific(wn2.getTextContent());\n+                    retVal.honorific = wn2.getTextContent();\n                 } else if (wn2.getNodeName().equalsIgnoreCase(\"maidenName\")) {\n                     retVal.maidenName = wn2.getTextContent();\n                 } else if (wn2.getNodeName().equalsIgnoreCase(\"callsign\")) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMzc0OQ==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392533749", "bodyText": "Why not just call this once at the very end?", "author": "sixlettervariables", "createdAt": "2020-03-14T00:06:30Z", "path": "MekHQ/src/mekhq/campaign/personnel/Person.java", "diffHunk": "@@ -1644,13 +2213,13 @@ public static Person generateInstanceFromXML(Node wn, Campaign c, Version versio\n                     String systemId = wn2.getAttributes().getNamedItem(\"systemId\").getTextContent().trim();\n                     String planetId = wn2.getTextContent().trim();\n                     retVal.originPlanet = c.getSystemById(systemId).getPlanetById(planetId);\n-                } else if (wn2.getNodeName().equalsIgnoreCase(\"isClanTech\")\n-                           || wn2.getNodeName().equalsIgnoreCase(\"clan\")) {\n+                } else if (wn2.getNodeName().equalsIgnoreCase(\"clan\")) {\n                     retVal.clan = Boolean.parseBoolean(wn2.getTextContent().trim());\n                 } else if (wn2.getNodeName().equalsIgnoreCase(\"phenotype\")) {\n                     retVal.phenotype = Integer.parseInt(wn2.getTextContent());\n                 } else if (wn2.getNodeName().equalsIgnoreCase(\"bloodname\")) {\n                     retVal.bloodname = wn2.getTextContent();\n+                    retVal.setFullName();", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MDcyNg==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392540726", "bodyText": "Switched it over to do so", "author": "Windchild292", "createdAt": "2020-03-14T00:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMzc0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "93180719e581b28c7f49738bfc1bf8b88f83cbc1", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/personnel/Person.java b/MekHQ/src/mekhq/campaign/personnel/Person.java\nindex c0ecbf61c..d922b4e89 100644\n--- a/MekHQ/src/mekhq/campaign/personnel/Person.java\n+++ b/MekHQ/src/mekhq/campaign/personnel/Person.java\n\n@@ -2219,7 +2165,6 @@ public class Person implements Serializable, MekHqXmlSerializable {\n                     retVal.phenotype = Integer.parseInt(wn2.getTextContent());\n                 } else if (wn2.getNodeName().equalsIgnoreCase(\"bloodname\")) {\n                     retVal.bloodname = wn2.getTextContent();\n-                    retVal.setFullName();\n                 } else if (wn2.getNodeName().equalsIgnoreCase(\"biography\")) {\n                     retVal.biography = wn2.getTextContent();\n                 } else if (wn2.getNodeName().equalsIgnoreCase(\"primaryRole\")) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNDQ4MA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392534480", "bodyText": "Is abilityString.length() == 0 not an option? (or size() == 0) ?", "author": "sixlettervariables", "createdAt": "2020-03-14T00:10:56Z", "path": "MekHQ/src/mekhq/campaign/personnel/Person.java", "diffHunk": "@@ -2999,39 +3536,38 @@ public void changeEdgeTrigger(String name) {\n     }\n \n     /**\n-     * This function returns an html-coded tooltip that says what edge will be used\n      *\n-     * @return\n+     * @return an html-coded tooltip that says what edge will be used\n      */\n     public String getEdgeTooltip() {\n-        String edgett = \"\";\n+        StringBuilder edgett = new StringBuilder();\n         for (Enumeration<IOption> i = getOptions(PilotOptions.EDGE_ADVANTAGES); i.hasMoreElements(); ) {\n             IOption ability = i.nextElement();\n             //yuck, it would be nice to have a more fool-proof way of identifying edge triggers\n             if (ability.getName().contains(\"edge_when\") && ability.booleanValue()) {\n-                edgett = edgett + ability.getDescription() + \"<br>\";\n+                edgett.append(ability.getDescription()).append(\"<br>\");\n             }\n         }\n-        if (edgett.equals(\"\")) {\n+        if (edgett.toString().equals(\"\")) {\n             return \"No triggers set\";\n         }\n         return \"<html>\" + edgett + \"</html>\";\n     }\n+    //endregion edge\n \n     /**\n-     * This function returns an html-coded list that says what abilities are enabled for this pilot\n      *\n-     * @return\n+     * @return an html-coded list that says what abilities are enabled for this pilot\n      */\n     public String getAbilityList(String type) {\n-        String abilityString = \"\";\n+        StringBuilder abilityString = new StringBuilder();\n         for (Enumeration<IOption> i = getOptions(type); i.hasMoreElements(); ) {\n             IOption ability = i.nextElement();\n             if (ability.booleanValue()) {\n-                abilityString = abilityString + Utilities.getOptionDisplayName(ability) + \"<br>\";\n+                abilityString.append(Utilities.getOptionDisplayName(ability)).append(\"<br>\");\n             }\n         }\n-        if (abilityString.equals(\"\")) {\n+        if (abilityString.toString().equals(\"\")) {", "originalCommit": "106ed2739d3941e172f9ec5ab83d301febb1770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MTA5NA==", "url": "https://github.com/MegaMek/mekhq/pull/1533#discussion_r392541094", "bodyText": "It is, swapped over to using abilityString.length() == 0", "author": "Windchild292", "createdAt": "2020-03-14T00:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNDQ4MA=="}], "type": "inlineReview", "revised_code": {"commit": "93180719e581b28c7f49738bfc1bf8b88f83cbc1", "chunk": "diff --git a/MekHQ/src/mekhq/campaign/personnel/Person.java b/MekHQ/src/mekhq/campaign/personnel/Person.java\nindex c0ecbf61c..d922b4e89 100644\n--- a/MekHQ/src/mekhq/campaign/personnel/Person.java\n+++ b/MekHQ/src/mekhq/campaign/personnel/Person.java\n\n@@ -3567,7 +3514,7 @@ public class Person implements Serializable, MekHqXmlSerializable {\n                 abilityString.append(Utilities.getOptionDisplayName(ability)).append(\"<br>\");\n             }\n         }\n-        if (abilityString.toString().equals(\"\")) {\n+        if (abilityString.length() == 0) {\n             return null;\n         }\n         return \"<html>\" + abilityString + \"</html>\";\n"}}, {"oid": "0f073e3a7e2c11b039283ba4f3d2241a8bdbcd1e", "url": "https://github.com/MegaMek/mekhq/commit/0f073e3a7e2c11b039283ba4f3d2241a8bdbcd1e", "message": "Fixing formatting of activePersonnel if statement\n\nCo-Authored-By: Christopher Watford <christopher.watford@gmail.com>", "committedDate": "2020-03-14T00:27:56Z", "type": "commit"}, {"oid": "13693ac94adbdff28e62d1272c354cb37a869c2b", "url": "https://github.com/MegaMek/mekhq/commit/13693ac94adbdff28e62d1272c354cb37a869c2b", "message": "Update MekHQ/src/mekhq/campaign/personnel/Person.java\n\nCo-Authored-By: Christopher Watford <christopher.watford@gmail.com>", "committedDate": "2020-03-14T00:38:56Z", "type": "commit"}, {"oid": "7a5e8d00fe66db92cc5c89c6cb8e24bd9663d6a1", "url": "https://github.com/MegaMek/mekhq/commit/7a5e8d00fe66db92cc5c89c6cb8e24bd9663d6a1", "message": "Fixing person primary constructor", "committedDate": "2020-03-14T00:39:29Z", "type": "commit"}, {"oid": "87d878402ed18b79eb299e13b6c7e9fc0c34e4ca", "url": "https://github.com/MegaMek/mekhq/commit/87d878402ed18b79eb299e13b6c7e9fc0c34e4ca", "message": "Merge branch 'dev_Windchild_Personnel_Improvements' of https://github.com/Windchild292/mekhq into dev_Windchild_Personnel_Improvements", "committedDate": "2020-03-14T00:39:38Z", "type": "commit"}, {"oid": "93180719e581b28c7f49738bfc1bf8b88f83cbc1", "url": "https://github.com/MegaMek/mekhq/commit/93180719e581b28c7f49738bfc1bf8b88f83cbc1", "message": "Applying review changes to Personnel Improvements", "committedDate": "2020-03-14T01:07:22Z", "type": "commit"}, {"oid": "89df3eebf8e51be3c93d6fbbaeac3a926bc8636c", "url": "https://github.com/MegaMek/mekhq/commit/89df3eebf8e51be3c93d6fbbaeac3a926bc8636c", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-03-14T17:05:14Z", "type": "commit"}, {"oid": "a281a777e4e195487cad182fca2e5db0fe348e43", "url": "https://github.com/MegaMek/mekhq/commit/a281a777e4e195487cad182fca2e5db0fe348e43", "message": "Switching bloodname fail target to automatic failure", "committedDate": "2020-03-14T17:09:09Z", "type": "commit"}, {"oid": "54b0e55928cce7b86a440231a1c6a708385a7e47", "url": "https://github.com/MegaMek/mekhq/commit/54b0e55928cce7b86a440231a1c6a708385a7e47", "message": "Switching to saving a decimal chance value, and adding JavaDoc comments", "committedDate": "2020-03-14T18:08:01Z", "type": "commit"}, {"oid": "5bbe64b993a62f7fdfefd0125816787d1761ce41", "url": "https://github.com/MegaMek/mekhq/commit/5bbe64b993a62f7fdfefd0125816787d1761ce41", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-03-16T22:50:31Z", "type": "commit"}, {"oid": "dfa532aaa2a27b2be18a70361c44659077423b13", "url": "https://github.com/MegaMek/mekhq/commit/dfa532aaa2a27b2be18a70361c44659077423b13", "message": "Fixing merge conflicts", "committedDate": "2020-03-17T13:45:13Z", "type": "commit"}, {"oid": "5ad6c26489923f9027cddea7ba2e2a27fb3334de", "url": "https://github.com/MegaMek/mekhq/commit/5ad6c26489923f9027cddea7ba2e2a27fb3334de", "message": "Fixing merge conflict", "committedDate": "2020-03-17T18:58:09Z", "type": "commit"}, {"oid": "4ec03b5f9da8954172e45720737774fa903e796e", "url": "https://github.com/MegaMek/mekhq/commit/4ec03b5f9da8954172e45720737774fa903e796e", "message": "Removing accidentally added imports", "committedDate": "2020-03-18T19:14:54Z", "type": "commit"}, {"oid": "d5b32aa7b41ce05810d3b526d6fa3c09a83c4a79", "url": "https://github.com/MegaMek/mekhq/commit/d5b32aa7b41ce05810d3b526d6fa3c09a83c4a79", "message": "Adding initial grandchildren support and improving personnel methods", "committedDate": "2020-01-30T19:29:16Z", "type": "commit"}, {"oid": "3571d42dcc3ff7457e8a9d03d661bbcfb634b81b", "url": "https://github.com/MegaMek/mekhq/commit/3571d42dcc3ff7457e8a9d03d661bbcfb634b81b", "message": "Adding logic to determine is a person has grandparents, grandchildren, aunts/uncles, cousins, siblings", "committedDate": "2020-01-30T22:00:12Z", "type": "commit"}, {"oid": "8284f3f767294022361947d9580131ff8201743a", "url": "https://github.com/MegaMek/mekhq/commit/8284f3f767294022361947d9580131ff8201743a", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-03T14:56:31Z", "type": "commit"}, {"oid": "0431e0abaf1a60a747b81b5804fe69e48b179fdc", "url": "https://github.com/MegaMek/mekhq/commit/0431e0abaf1a60a747b81b5804fe69e48b179fdc", "message": "Further refactoring in Person", "committedDate": "2020-02-03T15:13:42Z", "type": "commit"}, {"oid": "c23475b733c6b628f0c2f6322d784a7065d27716", "url": "https://github.com/MegaMek/mekhq/commit/c23475b733c6b628f0c2f6322d784a7065d27716", "message": "Added first version of extended family display", "committedDate": "2020-02-03T17:58:44Z", "type": "commit"}, {"oid": "4c7daae94d1c6d6f574a7b47a70fa9122d8bff07", "url": "https://github.com/MegaMek/mekhq/commit/4c7daae94d1c6d6f574a7b47a70fa9122d8bff07", "message": "Adding family resources", "committedDate": "2020-02-03T19:23:55Z", "type": "commit"}, {"oid": "1879cf3f8bdb2bee0d14ece93e47941af91c9cf8", "url": "https://github.com/MegaMek/mekhq/commit/1879cf3f8bdb2bee0d14ece93e47941af91c9cf8", "message": "Adding Family view changes to PersonViewPanel and fixing bugs", "committedDate": "2020-02-03T19:25:10Z", "type": "commit"}, {"oid": "104ccdf3cacfdf4283ba5d461075f4edae5af1f1", "url": "https://github.com/MegaMek/mekhq/commit/104ccdf3cacfdf4283ba5d461075f4edae5af1f1", "message": "Merge remote-tracking branch 'origin/dev_Windchild_Insomnia' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-03T20:27:34Z", "type": "commit"}, {"oid": "b63dcaa13db88f46dde202011b157668ae7467a4", "url": "https://github.com/MegaMek/mekhq/commit/b63dcaa13db88f46dde202011b157668ae7467a4", "message": "Merge remote-tracking branch 'origin/dev_Windchild_Insomnia' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-03T20:35:56Z", "type": "commit"}, {"oid": "c31e32c8f4b0c1ad6791ff497664dc84888249fb", "url": "https://github.com/MegaMek/mekhq/commit/c31e32c8f4b0c1ad6791ff497664dc84888249fb", "message": "Adding new Personnel Options", "committedDate": "2020-02-03T23:09:55Z", "type": "commit"}, {"oid": "0f70e12b632d01112651af11c0871fc1d064abb2", "url": "https://github.com/MegaMek/mekhq/commit/0f70e12b632d01112651af11c0871fc1d064abb2", "message": "Migrating Personnel Tab to Resources File, Part 1", "committedDate": "2020-02-03T23:10:39Z", "type": "commit"}, {"oid": "7aa20bbda5da4bd989472cf3220b52826a27321e", "url": "https://github.com/MegaMek/mekhq/commit/7aa20bbda5da4bd989472cf3220b52826a27321e", "message": "Adding initial personnel option changes to settings", "committedDate": "2020-02-04T02:36:51Z", "type": "commit"}, {"oid": "48e93ccff66afcec2a225a47b2a251ba17d8394e", "url": "https://github.com/MegaMek/mekhq/commit/48e93ccff66afcec2a225a47b2a251ba17d8394e", "message": "Added Options for Relationship Depth and Family Display Level", "committedDate": "2020-02-04T17:10:33Z", "type": "commit"}, {"oid": "607698b3f65d3c0974b789569ecb0c33bce74573", "url": "https://github.com/MegaMek/mekhq/commit/607698b3f65d3c0974b789569ecb0c33bce74573", "message": "Adding in FormerSpouse and options for Pregnancy percentage", "committedDate": "2020-02-05T01:12:10Z", "type": "commit"}, {"oid": "1161087f90c0510a4681c9fae19fdec253c61c80", "url": "https://github.com/MegaMek/mekhq/commit/1161087f90c0510a4681c9fae19fdec253c61c80", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-05T01:14:53Z", "type": "commit"}, {"oid": "bff187d8f950b6470b221cb949117350b514a59e", "url": "https://github.com/MegaMek/mekhq/commit/bff187d8f950b6470b221cb949117350b514a59e", "message": "Localizing pregnancy options", "committedDate": "2020-02-05T01:15:40Z", "type": "commit"}, {"oid": "b6cc5250a7c03d2d2b2cd32f8c22e8379ac49b21", "url": "https://github.com/MegaMek/mekhq/commit/b6cc5250a7c03d2d2b2cd32f8c22e8379ac49b21", "message": "Adding former spouse tracking", "committedDate": "2020-02-05T02:50:51Z", "type": "commit"}, {"oid": "728092643ee40ce4a7cf50a307737073d48a2280", "url": "https://github.com/MegaMek/mekhq/commit/728092643ee40ce4a7cf50a307737073d48a2280", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-05T03:07:38Z", "type": "commit"}, {"oid": "4bdd08eae4dbc05e838493c19e360081b95fa69d", "url": "https://github.com/MegaMek/mekhq/commit/4bdd08eae4dbc05e838493c19e360081b95fa69d", "message": "Added space between if and {", "committedDate": "2020-02-05T03:26:06Z", "type": "commit"}, {"oid": "1843572aa2e3936c4806f942f24b9146724d9018", "url": "https://github.com/MegaMek/mekhq/commit/1843572aa2e3936c4806f942f24b9146724d9018", "message": "Splitting names in Surname and Given Name in MekHQ", "committedDate": "2020-02-05T21:41:40Z", "type": "commit"}, {"oid": "5b4505366b7872e4b4ef8a2a594e1df5f19c7ff0", "url": "https://github.com/MegaMek/mekhq/commit/5b4505366b7872e4b4ef8a2a594e1df5f19c7ff0", "message": "Trying to fix sizing in person customization", "committedDate": "2020-02-05T21:54:34Z", "type": "commit"}, {"oid": "d02af3d47923c3b68f2c7ff601f566fbca5e1d41", "url": "https://github.com/MegaMek/mekhq/commit/d02af3d47923c3b68f2c7ff601f566fbca5e1d41", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-06T02:39:37Z", "type": "commit"}, {"oid": "3260bd4b701bd0f173d452758a8894f4f439a9d0", "url": "https://github.com/MegaMek/mekhq/commit/3260bd4b701bd0f173d452758a8894f4f439a9d0", "message": "Adding baby last name choice between father and mother", "committedDate": "2020-02-06T03:11:21Z", "type": "commit"}, {"oid": "9d351ce749f162e40f71207f6067a8844a0ae0b4", "url": "https://github.com/MegaMek/mekhq/commit/9d351ce749f162e40f71207f6067a8844a0ae0b4", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-06T16:43:43Z", "type": "commit"}, {"oid": "a9d9120047bbc7f0e0dfed376d09898b78cd90f3", "url": "https://github.com/MegaMek/mekhq/commit/a9d9120047bbc7f0e0dfed376d09898b78cd90f3", "message": "Adding baby surname support and implementing split names", "committedDate": "2020-02-06T18:10:41Z", "type": "commit"}, {"oid": "1bc5257ebaa9d492860ec98eace1878e9033a2dd", "url": "https://github.com/MegaMek/mekhq/commit/1bc5257ebaa9d492860ec98eace1878e9033a2dd", "message": "Enabling generateGivenNameSurnameSplit", "committedDate": "2020-02-06T18:37:22Z", "type": "commit"}, {"oid": "d8cfead07d93fd94d856241c969f6d85593b2735", "url": "https://github.com/MegaMek/mekhq/commit/d8cfead07d93fd94d856241c969f6d85593b2735", "message": "Bugfixing and enabling pregnancy choices up to 100%", "committedDate": "2020-02-06T19:37:46Z", "type": "commit"}, {"oid": "8126baa125b7cfce0ba02dd54eb9288b9adb3670", "url": "https://github.com/MegaMek/mekhq/commit/8126baa125b7cfce0ba02dd54eb9288b9adb3670", "message": "Added new generate version, then found it is about Crew, so commented it out", "committedDate": "2020-02-06T20:34:43Z", "type": "commit"}, {"oid": "b32870666b133c5e8ff691a45c6a6b307dea42eb", "url": "https://github.com/MegaMek/mekhq/commit/b32870666b133c5e8ff691a45c6a6b307dea42eb", "message": "Initial Bloodname changes", "committedDate": "2020-02-06T23:00:26Z", "type": "commit"}, {"oid": "193c1d075a24539ff975a2ce03d2ebecf5e2475c", "url": "https://github.com/MegaMek/mekhq/commit/193c1d075a24539ff975a2ce03d2ebecf5e2475c", "message": "Reverting Person.java changes for Bloodnames to ensure that names are finished first before Bloodnames are done", "committedDate": "2020-02-06T23:12:07Z", "type": "commit"}, {"oid": "aefb66b803387b7547f0ef5c67cf39e391893f43", "url": "https://github.com/MegaMek/mekhq/commit/aefb66b803387b7547f0ef5c67cf39e391893f43", "message": "Bugfixing the first 6 parts of the Personnel Improvements", "committedDate": "2020-02-07T03:07:13Z", "type": "commit"}, {"oid": "10c4ed89604bfdaef613c484a3c7cc69a4290d4b", "url": "https://github.com/MegaMek/mekhq/commit/10c4ed89604bfdaef613c484a3c7cc69a4290d4b", "message": "Changing save format from yyyy-MMM-dd to yyyy-MM-dd", "committedDate": "2020-02-07T03:12:33Z", "type": "commit"}, {"oid": "680b5fed370e91f9ec8eac3318523d760abfc2b4", "url": "https://github.com/MegaMek/mekhq/commit/680b5fed370e91f9ec8eac3318523d760abfc2b4", "message": "Removed unused import in MekHQ", "committedDate": "2020-02-07T04:45:48Z", "type": "commit"}, {"oid": "63e8b05f7f5d4121e3ed099d4d37ac886b1dd49c", "url": "https://github.com/MegaMek/mekhq/commit/63e8b05f7f5d4121e3ed099d4d37ac886b1dd49c", "message": "Bugfixing personnel family display, and adding initial age range ideas", "committedDate": "2020-02-07T17:31:21Z", "type": "commit"}, {"oid": "04d589a3bf4a00ea0522a9cdf182a2587fb688a0", "url": "https://github.com/MegaMek/mekhq/commit/04d589a3bf4a00ea0522a9cdf182a2587fb688a0", "message": "Adding concieved and baby born tracking to fathers", "committedDate": "2020-02-07T19:02:42Z", "type": "commit"}, {"oid": "81c0153dfe3e6539f0279f96337954afe4579ff0", "url": "https://github.com/MegaMek/mekhq/commit/81c0153dfe3e6539f0279f96337954afe4579ff0", "message": "Personal review 2: applying changes and fixes", "committedDate": "2020-02-07T19:35:30Z", "type": "commit"}, {"oid": "0ab7fd4e3cf647e115b4b082db43fd161d02a475", "url": "https://github.com/MegaMek/mekhq/commit/0ab7fd4e3cf647e115b4b082db43fd161d02a475", "message": "Adding more regions to make Person easier to parse", "committedDate": "2020-02-08T20:54:55Z", "type": "commit"}, {"oid": "1e90e73a2ecabdae62df8c59ef6ac2270caa20fc", "url": "https://github.com/MegaMek/mekhq/commit/1e90e73a2ecabdae62df8c59ef6ac2270caa20fc", "message": "Adding options for the next stage of Personnel Improvements", "committedDate": "2020-02-08T22:19:58Z", "type": "commit"}, {"oid": "130726f4524c70e8f46a80bb2585a11e62cb6388", "url": "https://github.com/MegaMek/mekhq/commit/130726f4524c70e8f46a80bb2585a11e62cb6388", "message": "Adding new settings for wave 2 of Personnel Improvements", "committedDate": "2020-02-09T04:42:22Z", "type": "commit"}, {"oid": "2786357cd6ce52630e26d66dbe1bf732285e09b9", "url": "https://github.com/MegaMek/mekhq/commit/2786357cd6ce52630e26d66dbe1bf732285e09b9", "message": "Adding missed Wave 2 Personnel options", "committedDate": "2020-02-09T16:47:28Z", "type": "commit"}, {"oid": "094857e9dd28412e4282d965dde8875f83cd128d", "url": "https://github.com/MegaMek/mekhq/commit/094857e9dd28412e4282d965dde8875f83cd128d", "message": "Adding pregnancy calculation changes for expected due dates", "committedDate": "2020-02-09T16:57:15Z", "type": "commit"}, {"oid": "ff856c2d778e7b52b28aa678df0369acae135f00", "url": "https://github.com/MegaMek/mekhq/commit/ff856c2d778e7b52b28aa678df0369acae135f00", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-09T16:57:54Z", "type": "commit"}, {"oid": "da15ffcd9e9cd8677b2ac72d6981807505c41855", "url": "https://github.com/MegaMek/mekhq/commit/da15ffcd9e9cd8677b2ac72d6981807505c41855", "message": "Merge remote-tracking branch 'origin/dev_Windchild_1261' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-09T16:59:02Z", "type": "commit"}, {"oid": "5514283c30c10ea35fa4bd936d7570f5e056622c", "url": "https://github.com/MegaMek/mekhq/commit/5514283c30c10ea35fa4bd936d7570f5e056622c", "message": "Changing name of setting to use True Due Date, and finishing the implementation of it", "committedDate": "2020-02-09T17:09:26Z", "type": "commit"}, {"oid": "3b10b0d2e16d6e3aab639903f9de7c5512ae1e23", "url": "https://github.com/MegaMek/mekhq/commit/3b10b0d2e16d6e3aab639903f9de7c5512ae1e23", "message": "Merging with latest develop", "committedDate": "2020-02-11T16:34:18Z", "type": "commit"}, {"oid": "08d2ccb4398c098fa4b7873c8f6e72f6f8f96d88", "url": "https://github.com/MegaMek/mekhq/commit/08d2ccb4398c098fa4b7873c8f6e72f6f8f96d88", "message": "Adding Given Name and Surname to personnel tables, and ordering with Bloodnames", "committedDate": "2020-02-12T00:35:13Z", "type": "commit"}, {"oid": "042e8c41708cc4903b794129f0959b826713bb31", "url": "https://github.com/MegaMek/mekhq/commit/042e8c41708cc4903b794129f0959b826713bb31", "message": "Removing unused import statement", "committedDate": "2020-02-12T00:36:03Z", "type": "commit"}, {"oid": "729577d1ff90c298e8d946536edb47e6b2b6cafb", "url": "https://github.com/MegaMek/mekhq/commit/729577d1ff90c298e8d946536edb47e6b2b6cafb", "message": "Moved the minimumMarriageAge to the top of the marriage subsection to avoid confusion with random marriages", "committedDate": "2020-02-12T01:13:57Z", "type": "commit"}, {"oid": "d4be9e8ad4372b85e1a905b235019d75fe1d4e83", "url": "https://github.com/MegaMek/mekhq/commit/d4be9e8ad4372b85e1a905b235019d75fe1d4e83", "message": "Adding personnel wave 2 campaign option descriptions to the resources file", "committedDate": "2020-02-12T01:17:13Z", "type": "commit"}, {"oid": "874320512e7adf8de474be6f94f0c7edb131355c", "url": "https://github.com/MegaMek/mekhq/commit/874320512e7adf8de474be6f94f0c7edb131355c", "message": "Moving Mutual Ancestor depth in options to avoid random marriage confusion", "committedDate": "2020-02-12T01:23:25Z", "type": "commit"}, {"oid": "d45f0c8f1e8d0876d5b25b945e40540671bf67a1", "url": "https://github.com/MegaMek/mekhq/commit/d45f0c8f1e8d0876d5b25b945e40540671bf67a1", "message": "Bugfixing display expected due date versus the true due date option", "committedDate": "2020-02-12T01:47:16Z", "type": "commit"}, {"oid": "efff230088085f646c058bd8e44d7735365e29ba", "url": "https://github.com/MegaMek/mekhq/commit/efff230088085f646c058bd8e44d7735365e29ba", "message": "Fixing Bloodname assignment on Load", "committedDate": "2020-02-12T01:58:20Z", "type": "commit"}, {"oid": "1b64734c058f3945e684c104b45f2972d2fd6f86", "url": "https://github.com/MegaMek/mekhq/commit/1b64734c058f3945e684c104b45f2972d2fd6f86", "message": "Implementing the ability to revert to maiden name upon spouse death", "committedDate": "2020-02-12T02:14:26Z", "type": "commit"}, {"oid": "ef912bfa298a5df09703aee87c5c86e3a5632e08", "url": "https://github.com/MegaMek/mekhq/commit/ef912bfa298a5df09703aee87c5c86e3a5632e08", "message": "Moving the maiden name reset outside of the keep married name if statement", "committedDate": "2020-02-12T02:15:08Z", "type": "commit"}, {"oid": "cf4e563d064fb532314d2459568bbed99616df90", "url": "https://github.com/MegaMek/mekhq/commit/cf4e563d064fb532314d2459568bbed99616df90", "message": "Implementing first stages of Divorce surname changes", "committedDate": "2020-02-12T02:35:41Z", "type": "commit"}, {"oid": "5f12dcde2bc2ebdd80fe447b6ab52a267cc0c6aa", "url": "https://github.com/MegaMek/mekhq/commit/5f12dcde2bc2ebdd80fe447b6ab52a267cc0c6aa", "message": "Adding divorce options", "committedDate": "2020-02-12T22:17:38Z", "type": "commit"}, {"oid": "e417978e47a8f757b4ea1e4bc62b52598707ccf2", "url": "https://github.com/MegaMek/mekhq/commit/e417978e47a8f757b4ea1e4bc62b52598707ccf2", "message": "Fixing spacing issue in PersonnelTab", "committedDate": "2020-02-12T22:49:51Z", "type": "commit"}, {"oid": "30f7654f5d5a1e4bb04f5378c10c7c41e2a52796", "url": "https://github.com/MegaMek/mekhq/commit/30f7654f5d5a1e4bb04f5378c10c7c41e2a52796", "message": "Removing old TODO statement in isChild", "committedDate": "2020-02-13T00:06:00Z", "type": "commit"}, {"oid": "76207d6a616eabbe84eb2183a612816d19bd1799", "url": "https://github.com/MegaMek/mekhq/commit/76207d6a616eabbe84eb2183a612816d19bd1799", "message": "Adding initial randomMarriage methods", "committedDate": "2020-02-14T14:33:22Z", "type": "commit"}, {"oid": "cf8fa99eda987e8db4dcb1a433b5c29b994d5cc4", "url": "https://github.com/MegaMek/mekhq/commit/cf8fa99eda987e8db4dcb1a433b5c29b994d5cc4", "message": "Removing prisoners from safe spouse list", "committedDate": "2020-02-14T14:34:45Z", "type": "commit"}, {"oid": "291a16e405bf7b21d5c41682ddaec3ca615b95f3", "url": "https://github.com/MegaMek/mekhq/commit/291a16e405bf7b21d5c41682ddaec3ca615b95f3", "message": "Fixing merge conflicts", "committedDate": "2020-02-15T16:08:15Z", "type": "commit"}, {"oid": "7f6fb0a635f0da53aea5b34a5cd4cf2aff9b465a", "url": "https://github.com/MegaMek/mekhq/commit/7f6fb0a635f0da53aea5b34a5cd4cf2aff9b465a", "message": "Applying MekHQ-side improvements after implementing extraData and gender in MegaMek", "committedDate": "2020-02-15T20:49:02Z", "type": "commit"}, {"oid": "5786cec6f97325cda0507e5d663a76553f9de9da", "url": "https://github.com/MegaMek/mekhq/commit/5786cec6f97325cda0507e5d663a76553f9de9da", "message": "Adding Bondsman hiring output as per TODO", "committedDate": "2020-02-15T21:36:29Z", "type": "commit"}, {"oid": "9d8620bc6444f53181d4c72ad239e9e602287e2c", "url": "https://github.com/MegaMek/mekhq/commit/9d8620bc6444f53181d4c72ad239e9e602287e2c", "message": "1482: Fixing Time In Service for bulk hired personnel", "committedDate": "2020-02-15T22:25:28Z", "type": "commit"}, {"oid": "902ab105adc18ff9b17e1c3033269773f95166c7", "url": "https://github.com/MegaMek/mekhq/commit/902ab105adc18ff9b17e1c3033269773f95166c7", "message": "Standardizing personnel hiring in MekHQ", "committedDate": "2020-02-15T23:52:03Z", "type": "commit"}, {"oid": "90da714a3da234f6f15cb0a9aee51320719f4730", "url": "https://github.com/MegaMek/mekhq/commit/90da714a3da234f6f15cb0a9aee51320719f4730", "message": "Adding in Random Marriages, outside of the weighted surname selection", "committedDate": "2020-02-16T02:38:52Z", "type": "commit"}, {"oid": "7ac51deb362e1dab360ee65a614ca442610d7e23", "url": "https://github.com/MegaMek/mekhq/commit/7ac51deb362e1dab360ee65a614ca442610d7e23", "message": "Cleaning up and localizing the menu in CampaignGUI", "committedDate": "2020-02-16T14:25:12Z", "type": "commit"}, {"oid": "639ce2828ad7f77ff96c6de5c4149710d0a66c12", "url": "https://github.com/MegaMek/mekhq/commit/639ce2828ad7f77ff96c6de5c4149710d0a66c12", "message": "Removing unnecessary quotation mark from miFireAllMedics.text", "committedDate": "2020-02-16T14:52:41Z", "type": "commit"}, {"oid": "1deab60cdfde3597f23c5d68e6989570121381be", "url": "https://github.com/MegaMek/mekhq/commit/1deab60cdfde3597f23c5d68e6989570121381be", "message": "Fixing personnel family option sizes", "committedDate": "2020-02-16T15:48:31Z", "type": "commit"}, {"oid": "bfbdb580d965d61d1a8bfe4894c6e4581a802b78", "url": "https://github.com/MegaMek/mekhq/commit/bfbdb580d965d61d1a8bfe4894c6e4581a802b78", "message": "Localizing PersonnelTableModel", "committedDate": "2020-02-16T17:18:05Z", "type": "commit"}, {"oid": "907b1e1b043e63c17db0fc28678abdf39addd177", "url": "https://github.com/MegaMek/mekhq/commit/907b1e1b043e63c17db0fc28678abdf39addd177", "message": "1486: Fixing Export to Unit and Personnel", "committedDate": "2020-02-16T17:18:49Z", "type": "commit"}, {"oid": "83945254815b5e151c38f1bc41d009a0ed8c0161", "url": "https://github.com/MegaMek/mekhq/commit/83945254815b5e151c38f1bc41d009a0ed8c0161", "message": "Moving WeightedMap to MegaMek Util and implemeting WeightedSurname choices for marriages", "committedDate": "2020-02-16T19:47:24Z", "type": "commit"}, {"oid": "974d80b27b7af29d787a3be1e2a70c99314474ec", "url": "https://github.com/MegaMek/mekhq/commit/974d80b27b7af29d787a3be1e2a70c99314474ec", "message": "Adding Surname Weights to settings", "committedDate": "2020-02-16T20:37:08Z", "type": "commit"}, {"oid": "9ef0a20dac15a342590da4e57469aba764174b2f", "url": "https://github.com/MegaMek/mekhq/commit/9ef0a20dac15a342590da4e57469aba764174b2f", "message": "Enabling random marriages", "committedDate": "2020-02-16T20:37:18Z", "type": "commit"}, {"oid": "aa750fce74108b4e46f5df07fa383ad04c3132df", "url": "https://github.com/MegaMek/mekhq/commit/aa750fce74108b4e46f5df07fa383ad04c3132df", "message": "Fixing random marriages", "committedDate": "2020-02-16T20:57:00Z", "type": "commit"}, {"oid": "3220b5d5c477456d1a571b55632dc4351a850e84", "url": "https://github.com/MegaMek/mekhq/commit/3220b5d5c477456d1a571b55632dc4351a850e84", "message": "Moving Divorce code to Person, and removing duplicate UUID check", "committedDate": "2020-02-16T21:23:36Z", "type": "commit"}, {"oid": "1335d1e14b921e719ba81412b8878e4c6131379c", "url": "https://github.com/MegaMek/mekhq/commit/1335d1e14b921e719ba81412b8878e4c6131379c", "message": "Refactoring MedicalViewDialog", "committedDate": "2020-02-16T22:44:39Z", "type": "commit"}, {"oid": "817a424491d46aee3cacf0b1e5341d3c8ab86395", "url": "https://github.com/MegaMek/mekhq/commit/817a424491d46aee3cacf0b1e5341d3c8ab86395", "message": "Fixes and refactoring in Utilities and Person", "committedDate": "2020-02-16T22:45:53Z", "type": "commit"}, {"oid": "eabd6cc24c1a8f99ded6417fdf8adf14baa15c39", "url": "https://github.com/MegaMek/mekhq/commit/eabd6cc24c1a8f99ded6417fdf8adf14baa15c39", "message": "1492: Fixing Medical Personnel Display Null Issue and fixing bugs in random marriages", "committedDate": "2020-02-16T23:53:18Z", "type": "commit"}, {"oid": "56322256b90d940b8a3ea974ab9a2de5de566906", "url": "https://github.com/MegaMek/mekhq/commit/56322256b90d940b8a3ea974ab9a2de5de566906", "message": "Implementing Crew name and gender migration, and starting to bugfix", "committedDate": "2020-02-17T01:30:02Z", "type": "commit"}, {"oid": "7692538e9ef7b9ef2381bdfd5413786a914f6b8f", "url": "https://github.com/MegaMek/mekhq/commit/7692538e9ef7b9ef2381bdfd5413786a914f6b8f", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-17T01:32:26Z", "type": "commit"}, {"oid": "57110775d7110a4f7b19dd413707168e14dfa2bc", "url": "https://github.com/MegaMek/mekhq/commit/57110775d7110a4f7b19dd413707168e14dfa2bc", "message": "Fixed name migration for names including spaces", "committedDate": "2020-02-17T02:28:53Z", "type": "commit"}, {"oid": "6f68879374aa1942110459419d36bea2003dae4b", "url": "https://github.com/MegaMek/mekhq/commit/6f68879374aa1942110459419d36bea2003dae4b", "message": "Initial fixes in writing and using the new gender and extraDatacrew fields in MekHQ", "committedDate": "2020-02-17T15:22:48Z", "type": "commit"}, {"oid": "5a8ceb0dac8a422f28898d735593ae3a62dc6867", "url": "https://github.com/MegaMek/mekhq/commit/5a8ceb0dac8a422f28898d735593ae3a62dc6867", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_Personnel_Improvements", "committedDate": "2020-02-17T15:23:57Z", "type": "commit"}, {"oid": "47f51e137f134dc182751bd55e50f7a718776a7b", "url": "https://github.com/MegaMek/mekhq/commit/47f51e137f134dc182751bd55e50f7a718776a7b", "message": "Changing newPerson to use a set gender or randomize based on a single value, so that genders are set properly during import from MegaMek", "committedDate": "2020-02-17T16:17:27Z", "type": "commit"}, {"oid": "0956177ec937fb1ee8e98740d66e245c443ba7e1", "url": "https://github.com/MegaMek/mekhq/commit/0956177ec937fb1ee8e98740d66e245c443ba7e1", "message": "Adding option for Randomize Dependent Origin", "committedDate": "2020-02-17T17:06:39Z", "type": "commit"}, {"oid": "1b673ed1996558c65c6cc2cb42c85deaad78dc74", "url": "https://github.com/MegaMek/mekhq/commit/1b673ed1996558c65c6cc2cb42c85deaad78dc74", "message": "Removing gender overwrites in Utilities", "committedDate": "2020-02-17T17:10:31Z", "type": "commit"}, {"oid": "9c77e4bb8ce34b0e07e3090ba7267ba3db462830", "url": "https://github.com/MegaMek/mekhq/commit/9c77e4bb8ce34b0e07e3090ba7267ba3db462830", "message": "Fixing gender input from MegaMek", "committedDate": "2020-02-18T05:41:09Z", "type": "commit"}, {"oid": "36a49a6b0b071b4b7af4bf8b1d7091ff18d67650", "url": "https://github.com/MegaMek/mekhq/commit/36a49a6b0b071b4b7af4bf8b1d7091ff18d67650", "message": "Personnel Improvements: Fixing merge conflicts", "committedDate": "2020-02-24T00:39:47Z", "type": "commit"}, {"oid": "5ef79c35409e71fac4c86a24e921a8307310ea04", "url": "https://github.com/MegaMek/mekhq/commit/5ef79c35409e71fac4c86a24e921a8307310ea04", "message": "Fixing merge conflicts", "committedDate": "2020-02-24T13:19:12Z", "type": "commit"}, {"oid": "b2b6b11cae139d5a8f5fe3c8245786288470ad60", "url": "https://github.com/MegaMek/mekhq/commit/b2b6b11cae139d5a8f5fe3c8245786288470ad60", "message": "Continuing to remove recruitPersonWithoutId", "committedDate": "2020-02-24T20:07:48Z", "type": "commit"}, {"oid": "dea16869a6011994d13fc7b12815d1fc67b9849d", "url": "https://github.com/MegaMek/mekhq/commit/dea16869a6011994d13fc7b12815d1fc67b9849d", "message": "Reordering personnel methods in campaign.java", "committedDate": "2020-02-24T20:17:04Z", "type": "commit"}, {"oid": "b7b4dba057328acc2cc3d38196f605d871b8def4", "url": "https://github.com/MegaMek/mekhq/commit/b7b4dba057328acc2cc3d38196f605d871b8def4", "message": "Removing recruitPersonWithoutId, as this is now handled in recruitPerson", "committedDate": "2020-02-24T20:28:53Z", "type": "commit"}, {"oid": "7dce07beabb54e51f8172260f56700d733802f81", "url": "https://github.com/MegaMek/mekhq/commit/7dce07beabb54e51f8172260f56700d733802f81", "message": "Switching to ternary for gender decision in the personnel generator", "committedDate": "2020-02-24T20:50:55Z", "type": "commit"}, {"oid": "08b3767bfd80e02d785b6ac6f38359a3655aba40", "url": "https://github.com/MegaMek/mekhq/commit/08b3767bfd80e02d785b6ac6f38359a3655aba40", "message": "Fixing safeSpouse and pregnancy issues", "committedDate": "2020-02-25T16:13:15Z", "type": "commit"}, {"oid": "91362f91ffd7727db978c05582b3a2e5306b1825", "url": "https://github.com/MegaMek/mekhq/commit/91362f91ffd7727db978c05582b3a2e5306b1825", "message": "Fixing merge conflicts", "committedDate": "2020-02-25T18:46:58Z", "type": "commit"}, {"oid": "0fffbce94db9e008bea8e83e014c9d7821e6d168", "url": "https://github.com/MegaMek/mekhq/commit/0fffbce94db9e008bea8e83e014c9d7821e6d168", "message": "Removing import that will cause issues when pushed", "committedDate": "2020-02-25T19:32:24Z", "type": "commit"}, {"oid": "ce8218c9a85d4531e5031ce449ab5ba546eacfe8", "url": "https://github.com/MegaMek/mekhq/commit/ce8218c9a85d4531e5031ce449ab5ba546eacfe8", "message": "Fixing getFullName with null/empty first name", "committedDate": "2020-02-26T01:22:55Z", "type": "commit"}, {"oid": "30a9e1ee019a3a93ead82fbdd192ec19f36c386f", "url": "https://github.com/MegaMek/mekhq/commit/30a9e1ee019a3a93ead82fbdd192ec19f36c386f", "message": "Continuing work on fixing peronnel import", "committedDate": "2020-02-26T01:23:29Z", "type": "commit"}, {"oid": "86e4643661c4ae103049dd68faa20de06a4a6786", "url": "https://github.com/MegaMek/mekhq/commit/86e4643661c4ae103049dd68faa20de06a4a6786", "message": "Fixing merge conflicts", "committedDate": "2020-02-26T16:15:04Z", "type": "commit"}]}