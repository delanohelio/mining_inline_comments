{"pr_number": 1217, "pr_title": "performance improvements to prover frontend", "pr_createdAt": "2020-04-17T21:09:44Z", "pr_url": "https://github.com/kframework/k/pull/1217", "timeline": [{"oid": "d30366afdadf046649e9fb610fde598c63944696", "url": "https://github.com/kframework/k/commit/d30366afdadf046649e9fb610fde598c63944696", "message": "performance improvements to prover frontend", "committedDate": "2020-04-17T21:09:08Z", "type": "commit"}, {"oid": "df19d71599a739d692b13976a9680595149153b3", "url": "https://github.com/kframework/k/commit/df19d71599a739d692b13976a9680595149153b3", "message": "parse configs in sequence after all", "committedDate": "2020-04-20T16:16:04Z", "type": "commit"}, {"oid": "f003f9ac90f858ef749fb25d3d999b9ae6f21343", "url": "https://github.com/kframework/k/commit/f003f9ac90f858ef749fb25d3d999b9ae6f21343", "message": "update tests", "committedDate": "2020-04-21T13:45:19Z", "type": "commit"}, {"oid": "b5c650b92a88b0c9dbe99130fcc624500d75f140", "url": "https://github.com/kframework/k/commit/b5c650b92a88b0c9dbe99130fcc624500d75f140", "message": "add another error message", "committedDate": "2020-04-21T13:45:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MTMyMQ==", "url": "https://github.com/kframework/k/pull/1217#discussion_r412341321", "bodyText": "I don't think I fully understand this, so want to make sure I do.\nWe're grabbing the entryPoint and main modules, as well as any modules they transitively import. We're also grabbing any entryModule (which I guess would be something like the proving module?), but not the transitive imports of the entryModules? And we're specifically only grabbing entryModules which have bubbles which need parsing.\nI guess my questions are:\n\nWhy not get transitive imports of entryModules()?\nWhy not apply the filter for only modules with bubbles across all the modules, not just the entryModules()?", "author": "ehildenb", "createdAt": "2020-04-21T17:15:50Z", "path": "kernel/src/main/java/org/kframework/kompile/DefinitionParsing.java", "diffHunk": "@@ -111,23 +113,36 @@ public DefinitionParsing(\n                 kore,\n                 options.preprocess);\n \n+        if (!def.getModule(mainModule).isDefined()) {\n+          throw KEMException.criticalError(\"Module \" + mainModule + \" does not exist.\");\n+        }\n+        if (!def.getModule(entryPointModule).isDefined()) {\n+          throw KEMException.criticalError(\"Module \" + entryPointModule + \" does not exist.\");\n+        }\n+        Stream<Module> modules = Stream.of(def.getModule(mainModule).get());\n+        modules = Stream.concat(modules, stream(def.getModule(mainModule).get().importedModules()));\n+        modules = Stream.concat(modules, Stream.of(def.getModule(entryPointModule).get()));\n+        modules = Stream.concat(modules, stream(def.getModule(entryPointModule).get().importedModules()));\n+        modules = Stream.concat(modules,\n+                stream(def.entryModules()).filter(m -> !stream(m.sentences()).anyMatch(s -> s instanceof Bubble)));\n+        def = Definition(def.mainModule(), modules.collect(Collections.toSet()), def.att());", "originalCommit": "b5c650b92a88b0c9dbe99130fcc624500d75f140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0NTE4Mw==", "url": "https://github.com/kframework/k/pull/1217#discussion_r412345183", "bodyText": "so, Definition.entryModules is a bit of a misnomer insofar as it contains every module that was included in the K files you parsed. that's why we're not doing a transitive closure there. And specifically we are only grabbing those modules which /don't/ contain bubbles. And the only reason we are doing this is because some of them are required to exist in the parser, like some of the ones in kast.k.", "author": "dwightguth", "createdAt": "2020-04-21T17:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MTMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM1NjYyNA==", "url": "https://github.com/kframework/k/pull/1217#discussion_r412356624", "bodyText": "Ok, so it's an over-approximation of the modules needed to do parsing.", "author": "ehildenb", "createdAt": "2020-04-21T17:37:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MTMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NTQyMw==", "url": "https://github.com/kframework/k/pull/1217#discussion_r413995423", "bodyText": "I recommend a comment explaining the above logic. Lack of comments in such places is a reason why code is hard to maintain.\nI don't see any advantage to build a Stream then to convert it to Set. You should create a Set from start. Code will look simpler. If you want the preserve the iterating order then use LinkedHashSet.", "author": "denis-bogdanas", "createdAt": "2020-04-23T17:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MTMyMQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "f2038003f67ad5427b74feb24d065b815d2481fe", "url": "https://github.com/kframework/k/commit/f2038003f67ad5427b74feb24d065b815d2481fe", "message": "Merge branch 'master' into kprove", "committedDate": "2020-04-21T23:51:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5Nzg5OA==", "url": "https://github.com/kframework/k/pull/1217#discussion_r413997898", "bodyText": "Please add comments where you see fit.", "author": "denis-bogdanas", "createdAt": "2020-04-23T17:45:01Z", "path": "kernel/src/main/java/org/kframework/kompile/DefinitionParsing.java", "diffHunk": "@@ -247,15 +260,90 @@ protected Definition resolveConfigBubbles(Definition definition, Module defaultC\n         return errors;\n     }\n \n-    public Definition resolveNonConfigBubbles(Definition defWithConfig, RuleGrammarGenerator gen) {\n-        Module ruleParserModule = gen.getRuleGrammar(defWithConfig.mainModule());\n+    public Definition resolveNonConfigBubbles(Definition defWithConfig, Module mainModule, RuleGrammarGenerator gen) {\n+        Module ruleParserModule = gen.getRuleGrammar(mainModule);\n         ParseCache cache = loadCache(ruleParserModule);\n         try (ParseInModule parser = RuleGrammarGenerator.getCombinedGrammar(cache.getModule(), isStrict, profileRules, files)) {\n+            parser.getScanner();\n             Map<String, Module> parsed = defWithConfig.parMap(m -> this.resolveNonConfigBubbles(m, parser.getScanner(), gen));\n             return DefinitionTransformer.from(m -> Module(m.name(), m.imports(), parsed.get(m.name()).localSentences(), m.att()), \"parsing rules\").apply(defWithConfig);\n         }\n     }\n \n+    private Definition resolveConfigBubbles(Definition def, RuleGrammarGenerator gen) {\n+      return DefinitionTransformer.from(m -> resolveConfigBubbles(def, m, gen), \"parsing configs\").apply(def);\n+    }\n+\n+    private Module resolveConfigBubbles(Definition def, Module inputModule, RuleGrammarGenerator gen) {\n+        if (stream(inputModule.localSentences())\n+                .filter(s -> s instanceof Bubble)\n+                .map(b -> (Bubble) b)\n+                .filter(b -> b.sentenceType().equals(\"config\")).count() == 0)\n+            return inputModule;\n+\n+\n+        Set<Sentence> importedConfigurationSortsSubsortedToCell = stream(inputModule.productions())\n+                .filter(p -> p.att().contains(\"cell\"))\n+                .map(p -> Production(Seq(), Sorts.Cell(), Seq(NonTerminal(p.sort())))).collect(Collections.toSet());\n+\n+        Module module = Module(inputModule.name(), (Set<Module>) inputModule.imports(),\n+                (Set<Sentence>) inputModule.localSentences().$bar(importedConfigurationSortsSubsortedToCell),\n+                inputModule.att());\n+\n+        Set<Sentence> configDeclProductions;\n+        ParseCache cache = loadCache(gen.getConfigGrammar(module));\n+        try (ParseInModule parser = RuleGrammarGenerator.getCombinedGrammar(cache.getModule(), isStrict, profileRules, files)) {\n+             parser.getScanner();\n+             configDeclProductions = stream(module.localSentences())\n+                    .parallel()\n+                    .filter(s -> s instanceof Bubble)\n+                    .map(b -> (Bubble) b)\n+                    .filter(b -> b.sentenceType().equals(\"config\"))\n+                    .flatMap(b -> performParse(cache.getCache(), parser, parser.getScanner(), b))\n+                    .map(contents -> {\n+                        KApply configContents = (KApply) contents;\n+                        List<K> items = configContents.klist().items();\n+                        switch (configContents.klabel().name()) {\n+                        case \"#ruleNoConditions\":\n+                            return Configuration(items.get(0), BooleanUtils.TRUE, configContents.att());\n+                        case \"#ruleEnsures\":\n+                            return Configuration(items.get(0), items.get(1), configContents.att());\n+                        default:\n+                            throw KEMException.compilerError(\"Illegal configuration with requires clause detected.\", configContents);\n+                        }\n+                    })\n+                    .flatMap(\n+                            configDecl -> stream(GenerateSentencesFromConfigDecl.gen(configDecl.body(), configDecl.ensures(), configDecl.att(), parser.getExtensionModule(), kore)))\n+                    .collect(Collections.toSet());\n+        }\n+\n+        Set<Sentence> configDeclSyntax = stream(configDeclProductions).filter(Sentence::isSyntax).collect(Collections.toSet());\n+        Set<Sentence> configDeclRules = stream(configDeclProductions).filter(Sentence::isNonSyntax).collect(Collections.toSet());\n+\n+        if (module.name().endsWith(Import.IMPORTS_SYNTAX_SUFFIX)) {\n+            Module mapModule;\n+            if (def.getModule(\"MAP$SYNTAX\").isDefined()) {\n+                mapModule = def.getModule(\"MAP$SYNTAX\").get();\n+            } else {\n+                throw KEMException.compilerError(\"Module Map must be visible at the configuration declaration, in module \" + module.name());\n+            }\n+            return Module(module.name(), (Set<Module>) module.imports().$bar(Set(mapModule)),\n+                    (Set<Sentence>) module.localSentences().$bar(configDeclSyntax),\n+                    module.att());\n+        } else {\n+            Module mapModule;\n+            if (def.getModule(\"MAP\").isDefined()) {\n+                mapModule = def.getModule(\"MAP\").get();\n+            } else {\n+                throw KEMException.compilerError(\"Module Map must be visible at the configuration declaration, in module \" + module.name());\n+            }\n+            return Module(module.name(), (Set<Module>) module.imports().$bar(Set(mapModule)),\n+                    (Set<Sentence>) module.localSentences().$bar(configDeclRules),\n+                    module.att());\n+        }\n+\n+    }\n+", "originalCommit": "f2038003f67ad5427b74feb24d065b815d2481fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}