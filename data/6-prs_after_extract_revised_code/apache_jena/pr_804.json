{"pr_number": 804, "pr_title": "JENA-1974: G, a library of functions for working with Graph.", "pr_createdAt": "2020-10-01T13:20:10Z", "pr_url": "https://github.com/apache/jena/pull/804", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MzAxOA==", "url": "https://github.com/apache/jena/pull/804#discussion_r498273018", "bodyText": "Could be more efficient without counting all triples, e.g.\ntry (ExtendedIterator<Triple> it = g.find(s, p, null) {\n  if (!it.hasNext()) {\n     return false;\n  }\n  it.next();\n  return !it.hasNext();\n}", "author": "strangepleasures", "createdAt": "2020-10-01T14:08:30Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/other/G.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.riot.other;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import org.apache.jena.atlas.iterator.Iter;\n+import org.apache.jena.graph.Graph;\n+import org.apache.jena.graph.GraphUtil;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.riot.out.NodeFmtLib;\n+//import org.apache.jena.shacl.lib.GN;\n+//import org.apache.jena.shacl.lib.RDFDataException;\n+//import org.apache.jena.shacl.lib.Transitive;\n+//import org.apache.jena.shacl.sys.C;\n+import org.apache.jena.sparql.core.Quad;\n+import org.apache.jena.sparql.graph.NodeConst;\n+import org.apache.jena.sparql.util.graph.GNode;\n+import org.apache.jena.sparql.util.graph.GraphList;\n+import org.apache.jena.util.iterator.ExtendedIterator;\n+\n+/** A library of functions for working with {@link Graph}. */\n+public class G {\n+    private G() {}\n+    private static Node rdfType = NodeConst.nodeRDFType;\n+\n+    /** Return the subject of a triple, or null if the triple is null. */\n+    public static Node subject(Triple triple) {\n+        return triple == null ? null : triple.getSubject();\n+    }\n+\n+    /** Return the predicate of a triple, or null if the triple is null. */\n+    public static Node predicate(Triple triple) {\n+        return triple == null ? null : triple.getPredicate();\n+    }\n+\n+    /** Return the object of a triple, or null if the triple is null. */\n+    public static Node object(Triple triple) {\n+        return triple == null ? null : triple.getObject();\n+    }\n+\n+    // ---- Node filter tests.\n+    public static boolean isURI(Node n)         { return n != null && n.isURI(); }\n+    public static boolean isBlank(Node n)       { return n != null && n.isBlank(); }\n+    public static boolean isLiteral(Node n)     { return n != null && n.isLiteral(); }\n+    public static boolean isResource(Node n)    { return n != null && (n.isURI()||n.isBlank()); }\n+\n+    /** Convert null to Node.ANY */\n+    public static Node nullAsAny(Node x) { return nullAsDft(x, Node.ANY) ; }\n+\n+    /** Convert null to some default Node */\n+    public static Node nullAsDft(Node x, Node dft) { return x==null ? dft : x ; }\n+\n+    /** Does the graph match the s/p/o pattern? */ \n+    public static boolean contains(Graph g, Node s, Node p, Node o) {\n+        return g.contains(s, p, o);\n+    }\n+    \n+    /** Does the graph use the node anywhere as a subject, predicate or object? */\n+    public static boolean containsNode(Graph graph, Node node) {\n+        return GraphUtil.containsNode(graph, node);\n+//        return\n+//            contains(graph, node, Node.ANY, Node.ANY) ||\n+//            contains(graph, Node.ANY, Node.ANY, node) ||\n+//            contains(graph, Node.ANY, node, Node.ANY) ;\n+    }\n+    \n+    /** Test whether the node has the type or is rdfs:subclassOf. */\n+    public static boolean isOfType(Graph graph, Node x, Node type) {\n+        Objects.requireNonNull(x, \"Subject\");\n+        Objects.requireNonNull(type, \"Type\");\n+        List<Node> allClasses = listSubClasses(graph, type);\n+        for ( Node c : allClasses ) {\n+            if ( hasType(graph, x, c) )\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /** Does the node x have the given type (non-RDFS - no rdfs:subclassOf considered)? */ \n+    public static boolean hasType(Graph graph, Node x, Node type) {\n+        Objects.requireNonNull(x, \"Subject\");\n+        Objects.requireNonNull(type, \"Type\");\n+        return contains(graph, x, NodeConst.nodeRDFType, type);\n+    }\n+\n+    //---- get/list/iter\n+\n+    /** Does node {@code s} have property {@code p} in graph {@code g}? */\n+    public static boolean hasProperty(Graph g, Node s, Node p) {\n+        return g.contains(s, p, null);\n+    }\n+\n+    /** Contains exactly one. */\n+    public static boolean containsOne(Graph g, Node s, Node p, Node o) {\n+        return g.contains(s, p, o) && Iter.count(g.find(s,p,null)) == 1;", "originalCommit": "2e29a2e34a35bf63f1c574596abfdc658db3f529", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI5ODYzMQ==", "url": "https://github.com/apache/jena/pull/804#discussion_r498298631", "bodyText": "Agreed.", "author": "afs", "createdAt": "2020-10-01T14:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MzAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxMTMwMA==", "url": "https://github.com/apache/jena/pull/804#discussion_r498311300", "bodyText": "Actually, try-with-resources wouldn't work here as ClosableIterator doesn't implement AutoCloseable. It would be quite convenient and shouldn't break anything. public interface ClosableIterator<T> extends Iterator<T>,  AutoCloseable", "author": "strangepleasures", "createdAt": "2020-10-01T14:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MzAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMyNzE1Nw==", "url": "https://github.com/apache/jena/pull/804#discussion_r498327157", "bodyText": "See https://issues.apache.org/jira/browse/JENA-1601...", "author": "ajs6f", "createdAt": "2020-10-01T15:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MzAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1OTIwMg==", "url": "https://github.com/apache/jena/pull/804#discussion_r498459202", "bodyText": "Ah great!", "author": "strangepleasures", "createdAt": "2020-10-01T19:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MzAxOA=="}], "type": "inlineReview", "revised_code": {"commit": "5b2ee120c0776dac876f0b9cbcb781202c1a0d83", "chunk": "diff --git a/jena-arq/src/main/java/org/apache/jena/riot/other/G.java b/jena-arq/src/main/java/org/apache/jena/riot/other/G.java\nindex 0004fa5346..1bbde682fe 100644\n--- a/jena-arq/src/main/java/org/apache/jena/riot/other/G.java\n+++ b/jena-arq/src/main/java/org/apache/jena/riot/other/G.java\n\n@@ -22,10 +22,7 @@ import java.util.*;\n import java.util.function.Consumer;\n \n import org.apache.jena.atlas.iterator.Iter;\n-import org.apache.jena.graph.Graph;\n-import org.apache.jena.graph.GraphUtil;\n-import org.apache.jena.graph.Node;\n-import org.apache.jena.graph.Triple;\n+import org.apache.jena.graph.*;\n import org.apache.jena.riot.out.NodeFmtLib;\n //import org.apache.jena.shacl.lib.GN;\n //import org.apache.jena.shacl.lib.RDFDataException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3NTU5MA==", "url": "https://github.com/apache/jena/pull/804#discussion_r498275590", "bodyText": "How about isNodeTriple?", "author": "strangepleasures", "createdAt": "2020-10-01T14:11:56Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/other/G.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.riot.other;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import org.apache.jena.atlas.iterator.Iter;\n+import org.apache.jena.graph.Graph;\n+import org.apache.jena.graph.GraphUtil;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.riot.out.NodeFmtLib;\n+//import org.apache.jena.shacl.lib.GN;\n+//import org.apache.jena.shacl.lib.RDFDataException;\n+//import org.apache.jena.shacl.lib.Transitive;\n+//import org.apache.jena.shacl.sys.C;\n+import org.apache.jena.sparql.core.Quad;\n+import org.apache.jena.sparql.graph.NodeConst;\n+import org.apache.jena.sparql.util.graph.GNode;\n+import org.apache.jena.sparql.util.graph.GraphList;\n+import org.apache.jena.util.iterator.ExtendedIterator;\n+\n+/** A library of functions for working with {@link Graph}. */\n+public class G {\n+    private G() {}\n+    private static Node rdfType = NodeConst.nodeRDFType;\n+\n+    /** Return the subject of a triple, or null if the triple is null. */\n+    public static Node subject(Triple triple) {\n+        return triple == null ? null : triple.getSubject();\n+    }\n+\n+    /** Return the predicate of a triple, or null if the triple is null. */\n+    public static Node predicate(Triple triple) {\n+        return triple == null ? null : triple.getPredicate();\n+    }\n+\n+    /** Return the object of a triple, or null if the triple is null. */\n+    public static Node object(Triple triple) {\n+        return triple == null ? null : triple.getObject();\n+    }\n+\n+    // ---- Node filter tests.\n+    public static boolean isURI(Node n)         { return n != null && n.isURI(); }\n+    public static boolean isBlank(Node n)       { return n != null && n.isBlank(); }\n+    public static boolean isLiteral(Node n)     { return n != null && n.isLiteral(); }\n+    public static boolean isResource(Node n)    { return n != null && (n.isURI()||n.isBlank()); }\n+", "originalCommit": "2e29a2e34a35bf63f1c574596abfdc658db3f529", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM0NjIwMQ==", "url": "https://github.com/apache/jena/pull/804#discussion_r498346201", "bodyText": "Good point. You can see that the code is dated!\n(and isNodeGraph even if it isn't current used)", "author": "afs", "createdAt": "2020-10-01T15:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3NTU5MA=="}], "type": "inlineReview", "revised_code": {"commit": "5b2ee120c0776dac876f0b9cbcb781202c1a0d83", "chunk": "diff --git a/jena-arq/src/main/java/org/apache/jena/riot/other/G.java b/jena-arq/src/main/java/org/apache/jena/riot/other/G.java\nindex 0004fa5346..1bbde682fe 100644\n--- a/jena-arq/src/main/java/org/apache/jena/riot/other/G.java\n+++ b/jena-arq/src/main/java/org/apache/jena/riot/other/G.java\n\n@@ -22,10 +22,7 @@ import java.util.*;\n import java.util.function.Consumer;\n \n import org.apache.jena.atlas.iterator.Iter;\n-import org.apache.jena.graph.Graph;\n-import org.apache.jena.graph.GraphUtil;\n-import org.apache.jena.graph.Node;\n-import org.apache.jena.graph.Triple;\n+import org.apache.jena.graph.*;\n import org.apache.jena.riot.out.NodeFmtLib;\n //import org.apache.jena.shacl.lib.GN;\n //import org.apache.jena.shacl.lib.RDFDataException;\n"}}, {"oid": "5b2ee120c0776dac876f0b9cbcb781202c1a0d83", "url": "https://github.com/apache/jena/commit/5b2ee120c0776dac876f0b9cbcb781202c1a0d83", "message": "Function library for working with graphs", "committedDate": "2020-10-01T14:50:06Z", "type": "forcePushed"}, {"oid": "b13c4c797f870cca9005821e0eca4c05e9ec5e1f", "url": "https://github.com/apache/jena/commit/b13c4c797f870cca9005821e0eca4c05e9ec5e1f", "message": "Spelling correction.", "committedDate": "2020-10-04T14:20:52Z", "type": "commit"}, {"oid": "7e02e499317dd05626d2ef15eb9dd7675a59c4a1", "url": "https://github.com/apache/jena/commit/7e02e499317dd05626d2ef15eb9dd7675a59c4a1", "message": "Correct whitespace in compact syntax output of [...]", "committedDate": "2020-10-04T14:20:52Z", "type": "commit"}, {"oid": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "url": "https://github.com/apache/jena/commit/b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "message": "Mark iterator to stream as immutable", "committedDate": "2020-10-04T19:08:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMxNzA5NA==", "url": "https://github.com/apache/jena/pull/804#discussion_r499317094", "bodyText": "s/tripel/triple", "author": "kinow", "createdAt": "2020-10-05T02:04:08Z", "path": "jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java", "diffHunk": "@@ -91,6 +94,27 @@ public static Constraint parseSparqlConstraint(Graph shapesGraph, Node shape, No\n             throw new ShaclParseException(\"SPARQL parse error: \"+ex.getMessage()+\"\\n\"+qs);\n         }\n     }\n+    \n+    /**\n+     * Test for zero or one occurrences of a tripel pattern that is expected to be   ", "originalCommit": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b552757b224a43926b9ffeb5e86efca206c57ecc", "chunk": "diff --git a/jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java b/jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java\nindex f75dc436cd..0e38bee115 100644\n--- a/jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java\n+++ b/jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java\n\n@@ -94,27 +91,6 @@ public class SparqlConstraints {\n             throw new ShaclParseException(\"SPARQL parse error: \"+ex.getMessage()+\"\\n\"+qs);\n         }\n     }\n-    \n-    /**\n-     * Test for zero or one occurrences of a tripel pattern that is expected to be   \n-     * Returns false for zero, true for one. \n-     * Throws an exception on two or more.\n-     */\n-    private static boolean absentOrOne(Graph g, Node s, Node p, Node o) {\n-        ExtendedIterator<Triple> iter = G.find(g, s, p, null);\n-        try {\n-            if ( ! iter.hasNext() )\n-                return false;\n-            iter.next();\n-            if ( ! iter.hasNext() )\n-                return true;\n-            long x = Iter.count(G.find(g, s, p, null));\n-            throw new ShaclParseException(\"More then one (\" + x + \") of \" + String.format(\"(%s %s %s)\", s, p, o));\n-        }\n-        finally { iter.close(); }\n-    }\n-\n-\n \n     public static String prefixes(Graph shapesGraph, Node sparqlNode) {\n         // XXX Ignores sparqlNode ATM\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMxNzEyOA==", "url": "https://github.com/apache/jena/pull/804#discussion_r499317128", "bodyText": "s/then/than", "author": "kinow", "createdAt": "2020-10-05T02:04:22Z", "path": "jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java", "diffHunk": "@@ -91,6 +94,27 @@ public static Constraint parseSparqlConstraint(Graph shapesGraph, Node shape, No\n             throw new ShaclParseException(\"SPARQL parse error: \"+ex.getMessage()+\"\\n\"+qs);\n         }\n     }\n+    \n+    /**\n+     * Test for zero or one occurrences of a tripel pattern that is expected to be   \n+     * Returns false for zero, true for one. \n+     * Throws an exception on two or more.\n+     */\n+    private static boolean absentOrOne(Graph g, Node s, Node p, Node o) {\n+        ExtendedIterator<Triple> iter = G.find(g, s, p, null);\n+        try {\n+            if ( ! iter.hasNext() )\n+                return false;\n+            iter.next();\n+            if ( ! iter.hasNext() )\n+                return true;\n+            long x = Iter.count(G.find(g, s, p, null));\n+            throw new ShaclParseException(\"More then one (\" + x + \") of \" + String.format(\"(%s %s %s)\", s, p, o));", "originalCommit": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MTUyMw==", "url": "https://github.com/apache/jena/pull/804#discussion_r499551523", "bodyText": "Done", "author": "afs", "createdAt": "2020-10-05T12:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMxNzEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "b552757b224a43926b9ffeb5e86efca206c57ecc", "chunk": "diff --git a/jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java b/jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java\nindex f75dc436cd..0e38bee115 100644\n--- a/jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java\n+++ b/jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java\n\n@@ -94,27 +91,6 @@ public class SparqlConstraints {\n             throw new ShaclParseException(\"SPARQL parse error: \"+ex.getMessage()+\"\\n\"+qs);\n         }\n     }\n-    \n-    /**\n-     * Test for zero or one occurrences of a tripel pattern that is expected to be   \n-     * Returns false for zero, true for one. \n-     * Throws an exception on two or more.\n-     */\n-    private static boolean absentOrOne(Graph g, Node s, Node p, Node o) {\n-        ExtendedIterator<Triple> iter = G.find(g, s, p, null);\n-        try {\n-            if ( ! iter.hasNext() )\n-                return false;\n-            iter.next();\n-            if ( ! iter.hasNext() )\n-                return true;\n-            long x = Iter.count(G.find(g, s, p, null));\n-            throw new ShaclParseException(\"More then one (\" + x + \") of \" + String.format(\"(%s %s %s)\", s, p, o));\n-        }\n-        finally { iter.close(); }\n-    }\n-\n-\n \n     public static String prefixes(Graph shapesGraph, Node sparqlNode) {\n         // XXX Ignores sparqlNode ATM\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MDkyNg==", "url": "https://github.com/apache/jena/pull/804#discussion_r499360926", "bodyText": "Do we have to close iter?", "author": "kinow", "createdAt": "2020-10-05T06:03:44Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/other/G.java", "diffHunk": "@@ -0,0 +1,669 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.riot.other;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import org.apache.jena.atlas.iterator.Iter;\n+import org.apache.jena.graph.*;\n+import org.apache.jena.riot.out.NodeFmtLib;\n+import org.apache.jena.sparql.core.Quad;\n+import org.apache.jena.sparql.graph.NodeConst;\n+import org.apache.jena.sparql.util.graph.GNode;\n+import org.apache.jena.sparql.util.graph.GraphList;\n+import org.apache.jena.util.iterator.ExtendedIterator;\n+\n+/** A library of functions for working with {@link Graph}. */\n+public class G {\n+    private G() {}\n+\n+    private static Node rdfType = NodeConst.nodeRDFType;\n+\n+    /** Return the subject of a triple, or null if the triple is null. */\n+    public static Node subject(Triple triple) {\n+        return triple == null ? null : triple.getSubject();\n+    }\n+\n+    /** Return the predicate of a triple, or null if the triple is null. */\n+    public static Node predicate(Triple triple) {\n+        return triple == null ? null : triple.getPredicate();\n+    }\n+\n+    /** Return the object of a triple, or null if the triple is null. */\n+    public static Node object(Triple triple) {\n+        return triple == null ? null : triple.getObject();\n+    }\n+\n+    // ---- Node filter tests.\n+    public static boolean isURI(Node n)         { return n != null && n.isURI(); }\n+    public static boolean isBlank(Node n)       { return n != null && n.isBlank(); }\n+    public static boolean isLiteral(Node n)     { return n != null && n.isLiteral(); }\n+    public static boolean isResource(Node n)    { return n != null && (n.isURI()||n.isBlank()); }\n+    public static boolean isNodeTriple(Node n)  { return n != null && n.isNodeTriple(); }\n+    public static boolean isNodeGraph(Node n)   { return n != null && n.isNodeGraph(); }\n+\n+    /** Convert null to Node.ANY */\n+    public static Node nullAsAny(Node x) { return nullAsDft(x, Node.ANY) ; }\n+\n+    /** Convert null to some default Node */\n+    public static Node nullAsDft(Node x, Node dft) { return x==null ? dft : x ; }\n+\n+    /** Does the graph match the s/p/o pattern? */\n+    public static boolean contains(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return graph.contains(subject, predicate, object);\n+    }\n+\n+    /** Does the graph use the node anywhere as a subject, predicate or object? */\n+    public static boolean containsNode(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        return GraphUtil.containsNode(graph, node);\n+//        return\n+//            contains(graph, node, Node.ANY, Node.ANY) ||\n+//            contains(graph, Node.ANY, Node.ANY, node) ||\n+//            contains(graph, Node.ANY, node, Node.ANY) ;\n+    }\n+\n+    /** Test whether the node has the type or is rdfs:subclassOf. */\n+    public static boolean isOfType(Graph graph, Node node, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> allClasses = listSubClasses(graph, type);\n+        for ( Node c : allClasses ) {\n+            if ( hasType(graph, node, c) )\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /** Does the node x have the given type (non-RDFS - no rdfs:subclassOf considered)? */\n+    public static boolean hasType(Graph graph, Node node, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        Objects.requireNonNull(type, \"type\");\n+        return contains(graph, node, NodeConst.nodeRDFType, type);\n+    }\n+\n+    //---- get/list/iter\n+\n+    /** Does node {@code s} have property {@code p} in graph {@code g}? */\n+    public static boolean hasProperty(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return graph.contains(subject, predicate, null);\n+    }\n+\n+    /** Contains exactly one. */\n+    public static boolean containsOne(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(subject, predicate, object);\n+        try {\n+            if ( ! iter.hasNext() )\n+                return false;\n+            iter.next();\n+            return !iter.hasNext();\n+        } finally { iter.close(); }\n+    }\n+\n+    /**\n+     * Get object, given subject and predicate. Returns one (non-deterministically) or null.\n+     * See also {@link #getOneSP} and {@link #getZeroOrOneSP}.\n+     */\n+    public static Node getSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(first(find(graph, subject, predicate, Node.ANY)));\n+    }\n+\n+    // --- Graph walking.\n+\n+    /**\n+     * Get object for subject-predicate. Must be exactly one object; exception\n+     * {@linkplain RDFDataException} thrown when none or more than one.\n+     */\n+    public static Node getOneSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(findUnique(graph, subject, predicate, Node.ANY));\n+    }\n+\n+    /**\n+     * Get object for subject-predicate. Return null for none, object for one, and\n+     * exception {@linkplain RDFDataException} if more than one.\n+     */\n+    public static Node getZeroOrOneSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(findZeroOne(graph, subject, predicate, Node.ANY));\n+    }\n+\n+    /**\n+     *  Get the subject, given predicate and object. Returns one (non-deterministically) or null.\n+     *  See also {@link #getOnePO} and {@link #getZeroOrOnePO}.\n+     */\n+    public static Node getPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(first(find(graph, Node.ANY, predicate, object)));\n+    }\n+\n+    /**\n+     * Get the subject for predicate-object. Must be exactly one subject; exception\n+     * {@linkplain RDFDataException} thrown when none or more than one.\n+     */\n+    public static Node getOnePO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return subject(findUnique(graph, Node.ANY, predicate, object));\n+    }\n+\n+    /**\n+     * Get the subject for predicate-object. Return null for none, subject for one, throw\n+     * exception {@linkplain RDFDataException} if more than one.\n+     */\n+    public static Node getZeroOrOnePO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return subject(findZeroOne(graph, Node.ANY, predicate, object));\n+    }\n+\n+    /**\n+     * Get triple if there is exactly one to match the s/p/o, else throw\n+     * {@linkplain RDFDataException}.\n+     */\n+    public static Triple getOne(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return findUnique(graph, subject, predicate, object);\n+    }\n+\n+    /**\n+     * Get triple if there is exactly one to match the s/p/o; return null if none;\n+     * throw {@linkplain RDFDataException} if more than one.\n+     */\n+    public static Triple getZeroOrOne(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return findZeroOne(graph, subject, predicate, object);\n+    }\n+\n+    // ---- Multiple matches.\n+\n+    /**\n+     * {@link ExtendedIterator} of objects where the triple matches for subject and\n+     * predicate (which can be wildcards). The {@link ExtendedIterator} must be fully\n+     * used or explicitly closed. It is preferable use {@link #listSP} which handles\n+     * this condition.\n+     */\n+    public static ExtendedIterator<Node> iterSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, subject, predicate, null).mapWith(Triple::getObject);\n+    }\n+\n+    /**\n+     * List of objects matching the subject-predicate (which can be wildcards).\n+     */\n+    public static List<Node> listSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return iterSP(graph, subject, predicate).toList();\n+    }\n+\n+    /** Count matches of subject-predicate (which can be wildcards). */\n+    public static long countSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return Iter.count(iterSP(graph, subject, predicate));\n+    }\n+\n+    /**\n+     * {@link ExtendedIterator} of subjects where the triple matches for predicate\n+     * and object (which can be wildcards). The {@link ExtendedIterator} must be\n+     * fully used or explicitly closed. It is preferable use {@link #listSP} which\n+     * handles this condition.\n+     */\n+    public static ExtendedIterator<Node> iterPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, null, predicate, object).mapWith(Triple::getSubject);\n+    }\n+\n+    /**\n+     * List of subjects matching the predicate-object (which can be wildcards).\n+     */\n+    public static List<Node> listPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return iterPO(graph, predicate, object).toList();\n+    }\n+\n+    /** Count matches of predicate-object (which can be wildcards). */\n+    public static long countPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return Iter.count(iterPO(graph, predicate, object));\n+    }\n+\n+    // DISTINCT means these are space using.\n+\n+    /** List the subjects in a graph (no duplicates) */\n+    public static Iterator<Node> listSubjects(Graph graph) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n+        return Iter.iter(iter).map(Triple::getSubject).distinct();\n+    }\n+\n+    /** List the predicates in a graph (no duplicates) */\n+    public static Iterator<Node> listPredicates(Graph graph) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n+        return Iter.iter(iter).map(Triple::getPredicate).distinct();\n+    }\n+\n+    /** List the objects in a graph (no duplicates) */\n+    public static Iterator<Node> listObjects(Graph graph) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n+        return Iter.iter(iter).map(Triple::getObject).distinct();\n+    }\n+\n+    // ---- rdf:type, not RDFS\n+\n+    /**\n+     * List the subjects with exactly {@code type}.\n+     * See {@link #listNodesOfTypeRDFS(Graph, Node)}, which does include sub-classes.\n+     */\n+    public static List<Node> nodesOfTypeAsList(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        return find(graph, null, rdfType, type).mapWith(Triple::getSubject).toList();\n+    }\n+\n+    /**\n+     * List the types of a node/subject.\n+     * See {@link #listTypesOfNodeRDFS(Graph, Node)} , which does include super-classes.\n+     */\n+    public static List<Node> typesOfNodeAsList(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        return find(graph, node, rdfType, null).mapWith(Triple::getObject).toList();\n+    }\n+\n+    /**\n+     * Set of nodes with exactly {@code type}.\n+     * See {@link #allNodesOfTypeRDFS(Graph, Node)}, which does include sub-classes.\n+     */\n+    public static Set<Node> nodesOfTypeAsSet(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        return find(graph, null, rdfType, type).mapWith(Triple::getSubject).toSet();\n+    }\n+\n+    /**\n+     * Set of exact types of a node See {@link #allTypesOfNodeRDFS(Graph, Node)},\n+     * which does include super-classes.\n+     */\n+    public static Set<Node> typesOfNodeAsSet(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        return find(graph, node, rdfType, null).mapWith(Triple::getObject).toSet();\n+    }\n+\n+    // ---- RDF list.\n+\n+    /** Return a java list for an RDF list of data. */\n+    public static List<Node> rdfList(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        GNode gNode = GNode.create(graph, node);\n+        return GraphList.members(gNode);\n+    }\n+\n+    // Sub-class / super-class\n+\n+    /**\n+     * List the subclasses of a type, including itself.\n+     * This is <tt>?x rdfs:subClassOf* type</tt>.\n+     * The list does not contain duplicates.\n+     */\n+    public static List<Node> listSubClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> acc = new ArrayList<>();\n+        // Subclasses are follow rdfs:subClassOf in reverse - object to subject.\n+        // Transitive.transitive is \"visit once\".\n+        Transitive.transitiveInc(graph, false, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    /**\n+     * List the super-classes of a type, including itself.\n+     * This is <tt>type rdfs:subClassOf* ?x</tt>.\n+     * The list does not contain duplicates.\n+     */\n+    public static List<Node> listSuperClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> acc = new ArrayList<>();\n+        // Super classes are \"follow rdfs:subclassOf\" - subject to object.\n+        // Transitive.transitive is \"visit once\".\n+        Transitive.transitiveInc(graph, true, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    /**\n+     * Set of the subclasses of a type, including itself.\n+     * This is <tt>?x rdfs:subClassOf* type</tt>.\n+     */\n+    public static Set<Node> subClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        Set<Node> acc = new HashSet<>();\n+        // Subclasses are follow rdfs:subclassOf in reverse - object to subject.\n+        Transitive.transitiveInc(graph, false, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    /**\n+     * Set of the subclasses of a type, including itself.\n+     * This is <tt>?x rdfs:subClassOf* type</tt>.\n+     */\n+    public static Set<Node> superClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        Set<Node> acc = new HashSet<>();\n+        Transitive.transitiveInc(graph, true, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    // ---- RDFS\n+\n+    /**\n+     * List the types of a node, following rdfs:subClassOf for super classes.\n+     */\n+    public static List<Node> listTypesOfNodeRDFS(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        List<Node> types = typesOfNodeAsList(graph, node);\n+        List<Node> types2 = new ArrayList<>();\n+        types.forEach(t->{\n+            List<Node> subClasses = listSuperClasses(graph, t);\n+            types2.addAll(subClasses);\n+        });\n+        return types2;\n+    }\n+\n+    /**\n+     * List all the nodes of type, including node of sub-classes.\n+     */\n+    public static List<Node> listNodesOfTypeRDFS(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> types = listSubClasses(graph, type);\n+        List<Node> nodes = new ArrayList<>();\n+        accNodesOfTypes(nodes, graph, types);\n+        return nodes;\n+    }\n+\n+    /**\n+     * List all the types of a node, including super-classes.\n+     */\n+    public static Set<Node> allTypesOfNodeRDFS(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        Set<Node> types = typesOfNodeAsSet(graph, node);\n+        Set<Node> types2 = new HashSet<>();\n+        types.forEach(t->{\n+            List<Node> subClasses = listSuperClasses(graph, t);\n+            types2.addAll(subClasses);\n+        });\n+        return types2;\n+    }\n+\n+    /** List all the node of type, including considering rdfs:subClassOf */\n+    public static Set<Node> allNodesOfTypeRDFS(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        Set<Node> types = subClasses(graph, type);\n+        Set<Node> nodes = new HashSet<>();\n+        accNodesOfTypes(nodes, graph, types);\n+        return nodes;\n+    }\n+\n+    /** For each type, find nodes of that type and accumulate */\n+    private static void accNodesOfTypes(Collection<Node> acc, Graph graph, Collection<Node> types) {\n+        types.forEach(t->\n+            find(graph, null, rdfType, t).mapWith(Triple::getSubject).forEach(acc::add)\n+            );\n+    }\n+\n+    /** Return a set of all objects for subject-predicate */\n+    public static Set<Node> allSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, subject, predicate, null).mapWith(Triple::getObject).toSet();\n+    }\n+\n+    /** Return a set of all subjects for predicate-object */\n+    public static Set<Node> allPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, null, predicate, object).mapWith(Triple::getSubject).toSet();\n+    }\n+\n+    // --- Graph walking.\n+\n+    /** Count the number of in-arc to an object */\n+    public static long objectConnectiveness(Graph graph, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(object, \"object\");\n+        return Iter.count(find(graph, null, null, object));\n+    }\n+\n+    /** Test whether an object has exactly one in-arc. */\n+    public static boolean oneConnected(Graph graph, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(object, \"object\");\n+        ExtendedIterator<Triple> iter = find(graph, null, null, object);\n+        if ( ! iter.hasNext() )\n+            // Zero.\n+            return false;\n+        iter.next();\n+        if ( iter.hasNext() )\n+            // more than one\n+            return false;\n+        return true;", "originalCommit": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MzU1NQ==", "url": "https://github.com/apache/jena/pull/804#discussion_r499553555", "bodyText": "Yes. (It is also most the same as findUnique)\nClosing unfinished extended iterators is contract even if many (most?) apps don't care or attend to the detail. In fact, plain in-memory, TDB1, TDB2 and TIM don't rely on this. But as a library it ought to get it right!", "author": "afs", "createdAt": "2020-10-05T12:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MDkyNg=="}], "type": "inlineReview", "revised_code": {"commit": "b552757b224a43926b9ffeb5e86efca206c57ecc", "chunk": "diff --git a/jena-arq/src/main/java/org/apache/jena/riot/other/G.java b/jena-arq/src/main/java/org/apache/jena/riot/other/G.java\ndeleted file mode 100644\nindex 2be93fad9f..0000000000\n--- a/jena-arq/src/main/java/org/apache/jena/riot/other/G.java\n+++ /dev/null\n\n@@ -1,669 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.jena.riot.other;\n-\n-import java.util.*;\n-import java.util.function.Consumer;\n-\n-import org.apache.jena.atlas.iterator.Iter;\n-import org.apache.jena.graph.*;\n-import org.apache.jena.riot.out.NodeFmtLib;\n-import org.apache.jena.sparql.core.Quad;\n-import org.apache.jena.sparql.graph.NodeConst;\n-import org.apache.jena.sparql.util.graph.GNode;\n-import org.apache.jena.sparql.util.graph.GraphList;\n-import org.apache.jena.util.iterator.ExtendedIterator;\n-\n-/** A library of functions for working with {@link Graph}. */\n-public class G {\n-    private G() {}\n-\n-    private static Node rdfType = NodeConst.nodeRDFType;\n-\n-    /** Return the subject of a triple, or null if the triple is null. */\n-    public static Node subject(Triple triple) {\n-        return triple == null ? null : triple.getSubject();\n-    }\n-\n-    /** Return the predicate of a triple, or null if the triple is null. */\n-    public static Node predicate(Triple triple) {\n-        return triple == null ? null : triple.getPredicate();\n-    }\n-\n-    /** Return the object of a triple, or null if the triple is null. */\n-    public static Node object(Triple triple) {\n-        return triple == null ? null : triple.getObject();\n-    }\n-\n-    // ---- Node filter tests.\n-    public static boolean isURI(Node n)         { return n != null && n.isURI(); }\n-    public static boolean isBlank(Node n)       { return n != null && n.isBlank(); }\n-    public static boolean isLiteral(Node n)     { return n != null && n.isLiteral(); }\n-    public static boolean isResource(Node n)    { return n != null && (n.isURI()||n.isBlank()); }\n-    public static boolean isNodeTriple(Node n)  { return n != null && n.isNodeTriple(); }\n-    public static boolean isNodeGraph(Node n)   { return n != null && n.isNodeGraph(); }\n-\n-    /** Convert null to Node.ANY */\n-    public static Node nullAsAny(Node x) { return nullAsDft(x, Node.ANY) ; }\n-\n-    /** Convert null to some default Node */\n-    public static Node nullAsDft(Node x, Node dft) { return x==null ? dft : x ; }\n-\n-    /** Does the graph match the s/p/o pattern? */\n-    public static boolean contains(Graph graph, Node subject, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return graph.contains(subject, predicate, object);\n-    }\n-\n-    /** Does the graph use the node anywhere as a subject, predicate or object? */\n-    public static boolean containsNode(Graph graph, Node node) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(node, \"node\");\n-        return GraphUtil.containsNode(graph, node);\n-//        return\n-//            contains(graph, node, Node.ANY, Node.ANY) ||\n-//            contains(graph, Node.ANY, Node.ANY, node) ||\n-//            contains(graph, Node.ANY, node, Node.ANY) ;\n-    }\n-\n-    /** Test whether the node has the type or is rdfs:subclassOf. */\n-    public static boolean isOfType(Graph graph, Node node, Node type) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(node, \"node\");\n-        Objects.requireNonNull(type, \"type\");\n-        List<Node> allClasses = listSubClasses(graph, type);\n-        for ( Node c : allClasses ) {\n-            if ( hasType(graph, node, c) )\n-                return true;\n-        }\n-        return false;\n-    }\n-\n-    /** Does the node x have the given type (non-RDFS - no rdfs:subclassOf considered)? */\n-    public static boolean hasType(Graph graph, Node node, Node type) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(node, \"node\");\n-        Objects.requireNonNull(type, \"type\");\n-        return contains(graph, node, NodeConst.nodeRDFType, type);\n-    }\n-\n-    //---- get/list/iter\n-\n-    /** Does node {@code s} have property {@code p} in graph {@code g}? */\n-    public static boolean hasProperty(Graph graph, Node subject, Node predicate) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return graph.contains(subject, predicate, null);\n-    }\n-\n-    /** Contains exactly one. */\n-    public static boolean containsOne(Graph graph, Node subject, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        ExtendedIterator<Triple> iter = graph.find(subject, predicate, object);\n-        try {\n-            if ( ! iter.hasNext() )\n-                return false;\n-            iter.next();\n-            return !iter.hasNext();\n-        } finally { iter.close(); }\n-    }\n-\n-    /**\n-     * Get object, given subject and predicate. Returns one (non-deterministically) or null.\n-     * See also {@link #getOneSP} and {@link #getZeroOrOneSP}.\n-     */\n-    public static Node getSP(Graph graph, Node subject, Node predicate) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return object(first(find(graph, subject, predicate, Node.ANY)));\n-    }\n-\n-    // --- Graph walking.\n-\n-    /**\n-     * Get object for subject-predicate. Must be exactly one object; exception\n-     * {@linkplain RDFDataException} thrown when none or more than one.\n-     */\n-    public static Node getOneSP(Graph graph, Node subject, Node predicate) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return object(findUnique(graph, subject, predicate, Node.ANY));\n-    }\n-\n-    /**\n-     * Get object for subject-predicate. Return null for none, object for one, and\n-     * exception {@linkplain RDFDataException} if more than one.\n-     */\n-    public static Node getZeroOrOneSP(Graph graph, Node subject, Node predicate) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return object(findZeroOne(graph, subject, predicate, Node.ANY));\n-    }\n-\n-    /**\n-     *  Get the subject, given predicate and object. Returns one (non-deterministically) or null.\n-     *  See also {@link #getOnePO} and {@link #getZeroOrOnePO}.\n-     */\n-    public static Node getPO(Graph graph, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return object(first(find(graph, Node.ANY, predicate, object)));\n-    }\n-\n-    /**\n-     * Get the subject for predicate-object. Must be exactly one subject; exception\n-     * {@linkplain RDFDataException} thrown when none or more than one.\n-     */\n-    public static Node getOnePO(Graph graph, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return subject(findUnique(graph, Node.ANY, predicate, object));\n-    }\n-\n-    /**\n-     * Get the subject for predicate-object. Return null for none, subject for one, throw\n-     * exception {@linkplain RDFDataException} if more than one.\n-     */\n-    public static Node getZeroOrOnePO(Graph graph, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return subject(findZeroOne(graph, Node.ANY, predicate, object));\n-    }\n-\n-    /**\n-     * Get triple if there is exactly one to match the s/p/o, else throw\n-     * {@linkplain RDFDataException}.\n-     */\n-    public static Triple getOne(Graph graph, Node subject, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return findUnique(graph, subject, predicate, object);\n-    }\n-\n-    /**\n-     * Get triple if there is exactly one to match the s/p/o; return null if none;\n-     * throw {@linkplain RDFDataException} if more than one.\n-     */\n-    public static Triple getZeroOrOne(Graph graph, Node subject, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return findZeroOne(graph, subject, predicate, object);\n-    }\n-\n-    // ---- Multiple matches.\n-\n-    /**\n-     * {@link ExtendedIterator} of objects where the triple matches for subject and\n-     * predicate (which can be wildcards). The {@link ExtendedIterator} must be fully\n-     * used or explicitly closed. It is preferable use {@link #listSP} which handles\n-     * this condition.\n-     */\n-    public static ExtendedIterator<Node> iterSP(Graph graph, Node subject, Node predicate) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return find(graph, subject, predicate, null).mapWith(Triple::getObject);\n-    }\n-\n-    /**\n-     * List of objects matching the subject-predicate (which can be wildcards).\n-     */\n-    public static List<Node> listSP(Graph graph, Node subject, Node predicate) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return iterSP(graph, subject, predicate).toList();\n-    }\n-\n-    /** Count matches of subject-predicate (which can be wildcards). */\n-    public static long countSP(Graph graph, Node subject, Node predicate) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return Iter.count(iterSP(graph, subject, predicate));\n-    }\n-\n-    /**\n-     * {@link ExtendedIterator} of subjects where the triple matches for predicate\n-     * and object (which can be wildcards). The {@link ExtendedIterator} must be\n-     * fully used or explicitly closed. It is preferable use {@link #listSP} which\n-     * handles this condition.\n-     */\n-    public static ExtendedIterator<Node> iterPO(Graph graph, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return find(graph, null, predicate, object).mapWith(Triple::getSubject);\n-    }\n-\n-    /**\n-     * List of subjects matching the predicate-object (which can be wildcards).\n-     */\n-    public static List<Node> listPO(Graph graph, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return iterPO(graph, predicate, object).toList();\n-    }\n-\n-    /** Count matches of predicate-object (which can be wildcards). */\n-    public static long countPO(Graph graph, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return Iter.count(iterPO(graph, predicate, object));\n-    }\n-\n-    // DISTINCT means these are space using.\n-\n-    /** List the subjects in a graph (no duplicates) */\n-    public static Iterator<Node> listSubjects(Graph graph) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n-        return Iter.iter(iter).map(Triple::getSubject).distinct();\n-    }\n-\n-    /** List the predicates in a graph (no duplicates) */\n-    public static Iterator<Node> listPredicates(Graph graph) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n-        return Iter.iter(iter).map(Triple::getPredicate).distinct();\n-    }\n-\n-    /** List the objects in a graph (no duplicates) */\n-    public static Iterator<Node> listObjects(Graph graph) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n-        return Iter.iter(iter).map(Triple::getObject).distinct();\n-    }\n-\n-    // ---- rdf:type, not RDFS\n-\n-    /**\n-     * List the subjects with exactly {@code type}.\n-     * See {@link #listNodesOfTypeRDFS(Graph, Node)}, which does include sub-classes.\n-     */\n-    public static List<Node> nodesOfTypeAsList(Graph graph, Node type) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(type, \"type\");\n-        return find(graph, null, rdfType, type).mapWith(Triple::getSubject).toList();\n-    }\n-\n-    /**\n-     * List the types of a node/subject.\n-     * See {@link #listTypesOfNodeRDFS(Graph, Node)} , which does include super-classes.\n-     */\n-    public static List<Node> typesOfNodeAsList(Graph graph, Node node) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(node, \"node\");\n-        return find(graph, node, rdfType, null).mapWith(Triple::getObject).toList();\n-    }\n-\n-    /**\n-     * Set of nodes with exactly {@code type}.\n-     * See {@link #allNodesOfTypeRDFS(Graph, Node)}, which does include sub-classes.\n-     */\n-    public static Set<Node> nodesOfTypeAsSet(Graph graph, Node type) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(type, \"type\");\n-        return find(graph, null, rdfType, type).mapWith(Triple::getSubject).toSet();\n-    }\n-\n-    /**\n-     * Set of exact types of a node See {@link #allTypesOfNodeRDFS(Graph, Node)},\n-     * which does include super-classes.\n-     */\n-    public static Set<Node> typesOfNodeAsSet(Graph graph, Node node) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(node, \"node\");\n-        return find(graph, node, rdfType, null).mapWith(Triple::getObject).toSet();\n-    }\n-\n-    // ---- RDF list.\n-\n-    /** Return a java list for an RDF list of data. */\n-    public static List<Node> rdfList(Graph graph, Node node) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(node, \"node\");\n-        GNode gNode = GNode.create(graph, node);\n-        return GraphList.members(gNode);\n-    }\n-\n-    // Sub-class / super-class\n-\n-    /**\n-     * List the subclasses of a type, including itself.\n-     * This is <tt>?x rdfs:subClassOf* type</tt>.\n-     * The list does not contain duplicates.\n-     */\n-    public static List<Node> listSubClasses(Graph graph, Node type) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(type, \"type\");\n-        List<Node> acc = new ArrayList<>();\n-        // Subclasses are follow rdfs:subClassOf in reverse - object to subject.\n-        // Transitive.transitive is \"visit once\".\n-        Transitive.transitiveInc(graph, false, type, NodeConst.rdfsSubclassOf, acc);\n-        return acc;\n-    }\n-\n-    /**\n-     * List the super-classes of a type, including itself.\n-     * This is <tt>type rdfs:subClassOf* ?x</tt>.\n-     * The list does not contain duplicates.\n-     */\n-    public static List<Node> listSuperClasses(Graph graph, Node type) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(type, \"type\");\n-        List<Node> acc = new ArrayList<>();\n-        // Super classes are \"follow rdfs:subclassOf\" - subject to object.\n-        // Transitive.transitive is \"visit once\".\n-        Transitive.transitiveInc(graph, true, type, NodeConst.rdfsSubclassOf, acc);\n-        return acc;\n-    }\n-\n-    /**\n-     * Set of the subclasses of a type, including itself.\n-     * This is <tt>?x rdfs:subClassOf* type</tt>.\n-     */\n-    public static Set<Node> subClasses(Graph graph, Node type) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(type, \"type\");\n-        Set<Node> acc = new HashSet<>();\n-        // Subclasses are follow rdfs:subclassOf in reverse - object to subject.\n-        Transitive.transitiveInc(graph, false, type, NodeConst.rdfsSubclassOf, acc);\n-        return acc;\n-    }\n-\n-    /**\n-     * Set of the subclasses of a type, including itself.\n-     * This is <tt>?x rdfs:subClassOf* type</tt>.\n-     */\n-    public static Set<Node> superClasses(Graph graph, Node type) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(type, \"type\");\n-        Set<Node> acc = new HashSet<>();\n-        Transitive.transitiveInc(graph, true, type, NodeConst.rdfsSubclassOf, acc);\n-        return acc;\n-    }\n-\n-    // ---- RDFS\n-\n-    /**\n-     * List the types of a node, following rdfs:subClassOf for super classes.\n-     */\n-    public static List<Node> listTypesOfNodeRDFS(Graph graph, Node node) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(node, \"node\");\n-        List<Node> types = typesOfNodeAsList(graph, node);\n-        List<Node> types2 = new ArrayList<>();\n-        types.forEach(t->{\n-            List<Node> subClasses = listSuperClasses(graph, t);\n-            types2.addAll(subClasses);\n-        });\n-        return types2;\n-    }\n-\n-    /**\n-     * List all the nodes of type, including node of sub-classes.\n-     */\n-    public static List<Node> listNodesOfTypeRDFS(Graph graph, Node type) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(type, \"type\");\n-        List<Node> types = listSubClasses(graph, type);\n-        List<Node> nodes = new ArrayList<>();\n-        accNodesOfTypes(nodes, graph, types);\n-        return nodes;\n-    }\n-\n-    /**\n-     * List all the types of a node, including super-classes.\n-     */\n-    public static Set<Node> allTypesOfNodeRDFS(Graph graph, Node node) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(node, \"node\");\n-        Set<Node> types = typesOfNodeAsSet(graph, node);\n-        Set<Node> types2 = new HashSet<>();\n-        types.forEach(t->{\n-            List<Node> subClasses = listSuperClasses(graph, t);\n-            types2.addAll(subClasses);\n-        });\n-        return types2;\n-    }\n-\n-    /** List all the node of type, including considering rdfs:subClassOf */\n-    public static Set<Node> allNodesOfTypeRDFS(Graph graph, Node type) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(type, \"type\");\n-        Set<Node> types = subClasses(graph, type);\n-        Set<Node> nodes = new HashSet<>();\n-        accNodesOfTypes(nodes, graph, types);\n-        return nodes;\n-    }\n-\n-    /** For each type, find nodes of that type and accumulate */\n-    private static void accNodesOfTypes(Collection<Node> acc, Graph graph, Collection<Node> types) {\n-        types.forEach(t->\n-            find(graph, null, rdfType, t).mapWith(Triple::getSubject).forEach(acc::add)\n-            );\n-    }\n-\n-    /** Return a set of all objects for subject-predicate */\n-    public static Set<Node> allSP(Graph graph, Node subject, Node predicate) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return find(graph, subject, predicate, null).mapWith(Triple::getObject).toSet();\n-    }\n-\n-    /** Return a set of all subjects for predicate-object */\n-    public static Set<Node> allPO(Graph graph, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return find(graph, null, predicate, object).mapWith(Triple::getSubject).toSet();\n-    }\n-\n-    // --- Graph walking.\n-\n-    /** Count the number of in-arc to an object */\n-    public static long objectConnectiveness(Graph graph, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(object, \"object\");\n-        return Iter.count(find(graph, null, null, object));\n-    }\n-\n-    /** Test whether an object has exactly one in-arc. */\n-    public static boolean oneConnected(Graph graph, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        Objects.requireNonNull(object, \"object\");\n-        ExtendedIterator<Triple> iter = find(graph, null, null, object);\n-        if ( ! iter.hasNext() )\n-            // Zero.\n-            return false;\n-        iter.next();\n-        if ( iter.hasNext() )\n-            // more than one\n-            return false;\n-        return true;\n-    }\n-\n-    /** {@link Graph#find(Node, Node, Node)} as a function. */\n-    public static ExtendedIterator<Triple> find(Graph graph, Node subject, Node predicate, Node object) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return graph.find(subject, predicate, object);\n-    }\n-\n-    /** {@link Graph#find()} as a function. */\n-    public static ExtendedIterator<Triple> findAll(Graph graph) {\n-        Objects.requireNonNull(graph, \"graph\");\n-        return graph.find();\n-    }\n-\n-    private static Triple findUnique(Graph graph, Node subject, Node predicate, Node object) {\n-        ExtendedIterator<Triple> iter = graph.find(subject, predicate, object);\n-        try {\n-            if ( ! iter.hasNext() )\n-                throw new RDFDataException(\"No match : \"+matchStr(subject, predicate, object));\n-            Triple x = iter.next();\n-            if ( iter.hasNext() )\n-                throw new RDFDataException(\"More than one match : \"+matchStr(subject, predicate, object));\n-            return x;\n-        } finally { iter.close(); }\n-    }\n-\n-    private static Triple findZeroOne(Graph graph, Node subject, Node predicate, Node object) {\n-        ExtendedIterator<Triple> iter = graph.find(subject, predicate, object);\n-        try {\n-            if ( ! iter.hasNext() )\n-                return null;\n-            Triple x = iter.next();\n-            if ( iter.hasNext() )\n-                throw new RDFDataException(\"More than one match : \"+matchStr(subject, predicate, object));\n-            return x;\n-        } finally { iter.close(); }\n-    }\n-\n-    private static String matchStr(Node subject, Node predicate, Node object) {\n-        return \"(\"+NodeFmtLib.strNodes(subject, predicate, object)+\")\";\n-    }\n-\n-    private static Triple first(ExtendedIterator<Triple> iter) {\n-        try {\n-            if ( ! iter.hasNext() )\n-                return null;\n-            return iter.next();\n-        } finally { iter.close(); }\n-    }\n-\n-    /** Are all the arguments non-null? */\n-    @SafeVarargs\n-    public static <X> boolean allNonNull(X ... objects) {\n-        return countNonNulls(objects) == objects.length;\n-    }\n-\n-    /** Is one and only one argument non-null? */\n-    @SafeVarargs\n-    public static <X> boolean exactlyOneSet(X ... objects) {\n-        return countNonNulls(objects) == 1;\n-    }\n-\n-    /** Is one or none of the arguments non-null? */\n-    @SafeVarargs\n-    public static <X> X atMostOne(X ... objects) {\n-        int c = 0;\n-        X x = null;\n-        for ( X obj : objects ) {\n-            if ( obj != null ) {\n-                c++;\n-                if ( c > 1 )\n-                    throw new RDFDataException(\"atMostOne:\"+Arrays.asList(objects));\n-                if ( x == null )\n-                    x = obj;\n-            }\n-        }\n-        return x;\n-    }\n-\n-    /** Count non-nulls */\n-    @SafeVarargs\n-    public static <X> int countNonNulls(X ... objects) {\n-        int x = 0;\n-        for ( Object obj : objects ) {\n-            if ( obj != null )\n-                x++;\n-        }\n-        return x;\n-    }\n-\n-    // ---- Project\n-\n-    /** Project quads to triples */\n-    public static Iter<Triple> quads2triples(Iterator<Quad> iter)\n-    { return Iter.iter(iter).map(Quad::asTriple); }\n-\n-    /** Project quad to graph name */\n-    public static Iterator<Node> quad2graphName(Iterator<Quad> iter)\n-    { return Iter.map(iter, Quad::getGraph) ; }\n-\n-    /** Project quad to subject */\n-    public static Iterator<Node> quad2subject(Iterator<Quad> iter)\n-    { return Iter.map(iter, Quad::getSubject) ; }\n-\n-    /** Project quad to predicate */\n-    public static Iterator<Node> quad2predicate(Iterator<Quad> iter)\n-    { return Iter.map(iter, Quad::getPredicate) ; }\n-\n-    /** Project quad to object */\n-    public static Iterator<Node> quad2object(Iterator<Quad> iter)\n-    { return Iter.map(iter, Quad::getObject) ; }\n-\n-    /** Project triple to subject */\n-    public static Iterator<Node> triple2subject(Iterator<Triple> iter)\n-    { return Iter.map(iter, Triple::getSubject) ; }\n-\n-    /** Project triple to predicate */\n-    public static Iterator<Node> triple2predicate(Iterator<Triple> iter)\n-    { return Iter.map(iter, Triple::getPredicate) ; }\n-\n-    /** Project triple to object */\n-    public static Iterator<Node> triple2object(Iterator<Triple> iter)\n-    { return Iter.map(iter, Triple::getObject) ; }\n-\n-    // Graph operations.\n-\n-    /**\n-     * Add src to dst - assumes transaction.\n-     * src and dst must not overlap.\n-     * Copies \"left to right\" -- {@code src into dst}\n-     * @param src\n-     * @param dst\n-     */\n-    public static void copyGraphSrcToDst(Graph src, Graph dst) {\n-        apply(src, dst::add);\n-    }\n-\n-    /**\n-     * Clear graph.\n-     */\n-    public static void clear(Graph graph) {\n-        graph.clear();\n-    }\n-\n-    /**\n-     * Apply an action to every triple of a graph. The action must not attempt to\n-     * modify the graph but it can read it.\n-     */\n-    public static void apply(Graph src, Consumer<Triple> action) {\n-        ExtendedIterator<Triple> iter = src.find();\n-        apply(iter, action);\n-    }\n-\n-    /**\n-     * Apply an action to every triple of an iterator.\n-     * If the iterator is attracted to a graph, the action must not attempt to\n-     * modify the graph but it can read it.\n-     */\n-    public static void apply(ExtendedIterator<Triple> iter, Consumer<Triple> action) {\n-        try {\n-            while(iter.hasNext()) {\n-                Triple t = iter.next();\n-                action.accept(t);\n-            }\n-        } finally { iter.close(); }\n-    }\n-\n-    /**\n-     * Delete triples in the graph-to-modify (arg 1) that are in the source (arg 2).\n-     * @param modify\n-     * @param srcGraph\n-     */\n-    public static void deleteModify(Graph modify, Graph srcGraph) {\n-        // NB order of arguments.\n-        GraphUtil.deleteFrom(modify, srcGraph);\n-    }\n-\n-    /** Convert an iterator of triples into quads for the specified graph name. */\n-    public static Iter<Quad> triples2quads(Node graphNode, Iterator<Triple> iter) {\n-        return Iter.iter(iter).map(t -> new Quad(graphNode, t)) ;\n-    }\n-\n-    /**\n-     * Convert an iterator of triples into quads for the default graph. This is\n-     * {@link Quad#defaultGraphIRI}, not {@link Quad#defaultGraphNodeGenerated}, which is\n-     * for quads outside a dataset, usually the output of parsers.\n-     */\n-    public static Iter<Quad> triples2quadsDftGraph(Iterator<Triple> iter) {\n-        return triples2quads(Quad.defaultGraphIRI, iter) ;\n-    }\n-}\n"}}, {"oid": "b552757b224a43926b9ffeb5e86efca206c57ecc", "url": "https://github.com/apache/jena/commit/b552757b224a43926b9ffeb5e86efca206c57ecc", "message": "Mark iterator to stream as immutable", "committedDate": "2020-10-05T11:12:43Z", "type": "commit"}, {"oid": "2ce67087fc0decde38d3c79b6b85dde259c788ea", "url": "https://github.com/apache/jena/commit/2ce67087fc0decde38d3c79b6b85dde259c788ea", "message": "JENA-1974: Function library for working with graphs", "committedDate": "2020-10-05T11:13:47Z", "type": "commit"}, {"oid": "2ce67087fc0decde38d3c79b6b85dde259c788ea", "url": "https://github.com/apache/jena/commit/2ce67087fc0decde38d3c79b6b85dde259c788ea", "message": "JENA-1974: Function library for working with graphs", "committedDate": "2020-10-05T11:13:47Z", "type": "forcePushed"}]}