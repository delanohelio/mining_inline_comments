{"pr_number": 880, "pr_title": "JENA-2006: DatasetGraph prefixes", "pr_createdAt": "2020-12-01T19:14:54Z", "pr_url": "https://github.com/apache/jena/pull/880", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5NjgzOQ==", "url": "https://github.com/apache/jena/pull/880#discussion_r533996839", "bodyText": "This is a really nice looking new test suite \ud83d\udc4d", "author": "rvesse", "createdAt": "2020-12-02T08:58:50Z", "path": "jena-integration-tests/src/test/java/org/apache/jena/test/integration/TestDatasetPrefixes.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.test.integration;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.jena.atlas.lib.Creator;\n+import org.apache.jena.query.TxnType;\n+import org.apache.jena.riot.system.PrefixMap;\n+import org.apache.jena.riot.system.Prefixes;\n+import org.apache.jena.shared.JenaException;\n+import org.apache.jena.sparql.JenaTransactionException;\n+import org.apache.jena.sparql.core.DatasetGraph;\n+import org.apache.jena.sparql.core.DatasetGraphFactory;\n+import org.apache.jena.sparql.core.DatasetGraphMap;\n+import org.apache.jena.sparql.core.DatasetGraphMapLink;\n+import org.apache.jena.sparql.graph.GraphFactory;\n+import org.apache.jena.system.Txn;\n+import org.apache.jena.tdb.TDBFactory;\n+import org.apache.jena.tdb.transaction.TDBTransactionException;\n+import org.apache.jena.tdb2.DatabaseMgr;\n+import org.junit.Assume;\n+import org.junit.FixMethodOrder;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.MethodSorters;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+// Tests go simple -> complex\n+// Does not matter ass to their execution, it does help pinpoint what has broken.\n+/**\n+ * Test of dataset prefixes.\n+ * See {@code AbstractTestPrefixMap} for tests of prefix maps in general.\n+ */\n+\n+\n+@FixMethodOrder(MethodSorters.JVM)\n+@RunWith(Parameterized.class)\n+public class TestDatasetPrefixes {\n+\n+    @Parameters(name = \"{index}: {0}\")\n+    public static Collection<Object[]> data(){\n+        Creator<DatasetGraph> c1 = ()->DatasetGraphFactory.createTxnMem();\n+        Creator<DatasetGraph> c2 = ()->TDBFactory.createDatasetGraph();\n+        Creator<DatasetGraph> c3 = ()->DatabaseMgr.createDatasetGraph();\n+        Creator<DatasetGraph> c4 = ()->new DatasetGraphMap();     //DatasetGraphFactory.create();\n+        Creator<DatasetGraph> c5 = ()->new DatasetGraphMapLink(GraphFactory.createDefaultGraph()); //DatasetGraphFactory.createGeneral();\n+\n+        Object[] x1 = { \"TIM\",  c1 , false, true, true };\n+        Object[] x2 = { \"TDB1\", c2 , true, true, true };\n+        Object[] x3 = { \"TDB2\", c3 , true, true, true };\n+        Object[] x4 = { \"Map\",  c4 , false, false, false };\n+        Object[] x5 = { \"MapLink\", c5 , false, false, false };\n+        return Arrays.asList(x1, x2, x3, x4,x5);\n+    }\n+", "originalCommit": "31475bbb21deb31f0dc286e1e3a3bd061a5ab864", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU0NDg3OA==", "url": "https://github.com/apache/jena/pull/880#discussion_r535544878", "bodyText": "s/th/the", "author": "kinow", "createdAt": "2020-12-03T19:59:26Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/system/PrefixLib.java", "diffHunk": "@@ -80,35 +72,52 @@ public static String abbreviate(PrefixMapI pmap, String uriStr) {\n      * Abbreviate a uriStr, return the prefix and local parts.\n      * This does not guarantee that the result is suitable for all RDF syntaxes.\n      */\n-    public static Pair<String, String> abbrev(PrefixMapI prefixes, String uriStr) {\n-        for ( PrefixEntry e : prefixes ) {\n-            String uriForPrefix = e.getUri();\n-            if ( uriStr.startsWith(uriForPrefix) )\n-                return Pair.create(e.getPrefix(), uriStr.substring(uriForPrefix.length()));\n+    public static Pair<String, String> abbrev(PrefixMap prefixes, String uriStr) {\n+        return abbrev(prefixes.getMapping(), uriStr, true);\n+    }\n+\n+    /**\n+     * Abbreviate a uriStr, return the prefix and local parts, using a {@code Map} of\n+     * prefix string to URI string. This does not guarantee that the result is\n+     * suitable for all RDF syntaxes. In addition, perform a fast check for legal\n+     * turtle local parts using {@link #isSafeLocalPart}. This covers the majority of\n+     * real work cases and allows th code to find a probably-legal abbrev pair if an", "originalCommit": "31475bbb21deb31f0dc286e1e3a3bd061a5ab864", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19b4ed3d8a6e39573a78d5a0c39aeb3b3f95fe7b", "chunk": "diff --git a/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixLib.java b/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixLib.java\nindex ef0e10c5fd..4bb2e4d1a5 100644\n--- a/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixLib.java\n+++ b/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixLib.java\n\n@@ -81,8 +81,8 @@ public class PrefixLib {\n      * prefix string to URI string. This does not guarantee that the result is\n      * suitable for all RDF syntaxes. In addition, perform a fast check for legal\n      * turtle local parts using {@link #isSafeLocalPart}. This covers the majority of\n-     * real work cases and allows th code to find a probably-legal abbrev pair if an\n-     * illegal one if found. (In practice, illegal local names arise only when one\n+     * real work cases and allows the code to find a probably-legal abbrev pair if an\n+     * illegal one is found. (In practice, illegal local names arise only when one\n      * prefix URI is a substring of another.)\n      */\n     public static Pair<String, String> abbrev(Map<String, String> prefixesMap, String uriStr, boolean turtleSafeLocalPart) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU0NTAxMA==", "url": "https://github.com/apache/jena/pull/880#discussion_r535545010", "bodyText": "s/if/is", "author": "kinow", "createdAt": "2020-12-03T19:59:40Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/system/PrefixLib.java", "diffHunk": "@@ -80,35 +72,52 @@ public static String abbreviate(PrefixMapI pmap, String uriStr) {\n      * Abbreviate a uriStr, return the prefix and local parts.\n      * This does not guarantee that the result is suitable for all RDF syntaxes.\n      */\n-    public static Pair<String, String> abbrev(PrefixMapI prefixes, String uriStr) {\n-        for ( PrefixEntry e : prefixes ) {\n-            String uriForPrefix = e.getUri();\n-            if ( uriStr.startsWith(uriForPrefix) )\n-                return Pair.create(e.getPrefix(), uriStr.substring(uriForPrefix.length()));\n+    public static Pair<String, String> abbrev(PrefixMap prefixes, String uriStr) {\n+        return abbrev(prefixes.getMapping(), uriStr, true);\n+    }\n+\n+    /**\n+     * Abbreviate a uriStr, return the prefix and local parts, using a {@code Map} of\n+     * prefix string to URI string. This does not guarantee that the result is\n+     * suitable for all RDF syntaxes. In addition, perform a fast check for legal\n+     * turtle local parts using {@link #isSafeLocalPart}. This covers the majority of\n+     * real work cases and allows th code to find a probably-legal abbrev pair if an\n+     * illegal one if found. (In practice, illegal local names arise only when one", "originalCommit": "31475bbb21deb31f0dc286e1e3a3bd061a5ab864", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19b4ed3d8a6e39573a78d5a0c39aeb3b3f95fe7b", "chunk": "diff --git a/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixLib.java b/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixLib.java\nindex ef0e10c5fd..4bb2e4d1a5 100644\n--- a/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixLib.java\n+++ b/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixLib.java\n\n@@ -81,8 +81,8 @@ public class PrefixLib {\n      * prefix string to URI string. This does not guarantee that the result is\n      * suitable for all RDF syntaxes. In addition, perform a fast check for legal\n      * turtle local parts using {@link #isSafeLocalPart}. This covers the majority of\n-     * real work cases and allows th code to find a probably-legal abbrev pair if an\n-     * illegal one if found. (In practice, illegal local names arise only when one\n+     * real work cases and allows the code to find a probably-legal abbrev pair if an\n+     * illegal one is found. (In practice, illegal local names arise only when one\n      * prefix URI is a substring of another.)\n      */\n     public static Pair<String, String> abbrev(Map<String, String> prefixesMap, String uriStr, boolean turtleSafeLocalPart) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU0NTIzMQ==", "url": "https://github.com/apache/jena/pull/880#discussion_r535545231", "bodyText": "\ud83d\udc4d", "author": "kinow", "createdAt": "2020-12-03T20:00:02Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/system/PrefixMap.java", "diffHunk": "@@ -35,6 +36,24 @@\n  * </p>\n  */\n public interface PrefixMap {\n+    /**\n+     * Return the URI for the prefix, or null if there is no entry for this prefix.\n+     */\n+    public String get(String prefix);\n+\n+    // Is this a good idea? Leave out until it is justified.", "originalCommit": "31475bbb21deb31f0dc286e1e3a3bd061a5ab864", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU1MTA5NA==", "url": "https://github.com/apache/jena/pull/880#discussion_r535551094", "bodyText": "Base?", "author": "kinow", "createdAt": "2020-12-03T20:09:12Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/system/PrefixMapNull.java", "diffHunk": "@@ -18,18 +18,20 @@\n \n package org.apache.jena.riot.system ;\n \n+import static org.apache.jena.atlas.lib.Lib.unsupportedMethod;\n+\n import java.util.Collections ;\n import java.util.Map ;\n import java.util.function.BiConsumer ;\n+import java.util.stream.Stream;\n \n import org.apache.jena.atlas.lib.Pair ;\n import org.apache.jena.shared.PrefixMapping ;\n \n-/** Always empty prefix map */\n-public class PrefixMapNull implements PrefixMap {\n-    public static PrefixMap empty = new PrefixMapNull() ;\n+/** Baes of always empty prefix maps {@link PrefixMapSink} and {@link PrefixMapZero}. */", "originalCommit": "31475bbb21deb31f0dc286e1e3a3bd061a5ab864", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19b4ed3d8a6e39573a78d5a0c39aeb3b3f95fe7b", "chunk": "diff --git a/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixMapNull.java b/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixMapNull.java\nindex f8b1d5f6ca..b4cc3cdf27 100644\n--- a/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixMapNull.java\n+++ b/jena-arq/src/main/java/org/apache/jena/riot/system/PrefixMapNull.java\n\n@@ -28,7 +28,7 @@ import java.util.stream.Stream;\n import org.apache.jena.atlas.lib.Pair ;\n import org.apache.jena.shared.PrefixMapping ;\n \n-/** Baes of always empty prefix maps {@link PrefixMapSink} and {@link PrefixMapZero}. */\n+/** Base of always empty prefix maps {@link PrefixMapSink} and {@link PrefixMapZero}. */\n public abstract class PrefixMapNull implements PrefixMap {\n \n     protected PrefixMapNull() {}\n"}}, {"oid": "19b4ed3d8a6e39573a78d5a0c39aeb3b3f95fe7b", "url": "https://github.com/apache/jena/commit/19b4ed3d8a6e39573a78d5a0c39aeb3b3f95fe7b", "message": "JENA-2006: DatasetGraph prefixes", "committedDate": "2020-12-04T10:21:48Z", "type": "commit"}, {"oid": "19b4ed3d8a6e39573a78d5a0c39aeb3b3f95fe7b", "url": "https://github.com/apache/jena/commit/19b4ed3d8a6e39573a78d5a0c39aeb3b3f95fe7b", "message": "JENA-2006: DatasetGraph prefixes", "committedDate": "2020-12-04T10:21:48Z", "type": "forcePushed"}]}