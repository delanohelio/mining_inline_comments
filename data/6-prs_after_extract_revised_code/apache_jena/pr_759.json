{"pr_number": 759, "pr_title": "JENA-1917: FileManager as interface; Deprecate FileManager.get()", "pr_createdAt": "2020-06-15T12:11:50Z", "pr_url": "https://github.com/apache/jena/pull/759", "timeline": [{"oid": "1d553248e493ab00c88468c51328d22f3df1de17", "url": "https://github.com/apache/jena/commit/1d553248e493ab00c88468c51328d22f3df1de17", "message": "JENA-1917: FileManager as interface; Deprecate FileManager.get()", "committedDate": "2020-06-15T13:33:26Z", "type": "forcePushed"}, {"oid": "e367d0247eec57c7466adef3a31601548a420ed6", "url": "https://github.com/apache/jena/commit/e367d0247eec57c7466adef3a31601548a420ed6", "message": "JENA-1917: FileManager as interface; Deprecate FileManager.get()", "committedDate": "2020-06-15T21:21:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NjAzOA==", "url": "https://github.com/apache/jena/pull/759#discussion_r440596038", "bodyText": "Oh, the list used to be on Yahoo! Groups? That was probably a long time ago?", "author": "kinow", "createdAt": "2020-06-16T05:34:23Z", "path": "jena-core/src/main/java/org/apache/jena/ontology/OntDocumentManager.java", "diffHunk": "@@ -54,16 +54,14 @@\n  * example:\n  * </p>\n  * <pre>OntDocumentManager dm = OntDocumentManager.getInstance();\n- * dm.setFileManager( FileManager.get() );</pre>\n- * <p>Note that in Jena 2.3, we have deprecated the capability of the document manager\n- * to store a table of known prefixes, and a table mapping document URI's to ontology language\n- * types. <strong>The intention is to remove both of these capabilities from\n- * Jena 2.4 onwards</strong>. If this change would be problematic, please send email to the\n- * <a href=\"http://groups.yahoo.com/group/jena-dev\">Jena support", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dd3ee540c13087adca06cba5b170804e9de06e54", "chunk": "diff --git a/jena-core/src/main/java/org/apache/jena/ontology/OntDocumentManager.java b/jena-core/src/main/java/org/apache/jena/ontology/OntDocumentManager.java\nindex ddfe1aa483..e1b68a40a5 100644\n--- a/jena-core/src/main/java/org/apache/jena/ontology/OntDocumentManager.java\n+++ b/jena-core/src/main/java/org/apache/jena/ontology/OntDocumentManager.java\n\n@@ -54,14 +54,16 @@ import org.slf4j.LoggerFactory ;\n  * example:\n  * </p>\n  * <pre>OntDocumentManager dm = OntDocumentManager.getInstance();\n- * dm.setFileManager( FileManager.get() );\n- * </pre>\n+ * dm.setFileManager( FileManager.get() );</pre>\n+ * <p>Note that in Jena 2.3, we have deprecated the capability of the document manager\n+ * to store a table of known prefixes, and a table mapping document URI's to ontology language\n+ * types. <strong>The intention is to remove both of these capabilities from\n+ * Jena 2.4 onwards</strong>. If this change would be problematic, please send email to the\n+ * <a href=\"http://groups.yahoo.com/group/jena-dev\">Jena support\n+ * list</a>.</p>\n  */\n-@SuppressWarnings(\"deprecation\")\n public class OntDocumentManager\n {\n-    // @SuppressWarnings - FileManager model caching.\n-    \n     // Constants\n     ////////////////////////////////////\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NjUzOA==", "url": "https://github.com/apache/jena/pull/759#discussion_r440596538", "bodyText": "I think the only difference now is that writerName.equals(n3WriterPrettyPrinter) used to work, and now it won't? But probably no harm I guess?", "author": "kinow", "createdAt": "2020-06-16T05:36:06Z", "path": "jena-core/src/main/java/org/apache/jena/n3/N3JenaWriter.java", "diffHunk": "@@ -105,16 +80,20 @@ N3JenaWriterCommon chooseWriter()\n     {\n         // Choose the writer\n         String writerName = JenaRuntime.getSystemProperty(propWriterName) ;\n-        if ( writerName == null ||\n-             writerName.equals(\"N3\") || writerName.equals(n3WriterPrettyPrinter) )\n+        if ( writerName == null )\n+            return new N3JenaWriterPP() ;\n+        if ( writerName.equals(\"N3\") )\n             return new N3JenaWriterPP() ;\n         \n-        if ( writerName.equalsIgnoreCase(n3WriterPlain) )\n-            return new N3JenaWriterCommon() ;\n-        \n-        if ( writerName.equalsIgnoreCase(n3WriterTriples) ||\n-             writerName.equalsIgnoreCase(n3WriterTriplesAlt) )\n-            return new N3JenaWriterTriples() ;\n+//        if ( writerName.equals(n3WriterPrettyPrinter) )", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NzE1Mw==", "url": "https://github.com/apache/jena/pull/759#discussion_r440597153", "bodyText": "s/FileManger/FileManager", "author": "kinow", "createdAt": "2020-06-16T05:38:12Z", "path": "jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.util;\n+\n+import java.io.* ;\n+import java.util.* ;\n+\n+import org.apache.jena.atlas.logging.FmtLog;\n+import org.apache.jena.rdf.model.Model ;\n+import org.apache.jena.rdf.model.ModelFactory ;\n+import org.apache.jena.shared.JenaException ;\n+import org.apache.jena.shared.NotFoundException ;\n+import org.apache.jena.shared.WrappedIOException ;\n+import org.apache.jena.sys.JenaSystem ;\n+import org.slf4j.Logger ;\n+import org.slf4j.LoggerFactory ;\n+\n+/** FileManager\n+ * \n+ * A FileManager provides access to named file-like resources by opening\n+ * InputStreams to things in the filing system, by URL (http: and file:) and\n+ * found by the classloader.  It can also load RDF data from such a system\n+ * resource into an existing model or create a new (Memory-based) model.\n+ * There is a global FileManager which provide uniform access to system\n+ * resources: applications may also create specialised FileManagers.\n+ * \n+ * A FileManager contains a list of location functions to try: the global\n+ * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dd3ee540c13087adca06cba5b170804e9de06e54", "chunk": "diff --git a/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java b/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java\ndeleted file mode 100644\nindex d32bb21464..0000000000\n--- a/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java\n+++ /dev/null\n\n@@ -1,566 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.jena.util;\n-\n-import java.io.* ;\n-import java.util.* ;\n-\n-import org.apache.jena.atlas.logging.FmtLog;\n-import org.apache.jena.rdf.model.Model ;\n-import org.apache.jena.rdf.model.ModelFactory ;\n-import org.apache.jena.shared.JenaException ;\n-import org.apache.jena.shared.NotFoundException ;\n-import org.apache.jena.shared.WrappedIOException ;\n-import org.apache.jena.sys.JenaSystem ;\n-import org.slf4j.Logger ;\n-import org.slf4j.LoggerFactory ;\n-\n-/** FileManager\n- * \n- * A FileManager provides access to named file-like resources by opening\n- * InputStreams to things in the filing system, by URL (http: and file:) and\n- * found by the classloader.  It can also load RDF data from such a system\n- * resource into an existing model or create a new (Memory-based) model.\n- * There is a global FileManager which provide uniform access to system\n- * resources: applications may also create specialised FileManagers.\n- * \n- * A FileManager contains a list of location functions to try: the global\n- * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and\n- * one {@link LocatorURL}\n- * \n- * Main operations:\n- *  * <ul>\n- * <li>loadModel, readModel : URI to model</li>\n- * <li>open, openNoMap : URI to input stream</li>\n- * <li>mapURI : map URI to another by {@link LocationMapper}</li> \n- * </ul>\n- * \n- * Utilities:\n- * <ul>\n- * <li>readWholeFileAsUTF8</li>\n- * <li>optional caching of models<li>\n- * </ul>\n- * \n- * A FileManager works in conjunction with a LocationMapper.\n- * A {@link LocationMapper} is a set of alternative locations for system\n- * resources and a set of alternative prefix locations.  For example, a local\n- * copy of a common RDF dataset may be used whenever the usual URL is used by\n- * the application.\n- *\n- * The {@link LocatorFile} also supports the idea of \"current directory\".\n- * \n- * @see LocationMapper\n- * @see FileUtils\n- */\n- \n-public class FileManagerImpl implements FileManager\n-{\n-    // The case of the FileManager used first.\n-    private static Logger log = LoggerFactory.getLogger(FileManager.class) ;\n-    \n-    /** Delimiter between path entries : because URI scheme names use : we only allow ; */\n-\n-    static FileManager fmInstance = null ;\n-\n-    protected List<Locator> fmHandlers = new ArrayList<>() ;\n-    protected LocationMapper fmMapper = null ;\n-    \n-    static { JenaSystem.init(); }\n-\n-    /** Get the global file manager.\n-     * @return the global file manager\n-     */\n-    public static FileManager get()\n-    {\n-        // Singleton pattern adopted in case we later have several file managers.\n-        if ( fmInstance == null )\n-            fmInstance = makeGlobal() ;\n-        return fmInstance ;\n-    }\n-    \n-    /** Set the global file manager (as returned by get())\n-     * If called before any call to get(), then the usual default filemanager is not created \n-     * @param globalFileManager\n-     */\n-    public static void setGlobalFileManager(FileManager globalFileManager)\n-    {\n-        fmInstance = globalFileManager ;\n-    }\n-    \n-    /** Create an uninitialized FileManager */\n-\n-    protected FileManagerImpl() {}\n-    \n-    protected static FileManager makeStd() {\n-        FileManagerImpl fm = new FileManagerImpl();\n-        setStdLocators(fm);\n-        return fm;\n-    }\n-    \n-    /** Create with the given location mapper */\n-    protected FileManagerImpl(LocationMapper _mapper)    { setLocationMapper(_mapper) ; }\n-\n-    @Override\n-    public FileManager clone() { return clone(this) ; } \n- \n-    // Isolate to help avoid copy errors.\n-    private static FileManager clone(FileManagerImpl filemanager) {\n-        FileManagerImpl newFm = new FileManagerImpl() ;\n-        newFm.fmHandlers.addAll(filemanager.fmHandlers) ;\n-        newFm.fmMapper = null ;\n-        if ( filemanager.getLocationMapper() != null )\n-            newFm.fmMapper = new LocationMapper(filemanager.getLocationMapper()) ;\n-        newFm.cacheModelLoads = false ;\n-        newFm.modelCache = null ;\n-        return newFm ;\n-    }\n-\n-    /** Create a \"standard\" FileManager. */\n-    public static FileManager makeGlobal()\n-    {\n-        FileManagerImpl fMgr = new FileManagerImpl(LocationMapper.get()) ;\n-        setStdLocators(fMgr) ;\n-        return fMgr ;\n-    }\n-    \n-    /** Force a file handler to have the default configuration. */\n-    private static void setStdLocators(FileManagerImpl fMgr)\n-    {\n-        fMgr.fmHandlers.clear() ;\n-        fMgr.addLocatorFile() ;\n-        fMgr.addLocatorURL() ;\n-        fMgr.addLocatorClassLoader(fMgr.getClass().getClassLoader()) ;\n-    }\n-    /** Set the location mapping */\n-    @Override\n-    public void setLocationMapper(LocationMapper _mapper) { fmMapper = _mapper ; }\n-    \n-    /** Get the location mapping */\n-    @Override\n-    public LocationMapper getLocationMapper() { return fmMapper ; }\n-    \n-    /** Return an iterator over all the handlers */\n-    @Override\n-    public Iterator<Locator> locators() { return fmHandlers.listIterator() ; }\n-\n-    /** Add a locator to the end of the locators list */ \n-    @Override\n-    public void addLocator(Locator loc)\n-    {\n-        log.debug(\"Add location: \"+loc.getName()) ;\n-        fmHandlers.add(loc) ; }\n-\n-    /** Add a file locator */ \n-    @Override\n-    public void addLocatorFile() { addLocatorFile(null) ; } \n-\n-    /** Add a file locator which uses dir as its working directory */ \n-    @Override\n-    public void addLocatorFile(String dir)\n-    {\n-        LocatorFile fLoc = new LocatorFile(dir) ;\n-        addLocator(fLoc) ;\n-    }\n-    \n-    /** Add a class loader locator */ \n-    @Override\n-    public void addLocatorClassLoader(ClassLoader cLoad)\n-    {\n-        LocatorClassLoader cLoc = new LocatorClassLoader(cLoad) ;\n-        addLocator(cLoc) ;\n-    }\n-\n-    /** Add a URL locator */\n-    @Override\n-    public void addLocatorURL()\n-    {\n-        Locator loc = new LocatorURL() ;\n-        addLocator(loc) ;\n-    }\n-\n-    /** Add a zip file locator */\n-    @Override\n-    public void addLocatorZip(String zfn)\n-    {\n-        Locator loc = new LocatorZip(zfn) ;\n-        addLocator(loc) ;\n-    }\n-\n-    \n-    /** Remove a locator */ \n-    @Override\n-    public void remove(Locator loc) { fmHandlers.remove(loc) ; }\n-\n-    // -------- Cache operations\n-    boolean cacheModelLoads = false ;\n-    Map<String, Model> modelCache = null ;\n-    \n-    /** Reset the model cache */\n-    @Override\n-    public void resetCache()\n-    {\n-        if ( modelCache != null )\n-            modelCache.clear() ;\n-    }\n-    \n-    /** Change the state of model cache : does not clear the cache */ \n-    @Override\n-    public void setModelCaching(boolean state)\n-    {\n-        cacheModelLoads = state ;\n-        if ( cacheModelLoads && modelCache == null )\n-            modelCache = new HashMap<String, Model>() ;\n-    }\n-\n-    /** return whether caching is on of off */\n-    @Override\n-    public boolean isCachingModels() { return cacheModelLoads ; }\n-    \n-    /** Read out of the cache - return null if not in the cache */ \n-    @Override\n-    public Model getFromCache(String filenameOrURI)\n-    { \n-        if ( ! isCachingModels() )\n-            return null; \n-        return modelCache.get(filenameOrURI) ;\n-    }\n-    \n-    @Override\n-    public boolean hasCachedModel(String filenameOrURI)\n-    { \n-        if ( ! isCachingModels() )\n-            return false ; \n-        return modelCache.containsKey(filenameOrURI) ;\n-    }\n-    \n-    @Override\n-    public void addCacheModel(String uri, Model m)\n-    { \n-        if ( isCachingModels() )\n-            modelCache.put(uri, m) ;\n-    }\n-\n-    @Override\n-    public void removeCacheModel(String uri)\n-    { \n-        if ( isCachingModels() )\n-            modelCache.remove(uri) ;\n-    }\n-\n-    // -------- Cache operations (end)\n-\n-    /** Load a model from a file (local or remote).\n-     *  This operation may attempt content negotiation for http URLs.\n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-     */\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI)\n-    { \n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\")\") ;\n-        \n-        return loadModelWorker(filenameOrURI, null, null) ;\n-    }\n-\n-    /** Load a model from a file (local or remote).\n-     *  URI is the base for reading the model.\n-     * \n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @param rdfSyntax  RDF Serialization syntax. \n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-     */\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n-        return loadModelWorker(filenameOrURI, null, rdfSyntax) ;\n-    }\n-    \n-    /** Load a model from a file (local or remote).\n-     * \n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @param baseURI  Base URI for loading the RDF model.\n-     *  @param rdfSyntax  RDF Serialization syntax. \n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-    */\n-\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI, String baseURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\", \"+baseURI+\", \"+rdfSyntax+\")\") ;\n-\n-        return loadModelWorker(filenameOrURI, baseURI, rdfSyntax) ;\n-    }\n-\n-    private Model loadModelWorker(String filenameOrURI, String baseURI, String rdfSyntax)\n-    {\n-        if ( hasCachedModel(filenameOrURI) )\n-        {\n-            if ( log.isDebugEnabled() )\n-                log.debug(\"Model cache hit: \"+filenameOrURI) ;\n-            return getFromCache(filenameOrURI) ;\n-        }\n-\n-        Model m = ModelFactory.createDefaultModel() ;\n-        readModelWorker(m, filenameOrURI, baseURI, rdfSyntax) ;\n-        \n-        if ( isCachingModels() )\n-            addCacheModel(filenameOrURI, m) ;\n-        return m ;\n-    }\n-    \n-    /**\n-     * Read a file of RDF into a model.  Guesses the syntax of the file based on filename extension, \n-     *  defaulting to RDF/XML.\n-     * @param model\n-     * @param filenameOrURI\n-     * @return The model or null, if there was an error.\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\")\") ;\n-        return readModel(model, filenameOrURI, null);\n-    }\n-    \n-    /**\n-     * Read a file of RDF into a model.\n-     * @param model\n-     * @param filenameOrURI\n-     * @param rdfSyntax RDF Serialization syntax.\n-     * @return The model or null, if there was an error.\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n-        return readModelWorker(model, filenameOrURI, null, rdfSyntax);\n-    }\n-\n-    /**\n-     * Read a file of RDF into a model.\n-     * @param model\n-     * @param filenameOrURI\n-     * @param baseURI\n-     * @param syntax\n-     * @return The model\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI, String baseURI, String syntax)\n-    {\n-        \n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+baseURI+\", \"+syntax+\")\") ;\n-        return readModelWorker(model, filenameOrURI, baseURI, syntax) ;\n-    }\n-    \n-    protected Model readModelWorker(Model model, String filenameOrURI, String baseURI, String syntax)\n-    {\n-        // Doesn't call open() - we want to make the syntax guess based on the mapped URI.\n-        String mappedURI = mapURI(filenameOrURI) ;\n-\n-        if ( log.isDebugEnabled() && ! mappedURI.equals(filenameOrURI) )\n-            log.debug(\"Map: \"+filenameOrURI+\" => \"+mappedURI) ;\n-\n-        if ( syntax == null && baseURI == null && mappedURI.startsWith( \"http:\" ) )\n-        {\n-            syntax = FileUtils.guessLang(mappedURI) ;\n-            // Content negotation in next version (FileManager2) \n-            model.read(mappedURI, syntax) ;\n-            return model ;\n-        }\n-        \n-        if ( syntax == null )\n-        {\n-            syntax = FileUtils.guessLang(mappedURI) ;\n-            if ( syntax == null || syntax.equals(\"\") )\n-                syntax = FileUtils.langXML ;\n-            if ( log.isDebugEnabled() ) \n-                log.debug(\"Syntax guess: \"+syntax);\n-        }\n-\n-        if ( baseURI == null )\n-            baseURI = chooseBaseURI(filenameOrURI) ;\n-\n-        TypedStream in = openNoMapOrNull(mappedURI) ;\n-        if ( in == null )\n-        {\n-            FmtLog.debug(log, \"Failed to locate '%s'\", mappedURI);\n-            throw new NotFoundException(\"Not found: \"+filenameOrURI) ;\n-        }\n-        if ( in.getMimeType() != null )\n-        {\n-            //syntax\n-        }\n-        model.read(in.getInput(), baseURI, syntax) ;\n-        try { in.getInput().close(); } catch (IOException ex) {}\n-        return model ;\n-    }\n-\n-    private static String chooseBaseURI(String baseURI)\n-    {\n-        String scheme = FileUtils.getScheme(baseURI) ;\n-        \n-        if ( scheme != null )\n-        {\n-            if ( scheme.equals(\"file\") )\n-            {\n-                if ( ! baseURI.startsWith(\"file:///\") )\n-                {\n-                    try {\n-                        // Fix up file URIs.  Yuk.\n-                        String tmp = baseURI.substring(\"file:\".length()) ;\n-                        File f = new File(tmp) ;\n-                        baseURI = \"file:///\"+f.getCanonicalPath() ;\n-                        baseURI = baseURI.replace('\\\\','/') ;\n-\n-//                        baseURI = baseURI.replace(\" \",\"%20\");\n-//                        baseURI = baseURI.replace(\"~\",\"%7E\");\n-                        // Convert to URI.  Except that it removes ///\n-                        // Could do that and fix up (again)\n-                        //java.net.URL u = new java.net.URL(baseURI) ;\n-                        //baseURI = u.toExternalForm() ;\n-                    } catch (Exception ex) {}\n-                }\n-            }\n-            return baseURI ;\n-        }\n-            \n-        if ( baseURI.startsWith(\"/\") )\n-            return \"file://\"+baseURI ;\n-        return \"file:\"+baseURI ;\n-    }\n-    \n-    /** Open a file using the locators of this FileManager */\n-    @Override\n-    public InputStream open(String filenameOrURI)\n-    {\n-        if ( log.isDebugEnabled())\n-            log.debug(\"open(\"+filenameOrURI+\")\") ;\n-        \n-        String uri = mapURI(filenameOrURI) ;\n-        \n-        if ( log.isDebugEnabled() && ! uri.equals(filenameOrURI) )\n-            log.debug(\"open: mapped to \"+uri) ;\n-        \n-        return openNoMap(uri) ;\n-    }\n-\n-\n-    /** Apply the mapping of a filename or URI */\n-    @Override\n-    public String mapURI(String filenameOrURI)\n-    {\n-        if ( fmMapper == null )\n-            return filenameOrURI ; \n-            \n-        String uri = fmMapper.altMapping(filenameOrURI, null) ;\n-\n-        if ( uri == null )\n-        {\n-            if ( FileManager.logAllLookups && log.isDebugEnabled() )\n-                log.debug(\"Not mapped: \"+filenameOrURI) ;\n-            uri = filenameOrURI ;\n-        }\n-        else\n-        {\n-            if ( log.isDebugEnabled() )\n-                log.debug(\"Mapped: \"+filenameOrURI+\" => \"+uri) ;\n-        }\n-        return uri ;\n-    }\n-    \n-    /** Slurp up a whole file */\n-    @Override\n-    public String readWholeFileAsUTF8(InputStream in)\n-    {\n-        try (Reader r = FileUtils.asBufferedUTF8(in); StringWriter sw = new StringWriter(1024)) {\n-            char buff[] = new char[1024] ;\n-            while (true) {\n-                int l = r.read(buff) ;\n-                if ( l <= 0 )\n-                    break ;\n-                sw.write(buff, 0, l) ;\n-            }\n-            return sw.toString() ;\n-        } catch (IOException ex)\n-        { throw new WrappedIOException(ex) ; }\n-    }\n-    \n-    /** Slurp up a whole file: map filename as necessary */\n-    @Override\n-    public String readWholeFileAsUTF8(String filename)\n-    {\n-        InputStream in = open(filename) ;\n-        if ( in == null )\n-            throw new NotFoundException(\"File not found: \"+filename) ;\n-        return readWholeFileAsUTF8(in) ;\n-    }\n-        \n-    /** Open a file using the locators of this FileManager \n-     *  but without location mapping */ \n-    @Override\n-    public InputStream openNoMap(String filenameOrURI)\n-    {\n-        TypedStream in = openNoMapOrNull(filenameOrURI) ;\n-        if ( in == null )\n-            return null ;\n-//        if ( in == null )\n-//            throw new NotFoundException(filenameOrURI) ;\n-        return in.getInput() ;\n-    }\n-    \n-    /** Open a file using the locators of this FileManager \n-     *  but without location mapping.\n-     *  Return null if not found\n-     */ \n-    \n-    @Override\n-    public TypedStream openNoMapOrNull(String filenameOrURI)\n-    {\n-        for (Locator loc : fmHandlers)\n-        {\n-            TypedStream in = loc.open(filenameOrURI) ;\n-            if ( in != null )\n-            {\n-                if ( log.isDebugEnabled() )\n-                    log.debug(\"Found: \"+filenameOrURI+\" (\"+loc.getName()+\")\") ;\n-                return in ;\n-            }\n-        }\n-        return null; \n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NzIxMw==", "url": "https://github.com/apache/jena/pull/759#discussion_r440597213", "bodyText": "Extra *", "author": "kinow", "createdAt": "2020-06-16T05:38:27Z", "path": "jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.util;\n+\n+import java.io.* ;\n+import java.util.* ;\n+\n+import org.apache.jena.atlas.logging.FmtLog;\n+import org.apache.jena.rdf.model.Model ;\n+import org.apache.jena.rdf.model.ModelFactory ;\n+import org.apache.jena.shared.JenaException ;\n+import org.apache.jena.shared.NotFoundException ;\n+import org.apache.jena.shared.WrappedIOException ;\n+import org.apache.jena.sys.JenaSystem ;\n+import org.slf4j.Logger ;\n+import org.slf4j.LoggerFactory ;\n+\n+/** FileManager\n+ * \n+ * A FileManager provides access to named file-like resources by opening\n+ * InputStreams to things in the filing system, by URL (http: and file:) and\n+ * found by the classloader.  It can also load RDF data from such a system\n+ * resource into an existing model or create a new (Memory-based) model.\n+ * There is a global FileManager which provide uniform access to system\n+ * resources: applications may also create specialised FileManagers.\n+ * \n+ * A FileManager contains a list of location functions to try: the global\n+ * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and\n+ * one {@link LocatorURL}\n+ * \n+ * Main operations:\n+ *  * <ul>", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dd3ee540c13087adca06cba5b170804e9de06e54", "chunk": "diff --git a/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java b/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java\ndeleted file mode 100644\nindex d32bb21464..0000000000\n--- a/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java\n+++ /dev/null\n\n@@ -1,566 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.jena.util;\n-\n-import java.io.* ;\n-import java.util.* ;\n-\n-import org.apache.jena.atlas.logging.FmtLog;\n-import org.apache.jena.rdf.model.Model ;\n-import org.apache.jena.rdf.model.ModelFactory ;\n-import org.apache.jena.shared.JenaException ;\n-import org.apache.jena.shared.NotFoundException ;\n-import org.apache.jena.shared.WrappedIOException ;\n-import org.apache.jena.sys.JenaSystem ;\n-import org.slf4j.Logger ;\n-import org.slf4j.LoggerFactory ;\n-\n-/** FileManager\n- * \n- * A FileManager provides access to named file-like resources by opening\n- * InputStreams to things in the filing system, by URL (http: and file:) and\n- * found by the classloader.  It can also load RDF data from such a system\n- * resource into an existing model or create a new (Memory-based) model.\n- * There is a global FileManager which provide uniform access to system\n- * resources: applications may also create specialised FileManagers.\n- * \n- * A FileManager contains a list of location functions to try: the global\n- * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and\n- * one {@link LocatorURL}\n- * \n- * Main operations:\n- *  * <ul>\n- * <li>loadModel, readModel : URI to model</li>\n- * <li>open, openNoMap : URI to input stream</li>\n- * <li>mapURI : map URI to another by {@link LocationMapper}</li> \n- * </ul>\n- * \n- * Utilities:\n- * <ul>\n- * <li>readWholeFileAsUTF8</li>\n- * <li>optional caching of models<li>\n- * </ul>\n- * \n- * A FileManager works in conjunction with a LocationMapper.\n- * A {@link LocationMapper} is a set of alternative locations for system\n- * resources and a set of alternative prefix locations.  For example, a local\n- * copy of a common RDF dataset may be used whenever the usual URL is used by\n- * the application.\n- *\n- * The {@link LocatorFile} also supports the idea of \"current directory\".\n- * \n- * @see LocationMapper\n- * @see FileUtils\n- */\n- \n-public class FileManagerImpl implements FileManager\n-{\n-    // The case of the FileManager used first.\n-    private static Logger log = LoggerFactory.getLogger(FileManager.class) ;\n-    \n-    /** Delimiter between path entries : because URI scheme names use : we only allow ; */\n-\n-    static FileManager fmInstance = null ;\n-\n-    protected List<Locator> fmHandlers = new ArrayList<>() ;\n-    protected LocationMapper fmMapper = null ;\n-    \n-    static { JenaSystem.init(); }\n-\n-    /** Get the global file manager.\n-     * @return the global file manager\n-     */\n-    public static FileManager get()\n-    {\n-        // Singleton pattern adopted in case we later have several file managers.\n-        if ( fmInstance == null )\n-            fmInstance = makeGlobal() ;\n-        return fmInstance ;\n-    }\n-    \n-    /** Set the global file manager (as returned by get())\n-     * If called before any call to get(), then the usual default filemanager is not created \n-     * @param globalFileManager\n-     */\n-    public static void setGlobalFileManager(FileManager globalFileManager)\n-    {\n-        fmInstance = globalFileManager ;\n-    }\n-    \n-    /** Create an uninitialized FileManager */\n-\n-    protected FileManagerImpl() {}\n-    \n-    protected static FileManager makeStd() {\n-        FileManagerImpl fm = new FileManagerImpl();\n-        setStdLocators(fm);\n-        return fm;\n-    }\n-    \n-    /** Create with the given location mapper */\n-    protected FileManagerImpl(LocationMapper _mapper)    { setLocationMapper(_mapper) ; }\n-\n-    @Override\n-    public FileManager clone() { return clone(this) ; } \n- \n-    // Isolate to help avoid copy errors.\n-    private static FileManager clone(FileManagerImpl filemanager) {\n-        FileManagerImpl newFm = new FileManagerImpl() ;\n-        newFm.fmHandlers.addAll(filemanager.fmHandlers) ;\n-        newFm.fmMapper = null ;\n-        if ( filemanager.getLocationMapper() != null )\n-            newFm.fmMapper = new LocationMapper(filemanager.getLocationMapper()) ;\n-        newFm.cacheModelLoads = false ;\n-        newFm.modelCache = null ;\n-        return newFm ;\n-    }\n-\n-    /** Create a \"standard\" FileManager. */\n-    public static FileManager makeGlobal()\n-    {\n-        FileManagerImpl fMgr = new FileManagerImpl(LocationMapper.get()) ;\n-        setStdLocators(fMgr) ;\n-        return fMgr ;\n-    }\n-    \n-    /** Force a file handler to have the default configuration. */\n-    private static void setStdLocators(FileManagerImpl fMgr)\n-    {\n-        fMgr.fmHandlers.clear() ;\n-        fMgr.addLocatorFile() ;\n-        fMgr.addLocatorURL() ;\n-        fMgr.addLocatorClassLoader(fMgr.getClass().getClassLoader()) ;\n-    }\n-    /** Set the location mapping */\n-    @Override\n-    public void setLocationMapper(LocationMapper _mapper) { fmMapper = _mapper ; }\n-    \n-    /** Get the location mapping */\n-    @Override\n-    public LocationMapper getLocationMapper() { return fmMapper ; }\n-    \n-    /** Return an iterator over all the handlers */\n-    @Override\n-    public Iterator<Locator> locators() { return fmHandlers.listIterator() ; }\n-\n-    /** Add a locator to the end of the locators list */ \n-    @Override\n-    public void addLocator(Locator loc)\n-    {\n-        log.debug(\"Add location: \"+loc.getName()) ;\n-        fmHandlers.add(loc) ; }\n-\n-    /** Add a file locator */ \n-    @Override\n-    public void addLocatorFile() { addLocatorFile(null) ; } \n-\n-    /** Add a file locator which uses dir as its working directory */ \n-    @Override\n-    public void addLocatorFile(String dir)\n-    {\n-        LocatorFile fLoc = new LocatorFile(dir) ;\n-        addLocator(fLoc) ;\n-    }\n-    \n-    /** Add a class loader locator */ \n-    @Override\n-    public void addLocatorClassLoader(ClassLoader cLoad)\n-    {\n-        LocatorClassLoader cLoc = new LocatorClassLoader(cLoad) ;\n-        addLocator(cLoc) ;\n-    }\n-\n-    /** Add a URL locator */\n-    @Override\n-    public void addLocatorURL()\n-    {\n-        Locator loc = new LocatorURL() ;\n-        addLocator(loc) ;\n-    }\n-\n-    /** Add a zip file locator */\n-    @Override\n-    public void addLocatorZip(String zfn)\n-    {\n-        Locator loc = new LocatorZip(zfn) ;\n-        addLocator(loc) ;\n-    }\n-\n-    \n-    /** Remove a locator */ \n-    @Override\n-    public void remove(Locator loc) { fmHandlers.remove(loc) ; }\n-\n-    // -------- Cache operations\n-    boolean cacheModelLoads = false ;\n-    Map<String, Model> modelCache = null ;\n-    \n-    /** Reset the model cache */\n-    @Override\n-    public void resetCache()\n-    {\n-        if ( modelCache != null )\n-            modelCache.clear() ;\n-    }\n-    \n-    /** Change the state of model cache : does not clear the cache */ \n-    @Override\n-    public void setModelCaching(boolean state)\n-    {\n-        cacheModelLoads = state ;\n-        if ( cacheModelLoads && modelCache == null )\n-            modelCache = new HashMap<String, Model>() ;\n-    }\n-\n-    /** return whether caching is on of off */\n-    @Override\n-    public boolean isCachingModels() { return cacheModelLoads ; }\n-    \n-    /** Read out of the cache - return null if not in the cache */ \n-    @Override\n-    public Model getFromCache(String filenameOrURI)\n-    { \n-        if ( ! isCachingModels() )\n-            return null; \n-        return modelCache.get(filenameOrURI) ;\n-    }\n-    \n-    @Override\n-    public boolean hasCachedModel(String filenameOrURI)\n-    { \n-        if ( ! isCachingModels() )\n-            return false ; \n-        return modelCache.containsKey(filenameOrURI) ;\n-    }\n-    \n-    @Override\n-    public void addCacheModel(String uri, Model m)\n-    { \n-        if ( isCachingModels() )\n-            modelCache.put(uri, m) ;\n-    }\n-\n-    @Override\n-    public void removeCacheModel(String uri)\n-    { \n-        if ( isCachingModels() )\n-            modelCache.remove(uri) ;\n-    }\n-\n-    // -------- Cache operations (end)\n-\n-    /** Load a model from a file (local or remote).\n-     *  This operation may attempt content negotiation for http URLs.\n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-     */\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI)\n-    { \n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\")\") ;\n-        \n-        return loadModelWorker(filenameOrURI, null, null) ;\n-    }\n-\n-    /** Load a model from a file (local or remote).\n-     *  URI is the base for reading the model.\n-     * \n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @param rdfSyntax  RDF Serialization syntax. \n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-     */\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n-        return loadModelWorker(filenameOrURI, null, rdfSyntax) ;\n-    }\n-    \n-    /** Load a model from a file (local or remote).\n-     * \n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @param baseURI  Base URI for loading the RDF model.\n-     *  @param rdfSyntax  RDF Serialization syntax. \n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-    */\n-\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI, String baseURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\", \"+baseURI+\", \"+rdfSyntax+\")\") ;\n-\n-        return loadModelWorker(filenameOrURI, baseURI, rdfSyntax) ;\n-    }\n-\n-    private Model loadModelWorker(String filenameOrURI, String baseURI, String rdfSyntax)\n-    {\n-        if ( hasCachedModel(filenameOrURI) )\n-        {\n-            if ( log.isDebugEnabled() )\n-                log.debug(\"Model cache hit: \"+filenameOrURI) ;\n-            return getFromCache(filenameOrURI) ;\n-        }\n-\n-        Model m = ModelFactory.createDefaultModel() ;\n-        readModelWorker(m, filenameOrURI, baseURI, rdfSyntax) ;\n-        \n-        if ( isCachingModels() )\n-            addCacheModel(filenameOrURI, m) ;\n-        return m ;\n-    }\n-    \n-    /**\n-     * Read a file of RDF into a model.  Guesses the syntax of the file based on filename extension, \n-     *  defaulting to RDF/XML.\n-     * @param model\n-     * @param filenameOrURI\n-     * @return The model or null, if there was an error.\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\")\") ;\n-        return readModel(model, filenameOrURI, null);\n-    }\n-    \n-    /**\n-     * Read a file of RDF into a model.\n-     * @param model\n-     * @param filenameOrURI\n-     * @param rdfSyntax RDF Serialization syntax.\n-     * @return The model or null, if there was an error.\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n-        return readModelWorker(model, filenameOrURI, null, rdfSyntax);\n-    }\n-\n-    /**\n-     * Read a file of RDF into a model.\n-     * @param model\n-     * @param filenameOrURI\n-     * @param baseURI\n-     * @param syntax\n-     * @return The model\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI, String baseURI, String syntax)\n-    {\n-        \n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+baseURI+\", \"+syntax+\")\") ;\n-        return readModelWorker(model, filenameOrURI, baseURI, syntax) ;\n-    }\n-    \n-    protected Model readModelWorker(Model model, String filenameOrURI, String baseURI, String syntax)\n-    {\n-        // Doesn't call open() - we want to make the syntax guess based on the mapped URI.\n-        String mappedURI = mapURI(filenameOrURI) ;\n-\n-        if ( log.isDebugEnabled() && ! mappedURI.equals(filenameOrURI) )\n-            log.debug(\"Map: \"+filenameOrURI+\" => \"+mappedURI) ;\n-\n-        if ( syntax == null && baseURI == null && mappedURI.startsWith( \"http:\" ) )\n-        {\n-            syntax = FileUtils.guessLang(mappedURI) ;\n-            // Content negotation in next version (FileManager2) \n-            model.read(mappedURI, syntax) ;\n-            return model ;\n-        }\n-        \n-        if ( syntax == null )\n-        {\n-            syntax = FileUtils.guessLang(mappedURI) ;\n-            if ( syntax == null || syntax.equals(\"\") )\n-                syntax = FileUtils.langXML ;\n-            if ( log.isDebugEnabled() ) \n-                log.debug(\"Syntax guess: \"+syntax);\n-        }\n-\n-        if ( baseURI == null )\n-            baseURI = chooseBaseURI(filenameOrURI) ;\n-\n-        TypedStream in = openNoMapOrNull(mappedURI) ;\n-        if ( in == null )\n-        {\n-            FmtLog.debug(log, \"Failed to locate '%s'\", mappedURI);\n-            throw new NotFoundException(\"Not found: \"+filenameOrURI) ;\n-        }\n-        if ( in.getMimeType() != null )\n-        {\n-            //syntax\n-        }\n-        model.read(in.getInput(), baseURI, syntax) ;\n-        try { in.getInput().close(); } catch (IOException ex) {}\n-        return model ;\n-    }\n-\n-    private static String chooseBaseURI(String baseURI)\n-    {\n-        String scheme = FileUtils.getScheme(baseURI) ;\n-        \n-        if ( scheme != null )\n-        {\n-            if ( scheme.equals(\"file\") )\n-            {\n-                if ( ! baseURI.startsWith(\"file:///\") )\n-                {\n-                    try {\n-                        // Fix up file URIs.  Yuk.\n-                        String tmp = baseURI.substring(\"file:\".length()) ;\n-                        File f = new File(tmp) ;\n-                        baseURI = \"file:///\"+f.getCanonicalPath() ;\n-                        baseURI = baseURI.replace('\\\\','/') ;\n-\n-//                        baseURI = baseURI.replace(\" \",\"%20\");\n-//                        baseURI = baseURI.replace(\"~\",\"%7E\");\n-                        // Convert to URI.  Except that it removes ///\n-                        // Could do that and fix up (again)\n-                        //java.net.URL u = new java.net.URL(baseURI) ;\n-                        //baseURI = u.toExternalForm() ;\n-                    } catch (Exception ex) {}\n-                }\n-            }\n-            return baseURI ;\n-        }\n-            \n-        if ( baseURI.startsWith(\"/\") )\n-            return \"file://\"+baseURI ;\n-        return \"file:\"+baseURI ;\n-    }\n-    \n-    /** Open a file using the locators of this FileManager */\n-    @Override\n-    public InputStream open(String filenameOrURI)\n-    {\n-        if ( log.isDebugEnabled())\n-            log.debug(\"open(\"+filenameOrURI+\")\") ;\n-        \n-        String uri = mapURI(filenameOrURI) ;\n-        \n-        if ( log.isDebugEnabled() && ! uri.equals(filenameOrURI) )\n-            log.debug(\"open: mapped to \"+uri) ;\n-        \n-        return openNoMap(uri) ;\n-    }\n-\n-\n-    /** Apply the mapping of a filename or URI */\n-    @Override\n-    public String mapURI(String filenameOrURI)\n-    {\n-        if ( fmMapper == null )\n-            return filenameOrURI ; \n-            \n-        String uri = fmMapper.altMapping(filenameOrURI, null) ;\n-\n-        if ( uri == null )\n-        {\n-            if ( FileManager.logAllLookups && log.isDebugEnabled() )\n-                log.debug(\"Not mapped: \"+filenameOrURI) ;\n-            uri = filenameOrURI ;\n-        }\n-        else\n-        {\n-            if ( log.isDebugEnabled() )\n-                log.debug(\"Mapped: \"+filenameOrURI+\" => \"+uri) ;\n-        }\n-        return uri ;\n-    }\n-    \n-    /** Slurp up a whole file */\n-    @Override\n-    public String readWholeFileAsUTF8(InputStream in)\n-    {\n-        try (Reader r = FileUtils.asBufferedUTF8(in); StringWriter sw = new StringWriter(1024)) {\n-            char buff[] = new char[1024] ;\n-            while (true) {\n-                int l = r.read(buff) ;\n-                if ( l <= 0 )\n-                    break ;\n-                sw.write(buff, 0, l) ;\n-            }\n-            return sw.toString() ;\n-        } catch (IOException ex)\n-        { throw new WrappedIOException(ex) ; }\n-    }\n-    \n-    /** Slurp up a whole file: map filename as necessary */\n-    @Override\n-    public String readWholeFileAsUTF8(String filename)\n-    {\n-        InputStream in = open(filename) ;\n-        if ( in == null )\n-            throw new NotFoundException(\"File not found: \"+filename) ;\n-        return readWholeFileAsUTF8(in) ;\n-    }\n-        \n-    /** Open a file using the locators of this FileManager \n-     *  but without location mapping */ \n-    @Override\n-    public InputStream openNoMap(String filenameOrURI)\n-    {\n-        TypedStream in = openNoMapOrNull(filenameOrURI) ;\n-        if ( in == null )\n-            return null ;\n-//        if ( in == null )\n-//            throw new NotFoundException(filenameOrURI) ;\n-        return in.getInput() ;\n-    }\n-    \n-    /** Open a file using the locators of this FileManager \n-     *  but without location mapping.\n-     *  Return null if not found\n-     */ \n-    \n-    @Override\n-    public TypedStream openNoMapOrNull(String filenameOrURI)\n-    {\n-        for (Locator loc : fmHandlers)\n-        {\n-            TypedStream in = loc.open(filenameOrURI) ;\n-            if ( in != null )\n-            {\n-                if ( log.isDebugEnabled() )\n-                    log.debug(\"Found: \"+filenameOrURI+\" (\"+loc.getName()+\")\") ;\n-                return in ;\n-            }\n-        }\n-        return null; \n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5ODA0MA==", "url": "https://github.com/apache/jena/pull/759#discussion_r440598040", "bodyText": "Should this method be made synchronized, or should we tell users of this code that it is not thread-safe? (I think it's not, but my Java-fu is getting utterly confused due to writing more JS & Python at $work)", "author": "kinow", "createdAt": "2020-06-16T05:41:23Z", "path": "jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.util;\n+\n+import java.io.* ;\n+import java.util.* ;\n+\n+import org.apache.jena.atlas.logging.FmtLog;\n+import org.apache.jena.rdf.model.Model ;\n+import org.apache.jena.rdf.model.ModelFactory ;\n+import org.apache.jena.shared.JenaException ;\n+import org.apache.jena.shared.NotFoundException ;\n+import org.apache.jena.shared.WrappedIOException ;\n+import org.apache.jena.sys.JenaSystem ;\n+import org.slf4j.Logger ;\n+import org.slf4j.LoggerFactory ;\n+\n+/** FileManager\n+ * \n+ * A FileManager provides access to named file-like resources by opening\n+ * InputStreams to things in the filing system, by URL (http: and file:) and\n+ * found by the classloader.  It can also load RDF data from such a system\n+ * resource into an existing model or create a new (Memory-based) model.\n+ * There is a global FileManager which provide uniform access to system\n+ * resources: applications may also create specialised FileManagers.\n+ * \n+ * A FileManager contains a list of location functions to try: the global\n+ * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and\n+ * one {@link LocatorURL}\n+ * \n+ * Main operations:\n+ *  * <ul>\n+ * <li>loadModel, readModel : URI to model</li>\n+ * <li>open, openNoMap : URI to input stream</li>\n+ * <li>mapURI : map URI to another by {@link LocationMapper}</li> \n+ * </ul>\n+ * \n+ * Utilities:\n+ * <ul>\n+ * <li>readWholeFileAsUTF8</li>\n+ * <li>optional caching of models<li>\n+ * </ul>\n+ * \n+ * A FileManager works in conjunction with a LocationMapper.\n+ * A {@link LocationMapper} is a set of alternative locations for system\n+ * resources and a set of alternative prefix locations.  For example, a local\n+ * copy of a common RDF dataset may be used whenever the usual URL is used by\n+ * the application.\n+ *\n+ * The {@link LocatorFile} also supports the idea of \"current directory\".\n+ * \n+ * @see LocationMapper\n+ * @see FileUtils\n+ */\n+ \n+public class FileManagerImpl implements FileManager\n+{\n+    // The case of the FileManager used first.\n+    private static Logger log = LoggerFactory.getLogger(FileManager.class) ;\n+    \n+    /** Delimiter between path entries : because URI scheme names use : we only allow ; */\n+\n+    static FileManager fmInstance = null ;\n+\n+    protected List<Locator> fmHandlers = new ArrayList<>() ;\n+    protected LocationMapper fmMapper = null ;\n+    \n+    static { JenaSystem.init(); }\n+\n+    /** Get the global file manager.\n+     * @return the global file manager\n+     */\n+    public static FileManager get()\n+    {\n+        // Singleton pattern adopted in case we later have several file managers.\n+        if ( fmInstance == null )", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dd3ee540c13087adca06cba5b170804e9de06e54", "chunk": "diff --git a/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java b/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java\ndeleted file mode 100644\nindex d32bb21464..0000000000\n--- a/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java\n+++ /dev/null\n\n@@ -1,566 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.jena.util;\n-\n-import java.io.* ;\n-import java.util.* ;\n-\n-import org.apache.jena.atlas.logging.FmtLog;\n-import org.apache.jena.rdf.model.Model ;\n-import org.apache.jena.rdf.model.ModelFactory ;\n-import org.apache.jena.shared.JenaException ;\n-import org.apache.jena.shared.NotFoundException ;\n-import org.apache.jena.shared.WrappedIOException ;\n-import org.apache.jena.sys.JenaSystem ;\n-import org.slf4j.Logger ;\n-import org.slf4j.LoggerFactory ;\n-\n-/** FileManager\n- * \n- * A FileManager provides access to named file-like resources by opening\n- * InputStreams to things in the filing system, by URL (http: and file:) and\n- * found by the classloader.  It can also load RDF data from such a system\n- * resource into an existing model or create a new (Memory-based) model.\n- * There is a global FileManager which provide uniform access to system\n- * resources: applications may also create specialised FileManagers.\n- * \n- * A FileManager contains a list of location functions to try: the global\n- * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and\n- * one {@link LocatorURL}\n- * \n- * Main operations:\n- *  * <ul>\n- * <li>loadModel, readModel : URI to model</li>\n- * <li>open, openNoMap : URI to input stream</li>\n- * <li>mapURI : map URI to another by {@link LocationMapper}</li> \n- * </ul>\n- * \n- * Utilities:\n- * <ul>\n- * <li>readWholeFileAsUTF8</li>\n- * <li>optional caching of models<li>\n- * </ul>\n- * \n- * A FileManager works in conjunction with a LocationMapper.\n- * A {@link LocationMapper} is a set of alternative locations for system\n- * resources and a set of alternative prefix locations.  For example, a local\n- * copy of a common RDF dataset may be used whenever the usual URL is used by\n- * the application.\n- *\n- * The {@link LocatorFile} also supports the idea of \"current directory\".\n- * \n- * @see LocationMapper\n- * @see FileUtils\n- */\n- \n-public class FileManagerImpl implements FileManager\n-{\n-    // The case of the FileManager used first.\n-    private static Logger log = LoggerFactory.getLogger(FileManager.class) ;\n-    \n-    /** Delimiter between path entries : because URI scheme names use : we only allow ; */\n-\n-    static FileManager fmInstance = null ;\n-\n-    protected List<Locator> fmHandlers = new ArrayList<>() ;\n-    protected LocationMapper fmMapper = null ;\n-    \n-    static { JenaSystem.init(); }\n-\n-    /** Get the global file manager.\n-     * @return the global file manager\n-     */\n-    public static FileManager get()\n-    {\n-        // Singleton pattern adopted in case we later have several file managers.\n-        if ( fmInstance == null )\n-            fmInstance = makeGlobal() ;\n-        return fmInstance ;\n-    }\n-    \n-    /** Set the global file manager (as returned by get())\n-     * If called before any call to get(), then the usual default filemanager is not created \n-     * @param globalFileManager\n-     */\n-    public static void setGlobalFileManager(FileManager globalFileManager)\n-    {\n-        fmInstance = globalFileManager ;\n-    }\n-    \n-    /** Create an uninitialized FileManager */\n-\n-    protected FileManagerImpl() {}\n-    \n-    protected static FileManager makeStd() {\n-        FileManagerImpl fm = new FileManagerImpl();\n-        setStdLocators(fm);\n-        return fm;\n-    }\n-    \n-    /** Create with the given location mapper */\n-    protected FileManagerImpl(LocationMapper _mapper)    { setLocationMapper(_mapper) ; }\n-\n-    @Override\n-    public FileManager clone() { return clone(this) ; } \n- \n-    // Isolate to help avoid copy errors.\n-    private static FileManager clone(FileManagerImpl filemanager) {\n-        FileManagerImpl newFm = new FileManagerImpl() ;\n-        newFm.fmHandlers.addAll(filemanager.fmHandlers) ;\n-        newFm.fmMapper = null ;\n-        if ( filemanager.getLocationMapper() != null )\n-            newFm.fmMapper = new LocationMapper(filemanager.getLocationMapper()) ;\n-        newFm.cacheModelLoads = false ;\n-        newFm.modelCache = null ;\n-        return newFm ;\n-    }\n-\n-    /** Create a \"standard\" FileManager. */\n-    public static FileManager makeGlobal()\n-    {\n-        FileManagerImpl fMgr = new FileManagerImpl(LocationMapper.get()) ;\n-        setStdLocators(fMgr) ;\n-        return fMgr ;\n-    }\n-    \n-    /** Force a file handler to have the default configuration. */\n-    private static void setStdLocators(FileManagerImpl fMgr)\n-    {\n-        fMgr.fmHandlers.clear() ;\n-        fMgr.addLocatorFile() ;\n-        fMgr.addLocatorURL() ;\n-        fMgr.addLocatorClassLoader(fMgr.getClass().getClassLoader()) ;\n-    }\n-    /** Set the location mapping */\n-    @Override\n-    public void setLocationMapper(LocationMapper _mapper) { fmMapper = _mapper ; }\n-    \n-    /** Get the location mapping */\n-    @Override\n-    public LocationMapper getLocationMapper() { return fmMapper ; }\n-    \n-    /** Return an iterator over all the handlers */\n-    @Override\n-    public Iterator<Locator> locators() { return fmHandlers.listIterator() ; }\n-\n-    /** Add a locator to the end of the locators list */ \n-    @Override\n-    public void addLocator(Locator loc)\n-    {\n-        log.debug(\"Add location: \"+loc.getName()) ;\n-        fmHandlers.add(loc) ; }\n-\n-    /** Add a file locator */ \n-    @Override\n-    public void addLocatorFile() { addLocatorFile(null) ; } \n-\n-    /** Add a file locator which uses dir as its working directory */ \n-    @Override\n-    public void addLocatorFile(String dir)\n-    {\n-        LocatorFile fLoc = new LocatorFile(dir) ;\n-        addLocator(fLoc) ;\n-    }\n-    \n-    /** Add a class loader locator */ \n-    @Override\n-    public void addLocatorClassLoader(ClassLoader cLoad)\n-    {\n-        LocatorClassLoader cLoc = new LocatorClassLoader(cLoad) ;\n-        addLocator(cLoc) ;\n-    }\n-\n-    /** Add a URL locator */\n-    @Override\n-    public void addLocatorURL()\n-    {\n-        Locator loc = new LocatorURL() ;\n-        addLocator(loc) ;\n-    }\n-\n-    /** Add a zip file locator */\n-    @Override\n-    public void addLocatorZip(String zfn)\n-    {\n-        Locator loc = new LocatorZip(zfn) ;\n-        addLocator(loc) ;\n-    }\n-\n-    \n-    /** Remove a locator */ \n-    @Override\n-    public void remove(Locator loc) { fmHandlers.remove(loc) ; }\n-\n-    // -------- Cache operations\n-    boolean cacheModelLoads = false ;\n-    Map<String, Model> modelCache = null ;\n-    \n-    /** Reset the model cache */\n-    @Override\n-    public void resetCache()\n-    {\n-        if ( modelCache != null )\n-            modelCache.clear() ;\n-    }\n-    \n-    /** Change the state of model cache : does not clear the cache */ \n-    @Override\n-    public void setModelCaching(boolean state)\n-    {\n-        cacheModelLoads = state ;\n-        if ( cacheModelLoads && modelCache == null )\n-            modelCache = new HashMap<String, Model>() ;\n-    }\n-\n-    /** return whether caching is on of off */\n-    @Override\n-    public boolean isCachingModels() { return cacheModelLoads ; }\n-    \n-    /** Read out of the cache - return null if not in the cache */ \n-    @Override\n-    public Model getFromCache(String filenameOrURI)\n-    { \n-        if ( ! isCachingModels() )\n-            return null; \n-        return modelCache.get(filenameOrURI) ;\n-    }\n-    \n-    @Override\n-    public boolean hasCachedModel(String filenameOrURI)\n-    { \n-        if ( ! isCachingModels() )\n-            return false ; \n-        return modelCache.containsKey(filenameOrURI) ;\n-    }\n-    \n-    @Override\n-    public void addCacheModel(String uri, Model m)\n-    { \n-        if ( isCachingModels() )\n-            modelCache.put(uri, m) ;\n-    }\n-\n-    @Override\n-    public void removeCacheModel(String uri)\n-    { \n-        if ( isCachingModels() )\n-            modelCache.remove(uri) ;\n-    }\n-\n-    // -------- Cache operations (end)\n-\n-    /** Load a model from a file (local or remote).\n-     *  This operation may attempt content negotiation for http URLs.\n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-     */\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI)\n-    { \n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\")\") ;\n-        \n-        return loadModelWorker(filenameOrURI, null, null) ;\n-    }\n-\n-    /** Load a model from a file (local or remote).\n-     *  URI is the base for reading the model.\n-     * \n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @param rdfSyntax  RDF Serialization syntax. \n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-     */\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n-        return loadModelWorker(filenameOrURI, null, rdfSyntax) ;\n-    }\n-    \n-    /** Load a model from a file (local or remote).\n-     * \n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @param baseURI  Base URI for loading the RDF model.\n-     *  @param rdfSyntax  RDF Serialization syntax. \n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-    */\n-\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI, String baseURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\", \"+baseURI+\", \"+rdfSyntax+\")\") ;\n-\n-        return loadModelWorker(filenameOrURI, baseURI, rdfSyntax) ;\n-    }\n-\n-    private Model loadModelWorker(String filenameOrURI, String baseURI, String rdfSyntax)\n-    {\n-        if ( hasCachedModel(filenameOrURI) )\n-        {\n-            if ( log.isDebugEnabled() )\n-                log.debug(\"Model cache hit: \"+filenameOrURI) ;\n-            return getFromCache(filenameOrURI) ;\n-        }\n-\n-        Model m = ModelFactory.createDefaultModel() ;\n-        readModelWorker(m, filenameOrURI, baseURI, rdfSyntax) ;\n-        \n-        if ( isCachingModels() )\n-            addCacheModel(filenameOrURI, m) ;\n-        return m ;\n-    }\n-    \n-    /**\n-     * Read a file of RDF into a model.  Guesses the syntax of the file based on filename extension, \n-     *  defaulting to RDF/XML.\n-     * @param model\n-     * @param filenameOrURI\n-     * @return The model or null, if there was an error.\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\")\") ;\n-        return readModel(model, filenameOrURI, null);\n-    }\n-    \n-    /**\n-     * Read a file of RDF into a model.\n-     * @param model\n-     * @param filenameOrURI\n-     * @param rdfSyntax RDF Serialization syntax.\n-     * @return The model or null, if there was an error.\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n-        return readModelWorker(model, filenameOrURI, null, rdfSyntax);\n-    }\n-\n-    /**\n-     * Read a file of RDF into a model.\n-     * @param model\n-     * @param filenameOrURI\n-     * @param baseURI\n-     * @param syntax\n-     * @return The model\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI, String baseURI, String syntax)\n-    {\n-        \n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+baseURI+\", \"+syntax+\")\") ;\n-        return readModelWorker(model, filenameOrURI, baseURI, syntax) ;\n-    }\n-    \n-    protected Model readModelWorker(Model model, String filenameOrURI, String baseURI, String syntax)\n-    {\n-        // Doesn't call open() - we want to make the syntax guess based on the mapped URI.\n-        String mappedURI = mapURI(filenameOrURI) ;\n-\n-        if ( log.isDebugEnabled() && ! mappedURI.equals(filenameOrURI) )\n-            log.debug(\"Map: \"+filenameOrURI+\" => \"+mappedURI) ;\n-\n-        if ( syntax == null && baseURI == null && mappedURI.startsWith( \"http:\" ) )\n-        {\n-            syntax = FileUtils.guessLang(mappedURI) ;\n-            // Content negotation in next version (FileManager2) \n-            model.read(mappedURI, syntax) ;\n-            return model ;\n-        }\n-        \n-        if ( syntax == null )\n-        {\n-            syntax = FileUtils.guessLang(mappedURI) ;\n-            if ( syntax == null || syntax.equals(\"\") )\n-                syntax = FileUtils.langXML ;\n-            if ( log.isDebugEnabled() ) \n-                log.debug(\"Syntax guess: \"+syntax);\n-        }\n-\n-        if ( baseURI == null )\n-            baseURI = chooseBaseURI(filenameOrURI) ;\n-\n-        TypedStream in = openNoMapOrNull(mappedURI) ;\n-        if ( in == null )\n-        {\n-            FmtLog.debug(log, \"Failed to locate '%s'\", mappedURI);\n-            throw new NotFoundException(\"Not found: \"+filenameOrURI) ;\n-        }\n-        if ( in.getMimeType() != null )\n-        {\n-            //syntax\n-        }\n-        model.read(in.getInput(), baseURI, syntax) ;\n-        try { in.getInput().close(); } catch (IOException ex) {}\n-        return model ;\n-    }\n-\n-    private static String chooseBaseURI(String baseURI)\n-    {\n-        String scheme = FileUtils.getScheme(baseURI) ;\n-        \n-        if ( scheme != null )\n-        {\n-            if ( scheme.equals(\"file\") )\n-            {\n-                if ( ! baseURI.startsWith(\"file:///\") )\n-                {\n-                    try {\n-                        // Fix up file URIs.  Yuk.\n-                        String tmp = baseURI.substring(\"file:\".length()) ;\n-                        File f = new File(tmp) ;\n-                        baseURI = \"file:///\"+f.getCanonicalPath() ;\n-                        baseURI = baseURI.replace('\\\\','/') ;\n-\n-//                        baseURI = baseURI.replace(\" \",\"%20\");\n-//                        baseURI = baseURI.replace(\"~\",\"%7E\");\n-                        // Convert to URI.  Except that it removes ///\n-                        // Could do that and fix up (again)\n-                        //java.net.URL u = new java.net.URL(baseURI) ;\n-                        //baseURI = u.toExternalForm() ;\n-                    } catch (Exception ex) {}\n-                }\n-            }\n-            return baseURI ;\n-        }\n-            \n-        if ( baseURI.startsWith(\"/\") )\n-            return \"file://\"+baseURI ;\n-        return \"file:\"+baseURI ;\n-    }\n-    \n-    /** Open a file using the locators of this FileManager */\n-    @Override\n-    public InputStream open(String filenameOrURI)\n-    {\n-        if ( log.isDebugEnabled())\n-            log.debug(\"open(\"+filenameOrURI+\")\") ;\n-        \n-        String uri = mapURI(filenameOrURI) ;\n-        \n-        if ( log.isDebugEnabled() && ! uri.equals(filenameOrURI) )\n-            log.debug(\"open: mapped to \"+uri) ;\n-        \n-        return openNoMap(uri) ;\n-    }\n-\n-\n-    /** Apply the mapping of a filename or URI */\n-    @Override\n-    public String mapURI(String filenameOrURI)\n-    {\n-        if ( fmMapper == null )\n-            return filenameOrURI ; \n-            \n-        String uri = fmMapper.altMapping(filenameOrURI, null) ;\n-\n-        if ( uri == null )\n-        {\n-            if ( FileManager.logAllLookups && log.isDebugEnabled() )\n-                log.debug(\"Not mapped: \"+filenameOrURI) ;\n-            uri = filenameOrURI ;\n-        }\n-        else\n-        {\n-            if ( log.isDebugEnabled() )\n-                log.debug(\"Mapped: \"+filenameOrURI+\" => \"+uri) ;\n-        }\n-        return uri ;\n-    }\n-    \n-    /** Slurp up a whole file */\n-    @Override\n-    public String readWholeFileAsUTF8(InputStream in)\n-    {\n-        try (Reader r = FileUtils.asBufferedUTF8(in); StringWriter sw = new StringWriter(1024)) {\n-            char buff[] = new char[1024] ;\n-            while (true) {\n-                int l = r.read(buff) ;\n-                if ( l <= 0 )\n-                    break ;\n-                sw.write(buff, 0, l) ;\n-            }\n-            return sw.toString() ;\n-        } catch (IOException ex)\n-        { throw new WrappedIOException(ex) ; }\n-    }\n-    \n-    /** Slurp up a whole file: map filename as necessary */\n-    @Override\n-    public String readWholeFileAsUTF8(String filename)\n-    {\n-        InputStream in = open(filename) ;\n-        if ( in == null )\n-            throw new NotFoundException(\"File not found: \"+filename) ;\n-        return readWholeFileAsUTF8(in) ;\n-    }\n-        \n-    /** Open a file using the locators of this FileManager \n-     *  but without location mapping */ \n-    @Override\n-    public InputStream openNoMap(String filenameOrURI)\n-    {\n-        TypedStream in = openNoMapOrNull(filenameOrURI) ;\n-        if ( in == null )\n-            return null ;\n-//        if ( in == null )\n-//            throw new NotFoundException(filenameOrURI) ;\n-        return in.getInput() ;\n-    }\n-    \n-    /** Open a file using the locators of this FileManager \n-     *  but without location mapping.\n-     *  Return null if not found\n-     */ \n-    \n-    @Override\n-    public TypedStream openNoMapOrNull(String filenameOrURI)\n-    {\n-        for (Locator loc : fmHandlers)\n-        {\n-            TypedStream in = loc.open(filenameOrURI) ;\n-            if ( in != null )\n-            {\n-                if ( log.isDebugEnabled() )\n-                    log.debug(\"Found: \"+filenameOrURI+\" (\"+loc.getName()+\")\") ;\n-                return in ;\n-            }\n-        }\n-        return null; \n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5OTc2NQ==", "url": "https://github.com/apache/jena/pull/759#discussion_r440599765", "bodyText": "\ud83d\ude04", "author": "kinow", "createdAt": "2020-06-16T05:47:33Z", "path": "jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.util;\n+\n+import java.io.* ;\n+import java.util.* ;\n+\n+import org.apache.jena.atlas.logging.FmtLog;\n+import org.apache.jena.rdf.model.Model ;\n+import org.apache.jena.rdf.model.ModelFactory ;\n+import org.apache.jena.shared.JenaException ;\n+import org.apache.jena.shared.NotFoundException ;\n+import org.apache.jena.shared.WrappedIOException ;\n+import org.apache.jena.sys.JenaSystem ;\n+import org.slf4j.Logger ;\n+import org.slf4j.LoggerFactory ;\n+\n+/** FileManager\n+ * \n+ * A FileManager provides access to named file-like resources by opening\n+ * InputStreams to things in the filing system, by URL (http: and file:) and\n+ * found by the classloader.  It can also load RDF data from such a system\n+ * resource into an existing model or create a new (Memory-based) model.\n+ * There is a global FileManager which provide uniform access to system\n+ * resources: applications may also create specialised FileManagers.\n+ * \n+ * A FileManager contains a list of location functions to try: the global\n+ * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and\n+ * one {@link LocatorURL}\n+ * \n+ * Main operations:\n+ *  * <ul>\n+ * <li>loadModel, readModel : URI to model</li>\n+ * <li>open, openNoMap : URI to input stream</li>\n+ * <li>mapURI : map URI to another by {@link LocationMapper}</li> \n+ * </ul>\n+ * \n+ * Utilities:\n+ * <ul>\n+ * <li>readWholeFileAsUTF8</li>\n+ * <li>optional caching of models<li>\n+ * </ul>\n+ * \n+ * A FileManager works in conjunction with a LocationMapper.\n+ * A {@link LocationMapper} is a set of alternative locations for system\n+ * resources and a set of alternative prefix locations.  For example, a local\n+ * copy of a common RDF dataset may be used whenever the usual URL is used by\n+ * the application.\n+ *\n+ * The {@link LocatorFile} also supports the idea of \"current directory\".\n+ * \n+ * @see LocationMapper\n+ * @see FileUtils\n+ */\n+ \n+public class FileManagerImpl implements FileManager\n+{\n+    // The case of the FileManager used first.\n+    private static Logger log = LoggerFactory.getLogger(FileManager.class) ;\n+    \n+    /** Delimiter between path entries : because URI scheme names use : we only allow ; */\n+\n+    static FileManager fmInstance = null ;\n+\n+    protected List<Locator> fmHandlers = new ArrayList<>() ;\n+    protected LocationMapper fmMapper = null ;\n+    \n+    static { JenaSystem.init(); }\n+\n+    /** Get the global file manager.\n+     * @return the global file manager\n+     */\n+    public static FileManager get()\n+    {\n+        // Singleton pattern adopted in case we later have several file managers.\n+        if ( fmInstance == null )\n+            fmInstance = makeGlobal() ;\n+        return fmInstance ;\n+    }\n+    \n+    /** Set the global file manager (as returned by get())\n+     * If called before any call to get(), then the usual default filemanager is not created \n+     * @param globalFileManager\n+     */\n+    public static void setGlobalFileManager(FileManager globalFileManager)\n+    {\n+        fmInstance = globalFileManager ;\n+    }\n+    \n+    /** Create an uninitialized FileManager */\n+\n+    protected FileManagerImpl() {}\n+    \n+    protected static FileManager makeStd() {\n+        FileManagerImpl fm = new FileManagerImpl();\n+        setStdLocators(fm);\n+        return fm;\n+    }\n+    \n+    /** Create with the given location mapper */\n+    protected FileManagerImpl(LocationMapper _mapper)    { setLocationMapper(_mapper) ; }\n+\n+    @Override\n+    public FileManager clone() { return clone(this) ; } \n+ \n+    // Isolate to help avoid copy errors.\n+    private static FileManager clone(FileManagerImpl filemanager) {\n+        FileManagerImpl newFm = new FileManagerImpl() ;\n+        newFm.fmHandlers.addAll(filemanager.fmHandlers) ;\n+        newFm.fmMapper = null ;\n+        if ( filemanager.getLocationMapper() != null )\n+            newFm.fmMapper = new LocationMapper(filemanager.getLocationMapper()) ;\n+        newFm.cacheModelLoads = false ;\n+        newFm.modelCache = null ;\n+        return newFm ;\n+    }\n+\n+    /** Create a \"standard\" FileManager. */\n+    public static FileManager makeGlobal()\n+    {\n+        FileManagerImpl fMgr = new FileManagerImpl(LocationMapper.get()) ;\n+        setStdLocators(fMgr) ;\n+        return fMgr ;\n+    }\n+    \n+    /** Force a file handler to have the default configuration. */\n+    private static void setStdLocators(FileManagerImpl fMgr)\n+    {\n+        fMgr.fmHandlers.clear() ;\n+        fMgr.addLocatorFile() ;\n+        fMgr.addLocatorURL() ;\n+        fMgr.addLocatorClassLoader(fMgr.getClass().getClassLoader()) ;\n+    }\n+    /** Set the location mapping */\n+    @Override\n+    public void setLocationMapper(LocationMapper _mapper) { fmMapper = _mapper ; }\n+    \n+    /** Get the location mapping */\n+    @Override\n+    public LocationMapper getLocationMapper() { return fmMapper ; }\n+    \n+    /** Return an iterator over all the handlers */\n+    @Override\n+    public Iterator<Locator> locators() { return fmHandlers.listIterator() ; }\n+\n+    /** Add a locator to the end of the locators list */ \n+    @Override\n+    public void addLocator(Locator loc)\n+    {\n+        log.debug(\"Add location: \"+loc.getName()) ;\n+        fmHandlers.add(loc) ; }\n+\n+    /** Add a file locator */ \n+    @Override\n+    public void addLocatorFile() { addLocatorFile(null) ; } \n+\n+    /** Add a file locator which uses dir as its working directory */ \n+    @Override\n+    public void addLocatorFile(String dir)\n+    {\n+        LocatorFile fLoc = new LocatorFile(dir) ;\n+        addLocator(fLoc) ;\n+    }\n+    \n+    /** Add a class loader locator */ \n+    @Override\n+    public void addLocatorClassLoader(ClassLoader cLoad)\n+    {\n+        LocatorClassLoader cLoc = new LocatorClassLoader(cLoad) ;\n+        addLocator(cLoc) ;\n+    }\n+\n+    /** Add a URL locator */\n+    @Override\n+    public void addLocatorURL()\n+    {\n+        Locator loc = new LocatorURL() ;\n+        addLocator(loc) ;\n+    }\n+\n+    /** Add a zip file locator */\n+    @Override\n+    public void addLocatorZip(String zfn)\n+    {\n+        Locator loc = new LocatorZip(zfn) ;\n+        addLocator(loc) ;\n+    }\n+\n+    \n+    /** Remove a locator */ \n+    @Override\n+    public void remove(Locator loc) { fmHandlers.remove(loc) ; }\n+\n+    // -------- Cache operations\n+    boolean cacheModelLoads = false ;\n+    Map<String, Model> modelCache = null ;\n+    \n+    /** Reset the model cache */\n+    @Override\n+    public void resetCache()\n+    {\n+        if ( modelCache != null )\n+            modelCache.clear() ;\n+    }\n+    \n+    /** Change the state of model cache : does not clear the cache */ \n+    @Override\n+    public void setModelCaching(boolean state)\n+    {\n+        cacheModelLoads = state ;\n+        if ( cacheModelLoads && modelCache == null )\n+            modelCache = new HashMap<String, Model>() ;\n+    }\n+\n+    /** return whether caching is on of off */\n+    @Override\n+    public boolean isCachingModels() { return cacheModelLoads ; }\n+    \n+    /** Read out of the cache - return null if not in the cache */ \n+    @Override\n+    public Model getFromCache(String filenameOrURI)\n+    { \n+        if ( ! isCachingModels() )\n+            return null; \n+        return modelCache.get(filenameOrURI) ;\n+    }\n+    \n+    @Override\n+    public boolean hasCachedModel(String filenameOrURI)\n+    { \n+        if ( ! isCachingModels() )\n+            return false ; \n+        return modelCache.containsKey(filenameOrURI) ;\n+    }\n+    \n+    @Override\n+    public void addCacheModel(String uri, Model m)\n+    { \n+        if ( isCachingModels() )\n+            modelCache.put(uri, m) ;\n+    }\n+\n+    @Override\n+    public void removeCacheModel(String uri)\n+    { \n+        if ( isCachingModels() )\n+            modelCache.remove(uri) ;\n+    }\n+\n+    // -------- Cache operations (end)\n+\n+    /** Load a model from a file (local or remote).\n+     *  This operation may attempt content negotiation for http URLs.\n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+     */\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI)\n+    { \n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\")\") ;\n+        \n+        return loadModelWorker(filenameOrURI, null, null) ;\n+    }\n+\n+    /** Load a model from a file (local or remote).\n+     *  URI is the base for reading the model.\n+     * \n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @param rdfSyntax  RDF Serialization syntax. \n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+     */\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n+        return loadModelWorker(filenameOrURI, null, rdfSyntax) ;\n+    }\n+    \n+    /** Load a model from a file (local or remote).\n+     * \n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @param baseURI  Base URI for loading the RDF model.\n+     *  @param rdfSyntax  RDF Serialization syntax. \n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+    */\n+\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI, String baseURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\", \"+baseURI+\", \"+rdfSyntax+\")\") ;\n+\n+        return loadModelWorker(filenameOrURI, baseURI, rdfSyntax) ;\n+    }\n+\n+    private Model loadModelWorker(String filenameOrURI, String baseURI, String rdfSyntax)\n+    {\n+        if ( hasCachedModel(filenameOrURI) )\n+        {\n+            if ( log.isDebugEnabled() )\n+                log.debug(\"Model cache hit: \"+filenameOrURI) ;\n+            return getFromCache(filenameOrURI) ;\n+        }\n+\n+        Model m = ModelFactory.createDefaultModel() ;\n+        readModelWorker(m, filenameOrURI, baseURI, rdfSyntax) ;\n+        \n+        if ( isCachingModels() )\n+            addCacheModel(filenameOrURI, m) ;\n+        return m ;\n+    }\n+    \n+    /**\n+     * Read a file of RDF into a model.  Guesses the syntax of the file based on filename extension, \n+     *  defaulting to RDF/XML.\n+     * @param model\n+     * @param filenameOrURI\n+     * @return The model or null, if there was an error.\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\")\") ;\n+        return readModel(model, filenameOrURI, null);\n+    }\n+    \n+    /**\n+     * Read a file of RDF into a model.\n+     * @param model\n+     * @param filenameOrURI\n+     * @param rdfSyntax RDF Serialization syntax.\n+     * @return The model or null, if there was an error.\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n+        return readModelWorker(model, filenameOrURI, null, rdfSyntax);\n+    }\n+\n+    /**\n+     * Read a file of RDF into a model.\n+     * @param model\n+     * @param filenameOrURI\n+     * @param baseURI\n+     * @param syntax\n+     * @return The model\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI, String baseURI, String syntax)\n+    {\n+        \n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+baseURI+\", \"+syntax+\")\") ;\n+        return readModelWorker(model, filenameOrURI, baseURI, syntax) ;\n+    }\n+    \n+    protected Model readModelWorker(Model model, String filenameOrURI, String baseURI, String syntax)\n+    {\n+        // Doesn't call open() - we want to make the syntax guess based on the mapped URI.\n+        String mappedURI = mapURI(filenameOrURI) ;\n+\n+        if ( log.isDebugEnabled() && ! mappedURI.equals(filenameOrURI) )\n+            log.debug(\"Map: \"+filenameOrURI+\" => \"+mappedURI) ;\n+\n+        if ( syntax == null && baseURI == null && mappedURI.startsWith( \"http:\" ) )\n+        {\n+            syntax = FileUtils.guessLang(mappedURI) ;\n+            // Content negotation in next version (FileManager2) \n+            model.read(mappedURI, syntax) ;\n+            return model ;\n+        }\n+        \n+        if ( syntax == null )\n+        {\n+            syntax = FileUtils.guessLang(mappedURI) ;\n+            if ( syntax == null || syntax.equals(\"\") )\n+                syntax = FileUtils.langXML ;\n+            if ( log.isDebugEnabled() ) \n+                log.debug(\"Syntax guess: \"+syntax);\n+        }\n+\n+        if ( baseURI == null )\n+            baseURI = chooseBaseURI(filenameOrURI) ;\n+\n+        TypedStream in = openNoMapOrNull(mappedURI) ;\n+        if ( in == null )\n+        {\n+            FmtLog.debug(log, \"Failed to locate '%s'\", mappedURI);\n+            throw new NotFoundException(\"Not found: \"+filenameOrURI) ;\n+        }\n+        if ( in.getMimeType() != null )\n+        {\n+            //syntax\n+        }\n+        model.read(in.getInput(), baseURI, syntax) ;\n+        try { in.getInput().close(); } catch (IOException ex) {}\n+        return model ;\n+    }\n+\n+    private static String chooseBaseURI(String baseURI)\n+    {\n+        String scheme = FileUtils.getScheme(baseURI) ;\n+        \n+        if ( scheme != null )\n+        {\n+            if ( scheme.equals(\"file\") )\n+            {\n+                if ( ! baseURI.startsWith(\"file:///\") )\n+                {\n+                    try {\n+                        // Fix up file URIs.  Yuk.", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dd3ee540c13087adca06cba5b170804e9de06e54", "chunk": "diff --git a/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java b/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java\ndeleted file mode 100644\nindex d32bb21464..0000000000\n--- a/jena-core/src/main/java/org/apache/jena/util/FileManagerImpl.java\n+++ /dev/null\n\n@@ -1,566 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.jena.util;\n-\n-import java.io.* ;\n-import java.util.* ;\n-\n-import org.apache.jena.atlas.logging.FmtLog;\n-import org.apache.jena.rdf.model.Model ;\n-import org.apache.jena.rdf.model.ModelFactory ;\n-import org.apache.jena.shared.JenaException ;\n-import org.apache.jena.shared.NotFoundException ;\n-import org.apache.jena.shared.WrappedIOException ;\n-import org.apache.jena.sys.JenaSystem ;\n-import org.slf4j.Logger ;\n-import org.slf4j.LoggerFactory ;\n-\n-/** FileManager\n- * \n- * A FileManager provides access to named file-like resources by opening\n- * InputStreams to things in the filing system, by URL (http: and file:) and\n- * found by the classloader.  It can also load RDF data from such a system\n- * resource into an existing model or create a new (Memory-based) model.\n- * There is a global FileManager which provide uniform access to system\n- * resources: applications may also create specialised FileManagers.\n- * \n- * A FileManager contains a list of location functions to try: the global\n- * FileManger has one {@link LocatorFile}, one {@link LocatorClassLoader} and\n- * one {@link LocatorURL}\n- * \n- * Main operations:\n- *  * <ul>\n- * <li>loadModel, readModel : URI to model</li>\n- * <li>open, openNoMap : URI to input stream</li>\n- * <li>mapURI : map URI to another by {@link LocationMapper}</li> \n- * </ul>\n- * \n- * Utilities:\n- * <ul>\n- * <li>readWholeFileAsUTF8</li>\n- * <li>optional caching of models<li>\n- * </ul>\n- * \n- * A FileManager works in conjunction with a LocationMapper.\n- * A {@link LocationMapper} is a set of alternative locations for system\n- * resources and a set of alternative prefix locations.  For example, a local\n- * copy of a common RDF dataset may be used whenever the usual URL is used by\n- * the application.\n- *\n- * The {@link LocatorFile} also supports the idea of \"current directory\".\n- * \n- * @see LocationMapper\n- * @see FileUtils\n- */\n- \n-public class FileManagerImpl implements FileManager\n-{\n-    // The case of the FileManager used first.\n-    private static Logger log = LoggerFactory.getLogger(FileManager.class) ;\n-    \n-    /** Delimiter between path entries : because URI scheme names use : we only allow ; */\n-\n-    static FileManager fmInstance = null ;\n-\n-    protected List<Locator> fmHandlers = new ArrayList<>() ;\n-    protected LocationMapper fmMapper = null ;\n-    \n-    static { JenaSystem.init(); }\n-\n-    /** Get the global file manager.\n-     * @return the global file manager\n-     */\n-    public static FileManager get()\n-    {\n-        // Singleton pattern adopted in case we later have several file managers.\n-        if ( fmInstance == null )\n-            fmInstance = makeGlobal() ;\n-        return fmInstance ;\n-    }\n-    \n-    /** Set the global file manager (as returned by get())\n-     * If called before any call to get(), then the usual default filemanager is not created \n-     * @param globalFileManager\n-     */\n-    public static void setGlobalFileManager(FileManager globalFileManager)\n-    {\n-        fmInstance = globalFileManager ;\n-    }\n-    \n-    /** Create an uninitialized FileManager */\n-\n-    protected FileManagerImpl() {}\n-    \n-    protected static FileManager makeStd() {\n-        FileManagerImpl fm = new FileManagerImpl();\n-        setStdLocators(fm);\n-        return fm;\n-    }\n-    \n-    /** Create with the given location mapper */\n-    protected FileManagerImpl(LocationMapper _mapper)    { setLocationMapper(_mapper) ; }\n-\n-    @Override\n-    public FileManager clone() { return clone(this) ; } \n- \n-    // Isolate to help avoid copy errors.\n-    private static FileManager clone(FileManagerImpl filemanager) {\n-        FileManagerImpl newFm = new FileManagerImpl() ;\n-        newFm.fmHandlers.addAll(filemanager.fmHandlers) ;\n-        newFm.fmMapper = null ;\n-        if ( filemanager.getLocationMapper() != null )\n-            newFm.fmMapper = new LocationMapper(filemanager.getLocationMapper()) ;\n-        newFm.cacheModelLoads = false ;\n-        newFm.modelCache = null ;\n-        return newFm ;\n-    }\n-\n-    /** Create a \"standard\" FileManager. */\n-    public static FileManager makeGlobal()\n-    {\n-        FileManagerImpl fMgr = new FileManagerImpl(LocationMapper.get()) ;\n-        setStdLocators(fMgr) ;\n-        return fMgr ;\n-    }\n-    \n-    /** Force a file handler to have the default configuration. */\n-    private static void setStdLocators(FileManagerImpl fMgr)\n-    {\n-        fMgr.fmHandlers.clear() ;\n-        fMgr.addLocatorFile() ;\n-        fMgr.addLocatorURL() ;\n-        fMgr.addLocatorClassLoader(fMgr.getClass().getClassLoader()) ;\n-    }\n-    /** Set the location mapping */\n-    @Override\n-    public void setLocationMapper(LocationMapper _mapper) { fmMapper = _mapper ; }\n-    \n-    /** Get the location mapping */\n-    @Override\n-    public LocationMapper getLocationMapper() { return fmMapper ; }\n-    \n-    /** Return an iterator over all the handlers */\n-    @Override\n-    public Iterator<Locator> locators() { return fmHandlers.listIterator() ; }\n-\n-    /** Add a locator to the end of the locators list */ \n-    @Override\n-    public void addLocator(Locator loc)\n-    {\n-        log.debug(\"Add location: \"+loc.getName()) ;\n-        fmHandlers.add(loc) ; }\n-\n-    /** Add a file locator */ \n-    @Override\n-    public void addLocatorFile() { addLocatorFile(null) ; } \n-\n-    /** Add a file locator which uses dir as its working directory */ \n-    @Override\n-    public void addLocatorFile(String dir)\n-    {\n-        LocatorFile fLoc = new LocatorFile(dir) ;\n-        addLocator(fLoc) ;\n-    }\n-    \n-    /** Add a class loader locator */ \n-    @Override\n-    public void addLocatorClassLoader(ClassLoader cLoad)\n-    {\n-        LocatorClassLoader cLoc = new LocatorClassLoader(cLoad) ;\n-        addLocator(cLoc) ;\n-    }\n-\n-    /** Add a URL locator */\n-    @Override\n-    public void addLocatorURL()\n-    {\n-        Locator loc = new LocatorURL() ;\n-        addLocator(loc) ;\n-    }\n-\n-    /** Add a zip file locator */\n-    @Override\n-    public void addLocatorZip(String zfn)\n-    {\n-        Locator loc = new LocatorZip(zfn) ;\n-        addLocator(loc) ;\n-    }\n-\n-    \n-    /** Remove a locator */ \n-    @Override\n-    public void remove(Locator loc) { fmHandlers.remove(loc) ; }\n-\n-    // -------- Cache operations\n-    boolean cacheModelLoads = false ;\n-    Map<String, Model> modelCache = null ;\n-    \n-    /** Reset the model cache */\n-    @Override\n-    public void resetCache()\n-    {\n-        if ( modelCache != null )\n-            modelCache.clear() ;\n-    }\n-    \n-    /** Change the state of model cache : does not clear the cache */ \n-    @Override\n-    public void setModelCaching(boolean state)\n-    {\n-        cacheModelLoads = state ;\n-        if ( cacheModelLoads && modelCache == null )\n-            modelCache = new HashMap<String, Model>() ;\n-    }\n-\n-    /** return whether caching is on of off */\n-    @Override\n-    public boolean isCachingModels() { return cacheModelLoads ; }\n-    \n-    /** Read out of the cache - return null if not in the cache */ \n-    @Override\n-    public Model getFromCache(String filenameOrURI)\n-    { \n-        if ( ! isCachingModels() )\n-            return null; \n-        return modelCache.get(filenameOrURI) ;\n-    }\n-    \n-    @Override\n-    public boolean hasCachedModel(String filenameOrURI)\n-    { \n-        if ( ! isCachingModels() )\n-            return false ; \n-        return modelCache.containsKey(filenameOrURI) ;\n-    }\n-    \n-    @Override\n-    public void addCacheModel(String uri, Model m)\n-    { \n-        if ( isCachingModels() )\n-            modelCache.put(uri, m) ;\n-    }\n-\n-    @Override\n-    public void removeCacheModel(String uri)\n-    { \n-        if ( isCachingModels() )\n-            modelCache.remove(uri) ;\n-    }\n-\n-    // -------- Cache operations (end)\n-\n-    /** Load a model from a file (local or remote).\n-     *  This operation may attempt content negotiation for http URLs.\n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-     */\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI)\n-    { \n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\")\") ;\n-        \n-        return loadModelWorker(filenameOrURI, null, null) ;\n-    }\n-\n-    /** Load a model from a file (local or remote).\n-     *  URI is the base for reading the model.\n-     * \n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @param rdfSyntax  RDF Serialization syntax. \n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-     */\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n-        return loadModelWorker(filenameOrURI, null, rdfSyntax) ;\n-    }\n-    \n-    /** Load a model from a file (local or remote).\n-     * \n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @param baseURI  Base URI for loading the RDF model.\n-     *  @param rdfSyntax  RDF Serialization syntax. \n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-    */\n-\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI, String baseURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\", \"+baseURI+\", \"+rdfSyntax+\")\") ;\n-\n-        return loadModelWorker(filenameOrURI, baseURI, rdfSyntax) ;\n-    }\n-\n-    private Model loadModelWorker(String filenameOrURI, String baseURI, String rdfSyntax)\n-    {\n-        if ( hasCachedModel(filenameOrURI) )\n-        {\n-            if ( log.isDebugEnabled() )\n-                log.debug(\"Model cache hit: \"+filenameOrURI) ;\n-            return getFromCache(filenameOrURI) ;\n-        }\n-\n-        Model m = ModelFactory.createDefaultModel() ;\n-        readModelWorker(m, filenameOrURI, baseURI, rdfSyntax) ;\n-        \n-        if ( isCachingModels() )\n-            addCacheModel(filenameOrURI, m) ;\n-        return m ;\n-    }\n-    \n-    /**\n-     * Read a file of RDF into a model.  Guesses the syntax of the file based on filename extension, \n-     *  defaulting to RDF/XML.\n-     * @param model\n-     * @param filenameOrURI\n-     * @return The model or null, if there was an error.\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\")\") ;\n-        return readModel(model, filenameOrURI, null);\n-    }\n-    \n-    /**\n-     * Read a file of RDF into a model.\n-     * @param model\n-     * @param filenameOrURI\n-     * @param rdfSyntax RDF Serialization syntax.\n-     * @return The model or null, if there was an error.\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n-        return readModelWorker(model, filenameOrURI, null, rdfSyntax);\n-    }\n-\n-    /**\n-     * Read a file of RDF into a model.\n-     * @param model\n-     * @param filenameOrURI\n-     * @param baseURI\n-     * @param syntax\n-     * @return The model\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI, String baseURI, String syntax)\n-    {\n-        \n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+baseURI+\", \"+syntax+\")\") ;\n-        return readModelWorker(model, filenameOrURI, baseURI, syntax) ;\n-    }\n-    \n-    protected Model readModelWorker(Model model, String filenameOrURI, String baseURI, String syntax)\n-    {\n-        // Doesn't call open() - we want to make the syntax guess based on the mapped URI.\n-        String mappedURI = mapURI(filenameOrURI) ;\n-\n-        if ( log.isDebugEnabled() && ! mappedURI.equals(filenameOrURI) )\n-            log.debug(\"Map: \"+filenameOrURI+\" => \"+mappedURI) ;\n-\n-        if ( syntax == null && baseURI == null && mappedURI.startsWith( \"http:\" ) )\n-        {\n-            syntax = FileUtils.guessLang(mappedURI) ;\n-            // Content negotation in next version (FileManager2) \n-            model.read(mappedURI, syntax) ;\n-            return model ;\n-        }\n-        \n-        if ( syntax == null )\n-        {\n-            syntax = FileUtils.guessLang(mappedURI) ;\n-            if ( syntax == null || syntax.equals(\"\") )\n-                syntax = FileUtils.langXML ;\n-            if ( log.isDebugEnabled() ) \n-                log.debug(\"Syntax guess: \"+syntax);\n-        }\n-\n-        if ( baseURI == null )\n-            baseURI = chooseBaseURI(filenameOrURI) ;\n-\n-        TypedStream in = openNoMapOrNull(mappedURI) ;\n-        if ( in == null )\n-        {\n-            FmtLog.debug(log, \"Failed to locate '%s'\", mappedURI);\n-            throw new NotFoundException(\"Not found: \"+filenameOrURI) ;\n-        }\n-        if ( in.getMimeType() != null )\n-        {\n-            //syntax\n-        }\n-        model.read(in.getInput(), baseURI, syntax) ;\n-        try { in.getInput().close(); } catch (IOException ex) {}\n-        return model ;\n-    }\n-\n-    private static String chooseBaseURI(String baseURI)\n-    {\n-        String scheme = FileUtils.getScheme(baseURI) ;\n-        \n-        if ( scheme != null )\n-        {\n-            if ( scheme.equals(\"file\") )\n-            {\n-                if ( ! baseURI.startsWith(\"file:///\") )\n-                {\n-                    try {\n-                        // Fix up file URIs.  Yuk.\n-                        String tmp = baseURI.substring(\"file:\".length()) ;\n-                        File f = new File(tmp) ;\n-                        baseURI = \"file:///\"+f.getCanonicalPath() ;\n-                        baseURI = baseURI.replace('\\\\','/') ;\n-\n-//                        baseURI = baseURI.replace(\" \",\"%20\");\n-//                        baseURI = baseURI.replace(\"~\",\"%7E\");\n-                        // Convert to URI.  Except that it removes ///\n-                        // Could do that and fix up (again)\n-                        //java.net.URL u = new java.net.URL(baseURI) ;\n-                        //baseURI = u.toExternalForm() ;\n-                    } catch (Exception ex) {}\n-                }\n-            }\n-            return baseURI ;\n-        }\n-            \n-        if ( baseURI.startsWith(\"/\") )\n-            return \"file://\"+baseURI ;\n-        return \"file:\"+baseURI ;\n-    }\n-    \n-    /** Open a file using the locators of this FileManager */\n-    @Override\n-    public InputStream open(String filenameOrURI)\n-    {\n-        if ( log.isDebugEnabled())\n-            log.debug(\"open(\"+filenameOrURI+\")\") ;\n-        \n-        String uri = mapURI(filenameOrURI) ;\n-        \n-        if ( log.isDebugEnabled() && ! uri.equals(filenameOrURI) )\n-            log.debug(\"open: mapped to \"+uri) ;\n-        \n-        return openNoMap(uri) ;\n-    }\n-\n-\n-    /** Apply the mapping of a filename or URI */\n-    @Override\n-    public String mapURI(String filenameOrURI)\n-    {\n-        if ( fmMapper == null )\n-            return filenameOrURI ; \n-            \n-        String uri = fmMapper.altMapping(filenameOrURI, null) ;\n-\n-        if ( uri == null )\n-        {\n-            if ( FileManager.logAllLookups && log.isDebugEnabled() )\n-                log.debug(\"Not mapped: \"+filenameOrURI) ;\n-            uri = filenameOrURI ;\n-        }\n-        else\n-        {\n-            if ( log.isDebugEnabled() )\n-                log.debug(\"Mapped: \"+filenameOrURI+\" => \"+uri) ;\n-        }\n-        return uri ;\n-    }\n-    \n-    /** Slurp up a whole file */\n-    @Override\n-    public String readWholeFileAsUTF8(InputStream in)\n-    {\n-        try (Reader r = FileUtils.asBufferedUTF8(in); StringWriter sw = new StringWriter(1024)) {\n-            char buff[] = new char[1024] ;\n-            while (true) {\n-                int l = r.read(buff) ;\n-                if ( l <= 0 )\n-                    break ;\n-                sw.write(buff, 0, l) ;\n-            }\n-            return sw.toString() ;\n-        } catch (IOException ex)\n-        { throw new WrappedIOException(ex) ; }\n-    }\n-    \n-    /** Slurp up a whole file: map filename as necessary */\n-    @Override\n-    public String readWholeFileAsUTF8(String filename)\n-    {\n-        InputStream in = open(filename) ;\n-        if ( in == null )\n-            throw new NotFoundException(\"File not found: \"+filename) ;\n-        return readWholeFileAsUTF8(in) ;\n-    }\n-        \n-    /** Open a file using the locators of this FileManager \n-     *  but without location mapping */ \n-    @Override\n-    public InputStream openNoMap(String filenameOrURI)\n-    {\n-        TypedStream in = openNoMapOrNull(filenameOrURI) ;\n-        if ( in == null )\n-            return null ;\n-//        if ( in == null )\n-//            throw new NotFoundException(filenameOrURI) ;\n-        return in.getInput() ;\n-    }\n-    \n-    /** Open a file using the locators of this FileManager \n-     *  but without location mapping.\n-     *  Return null if not found\n-     */ \n-    \n-    @Override\n-    public TypedStream openNoMapOrNull(String filenameOrURI)\n-    {\n-        for (Locator loc : fmHandlers)\n-        {\n-            TypedStream in = loc.open(filenameOrURI) ;\n-            if ( in != null )\n-            {\n-                if ( log.isDebugEnabled() )\n-                    log.debug(\"Found: \"+filenameOrURI+\" (\"+loc.getName()+\")\") ;\n-                return in ;\n-            }\n-        }\n-        return null; \n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTk3NA==", "url": "https://github.com/apache/jena/pull/759#discussion_r440601974", "bodyText": "This method looks a lot like another method I'd read on this PR. Could they be merged into one and re-used? Or are they doing something different? (Will have another look after submitting the review)", "author": "kinow", "createdAt": "2020-06-16T05:55:01Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/adapters/AdapterFileManager.java", "diffHunk": "@@ -331,4 +339,189 @@ public InputStream openNoMap(String filenameOrURI) {\n     public TypedStream openNoMapOrNull(String filenameOrURI) {\n         return AdapterLib.convert(streamManager.openNoMapOrNull(filenameOrURI)) ;\n     }\n+    \n+    // -------- Cache operations (end)\n+    \n+    // LEGACY \n+\n+    /** Load a model from a file (local or remote).\n+     *  This operation may attempt content negotiation for http URLs.\n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+     */\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI)\n+    { \n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\")\") ;\n+        \n+        return loadModelWorker(filenameOrURI, null, null) ;\n+    }\n+\n+    /** Load a model from a file (local or remote).\n+     *  URI is the base for reading the model.\n+     * \n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @param rdfSyntax  RDF Serialization syntax. \n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+     */\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n+        return loadModelWorker(filenameOrURI, null, rdfSyntax) ;\n+    }\n+    \n+    /** Load a model from a file (local or remote).\n+     * \n+     *  @param filenameOrURI The filename or a URI (file:, http:)\n+     *  @param baseURI  Base URI for loading the RDF model.\n+     *  @param rdfSyntax  RDF Serialization syntax. \n+     *  @return a new model\n+     *  @exception JenaException if there is syntax error in file.\n+    */\n+\n+\n+    @Override\n+    public Model loadModel(String filenameOrURI, String baseURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"loadModel(\"+filenameOrURI+\", \"+baseURI+\", \"+rdfSyntax+\")\") ;\n+\n+        return loadModelWorker(filenameOrURI, baseURI, rdfSyntax) ;\n+    }\n+\n+    private Model loadModelWorker(String filenameOrURI, String baseURI, String rdfSyntax)\n+    {\n+        if ( hasCachedModel(filenameOrURI) )\n+        {\n+            if ( log.isDebugEnabled() )\n+                log.debug(\"Model cache hit: \"+filenameOrURI) ;\n+            return getFromCache(filenameOrURI) ;\n+        }\n+\n+        Model m = ModelFactory.createDefaultModel() ;\n+        readModelWorker(m, filenameOrURI, baseURI, rdfSyntax) ;\n+        \n+        if ( isCachingModels() )\n+            addCacheModel(filenameOrURI, m) ;\n+        return m ;\n+    }\n+    \n+    /**\n+     * Read a file of RDF into a model.  Guesses the syntax of the file based on filename extension, \n+     *  defaulting to RDF/XML.\n+     * @param model\n+     * @param filenameOrURI\n+     * @return The model or null, if there was an error.\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\")\") ;\n+        return readModel(model, filenameOrURI, null);\n+    }\n+    \n+    /**\n+     * Read a file of RDF into a model.\n+     * @param model\n+     * @param filenameOrURI\n+     * @param rdfSyntax RDF Serialization syntax.\n+     * @return The model or null, if there was an error.\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI, String rdfSyntax)\n+    {\n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n+        return readModelWorker(model, filenameOrURI, null, rdfSyntax);\n+    }\n+\n+    /**\n+     * Read a file of RDF into a model.\n+     * @param model\n+     * @param filenameOrURI\n+     * @param baseURI\n+     * @param syntax\n+     * @return The model\n+     *  @exception JenaException if there is syntax error in file.\n+     */    \n+\n+    @Override\n+    public Model readModel(Model model, String filenameOrURI, String baseURI, String syntax)\n+    {\n+        \n+        if ( log.isDebugEnabled() )\n+            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+baseURI+\", \"+syntax+\")\") ;\n+        return readModelWorker(model, filenameOrURI, baseURI, syntax) ;\n+    }\n+    \n+    private static String chooseBaseURI(String baseURI)\n+    {\n+        String scheme = FileUtils.getScheme(baseURI) ;\n+        \n+        if ( scheme != null )\n+        {\n+            if ( scheme.equals(\"file\") )\n+            {\n+                if ( ! baseURI.startsWith(\"file:///\") )\n+                {\n+                    try {\n+                        // Fix up file URIs.  Yuk.", "originalCommit": "e367d0247eec57c7466adef3a31601548a420ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNDIyNA==", "url": "https://github.com/apache/jena/pull/759#discussion_r440604224", "bodyText": "It's FileManager#chooseBaseURI and AdapterFileManager#chooseBaseURI. They look identical. Should they be moved somewhere else so that both classes can re-use it?", "author": "kinow", "createdAt": "2020-06-16T06:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTk3NA=="}], "type": "inlineReview", "revised_code": {"commit": "dd3ee540c13087adca06cba5b170804e9de06e54", "chunk": "diff --git a/jena-arq/src/main/java/org/apache/jena/riot/adapters/AdapterFileManager.java b/jena-arq/src/main/java/org/apache/jena/riot/adapters/AdapterFileManager.java\nindex ce412fee62..eb57b96937 100644\n--- a/jena-arq/src/main/java/org/apache/jena/riot/adapters/AdapterFileManager.java\n+++ b/jena-arq/src/main/java/org/apache/jena/riot/adapters/AdapterFileManager.java\n\n@@ -339,189 +331,4 @@ public class AdapterFileManager implements org.apache.jena.util.FileManager\n     public TypedStream openNoMapOrNull(String filenameOrURI) {\n         return AdapterLib.convert(streamManager.openNoMapOrNull(filenameOrURI)) ;\n     }\n-    \n-    // -------- Cache operations (end)\n-    \n-    // LEGACY \n-\n-    /** Load a model from a file (local or remote).\n-     *  This operation may attempt content negotiation for http URLs.\n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-     */\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI)\n-    { \n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\")\") ;\n-        \n-        return loadModelWorker(filenameOrURI, null, null) ;\n-    }\n-\n-    /** Load a model from a file (local or remote).\n-     *  URI is the base for reading the model.\n-     * \n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @param rdfSyntax  RDF Serialization syntax. \n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-     */\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n-        return loadModelWorker(filenameOrURI, null, rdfSyntax) ;\n-    }\n-    \n-    /** Load a model from a file (local or remote).\n-     * \n-     *  @param filenameOrURI The filename or a URI (file:, http:)\n-     *  @param baseURI  Base URI for loading the RDF model.\n-     *  @param rdfSyntax  RDF Serialization syntax. \n-     *  @return a new model\n-     *  @exception JenaException if there is syntax error in file.\n-    */\n-\n-\n-    @Override\n-    public Model loadModel(String filenameOrURI, String baseURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"loadModel(\"+filenameOrURI+\", \"+baseURI+\", \"+rdfSyntax+\")\") ;\n-\n-        return loadModelWorker(filenameOrURI, baseURI, rdfSyntax) ;\n-    }\n-\n-    private Model loadModelWorker(String filenameOrURI, String baseURI, String rdfSyntax)\n-    {\n-        if ( hasCachedModel(filenameOrURI) )\n-        {\n-            if ( log.isDebugEnabled() )\n-                log.debug(\"Model cache hit: \"+filenameOrURI) ;\n-            return getFromCache(filenameOrURI) ;\n-        }\n-\n-        Model m = ModelFactory.createDefaultModel() ;\n-        readModelWorker(m, filenameOrURI, baseURI, rdfSyntax) ;\n-        \n-        if ( isCachingModels() )\n-            addCacheModel(filenameOrURI, m) ;\n-        return m ;\n-    }\n-    \n-    /**\n-     * Read a file of RDF into a model.  Guesses the syntax of the file based on filename extension, \n-     *  defaulting to RDF/XML.\n-     * @param model\n-     * @param filenameOrURI\n-     * @return The model or null, if there was an error.\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\")\") ;\n-        return readModel(model, filenameOrURI, null);\n-    }\n-    \n-    /**\n-     * Read a file of RDF into a model.\n-     * @param model\n-     * @param filenameOrURI\n-     * @param rdfSyntax RDF Serialization syntax.\n-     * @return The model or null, if there was an error.\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI, String rdfSyntax)\n-    {\n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+rdfSyntax+\")\") ;\n-        return readModelWorker(model, filenameOrURI, null, rdfSyntax);\n-    }\n-\n-    /**\n-     * Read a file of RDF into a model.\n-     * @param model\n-     * @param filenameOrURI\n-     * @param baseURI\n-     * @param syntax\n-     * @return The model\n-     *  @exception JenaException if there is syntax error in file.\n-     */    \n-\n-    @Override\n-    public Model readModel(Model model, String filenameOrURI, String baseURI, String syntax)\n-    {\n-        \n-        if ( log.isDebugEnabled() )\n-            log.debug(\"readModel(model,\"+filenameOrURI+\", \"+baseURI+\", \"+syntax+\")\") ;\n-        return readModelWorker(model, filenameOrURI, baseURI, syntax) ;\n-    }\n-    \n-    private static String chooseBaseURI(String baseURI)\n-    {\n-        String scheme = FileUtils.getScheme(baseURI) ;\n-        \n-        if ( scheme != null )\n-        {\n-            if ( scheme.equals(\"file\") )\n-            {\n-                if ( ! baseURI.startsWith(\"file:///\") )\n-                {\n-                    try {\n-                        // Fix up file URIs.  Yuk.\n-                        String tmp = baseURI.substring(\"file:\".length()) ;\n-                        File f = new File(tmp) ;\n-                        baseURI = \"file:///\"+f.getCanonicalPath() ;\n-                        baseURI = baseURI.replace('\\\\','/') ;\n-\n-//                        baseURI = baseURI.replace(\" \",\"%20\");\n-//                        baseURI = baseURI.replace(\"~\",\"%7E\");\n-                        // Convert to URI.  Except that it removes ///\n-                        // Could do that and fix up (again)\n-                        //java.net.URL u = new java.net.URL(baseURI) ;\n-                        //baseURI = u.toExternalForm() ;\n-                    } catch (Exception ex) {}\n-                }\n-            }\n-            return baseURI ;\n-        }\n-            \n-        if ( baseURI.startsWith(\"/\") )\n-            return \"file://\"+baseURI ;\n-        return \"file:\"+baseURI ;\n-    }\n-    \n-    /**\n-     * @deprecated Use {@link IO#readWholeFileAsUTF8(InputStream)}\n-     */\n-    @Override\n-    @Deprecated\n-    public String readWholeFileAsUTF8(InputStream in)\n-    {\n-        try {\n-            return IO.readWholeFileAsUTF8(in);\n-        } catch (IOException ex)\n-        { throw new WrappedIOException(ex) ; }\n-    }\n-    \n-    /**\n-     * @deprecated Use {@link IO#readWholeFileAsUTF8(String)}\n-     */\n-    @Override\n-    public String readWholeFileAsUTF8(String filename)\n-    {\n-        InputStream in = open(filename) ;\n-        if ( in == null )\n-            throw new NotFoundException(\"File not found: \"+filename) ;\n-        return readWholeFileAsUTF8(in) ;\n-    }\n }\n"}}, {"oid": "dd3ee540c13087adca06cba5b170804e9de06e54", "url": "https://github.com/apache/jena/commit/dd3ee540c13087adca06cba5b170804e9de06e54", "message": "FileManager, N3 and testing clean-up", "committedDate": "2020-06-16T15:19:46Z", "type": "commit"}, {"oid": "b267b673a0da00ec123537abad9dcb984d8fba94", "url": "https://github.com/apache/jena/commit/b267b673a0da00ec123537abad9dcb984d8fba94", "message": "JENA-1917: FileManager as interface; Deprecate FileManager.get()", "committedDate": "2020-06-16T15:19:46Z", "type": "commit"}, {"oid": "97701ba5ad116bf146ef618310df4eba1488fd19", "url": "https://github.com/apache/jena/commit/97701ba5ad116bf146ef618310df4eba1488fd19", "message": "Fix permissions", "committedDate": "2020-06-16T15:19:47Z", "type": "commit"}, {"oid": "4b1d3c567d65b7344cd6b132a7f1beecbb503795", "url": "https://github.com/apache/jena/commit/4b1d3c567d65b7344cd6b132a7f1beecbb503795", "message": "JENA-1917: Deprecate readModel, loadModel; add internal versions", "committedDate": "2020-06-16T15:19:47Z", "type": "commit"}, {"oid": "4b1d3c567d65b7344cd6b132a7f1beecbb503795", "url": "https://github.com/apache/jena/commit/4b1d3c567d65b7344cd6b132a7f1beecbb503795", "message": "JENA-1917: Deprecate readModel, loadModel; add internal versions", "committedDate": "2020-06-16T15:19:47Z", "type": "forcePushed"}, {"oid": "26ffcde985ad3def09e03ac8d2aa1dccdefc1cc0", "url": "https://github.com/apache/jena/commit/26ffcde985ad3def09e03ac8d2aa1dccdefc1cc0", "message": "JENA-1917: Deprecate jena-core Locators and LocationMapper", "committedDate": "2020-06-17T16:02:28Z", "type": "commit"}]}