{"pr_number": 6066, "pr_title": "Add support for coercions in table scan redirections", "pr_createdAt": "2020-11-23T22:41:05Z", "pr_url": "https://github.com/trinodb/trino/pull/6066", "timeline": [{"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "url": "https://github.com/trinodb/trino/commit/c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "message": "Add support for coercions in table scan redirections", "committedDate": "2020-11-24T09:10:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkwOTk3OQ==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639909979", "bodyText": "What's dest_col_a in this example?", "author": "martint", "createdAt": "2021-05-26T16:36:22Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -201,6 +211,25 @@ public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n         }\n     }\n \n+    @Test\n+    public void testPredicateTypeMismatch()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB))),\n+                Optional.of(this::mockApplyProjection),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleC))))) {\n+            // After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n+            // Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n+            // but dest_col_a has mismatched type compared to source domain", "originalCommit": "a1f28760519f36f1d7083eedc1460ed401e522b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDYwNjY5Mw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640606693", "bodyText": "dest_col_a is integer", "author": "sopel39", "createdAt": "2021-05-27T13:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkwOTk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDc2NzE0MA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640767140", "bodyText": "Sorry, I meant what role does it play since it seems unrelated to the example given. But then I noticed you changed this to say dest_col_c in another commit.", "author": "martint", "createdAt": "2021-05-27T16:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkwOTk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkyNTQ0Nw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640925447", "bodyText": "source_col_c gets redirected to dest_col_a, but dest_col_a has different type (int) than source_col_c (varchar)", "author": "sopel39", "createdAt": "2021-05-27T19:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkwOTk3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "chunk": "diff --git a/presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java b/presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java\ndeleted file mode 100644\nindex f567be4259..0000000000\n--- a/presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java\n+++ /dev/null\n\n@@ -1,374 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.prestosql.sql.planner;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n-import io.prestosql.Session;\n-import io.prestosql.connector.MockConnectorColumnHandle;\n-import io.prestosql.connector.MockConnectorFactory;\n-import io.prestosql.connector.MockConnectorTableHandle;\n-import io.prestosql.execution.warnings.WarningCollector;\n-import io.prestosql.spi.PrestoException;\n-import io.prestosql.spi.connector.Assignment;\n-import io.prestosql.spi.connector.CatalogSchemaTableName;\n-import io.prestosql.spi.connector.ColumnHandle;\n-import io.prestosql.spi.connector.ColumnMetadata;\n-import io.prestosql.spi.connector.ConnectorSession;\n-import io.prestosql.spi.connector.ConnectorTableHandle;\n-import io.prestosql.spi.connector.ConstraintApplicationResult;\n-import io.prestosql.spi.connector.ProjectionApplicationResult;\n-import io.prestosql.spi.connector.SchemaTableName;\n-import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n-import io.prestosql.spi.expression.ConnectorExpression;\n-import io.prestosql.spi.expression.Variable;\n-import io.prestosql.spi.predicate.TupleDomain;\n-import io.prestosql.sql.planner.assertions.PlanAssert;\n-import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n-import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n-import io.prestosql.testing.LocalQueryRunner;\n-import org.intellij.lang.annotations.Language;\n-import org.testng.annotations.Test;\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-\n-import static com.google.common.base.Predicates.equalTo;\n-import static com.google.common.collect.ImmutableList.toImmutableList;\n-import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n-import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n-import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n-import static io.prestosql.spi.predicate.Domain.singleValue;\n-import static io.prestosql.spi.type.IntegerType.INTEGER;\n-import static io.prestosql.spi.type.VarcharType.VARCHAR;\n-import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n-import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n-import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n-import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n-import static io.prestosql.testing.TestingSession.testSessionBuilder;\n-import static io.prestosql.transaction.TransactionBuilder.transaction;\n-import static org.assertj.core.api.Assertions.assertThatThrownBy;\n-\n-public class TestTableScanRedirectionWithPushdown\n-{\n-    private static final String MOCK_CATALOG = \"mock_catalog\";\n-    private static final String TEST_SCHEMA = \"test_schema\";\n-    private static final String TEST_TABLE = \"test_table\";\n-    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n-\n-    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n-\n-    private static final String sourceColumnNameA = \"source_col_a\";\n-    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n-    private static final String sourceColumnNameB = \"source_col_b\";\n-    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n-    private static final String sourceColumnNameC = \"source_col_c\";\n-    private static final ColumnHandle sourceColumnHandleC = new MockConnectorColumnHandle(sourceColumnNameC, VARCHAR);\n-\n-    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n-    private static final String destinationColumnNameA = \"destination_col_a\";\n-    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n-    private static final String destinationColumnNameB = \"destination_col_b\";\n-    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n-\n-    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n-\n-    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n-            sourceColumnHandleA, destinationColumnNameA,\n-            sourceColumnHandleB, destinationColumnNameB);\n-\n-    private static final Map<ColumnHandle, String> typeMismatchedRedirectionMappingBC = ImmutableMap.of(\n-            sourceColumnHandleB, destinationColumnNameB,\n-            sourceColumnHandleC, destinationColumnNameA);\n-\n-    @Test\n-    public void testRedirectionAfterProjectionPushdown()\n-    {\n-        // make the mock connector return a table scan on destination table only if\n-        // the connector can detect that source_col_a is projected\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                this::mockApplyRedirectAfterProjectionPushdown,\n-                Optional.of(this::mockApplyProjection),\n-                Optional.empty())) {\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a FROM test_table\",\n-                    output(\n-                            ImmutableList.of(\"DEST_COL\"),\n-                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n-\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a, source_col_b FROM test_table\",\n-                    output(\n-                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n-                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n-\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n-                    output(\n-                            ImmutableList.of(\"DEST_COL\"),\n-                            filter(\n-                                    \"DEST_COL > 0\",\n-                                    tableScan(\n-                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n-                                            TupleDomain.all(),\n-                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n-        }\n-    }\n-\n-    @Test\n-    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n-    {\n-        // make the mock connector return a table scan on destination table only if\n-        // the connector can detect a filter\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA, Optional.empty()),\n-                Optional.empty(),\n-                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleA))))) {\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n-                    output(\n-                            ImmutableList.of(\"DEST_COL\"),\n-                            tableScan(\n-                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n-                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n-                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n-\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a FROM test_table\",\n-                    output(\n-                            ImmutableList.of(\"SOURCE_COL\"),\n-                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n-        }\n-    }\n-\n-    @Test\n-    public void testPredicatePushdownAfterRedirect()\n-    {\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB, Optional.empty()),\n-                Optional.empty(),\n-                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleB))))) {\n-            // Only 'source_col_a = 1' will get pushed down into source table scan\n-            // Only 'dest_col_b = 2' will get pushed down into destination table scan\n-            // This test verifies that the Filter('dest_col_a = 1') produced by redirection\n-            // does not prevent pushdown of 'dest_col_b = 2' into destination table scan\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a, source_col_b FROM test_table WHERE source_col_a = 1 AND source_col_b = 2\",\n-                    output(\n-                            ImmutableList.of(\"DEST_COL_A\", \"DEST_COL_B\"),\n-                            filter(\n-                                    \"DEST_COL_A = 1\",\n-                                    tableScan(\n-                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n-                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleB), singleValue(INTEGER, 2L))),\n-                                            ImmutableMap.of(\n-                                                    \"DEST_COL_A\", equalTo(destinationColumnHandleA),\n-                                                    \"DEST_COL_B\", equalTo(destinationColumnHandleB))))));\n-        }\n-    }\n-\n-    @Test\n-    public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n-    {\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB, Optional.of(ImmutableSet.of(sourceColumnHandleB))),\n-                Optional.of(this::mockApplyProjection),\n-                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleA))))) {\n-            // After 'source_col_a = 1' is pushed into source table scan, it's possible for 'source_col_a' table scan assignment to be pruned\n-            // Redirection results in Project('dest_col_b') -> Filter('dest_col_a = 1') -> TableScan for such case\n-            // Subsequent PPD and column pruning rules simplify the above as supported by the destination connector\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_b FROM test_table WHERE source_col_a = 1\",\n-                    output(\n-                            ImmutableList.of(\"DEST_COL_B\"),\n-                            tableScan(\n-                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n-                                    // PushProjectionIntoTableScan does not preserve enforced constraint\n-                                    // (issue: https://github.com/prestosql/presto/issues/6029)\n-                                    TupleDomain.all(),\n-                                    ImmutableMap.of(\"DEST_COL_B\", equalTo(destinationColumnHandleB)))));\n-        }\n-    }\n-\n-    @Test\n-    public void testPredicateTypeMismatch()\n-    {\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB))),\n-                Optional.of(this::mockApplyProjection),\n-                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleC))))) {\n-            // After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n-            // Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n-            // but dest_col_a has mismatched type compared to source domain\n-            transaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n-                    .execute(MOCK_SESSION, session -> {\n-                        assertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n-                                .isInstanceOf(PrestoException.class)\n-                                .hasMessageMatching(\"Redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, different from source column .*MockConnectorTableHandle.*source_col_c.* type: varchar\");\n-                    });\n-        }\n-    }\n-\n-    private LocalQueryRunner createLocalQueryRunner(\n-            ApplyTableScanRedirect applyTableScanRedirect,\n-            Optional<ApplyProjection> applyProjection,\n-            Optional<ApplyFilter> applyFilter)\n-    {\n-        LocalQueryRunner queryRunner = LocalQueryRunner.create(MOCK_SESSION);\n-        MockConnectorFactory.Builder builder = MockConnectorFactory.builder()\n-                .withGetTableHandle((session, schemaTableName) -> new MockConnectorTableHandle(schemaTableName))\n-                .withGetColumns(name -> {\n-                    if (name.equals(sourceTable)) {\n-                        return ImmutableList.of(\n-                                new ColumnMetadata(sourceColumnNameA, INTEGER),\n-                                new ColumnMetadata(sourceColumnNameB, INTEGER),\n-                                new ColumnMetadata(sourceColumnNameC, VARCHAR));\n-                    }\n-                    else if (name.equals(destinationTable)) {\n-                        return ImmutableList.of(\n-                                new ColumnMetadata(destinationColumnNameA, INTEGER),\n-                                new ColumnMetadata(destinationColumnNameB, INTEGER));\n-                    }\n-                    throw new IllegalArgumentException();\n-                })\n-                .withApplyTableScanRedirect(applyTableScanRedirect);\n-        applyProjection.ifPresent(builder::withApplyProjection);\n-        applyFilter.ifPresent(builder::withApplyFilter);\n-\n-        queryRunner.createCatalog(MOCK_CATALOG, builder.build(), ImmutableMap.of());\n-        return queryRunner;\n-    }\n-\n-    private Optional<ProjectionApplicationResult<ConnectorTableHandle>> mockApplyProjection(\n-            ConnectorSession session,\n-            ConnectorTableHandle tableHandle,\n-            List<ConnectorExpression> projections,\n-            Map<String, ColumnHandle> assignments)\n-    {\n-        MockConnectorTableHandle handle = (MockConnectorTableHandle) tableHandle;\n-\n-        List<Variable> variables = projections.stream()\n-                .map(Variable.class::cast)\n-                .collect(toImmutableList());\n-        List<ColumnHandle> newColumns = variables.stream()\n-                .map(variable -> assignments.get(variable.getName()))\n-                .collect(toImmutableList());\n-        if (handle.getColumns().isPresent() && newColumns.equals(handle.getColumns().get())) {\n-            return Optional.empty();\n-        }\n-\n-        return Optional.of(\n-                new ProjectionApplicationResult<>(\n-                        new MockConnectorTableHandle(handle.getTableName(), handle.getConstraint(), Optional.of(newColumns)),\n-                        projections,\n-                        variables.stream()\n-                                .map(variable -> new Assignment(\n-                                        variable.getName(),\n-                                        assignments.get(variable.getName()),\n-                                        ((MockConnectorColumnHandle) assignments.get(variable.getName())).getType()))\n-                                .collect(toImmutableList())));\n-    }\n-\n-    private Optional<TableScanRedirectApplicationResult> mockApplyRedirectAfterProjectionPushdown(\n-            ConnectorSession session,\n-            ConnectorTableHandle handle)\n-    {\n-        MockConnectorTableHandle mockConnectorTable = (MockConnectorTableHandle) handle;\n-        Optional<List<ColumnHandle>> projectedColumns = mockConnectorTable.getColumns();\n-        if (projectedColumns.isEmpty()) {\n-            return Optional.empty();\n-        }\n-        List<String> projectedColumnNames = projectedColumns.get().stream()\n-                .map(MockConnectorColumnHandle.class::cast)\n-                .map(MockConnectorColumnHandle::getName)\n-                .collect(toImmutableList());\n-        if (!projectedColumnNames.equals(ImmutableList.of(sourceColumnNameA))) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(\n-                new TableScanRedirectApplicationResult(\n-                        new CatalogSchemaTableName(MOCK_CATALOG, destinationTable),\n-                        redirectionMappingA,\n-                        mockConnectorTable.getConstraint()\n-                                .transform(MockConnectorColumnHandle.class::cast)\n-                                .transform(MockConnectorColumnHandle::getName)));\n-    }\n-\n-    private ApplyFilter getMockApplyFilter(Set<ColumnHandle> pushdownColumns)\n-    {\n-        // returns a mock implementation of applyFilter which allows predicate pushdown only for pushdownColumns\n-        return (session, table, constraint) -> {\n-            MockConnectorTableHandle handle = (MockConnectorTableHandle) table;\n-\n-            TupleDomain<ColumnHandle> oldDomain = handle.getConstraint();\n-            TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary()\n-                    .filter((columnHandle, domain) -> pushdownColumns.contains(columnHandle)));\n-            if (oldDomain.equals(newDomain)) {\n-                return Optional.empty();\n-            }\n-\n-            return Optional.of(\n-                    new ConstraintApplicationResult<>(\n-                            new MockConnectorTableHandle(handle.getTableName(), newDomain, Optional.empty()),\n-                            constraint.getSummary()\n-                                    .filter((columnHandle, domain) -> !pushdownColumns.contains(columnHandle))));\n-        };\n-    }\n-\n-    private ApplyTableScanRedirect getMockApplyRedirectAfterPredicatePushdown(\n-            Map<ColumnHandle, String> redirectionMapping,\n-            Optional<Set<ColumnHandle>> requiredProjections)\n-    {\n-        return (session, handle) -> {\n-            MockConnectorTableHandle mockConnectorTable = (MockConnectorTableHandle) handle;\n-            // make sure we do redirection after predicate is pushed down\n-            if (mockConnectorTable.getConstraint().isAll()) {\n-                return Optional.empty();\n-            }\n-            Optional<List<ColumnHandle>> projectedColumns = mockConnectorTable.getColumns();\n-            if (requiredProjections.isPresent()\n-                    && (projectedColumns.isEmpty() || !requiredProjections.get().equals(ImmutableSet.copyOf(projectedColumns.get())))) {\n-                return Optional.empty();\n-            }\n-            return Optional.of(\n-                    new TableScanRedirectApplicationResult(\n-                            new CatalogSchemaTableName(MOCK_CATALOG, destinationTable),\n-                            redirectionMapping,\n-                            mockConnectorTable.getConstraint()\n-                                    .transform(MockConnectorColumnHandle.class::cast)\n-                                    .transform(redirectionMapping::get)));\n-        };\n-    }\n-\n-    void assertPlan(LocalQueryRunner queryRunner, @Language(\"SQL\") String sql, PlanMatchPattern pattern)\n-    {\n-        List<PlanOptimizer> optimizers = queryRunner.getPlanOptimizers(true);\n-\n-        queryRunner.inTransaction(transactionSession -> {\n-            Plan actualPlan = queryRunner.createPlan(transactionSession, sql, optimizers, OPTIMIZED_AND_VALIDATED, WarningCollector.NOOP);\n-            PlanAssert.assertPlan(transactionSession, queryRunner.getMetadata(), queryRunner.getStatsCalculator(), actualPlan, pattern);\n-            return null;\n-        });\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxMTkyMQ==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639911921", "bodyText": "Commit message should provide some explanation on what this change is about", "author": "martint", "createdAt": "2021-05-26T16:37:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -16,6 +16,8 @@\n import com.google.common.collect.ImmutableBiMap;", "originalCommit": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java\ndeleted file mode 100644\nindex ce58a03f9e..0000000000\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java\n+++ /dev/null\n\n@@ -1,274 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.prestosql.sql.planner.iterative.rule;\n-\n-import com.google.common.collect.ImmutableBiMap;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Sets;\n-import io.prestosql.matching.Captures;\n-import io.prestosql.matching.Pattern;\n-import io.prestosql.metadata.Metadata;\n-import io.prestosql.metadata.TableHandle;\n-import io.prestosql.spi.PrestoException;\n-import io.prestosql.spi.connector.CatalogSchemaTableName;\n-import io.prestosql.spi.connector.ColumnHandle;\n-import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n-import io.prestosql.spi.predicate.TupleDomain;\n-import io.prestosql.spi.type.Type;\n-import io.prestosql.sql.planner.DomainTranslator;\n-import io.prestosql.sql.planner.PlanNodeIdAllocator;\n-import io.prestosql.sql.planner.Symbol;\n-import io.prestosql.sql.planner.iterative.Rule;\n-import io.prestosql.sql.planner.plan.Assignments;\n-import io.prestosql.sql.planner.plan.FilterNode;\n-import io.prestosql.sql.planner.plan.PlanNode;\n-import io.prestosql.sql.planner.plan.ProjectNode;\n-import io.prestosql.sql.planner.plan.TableScanNode;\n-import io.prestosql.sql.tree.Cast;\n-\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-\n-import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n-import static io.prestosql.spi.StandardErrorCode.COLUMN_NOT_FOUND;\n-import static io.prestosql.spi.StandardErrorCode.FUNCTION_NOT_FOUND;\n-import static io.prestosql.spi.StandardErrorCode.TABLE_NOT_FOUND;\n-import static io.prestosql.spi.StandardErrorCode.TYPE_MISMATCH;\n-import static io.prestosql.sql.analyzer.TypeSignatureTranslator.toSqlType;\n-import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static java.lang.String.format;\n-import static java.util.Objects.requireNonNull;\n-\n-public class ApplyTableScanRedirection\n-        implements Rule<TableScanNode>\n-{\n-    private static final Pattern<TableScanNode> PATTERN = tableScan();\n-\n-    private final Metadata metadata;\n-    private final DomainTranslator domainTranslator;\n-\n-    public ApplyTableScanRedirection(Metadata metadata)\n-    {\n-        this.metadata = requireNonNull(metadata, \"metadata is null\");\n-        this.domainTranslator = new DomainTranslator(metadata);\n-    }\n-\n-    @Override\n-    public Pattern<TableScanNode> getPattern()\n-    {\n-        return PATTERN;\n-    }\n-\n-    @Override\n-    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n-    {\n-        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n-        if (tableScanRedirectApplicationResult.isEmpty()) {\n-            return Result.empty();\n-        }\n-\n-        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n-        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n-                context.getSession(),\n-                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n-        if (destinationTableHandle.isEmpty()) {\n-            throw new PrestoException(TABLE_NOT_FOUND, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n-        }\n-        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n-            return Result.empty();\n-        }\n-\n-        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n-        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n-        ImmutableMap.Builder<Symbol, Cast> casts = ImmutableMap.builder();\n-        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.builder();\n-        for (Map.Entry<Symbol, ColumnHandle> assignment : scanNode.getAssignments().entrySet()) {\n-            String destinationColumn = columnMapping.get(assignment.getValue());\n-            if (destinationColumn == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", assignment.getValue()));\n-            }\n-            ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n-            if (destinationColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n-            }\n-\n-            // insert casts if redirected types don't match source types\n-            Type sourceType = context.getSymbolAllocator().getTypes().get(assignment.getKey());\n-            Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n-            if (!sourceType.equals(redirectedType)) {\n-                Symbol redirectedSymbol = context.getSymbolAllocator().newSymbol(destinationColumn, redirectedType);\n-                Cast cast = getCast(\n-                        tableScanRedirectApplicationResult.get().isAllowCoercions(),\n-                        destinationTable,\n-                        destinationColumn,\n-                        redirectedType,\n-                        redirectedSymbol,\n-                        scanNode.getTable(),\n-                        assignment.getValue(),\n-                        sourceType);\n-                casts.put(assignment.getKey(), cast);\n-                newAssignmentsBuilder.put(redirectedSymbol, destinationColumnHandle);\n-            }\n-            else {\n-                newAssignmentsBuilder.put(assignment.getKey(), destinationColumnHandle);\n-            }\n-        }\n-\n-        TupleDomain<String> requiredFilter = tableScanRedirectApplicationResult.get().getFilter();\n-        if (requiredFilter.isAll()) {\n-            ImmutableMap<Symbol, ColumnHandle> newAssignments = newAssignmentsBuilder.build();\n-            return Result.ofPlanNode(applyProjection(\n-                    context.getIdAllocator(),\n-                    ImmutableSet.copyOf(scanNode.getOutputSymbols()),\n-                    casts.build(),\n-                    new TableScanNode(\n-                            scanNode.getId(),\n-                            destinationTableHandle.get(),\n-                            ImmutableList.copyOf(newAssignments.keySet()),\n-                            newAssignments,\n-                            TupleDomain.all(),\n-                            scanNode.isForDelete())));\n-        }\n-\n-        Map<ColumnHandle, Symbol> inverseAssignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n-        Map<String, ColumnHandle> inverseColumnsMapping = ImmutableBiMap.copyOf(columnMapping).inverse();\n-        TupleDomain<Symbol> transformedConstraint = requiredFilter.transform(destinationColumn -> {\n-            ColumnHandle sourceColumnHandle = inverseColumnsMapping.get(destinationColumn);\n-            if (sourceColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for destination column %s in table scan redirection\", destinationColumn));\n-            }\n-            Symbol symbol = inverseAssignments.get(sourceColumnHandle);\n-            if (symbol != null) {\n-                // symbol should be mapped in redirected table scan\n-                return symbol;\n-            }\n-\n-            // Column pruning after predicate is pushed into table scan can remove assignments for filter columns from the scan node\n-            Type domainType = requiredFilter.getDomains().get().get(destinationColumn).getType();\n-            symbol = context.getSymbolAllocator().newSymbol(destinationColumn, domainType);\n-\n-            ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n-            if (destinationColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n-            }\n-\n-            // insert casts if redirected types don't match domain types\n-            Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n-            if (!domainType.equals(redirectedType)) {\n-                Symbol redirectedSymbol = context.getSymbolAllocator().newSymbol(destinationColumn, redirectedType);\n-                Cast cast = getCast(\n-                        tableScanRedirectApplicationResult.get().isAllowCoercions(),\n-                        destinationTable,\n-                        destinationColumn,\n-                        redirectedType,\n-                        redirectedSymbol,\n-                        scanNode.getTable(),\n-                        sourceColumnHandle,\n-                        domainType);\n-                casts.put(symbol, cast);\n-                newAssignmentsBuilder.put(redirectedSymbol, destinationColumnHandle);\n-            }\n-            else {\n-                newAssignmentsBuilder.put(symbol, destinationColumnHandle);\n-            }\n-\n-            return symbol;\n-        });\n-\n-        Map<Symbol, ColumnHandle> newAssignments = newAssignmentsBuilder.build();\n-        TableScanNode newScanNode = new TableScanNode(\n-                scanNode.getId(),\n-                destinationTableHandle.get(),\n-                ImmutableList.copyOf(newAssignments.keySet()),\n-                newAssignments,\n-                TupleDomain.all(),\n-                scanNode.isForDelete());\n-\n-        FilterNode filterNode = new FilterNode(\n-                context.getIdAllocator().getNextId(),\n-                applyProjection(\n-                        context.getIdAllocator(),\n-                        newAssignments.keySet(),\n-                        casts.build(),\n-                        newScanNode),\n-                domainTranslator.toPredicate(transformedConstraint));\n-\n-        return Result.ofPlanNode(applyProjection(\n-                context.getIdAllocator(),\n-                ImmutableSet.copyOf(scanNode.getOutputSymbols()),\n-                ImmutableMap.of(),\n-                filterNode));\n-    }\n-\n-    private PlanNode applyProjection(\n-            PlanNodeIdAllocator idAllocator,\n-            Set<Symbol> requiredSymbols,\n-            Map<Symbol, Cast> casts,\n-            PlanNode source)\n-    {\n-        if (casts.isEmpty() && requiredSymbols.equals(ImmutableSet.copyOf(source.getOutputSymbols()))) {\n-            return source;\n-        }\n-\n-        return new ProjectNode(\n-                idAllocator.getNextId(),\n-                source,\n-                Assignments.builder()\n-                        .putIdentities(Sets.difference(requiredSymbols, casts.keySet()))\n-                        .putAll(casts)\n-                        .build());\n-    }\n-\n-    private Cast getCast(\n-            boolean allowCoercions,\n-            CatalogSchemaTableName destinationTable,\n-            String destinationColumn,\n-            Type destinationType,\n-            Symbol destinationSymbol,\n-            TableHandle sourceTable,\n-            ColumnHandle sourceColumnHandle,\n-            Type sourceType)\n-    {\n-        if (!allowCoercions) {\n-            throw new PrestoException(TYPE_MISMATCH, format(\n-                    \"Redirected column %s.%s has type %s, different from source column %s.%s type: %s\",\n-                    destinationTable,\n-                    destinationColumn,\n-                    destinationType,\n-                    // TODO report source table and column name instead of ConnectorTableHandle, ConnectorColumnHandle toString\n-                    sourceTable,\n-                    sourceColumnHandle,\n-                    sourceType));\n-        }\n-\n-        try {\n-            metadata.getCoercion(destinationType, sourceType);\n-        }\n-        catch (PrestoException e) {\n-            throw new PrestoException(FUNCTION_NOT_FOUND, format(\n-                    \"Cast not possible from redirected column %s.%s with type %s to source column %s.%s with type: %s\",\n-                    destinationTable,\n-                    destinationColumn,\n-                    destinationType,\n-                    sourceTable,\n-                    sourceColumnHandle,\n-                    sourceType));\n-        }\n-\n-        return new Cast(destinationSymbol.toSymbolReference(), toSqlType(sourceType));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639914049", "bodyText": "When and why would this ever be false? This doesn't seem necessary. If the connector doesn't want to allow coercions, it should just not perform the redirection.", "author": "martint", "createdAt": "2021-05-26T16:40:40Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/TableScanRedirectApplicationResult.java", "diffHunk": "@@ -26,12 +26,27 @@\n     private final Map<ColumnHandle, String> destinationColumns;\n     // filter that needs to be applied on top of table scan\n     private final TupleDomain<String> filter;\n+    // should coercions be used when source and redirected column types don't match\n+    private boolean allowCoercions;", "originalCommit": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDUyMjIzMw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640522233", "bodyText": "I was thinking this would be useful for connectors that want to match source with redirected table 1-1 (without mismatched type) and would prefer to throw exception when types mismatch", "author": "sopel39", "createdAt": "2021-05-27T11:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDczMzUxNA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640733514", "bodyText": "The can do this on its own. It needs to somehow be aware of the target table anyway, so it can do this check by itself.", "author": "martint", "createdAt": "2021-05-27T15:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkyNTkxNg==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640925916", "bodyText": "It needs to somehow be aware of the target table anyway, so it can do this check by itself.\n\nIt might not be aware of target table types since it can be in different catalog and could be created externally.", "author": "sopel39", "createdAt": "2021-05-27T19:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkyOTI2MA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640929260", "bodyText": "Then how is it going to know to redirect to those tables, or that they are the right table to redirect to? Table redirections don't seem very useful without that level of understanding, so it seems reasonable to me to expect that from connectors.", "author": "martint", "createdAt": "2021-05-27T20:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDk0Mjg5Mw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640942893", "bodyText": "removed toggle", "author": "sopel39", "createdAt": "2021-05-27T20:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/TableScanRedirectApplicationResult.java b/presto-spi/src/main/java/io/prestosql/spi/connector/TableScanRedirectApplicationResult.java\ndeleted file mode 100644\nindex 2a62dd41e6..0000000000\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/TableScanRedirectApplicationResult.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.prestosql.spi.connector;\n-\n-import io.prestosql.spi.predicate.TupleDomain;\n-\n-import java.util.Map;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-public class TableScanRedirectApplicationResult\n-{\n-    private final CatalogSchemaTableName destinationTable;\n-    // mapping of source table handles to destination table columns\n-    private final Map<ColumnHandle, String> destinationColumns;\n-    // filter that needs to be applied on top of table scan\n-    private final TupleDomain<String> filter;\n-    // should coercions be used when source and redirected column types don't match\n-    private boolean allowCoercions;\n-\n-    public TableScanRedirectApplicationResult(\n-            CatalogSchemaTableName destinationTable,\n-            Map<ColumnHandle, String> destinationColumns,\n-            TupleDomain<String> filter)\n-    {\n-        this(destinationTable, destinationColumns, filter, false);\n-    }\n-\n-    public TableScanRedirectApplicationResult(\n-            CatalogSchemaTableName destinationTable,\n-            Map<ColumnHandle, String> destinationColumns,\n-            TupleDomain<String> filter,\n-            boolean allowCoercions)\n-    {\n-        this.destinationTable = requireNonNull(destinationTable, \"destinationTable is null\");\n-        this.destinationColumns = Map.copyOf(requireNonNull(destinationColumns, \"destinationColumns is null\"));\n-        this.filter = requireNonNull(filter, \"filter is null\");\n-        this.allowCoercions = allowCoercions;\n-    }\n-\n-    public CatalogSchemaTableName getDestinationTable()\n-    {\n-        return destinationTable;\n-    }\n-\n-    public Map<ColumnHandle, String> getDestinationColumns()\n-    {\n-        return destinationColumns;\n-    }\n-\n-    public TupleDomain<String> getFilter()\n-    {\n-        return filter;\n-    }\n-\n-    public boolean isAllowCoercions()\n-    {\n-        return allowCoercions;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNTExNg==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639915116", "bodyText": "This belongs in the previous commit", "author": "martint", "createdAt": "2021-05-26T16:42:03Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -215,12 +223,12 @@ public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n     public void testPredicateTypeMismatch()\n     {\n         try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB))),\n+                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB)), false),\n                 Optional.of(this::mockApplyProjection),\n                 Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleC))))) {\n             // After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n             // Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n-            // but dest_col_a has mismatched type compared to source domain\n+            // but dest_col_c has mismatched type compared to source domain", "originalCommit": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "chunk": "diff --git a/presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java b/presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java\ndeleted file mode 100644\nindex f8a8e70362..0000000000\n--- a/presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java\n+++ /dev/null\n\n@@ -1,432 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.prestosql.sql.planner;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n-import io.prestosql.Session;\n-import io.prestosql.connector.MockConnectorColumnHandle;\n-import io.prestosql.connector.MockConnectorFactory;\n-import io.prestosql.connector.MockConnectorTableHandle;\n-import io.prestosql.execution.warnings.WarningCollector;\n-import io.prestosql.spi.PrestoException;\n-import io.prestosql.spi.connector.Assignment;\n-import io.prestosql.spi.connector.CatalogSchemaTableName;\n-import io.prestosql.spi.connector.ColumnHandle;\n-import io.prestosql.spi.connector.ColumnMetadata;\n-import io.prestosql.spi.connector.ConnectorSession;\n-import io.prestosql.spi.connector.ConnectorTableHandle;\n-import io.prestosql.spi.connector.ConstraintApplicationResult;\n-import io.prestosql.spi.connector.ProjectionApplicationResult;\n-import io.prestosql.spi.connector.SchemaTableName;\n-import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n-import io.prestosql.spi.expression.ConnectorExpression;\n-import io.prestosql.spi.expression.Variable;\n-import io.prestosql.spi.predicate.TupleDomain;\n-import io.prestosql.sql.planner.assertions.PlanAssert;\n-import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n-import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n-import io.prestosql.testing.LocalQueryRunner;\n-import org.intellij.lang.annotations.Language;\n-import org.testng.annotations.Test;\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-\n-import static com.google.common.base.Predicates.equalTo;\n-import static com.google.common.collect.ImmutableList.toImmutableList;\n-import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n-import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n-import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n-import static io.prestosql.spi.predicate.Domain.singleValue;\n-import static io.prestosql.spi.type.IntegerType.INTEGER;\n-import static io.prestosql.spi.type.VarcharType.VARCHAR;\n-import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n-import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n-import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n-import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n-import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n-import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n-import static io.prestosql.testing.TestingSession.testSessionBuilder;\n-import static io.prestosql.tests.BogusType.BOGUS;\n-import static io.prestosql.transaction.TransactionBuilder.transaction;\n-import static org.assertj.core.api.Assertions.assertThatThrownBy;\n-\n-public class TestTableScanRedirectionWithPushdown\n-{\n-    private static final String MOCK_CATALOG = \"mock_catalog\";\n-    private static final String TEST_SCHEMA = \"test_schema\";\n-    private static final String TEST_TABLE = \"test_table\";\n-    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n-\n-    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n-\n-    private static final String sourceColumnNameA = \"source_col_a\";\n-    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n-    private static final String sourceColumnNameB = \"source_col_b\";\n-    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n-    private static final String sourceColumnNameC = \"source_col_c\";\n-    private static final ColumnHandle sourceColumnHandleC = new MockConnectorColumnHandle(sourceColumnNameC, VARCHAR);\n-\n-    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n-    private static final String destinationColumnNameA = \"destination_col_a\";\n-    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n-    private static final String destinationColumnNameB = \"destination_col_b\";\n-    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n-    private static final String destinationColumnNameC = \"destination_col_c\";\n-\n-    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n-\n-    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n-            sourceColumnHandleA, destinationColumnNameA,\n-            sourceColumnHandleB, destinationColumnNameB);\n-\n-    private static final Map<ColumnHandle, String> typeMismatchedRedirectionMappingBC = ImmutableMap.of(\n-            sourceColumnHandleB, destinationColumnNameB,\n-            sourceColumnHandleC, destinationColumnNameA);\n-\n-    private static final Map<ColumnHandle, String> bogusRedirectionMappingBC = ImmutableMap.of(\n-            sourceColumnHandleB, destinationColumnNameB,\n-            sourceColumnHandleC, destinationColumnNameC);\n-\n-    @Test\n-    public void testRedirectionAfterProjectionPushdown()\n-    {\n-        // make the mock connector return a table scan on destination table only if\n-        // the connector can detect that source_col_a is projected\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                this::mockApplyRedirectAfterProjectionPushdown,\n-                Optional.of(this::mockApplyProjection),\n-                Optional.empty())) {\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a FROM test_table\",\n-                    output(\n-                            ImmutableList.of(\"DEST_COL\"),\n-                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n-\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a, source_col_b FROM test_table\",\n-                    output(\n-                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n-                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n-\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n-                    output(\n-                            ImmutableList.of(\"DEST_COL\"),\n-                            filter(\n-                                    \"DEST_COL > 0\",\n-                                    tableScan(\n-                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n-                                            TupleDomain.all(),\n-                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n-        }\n-    }\n-\n-    @Test\n-    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n-    {\n-        // make the mock connector return a table scan on destination table only if\n-        // the connector can detect a filter\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA, Optional.empty(), false),\n-                Optional.empty(),\n-                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleA))))) {\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n-                    output(\n-                            ImmutableList.of(\"DEST_COL\"),\n-                            tableScan(\n-                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n-                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n-                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n-\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a FROM test_table\",\n-                    output(\n-                            ImmutableList.of(\"SOURCE_COL\"),\n-                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n-        }\n-    }\n-\n-    @Test\n-    public void testPredicatePushdownAfterRedirect()\n-    {\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB, Optional.empty(), false),\n-                Optional.empty(),\n-                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleB))))) {\n-            // Only 'source_col_a = 1' will get pushed down into source table scan\n-            // Only 'dest_col_b = 2' will get pushed down into destination table scan\n-            // This test verifies that the Filter('dest_col_a = 1') produced by redirection\n-            // does not prevent pushdown of 'dest_col_b = 2' into destination table scan\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_a, source_col_b FROM test_table WHERE source_col_a = 1 AND source_col_b = 2\",\n-                    output(\n-                            ImmutableList.of(\"DEST_COL_A\", \"DEST_COL_B\"),\n-                            filter(\n-                                    \"DEST_COL_A = 1\",\n-                                    tableScan(\n-                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n-                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleB), singleValue(INTEGER, 2L))),\n-                                            ImmutableMap.of(\n-                                                    \"DEST_COL_A\", equalTo(destinationColumnHandleA),\n-                                                    \"DEST_COL_B\", equalTo(destinationColumnHandleB))))));\n-        }\n-    }\n-\n-    @Test\n-    public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n-    {\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB, Optional.of(ImmutableSet.of(sourceColumnHandleB)), false),\n-                Optional.of(this::mockApplyProjection),\n-                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleA))))) {\n-            // After 'source_col_a = 1' is pushed into source table scan, it's possible for 'source_col_a' table scan assignment to be pruned\n-            // Redirection results in Project('dest_col_b') -> Filter('dest_col_a = 1') -> TableScan for such case\n-            // Subsequent PPD and column pruning rules simplify the above as supported by the destination connector\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_b FROM test_table WHERE source_col_a = 1\",\n-                    output(\n-                            ImmutableList.of(\"DEST_COL_B\"),\n-                            tableScan(\n-                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n-                                    // PushProjectionIntoTableScan does not preserve enforced constraint\n-                                    // (issue: https://github.com/prestosql/presto/issues/6029)\n-                                    TupleDomain.all(),\n-                                    ImmutableMap.of(\"DEST_COL_B\", equalTo(destinationColumnHandleB)))));\n-        }\n-    }\n-\n-    @Test\n-    public void testPredicateTypeMismatch()\n-    {\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB)), false),\n-                Optional.of(this::mockApplyProjection),\n-                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleC))))) {\n-            // After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n-            // Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n-            // but dest_col_c has mismatched type compared to source domain\n-            transaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n-                    .execute(MOCK_SESSION, session -> {\n-                        assertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n-                                .isInstanceOf(PrestoException.class)\n-                                .hasMessageMatching(\"Redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, different from source column .*MockConnectorTableHandle.*source_col_c.* type: varchar\");\n-                    });\n-        }\n-    }\n-\n-    @Test\n-    public void testPredicateTypeWithCoercion()\n-    {\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB)), true),\n-                Optional.of(this::mockApplyProjection),\n-                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleC))))) {\n-            // After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n-            // Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n-            // but dest_col_a has mismatched type compared to source domain\n-            assertPlan(\n-                    queryRunner,\n-                    \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\",\n-                    output(\n-                            ImmutableList.of(\"DEST_COL_B\"),\n-                            project(ImmutableMap.of(\"DEST_COL_B\", expression(\"DEST_COL_B\")),\n-                                    filter(\"CAST(DEST_COL_A AS VARCHAR) = CAST('foo' AS VARCHAR)\",\n-                                            tableScan(\n-                                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n-                                                    // PushProjectionIntoTableScan does not preserve enforced constraint\n-                                                    // (issue: https://github.com/prestosql/presto/issues/6029)\n-                                                    TupleDomain.all(),\n-                                                    ImmutableMap.of(\n-                                                            \"DEST_COL_B\", equalTo(destinationColumnHandleB),\n-                                                            \"DEST_COL_A\", equalTo(destinationColumnHandleA)))))));\n-        }\n-    }\n-\n-    @Test\n-    public void testPredicateTypeMismatchWithMissingCoercion()\n-    {\n-        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(bogusRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB)), true),\n-                Optional.of(this::mockApplyProjection),\n-                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleC))))) {\n-            // After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n-            // Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n-            // but dest_col_a has mismatched type compared to source domain\n-            transaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n-                    .execute(MOCK_SESSION, session -> {\n-                        assertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n-                                .isInstanceOf(PrestoException.class)\n-                                .hasMessageMatching(\"Cast not possible from redirected column mock_catalog.target_schema.target_table.destination_col_c with type Bogus to source column .*MockConnectorTableHandle.*source_col_c.* with type: varchar\");\n-                    });\n-        }\n-    }\n-\n-    private LocalQueryRunner createLocalQueryRunner(\n-            ApplyTableScanRedirect applyTableScanRedirect,\n-            Optional<ApplyProjection> applyProjection,\n-            Optional<ApplyFilter> applyFilter)\n-    {\n-        LocalQueryRunner queryRunner = LocalQueryRunner.create(MOCK_SESSION);\n-        MockConnectorFactory.Builder builder = MockConnectorFactory.builder()\n-                .withGetTableHandle((session, schemaTableName) -> new MockConnectorTableHandle(schemaTableName))\n-                .withGetColumns(name -> {\n-                    if (name.equals(sourceTable)) {\n-                        return ImmutableList.of(\n-                                new ColumnMetadata(sourceColumnNameA, INTEGER),\n-                                new ColumnMetadata(sourceColumnNameB, INTEGER),\n-                                new ColumnMetadata(sourceColumnNameC, VARCHAR));\n-                    }\n-                    else if (name.equals(destinationTable)) {\n-                        return ImmutableList.of(\n-                                new ColumnMetadata(destinationColumnNameA, INTEGER),\n-                                new ColumnMetadata(destinationColumnNameB, INTEGER),\n-                                new ColumnMetadata(destinationColumnNameC, BOGUS));\n-                    }\n-                    throw new IllegalArgumentException();\n-                })\n-                .withApplyTableScanRedirect(applyTableScanRedirect);\n-        applyProjection.ifPresent(builder::withApplyProjection);\n-        applyFilter.ifPresent(builder::withApplyFilter);\n-\n-        queryRunner.createCatalog(MOCK_CATALOG, builder.build(), ImmutableMap.of());\n-        return queryRunner;\n-    }\n-\n-    private Optional<ProjectionApplicationResult<ConnectorTableHandle>> mockApplyProjection(\n-            ConnectorSession session,\n-            ConnectorTableHandle tableHandle,\n-            List<ConnectorExpression> projections,\n-            Map<String, ColumnHandle> assignments)\n-    {\n-        MockConnectorTableHandle handle = (MockConnectorTableHandle) tableHandle;\n-\n-        List<Variable> variables = projections.stream()\n-                .map(Variable.class::cast)\n-                .collect(toImmutableList());\n-        List<ColumnHandle> newColumns = variables.stream()\n-                .map(variable -> assignments.get(variable.getName()))\n-                .collect(toImmutableList());\n-        if (handle.getColumns().isPresent() && newColumns.equals(handle.getColumns().get())) {\n-            return Optional.empty();\n-        }\n-\n-        return Optional.of(\n-                new ProjectionApplicationResult<>(\n-                        new MockConnectorTableHandle(handle.getTableName(), handle.getConstraint(), Optional.of(newColumns)),\n-                        projections,\n-                        variables.stream()\n-                                .map(variable -> new Assignment(\n-                                        variable.getName(),\n-                                        assignments.get(variable.getName()),\n-                                        ((MockConnectorColumnHandle) assignments.get(variable.getName())).getType()))\n-                                .collect(toImmutableList())));\n-    }\n-\n-    private Optional<TableScanRedirectApplicationResult> mockApplyRedirectAfterProjectionPushdown(\n-            ConnectorSession session,\n-            ConnectorTableHandle handle)\n-    {\n-        MockConnectorTableHandle mockConnectorTable = (MockConnectorTableHandle) handle;\n-        Optional<List<ColumnHandle>> projectedColumns = mockConnectorTable.getColumns();\n-        if (projectedColumns.isEmpty()) {\n-            return Optional.empty();\n-        }\n-        List<String> projectedColumnNames = projectedColumns.get().stream()\n-                .map(MockConnectorColumnHandle.class::cast)\n-                .map(MockConnectorColumnHandle::getName)\n-                .collect(toImmutableList());\n-        if (!projectedColumnNames.equals(ImmutableList.of(sourceColumnNameA))) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(\n-                new TableScanRedirectApplicationResult(\n-                        new CatalogSchemaTableName(MOCK_CATALOG, destinationTable),\n-                        redirectionMappingA,\n-                        mockConnectorTable.getConstraint()\n-                                .transform(MockConnectorColumnHandle.class::cast)\n-                                .transform(MockConnectorColumnHandle::getName)));\n-    }\n-\n-    private ApplyFilter getMockApplyFilter(Set<ColumnHandle> pushdownColumns)\n-    {\n-        // returns a mock implementation of applyFilter which allows predicate pushdown only for pushdownColumns\n-        return (session, table, constraint) -> {\n-            MockConnectorTableHandle handle = (MockConnectorTableHandle) table;\n-\n-            TupleDomain<ColumnHandle> oldDomain = handle.getConstraint();\n-            TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary()\n-                    .filter((columnHandle, domain) -> pushdownColumns.contains(columnHandle)));\n-            if (oldDomain.equals(newDomain)) {\n-                return Optional.empty();\n-            }\n-\n-            return Optional.of(\n-                    new ConstraintApplicationResult<>(\n-                            new MockConnectorTableHandle(handle.getTableName(), newDomain, Optional.empty()),\n-                            constraint.getSummary()\n-                                    .filter((columnHandle, domain) -> !pushdownColumns.contains(columnHandle))));\n-        };\n-    }\n-\n-    private ApplyTableScanRedirect getMockApplyRedirectAfterPredicatePushdown(\n-            Map<ColumnHandle, String> redirectionMapping,\n-            Optional<Set<ColumnHandle>> requiredProjections,\n-            boolean allowCoercions)\n-    {\n-        return (session, handle) -> {\n-            MockConnectorTableHandle mockConnectorTable = (MockConnectorTableHandle) handle;\n-            // make sure we do redirection after predicate is pushed down\n-            if (mockConnectorTable.getConstraint().isAll()) {\n-                return Optional.empty();\n-            }\n-            Optional<List<ColumnHandle>> projectedColumns = mockConnectorTable.getColumns();\n-            if (requiredProjections.isPresent()\n-                    && (projectedColumns.isEmpty() || !requiredProjections.get().equals(ImmutableSet.copyOf(projectedColumns.get())))) {\n-                return Optional.empty();\n-            }\n-            return Optional.of(\n-                    new TableScanRedirectApplicationResult(\n-                            new CatalogSchemaTableName(MOCK_CATALOG, destinationTable),\n-                            redirectionMapping,\n-                            mockConnectorTable.getConstraint()\n-                                    .transform(MockConnectorColumnHandle.class::cast)\n-                                    .transform(redirectionMapping::get),\n-                            allowCoercions));\n-        };\n-    }\n-\n-    void assertPlan(LocalQueryRunner queryRunner, @Language(\"SQL\") String sql, PlanMatchPattern pattern)\n-    {\n-        List<PlanOptimizer> optimizers = queryRunner.getPlanOptimizers(true);\n-\n-        queryRunner.inTransaction(transactionSession -> {\n-            Plan actualPlan = queryRunner.createPlan(transactionSession, sql, optimizers, OPTIMIZED_AND_VALIDATED, WarningCollector.NOOP);\n-            PlanAssert.assertPlan(transactionSession, queryRunner.getMetadata(), queryRunner.getStatsCalculator(), actualPlan, pattern);\n-            return null;\n-        });\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNjA2Nw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639916067", "bodyText": "TrinoException", "author": "martint", "createdAt": "2021-05-26T16:43:19Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -88,49 +94,56 @@ public Result apply(TableScanNode scanNode, Captures captures, Context context)\n \n         Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n         Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n-        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n-                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n-                    String destinationColumn = columnMapping.get(entry.getValue());\n-                    if (destinationColumn == null) {\n-                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n-                    }\n-                    ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n-                    if (destinationColumnHandle == null) {\n-                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n-                    }\n-\n-                    // validate that redirected types match source types\n-                    Type sourceType = context.getSymbolAllocator().getTypes().get(entry.getKey());\n-                    Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n-                    if (!sourceType.equals(redirectedType)) {\n-                        throwTypeMismatchException(\n-                                destinationTable,\n-                                destinationColumn,\n-                                redirectedType,\n-                                scanNode.getTable(),\n-                                entry.getValue(),\n-                                sourceType);\n-                    }\n-\n-                    return destinationColumnHandle;\n-                }));\n+        ImmutableMap.Builder<Symbol, Cast> casts = ImmutableMap.builder();\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.builder();\n+        for (Map.Entry<Symbol, ColumnHandle> assignment : scanNode.getAssignments().entrySet()) {\n+            String destinationColumn = columnMapping.get(assignment.getValue());\n+            if (destinationColumn == null) {\n+                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", assignment.getValue()));", "originalCommit": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java\ndeleted file mode 100644\nindex ce58a03f9e..0000000000\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java\n+++ /dev/null\n\n@@ -1,274 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.prestosql.sql.planner.iterative.rule;\n-\n-import com.google.common.collect.ImmutableBiMap;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Sets;\n-import io.prestosql.matching.Captures;\n-import io.prestosql.matching.Pattern;\n-import io.prestosql.metadata.Metadata;\n-import io.prestosql.metadata.TableHandle;\n-import io.prestosql.spi.PrestoException;\n-import io.prestosql.spi.connector.CatalogSchemaTableName;\n-import io.prestosql.spi.connector.ColumnHandle;\n-import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n-import io.prestosql.spi.predicate.TupleDomain;\n-import io.prestosql.spi.type.Type;\n-import io.prestosql.sql.planner.DomainTranslator;\n-import io.prestosql.sql.planner.PlanNodeIdAllocator;\n-import io.prestosql.sql.planner.Symbol;\n-import io.prestosql.sql.planner.iterative.Rule;\n-import io.prestosql.sql.planner.plan.Assignments;\n-import io.prestosql.sql.planner.plan.FilterNode;\n-import io.prestosql.sql.planner.plan.PlanNode;\n-import io.prestosql.sql.planner.plan.ProjectNode;\n-import io.prestosql.sql.planner.plan.TableScanNode;\n-import io.prestosql.sql.tree.Cast;\n-\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-\n-import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n-import static io.prestosql.spi.StandardErrorCode.COLUMN_NOT_FOUND;\n-import static io.prestosql.spi.StandardErrorCode.FUNCTION_NOT_FOUND;\n-import static io.prestosql.spi.StandardErrorCode.TABLE_NOT_FOUND;\n-import static io.prestosql.spi.StandardErrorCode.TYPE_MISMATCH;\n-import static io.prestosql.sql.analyzer.TypeSignatureTranslator.toSqlType;\n-import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static java.lang.String.format;\n-import static java.util.Objects.requireNonNull;\n-\n-public class ApplyTableScanRedirection\n-        implements Rule<TableScanNode>\n-{\n-    private static final Pattern<TableScanNode> PATTERN = tableScan();\n-\n-    private final Metadata metadata;\n-    private final DomainTranslator domainTranslator;\n-\n-    public ApplyTableScanRedirection(Metadata metadata)\n-    {\n-        this.metadata = requireNonNull(metadata, \"metadata is null\");\n-        this.domainTranslator = new DomainTranslator(metadata);\n-    }\n-\n-    @Override\n-    public Pattern<TableScanNode> getPattern()\n-    {\n-        return PATTERN;\n-    }\n-\n-    @Override\n-    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n-    {\n-        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n-        if (tableScanRedirectApplicationResult.isEmpty()) {\n-            return Result.empty();\n-        }\n-\n-        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n-        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n-                context.getSession(),\n-                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n-        if (destinationTableHandle.isEmpty()) {\n-            throw new PrestoException(TABLE_NOT_FOUND, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n-        }\n-        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n-            return Result.empty();\n-        }\n-\n-        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n-        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n-        ImmutableMap.Builder<Symbol, Cast> casts = ImmutableMap.builder();\n-        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.builder();\n-        for (Map.Entry<Symbol, ColumnHandle> assignment : scanNode.getAssignments().entrySet()) {\n-            String destinationColumn = columnMapping.get(assignment.getValue());\n-            if (destinationColumn == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", assignment.getValue()));\n-            }\n-            ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n-            if (destinationColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n-            }\n-\n-            // insert casts if redirected types don't match source types\n-            Type sourceType = context.getSymbolAllocator().getTypes().get(assignment.getKey());\n-            Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n-            if (!sourceType.equals(redirectedType)) {\n-                Symbol redirectedSymbol = context.getSymbolAllocator().newSymbol(destinationColumn, redirectedType);\n-                Cast cast = getCast(\n-                        tableScanRedirectApplicationResult.get().isAllowCoercions(),\n-                        destinationTable,\n-                        destinationColumn,\n-                        redirectedType,\n-                        redirectedSymbol,\n-                        scanNode.getTable(),\n-                        assignment.getValue(),\n-                        sourceType);\n-                casts.put(assignment.getKey(), cast);\n-                newAssignmentsBuilder.put(redirectedSymbol, destinationColumnHandle);\n-            }\n-            else {\n-                newAssignmentsBuilder.put(assignment.getKey(), destinationColumnHandle);\n-            }\n-        }\n-\n-        TupleDomain<String> requiredFilter = tableScanRedirectApplicationResult.get().getFilter();\n-        if (requiredFilter.isAll()) {\n-            ImmutableMap<Symbol, ColumnHandle> newAssignments = newAssignmentsBuilder.build();\n-            return Result.ofPlanNode(applyProjection(\n-                    context.getIdAllocator(),\n-                    ImmutableSet.copyOf(scanNode.getOutputSymbols()),\n-                    casts.build(),\n-                    new TableScanNode(\n-                            scanNode.getId(),\n-                            destinationTableHandle.get(),\n-                            ImmutableList.copyOf(newAssignments.keySet()),\n-                            newAssignments,\n-                            TupleDomain.all(),\n-                            scanNode.isForDelete())));\n-        }\n-\n-        Map<ColumnHandle, Symbol> inverseAssignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n-        Map<String, ColumnHandle> inverseColumnsMapping = ImmutableBiMap.copyOf(columnMapping).inverse();\n-        TupleDomain<Symbol> transformedConstraint = requiredFilter.transform(destinationColumn -> {\n-            ColumnHandle sourceColumnHandle = inverseColumnsMapping.get(destinationColumn);\n-            if (sourceColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for destination column %s in table scan redirection\", destinationColumn));\n-            }\n-            Symbol symbol = inverseAssignments.get(sourceColumnHandle);\n-            if (symbol != null) {\n-                // symbol should be mapped in redirected table scan\n-                return symbol;\n-            }\n-\n-            // Column pruning after predicate is pushed into table scan can remove assignments for filter columns from the scan node\n-            Type domainType = requiredFilter.getDomains().get().get(destinationColumn).getType();\n-            symbol = context.getSymbolAllocator().newSymbol(destinationColumn, domainType);\n-\n-            ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n-            if (destinationColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n-            }\n-\n-            // insert casts if redirected types don't match domain types\n-            Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n-            if (!domainType.equals(redirectedType)) {\n-                Symbol redirectedSymbol = context.getSymbolAllocator().newSymbol(destinationColumn, redirectedType);\n-                Cast cast = getCast(\n-                        tableScanRedirectApplicationResult.get().isAllowCoercions(),\n-                        destinationTable,\n-                        destinationColumn,\n-                        redirectedType,\n-                        redirectedSymbol,\n-                        scanNode.getTable(),\n-                        sourceColumnHandle,\n-                        domainType);\n-                casts.put(symbol, cast);\n-                newAssignmentsBuilder.put(redirectedSymbol, destinationColumnHandle);\n-            }\n-            else {\n-                newAssignmentsBuilder.put(symbol, destinationColumnHandle);\n-            }\n-\n-            return symbol;\n-        });\n-\n-        Map<Symbol, ColumnHandle> newAssignments = newAssignmentsBuilder.build();\n-        TableScanNode newScanNode = new TableScanNode(\n-                scanNode.getId(),\n-                destinationTableHandle.get(),\n-                ImmutableList.copyOf(newAssignments.keySet()),\n-                newAssignments,\n-                TupleDomain.all(),\n-                scanNode.isForDelete());\n-\n-        FilterNode filterNode = new FilterNode(\n-                context.getIdAllocator().getNextId(),\n-                applyProjection(\n-                        context.getIdAllocator(),\n-                        newAssignments.keySet(),\n-                        casts.build(),\n-                        newScanNode),\n-                domainTranslator.toPredicate(transformedConstraint));\n-\n-        return Result.ofPlanNode(applyProjection(\n-                context.getIdAllocator(),\n-                ImmutableSet.copyOf(scanNode.getOutputSymbols()),\n-                ImmutableMap.of(),\n-                filterNode));\n-    }\n-\n-    private PlanNode applyProjection(\n-            PlanNodeIdAllocator idAllocator,\n-            Set<Symbol> requiredSymbols,\n-            Map<Symbol, Cast> casts,\n-            PlanNode source)\n-    {\n-        if (casts.isEmpty() && requiredSymbols.equals(ImmutableSet.copyOf(source.getOutputSymbols()))) {\n-            return source;\n-        }\n-\n-        return new ProjectNode(\n-                idAllocator.getNextId(),\n-                source,\n-                Assignments.builder()\n-                        .putIdentities(Sets.difference(requiredSymbols, casts.keySet()))\n-                        .putAll(casts)\n-                        .build());\n-    }\n-\n-    private Cast getCast(\n-            boolean allowCoercions,\n-            CatalogSchemaTableName destinationTable,\n-            String destinationColumn,\n-            Type destinationType,\n-            Symbol destinationSymbol,\n-            TableHandle sourceTable,\n-            ColumnHandle sourceColumnHandle,\n-            Type sourceType)\n-    {\n-        if (!allowCoercions) {\n-            throw new PrestoException(TYPE_MISMATCH, format(\n-                    \"Redirected column %s.%s has type %s, different from source column %s.%s type: %s\",\n-                    destinationTable,\n-                    destinationColumn,\n-                    destinationType,\n-                    // TODO report source table and column name instead of ConnectorTableHandle, ConnectorColumnHandle toString\n-                    sourceTable,\n-                    sourceColumnHandle,\n-                    sourceType));\n-        }\n-\n-        try {\n-            metadata.getCoercion(destinationType, sourceType);\n-        }\n-        catch (PrestoException e) {\n-            throw new PrestoException(FUNCTION_NOT_FOUND, format(\n-                    \"Cast not possible from redirected column %s.%s with type %s to source column %s.%s with type: %s\",\n-                    destinationTable,\n-                    destinationColumn,\n-                    destinationType,\n-                    sourceTable,\n-                    sourceColumnHandle,\n-                    sourceType));\n-        }\n-\n-        return new Cast(destinationSymbol.toSymbolReference(), toSqlType(sourceType));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639918664", "bodyText": "This is missing the typeOnlyCoercion flag.", "author": "martint", "createdAt": "2021-05-26T16:47:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -144,70 +157,118 @@ public Result apply(TableScanNode scanNode, Captures captures, Context context)\n                 return symbol;\n             }\n \n-            // validate that redirected types match source types\n+            // Column pruning after predicate is pushed into table scan can remove assignments for filter columns from the scan node\n             Type domainType = requiredFilter.getDomains().get().get(destinationColumn).getType();\n+            symbol = context.getSymbolAllocator().newSymbol(destinationColumn, domainType);\n+\n             ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n+            if (destinationColumnHandle == null) {\n+                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+            }\n+\n+            // insert casts if redirected types don't match domain types\n             Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n             if (!domainType.equals(redirectedType)) {\n-                throwTypeMismatchException(\n+                Symbol redirectedSymbol = context.getSymbolAllocator().newSymbol(destinationColumn, redirectedType);\n+                Cast cast = getCast(\n+                        tableScanRedirectApplicationResult.get().isAllowCoercions(),\n                         destinationTable,\n                         destinationColumn,\n                         redirectedType,\n+                        redirectedSymbol,\n                         scanNode.getTable(),\n                         sourceColumnHandle,\n                         domainType);\n+                casts.put(symbol, cast);\n+                newAssignmentsBuilder.put(redirectedSymbol, destinationColumnHandle);\n             }\n-\n-            // Column pruning after predicate is pushed into table scan can remove assignments for filter columns from the scan node\n-            symbol = context.getSymbolAllocator().newSymbol(destinationColumn, domainType);\n-            if (destinationColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+            else {\n+                newAssignmentsBuilder.put(symbol, destinationColumnHandle);\n             }\n-            newAssignmentsBuilder.put(symbol, destinationColumnHandle);\n-            newOutputSymbolsBuilder.add(symbol);\n+\n             return symbol;\n         });\n \n-        List<Symbol> newOutputSymbols = newOutputSymbolsBuilder.build();\n+        Map<Symbol, ColumnHandle> newAssignments = newAssignmentsBuilder.build();\n         TableScanNode newScanNode = new TableScanNode(\n                 scanNode.getId(),\n                 destinationTableHandle.get(),\n-                newOutputSymbols,\n-                newAssignmentsBuilder.build(),\n+                ImmutableList.copyOf(newAssignments.keySet()),\n+                newAssignments,\n                 TupleDomain.all(),\n                 scanNode.isForDelete());\n \n         FilterNode filterNode = new FilterNode(\n                 context.getIdAllocator().getNextId(),\n-                newScanNode,\n+                applyProjection(\n+                        context.getIdAllocator(),\n+                        newAssignments.keySet(),\n+                        casts.build(),\n+                        newScanNode),\n                 domainTranslator.toPredicate(transformedConstraint));\n-        if (newOutputSymbols.size() == scanNode.getOutputSymbols().size()) {\n-            return Result.ofPlanNode(filterNode);\n+\n+        return Result.ofPlanNode(applyProjection(\n+                context.getIdAllocator(),\n+                ImmutableSet.copyOf(scanNode.getOutputSymbols()),\n+                ImmutableMap.of(),\n+                filterNode));\n+    }\n+\n+    private PlanNode applyProjection(\n+            PlanNodeIdAllocator idAllocator,\n+            Set<Symbol> requiredSymbols,\n+            Map<Symbol, Cast> casts,\n+            PlanNode source)\n+    {\n+        if (casts.isEmpty() && requiredSymbols.equals(ImmutableSet.copyOf(source.getOutputSymbols()))) {\n+            return source;\n         }\n \n-        return Result.ofPlanNode(\n-                new ProjectNode(\n-                        context.getIdAllocator().getNextId(),\n-                        filterNode,\n-                        Assignments.identity(scanNode.getOutputSymbols())));\n+        return new ProjectNode(\n+                idAllocator.getNextId(),\n+                source,\n+                Assignments.builder()\n+                        .putIdentities(Sets.difference(requiredSymbols, casts.keySet()))\n+                        .putAll(casts)\n+                        .build());\n     }\n \n-    private static void throwTypeMismatchException(\n+    private Cast getCast(\n+            boolean allowCoercions,\n             CatalogSchemaTableName destinationTable,\n             String destinationColumn,\n             Type destinationType,\n+            Symbol destinationSymbol,\n             TableHandle sourceTable,\n             ColumnHandle sourceColumnHandle,\n             Type sourceType)\n     {\n-        throw new PrestoException(TYPE_MISMATCH, format(\n-                \"Redirected column %s.%s has type %s, different from source column %s.%s type: %s\",\n-                destinationTable,\n-                destinationColumn,\n-                destinationType,\n-                // TODO report source table and column name instead of ConnectorTableHandle, ConnectorColumnHandle toString\n-                sourceTable,\n-                sourceColumnHandle,\n-                sourceType));\n+        if (!allowCoercions) {\n+            throw new PrestoException(TYPE_MISMATCH, format(\n+                    \"Redirected column %s.%s has type %s, different from source column %s.%s type: %s\",\n+                    destinationTable,\n+                    destinationColumn,\n+                    destinationType,\n+                    // TODO report source table and column name instead of ConnectorTableHandle, ConnectorColumnHandle toString\n+                    sourceTable,\n+                    sourceColumnHandle,\n+                    sourceType));\n+        }\n+\n+        try {\n+            metadata.getCoercion(destinationType, sourceType);\n+        }\n+        catch (PrestoException e) {\n+            throw new PrestoException(FUNCTION_NOT_FOUND, format(\n+                    \"Cast not possible from redirected column %s.%s with type %s to source column %s.%s with type: %s\",\n+                    destinationTable,\n+                    destinationColumn,\n+                    destinationType,\n+                    sourceTable,\n+                    sourceColumnHandle,\n+                    sourceType));\n+        }\n+\n+        return new Cast(destinationSymbol.toSymbolReference(), toSqlType(sourceType));", "originalCommit": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDUyMzc5Nw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640523797", "bodyText": "It can't be type only coercion. E.g we can coerce from timestamp(9) -> timestamp(0)", "author": "sopel39", "createdAt": "2021-05-27T11:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDczNDM5Nw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640734397", "bodyText": "I know. But currently it's saying every coercions is \"not type-only coercion\". It needs to pass the true/false flag depending on whether that's the case.", "author": "martint", "createdAt": "2021-05-27T15:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDc4MDQ3NA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640780474", "bodyText": "@martint shouldn't this not be a concern of this rule?\nie shouldn't we have a canonicalizer which can determine a certain cast is type-only?\nit's a function of types being converted from/to, not a function of particular creating site", "author": "findepi", "createdAt": "2021-05-27T16:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkwNDYzNA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640904634", "bodyText": "Well, the notion of type-only casts in the planner has always been somewhat of a misfeature. It's not clear it even does anything (a type-only cast will be just a passthrough method in the implementation, so the JIT should be able to inline and remove them).\nBut we don't have any such thing today, and we rely on the callsites to construct the cast properly. In a way, you can think of an IR cast as having (from, to, type-only) elements (vs the AST cast, which only has (from, to))\nTL;DR, we should consider getting rid of type-only casts, but in the meantime, we should construct them properly if at all possible.", "author": "martint", "createdAt": "2021-05-27T19:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkxNzc2OA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640917768", "bodyText": "TL;DR, we should consider getting rid of type-only casts,\n\ncan you please file an issue for that?", "author": "findepi", "createdAt": "2021-05-27T19:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkyODE5Ng==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640928196", "bodyText": "#8111", "author": "martint", "createdAt": "2021-05-27T20:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkzMDkyNQ==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640930925", "bodyText": "added call to isTypeOnlyCoercion", "author": "sopel39", "createdAt": "2021-05-27T20:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}], "type": "inlineReview", "revised_code": {"commit": "54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java\ndeleted file mode 100644\nindex ce58a03f9e..0000000000\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java\n+++ /dev/null\n\n@@ -1,274 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.prestosql.sql.planner.iterative.rule;\n-\n-import com.google.common.collect.ImmutableBiMap;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Sets;\n-import io.prestosql.matching.Captures;\n-import io.prestosql.matching.Pattern;\n-import io.prestosql.metadata.Metadata;\n-import io.prestosql.metadata.TableHandle;\n-import io.prestosql.spi.PrestoException;\n-import io.prestosql.spi.connector.CatalogSchemaTableName;\n-import io.prestosql.spi.connector.ColumnHandle;\n-import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n-import io.prestosql.spi.predicate.TupleDomain;\n-import io.prestosql.spi.type.Type;\n-import io.prestosql.sql.planner.DomainTranslator;\n-import io.prestosql.sql.planner.PlanNodeIdAllocator;\n-import io.prestosql.sql.planner.Symbol;\n-import io.prestosql.sql.planner.iterative.Rule;\n-import io.prestosql.sql.planner.plan.Assignments;\n-import io.prestosql.sql.planner.plan.FilterNode;\n-import io.prestosql.sql.planner.plan.PlanNode;\n-import io.prestosql.sql.planner.plan.ProjectNode;\n-import io.prestosql.sql.planner.plan.TableScanNode;\n-import io.prestosql.sql.tree.Cast;\n-\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-\n-import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n-import static io.prestosql.spi.StandardErrorCode.COLUMN_NOT_FOUND;\n-import static io.prestosql.spi.StandardErrorCode.FUNCTION_NOT_FOUND;\n-import static io.prestosql.spi.StandardErrorCode.TABLE_NOT_FOUND;\n-import static io.prestosql.spi.StandardErrorCode.TYPE_MISMATCH;\n-import static io.prestosql.sql.analyzer.TypeSignatureTranslator.toSqlType;\n-import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static java.lang.String.format;\n-import static java.util.Objects.requireNonNull;\n-\n-public class ApplyTableScanRedirection\n-        implements Rule<TableScanNode>\n-{\n-    private static final Pattern<TableScanNode> PATTERN = tableScan();\n-\n-    private final Metadata metadata;\n-    private final DomainTranslator domainTranslator;\n-\n-    public ApplyTableScanRedirection(Metadata metadata)\n-    {\n-        this.metadata = requireNonNull(metadata, \"metadata is null\");\n-        this.domainTranslator = new DomainTranslator(metadata);\n-    }\n-\n-    @Override\n-    public Pattern<TableScanNode> getPattern()\n-    {\n-        return PATTERN;\n-    }\n-\n-    @Override\n-    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n-    {\n-        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n-        if (tableScanRedirectApplicationResult.isEmpty()) {\n-            return Result.empty();\n-        }\n-\n-        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n-        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n-                context.getSession(),\n-                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n-        if (destinationTableHandle.isEmpty()) {\n-            throw new PrestoException(TABLE_NOT_FOUND, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n-        }\n-        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n-            return Result.empty();\n-        }\n-\n-        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n-        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n-        ImmutableMap.Builder<Symbol, Cast> casts = ImmutableMap.builder();\n-        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.builder();\n-        for (Map.Entry<Symbol, ColumnHandle> assignment : scanNode.getAssignments().entrySet()) {\n-            String destinationColumn = columnMapping.get(assignment.getValue());\n-            if (destinationColumn == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", assignment.getValue()));\n-            }\n-            ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n-            if (destinationColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n-            }\n-\n-            // insert casts if redirected types don't match source types\n-            Type sourceType = context.getSymbolAllocator().getTypes().get(assignment.getKey());\n-            Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n-            if (!sourceType.equals(redirectedType)) {\n-                Symbol redirectedSymbol = context.getSymbolAllocator().newSymbol(destinationColumn, redirectedType);\n-                Cast cast = getCast(\n-                        tableScanRedirectApplicationResult.get().isAllowCoercions(),\n-                        destinationTable,\n-                        destinationColumn,\n-                        redirectedType,\n-                        redirectedSymbol,\n-                        scanNode.getTable(),\n-                        assignment.getValue(),\n-                        sourceType);\n-                casts.put(assignment.getKey(), cast);\n-                newAssignmentsBuilder.put(redirectedSymbol, destinationColumnHandle);\n-            }\n-            else {\n-                newAssignmentsBuilder.put(assignment.getKey(), destinationColumnHandle);\n-            }\n-        }\n-\n-        TupleDomain<String> requiredFilter = tableScanRedirectApplicationResult.get().getFilter();\n-        if (requiredFilter.isAll()) {\n-            ImmutableMap<Symbol, ColumnHandle> newAssignments = newAssignmentsBuilder.build();\n-            return Result.ofPlanNode(applyProjection(\n-                    context.getIdAllocator(),\n-                    ImmutableSet.copyOf(scanNode.getOutputSymbols()),\n-                    casts.build(),\n-                    new TableScanNode(\n-                            scanNode.getId(),\n-                            destinationTableHandle.get(),\n-                            ImmutableList.copyOf(newAssignments.keySet()),\n-                            newAssignments,\n-                            TupleDomain.all(),\n-                            scanNode.isForDelete())));\n-        }\n-\n-        Map<ColumnHandle, Symbol> inverseAssignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n-        Map<String, ColumnHandle> inverseColumnsMapping = ImmutableBiMap.copyOf(columnMapping).inverse();\n-        TupleDomain<Symbol> transformedConstraint = requiredFilter.transform(destinationColumn -> {\n-            ColumnHandle sourceColumnHandle = inverseColumnsMapping.get(destinationColumn);\n-            if (sourceColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for destination column %s in table scan redirection\", destinationColumn));\n-            }\n-            Symbol symbol = inverseAssignments.get(sourceColumnHandle);\n-            if (symbol != null) {\n-                // symbol should be mapped in redirected table scan\n-                return symbol;\n-            }\n-\n-            // Column pruning after predicate is pushed into table scan can remove assignments for filter columns from the scan node\n-            Type domainType = requiredFilter.getDomains().get().get(destinationColumn).getType();\n-            symbol = context.getSymbolAllocator().newSymbol(destinationColumn, domainType);\n-\n-            ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n-            if (destinationColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n-            }\n-\n-            // insert casts if redirected types don't match domain types\n-            Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n-            if (!domainType.equals(redirectedType)) {\n-                Symbol redirectedSymbol = context.getSymbolAllocator().newSymbol(destinationColumn, redirectedType);\n-                Cast cast = getCast(\n-                        tableScanRedirectApplicationResult.get().isAllowCoercions(),\n-                        destinationTable,\n-                        destinationColumn,\n-                        redirectedType,\n-                        redirectedSymbol,\n-                        scanNode.getTable(),\n-                        sourceColumnHandle,\n-                        domainType);\n-                casts.put(symbol, cast);\n-                newAssignmentsBuilder.put(redirectedSymbol, destinationColumnHandle);\n-            }\n-            else {\n-                newAssignmentsBuilder.put(symbol, destinationColumnHandle);\n-            }\n-\n-            return symbol;\n-        });\n-\n-        Map<Symbol, ColumnHandle> newAssignments = newAssignmentsBuilder.build();\n-        TableScanNode newScanNode = new TableScanNode(\n-                scanNode.getId(),\n-                destinationTableHandle.get(),\n-                ImmutableList.copyOf(newAssignments.keySet()),\n-                newAssignments,\n-                TupleDomain.all(),\n-                scanNode.isForDelete());\n-\n-        FilterNode filterNode = new FilterNode(\n-                context.getIdAllocator().getNextId(),\n-                applyProjection(\n-                        context.getIdAllocator(),\n-                        newAssignments.keySet(),\n-                        casts.build(),\n-                        newScanNode),\n-                domainTranslator.toPredicate(transformedConstraint));\n-\n-        return Result.ofPlanNode(applyProjection(\n-                context.getIdAllocator(),\n-                ImmutableSet.copyOf(scanNode.getOutputSymbols()),\n-                ImmutableMap.of(),\n-                filterNode));\n-    }\n-\n-    private PlanNode applyProjection(\n-            PlanNodeIdAllocator idAllocator,\n-            Set<Symbol> requiredSymbols,\n-            Map<Symbol, Cast> casts,\n-            PlanNode source)\n-    {\n-        if (casts.isEmpty() && requiredSymbols.equals(ImmutableSet.copyOf(source.getOutputSymbols()))) {\n-            return source;\n-        }\n-\n-        return new ProjectNode(\n-                idAllocator.getNextId(),\n-                source,\n-                Assignments.builder()\n-                        .putIdentities(Sets.difference(requiredSymbols, casts.keySet()))\n-                        .putAll(casts)\n-                        .build());\n-    }\n-\n-    private Cast getCast(\n-            boolean allowCoercions,\n-            CatalogSchemaTableName destinationTable,\n-            String destinationColumn,\n-            Type destinationType,\n-            Symbol destinationSymbol,\n-            TableHandle sourceTable,\n-            ColumnHandle sourceColumnHandle,\n-            Type sourceType)\n-    {\n-        if (!allowCoercions) {\n-            throw new PrestoException(TYPE_MISMATCH, format(\n-                    \"Redirected column %s.%s has type %s, different from source column %s.%s type: %s\",\n-                    destinationTable,\n-                    destinationColumn,\n-                    destinationType,\n-                    // TODO report source table and column name instead of ConnectorTableHandle, ConnectorColumnHandle toString\n-                    sourceTable,\n-                    sourceColumnHandle,\n-                    sourceType));\n-        }\n-\n-        try {\n-            metadata.getCoercion(destinationType, sourceType);\n-        }\n-        catch (PrestoException e) {\n-            throw new PrestoException(FUNCTION_NOT_FOUND, format(\n-                    \"Cast not possible from redirected column %s.%s with type %s to source column %s.%s with type: %s\",\n-                    destinationTable,\n-                    destinationColumn,\n-                    destinationType,\n-                    sourceTable,\n-                    sourceColumnHandle,\n-                    sourceType));\n-        }\n-\n-        return new Cast(destinationSymbol.toSymbolReference(), toSqlType(sourceType));\n-    }\n-}\n"}}, {"oid": "54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "url": "https://github.com/trinodb/trino/commit/54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "message": "Remove SPI support for UNION ALL types of redirections\n\nRedirections SPI will be deprecated and Trino engine won't be extended\nfor UNION ALL support in a foreseeable future.", "committedDate": "2021-05-27T13:04:49Z", "type": "commit"}, {"oid": "9c9b955c83ebbee54ca0c35069a0c43641ffad62", "url": "https://github.com/trinodb/trino/commit/9c9b955c83ebbee54ca0c35069a0c43641ffad62", "message": "Add support for coercions in table scan redirections\n\nRedirected table can have different column types\nthan source table. In that case, an explicit cast\nwill be inserted by the engine.", "committedDate": "2021-05-27T20:26:00Z", "type": "commit"}, {"oid": "9c9b955c83ebbee54ca0c35069a0c43641ffad62", "url": "https://github.com/trinodb/trino/commit/9c9b955c83ebbee54ca0c35069a0c43641ffad62", "message": "Add support for coercions in table scan redirections\n\nRedirected table can have different column types\nthan source table. In that case, an explicit cast\nwill be inserted by the engine.", "committedDate": "2021-05-27T20:26:00Z", "type": "forcePushed"}]}