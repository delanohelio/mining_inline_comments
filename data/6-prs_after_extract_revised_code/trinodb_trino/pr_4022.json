{"pr_number": 4022, "pr_title": "Add Soundex function", "pr_createdAt": "2020-06-13T22:57:32Z", "pr_url": "https://github.com/trinodb/trino/pull/4022", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgyMjE2MQ==", "url": "https://github.com/trinodb/trino/pull/4022#discussion_r439822161", "bodyText": "Can we import Soundex directly ?", "author": "Praveen2112", "createdAt": "2020-06-14T11:56:27Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/StringFunctions.java", "diffHunk": "@@ -911,4 +911,12 @@ public static boolean startsWith(@SqlType(\"varchar(x)\") Slice source, @SqlType(\"\n         }\n         return source.compareTo(0, prefix.length(), prefix, 0, prefix.length()) == 0;\n     }\n+\n+    @Description(\"Encodes a string into a Soundex value\")\n+    @ScalarFunction\n+    @SqlType(StandardTypes.VARCHAR)\n+    public static Slice soundex(@SqlType(StandardTypes.VARCHAR) Slice slice)\n+    {\n+        return utf8Slice(new org.apache.commons.codec.language.Soundex().encode(slice.toStringUtf8()));", "originalCommit": "01feaecc40daafb4bcf38b0932142b6b2ef922ff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "92c56f8c6369f6e9daec49b349553e9d630adf75", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/operator/scalar/StringFunctions.java b/presto-main/src/main/java/io/prestosql/operator/scalar/StringFunctions.java\ndeleted file mode 100644\nindex 0cc05f6c7b..0000000000\n--- a/presto-main/src/main/java/io/prestosql/operator/scalar/StringFunctions.java\n+++ /dev/null\n\n@@ -1,922 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.prestosql.operator.scalar;\n-\n-import com.google.common.primitives.Ints;\n-import io.airlift.slice.InvalidCodePointException;\n-import io.airlift.slice.InvalidUtf8Exception;\n-import io.airlift.slice.Slice;\n-import io.airlift.slice.SliceUtf8;\n-import io.airlift.slice.Slices;\n-import io.prestosql.spi.PrestoException;\n-import io.prestosql.spi.block.Block;\n-import io.prestosql.spi.block.BlockBuilder;\n-import io.prestosql.spi.function.Description;\n-import io.prestosql.spi.function.LiteralParameter;\n-import io.prestosql.spi.function.LiteralParameters;\n-import io.prestosql.spi.function.OperatorType;\n-import io.prestosql.spi.function.ScalarFunction;\n-import io.prestosql.spi.function.ScalarOperator;\n-import io.prestosql.spi.function.SqlNullable;\n-import io.prestosql.spi.function.SqlType;\n-import io.prestosql.spi.type.StandardTypes;\n-import io.prestosql.type.CodePointsType;\n-import io.prestosql.type.Constraint;\n-\n-import java.text.Normalizer;\n-import java.util.OptionalInt;\n-\n-import static io.airlift.slice.SliceUtf8.countCodePoints;\n-import static io.airlift.slice.SliceUtf8.getCodePointAt;\n-import static io.airlift.slice.SliceUtf8.lengthOfCodePoint;\n-import static io.airlift.slice.SliceUtf8.lengthOfCodePointSafe;\n-import static io.airlift.slice.SliceUtf8.offsetOfCodePoint;\n-import static io.airlift.slice.SliceUtf8.toLowerCase;\n-import static io.airlift.slice.SliceUtf8.toUpperCase;\n-import static io.airlift.slice.SliceUtf8.tryGetCodePointAt;\n-import static io.airlift.slice.Slices.utf8Slice;\n-import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n-import static io.prestosql.spi.type.Chars.byteCountWithoutTrailingSpace;\n-import static io.prestosql.spi.type.Chars.padSpaces;\n-import static io.prestosql.spi.type.Chars.trimTrailingSpaces;\n-import static io.prestosql.spi.type.VarcharType.VARCHAR;\n-import static io.prestosql.util.Failures.checkCondition;\n-import static java.lang.Character.MAX_CODE_POINT;\n-import static java.lang.Character.SURROGATE;\n-import static java.lang.Math.abs;\n-import static java.lang.Math.toIntExact;\n-\n-/**\n- * Current implementation is based on code points from Unicode and does ignore grapheme cluster boundaries.\n- * Therefore only some methods work correctly with grapheme cluster boundaries.\n- */\n-public final class StringFunctions\n-{\n-    private StringFunctions() {}\n-\n-    @Description(\"Convert Unicode code point to a string\")\n-    @ScalarFunction\n-    @SqlType(\"varchar(1)\")\n-    public static Slice chr(@SqlType(StandardTypes.BIGINT) long codepoint)\n-    {\n-        try {\n-            return SliceUtf8.codePointToUtf8(Ints.saturatedCast(codepoint));\n-        }\n-        catch (InvalidCodePointException e) {\n-            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Not a valid Unicode code point: \" + codepoint, e);\n-        }\n-    }\n-\n-    @Description(\"Returns Unicode code point of a single character string\")\n-    @ScalarFunction(\"codepoint\")\n-    @SqlType(StandardTypes.INTEGER)\n-    public static long codepoint(@SqlType(\"varchar(1)\") Slice slice)\n-    {\n-        checkCondition(countCodePoints(slice) == 1, INVALID_FUNCTION_ARGUMENT, \"Input string must be a single character string\");\n-\n-        return getCodePointAt(slice, 0);\n-    }\n-\n-    @Description(\"Count of code points of the given string\")\n-    @ScalarFunction\n-    @LiteralParameters(\"x\")\n-    @SqlType(StandardTypes.BIGINT)\n-    public static long length(@SqlType(\"varchar(x)\") Slice slice)\n-    {\n-        return countCodePoints(slice);\n-    }\n-\n-    @Description(\"Count of code points of the given string\")\n-    @ScalarFunction(\"length\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(StandardTypes.BIGINT)\n-    public static long charLength(@LiteralParameter(\"x\") long x, @SqlType(\"char(x)\") Slice slice)\n-    {\n-        return x;\n-    }\n-\n-    @Description(\"Returns length of a character string without trailing spaces\")\n-    @ScalarFunction(value = \"$space_trimmed_length\", hidden = true)\n-    @SqlType(StandardTypes.BIGINT)\n-    public static long spaceTrimmedLength(@SqlType(\"varchar\") Slice slice)\n-    {\n-        return countCodePoints(slice, 0, byteCountWithoutTrailingSpace(slice, 0, slice.length()));\n-    }\n-\n-    @Description(\"Greedily removes occurrences of a pattern in a string\")\n-    @ScalarFunction\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(\"varchar(x)\")\n-    public static Slice replace(@SqlType(\"varchar(x)\") Slice str, @SqlType(\"varchar(y)\") Slice search)\n-    {\n-        return replace(str, search, Slices.EMPTY_SLICE);\n-    }\n-\n-    @Description(\"Greedily replaces occurrences of a pattern with a string\")\n-    @ScalarFunction\n-    @LiteralParameters({\"x\", \"y\", \"z\", \"u\"})\n-    @Constraint(variable = \"u\", expression = \"min(2147483647, x + z * (x + 1))\")\n-    @SqlType(\"varchar(u)\")\n-    public static Slice replace(@SqlType(\"varchar(x)\") Slice str, @SqlType(\"varchar(y)\") Slice search, @SqlType(\"varchar(z)\") Slice replace)\n-    {\n-        // Empty search?\n-        if (search.length() == 0) {\n-            // With empty `search` we insert `replace` in front of every character and and the end\n-            Slice buffer = Slices.allocate((countCodePoints(str) + 1) * replace.length() + str.length());\n-            // Always start with replace\n-            buffer.setBytes(0, replace);\n-            int indexBuffer = replace.length();\n-            // After every code point insert `replace`\n-            int index = 0;\n-            while (index < str.length()) {\n-                int codePointLength = lengthOfCodePointSafe(str, index);\n-                // Append current code point\n-                buffer.setBytes(indexBuffer, str, index, codePointLength);\n-                indexBuffer += codePointLength;\n-                // Append `replace`\n-                buffer.setBytes(indexBuffer, replace);\n-                indexBuffer += replace.length();\n-                // Advance pointer to current code point\n-                index += codePointLength;\n-            }\n-\n-            return buffer;\n-        }\n-        // Allocate a reasonable buffer\n-        Slice buffer = Slices.allocate(str.length());\n-\n-        int index = 0;\n-        int indexBuffer = 0;\n-        while (index < str.length()) {\n-            int matchIndex = str.indexOf(search, index);\n-            // Found a match?\n-            if (matchIndex < 0) {\n-                // No match found so copy the rest of string\n-                int bytesToCopy = str.length() - index;\n-                buffer = Slices.ensureSize(buffer, indexBuffer + bytesToCopy);\n-                buffer.setBytes(indexBuffer, str, index, bytesToCopy);\n-                indexBuffer += bytesToCopy;\n-\n-                break;\n-            }\n-\n-            int bytesToCopy = matchIndex - index;\n-            buffer = Slices.ensureSize(buffer, indexBuffer + bytesToCopy + replace.length());\n-            // Non empty match?\n-            if (bytesToCopy > 0) {\n-                buffer.setBytes(indexBuffer, str, index, bytesToCopy);\n-                indexBuffer += bytesToCopy;\n-            }\n-            // Non empty replace?\n-            if (replace.length() > 0) {\n-                buffer.setBytes(indexBuffer, replace);\n-                indexBuffer += replace.length();\n-            }\n-            // Continue searching after match\n-            index = matchIndex + search.length();\n-        }\n-\n-        return buffer.slice(0, indexBuffer);\n-    }\n-\n-    @Description(\"Reverse all code points in a given string\")\n-    @ScalarFunction\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice reverse(@SqlType(\"varchar(x)\") Slice slice)\n-    {\n-        return SliceUtf8.reverse(slice);\n-    }\n-\n-    @Description(\"Returns index of first occurrence of a substring (or 0 if not found)\")\n-    @ScalarFunction(\"strpos\")\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(StandardTypes.BIGINT)\n-    public static long stringPosition(@SqlType(\"varchar(x)\") Slice string, @SqlType(\"varchar(y)\") Slice substring)\n-    {\n-        return stringPosition(string, substring, 1);\n-    }\n-\n-    @Description(\"Returns index of n-th occurrence of a substring (or 0 if not found)\")\n-    @ScalarFunction(\"strpos\")\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(StandardTypes.BIGINT)\n-    public static long stringPosition(@SqlType(\"varchar(x)\") Slice string, @SqlType(\"varchar(y)\") Slice substring, @SqlType(StandardTypes.BIGINT) long instance)\n-    {\n-        if (instance < 0) {\n-            return stringPositionFromEnd(string, substring, abs(instance));\n-        }\n-        return stringPositionFromStart(string, substring, instance);\n-    }\n-\n-    private static long stringPositionFromStart(Slice string, Slice substring, long instance)\n-    {\n-        if (instance <= 0) {\n-            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'instance' must be a positive or negative number.\");\n-        }\n-        if (substring.length() == 0) {\n-            return 1;\n-        }\n-\n-        int foundInstances = 0;\n-        int index = -1;\n-        do {\n-            // step forwards through string\n-            index = string.indexOf(substring, index + 1);\n-            if (index < 0) {\n-                return 0;\n-            }\n-            foundInstances++;\n-        }\n-        while (foundInstances < instance);\n-\n-        return countCodePoints(string, 0, index) + 1;\n-    }\n-\n-    private static long stringPositionFromEnd(Slice string, Slice substring, long instance)\n-    {\n-        if (instance <= 0) {\n-            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'instance' must be a positive or negative number.\");\n-        }\n-        if (substring.length() == 0) {\n-            return 1;\n-        }\n-\n-        int foundInstances = 0;\n-        int index = string.length();\n-        do {\n-            // step backwards through string\n-            index = string.toStringUtf8().lastIndexOf(substring.toStringUtf8(), index - 1);\n-            if (index < 0) {\n-                return 0;\n-            }\n-            foundInstances++;\n-        }\n-        while (foundInstances < instance);\n-\n-        return index + 1;\n-    }\n-\n-    @Description(\"Suffix starting at given index\")\n-    @ScalarFunction(alias = \"substr\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice substring(@SqlType(\"varchar(x)\") Slice utf8, @SqlType(StandardTypes.BIGINT) long start)\n-    {\n-        if ((start == 0) || utf8.length() == 0) {\n-            return Slices.EMPTY_SLICE;\n-        }\n-\n-        int startCodePoint = Ints.saturatedCast(start);\n-\n-        if (startCodePoint > 0) {\n-            int indexStart = offsetOfCodePoint(utf8, startCodePoint - 1);\n-            if (indexStart < 0) {\n-                // before beginning of string\n-                return Slices.EMPTY_SLICE;\n-            }\n-            int indexEnd = utf8.length();\n-\n-            return utf8.slice(indexStart, indexEnd - indexStart);\n-        }\n-\n-        // negative start is relative to end of string\n-        int codePoints = countCodePoints(utf8);\n-        startCodePoint += codePoints;\n-\n-        // before beginning of string\n-        if (startCodePoint < 0) {\n-            return Slices.EMPTY_SLICE;\n-        }\n-\n-        int indexStart = offsetOfCodePoint(utf8, startCodePoint);\n-        int indexEnd = utf8.length();\n-\n-        return utf8.slice(indexStart, indexEnd - indexStart);\n-    }\n-\n-    @Description(\"Suffix starting at given index\")\n-    @ScalarFunction(value = \"substring\", alias = \"substr\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice charSubstring(@LiteralParameter(\"x\") Long x, @SqlType(\"char(x)\") Slice utf8, @SqlType(StandardTypes.BIGINT) long start)\n-    {\n-        return substring(padSpaces(utf8, x.intValue()), start);\n-    }\n-\n-    @Description(\"Substring of given length starting at an index\")\n-    @ScalarFunction(alias = \"substr\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice substring(@SqlType(\"varchar(x)\") Slice utf8, @SqlType(StandardTypes.BIGINT) long start, @SqlType(StandardTypes.BIGINT) long length)\n-    {\n-        if (start == 0 || (length <= 0) || (utf8.length() == 0)) {\n-            return Slices.EMPTY_SLICE;\n-        }\n-\n-        int startCodePoint = Ints.saturatedCast(start);\n-        int lengthCodePoints = Ints.saturatedCast(length);\n-\n-        if (startCodePoint > 0) {\n-            int indexStart = offsetOfCodePoint(utf8, startCodePoint - 1);\n-            if (indexStart < 0) {\n-                // before beginning of string\n-                return Slices.EMPTY_SLICE;\n-            }\n-            int indexEnd = offsetOfCodePoint(utf8, indexStart, lengthCodePoints);\n-            if (indexEnd < 0) {\n-                // after end of string\n-                indexEnd = utf8.length();\n-            }\n-\n-            return utf8.slice(indexStart, indexEnd - indexStart);\n-        }\n-\n-        // negative start is relative to end of string\n-        int codePoints = countCodePoints(utf8);\n-        startCodePoint += codePoints;\n-\n-        // before beginning of string\n-        if (startCodePoint < 0) {\n-            return Slices.EMPTY_SLICE;\n-        }\n-\n-        int indexStart = offsetOfCodePoint(utf8, startCodePoint);\n-        int indexEnd;\n-        if (startCodePoint + lengthCodePoints < codePoints) {\n-            indexEnd = offsetOfCodePoint(utf8, indexStart, lengthCodePoints);\n-        }\n-        else {\n-            indexEnd = utf8.length();\n-        }\n-\n-        return utf8.slice(indexStart, indexEnd - indexStart);\n-    }\n-\n-    @Description(\"Substring of given length starting at an index\")\n-    @ScalarFunction(value = \"substring\", alias = \"substr\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice charSubstr(@LiteralParameter(\"x\") Long x, @SqlType(\"char(x)\") Slice utf8, @SqlType(StandardTypes.BIGINT) long start, @SqlType(StandardTypes.BIGINT) long length)\n-    {\n-        return substring(padSpaces(utf8, x.intValue()), start, length);\n-    }\n-\n-    @ScalarFunction\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(\"array(varchar(x))\")\n-    public static Block split(@SqlType(\"varchar(x)\") Slice string, @SqlType(\"varchar(y)\") Slice delimiter)\n-    {\n-        return split(string, delimiter, string.length() + 1);\n-    }\n-\n-    @ScalarFunction\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(\"array(varchar(x))\")\n-    public static Block split(@SqlType(\"varchar(x)\") Slice string, @SqlType(\"varchar(y)\") Slice delimiter, @SqlType(StandardTypes.BIGINT) long limit)\n-    {\n-        checkCondition(limit > 0, INVALID_FUNCTION_ARGUMENT, \"Limit must be positive\");\n-        checkCondition(limit <= Integer.MAX_VALUE, INVALID_FUNCTION_ARGUMENT, \"Limit is too large\");\n-        checkCondition(delimiter.length() > 0, INVALID_FUNCTION_ARGUMENT, \"The delimiter may not be the empty string\");\n-        BlockBuilder parts = VARCHAR.createBlockBuilder(null, 1, string.length());\n-        // If limit is one, the last and only element is the complete string\n-        if (limit == 1) {\n-            VARCHAR.writeSlice(parts, string);\n-            return parts.build();\n-        }\n-\n-        int index = 0;\n-        while (index < string.length()) {\n-            int splitIndex = string.indexOf(delimiter, index);\n-            // Found split?\n-            if (splitIndex < 0) {\n-                break;\n-            }\n-            // Add the part from current index to found split\n-            VARCHAR.writeSlice(parts, string, index, splitIndex - index);\n-            // Continue searching after delimiter\n-            index = splitIndex + delimiter.length();\n-            // Reached limit-1 parts so we can stop\n-            if (parts.getPositionCount() == limit - 1) {\n-                break;\n-            }\n-        }\n-        // Rest of string\n-        VARCHAR.writeSlice(parts, string, index, string.length() - index);\n-\n-        return parts.build();\n-    }\n-\n-    @SqlNullable\n-    @Description(\"Splits a string by a delimiter and returns the specified field (counting from one)\")\n-    @ScalarFunction\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(\"varchar(x)\")\n-    public static Slice splitPart(@SqlType(\"varchar(x)\") Slice string, @SqlType(\"varchar(y)\") Slice delimiter, @SqlType(StandardTypes.BIGINT) long index)\n-    {\n-        checkCondition(index > 0, INVALID_FUNCTION_ARGUMENT, \"Index must be greater than zero\");\n-        // Empty delimiter? Then every character will be a split\n-        if (delimiter.length() == 0) {\n-            int startCodePoint = toIntExact(index);\n-\n-            int indexStart = offsetOfCodePoint(string, startCodePoint - 1);\n-            if (indexStart < 0) {\n-                // index too big\n-                return null;\n-            }\n-            int length = lengthOfCodePoint(string, indexStart);\n-            if (indexStart + length > string.length()) {\n-                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Invalid UTF-8 encoding\");\n-            }\n-            return string.slice(indexStart, length);\n-        }\n-\n-        int matchCount = 0;\n-\n-        int previousIndex = 0;\n-        while (previousIndex < string.length()) {\n-            int matchIndex = string.indexOf(delimiter, previousIndex);\n-            // No match\n-            if (matchIndex < 0) {\n-                break;\n-            }\n-            // Reached the requested part?\n-            if (++matchCount == index) {\n-                return string.slice(previousIndex, matchIndex - previousIndex);\n-            }\n-            // Continue searching after the delimiter\n-            previousIndex = matchIndex + delimiter.length();\n-        }\n-\n-        if (matchCount == index - 1) {\n-            // returns last section of the split\n-            return string.slice(previousIndex, string.length() - previousIndex);\n-        }\n-\n-        // index is too big, null is returned\n-        return null;\n-    }\n-\n-    @Description(\"Removes whitespace from the beginning of a string\")\n-    @ScalarFunction(\"ltrim\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice leftTrim(@SqlType(\"varchar(x)\") Slice slice)\n-    {\n-        return SliceUtf8.leftTrim(slice);\n-    }\n-\n-    @Description(\"Removes whitespace from the beginning of a string\")\n-    @ScalarFunction(\"ltrim\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"char(x)\")\n-    public static Slice charLeftTrim(@SqlType(\"char(x)\") Slice slice)\n-    {\n-        return SliceUtf8.leftTrim(slice);\n-    }\n-\n-    @Description(\"Removes whitespace from the end of a string\")\n-    @ScalarFunction(\"rtrim\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice rightTrim(@SqlType(\"varchar(x)\") Slice slice)\n-    {\n-        return SliceUtf8.rightTrim(slice);\n-    }\n-\n-    @Description(\"Removes whitespace from the end of a string\")\n-    @ScalarFunction(\"rtrim\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"char(x)\")\n-    public static Slice charRightTrim(@SqlType(\"char(x)\") Slice slice)\n-    {\n-        return rightTrim(slice);\n-    }\n-\n-    @Description(\"Removes whitespace from the beginning and end of a string\")\n-    @ScalarFunction\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice trim(@SqlType(\"varchar(x)\") Slice slice)\n-    {\n-        return SliceUtf8.trim(slice);\n-    }\n-\n-    @Description(\"Removes whitespace from the beginning and end of a string\")\n-    @ScalarFunction(\"trim\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"char(x)\")\n-    public static Slice charTrim(@SqlType(\"char(x)\") Slice slice)\n-    {\n-        return trim(slice);\n-    }\n-\n-    @Description(\"Remove the longest string containing only given characters from the beginning of a string\")\n-    @ScalarFunction(\"ltrim\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice leftTrim(@SqlType(\"varchar(x)\") Slice slice, @SqlType(CodePointsType.NAME) int[] codePointsToTrim)\n-    {\n-        return SliceUtf8.leftTrim(slice, codePointsToTrim);\n-    }\n-\n-    @Description(\"Remove the longest string containing only given characters from the beginning of a string\")\n-    @ScalarFunction(\"ltrim\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"char(x)\")\n-    public static Slice charLeftTrim(@SqlType(\"char(x)\") Slice slice, @SqlType(CodePointsType.NAME) int[] codePointsToTrim)\n-    {\n-        return leftTrim(slice, codePointsToTrim);\n-    }\n-\n-    @Description(\"Remove the longest string containing only given characters from the end of a string\")\n-    @ScalarFunction(\"rtrim\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice rightTrim(@SqlType(\"varchar(x)\") Slice slice, @SqlType(CodePointsType.NAME) int[] codePointsToTrim)\n-    {\n-        return SliceUtf8.rightTrim(slice, codePointsToTrim);\n-    }\n-\n-    @Description(\"Remove the longest string containing only given characters from the end of a string\")\n-    @ScalarFunction(\"rtrim\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"char(x)\")\n-    public static Slice charRightTrim(@SqlType(\"char(x)\") Slice slice, @SqlType(CodePointsType.NAME) int[] codePointsToTrim)\n-    {\n-        return trimTrailingSpaces(rightTrim(slice, codePointsToTrim));\n-    }\n-\n-    @Description(\"Remove the longest string containing only given characters from the beginning and end of a string\")\n-    @ScalarFunction(\"trim\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice trim(@SqlType(\"varchar(x)\") Slice slice, @SqlType(CodePointsType.NAME) int[] codePointsToTrim)\n-    {\n-        return SliceUtf8.trim(slice, codePointsToTrim);\n-    }\n-\n-    @Description(\"Remove the longest string containing only given characters from the beginning and end of a string\")\n-    @ScalarFunction(\"trim\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"char(x)\")\n-    public static Slice charTrim(@SqlType(\"char(x)\") Slice slice, @SqlType(CodePointsType.NAME) int[] codePointsToTrim)\n-    {\n-        return trimTrailingSpaces(trim(slice, codePointsToTrim));\n-    }\n-\n-    @ScalarOperator(OperatorType.CAST)\n-    @LiteralParameters(\"x\")\n-    @SqlType(CodePointsType.NAME)\n-    public static int[] castVarcharToCodePoints(@SqlType(\"varchar(x)\") Slice slice)\n-    {\n-        return castToCodePoints(slice);\n-    }\n-\n-    @ScalarOperator(OperatorType.CAST)\n-    @SqlType(CodePointsType.NAME)\n-    @LiteralParameters(\"x\")\n-    public static int[] castCharToCodePoints(@LiteralParameter(\"x\") Long charLength, @SqlType(\"char(x)\") Slice slice)\n-    {\n-        return castToCodePoints(padSpaces(slice, charLength.intValue()));\n-    }\n-\n-    private static int[] castToCodePoints(Slice slice)\n-    {\n-        int[] codePoints = new int[safeCountCodePoints(slice)];\n-        int position = 0;\n-        for (int index = 0; index < codePoints.length; index++) {\n-            codePoints[index] = getCodePointAt(slice, position);\n-            position += lengthOfCodePoint(slice, position);\n-        }\n-        return codePoints;\n-    }\n-\n-    private static int safeCountCodePoints(Slice slice)\n-    {\n-        int codePoints = 0;\n-        for (int position = 0; position < slice.length(); ) {\n-            int codePoint = tryGetCodePointAt(slice, position);\n-            if (codePoint < 0) {\n-                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Invalid UTF-8 encoding in characters: \" + slice.toStringUtf8());\n-            }\n-            position += lengthOfCodePoint(codePoint);\n-            codePoints++;\n-        }\n-        return codePoints;\n-    }\n-\n-    @Description(\"Converts the string to lower case\")\n-    @ScalarFunction\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice lower(@SqlType(\"varchar(x)\") Slice slice)\n-    {\n-        return toLowerCase(slice);\n-    }\n-\n-    @Description(\"Converts the string to lower case\")\n-    @ScalarFunction(\"lower\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"char(x)\")\n-    public static Slice charLower(@SqlType(\"char(x)\") Slice slice)\n-    {\n-        return lower(slice);\n-    }\n-\n-    @Description(\"Converts the string to upper case\")\n-    @ScalarFunction\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"varchar(x)\")\n-    public static Slice upper(@SqlType(\"varchar(x)\") Slice slice)\n-    {\n-        return toUpperCase(slice);\n-    }\n-\n-    @Description(\"Converts the string to upper case\")\n-    @ScalarFunction(\"upper\")\n-    @LiteralParameters(\"x\")\n-    @SqlType(\"char(x)\")\n-    public static Slice charUpper(@SqlType(\"char(x)\") Slice slice)\n-    {\n-        return upper(slice);\n-    }\n-\n-    private static Slice pad(Slice text, long targetLength, Slice padString, int paddingOffset)\n-    {\n-        checkCondition(\n-                0 <= targetLength && targetLength <= Integer.MAX_VALUE,\n-                INVALID_FUNCTION_ARGUMENT,\n-                \"Target length must be in the range [0..\" + Integer.MAX_VALUE + \"]\");\n-        checkCondition(padString.length() > 0, INVALID_FUNCTION_ARGUMENT, \"Padding string must not be empty\");\n-\n-        int textLength = countCodePoints(text);\n-        int resultLength = (int) targetLength;\n-\n-        // if our target length is the same as our string then return our string\n-        if (textLength == resultLength) {\n-            return text;\n-        }\n-\n-        // if our string is bigger than requested then truncate\n-        if (textLength > resultLength) {\n-            return SliceUtf8.substring(text, 0, resultLength);\n-        }\n-\n-        // number of bytes in each code point\n-        int padStringLength = countCodePoints(padString);\n-        int[] padStringCounts = new int[padStringLength];\n-        for (int i = 0; i < padStringLength; ++i) {\n-            padStringCounts[i] = lengthOfCodePointSafe(padString, offsetOfCodePoint(padString, i));\n-        }\n-\n-        // preallocate the result\n-        int bufferSize = text.length();\n-        for (int i = 0; i < resultLength - textLength; ++i) {\n-            bufferSize += padStringCounts[i % padStringLength];\n-        }\n-\n-        Slice buffer = Slices.allocate(bufferSize);\n-\n-        // fill in the existing string\n-        int countBytes = bufferSize - text.length();\n-        int startPointOfExistingText = (paddingOffset + countBytes) % bufferSize;\n-        buffer.setBytes(startPointOfExistingText, text);\n-\n-        // assign the pad string while there's enough space for it\n-        int byteIndex = paddingOffset;\n-        for (int i = 0; i < countBytes / padString.length(); ++i) {\n-            buffer.setBytes(byteIndex, padString);\n-            byteIndex += padString.length();\n-        }\n-\n-        // handle the tail: at most we assign padStringLength - 1 code points\n-        buffer.setBytes(byteIndex, padString.getBytes(0, paddingOffset + countBytes - byteIndex));\n-        return buffer;\n-    }\n-\n-    @Description(\"Pads a string on the left\")\n-    @ScalarFunction(\"lpad\")\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(StandardTypes.VARCHAR)\n-    public static Slice leftPad(@SqlType(\"varchar(x)\") Slice text, @SqlType(StandardTypes.BIGINT) long targetLength, @SqlType(\"varchar(y)\") Slice padString)\n-    {\n-        return pad(text, targetLength, padString, 0);\n-    }\n-\n-    @Description(\"Pads a string on the right\")\n-    @ScalarFunction(\"rpad\")\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(StandardTypes.VARCHAR)\n-    public static Slice rightPad(@SqlType(\"varchar(x)\") Slice text, @SqlType(StandardTypes.BIGINT) long targetLength, @SqlType(\"varchar(y)\") Slice padString)\n-    {\n-        return pad(text, targetLength, padString, text.length());\n-    }\n-\n-    @Description(\"Computes Levenshtein distance between two strings\")\n-    @ScalarFunction\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(StandardTypes.BIGINT)\n-    public static long levenshteinDistance(@SqlType(\"varchar(x)\") Slice left, @SqlType(\"varchar(y)\") Slice right)\n-    {\n-        int[] leftCodePoints = castToCodePoints(left);\n-        int[] rightCodePoints = castToCodePoints(right);\n-\n-        if (leftCodePoints.length < rightCodePoints.length) {\n-            int[] tempCodePoints = leftCodePoints;\n-            leftCodePoints = rightCodePoints;\n-            rightCodePoints = tempCodePoints;\n-        }\n-\n-        if (rightCodePoints.length == 0) {\n-            return leftCodePoints.length;\n-        }\n-\n-        checkCondition(\n-                (leftCodePoints.length * (rightCodePoints.length - 1)) <= 1_000_000,\n-                INVALID_FUNCTION_ARGUMENT,\n-                \"The combined inputs for Levenshtein distance are too large\");\n-\n-        int[] distances = new int[rightCodePoints.length];\n-        for (int i = 0; i < rightCodePoints.length; i++) {\n-            distances[i] = i + 1;\n-        }\n-\n-        for (int i = 0; i < leftCodePoints.length; i++) {\n-            int leftUpDistance = distances[0];\n-            if (leftCodePoints[i] == rightCodePoints[0]) {\n-                distances[0] = i;\n-            }\n-            else {\n-                distances[0] = Math.min(i, distances[0]) + 1;\n-            }\n-            for (int j = 1; j < rightCodePoints.length; j++) {\n-                int leftUpDistanceNext = distances[j];\n-                if (leftCodePoints[i] == rightCodePoints[j]) {\n-                    distances[j] = leftUpDistance;\n-                }\n-                else {\n-                    distances[j] = Math.min(distances[j - 1], Math.min(leftUpDistance, distances[j])) + 1;\n-                }\n-                leftUpDistance = leftUpDistanceNext;\n-            }\n-        }\n-\n-        return distances[rightCodePoints.length - 1];\n-    }\n-\n-    @Description(\"Computes Hamming distance between two strings\")\n-    @ScalarFunction\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(StandardTypes.BIGINT)\n-    public static long hammingDistance(@SqlType(\"varchar(x)\") Slice left, @SqlType(\"varchar(y)\") Slice right)\n-    {\n-        int distance = 0;\n-        int leftPosition = 0;\n-        int rightPosition = 0;\n-        while (leftPosition < left.length() && rightPosition < right.length()) {\n-            int codePointLeft = tryGetCodePointAt(left, leftPosition);\n-            int codePointRight = tryGetCodePointAt(right, rightPosition);\n-\n-            // if both code points are invalid, we do not care if they are equal\n-            // the following code treats them as equal if they happen to be of the same length\n-            if (codePointLeft != codePointRight) {\n-                distance++;\n-            }\n-\n-            leftPosition += codePointLeft > 0 ? lengthOfCodePoint(codePointLeft) : -codePointLeft;\n-            rightPosition += codePointRight > 0 ? lengthOfCodePoint(codePointRight) : -codePointRight;\n-        }\n-\n-        checkCondition(\n-                leftPosition == left.length() && rightPosition == right.length(),\n-                INVALID_FUNCTION_ARGUMENT,\n-                \"The input strings to hamming_distance function must have the same length\");\n-\n-        return distance;\n-    }\n-\n-    @Description(\"Transforms the string to normalized form\")\n-    @ScalarFunction\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(StandardTypes.VARCHAR)\n-    public static Slice normalize(@SqlType(\"varchar(x)\") Slice slice, @SqlType(\"varchar(y)\") Slice form)\n-    {\n-        Normalizer.Form targetForm;\n-        try {\n-            targetForm = Normalizer.Form.valueOf(form.toStringUtf8());\n-        }\n-        catch (IllegalArgumentException e) {\n-            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Normalization form must be one of [NFD, NFC, NFKD, NFKC]\");\n-        }\n-        return utf8Slice(Normalizer.normalize(slice.toStringUtf8(), targetForm));\n-    }\n-\n-    @Description(\"Decodes the UTF-8 encoded string\")\n-    @ScalarFunction\n-    @SqlType(StandardTypes.VARCHAR)\n-    public static Slice fromUtf8(@SqlType(StandardTypes.VARBINARY) Slice slice)\n-    {\n-        return SliceUtf8.fixInvalidUtf8(slice);\n-    }\n-\n-    @Description(\"Decodes the UTF-8 encoded string\")\n-    @ScalarFunction\n-    @LiteralParameters(\"x\")\n-    @SqlType(StandardTypes.VARCHAR)\n-    public static Slice fromUtf8(@SqlType(StandardTypes.VARBINARY) Slice slice, @SqlType(\"varchar(x)\") Slice replacementCharacter)\n-    {\n-        int count = countCodePoints(replacementCharacter);\n-        if (count > 1) {\n-            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Replacement character string must empty or a single character\");\n-        }\n-\n-        OptionalInt replacementCodePoint;\n-        if (count == 1) {\n-            try {\n-                replacementCodePoint = OptionalInt.of(getCodePointAt(replacementCharacter, 0));\n-            }\n-            catch (InvalidUtf8Exception e) {\n-                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Invalid replacement character\");\n-            }\n-        }\n-        else {\n-            replacementCodePoint = OptionalInt.empty();\n-        }\n-        return SliceUtf8.fixInvalidUtf8(slice, replacementCodePoint);\n-    }\n-\n-    @Description(\"Decodes the UTF-8 encoded string\")\n-    @ScalarFunction\n-    @SqlType(StandardTypes.VARCHAR)\n-    public static Slice fromUtf8(@SqlType(StandardTypes.VARBINARY) Slice slice, @SqlType(StandardTypes.BIGINT) long replacementCodePoint)\n-    {\n-        if (replacementCodePoint > MAX_CODE_POINT || Character.getType((int) replacementCodePoint) == SURROGATE) {\n-            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Invalid replacement character\");\n-        }\n-        return SliceUtf8.fixInvalidUtf8(slice, OptionalInt.of((int) replacementCodePoint));\n-    }\n-\n-    @Description(\"Encodes the string to UTF-8\")\n-    @ScalarFunction\n-    @LiteralParameters(\"x\")\n-    @SqlType(StandardTypes.VARBINARY)\n-    public static Slice toUtf8(@SqlType(\"varchar(x)\") Slice slice)\n-    {\n-        return slice;\n-    }\n-\n-    // TODO: implement N arguments char concat\n-    @Description(\"Concatenates given character strings\")\n-    @ScalarFunction\n-    @LiteralParameters({\"x\", \"y\", \"u\"})\n-    @Constraint(variable = \"u\", expression = \"x + y\")\n-    @SqlType(\"char(u)\")\n-    public static Slice concat(@LiteralParameter(\"x\") Long x, @SqlType(\"char(x)\") Slice left, @SqlType(\"char(y)\") Slice right)\n-    {\n-        int rightLength = right.length();\n-        if (rightLength == 0) {\n-            return left;\n-        }\n-\n-        Slice paddedLeft = padSpaces(left, x.intValue());\n-        int leftLength = paddedLeft.length();\n-\n-        Slice result = Slices.allocate(leftLength + rightLength);\n-        result.setBytes(0, paddedLeft);\n-        result.setBytes(leftLength, right);\n-\n-        return result;\n-    }\n-\n-    @Description(\"Determine whether source starts with prefix or not\")\n-    @ScalarFunction\n-    @LiteralParameters({\"x\", \"y\"})\n-    @SqlType(StandardTypes.BOOLEAN)\n-    public static boolean startsWith(@SqlType(\"varchar(x)\") Slice source, @SqlType(\"varchar(y)\") Slice prefix)\n-    {\n-        if (source.length() < prefix.length()) {\n-            return false;\n-        }\n-        return source.compareTo(0, prefix.length(), prefix, 0, prefix.length()) == 0;\n-    }\n-\n-    @Description(\"Encodes a string into a Soundex value\")\n-    @ScalarFunction\n-    @SqlType(StandardTypes.VARCHAR)\n-    public static Slice soundex(@SqlType(StandardTypes.VARCHAR) Slice slice)\n-    {\n-        return utf8Slice(new org.apache.commons.codec.language.Soundex().encode(slice.toStringUtf8()));\n-    }\n-}\n"}}, {"oid": "92c56f8c6369f6e9daec49b349553e9d630adf75", "url": "https://github.com/trinodb/trino/commit/92c56f8c6369f6e9daec49b349553e9d630adf75", "message": "Add Soundex function", "committedDate": "2021-04-20T22:41:53Z", "type": "commit"}, {"oid": "92c56f8c6369f6e9daec49b349553e9d630adf75", "url": "https://github.com/trinodb/trino/commit/92c56f8c6369f6e9daec49b349553e9d630adf75", "message": "Add Soundex function", "committedDate": "2021-04-20T22:41:53Z", "type": "forcePushed"}]}