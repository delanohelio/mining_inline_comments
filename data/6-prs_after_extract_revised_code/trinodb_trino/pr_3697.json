{"pr_number": 3697, "pr_title": "SPI and engine changes for aggregation pushdown", "pr_createdAt": "2020-05-11T17:03:02Z", "pr_url": "https://github.com/trinodb/trino/pull/3697", "timeline": [{"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "url": "https://github.com/trinodb/trino/commit/5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "message": "SPI changes to support nonpartial and complete aggregate pushdown to connectors.\nThe commit also includes the top level optimizer rule", "committedDate": "2020-05-18T21:37:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTM2MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428459360", "bodyText": "Place the first argument on the next line", "author": "martint", "createdAt": "2020-05-21T05:54:55Z", "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -352,6 +354,12 @@\n \n     Optional<TableHandle> applySample(Session session, TableHandle table, SampleType sampleType, double sampleRatio);\n \n+    Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDI2Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130262", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTM2MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/metadata/Metadata.java b/presto-main/src/main/java/io/prestosql/metadata/Metadata.java\nindex 583680937e..2241a084ef 100644\n--- a/presto-main/src/main/java/io/prestosql/metadata/Metadata.java\n+++ b/presto-main/src/main/java/io/prestosql/metadata/Metadata.java\n\n@@ -354,11 +355,12 @@ public interface Metadata\n \n     Optional<TableHandle> applySample(Session session, TableHandle table, SampleType sampleType, double sampleRatio);\n \n-    Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,\n+    Optional<AggregationApplicationResult<TableHandle>> applyAggregation(\n+            Session session,\n             TableHandle table,\n             List<AggregateFunction> aggregations,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy);\n+            List<List<ColumnHandle>> groupingSets);\n \n     default void validateScan(Session session, TableHandle table) {}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTI5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428461299", "bodyText": "Rename to AggregationApplicationResult for consistency with ProjectionApplicationResult", "author": "martint", "createdAt": "2020-05-21T06:01:32Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationPushdownResult<T>", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDIxMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130212", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTI5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\nsimilarity index 58%\nrename from presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java\nrename to presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\nindex f1ace05a19..943361e42b 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\n\n@@ -15,23 +15,31 @@ package io.prestosql.spi.connector;\n \n import io.prestosql.spi.expression.ConnectorExpression;\n \n-import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n \n-import static java.util.Collections.unmodifiableList;\n import static java.util.Objects.requireNonNull;\n \n-public class AggregationPushdownResult<T>\n+public class AggregationApplicationResult<T>\n {\n     private final T handle;\n     private final List<ConnectorExpression> projections;\n     private final List<Assignment> assignments;\n+    private final Map<ColumnHandle, ColumnHandle> groupingColumnMapping;\n \n-    public AggregationPushdownResult(T handle, List<ConnectorExpression> projections, List<Assignment> assignments)\n+    public AggregationApplicationResult(\n+            T handle,\n+            List<ConnectorExpression> projections,\n+            List<Assignment> assignments,\n+            Map<ColumnHandle, ColumnHandle> groupingColumnMapping)\n     {\n         this.handle = requireNonNull(handle, \"handle is null\");\n-        this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n-        this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));\n+        requireNonNull(groupingColumnMapping, \"goupingSetMapping is null\");\n+        requireNonNull(projections, \"projections is null\");\n+        requireNonNull(assignments, \"assignment is null\");\n+        this.groupingColumnMapping = Map.copyOf(groupingColumnMapping);\n+        this.projections = List.copyOf(projections);\n+        this.assignments = List.copyOf(assignments);\n     }\n \n     public T getHandle()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzA4MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428463081", "bodyText": "Format as:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .map(\n          \n          \n            \n                                    result -> {\n          \n          \n            \n                            .map(result -> {", "author": "martint", "createdAt": "2020-05-21T06:07:51Z", "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1103,56 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+            Session session,\n+            TableHandle table,\n+            List<AggregateFunction> aggregations,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupBy)\n+                .map(\n+                        result -> {", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE4OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130188", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzA4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java b/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\nindex 9ee303fae8..f12a45082b 100644\n--- a/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\n+++ b/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\n\n@@ -1104,12 +1112,12 @@ public final class MetadataManager\n     }\n \n     @Override\n-    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+    public Optional<AggregationApplicationResult<TableHandle>> applyAggregation(\n             Session session,\n             TableHandle table,\n             List<AggregateFunction> aggregations,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         CatalogName catalogName = table.getCatalogName();\n         ConnectorMetadata metadata = getMetadata(session, catalogName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzU2MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428463560", "bodyText": "Format as:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .findAny().ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });\n          \n          \n            \n                            .findAny()\n          \n          \n            \n                            .ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });", "author": "martint", "createdAt": "2020-05-21T06:09:39Z", "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1103,56 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+            Session session,\n+            TableHandle table,\n+            List<AggregateFunction> aggregations,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupBy)\n+                .map(\n+                        result -> {\n+                            verifyProjection(table, result.getProjections(), result.getAssignments(), aggregations.size());\n+\n+                            return new AggregationPushdownResult<>(\n+                                    new TableHandle(catalogName, result.getHandle(), table.getTransaction(), Optional.empty()),\n+                                    result.getProjections(),\n+                                    result.getAssignments());\n+                        });\n+    }\n+\n+    private void verifyProjection(TableHandle table, List<ConnectorExpression> projections, List<Assignment> assignments, int expectedProjectionSize)\n+    {\n+        projections.forEach(projection -> requireNonNull(projection, \"one of the projections is null\"));\n+        assignments.forEach(assignment -> requireNonNull(assignment, \"one of the assignments is null\"));\n+\n+        verify(\n+                expectedProjectionSize == projections.size(),\n+                \"ConnectorMetadata returned invalid number of projections: %s instead of %s for %s\",\n+                projections.size(),\n+                expectedProjectionSize,\n+                table);\n+\n+        Set<String> assignedVariables = assignments.stream()\n+                .map(Assignment::getVariable)\n+                .collect(toImmutableSet());\n+        projections.stream()\n+                .flatMap(connectorExpression -> ConnectorExpressions.extractVariables(connectorExpression).stream())\n+                .map(Variable::getName)\n+                .filter(variableName -> !assignedVariables.contains(variableName))\n+                .findAny().ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130165", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzU2MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java b/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\nindex 9ee303fae8..f12a45082b 100644\n--- a/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\n+++ b/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\n\n@@ -1104,12 +1112,12 @@ public final class MetadataManager\n     }\n \n     @Override\n-    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+    public Optional<AggregationApplicationResult<TableHandle>> applyAggregation(\n             Session session,\n             TableHandle table,\n             List<AggregateFunction> aggregations,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         CatalogName catalogName = table.getCatalogName();\n         ConnectorMetadata metadata = getMetadata(session, catalogName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDI5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428464294", "bodyText": "Put the first argument on the next line", "author": "martint", "createdAt": "2020-05-21T06:12:12Z", "path": "presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java", "diffHunk": "@@ -447,6 +449,16 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n         return Optional.empty();\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE0Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130143", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDI5NA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java b/presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java\nindex 8f1b567a1d..bd686f74d1 100644\n--- a/presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java\n+++ b/presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java\n\n@@ -450,11 +450,12 @@ public abstract class AbstractMockMetadata\n     }\n \n     @Override\n-    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,\n+    public Optional<AggregationApplicationResult<TableHandle>> applyAggregation(\n+            Session session,\n             TableHandle table,\n             List<AggregateFunction> aggregations,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDM4Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428464387", "bodyText": "First argument on the next line", "author": "martint", "createdAt": "2020-05-21T06:12:30Z", "path": "presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java", "diffHunk": "@@ -687,6 +689,18 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n         }\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(ConnectorSession session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDEyMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130121", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java b/presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java\nindex 8655333c1b..3a1eb0a5e5 100644\n--- a/presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java\n+++ b/presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java\n\n@@ -690,14 +698,15 @@ public class ClassLoaderSafeConnectorMetadata\n     }\n \n     @Override\n-    public Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(ConnectorSession session,\n+    public Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n+            ConnectorSession session,\n             ConnectorTableHandle table,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(classLoader)) {\n-            return delegate.applyAggregation(session, table, aggregates, assignments, groupBy);\n+            return delegate.applyAggregation(session, table, aggregates, assignments, groupingSets);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTQ0Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428465443", "bodyText": "It's not a great idea to piggyback on Map.Entry to represent a sort item. For one, it doesn't clearly convey what the key and value represent. Let's create a dedicated class named SortItem.", "author": "martint", "createdAt": "2020-05-21T06:15:51Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDEwNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130104", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTQ0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\nindex badf41db1e..eca20e8c0c 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n\n@@ -16,14 +16,11 @@ package io.prestosql.spi.connector;\n import io.prestosql.spi.expression.ConnectorExpression;\n import io.prestosql.spi.type.Type;\n \n-import java.util.ArrayList;\n import java.util.List;\n-import java.util.Map;\n import java.util.Objects;\n import java.util.Optional;\n import java.util.StringJoiner;\n \n-import static java.util.Collections.unmodifiableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregateFunction\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NjIwNw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428466207", "bodyText": "requireNonNull", "author": "martint", "createdAt": "2020-05-21T06:18:16Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n+        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n+        this.filter = filter;", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA4OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130089", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NjIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\nindex badf41db1e..eca20e8c0c 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n\n@@ -16,14 +16,11 @@ package io.prestosql.spi.connector;\n import io.prestosql.spi.expression.ConnectorExpression;\n import io.prestosql.spi.type.Type;\n \n-import java.util.ArrayList;\n import java.util.List;\n-import java.util.Map;\n import java.util.Objects;\n import java.util.Optional;\n import java.util.StringJoiner;\n \n-import static java.util.Collections.unmodifiableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregateFunction\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NzA1MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428467051", "bodyText": "Move the requireNonNull for the arguments outside of the call. Having them inline muddles the code and makes it harder to read. Also, use List.copyOf():\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n          \n          \n            \n                    this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n          \n          \n            \n                    requireNonNull(inputs, \"inputs is null\");\n          \n          \n            \n                    requireNonNull(sortOrder, \"sortOrder is null\")\n          \n          \n            \n                    \n          \n          \n            \n                    this.inputs = List.copyOf(inputs);\n          \n          \n            \n                    this.sortOrder = List.copyOf(inputs);", "author": "martint", "createdAt": "2020-05-21T06:20:53Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA1OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130058", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NzA1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\nindex badf41db1e..eca20e8c0c 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n\n@@ -16,14 +16,11 @@ package io.prestosql.spi.connector;\n import io.prestosql.spi.expression.ConnectorExpression;\n import io.prestosql.spi.type.Type;\n \n-import java.util.ArrayList;\n import java.util.List;\n-import java.util.Map;\n import java.util.Objects;\n import java.util.Optional;\n import java.util.StringJoiner;\n \n-import static java.util.Collections.unmodifiableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregateFunction\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2ODA5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428468099", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n          \n          \n            \n                    this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));\n          \n          \n            \n                    requireNonNull(projections, \"projections is null\");\n          \n          \n            \n                    requireNonNull(assignments, \"assignment is null\");\n          \n          \n            \n                    this.projections = List.copyOf(projections);\n          \n          \n            \n                    this.assignments = List.copyOf(assignments);", "author": "martint", "createdAt": "2020-05-21T06:24:07Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationPushdownResult<T>\n+{\n+    private final T handle;\n+    private final List<ConnectorExpression> projections;\n+    private final List<Assignment> assignments;\n+\n+    public AggregationPushdownResult(T handle, List<ConnectorExpression> projections, List<Assignment> assignments)\n+    {\n+        this.handle = requireNonNull(handle, \"handle is null\");\n+        this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n+        this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA0OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130048", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2ODA5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\nsimilarity index 58%\nrename from presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java\nrename to presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\nindex f1ace05a19..943361e42b 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\n\n@@ -15,23 +15,31 @@ package io.prestosql.spi.connector;\n \n import io.prestosql.spi.expression.ConnectorExpression;\n \n-import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n \n-import static java.util.Collections.unmodifiableList;\n import static java.util.Objects.requireNonNull;\n \n-public class AggregationPushdownResult<T>\n+public class AggregationApplicationResult<T>\n {\n     private final T handle;\n     private final List<ConnectorExpression> projections;\n     private final List<Assignment> assignments;\n+    private final Map<ColumnHandle, ColumnHandle> groupingColumnMapping;\n \n-    public AggregationPushdownResult(T handle, List<ConnectorExpression> projections, List<Assignment> assignments)\n+    public AggregationApplicationResult(\n+            T handle,\n+            List<ConnectorExpression> projections,\n+            List<Assignment> assignments,\n+            Map<ColumnHandle, ColumnHandle> groupingColumnMapping)\n     {\n         this.handle = requireNonNull(handle, \"handle is null\");\n-        this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n-        this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));\n+        requireNonNull(groupingColumnMapping, \"goupingSetMapping is null\");\n+        requireNonNull(projections, \"projections is null\");\n+        requireNonNull(assignments, \"assignment is null\");\n+        this.groupingColumnMapping = Map.copyOf(groupingColumnMapping);\n+        this.projections = List.copyOf(projections);\n+        this.assignments = List.copyOf(assignments);\n     }\n \n     public T getHandle()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjMzOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428906338", "bodyText": "We generally place the .stream() call next to the previous one as it's immaterial to understanding what the transformation does:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .entrySet()\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .entrySet().stream()", "author": "martint", "createdAt": "2020-05-21T20:49:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDAzMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130031", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjMzOA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428906526", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n          \n          \n            \n                            .stream()\n          \n          \n            \n                    List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations.stream()", "author": "martint", "createdAt": "2020-05-21T20:49:43Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwODUwOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428908508", "bodyText": "If you change toAggregateFunction to process a single aggregation, you can rewrite this as:\nList<AggregateFunction> aggregateFunctions = aggregations.stream()\n        .map(Entry::getValue)\n        .map(this::toAggregateFunction)\n        .collect(toImmutableList());\nAlso, since some aggregations are not candidates to be pushed down (e.g., if they contain lambda expressions), add a check before that bails out early if the condition doesn't hold, although it'd be it'd be better to add this condition to the pattern:\n    private static final Pattern<AggregationNode> PATTERN = aggregation()\n            .matching(PushAggregationIntoTableScan::allArgumentsAreSimpleReferences) // skip arguments that are, for instance, lambda expressions\n            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n\n    private static boolean allArgumentsAreSimpleReferences(AggregationNode node)\n    {\n        return node.getAggregations()\n                .values().stream()\n                .flatMap(aggregation -> aggregation.getArguments().stream())\n                .allMatch(SymbolReference.class::isInstance)\n    }", "author": "martint", "createdAt": "2020-05-21T20:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTk4Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129983", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMjg4MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428912880", "bodyText": "Add this to the pattern:\nprivate static final Pattern<AggregationNode> PATTERN = aggregation()\n        .matching(node -> node.getGroupingSets().getGroupingSetCount() == 1)\n        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "author": "martint", "createdAt": "2020-05-21T21:02:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTk1OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129958", "bodyText": "Changed the pattern to capture this and no masks.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMjg4MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxODczNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428918734", "bodyText": "These variables are used only once. Inline them where they are referenced.", "author": "martint", "createdAt": "2020-05-21T21:15:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTY1Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129656", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxODczNA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTEzMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919130", "bodyText": "This should unnecessary once you add the filter to the pattern as described above.", "author": "martint", "createdAt": "2020-05-21T21:16:24Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTYzMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129632", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTEzMA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTcxMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919710", "bodyText": "This can only be a SymbolReference, so it'd be more appropriate to do:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .map(SymbolsExtractor::extractUnique)\n          \n          \n            \n                                .flatMap(Collection::stream)\n          \n          \n            \n                                .map(Symbol::from)", "author": "martint", "createdAt": "2020-05-21T21:17:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTU4NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129585", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTcxMA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTg0Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919842", "bodyText": "This should unnecessary once you add the filter to the pattern as described above.", "author": "martint", "createdAt": "2020-05-21T21:18:06Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)\n+                    .collect(toImmutableList());\n+\n+            if (arguments.size() != symbols.size()) {\n+                return ImmutableList.of();\n+            }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTUwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129500", "bodyText": "removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428922849", "bodyText": "Once you apply all the suggestions above and below, this method can simplify to:\nprivate AggregateFunction toAggregateFunction(AggregationNode.Aggregation aggregation)\n{\n    Signature signature = aggregation.getResolvedFunction().getSignature();\n\n    ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n    for (int i = 0; i < aggregation.getArguments().size(); i++) {\n        SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n        arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n    }\n\n    Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n    Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n            orderings.getOrderBy().stream()\n                    .map(orderBy -> new AbstractMap.SimpleEntry<>(\n                            orderBy.getName(),\n                            SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n                    .collect(toImmutableList()));\n\n    return new AggregateFunction(\n            signature.getName(),\n            metadata.getType(signature.getReturnType()),\n            arguments.build(),\n            sortBy.orElse(ImmutableList.of()),\n            aggregation.isDistinct(),\n            aggregation.getFilter().map(Symbol::getName));\n}", "author": "martint", "createdAt": "2020-05-21T21:24:03Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5OTAwNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429899005", "bodyText": "what about aggregation.getMask()? we should verify aggregation.getMask() is not present (yet).", "author": "findepi", "createdAt": "2020-05-25T12:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTQyNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129424", "bodyText": "Done, added check for masks in pattern.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyNDI5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428924290", "bodyText": "This is incorrect. The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.", "author": "martint", "createdAt": "2020-05-21T21:26:50Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTM2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129365", "bodyText": "comment removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyNDI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NDk5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429864990", "bodyText": "6d9d47e", "author": "findepi", "createdAt": "2020-05-25T10:37:23Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODczMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128731", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NDk5MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NjMzNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429866335", "bodyText": "Why not ImmutableList.of(groupByColumns) always?\n[ [] ] would correctly describe the fact that there is 1 grouping set and that it is a global aggregation.", "author": "findepi", "createdAt": "2020-05-25T10:41:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODcwOQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128709", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NjMzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MDUxNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429870514", "bodyText": "i think #3697 (comment) is still waiting for final resolution. @martint ?\n(nit: if this stays, would be good to avoid \"unioned\" as intellij spellchecker highlights this)", "author": "findepi", "createdAt": "2020-05-25T10:51:58Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODY3OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128679", "bodyText": "unioned removed. I have assumed @martint 's last comment is what we want the API to do and changed both the contract and docs to reflect that. Let me know if there is a gap in my understanding vs what is expected.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MDUxNA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTA5NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "author": "findepi", "createdAt": "2020-05-25T10:53:23Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODA2Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128062", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTQ5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871499", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n          \n          \n            \n                 *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n          \n      \n    \n    \n  \n\notherwise you would need to use &lt; &gt;", "author": "findepi", "createdAt": "2020-05-25T10:54:24Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODA0MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128041", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTQ5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTkwOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * group_by=[{@link ColumnHandle} CH2]\n          \n          \n            \n                 * group_by=[[{@link ColumnHandle} CH2]]\n          \n      \n    \n    \n  \n\n(it's list of lists)", "author": "findepi", "createdAt": "2020-05-25T10:55:33Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MjA5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872099", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * assignments = {a = CH0, b=CH1, c=CH2}\n          \n          \n            \n                 * assignments = {a = CH0, b = CH1, c = CH2}", "author": "findepi", "createdAt": "2020-05-25T10:56:00Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MjgzNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872834", "bodyText": "c assignments seems redundant, as there is no c variable", "author": "findepi", "createdAt": "2020-05-25T10:57:50Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3Mjk5Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872996", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *  - aggregation\n          \n          \n            \n                 *          variable0 = agg_fn1(a)\n          \n          \n            \n                 *          variable1 = agg_fn2(b, 2)\n          \n          \n            \n                 *          variable2 = group_by c\n          \n          \n            \n                 *  - aggregation (GROUP BY c)\n          \n          \n            \n                 *          variable0 = agg_fn1(a)\n          \n          \n            \n                 *          variable1 = agg_fn2(b, 2)\n          \n          \n            \n                 *          variable2 = c", "author": "findepi", "createdAt": "2020-05-25T10:58:15Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MzM3Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873373", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "author": "findepi", "createdAt": "2020-05-25T10:59:19Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MzY1Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873653", "bodyText": "i like the way you wrote this!\njust consider adding an indent (here and following).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@link AggregationPushdownResult} {\n          \n          \n            \n                 * handle = TH1\n          \n          \n            \n                 * {@link AggregationPushdownResult} {\n          \n          \n            \n                 *     handle = TH1", "author": "findepi", "createdAt": "2020-05-25T11:00:01Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3Mzk3MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873970", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n          \n          \n            \n                 * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>", "author": "findepi", "createdAt": "2020-05-25T11:00:51Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDIxNw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874217", "bodyText": "CH0, CH1, and CH2 are already used above", "author": "findepi", "createdAt": "2020-05-25T11:01:31Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDQxNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874415", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n          \n          \n            \n                 * if the connector only knows how to handle {@code agg_fn1}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.", "author": "findepi", "createdAt": "2020-05-25T11:02:03Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDc2OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874769", "bodyText": "Should we call this groupingSets? @martint ?", "author": "findepi", "createdAt": "2020-05-25T11:03:00Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     */\n+    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+            ConnectorSession session,\n+            ConnectorTableHandle handle,\n+            List<AggregateFunction> aggregates,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n\n@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NTY5NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429875695", "bodyText": "isDistinct is primitive, so\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n          \n          \n            \n                    this.isDistinct = isDistinct;", "author": "findepi", "createdAt": "2020-05-25T11:05:33Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n+        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\nindex badf41db1e..eca20e8c0c 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n\n@@ -16,14 +16,11 @@ package io.prestosql.spi.connector;\n import io.prestosql.spi.expression.ConnectorExpression;\n import io.prestosql.spi.type.Type;\n \n-import java.util.ArrayList;\n import java.util.List;\n-import java.util.Map;\n import java.util.Objects;\n import java.util.Optional;\n import java.util.StringJoiner;\n \n-import static java.util.Collections.unmodifiableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregateFunction\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4NTY5Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429885693", "bodyText": "Moving out Assignment as a top level class touches a lot of files, that are otherwise unrelated to the change.\nCan you please extract this to a preparatory commit?", "author": "findepi", "createdAt": "2020-05-25T11:31:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -91,7 +92,7 @@ public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n             handle = result.get().getHandle();\n \n             Map<String, ColumnHandle> assignments = result.get().getAssignments().stream()\n-                    .collect(toImmutableMap(ProjectionApplicationResult.Assignment::getVariable, ProjectionApplicationResult.Assignment::getColumn));\n+                    .collect(toImmutableMap(Assignment::getVariable, Assignment::getColumn));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4Nzg2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429887865", "bodyText": "Why?\nIf you remove this, the rule would be applicable also for queries like\nSELECT DISTINCT regionkey FROM tpch.tiny.nation;", "author": "findepi", "createdAt": "2020-05-25T11:36:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MTA0NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429891044", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Pattern<AggregationNode> PATTERN = aggregation()\n          \n          \n            \n                        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n          \n            \n                    private static final Pattern<AggregationNode> PATTERN =\n          \n          \n            \n                        aggregation()\n          \n          \n            \n                                .with(step().equalTo(SINGLE))\n          \n          \n            \n                                .matching(node -> node.getGroupingSetCount() == 1)\n          \n          \n            \n                                .matching(node -> node.getGroupIdSymbol().isEmpty())\n          \n          \n            \n                                .matching(node -> node.getHashSymbol().isEmpty())\n          \n          \n            \n                                .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n      \n    \n    \n  \n\n\na few additional checks\nif you move aggregation() to new line, this fill be formatted better", "author": "findepi", "createdAt": "2020-05-25T11:44:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5OTM5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429899390", "bodyText": "plus additional conditions\n\n@martint 's all agg args are symbols condition\nagg mask is not present\nanything else?", "author": "findepi", "createdAt": "2020-05-25T12:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MTA0NA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MjcxMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429892713", "bodyText": "what does \"partial project\" mean here? (can this be  newProjections?)", "author": "findepi", "createdAt": "2020-05-25T11:49:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODAxNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128015", "bodyText": "renamed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MjcxMw=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MzEzMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429893130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    groupingSets.getGroupingKeys().stream()\n          \n          \n            \n                            .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n          \n          \n            \n                    groupingSets.getGroupingKeys()\n          \n          \n            \n                            .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n          \n      \n    \n    \n  \n\n-- use Collection#forEach without going thru Stream", "author": "findepi", "createdAt": "2020-05-25T11:50:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzcxNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127716", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MzEzMA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NDk0Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429894946", "bodyText": "add verify(aggregationOutputSymbols.size() == newPartialProjections.size()); just before this line as this is where you depend on this\nno need for good exc msg, since it's in fact already validated in MetadataManager, so it's more for documenting assumptions/dependencies of the code here", "author": "findepi", "createdAt": "2020-05-25T11:54:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzcwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127700", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NDk0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n\n@@ -13,8 +13,8 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import io.prestosql.matching.Capture;\n import io.prestosql.matching.Captures;\n import io.prestosql.matching.Pattern;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429896486", "bodyText": "Optional<Variable>", "author": "findepi", "createdAt": "2020-05-25T11:58:16Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzY4Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127682", "bodyText": "Not sure about this, Why would this need to be a variable given the filter on the agg side is just a Symbol?", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4NTI5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432385294", "bodyText": "Symbols (engine things) are mapped to Variables in ConnectorExpression.\nUsing Variable here would give semantics to this field -- connector would know it needs to check assignments to know which column handle this is.", "author": "findepi", "createdAt": "2020-05-29T10:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMTYwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r434531600", "bodyText": "BTW why isn't filter a Optional<ConnectorExpression> (or ConnectorExpression without Optional,  using new Constant(true, BOOLEAN) instead of empty).\n@Parth-Brahmbhatt  @martint did you discuss this bit already?", "author": "findepi", "createdAt": "2020-06-03T12:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NTM5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r436055394", "bodyText": "We haven't discussed this, originally I did not have mask or filter as I couldn't quite understand how those were used. I will figure out how to get the corresponding connector expression from the symbol and update the PR today.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-05T17:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NDUxMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r436144513", "bodyText": "we haven't discussed this, I originally had no filters or masks as I did not completely understand what masks are for. @martint asked to add the filter in this PR in the first pass so the connectors have to explicitly decide to not handle them. For the current rule given it will only be matched when agg is followed by scan node the only possible place to look for filter symbol is tablescan assignment so I think it makes sense to just map it to Variable for now. I can't think of a scenario where we match this rule and it has a filter but the symbol is not in tablescan assignment so I have not added a check for that If you think we should add a defensive check I can add a condition.\nI personally prefer Optional so I have kept it as is, let me know if you would like me to remove Optional.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-05T20:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "chunk": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\nindex badf41db1e..eca20e8c0c 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n\n@@ -16,14 +16,11 @@ package io.prestosql.spi.connector;\n import io.prestosql.spi.expression.ConnectorExpression;\n import io.prestosql.spi.type.Type;\n \n-import java.util.ArrayList;\n import java.util.List;\n-import java.util.Map;\n import java.util.Objects;\n import java.util.Optional;\n import java.util.StringJoiner;\n \n-import static java.util.Collections.unmodifiableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregateFunction\n"}}, {"oid": "0a598fdfffa13d60136ab89df3370bf637b362a1", "url": "https://github.com/trinodb/trino/commit/0a598fdfffa13d60136ab89df3370bf637b362a1", "message": "Add support for aggregation pushdow", "committedDate": "2020-06-11T18:05:43Z", "type": "commit"}, {"oid": "0a598fdfffa13d60136ab89df3370bf637b362a1", "url": "https://github.com/trinodb/trino/commit/0a598fdfffa13d60136ab89df3370bf637b362a1", "message": "Add support for aggregation pushdow", "committedDate": "2020-06-11T18:05:43Z", "type": "forcePushed"}]}