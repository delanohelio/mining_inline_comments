{"pr_number": 3600, "pr_title": "Revamp TranslationMap and planner", "pr_createdAt": "2020-05-02T16:34:45Z", "pr_url": "https://github.com/trinodb/trino/pull/3600", "timeline": [{"oid": "2706fc40d5a4e0cf88f69ad27d8e4044271adfe0", "url": "https://github.com/trinodb/trino/commit/2706fc40d5a4e0cf88f69ad27d8e4044271adfe0", "message": "Simplify expression", "committedDate": "2020-06-27T01:33:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1OTkwMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447559902", "bodyText": "it would be nice to have concat accepts more arguments", "author": "kokosing", "createdAt": "2020-06-30T09:53:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -1027,6 +1028,18 @@ public GroupingSetAnalysis(\n         {\n             return complexExpressions;\n         }\n+\n+        public Set<FieldId> getAllFields()\n+        {\n+            return Stream.concat(", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg3MzIxMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448873211", "bodyText": "You can use https://guava.dev/releases/23.0/api/docs/com/google/common/collect/Streams.html#concat-java.util.stream.Stream...- instead", "author": "sopel39", "createdAt": "2020-07-02T09:30:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1OTkwMg=="}], "type": "inlineReview", "revised_code": {"commit": "0021100712c13f47721667c40b13d9e41fa162a7", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java b/presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java\nindex 909937d1ad..2f7be5c140 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java\n\n@@ -1028,18 +1027,6 @@ public class Analysis\n         {\n             return complexExpressions;\n         }\n-\n-        public Set<FieldId> getAllFields()\n-        {\n-            return Stream.concat(\n-                    Stream.concat(\n-                            cubes.stream().flatMap(Collection::stream),\n-                            rollups.stream().flatMap(Collection::stream)),\n-                    ordinarySets.stream()\n-                            .flatMap(Collection::stream)\n-                            .flatMap(Collection::stream))\n-                    .collect(toImmutableSet());\n-        }\n     }\n \n     public static class UnnestAnalysis\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2MzU5NA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447563594", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // TODO: this should properly be multiset(row(...))\n          \n          \n            \n                        // TODO: this should be multiset(row(...))\n          \n      \n    \n    \n  \n\n?\nWouldn't be more proper for io.prestosql.sql.tree.ExistsPredicate to store io.prestosql.sql.tree.Query instead of Expression? Is it legal to have EXISTS (1)", "author": "kokosing", "createdAt": "2020-06-30T09:58:48Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1280,8 +1278,24 @@ else if (previousNode instanceof QuantifiedComparisonExpression) {\n         protected Type visitExists(ExistsPredicate node, StackableAstVisitorContext<Context> context)\n         {\n             StatementAnalyzer analyzer = statementAnalyzerFactory.apply(node);\n-            Scope subqueryScope = Scope.builder().withParent(context.getContext().getScope()).build();\n-            analyzer.analyze(node.getSubquery(), subqueryScope);\n+            Scope subqueryScope = Scope.builder()\n+                    .withParent(context.getContext().getScope())\n+                    .build();\n+\n+            List<RowType.Field> fields = analyzer.analyze(node.getSubquery(), subqueryScope)\n+                    .getRelationType()\n+                    .getAllFields().stream()\n+                    .map(field -> {\n+                        if (field.getName().isPresent()) {\n+                            return RowType.field(field.getName().get(), field.getType());\n+                        }\n+\n+                        return RowType.field(field.getType());\n+                    })\n+                    .collect(toImmutableList());\n+\n+            // TODO: this should properly be multiset(row(...))", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY5NDE0Ng==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447694146", "bodyText": "I agree. Unfortunately, the AST doesn\u2019t allow for such structure. That\u2019s why subqueries were modeled that way.\nOnce this PR is in, we can start splitting AST from IR and have more flexibility to evolve the IR to fit the needs of the planner and optimizer", "author": "martint", "createdAt": "2020-06-30T13:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2MzU5NA=="}], "type": "inlineReview", "revised_code": {"commit": "0021100712c13f47721667c40b13d9e41fa162a7", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java b/presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java\nindex fe2fc0c800..b0670adf97 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java\n\n@@ -1278,24 +1280,8 @@ public class ExpressionAnalyzer\n         protected Type visitExists(ExistsPredicate node, StackableAstVisitorContext<Context> context)\n         {\n             StatementAnalyzer analyzer = statementAnalyzerFactory.apply(node);\n-            Scope subqueryScope = Scope.builder()\n-                    .withParent(context.getContext().getScope())\n-                    .build();\n-\n-            List<RowType.Field> fields = analyzer.analyze(node.getSubquery(), subqueryScope)\n-                    .getRelationType()\n-                    .getAllFields().stream()\n-                    .map(field -> {\n-                        if (field.getName().isPresent()) {\n-                            return RowType.field(field.getName().get(), field.getType());\n-                        }\n-\n-                        return RowType.field(field.getType());\n-                    })\n-                    .collect(toImmutableList());\n-\n-            // TODO: this should properly be multiset(row(...))\n-            setExpressionType(node.getSubquery(), RowType.from(fields));\n+            Scope subqueryScope = Scope.builder().withParent(context.getContext().getScope()).build();\n+            analyzer.analyze(node.getSubquery(), subqueryScope);\n \n             existsSubqueries.add(NodeRef.of(node));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2NzQwMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447567403", "bodyText": "separate commit?", "author": "kokosing", "createdAt": "2020-06-30T10:05:20Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1622,7 +1636,11 @@ public static ExpressionAnalysis analyzeExpressions(\n         Analysis analysis = new Analysis(null, parameters, isDescribe);\n         ExpressionAnalyzer analyzer = create(analysis, session, metadata, sqlParser, accessControl, types, warningCollector);\n         for (Expression expression : expressions) {\n-            analyzer.analyze(expression, Scope.builder().withRelationType(RelationId.anonymous(), new RelationType()).build());", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0021100712c13f47721667c40b13d9e41fa162a7", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java b/presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java\nindex fe2fc0c800..b0670adf97 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java\n\n@@ -1636,11 +1622,7 @@ public class ExpressionAnalyzer\n         Analysis analysis = new Analysis(null, parameters, isDescribe);\n         ExpressionAnalyzer analyzer = create(analysis, session, metadata, sqlParser, accessControl, types, warningCollector);\n         for (Expression expression : expressions) {\n-            analyzer.analyze(\n-                    expression,\n-                    Scope.builder()\n-                            .withRelationType(RelationId.anonymous(), new RelationType())\n-                            .build());\n+            analyzer.analyze(expression, Scope.builder().withRelationType(RelationId.anonymous(), new RelationType()).build());\n         }\n \n         return new ExpressionAnalysis(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MzM3MQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447593371", "bodyText": "extract variable selectExpressions", "author": "kokosing", "createdAt": "2020-06-30T10:52:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1322,22 +1321,20 @@ protected Scope visitQuerySpecification(QuerySpecification node, Optional<Scope>\n                 }\n             }\n \n-            List<Expression> sourceExpressions = new ArrayList<>(outputExpressions);\n+            List<Expression> sourceExpressions = new ArrayList<>(analysis.getSelectExpressions(node).stream().map(SelectExpression::getExpression).collect(Collectors.toList()));", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0021100712c13f47721667c40b13d9e41fa162a7", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java b/presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java\nindex ae13adeac2..7c98a18e78 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java\n\n@@ -1321,20 +1322,22 @@ class StatementAnalyzer\n                 }\n             }\n \n-            List<Expression> sourceExpressions = new ArrayList<>(analysis.getSelectExpressions(node).stream().map(SelectExpression::getExpression).collect(Collectors.toList()));\n+            List<Expression> sourceExpressions = new ArrayList<>(outputExpressions);\n             node.getHaving().ifPresent(sourceExpressions::add);\n \n             analyzeGroupingOperations(node, sourceExpressions, orderByExpressions);\n-            analyzeAggregations(node, sourceScope, orderByScope, groupByAnalysis, sourceExpressions, orderByExpressions);\n+            analyzeAggregations(node, sourceScope, orderByScope, groupByExpressions, sourceExpressions, orderByExpressions);\n             analyzeWindowFunctions(node, outputExpressions, orderByExpressions);\n \n             if (analysis.isAggregation(node) && node.getOrderBy().isPresent()) {\n-                ImmutableList.Builder<Expression> aggregates = ImmutableList.<Expression>builder()\n-                        .addAll(groupByAnalysis.getOriginalExpressions())\n-                        .addAll(extractAggregateFunctions(orderByExpressions, metadata))\n-                        .addAll(extractExpressions(orderByExpressions, GroupingOperation.class));\n-\n-                analysis.setOrderByAggregates(node.getOrderBy().get(), aggregates.build());\n+                // Create a different scope for ORDER BY expressions when aggregation is present.\n+                // This is because planner requires scope in order to resolve names against fields.\n+                // Original ORDER BY scope \"sees\" FROM query fields. However, during planning\n+                // and when aggregation is present, ORDER BY expressions should only be resolvable against\n+                // output scope, group by expressions and aggregation expressions.\n+                List<GroupingOperation> orderByGroupingOperations = extractExpressions(orderByExpressions, GroupingOperation.class);\n+                List<FunctionCall> orderByAggregations = extractAggregateFunctions(orderByExpressions, metadata);\n+                computeAndAssignOrderByScopeWithAggregation(node.getOrderBy().get(), sourceScope, outputScope, orderByAggregations, groupByExpressions, orderByGroupingOperations);\n             }\n \n             return outputScope;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MzgzNA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447593834", "bodyText": "seperate commit?", "author": "kokosing", "createdAt": "2020-06-30T10:53:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1601,8 +1598,10 @@ protected Scope visitValues(Values node, Optional<Scope> scope)\n         {\n             checkState(node.getRows().size() >= 1);\n \n+            Scope valuesScope = createScope(scope);\n+\n             List<List<Type>> rowTypes = node.getRows().stream()\n-                    .map(row -> analyzeExpression(row, createScope(scope)).getType(row))\n+                    .map(row -> analyzeExpression(row, valuesScope).getType(row))", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edb4b8b12a01d4b5ecad3395b87bc92daa829902", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java b/presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java\nindex ae13adeac2..9a8f35fab8 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java\n\n@@ -1598,10 +1601,8 @@ class StatementAnalyzer\n         {\n             checkState(node.getRows().size() >= 1);\n \n-            Scope valuesScope = createScope(scope);\n-\n             List<List<Type>> rowTypes = node.getRows().stream()\n-                    .map(row -> analyzeExpression(row, valuesScope).getType(row))\n+                    .map(row -> analyzeExpression(row, createScope(scope)).getType(row))\n                     .map(type -> {\n                         if (type instanceof RowType) {\n                             return type.getTypeParameters();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NjUwNQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447596505", "bodyText": "private", "author": "kokosing", "createdAt": "2020-06-30T10:58:44Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -466,130 +331,154 @@ private PlanBuilder aggregate(PlanBuilder subPlan, QuerySpecification node)\n                 .map(OrderBy::getSortItems)\n                 .flatMap(List::stream)\n                 .map(SortItem::getSortKey)\n-                .forEach(arguments::add);\n+                .forEach(inputBuilder::add);\n \n         // filter expressions need to be projected first\n         analysis.getAggregates(node).stream()\n                 .map(FunctionCall::getFilter)\n                 .filter(Optional::isPresent)\n                 .map(Optional::get)\n-                .forEach(arguments::add);\n+                .forEach(inputBuilder::add);\n \n-        Iterable<Expression> inputs = Iterables.concat(groupByExpressions, arguments.build());\n-        subPlan = handleSubqueries(subPlan, node, inputs);\n+        GroupingSetAnalysis groupingSetAnalysis = analysis.getGroupingSets(node);\n+        inputBuilder.addAll(groupingSetAnalysis.getComplexExpressions());\n \n-        if (!Iterables.isEmpty(inputs)) { // avoid an empty projection if the only aggregation is COUNT (which has no arguments)\n-            subPlan = project(subPlan, inputs);\n-        }\n+        List<Expression> inputs = inputBuilder.build();\n+        subPlan = subqueryPlanner.handleSubqueries(subPlan, inputs, node);\n+        subPlan = subPlan.appendProjections(inputs, symbolAllocator, idAllocator);\n \n-        // 2. Aggregate\n+        // Add projection to coerce inputs to their site-specific types.\n+        // This is important because the same lexical expression may need to be coerced\n+        // in different ways if it's referenced by multiple arguments to the window function.\n+        // For example, given v::integer,\n+        //    avg(v)\n+        // Needs to be rewritten as\n+        //    avg(CAST(v AS double))\n+        PlanAndMappings coercions = coerce(subPlan, inputs, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = coercions.getSubPlan();\n \n-        // 2.a. Rewrite aggregate arguments\n-        TranslationMap argumentTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n+        GroupingSetsPlan groupingSets = planGroupingSets(subPlan, node, groupingSetAnalysis);\n \n-        ImmutableList.Builder<Symbol> aggregationArgumentsBuilder = ImmutableList.builder();\n-        for (Expression argument : arguments.build()) {\n-            Symbol symbol = subPlan.translate(argument);\n-            argumentTranslations.put(argument, symbol);\n-            aggregationArgumentsBuilder.add(symbol);\n-        }\n-        List<Symbol> aggregationArguments = aggregationArgumentsBuilder.build();\n+        subPlan = planAggregation(groupingSets.getSubPlan(), groupingSets.getGroupingSets(), groupingSets.getGroupIdSymbol(), analysis.getAggregates(node), coercions::get);\n \n-        // 2.b. Rewrite grouping columns\n-        TranslationMap groupingTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n+        return planGroupingOperations(subPlan, node, groupingSets.getGroupIdSymbol(), groupingSets.getColumnOnlyGroupingSets());\n+    }\n+\n+    public GroupingSetsPlan planGroupingSets(PlanBuilder subPlan, QuerySpecification node, GroupingSetAnalysis groupingSetAnalysis)", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0021100712c13f47721667c40b13d9e41fa162a7", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java b/presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java\nindex 9c400ab4a1..ec60276010 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java\n\n@@ -331,154 +466,130 @@ class QueryPlanner\n                 .map(OrderBy::getSortItems)\n                 .flatMap(List::stream)\n                 .map(SortItem::getSortKey)\n-                .forEach(inputBuilder::add);\n+                .forEach(arguments::add);\n \n         // filter expressions need to be projected first\n         analysis.getAggregates(node).stream()\n                 .map(FunctionCall::getFilter)\n                 .filter(Optional::isPresent)\n                 .map(Optional::get)\n-                .forEach(inputBuilder::add);\n-\n-        GroupingSetAnalysis groupingSetAnalysis = analysis.getGroupingSets(node);\n-        inputBuilder.addAll(groupingSetAnalysis.getComplexExpressions());\n+                .forEach(arguments::add);\n \n-        List<Expression> inputs = inputBuilder.build();\n-        subPlan = subqueryPlanner.handleSubqueries(subPlan, inputs, node);\n-        subPlan = subPlan.appendProjections(inputs, symbolAllocator, idAllocator);\n+        Iterable<Expression> inputs = Iterables.concat(groupByExpressions, arguments.build());\n+        subPlan = handleSubqueries(subPlan, node, inputs);\n \n-        // Add projection to coerce inputs to their site-specific types.\n-        // This is important because the same lexical expression may need to be coerced\n-        // in different ways if it's referenced by multiple arguments to the window function.\n-        // For example, given v::integer,\n-        //    avg(v)\n-        // Needs to be rewritten as\n-        //    avg(CAST(v AS double))\n-        PlanAndMappings coercions = coerce(subPlan, inputs, analysis, idAllocator, symbolAllocator, typeCoercion);\n-        subPlan = coercions.getSubPlan();\n+        if (!Iterables.isEmpty(inputs)) { // avoid an empty projection if the only aggregation is COUNT (which has no arguments)\n+            subPlan = project(subPlan, inputs);\n+        }\n \n-        GroupingSetsPlan groupingSets = planGroupingSets(subPlan, node, groupingSetAnalysis);\n+        // 2. Aggregate\n \n-        subPlan = planAggregation(groupingSets.getSubPlan(), groupingSets.getGroupingSets(), groupingSets.getGroupIdSymbol(), analysis.getAggregates(node), coercions::get);\n+        // 2.a. Rewrite aggregate arguments\n+        TranslationMap argumentTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n \n-        return planGroupingOperations(subPlan, node, groupingSets.getGroupIdSymbol(), groupingSets.getColumnOnlyGroupingSets());\n-    }\n+        ImmutableList.Builder<Symbol> aggregationArgumentsBuilder = ImmutableList.builder();\n+        for (Expression argument : arguments.build()) {\n+            Symbol symbol = subPlan.translate(argument);\n+            argumentTranslations.put(argument, symbol);\n+            aggregationArgumentsBuilder.add(symbol);\n+        }\n+        List<Symbol> aggregationArguments = aggregationArgumentsBuilder.build();\n \n-    public GroupingSetsPlan planGroupingSets(PlanBuilder subPlan, QuerySpecification node, GroupingSetAnalysis groupingSetAnalysis)\n-    {\n+        // 2.b. Rewrite grouping columns\n+        TranslationMap groupingTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n         Map<Symbol, Symbol> groupingSetMappings = new LinkedHashMap<>();\n \n-        // Compute a set of artificial columns that will contain the values of the original columns\n-        // filtered by whether the column is included in the grouping set\n-        // This will become the basis for the scope for any column references\n-        Symbol[] fields = new Symbol[subPlan.getTranslations().getFieldSymbols().size()];\n-        for (FieldId field : groupingSetAnalysis.getAllFields()) {\n-            Symbol input = subPlan.getTranslations().getFieldSymbols().get(field.getFieldIndex());\n-            Symbol output = symbolAllocator.newSymbol(input, \"gid\");\n-            fields[field.getFieldIndex()] = output;\n-            groupingSetMappings.put(output, input);\n-        }\n-\n-        ImmutableMap.Builder<Expression, Symbol> expressionsBuilder = ImmutableMap.builder();\n-        for (Expression expression : groupingSetAnalysis.getComplexExpressions()) {\n+        for (Expression expression : groupByExpressions) {\n             Symbol input = subPlan.translate(expression);\n-            Symbol output = symbolAllocator.newSymbol(expression, analysis.getType(expression), \"gid\");\n-            expressionsBuilder.put(expression, output);\n+            Symbol output = symbolAllocator.newSymbol(expression, analysis.getTypeWithCoercions(expression), \"gid\");\n+            groupingTranslations.put(expression, output);\n             groupingSetMappings.put(output, input);\n         }\n-        Map<Expression, Symbol> complexExpressions = expressionsBuilder.build();\n \n-        // For the purpose of \"distinct\", we need to canonicalize column references that may have varying\n-        // syntactic forms (e.g., \"t.a\" vs \"a\"). Thus we need to enumerate grouping sets based on the underlying\n-        // fieldId associated with each column reference expression.\n+        // This tracks the grouping sets before complex expressions are considered (see comments below)\n+        // It's also used to compute the descriptors needed to implement grouping()\n+        List<Set<FieldId>> columnOnlyGroupingSets = ImmutableList.of(ImmutableSet.of());\n+        List<List<Symbol>> groupingSets = ImmutableList.of(ImmutableList.of());\n+\n+        if (node.getGroupBy().isPresent()) {\n+            // For the purpose of \"distinct\", we need to canonicalize column references that may have varying\n+            // syntactic forms (e.g., \"t.a\" vs \"a\"). Thus we need to enumerate grouping sets based on the underlying\n+            // fieldId associated with each column reference expression.\n+\n+            // The catch is that simple group-by expressions can be arbitrary expressions (this is a departure from the SQL specification).\n+            // But, they don't affect the number of grouping sets or the behavior of \"distinct\" . We can compute all the candidate\n+            // grouping sets in terms of fieldId, dedup as appropriate and then cross-join them with the complex expressions.\n+            GroupingSetAnalysis groupingSetAnalysis = analysis.getGroupingSets(node);\n+            columnOnlyGroupingSets = enumerateGroupingSets(groupingSetAnalysis);\n+\n+            if (node.getGroupBy().get().isDistinct()) {\n+                columnOnlyGroupingSets = columnOnlyGroupingSets.stream()\n+                        .distinct()\n+                        .collect(toImmutableList());\n+            }\n \n-        // The catch is that simple group-by expressions can be arbitrary expressions (this is a departure from the SQL specification).\n-        // But, they don't affect the number of grouping sets or the behavior of \"distinct\" . We can compute all the candidate\n-        // grouping sets in terms of fieldId, dedup as appropriate and then cross-join them with the complex expressions.\n+            // add in the complex expressions an turn materialize the grouping sets in terms of plan columns\n+            ImmutableList.Builder<List<Symbol>> groupingSetBuilder = ImmutableList.builder();\n+            for (Set<FieldId> groupingSet : columnOnlyGroupingSets) {\n+                ImmutableList.Builder<Symbol> columns = ImmutableList.builder();\n+                groupingSetAnalysis.getComplexExpressions().stream()\n+                        .map(groupingTranslations::get)\n+                        .forEach(columns::add);\n \n-        // This tracks the grouping sets before complex expressions are considered.\n-        // It's also used to compute the descriptors needed to implement grouping()\n-        List<Set<FieldId>> columnOnlyGroupingSets = enumerateGroupingSets(groupingSetAnalysis);\n-        if (node.getGroupBy().isPresent() && node.getGroupBy().get().isDistinct()) {\n-            columnOnlyGroupingSets = columnOnlyGroupingSets.stream()\n-                    .distinct()\n-                    .collect(toImmutableList());\n-        }\n+                groupingSet.stream()\n+                        .map(field -> groupingTranslations.get(new FieldReference(field.getFieldIndex())))\n+                        .forEach(columns::add);\n \n-        // translate from FieldIds to Symbols\n-        List<List<Symbol>> sets = columnOnlyGroupingSets.stream()\n-                .map(set -> set.stream()\n-                        .map(FieldId::getFieldIndex)\n-                        .map(index -> fields[index])\n-                        .collect(toImmutableList()))\n-                .collect(toImmutableList());\n+                groupingSetBuilder.add(columns.build());\n+            }\n \n-        // combine (cartesian product) with complex expressions\n-        List<List<Symbol>> groupingSets = sets.stream()\n-                .map(set -> ImmutableList.<Symbol>builder()\n-                        .addAll(set)\n-                        .addAll(complexExpressions.values())\n-                        .build())\n-                .collect(toImmutableList());\n+            groupingSets = groupingSetBuilder.build();\n+        }\n \n-        // Generate GroupIdNode (multiple grouping sets) or ProjectNode (single grouping set)\n-        PlanNode groupId;\n+        // 2.c. Generate GroupIdNode (multiple grouping sets) or ProjectNode (single grouping set)\n         Optional<Symbol> groupIdSymbol = Optional.empty();\n         if (groupingSets.size() > 1) {\n             groupIdSymbol = Optional.of(symbolAllocator.newSymbol(\"groupId\", BIGINT));\n-            groupId = new GroupIdNode(\n-                    idAllocator.getNextId(),\n-                    subPlan.getRoot(),\n-                    groupingSets,\n-                    groupingSetMappings,\n-                    subPlan.getRoot().getOutputSymbols(),\n-                    groupIdSymbol.get());\n+            GroupIdNode groupId = new GroupIdNode(idAllocator.getNextId(), subPlan.getRoot(), groupingSets, groupingSetMappings, aggregationArguments, groupIdSymbol.get());\n+            subPlan = new PlanBuilder(groupingTranslations, groupId);\n         }\n         else {\n             Assignments.Builder assignments = Assignments.builder();\n-            assignments.putIdentities(subPlan.getRoot().getOutputSymbols());\n+            aggregationArguments.forEach(assignments::putIdentity);\n             groupingSetMappings.forEach((key, value) -> assignments.put(key, value.toSymbolReference()));\n \n-            groupId = new ProjectNode(idAllocator.getNextId(), subPlan.getRoot(), assignments.build());\n+            ProjectNode project = new ProjectNode(idAllocator.getNextId(), subPlan.getRoot(), assignments.build());\n+            subPlan = new PlanBuilder(groupingTranslations, project);\n         }\n \n-        subPlan = new PlanBuilder(\n-                subPlan.getTranslations()\n-                        .withNewMappings(complexExpressions, Arrays.asList(fields)),\n-                groupId);\n+        TranslationMap aggregationTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n+        aggregationTranslations.copyMappingsFrom(groupingTranslations);\n \n-        return new GroupingSetsPlan(subPlan, columnOnlyGroupingSets, groupingSets, groupIdSymbol);\n-    }\n+        // 2.d. Rewrite aggregates\n+        ImmutableMap.Builder<Symbol, Aggregation> aggregationsBuilder = ImmutableMap.builder();\n+        boolean needPostProjectionCoercion = false;\n+        for (FunctionCall aggregate : analysis.getAggregates(node)) {\n+            Expression rewritten = argumentTranslations.rewrite(aggregate);\n+            Symbol newSymbol = symbolAllocator.newSymbol(rewritten, analysis.getType(aggregate));\n \n-    private PlanBuilder planAggregation(PlanBuilder subPlan, List<List<Symbol>> groupingSets, Optional<Symbol> groupIdSymbol, List<FunctionCall> aggregates, Function<Expression, Symbol> coercions)\n-    {\n-        ImmutableList.Builder<AggregationAssignment> aggregateMappingBuilder = ImmutableList.builder();\n-\n-        // deduplicate based on scope-aware equality\n-        for (FunctionCall function : scopeAwareDistinct(subPlan, aggregates)) {\n-            Symbol symbol = symbolAllocator.newSymbol(function, analysis.getType(function));\n-\n-            // TODO: for ORDER BY arguments, rewrite them such that they match the actual arguments to the function. This is necessary to maintain the semantics of DISTINCT + ORDER BY,\n-            //   which requires that ORDER BY be a subset of arguments\n-            //   What can happen currently is that if the argument requires a coercion, the argument will take a different input that the ORDER BY clause, which is undefined behavior\n-            Aggregation aggregation = new Aggregation(\n-                    analysis.getResolvedFunction(function),\n-                    function.getArguments().stream()\n-                            .map(argument -> {\n-                                if (argument instanceof LambdaExpression) {\n-                                    return subPlan.rewrite(argument);\n-                                }\n-                                return coercions.apply(argument).toSymbolReference();\n-                            })\n-                            .collect(toImmutableList()),\n-                    function.isDistinct(),\n-                    function.getFilter().map(coercions::apply),\n-                    function.getOrderBy().map(orderBy -> translateOrderingScheme(orderBy.getSortItems(), coercions)),\n-                    Optional.empty());\n-\n-            aggregateMappingBuilder.add(new AggregationAssignment(symbol, function, aggregation));\n-        }\n-        List<AggregationAssignment> aggregateMappings = aggregateMappingBuilder.build();\n+            // TODO: this is a hack, because we apply coercions to the output of expressions, rather than the arguments to expressions.\n+            // Therefore we can end up with this implicit cast, and have to move it into a post-projection\n+            if (rewritten instanceof Cast) {\n+                rewritten = ((Cast) rewritten).getExpression();\n+                needPostProjectionCoercion = true;\n+            }\n+            aggregationTranslations.put(aggregate, newSymbol);\n+\n+            FunctionCall functionCall = (FunctionCall) rewritten;\n+            aggregationsBuilder.put(newSymbol, new Aggregation(\n+                    analysis.getResolvedFunction(aggregate),\n+                    functionCall.getArguments(),\n+                    functionCall.isDistinct(),\n+                    functionCall.getFilter().map(Symbol::from),\n+                    functionCall.getOrderBy().map(OrderingScheme::fromOrderBy),\n+                    Optional.empty()));\n+        }\n+        Map<Symbol, Aggregation> aggregations = aggregationsBuilder.build();\n \n         ImmutableSet.Builder<Integer> globalGroupingSets = ImmutableSet.builder();\n         for (int i = 0; i < groupingSets.size(); i++) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDcwOA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447600708", "bodyText": "I think it makes a sense to extract Cluster class", "author": "kokosing", "createdAt": "2020-06-30T11:07:32Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,316 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMDMzOQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447830339", "bodyText": "What's the benefit? A \"cluster\" is just a list of expressions, so that would be just a wrapper over a list.", "author": "martint", "createdAt": "2020-06-30T16:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4NTQzMA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448185430", "bodyText": "A \"cluster\" is just a list of expressions\n\nIt is just an implementation of collection of equal elements. Having this abstraction you wouldn't need to call such checks.\nAlso do you actually need this list? Maybe you could have an representative element and count of copies?", "author": "kokosing", "createdAt": "2020-07-01T07:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDcwOA=="}], "type": "inlineReview", "revised_code": {"commit": "0021100712c13f47721667c40b13d9e41fa162a7", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java b/presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java\nindex 1434462e11..708b59edd9 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java\n\n@@ -111,239 +105,225 @@ class SubqueryPlanner\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n-            builder = planInPredicate(builder, cluster, node);\n-        }\n-        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n-            builder = planScalarSubquery(builder, cluster);\n-        }\n-        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n-            builder = planExists(builder, cluster);\n-        }\n-        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n-            builder = planQuantifiedComparison(builder, cluster, node);\n-        }\n-\n+        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n+        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n+        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n+        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n         return builder;\n     }\n \n-    /**\n-     * Find subqueries from the candidate set that are children of the given parent\n-     * and that have not already been handled in the subplan\n-     */\n-    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n+    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n     {\n-        SuccessorsFunction<Node> recurse = expression -> {\n-            if (expression instanceof Expression &&\n-                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n-                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n-                return expression.getChildren();\n-            }\n-\n-            return ImmutableList.of();\n-        };\n+        return analysis.getInPredicateSubqueries(node)\n+                .stream()\n+                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n+                .collect(toImmutableSet());\n+    }\n \n-        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n+    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n+    {\n+        return analysis.getScalarSubqueries(node)\n+                .stream()\n+                .filter(subquery -> nodeContains(expression, subquery))\n+                .collect(toImmutableSet());\n+    }\n \n-        return candidates\n+    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n+    {\n+        return analysis.getExistsSubqueries(node)\n                 .stream()\n-                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n-                .filter(candidate -> !subPlan.canTranslate(candidate))\n-                .collect(toImmutableList());\n+                .filter(subquery -> nodeContains(expression, subquery))\n+                .collect(toImmutableSet());\n     }\n \n-    /**\n-     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n-     */\n-    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n+    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n     {\n-        Map<T, List<T>> sets = new LinkedHashMap<>();\n+        return analysis.getQuantifiedComparisonSubqueries(node)\n+                .stream()\n+                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n+                .collect(toImmutableSet());\n+    }\n \n-        for (T expression : expressions) {\n-            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n-                    .add(expression);\n+    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    {\n+        for (InPredicate inPredicate : inPredicates) {\n+            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n         }\n-\n-        return sets.values();\n+        return subPlan;\n     }\n \n-    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n+    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n     {\n-        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n-\n-        // Plan one of the predicates from the cluster\n-        InPredicate predicate = cluster.get(0);\n-\n-        Expression value = predicate.getValue();\n-        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n-        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n+        if (subPlan.canTranslate(inPredicate)) {\n+            // given subquery is already appended\n+            return subPlan;\n+        }\n \n-        subPlan = handleSubqueries(subPlan, value, node);\n-        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n+        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n \n-        return new PlanBuilder(\n-                subPlan.getTranslations()\n-                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n-                subPlan.getRoot());\n-    }\n+        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n \n-    /**\n-     * Plans a correlated subquery for value IN (subQuery)\n-     *\n-     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n-     */\n-    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n-    {\n-        // Use the current plan's translations as the outer context when planning the subquery\n-        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n-        PlanBuilder subqueryPlan = newPlanBuilder(\n-                relationPlan,\n-                analysis,\n-                lambdaDeclarationToSymbolMap,\n-                ImmutableMap.of(scopeAwareKey(subquery, analysis, relationPlan.getScope()), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n+        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n+        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n+        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n+        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n \n-        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n-        subqueryPlan = subqueryCoercions.getSubPlan();\n+        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n+        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n \n-        subPlan = subPlan.appendProjections(\n-                ImmutableList.of(value),\n-                symbolAllocator,\n-                idAllocator);\n+        Symbol rewrittenValue = subPlan.translate(inPredicate.getValue());\n+        InPredicate inPredicateSubqueryExpression = new InPredicate(rewrittenValue.toSymbolReference(), valueList);\n+        Symbol inPredicateSubquerySymbol = symbolAllocator.newSymbol(inPredicateSubqueryExpression, BOOLEAN);\n \n-        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n-        subPlan = subplanCoercions.getSubPlan();\n+        subPlan.getTranslations().put(inPredicate, inPredicateSubquerySymbol);\n \n-        return new PlanBuilder(\n-                subPlan.getTranslations(),\n-                new ApplyNode(\n-                        idAllocator.getNextId(),\n-                        subPlan.getRoot(),\n-                        subqueryPlan.getRoot(),\n-                        Assignments.of(output, new InPredicate(\n-                                subplanCoercions.get(value).toSymbolReference(),\n-                                subqueryCoercions.get(subquery).toSymbolReference())),\n-                        subPlan.getRoot().getOutputSymbols(),\n-                        originalExpression));\n+        return appendApplyNode(subPlan, inPredicate, subqueryPlan.getRoot(), Assignments.of(inPredicateSubquerySymbol, inPredicateSubqueryExpression));\n     }\n \n-    private PlanBuilder planScalarSubquery(PlanBuilder subPlan, List<SubqueryExpression> cluster)\n+    private PlanBuilder appendScalarSubqueryCorrelatedJoins(PlanBuilder builder, Set<SubqueryExpression> scalarSubqueries)\n     {\n-        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n+        for (SubqueryExpression scalarSubquery : scalarSubqueries) {\n+            builder = appendScalarSubqueryApplyNode(builder, scalarSubquery);\n+        }\n+        return builder;\n+    }\n \n-        // Plan one of the predicates from the cluster\n-        SubqueryExpression scalarSubquery = cluster.get(0);\n+    private PlanBuilder appendScalarSubqueryApplyNode(PlanBuilder subPlan, SubqueryExpression scalarSubquery)\n+    {\n+        if (subPlan.canTranslate(scalarSubquery)) {\n+            // given subquery is already appended\n+            return subPlan;\n+        }\n \n-        RelationPlan relationPlan = planSubquery(scalarSubquery, subPlan.getTranslations());\n-        PlanBuilder subqueryPlan = newPlanBuilder(\n-                relationPlan,\n-                analysis,\n-                lambdaDeclarationToSymbolMap);\n+        List<Expression> coercions = coercionsFor(scalarSubquery);\n \n+        SubqueryExpression uncoercedScalarSubquery = uncoercedSubquery(scalarSubquery);\n+        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedScalarSubquery);\n         subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n+        subqueryPlan = subqueryPlan.appendProjections(coercions, symbolAllocator, idAllocator);\n \n-        return appendCorrelatedJoin(\n-                subPlan,\n-                subqueryPlan,\n-                scalarSubquery.getQuery(),\n-                CorrelatedJoinNode.Type.INNER,\n-                TRUE_LITERAL,\n-                mapAll(cluster, subPlan.getScope(), getOnlyElement(relationPlan.getFieldMappings())));\n+        Symbol uncoercedScalarSubquerySymbol = subqueryPlan.translate(uncoercedScalarSubquery);\n+        subPlan.getTranslations().put(uncoercedScalarSubquery, uncoercedScalarSubquerySymbol);\n+\n+        for (Expression coercion : coercions) {\n+            Symbol coercionSymbol = subqueryPlan.translate(coercion);\n+            subPlan.getTranslations().put(coercion, coercionSymbol);\n+        }\n+\n+        // The subquery's EnforceSingleRowNode always produces a row, so the join is effectively INNER\n+        return appendCorrelatedJoin(subPlan, subqueryPlan, scalarSubquery.getQuery(), CorrelatedJoinNode.Type.INNER, TRUE_LITERAL);\n     }\n \n-    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition, Map<ScopeAware<Expression>, Symbol> mappings)\n+    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition)\n     {\n+        PlanNode subqueryNode = subqueryPlan.getRoot();\n+        Map<NodeRef<Expression>, Expression> correlation = extractCorrelation(subPlan, subqueryNode);\n+        subqueryNode = replaceExpressionsWithSymbols(subqueryNode, correlation);\n+\n         return new PlanBuilder(\n-                subPlan.getTranslations()\n-                        .withAdditionalMappings(mappings),\n+                subPlan.copyTranslations(),\n                 new CorrelatedJoinNode(\n                         idAllocator.getNextId(),\n                         subPlan.getRoot(),\n-                        subqueryPlan.getRoot(),\n-                        subPlan.getRoot().getOutputSymbols(),\n+                        subqueryNode,\n+                        ImmutableList.copyOf(SymbolsExtractor.extractUnique(correlation.values())),\n                         type,\n                         filterCondition,\n                         query));\n     }\n \n-    private PlanBuilder planExists(PlanBuilder subPlan, List<ExistsPredicate> cluster)\n+    private PlanBuilder appendExistsSubqueryApplyNodes(PlanBuilder builder, Set<ExistsPredicate> existsPredicates)\n     {\n-        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n+        for (ExistsPredicate existsPredicate : existsPredicates) {\n+            builder = appendExistSubqueryApplyNode(builder, existsPredicate);\n+        }\n+        return builder;\n+    }\n \n-        // Plan one of the predicates from the cluster\n-        ExistsPredicate existsPredicate = cluster.get(0);\n+    /**\n+     * Exists is modeled as:\n+     * <pre>\n+     *     - Project($0 > 0)\n+     *       - Aggregation(COUNT(*))\n+     *         - Limit(1)\n+     *           -- subquery\n+     * </pre>\n+     */\n+    private PlanBuilder appendExistSubqueryApplyNode(PlanBuilder subPlan, ExistsPredicate existsPredicate)\n+    {\n+        if (subPlan.canTranslate(existsPredicate)) {\n+            // given subquery is already appended\n+            return subPlan;\n+        }\n \n-        Expression subquery = existsPredicate.getSubquery();\n-        Symbol exists = symbolAllocator.newSymbol(\"exists\", BOOLEAN);\n+        PlanBuilder subqueryPlan = createPlanBuilder(existsPredicate.getSubquery());\n \n-        return new PlanBuilder(\n-                subPlan.getTranslations()\n-                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), exists)),\n-                new ApplyNode(\n-                        idAllocator.getNextId(),\n-                        subPlan.getRoot(),\n-                        planSubquery(subquery, subPlan.getTranslations()).getRoot(),\n-                        Assignments.of(exists, new ExistsPredicate(TRUE_LITERAL)),\n-                        subPlan.getRoot().getOutputSymbols(),\n-                        subquery));\n+        Symbol exists = symbolAllocator.newSymbol(\"exists\", BOOLEAN);\n+        subPlan.getTranslations().put(existsPredicate, exists);\n+        ExistsPredicate rewrittenExistsPredicate = new ExistsPredicate(TRUE_LITERAL);\n+        return appendApplyNode(\n+                subPlan,\n+                existsPredicate.getSubquery(),\n+                subqueryPlan.getRoot(),\n+                Assignments.of(exists, rewrittenExistsPredicate));\n     }\n \n-    private RelationPlan planSubquery(Expression subquery, TranslationMap outerContext)\n+    private PlanBuilder appendQuantifiedComparisonApplyNodes(PlanBuilder subPlan, Set<QuantifiedComparisonExpression> quantifiedComparisons, Node node)\n     {\n-        return new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, Optional.of(outerContext), session)\n-                .process(subquery, null);\n+        for (QuantifiedComparisonExpression quantifiedComparison : quantifiedComparisons) {\n+            subPlan = appendQuantifiedComparisonApplyNode(subPlan, quantifiedComparison, node);\n+        }\n+        return subPlan;\n     }\n \n-    private PlanBuilder planQuantifiedComparison(PlanBuilder subPlan, List<QuantifiedComparisonExpression> cluster, Node node)\n+    private PlanBuilder appendQuantifiedComparisonApplyNode(PlanBuilder subPlan, QuantifiedComparisonExpression quantifiedComparison, Node node)\n     {\n-        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n-\n-        // Plan one of the predicates from the cluster\n-        QuantifiedComparisonExpression quantifiedComparison = cluster.get(0);\n-\n-        ComparisonExpression.Operator operator = quantifiedComparison.getOperator();\n-        Quantifier quantifier = quantifiedComparison.getQuantifier();\n-        Expression value = quantifiedComparison.getValue();\n-        SubqueryExpression subquery = (SubqueryExpression) quantifiedComparison.getSubquery();\n-\n-        subPlan = handleSubqueries(subPlan, value, node);\n-\n-        Symbol output = symbolAllocator.newSymbol(quantifiedComparison, BOOLEAN);\n-\n-        switch (operator) {\n+        if (subPlan.canTranslate(quantifiedComparison)) {\n+            // given subquery is already appended\n+            return subPlan;\n+        }\n+        switch (quantifiedComparison.getOperator()) {\n             case EQUAL:\n-                switch (quantifier) {\n+                switch (quantifiedComparison.getQuantifier()) {\n                     case ALL:\n-                        subPlan = planQuantifiedComparison(subPlan, operator, quantifier, value, subquery, output);\n-                        return new PlanBuilder(\n-                                subPlan.getTranslations()\n-                                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(quantifiedComparison, analysis, subPlan.getScope()), output)),\n-                                subPlan.getRoot());\n+                        return planQuantifiedApplyNode(subPlan, quantifiedComparison);\n                     case ANY:\n                     case SOME:\n                         // A = ANY B <=> A IN B\n-                        subPlan = planInPredicate(subPlan, value, subquery, output, quantifiedComparison);\n-\n-                        return new PlanBuilder(\n-                                subPlan.getTranslations()\n-                                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n-                                subPlan.getRoot());\n+                        InPredicate inPredicate = new InPredicate(quantifiedComparison.getValue(), quantifiedComparison.getSubquery());\n+                        subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+                        subPlan.getTranslations().put(quantifiedComparison, subPlan.translate(inPredicate));\n+                        return subPlan;\n                 }\n                 break;\n \n             case NOT_EQUAL:\n-                switch (quantifier) {\n-                    case ALL: {\n-                        // A <> ALL B <=> !(A IN B)\n-                        subPlan = planInPredicate(subPlan, value, subquery, output, quantifiedComparison);\n-                        return addNegation(subPlan, cluster, output);\n-                    }\n+                switch (quantifiedComparison.getQuantifier()) {\n+                    case ALL:\n+                        // A <> ALL B <=> !(A IN B) <=> !(A = ANY B)\n+                        QuantifiedComparisonExpression rewrittenAny = new QuantifiedComparisonExpression(\n+                                EQUAL,\n+                                Quantifier.ANY,\n+                                quantifiedComparison.getValue(),\n+                                quantifiedComparison.getSubquery());\n+                        Expression notAny = new NotExpression(rewrittenAny);\n+                        // \"A <> ALL B\" is equivalent to \"NOT (A = ANY B)\" so add a rewrite for the initial quantifiedComparison to notAny\n+                        subPlan.getTranslations().put(quantifiedComparison, subPlan.getTranslations().rewrite(notAny));\n+                        // now plan \"A = ANY B\" part by calling ourselves for rewrittenAny\n+                        return appendQuantifiedComparisonApplyNode(subPlan, rewrittenAny, node);\n                     case ANY:\n-                    case SOME: {\n+                    case SOME:\n                         // A <> ANY B <=> min B <> max B || A <> min B <=> !(min B = max B && A = min B) <=> !(A = ALL B)\n+                        QuantifiedComparisonExpression rewrittenAll = new QuantifiedComparisonExpression(\n+                                EQUAL,\n+                                QuantifiedComparisonExpression.Quantifier.ALL,\n+                                quantifiedComparison.getValue(),\n+                                quantifiedComparison.getSubquery());\n+                        Expression notAll = new NotExpression(rewrittenAll);\n                         // \"A <> ANY B\" is equivalent to \"NOT (A = ALL B)\" so add a rewrite for the initial quantifiedComparison to notAll\n-                        subPlan = planQuantifiedComparison(subPlan, EQUAL, Quantifier.ALL, value, subquery, output);\n-                        return addNegation(subPlan, cluster, output);\n-                    }\n+                        subPlan.getTranslations().put(quantifiedComparison, subPlan.getTranslations().rewrite(notAll));\n+                        // now plan \"A = ALL B\" part by calling ourselves for rewrittenAll\n+                        return appendQuantifiedComparisonApplyNode(subPlan, rewrittenAll, node);\n                 }\n                 break;\n \n"}}, {"oid": "0021100712c13f47721667c40b13d9e41fa162a7", "url": "https://github.com/trinodb/trino/commit/0021100712c13f47721667c40b13d9e41fa162a7", "message": "Reuse scope when analyzing VALUEs expressions", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "edb4b8b12a01d4b5ecad3395b87bc92daa829902", "url": "https://github.com/trinodb/trino/commit/edb4b8b12a01d4b5ecad3395b87bc92daa829902", "message": "Revamp query planner\n\nNow there's a clean separation between expression in AST-land vs IR-land. Expressions\nare no longer rewritten over and over, which complicated maintaining that separation.\n\nTranslationMap is now responsible for Translating expressions from AST-land into IR-land by:\n* Inserting implicit coercions for intermediate expressions\n* Translating FunctionCalls to IR FunctionCalls (i.e., with information about the resolved function)\n* Rewriting sub-expressions based of a mapping of expressions in the current query scope that\n  have already been translated and the symbol from the tip of the current plan that contains their\n  value.\n* Tracking how fields in the current local scope (the FROM, SELECT, etc scopes) map to symbols\n  in the tip of the current plan.\n\nPreviously, the planning of subqueries went through these steps:\n* Plan the subquery. If any references originate from the outer scope, TranslationMap\n  leaves the Identifiers or references untouched. As a result, the temporary\n  subquery plan contains nodes from AST-land.\n* Collect any Identifiers from the temporary subplan and attemt to translate them against the\n  current scope. Any identifiers that are not local to the current scope are left untouched. Since\n  this also implies the current scope is with a subquery, the process repeats as the recursion\n  unwinds.\n* Stitch in the subplan via an Apply or CorrelatedJoin node.\n\nOne of the problems with this approach is that the intermediate temporary plans are invalid, as they\ncontain AST-land expressions. In the new implementation the TranslationMaps form a hierarchy mimicking\nquery scopes. Whenever an identifier cannot be resolved from a local scope, TranslationMap delegates to\nits parent.\n\nMany of the operation are now based on comparing expresions with awareness of what scopes identifiers\nbind to. Two expressions expressions that come from the same query scope are considered equal if all\ntheir references to columns in the query scope are the same.\n\nAs an example, in the following query:\n\n    SELECT f(k) as k\n    FROM (VALUES 1) t(k)\n    ORDER BY k\n\neven though the \"k\" in \"f(k)\" is syntactically equal to the \"k\"\nin the ORDER BY clause, they reference different fields. The former\ncomes from the scope associated with the FROM clause, while the\nlatter comes from the scope associated with the SELECT clause.", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "1676ddc4600dd6e29b8b431e66fca551959dc2bf", "url": "https://github.com/trinodb/trino/commit/1676ddc4600dd6e29b8b431e66fca551959dc2bf", "message": "Simplify argument and field name\n\nlambdaDeclarationToSymbolMap is too verbose and doesn't provide any\nadditional information that the type of the variable doesn't convey.", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "02947c40f0a965c4d380b414c4a1450bdf42548a", "url": "https://github.com/trinodb/trino/commit/02947c40f0a965c4d380b414c4a1450bdf42548a", "message": "Simplify expression", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "b6ce459fa25e55290588c3472c258361fe0cc96c", "url": "https://github.com/trinodb/trino/commit/b6ce459fa25e55290588c3472c258361fe0cc96c", "message": "Improve formatting", "committedDate": "2020-07-08T16:49:26Z", "type": "commit"}, {"oid": "b6ce459fa25e55290588c3472c258361fe0cc96c", "url": "https://github.com/trinodb/trino/commit/b6ce459fa25e55290588c3472c258361fe0cc96c", "message": "Improve formatting", "committedDate": "2020-07-08T16:49:26Z", "type": "forcePushed"}]}