{"pr_number": 3350, "pr_title": "Cleanup in PushProjectionThroughExchange rule", "pr_createdAt": "2020-04-06T06:22:44Z", "pr_url": "https://github.com/trinodb/trino/pull/3350", "timeline": [{"oid": "3fb03bff84c3ae3bcee07f09c327d83e600b12c5", "url": "https://github.com/trinodb/trino/commit/3fb03bff84c3ae3bcee07f09c327d83e600b12c5", "message": "Minor refactor in PushProjectionThroughExchange rule", "committedDate": "2020-04-05T13:14:59Z", "type": "commit"}, {"oid": "1483f78495dbb7f4621385b29da060878a5b9187", "url": "https://github.com/trinodb/trino/commit/1483f78495dbb7f4621385b29da060878a5b9187", "message": "Fix comments", "committedDate": "2020-04-05T14:42:45Z", "type": "commit"}, {"oid": "9a5da8a2ebe04d72a12240f464318c749ae1d7f3", "url": "https://github.com/trinodb/trino/commit/9a5da8a2ebe04d72a12240f464318c749ae1d7f3", "message": "Use source's symbol for projection instead of output symbol\n\nIn PushProjectionThroughExchange rule, there is a projection\ninserted into the plan between ExchangeNode and each of it's\nsources. The projection is supposed to retain source's hash symbol.\nBefore this change, there was added an identity assignment\non hash symbol from ExchangeNode's output. It was wrong in the\ncase when source used other symbol (with different name) than the\nExchangeNode.\nIt was fixed by using the source's symbol instead.", "committedDate": "2020-04-05T16:29:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg5NjM5Mw==", "url": "https://github.com/trinodb/trino/pull/3350#discussion_r406896393", "bodyText": "This is more functional and idiomatic:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ImmutableMap.Builder<Symbol, Expression> translationMap = ImmutableMap.builder();\n          \n          \n            \n                            outputToInputMap.forEach((key, value) -> translationMap.put(key, value.toSymbolReference()));\n          \n          \n            \n                            Expression translatedExpression = inlineSymbols(translationMap.build(), projection.getValue());\n          \n          \n            \n                            Map<Symbol, SymbolReference> translationMap = outputToInputMap.entrySet().stream()\n          \n          \n            \n                                    .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().toSymbolReference()));", "author": "martint", "createdAt": "2020-04-10T18:57:47Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushProjectionThroughExchange.java", "diffHunk": "@@ -113,15 +112,16 @@ public Result apply(ProjectNode project, Captures captures, Context context)\n                         // do not project the same symbol twice as ExchangeNode verifies that source input symbols match partitioning scheme outputLayout\n                         .filter(symbol -> !partitioningColumns.contains(symbol))\n                         .map(outputToInputMap::get)\n-                        .forEach(nameReference -> {\n-                            Symbol symbol = Symbol.from(nameReference);\n-                            projections.put(symbol, nameReference);\n-                            inputs.add(symbol);\n+                        .forEach(inputSymbol -> {\n+                            projections.put(inputSymbol, inputSymbol.toSymbolReference());\n+                            inputs.add(inputSymbol);\n                         });\n             }\n \n             for (Map.Entry<Symbol, Expression> projection : project.getAssignments().entrySet()) {\n-                Expression translatedExpression = inlineSymbols(outputToInputMap, projection.getValue());\n+                ImmutableMap.Builder<Symbol, Expression> translationMap = ImmutableMap.builder();\n+                outputToInputMap.forEach((key, value) -> translationMap.put(key, value.toSymbolReference()));\n+                Expression translatedExpression = inlineSymbols(translationMap.build(), projection.getValue());", "originalCommit": "3fb03bff84c3ae3bcee07f09c327d83e600b12c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e0483cf4842e1410d0843a102ded0a4d721269bf", "chunk": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushProjectionThroughExchange.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushProjectionThroughExchange.java\nindex 2a958976a5..d2b240c583 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushProjectionThroughExchange.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushProjectionThroughExchange.java\n\n@@ -100,16 +101,18 @@ public class PushProjectionThroughExchange\n                         inputs.add(inputSymbol);\n                     });\n \n-            if (exchange.getPartitioningScheme().getHashColumn().isPresent()) {\n-                // Need to retain the hash symbol for the exchange\n-                projections.put(exchange.getPartitioningScheme().getHashColumn().get(), exchange.getPartitioningScheme().getHashColumn().get().toSymbolReference());\n-                inputs.add(exchange.getPartitioningScheme().getHashColumn().get());\n-            }\n+            // Need to retain the hash symbol for the exchange\n+            exchange.getPartitioningScheme().getHashColumn()\n+                    .map(outputToInputMap::get)\n+                    .ifPresent(inputSymbol -> {\n+                        projections.put(inputSymbol, inputSymbol.toSymbolReference());\n+                        inputs.add(inputSymbol);\n+                    });\n \n             if (exchange.getOrderingScheme().isPresent()) {\n-                // need to retain ordering columns for the exchange\n+                // Need to retain ordering columns for the exchange\n                 exchange.getOrderingScheme().get().getOrderBy().stream()\n-                        // do not project the same symbol twice as ExchangeNode verifies that source input symbols match partitioning scheme outputLayout\n+                        // Do not duplicate symbols in inputs list\n                         .filter(symbol -> !partitioningColumns.contains(symbol))\n                         .map(outputToInputMap::get)\n                         .forEach(inputSymbol -> {\n"}}, {"oid": "e0483cf4842e1410d0843a102ded0a4d721269bf", "url": "https://github.com/trinodb/trino/commit/e0483cf4842e1410d0843a102ded0a4d721269bf", "message": "Fix duplicate symbols in Exchange outputs\n\nIn PushProjectionThroughExchange rule, when the pushed-down\nProjection has an identity assignment on a symbol which is used\nfor partitioning, ordering or as a hash symbol by the Exchange,\nthe symbol is added to Exchange's outputs twice:\n- once as a symbol required by Exchange\n- once as required by the parent Projection\nThis is fixed by skipping the other occurrence", "committedDate": "2020-04-14T13:44:40Z", "type": "commit"}, {"oid": "e0483cf4842e1410d0843a102ded0a4d721269bf", "url": "https://github.com/trinodb/trino/commit/e0483cf4842e1410d0843a102ded0a4d721269bf", "message": "Fix duplicate symbols in Exchange outputs\n\nIn PushProjectionThroughExchange rule, when the pushed-down\nProjection has an identity assignment on a symbol which is used\nfor partitioning, ordering or as a hash symbol by the Exchange,\nthe symbol is added to Exchange's outputs twice:\n- once as a symbol required by Exchange\n- once as required by the parent Projection\nThis is fixed by skipping the other occurrence", "committedDate": "2020-04-14T13:44:40Z", "type": "forcePushed"}]}