{"pr_number": 37, "pr_title": "Interceptor refactoring", "pr_createdAt": "2020-03-21T21:37:51Z", "pr_url": "https://github.com/temporalio/sdk-java/pull/37", "timeline": [{"oid": "073ba35b2d562d37dd6d0944a03f919311b64562", "url": "https://github.com/temporalio/sdk-java/commit/073ba35b2d562d37dd6d0944a03f919311b64562", "message": "Introduced WorkflowInterceptorFactory", "committedDate": "2020-03-20T19:37:27Z", "type": "commit"}, {"oid": "3b8c6624de13517b54d9d41c4cfee809e585e8d5", "url": "https://github.com/temporalio/sdk-java/commit/3b8c6624de13517b54d9d41c4cfee809e585e8d5", "message": "Renamed workflow interceptors", "committedDate": "2020-03-21T02:52:49Z", "type": "commit"}, {"oid": "c4216498df98c03f8277c547c6eb216f4df7742b", "url": "https://github.com/temporalio/sdk-java/commit/c4216498df98c03f8277c547c6eb216f4df7742b", "message": "before refactoring threading", "committedDate": "2020-03-21T17:33:09Z", "type": "commit"}, {"oid": "74ba9f91ae677095ea900f0628f6122e998a901c", "url": "https://github.com/temporalio/sdk-java/commit/74ba9f91ae677095ea900f0628f6122e998a901c", "message": "Refactored DeterministicRunner to support priorities", "committedDate": "2020-03-21T20:50:36Z", "type": "commit"}, {"oid": "52116f56ce0c3e6a37827e80e6f3f0a47e078e6a", "url": "https://github.com/temporalio/sdk-java/commit/52116f56ce0c3e6a37827e80e6f3f0a47e078e6a", "message": "Cleanup", "committedDate": "2020-03-21T21:35:35Z", "type": "commit"}, {"oid": "992828a3f28b4d80b4de2f09600dff187b5fcec8", "url": "https://github.com/temporalio/sdk-java/commit/992828a3f28b4d80b4de2f09600dff187b5fcec8", "message": "Merge branch 'master' of github.com:temporalio/temporal-java-sdk into interceptor_threading", "committedDate": "2020-03-21T21:44:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExNDc3Mw==", "url": "https://github.com/temporalio/sdk-java/pull/37#discussion_r396114773", "bodyText": "All workflow threads will have the same priority?  Will that be a problem or co-operative multiple threading is good enough to guarantee determinism?", "author": "samarabbas", "createdAt": "2020-03-22T16:42:49Z", "path": "src/main/java/io/temporal/internal/sync/DeterministicRunnerImpl.java", "diffHunk": "@@ -71,6 +71,10 @@\n /** Throws Error in case of any unexpected condition. It is to fail a decision, not a workflow. */\n class DeterministicRunnerImpl implements DeterministicRunner {\n \n+  private static final int ROOT_THREAD_PRIORITY = 0;\n+  private static final int CALLBACK_THREAD_PRIORITY = 10;\n+  private static final int WORKFLOW_THREAD_PRIORITY = 20000000;", "originalCommit": "992828a3f28b4d80b4de2f09600dff187b5fcec8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMDAyMg==", "url": "https://github.com/temporalio/sdk-java/pull/37#discussion_r396120022", "bodyText": "These priorities are not Java thread priorities. They define the order of cooperative scheduling to ensure that signals are processed before the main method. And for the root thread we need it to ensure that it runs before the first signal is delivered in case of signalWithStart.", "author": "mfateev", "createdAt": "2020-03-22T17:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExNDc3Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExNjY0NQ==", "url": "https://github.com/temporalio/sdk-java/pull/37#discussion_r396116645", "bodyText": "I'm confused on why newInstance is created for both processSignal and execute calls.  Is it expected that only one of them will ever be called?", "author": "samarabbas", "createdAt": "2020-03-22T17:01:02Z", "path": "src/main/java/io/temporal/internal/sync/POJOWorkflowImplementationFactory.java", "diffHunk": "@@ -318,24 +296,76 @@ public void processSignal(String signalName, byte[] input, long eventId) {\n                 + signalHandlers.keySet());\n         return;\n       }\n-\n       try {\n         Object[] args = dataConverter.fromDataArray(input, signalMethod.getGenericParameterTypes());\n-        newInstance();\n-        signalMethod.invoke(workflow, args);\n-      } catch (IllegalAccessException e) {\n-        throw new Error(\"Failure processing \\\"\" + signalName + \"\\\" at eventID \" + eventId, e);\n+        Preconditions.checkNotNull(workflowInvoker, \"initialize not called\");\n+        workflowInvoker.processSignal(signalName, args, eventId);\n       } catch (DataConverterException e) {\n         logSerializationException(signalName, eventId, e);\n-      } catch (InvocationTargetException e) {\n-        Throwable targetException = e.getTargetException();\n-        if (targetException instanceof DataConverterException) {\n-          logSerializationException(signalName, eventId, (DataConverterException) targetException);\n-        } else if (targetException instanceof Error) {\n-          throw (Error) targetException;\n-        } else {\n-          throw new Error(\n-              \"Failure processing \\\"\" + signalName + \"\\\" at eventID \" + eventId, targetException);\n+      }\n+    }\n+\n+    private class RootWorkflowInvocationInterceptor implements WorkflowInvocationInterceptor {\n+\n+      @Override\n+      public Object execute(Object[] arguments) {\n+        WorkflowInfo context = Workflow.getWorkflowInfo();\n+        newInstance();\n+        WorkflowInternal.registerQuery(workflow);\n+        try {\n+          return workflowMethod.invoke(workflow, arguments);\n+        } catch (IllegalAccessException e) {\n+          throw new Error(mapToWorkflowExecutionException(e, dataConverter));\n+        } catch (InvocationTargetException e) {\n+          Throwable targetException = e.getTargetException();\n+          if (targetException instanceof Error) {\n+            throw (Error) targetException;\n+          }\n+          // Cancellation should be delivered as it impacts which decision closes a\n+          // workflow.\n+          if (targetException instanceof CancellationException) {\n+            throw (CancellationException) targetException;\n+          }\n+          if (log.isErrorEnabled()) {\n+            log.error(\n+                \"Workflow execution failure \"\n+                    + \"WorkflowID=\"\n+                    + context.getWorkflowId()\n+                    + \", RunID=\"\n+                    + context.getRunId()\n+                    + \", WorkflowType=\"\n+                    + context.getWorkflowType(),\n+                targetException);\n+          }\n+          // Cast to Exception is safe as Error is handled above.\n+          throw mapToWorkflowExecutionException((Exception) targetException, dataConverter);\n+        }\n+      }\n+\n+      @Override\n+      public void init(WorkflowCallsInterceptor interceptor) {\n+        WorkflowInternal.getRootDecisionContext().setHeadInterceptor(interceptor);\n+      }\n+\n+      @Override\n+      public void processSignal(String signalName, Object[] arguments, long eventId) {\n+        Method signalMethod = signalHandlers.get(signalName);\n+        try {\n+          newInstance();", "originalCommit": "992828a3f28b4d80b4de2f09600dff187b5fcec8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMDU3Nw==", "url": "https://github.com/temporalio/sdk-java/pull/37#discussion_r396120577", "bodyText": "It is a noop if the instance is already created. But you are right that after my latest changes it belongs in init call.", "author": "mfateev", "createdAt": "2020-03-22T17:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExNjY0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6e00f126721364169f16c6a2bcae8083fb9914b4", "chunk": "diff --git a/src/main/java/io/temporal/internal/sync/POJOWorkflowImplementationFactory.java b/src/main/java/io/temporal/internal/sync/POJOWorkflowImplementationFactory.java\nindex 6156916d..703ced83 100644\n--- a/src/main/java/io/temporal/internal/sync/POJOWorkflowImplementationFactory.java\n+++ b/src/main/java/io/temporal/internal/sync/POJOWorkflowImplementationFactory.java\n\n@@ -310,7 +310,6 @@ final class POJOWorkflowImplementationFactory implements ReplayWorkflowFactory {\n       @Override\n       public Object execute(Object[] arguments) {\n         WorkflowInfo context = Workflow.getWorkflowInfo();\n-        newInstance();\n         WorkflowInternal.registerQuery(workflow);\n         try {\n           return workflowMethod.invoke(workflow, arguments);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExNzg2MQ==", "url": "https://github.com/temporalio/sdk-java/pull/37#discussion_r396117861", "bodyText": "Is that only going to be used by root context?  Why signal is missing here?", "author": "samarabbas", "createdAt": "2020-03-22T17:12:28Z", "path": "src/main/java/io/temporal/workflow/WorkflowInterceptor.java", "diffHunk": "@@ -19,89 +19,12 @@\n \n package io.temporal.workflow;\n \n-import io.temporal.activity.ActivityOptions;\n-import io.temporal.activity.LocalActivityOptions;\n-import io.temporal.proto.common.WorkflowExecution;\n-import io.temporal.workflow.Functions.Func;\n-import java.lang.reflect.Type;\n-import java.time.Duration;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Random;\n-import java.util.UUID;\n-import java.util.function.BiPredicate;\n-import java.util.function.Supplier;\n-\n+/**\n+ * Intercepts workflow execution.\n+ *\n+ * <p>TODO(maxim): JavaDoc with sample\n+ */\n public interface WorkflowInterceptor {\n-\n-  final class WorkflowResult<R> {\n-\n-    private final Promise<R> result;\n-    private final Promise<WorkflowExecution> workflowExecution;\n-\n-    public WorkflowResult(Promise<R> result, Promise<WorkflowExecution> workflowExecution) {\n-      this.result = result;\n-      this.workflowExecution = workflowExecution;\n-    }\n-\n-    public Promise<R> getResult() {\n-      return result;\n-    }\n-\n-    public Promise<WorkflowExecution> getWorkflowExecution() {\n-      return workflowExecution;\n-    }\n-  }\n-\n-  <R> Promise<R> executeActivity(\n-      String activityName,\n-      Class<R> resultClass,\n-      Type resultType,\n-      Object[] args,\n-      ActivityOptions options);\n-\n-  <R> Promise<R> executeLocalActivity(\n-      String activityName,\n-      Class<R> resultClass,\n-      Type resultType,\n-      Object[] args,\n-      LocalActivityOptions options);\n-\n-  <R> WorkflowResult<R> executeChildWorkflow(\n-      String workflowType,\n-      Class<R> resultClass,\n-      Type resultType,\n-      Object[] args,\n-      ChildWorkflowOptions options);\n-\n-  Random newRandom();\n-\n-  Promise<Void> signalExternalWorkflow(\n-      WorkflowExecution execution, String signalName, Object[] args);\n-\n-  Promise<Void> cancelWorkflow(WorkflowExecution execution);\n-\n-  void sleep(Duration duration);\n-\n-  boolean await(Duration timeout, String reason, Supplier<Boolean> unblockCondition);\n-\n-  void await(String reason, Supplier<Boolean> unblockCondition);\n-\n-  Promise<Void> newTimer(Duration duration);\n-\n-  <R> R sideEffect(Class<R> resultClass, Type resultType, Func<R> func);\n-\n-  <R> R mutableSideEffect(\n-      String id, Class<R> resultClass, Type resultType, BiPredicate<R, R> updated, Func<R> func);\n-\n-  int getVersion(String changeID, int minSupported, int maxSupported);\n-\n-  void continueAsNew(\n-      Optional<String> workflowType, Optional<ContinueAsNewOptions> options, Object[] args);\n-\n-  void registerQuery(String queryType, Type[] argTypes, Functions.Func1<Object[], Object> callback);\n-\n-  UUID randomUUID();\n-\n-  void upsertSearchAttributes(Map<String, Object> searchAttributes);\n+  WorkflowInvoker interceptExecuteWorkflow(", "originalCommit": "992828a3f28b4d80b4de2f09600dff187b5fcec8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMDc5Ng==", "url": "https://github.com/temporalio/sdk-java/pull/37#discussion_r396120796", "bodyText": "WorkflowInterceptor.interceptExecuteWorkflow returns WorkflowInvoker which has:\n\ninit() called when workflow class is instantiated\nexecute() called when main workflow method is executed\nprocessSignal() called for each signal.", "author": "mfateev", "createdAt": "2020-03-22T17:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExNzg2MQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "6e00f126721364169f16c6a2bcae8083fb9914b4", "url": "https://github.com/temporalio/sdk-java/commit/6e00f126721364169f16c6a2bcae8083fb9914b4", "message": "Moved instance creation to init where it belongs", "committedDate": "2020-03-22T17:38:26Z", "type": "commit"}, {"oid": "e809b0574c326fea0dcd62e9bacbc86b9325f815", "url": "https://github.com/temporalio/sdk-java/commit/e809b0574c326fea0dcd62e9bacbc86b9325f815", "message": "Refactored null check as duplicated calls are not possible anymore", "committedDate": "2020-03-22T17:51:16Z", "type": "commit"}, {"oid": "dc4f5a897bec94c60fe7af4168d2048282d4761d", "url": "https://github.com/temporalio/sdk-java/commit/dc4f5a897bec94c60fe7af4168d2048282d4761d", "message": "Disabled broken docker based tests", "committedDate": "2020-03-22T18:20:22Z", "type": "commit"}]}