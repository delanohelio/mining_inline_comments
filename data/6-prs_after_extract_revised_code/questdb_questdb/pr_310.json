{"pr_number": 310, "pr_title": "fix(griffin) - asof join error unless timestamp is selected #307", "pr_createdAt": "2020-05-20T12:41:34Z", "pr_url": "https://github.com/questdb/questdb/pull/310", "timeline": [{"oid": "b826ce5fc1841c50c4880b26f81dd3732bc02f07", "url": "https://github.com/questdb/questdb/commit/b826ce5fc1841c50c4880b26f81dd3732bc02f07", "message": "fix(griffin) - asof join error unless timestamp is selected #307", "committedDate": "2020-05-20T12:40:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk4MzUwNg==", "url": "https://github.com/questdb/questdb/pull/310#discussion_r427983506", "bodyText": "could we please cache branch outcome in boolean flag and then \"pop\" in \"finally\" block.", "author": "bluestreak01", "createdAt": "2020-05-20T12:52:34Z", "path": "core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java", "diffHunk": "@@ -1607,6 +1607,10 @@ private RecordCursorFactory generateTableQuery(\n                 throw e;\n             }\n \n+            if (model.getJoinType() == QueryModel.JOIN_ASOF || model.getJoinType() == QueryModel.JOIN_CROSS) {", "originalCommit": "b826ce5fc1841c50c4880b26f81dd3732bc02f07", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "103896a281ddc0c8e4d6fca82fabe699625efadc", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java b/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\nindex 250b566f9..e64742c81 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\n\n@@ -1607,57 +1607,61 @@ public class SqlCodeGenerator implements Mutable {\n                 throw e;\n             }\n \n-            if (model.getJoinType() == QueryModel.JOIN_ASOF || model.getJoinType() == QueryModel.JOIN_CROSS) {\n-                executionContext.pushTimestampRequiredFlag(true);\n-            }\n-\n+            boolean requiresTimestamp = model.getJoinType() == QueryModel.JOIN_ASOF || model.getJoinType() == QueryModel.JOIN_CROSS;\n             final GenericRecordMetadata myMeta = new GenericRecordMetadata();\n             boolean framingSupported;\n-            if (topDownColumnCount > 0) {\n-                framingSupported = true;\n-                for (int i = 0; i < topDownColumnCount; i++) {\n-                    int columnIndex = readerMeta.getColumnIndexQuiet(topDownColumns.getQuick(i).getName());\n-                    int type = readerMeta.getColumnType(columnIndex);\n-                    int typeSize = ColumnType.sizeOf(type);\n-\n-                    if (framingSupported && (typeSize < Byte.BYTES || typeSize > Double.BYTES)) {\n-                        // we don't frame non-primitive types yet\n-                        framingSupported = false;\n+            try {\n+                if (requiresTimestamp) {\n+                    executionContext.pushTimestampRequiredFlag(true);\n+                }\n+\n+                if (topDownColumnCount > 0) {\n+                    framingSupported = true;\n+                    for (int i = 0; i < topDownColumnCount; i++) {\n+                        int columnIndex = readerMeta.getColumnIndexQuiet(topDownColumns.getQuick(i).getName());\n+                        int type = readerMeta.getColumnType(columnIndex);\n+                        int typeSize = ColumnType.sizeOf(type);\n+\n+                        if (framingSupported && (typeSize < Byte.BYTES || typeSize > Double.BYTES)) {\n+                            // we don't frame non-primitive types yet\n+                            framingSupported = false;\n+                        }\n+                        columnIndexes.add(columnIndex);\n+                        columnSizes.add((Numbers.msb(typeSize)));\n+\n+                        myMeta.add(new TableColumnMetadata(\n+                                Chars.toString(topDownColumns.getQuick(i).getName()),\n+                                type,\n+                                readerMeta.isColumnIndexed(columnIndex),\n+                                readerMeta.getIndexValueBlockCapacity(columnIndex),\n+                                readerMeta.isSymbolTableStatic(columnIndex)\n+                        ));\n+\n+                        if (columnIndex == readerTimestampIndex) {\n+                            myMeta.setTimestampIndex(myMeta.getColumnCount() - 1);\n+                        }\n                     }\n-                    columnIndexes.add(columnIndex);\n-                    columnSizes.add((Numbers.msb(typeSize)));\n-\n-                    myMeta.add(new TableColumnMetadata(\n-                            Chars.toString(topDownColumns.getQuick(i).getName()),\n-                            type,\n-                            readerMeta.isColumnIndexed(columnIndex),\n-                            readerMeta.getIndexValueBlockCapacity(columnIndex),\n-                            readerMeta.isSymbolTableStatic(columnIndex)\n-                    ));\n-\n-                    if (columnIndex == readerTimestampIndex) {\n+\n+                    // select timestamp when it is required but not already selected\n+                    if (readerTimestampIndex != -1 && myMeta.getTimestampIndex() == -1 && executionContext.isTimestampRequired()) {\n+                        myMeta.add(new TableColumnMetadata(\n+                                readerMeta.getColumnName(readerTimestampIndex),\n+                                readerMeta.getColumnType(readerTimestampIndex)\n+                        ));\n                         myMeta.setTimestampIndex(myMeta.getColumnCount() - 1);\n+\n+                        columnIndexes.add(readerTimestampIndex);\n+                        columnSizes.add((Numbers.msb(ColumnType.TIMESTAMP)));\n                     }\n+                } else {\n+                    framingSupported = false;\n                 }\n-\n-                // select timestamp when it is required but not already selected\n-                if (readerTimestampIndex != -1 && myMeta.getTimestampIndex() == -1 && executionContext.isTimestampRequired()) {\n-                    myMeta.add(new TableColumnMetadata(\n-                            readerMeta.getColumnName(readerTimestampIndex),\n-                            readerMeta.getColumnType(readerTimestampIndex)\n-                    ));\n-                    myMeta.setTimestampIndex(myMeta.getColumnCount() - 1);\n-\n-                    columnIndexes.add(readerTimestampIndex);\n-                    columnSizes.add((Numbers.msb(ColumnType.TIMESTAMP)));\n+            } finally {\n+                if (requiresTimestamp) {\n+                    executionContext.popTimestampRequiredFlag();\n                 }\n-            } else {\n-                framingSupported = false;\n             }\n \n-            if (model.getJoinType() == QueryModel.JOIN_ASOF || model.getJoinType() == QueryModel.JOIN_CROSS) {\n-                executionContext.popTimestampRequiredFlag();\n-            }\n \n             // done with myMeta\n \n"}}, {"oid": "103896a281ddc0c8e4d6fca82fabe699625efadc", "url": "https://github.com/questdb/questdb/commit/103896a281ddc0c8e4d6fca82fabe699625efadc", "message": "fix(griffin) - asof join error unless timestamp is selected #307", "committedDate": "2020-05-20T14:33:57Z", "type": "commit"}]}