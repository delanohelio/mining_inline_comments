{"pr_number": 308, "pr_title": "chore: questdb can be configured to limit the number of in memory rows", "pr_createdAt": "2020-05-19T21:44:58Z", "pr_url": "https://github.com/questdb/questdb/pull/308", "timeline": [{"oid": "1132ce653437690e6b9348f7d9508f13c46e88d8", "url": "https://github.com/questdb/questdb/commit/1132ce653437690e6b9348f7d9508f13c46e88d8", "message": "chore: questdb can be configured to limit the number of in memory rows", "committedDate": "2020-05-19T21:42:33Z", "type": "commit"}, {"oid": "1bc9341c23870b6d6a2b8a546831e475bb3940a9", "url": "https://github.com/questdb/questdb/commit/1bc9341c23870b6d6a2b8a546831e475bb3940a9", "message": "chore: Allow queries that fail for certain exceptions (security) to be cached", "committedDate": "2020-05-20T08:48:32Z", "type": "commit"}, {"oid": "a3e74c41f8f325316b8283662103c837857f49d4", "url": "https://github.com/questdb/questdb/commit/a3e74c41f8f325316b8283662103c837857f49d4", "message": "chore: Allow queries that fail for certain exceptions (security) to be cached", "committedDate": "2020-05-20T10:36:40Z", "type": "commit"}, {"oid": "2670ca1dbe3d02c94707708e4bdf5ad29e0dc286", "url": "https://github.com/questdb/questdb/commit/2670ca1dbe3d02c94707708e4bdf5ad29e0dc286", "message": "chore: questdb can be configured to limit the number of in memory rows", "committedDate": "2020-05-20T13:30:45Z", "type": "commit"}, {"oid": "e46df08a3c5c847e3b5ef542515256f33d7528c3", "url": "https://github.com/questdb/questdb/commit/e46df08a3c5c847e3b5ef542515256f33d7528c3", "message": "chore: Allow queries that fail for certain exceptions (security) to be cached", "committedDate": "2020-05-20T15:47:49Z", "type": "commit"}, {"oid": "f0f4d919fd7691c62cf119c330df048fdba6caff", "url": "https://github.com/questdb/questdb/commit/f0f4d919fd7691c62cf119c330df048fdba6caff", "message": "chore: questdb can be configured to limit the number of in memory rows", "committedDate": "2020-05-20T16:07:45Z", "type": "commit"}, {"oid": "b3dce73c5599ea46c177023eded6378f03037e6d", "url": "https://github.com/questdb/questdb/commit/b3dce73c5599ea46c177023eded6378f03037e6d", "message": "chore: questdb can be configured to limit the number of in memory rows", "committedDate": "2020-05-20T16:45:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NzIyOQ==", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428277229", "bodyText": "This is what we were talking about this morning. 99% of the flow goes over mispredicted branch.\nhttps://dzone.com/articles/branch-prediction-in-java\nAdditionally, I would suggest that \"max\" value is set to Long.MAX_VALUE. With this choice of \"allow all\" value branching will look like:\nfinal long cursorSize = baseCursor.size();\nif (cursorSize < maxInMemoryRows) {\n// do the good stuff\n} else {\n      throw ....\n}", "author": "bluestreak01", "createdAt": "2020-05-20T20:06:48Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNoneRecordCursorFactory.java", "diffHunk": "@@ -112,7 +113,13 @@ public boolean recordCursorSupportsRandomAccess() {\n     }\n \n     @NotNull\n-    protected RecordCursor initFunctionsAndCursor(SqlExecutionContext executionContext, RecordCursor baseCursor) {\n+    private RecordCursor initFunctionsAndCursor(SqlExecutionContext executionContext, RecordCursor baseCursor) {\n+        long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+        if (maxInMemoryRows >= 0 && baseCursor.size() >= 0 && baseCursor.size() > maxInMemoryRows) {", "originalCommit": "b3dce73c5599ea46c177023eded6378f03037e6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3ODg1MA==", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428278850", "bodyText": "we have more naughty places that trigger branch issues, but we should stop their proliferation", "author": "bluestreak01", "createdAt": "2020-05-20T20:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NzIyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "45b63cc11c880f8969f6052bff045a41c24a6857", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNoneRecordCursorFactory.java b/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNoneRecordCursorFactory.java\nindex 3152b00bd..e6bb47cdc 100644\n--- a/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNoneRecordCursorFactory.java\n+++ b/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNoneRecordCursorFactory.java\n\n@@ -115,16 +125,17 @@ public class SampleByFillNoneRecordCursorFactory implements RecordCursorFactory\n     @NotNull\n     private RecordCursor initFunctionsAndCursor(SqlExecutionContext executionContext, RecordCursor baseCursor) {\n         long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n-        if (maxInMemoryRows >= 0 && baseCursor.size() >= 0 && baseCursor.size() > maxInMemoryRows) {\n+        if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {\n+            map.setMaxSize(maxInMemoryRows);\n+            cursor.of(baseCursor);\n+            // init all record function for this cursor, in case functions require metadata and/or symbol tables\n+            for (int i = 0, m = recordFunctions.size(); i < m; i++) {\n+                recordFunctions.getQuick(i).init(cursor, executionContext);\n+            }\n+            return cursor;\n+        } else {\n             baseCursor.close();\n             throw LimitOverflowException.instance(maxInMemoryRows);\n         }\n-        map.setMaxSize(maxInMemoryRows);\n-        cursor.of(baseCursor);\n-        // init all record function for this cursor, in case functions require metadata and/or symbol tables\n-        for (int i = 0, m = recordFunctions.size(); i < m; i++) {\n-            recordFunctions.getQuick(i).init(cursor, executionContext);\n-        }\n-        return cursor;\n     }\n }\n"}}, {"oid": "45b63cc11c880f8969f6052bff045a41c24a6857", "url": "https://github.com/questdb/questdb/commit/45b63cc11c880f8969f6052bff045a41c24a6857", "message": "chore: questdb can be configured to limit the number of in memory rows", "committedDate": "2020-05-20T21:35:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMzM0OA==", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428323348", "bodyText": "|| baseCursor.size() < 0\nis not necessary :)", "author": "bluestreak01", "createdAt": "2020-05-20T21:40:26Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNullRecordCursorFactory.java", "diffHunk": "@@ -135,43 +158,54 @@ public void close() {\n     @Override\n     public RecordCursor getCursor(SqlExecutionContext executionContext) {\n         final RecordCursor baseCursor = base.getCursor(executionContext);\n-        map.clear();\n-\n-        // This factory fills gaps in data. To do that we\n-        // have to know all possible key values. Essentially, every time\n-        // we sample we return same set of key values with different\n-        // aggregation results and timestamp\n-\n-        int n = groupByFunctions.size();\n-        final Record baseCursorRecord = baseCursor.getRecord();\n-        while (baseCursor.hasNext()) {\n-            MapKey key = map.withKey();\n-            mapSink.copy(baseCursorRecord, key);\n-            MapValue value = key.createValue();\n-            if (value.isNew()) {\n-                // timestamp is always stored in value field 0\n-                value.putLong(0, Numbers.LONG_NaN);\n-                // have functions reset their columns to \"zero\" state\n-                // this would set values for when keys are not found right away\n-                for (int i = 0; i < n; i++) {\n-                    groupByFunctions.getQuick(i).setNull(value);\n+        try {\n+            map.clear();\n+            long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {", "originalCommit": "45b63cc11c880f8969f6052bff045a41c24a6857", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "900655ddb51fbc48f854958fb0ee8125c01f5cdf", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNullRecordCursorFactory.java b/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNullRecordCursorFactory.java\nindex d3e0b342b..d0f18a0e8 100644\n--- a/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNullRecordCursorFactory.java\n+++ b/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNullRecordCursorFactory.java\n\n@@ -161,7 +161,7 @@ public class SampleByFillNullRecordCursorFactory implements RecordCursorFactory\n         try {\n             map.clear();\n             long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n-            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {\n+            if (maxInMemoryRows > baseCursor.size()) {\n                 map.setMaxSize(maxInMemoryRows);\n \n                 // This factory fills gaps in data. To do that we\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMzc2OA==", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428323768", "bodyText": "same", "author": "bluestreak01", "createdAt": "2020-05-20T21:41:21Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java", "diffHunk": "@@ -154,43 +178,54 @@ public void close() {\n     @Override\n     public RecordCursor getCursor(SqlExecutionContext executionContext) {\n         final RecordCursor baseCursor = base.getCursor(executionContext);\n-        map.clear();\n-\n-        // This factory fills gaps in data. To do that we\n-        // have to know all possible key values. Essentially, every time\n-        // we sample we return same set of key values with different\n-        // aggregation results and timestamp\n-\n-        int n = groupByFunctions.size();\n-        final Record baseCursorRecord = baseCursor.getRecord();\n-        while (baseCursor.hasNext()) {\n-            MapKey key = map.withKey();\n-            mapSink.copy(baseCursorRecord, key);\n-            MapValue value = key.createValue();\n-            if (value.isNew()) {\n-                // timestamp is always stored in value field 0\n-                value.putLong(0, Numbers.LONG_NaN);\n-                // have functions reset their columns to \"zero\" state\n-                // this would set values for when keys are not found right away\n-                for (int i = 0; i < n; i++) {\n-                    groupByFunctions.getQuick(i).setNull(value);\n+        try {\n+            map.clear();\n+            long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {", "originalCommit": "45b63cc11c880f8969f6052bff045a41c24a6857", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "900655ddb51fbc48f854958fb0ee8125c01f5cdf", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java b/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java\nindex edc57c978..8e8c9328f 100644\n--- a/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java\n+++ b/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java\n\n@@ -181,7 +181,7 @@ public class SampleByFillValueRecordCursorFactory implements RecordCursorFactory\n         try {\n             map.clear();\n             long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n-            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {\n+            if (maxInMemoryRows > baseCursor.size()) {\n                 map.setMaxSize(maxInMemoryRows);\n \n                 // This factory fills gaps in data. To do that we\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyNDQ5Nw==", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428324497", "bodyText": "this is purely syntax, (no extra code should be generated). But when there is return statement inside if statement, else branch is not necessary", "author": "bluestreak01", "createdAt": "2020-05-20T21:42:37Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java", "diffHunk": "@@ -154,43 +178,54 @@ public void close() {\n     @Override\n     public RecordCursor getCursor(SqlExecutionContext executionContext) {\n         final RecordCursor baseCursor = base.getCursor(executionContext);\n-        map.clear();\n-\n-        // This factory fills gaps in data. To do that we\n-        // have to know all possible key values. Essentially, every time\n-        // we sample we return same set of key values with different\n-        // aggregation results and timestamp\n-\n-        int n = groupByFunctions.size();\n-        final Record baseCursorRecord = baseCursor.getRecord();\n-        while (baseCursor.hasNext()) {\n-            MapKey key = map.withKey();\n-            mapSink.copy(baseCursorRecord, key);\n-            MapValue value = key.createValue();\n-            if (value.isNew()) {\n-                // timestamp is always stored in value field 0\n-                value.putLong(0, Numbers.LONG_NaN);\n-                // have functions reset their columns to \"zero\" state\n-                // this would set values for when keys are not found right away\n-                for (int i = 0; i < n; i++) {\n-                    groupByFunctions.getQuick(i).setNull(value);\n+        try {\n+            map.clear();\n+            long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {\n+                map.setMaxSize(maxInMemoryRows);\n+\n+                // This factory fills gaps in data. To do that we\n+                // have to know all possible key values. Essentially, every time\n+                // we sample we return same set of key values with different\n+                // aggregation results and timestamp\n+\n+                int n = groupByFunctions.size();\n+                final Record baseCursorRecord = baseCursor.getRecord();\n+                while (baseCursor.hasNext()) {\n+                    MapKey key = map.withKey();\n+                    mapSink.copy(baseCursorRecord, key);\n+                    MapValue value = key.createValue();\n+                    if (value.isNew()) {\n+                        // timestamp is always stored in value field 0\n+                        value.putLong(0, Numbers.LONG_NaN);\n+                        // have functions reset their columns to \"zero\" state\n+                        // this would set values for when keys are not found right away\n+                        for (int i = 0; i < n; i++) {\n+                            groupByFunctions.getQuick(i).setNull(value);\n+                        }\n+                    }\n+                }\n+\n+                // empty map? this means that base cursor was empty\n+                if (map.size() == 0) {\n+                    baseCursor.close();\n+                    return EmptyTableRecordCursor.INSTANCE;\n                 }\n-            }\n-        }\n \n-        // empty map? this means that base cursor was empty\n-        if (map.size() == 0) {\n+                // because we pass base cursor twice we have to go back to top\n+                // for the second run\n+                baseCursor.toTop();\n+                boolean next = baseCursor.hasNext();\n+                // we know base cursor has value\n+                assert next;\n+                return initFunctionsAndCursor(executionContext, baseCursor);\n+            } else {\n+                throw LimitOverflowException.instance(maxInMemoryRows);", "originalCommit": "45b63cc11c880f8969f6052bff045a41c24a6857", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "900655ddb51fbc48f854958fb0ee8125c01f5cdf", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java b/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java\nindex edc57c978..8e8c9328f 100644\n--- a/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java\n+++ b/core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java\n\n@@ -181,7 +181,7 @@ public class SampleByFillValueRecordCursorFactory implements RecordCursorFactory\n         try {\n             map.clear();\n             long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n-            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {\n+            if (maxInMemoryRows > baseCursor.size()) {\n                 map.setMaxSize(maxInMemoryRows);\n \n                 // This factory fills gaps in data. To do that we\n"}}, {"oid": "900655ddb51fbc48f854958fb0ee8125c01f5cdf", "url": "https://github.com/questdb/questdb/commit/900655ddb51fbc48f854958fb0ee8125c01f5cdf", "message": "chore: questdb can be configured to limit the number of in memory rows", "committedDate": "2020-05-20T22:08:41Z", "type": "commit"}]}