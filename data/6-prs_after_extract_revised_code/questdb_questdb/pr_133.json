{"pr_number": 133, "pr_title": "Table backup2", "pr_createdAt": "2020-03-31T11:05:46Z", "pr_url": "https://github.com/questdb/questdb/pull/133", "timeline": [{"oid": "dc3f1675f5e1350f1f011979ebc78300a72f0250", "url": "https://github.com/questdb/questdb/commit/dc3f1675f5e1350f1f011979ebc78300a72f0250", "message": "feat(cairo): add table backup", "committedDate": "2020-03-26T08:04:07Z", "type": "commit"}, {"oid": "6e0016a52f10b7c04ca5e17079fea57630fa86f2", "url": "https://github.com/questdb/questdb/commit/6e0016a52f10b7c04ca5e17079fea57630fa86f2", "message": "Merge branch 'master' into table-backup", "committedDate": "2020-03-26T08:37:31Z", "type": "commit"}, {"oid": "db0069c3f2063297466d1da597abede52942d7f2", "url": "https://github.com/questdb/questdb/commit/db0069c3f2063297466d1da597abede52942d7f2", "message": "Merge branch 'master' into table-backup", "committedDate": "2020-03-30T08:50:52Z", "type": "commit"}, {"oid": "651f92aadca96f1ae8d0cca1587d32a69c00f252", "url": "https://github.com/questdb/questdb/commit/651f92aadca96f1ae8d0cca1587d32a69c00f252", "message": "feat(cairo): add table backup", "committedDate": "2020-03-30T13:08:37Z", "type": "commit"}, {"oid": "039159463351e3bb0e760da6295529bf77279aa9", "url": "https://github.com/questdb/questdb/commit/039159463351e3bb0e760da6295529bf77279aa9", "message": "feat(cairo): add table backup\n\tMove backupTable to CairoEngine and use reader/writer pools", "committedDate": "2020-03-30T22:16:55Z", "type": "commit"}, {"oid": "2d7af63cb3c25b416da87641cf8be455d8d05bc0", "url": "https://github.com/questdb/questdb/commit/2d7af63cb3c25b416da87641cf8be455d8d05bc0", "message": "feat(cairo): add table backup", "committedDate": "2020-03-30T23:11:50Z", "type": "commit"}, {"oid": "86bc987640852387a5a8a7ded4fe2cbd605df87d", "url": "https://github.com/questdb/questdb/commit/86bc987640852387a5a8a7ded4fe2cbd605df87d", "message": "feat(cairo): add table backup", "committedDate": "2020-03-30T23:12:53Z", "type": "commit"}, {"oid": "7ea01dd3799e603c60929fbc741419028e515674", "url": "https://github.com/questdb/questdb/commit/7ea01dd3799e603c60929fbc741419028e515674", "message": "feat(cairo): add table backup\n\tMove backupTable to CairoEngine and use reader/writer pools", "committedDate": "2020-03-30T23:21:50Z", "type": "commit"}, {"oid": "f874d2c66dd0b59070c668592e801f5f171e43d2", "url": "https://github.com/questdb/questdb/commit/f874d2c66dd0b59070c668592e801f5f171e43d2", "message": "Merge branch 'table-backup' of github.com:questdb/questdb into table-backup", "committedDate": "2020-03-31T07:01:15Z", "type": "commit"}, {"oid": "9b21ccf4d129c1d53c0a15e76328877831f5d91d", "url": "https://github.com/questdb/questdb/commit/9b21ccf4d129c1d53c0a15e76328877831f5d91d", "message": "feat(griffin): add table backup", "committedDate": "2020-03-31T09:41:14Z", "type": "commit"}, {"oid": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "url": "https://github.com/questdb/questdb/commit/34d7114ca1fd7d662621ade008a9b82abf4e3a23", "message": "feat(griffin): add table backup", "committedDate": "2020-03-31T10:40:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgyODk1MA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400828950", "bodyText": "Misc.free() does null check already", "author": "bluestreak01", "createdAt": "2020-03-31T11:10:49Z", "path": "core/src/main/java/io/questdb/cairo/CairoEngine.java", "diffHunk": "@@ -51,23 +54,36 @@\n     private final ReaderPool readerPool;\n     private final CairoConfiguration configuration;\n     private final WriterMaintenanceJob writerMaintenanceJob;\n+    private final WriterPool backupWriterPool;\n \n     public CairoEngine(CairoConfiguration configuration) {\n         this(configuration, null);\n     }\n \n     public CairoEngine(CairoConfiguration configuration, @Nullable MessageBus messageBus) {\n         this.configuration = configuration;\n-        this.writerPool = new WriterPool(configuration, messageBus);\n+        this.writerPool = new WriterPool(configuration, messageBus, false);\n         this.readerPool = new ReaderPool(configuration);\n         this.writerMaintenanceJob = new WriterMaintenanceJob(configuration);\n+        if (null != configuration.getBackupRoot()) {\n+        \tbackupWriterPool = new WriterPool(configuration, messageBus, true);\n+        } else {\n+        \tbackupWriterPool = null;\n+        }\n+    }\n+\n+    public WriterMaintenanceJob getWriterMaintenanceJob() {\n+        return writerMaintenanceJob;\n     }\n \n     @Override\n     public void close() {\n         Misc.free(writerPool);\n         Misc.free(readerPool);\n-    }\n+        if (null != backupWriterPool) {", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd81cb5f34d8422f37271c9e1418e570bf97ea24", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/CairoEngine.java b/core/src/main/java/io/questdb/cairo/CairoEngine.java\nindex 56d44fdcf..1d1a6b913 100644\n--- a/core/src/main/java/io/questdb/cairo/CairoEngine.java\n+++ b/core/src/main/java/io/questdb/cairo/CairoEngine.java\n\n@@ -80,9 +80,7 @@ public class CairoEngine implements Closeable {\n     public void close() {\n         Misc.free(writerPool);\n         Misc.free(readerPool);\n-        if (null != backupWriterPool) {\n-        \tMisc.free(backupWriterPool);\n-        }\n+       \tMisc.free(backupWriterPool);\n    }\n \n     public void creatTable(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMDI1OQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400830259", "bodyText": "this should be &&\nif writerPool releases and backup doesn't result should be false.\nPerhaps a unit test should be added to ensure this behaviour", "author": "bluestreak01", "createdAt": "2020-03-31T11:13:20Z", "path": "core/src/main/java/io/questdb/cairo/CairoEngine.java", "diffHunk": "@@ -200,9 +219,13 @@ public boolean releaseAllReaders() {\n     }\n \n     public boolean releaseAllWriters() {\n-        return writerPool.releaseAll();\n+        boolean released = writerPool.releaseAll();\n+        if (null != backupWriterPool) {\n+        \treturn backupWriterPool.releaseAll() || released;", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzOTcwMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400839701", "bodyText": "I added a comment about this yesterday, it got lost in all the branch mess. writerPool.releaseAll() returns false if there are no writers OR if the release can't meet the deadline, but the deadline is infinite, so it will return false even iif the method succeeds (there were no writers).\nAlso, the return value of releaseAllWriters is never checked and its is always called when releaseAllReaders is called (by tests only). Wouldn't it be better to have a releaseAll with a void return?", "author": "patrickSpaceSurfer", "createdAt": "2020-03-31T11:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMDI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NzA4Ng==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400847086", "bodyText": "return value is used by WriterMaintenanceJob to throttle threads", "author": "bluestreak01", "createdAt": "2020-03-31T11:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMDI1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "cd81cb5f34d8422f37271c9e1418e570bf97ea24", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/CairoEngine.java b/core/src/main/java/io/questdb/cairo/CairoEngine.java\nindex 56d44fdcf..1d1a6b913 100644\n--- a/core/src/main/java/io/questdb/cairo/CairoEngine.java\n+++ b/core/src/main/java/io/questdb/cairo/CairoEngine.java\n\n@@ -218,12 +216,12 @@ public class CairoEngine implements Closeable {\n         return readerPool.releaseAll();\n     }\n \n-    public boolean releaseAllWriters() {\n-        boolean released = writerPool.releaseAll();\n-        if (null != backupWriterPool) {\n-        \treturn backupWriterPool.releaseAll() || released;\n-        }\n-        return released;\n+    public boolean releaseAllWriters () {\n+    \tboolean released = writerPool.releaseAll();\n+    \tif (null != backupWriterPool && backupWriterPool.releaseAll()) {\n+    \t\treleased = true;\n+    \t}\n+    \treturn released;\n     }\n     \n     public void releaseInactive() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMTgzNA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400831834", "bodyText": "what happened here with padding?", "author": "bluestreak01", "createdAt": "2020-03-31T11:16:16Z", "path": "core/src/test/java/io/questdb/cairo/AbstractCairoTest.java", "diffHunk": "@@ -51,17 +54,17 @@\n     protected static CairoConfiguration configuration;\n     protected static MessageBus messageBus;\n \n-    @BeforeClass\n-    public static void setUp() {\n-        // it is necessary to initialise logger before tests start\n-        // logger doesn't relinquish memory until JVM stops\n-        // which causes memory leak detector to fail should logger be\n-        // created mid-test\n-        LOG.info().$(\"begin\").$();\n-        root = temp.getRoot().getAbsolutePath();\n-        configuration = new DefaultCairoConfiguration(root);\n+\t@BeforeClass\n+\tpublic static void setUp() throws IOException {\n+\t\t// it is necessary to initialise logger before tests start\n+\t\t// logger doesn't relinquish memory until JVM stops", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0MDU2NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400840564", "bodyText": "I need to figure out how to configure the code formatter ...", "author": "patrickSpaceSurfer", "createdAt": "2020-03-31T11:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMTgzNA=="}], "type": "inlineReview", "revised_code": {"commit": "a20b7ecef33ad7f5f1e5bf843ad428d75448bc74", "chunk": "diff --git a/core/src/test/java/io/questdb/cairo/AbstractCairoTest.java b/core/src/test/java/io/questdb/cairo/AbstractCairoTest.java\nindex c88396610..6bc21c0ca 100644\n--- a/core/src/test/java/io/questdb/cairo/AbstractCairoTest.java\n+++ b/core/src/test/java/io/questdb/cairo/AbstractCairoTest.java\n\n@@ -54,17 +54,17 @@ public class AbstractCairoTest {\n     protected static CairoConfiguration configuration;\n     protected static MessageBus messageBus;\n \n-\t@BeforeClass\n-\tpublic static void setUp() throws IOException {\n-\t\t// it is necessary to initialise logger before tests start\n-\t\t// logger doesn't relinquish memory until JVM stops\n-\t\t// which causes memory leak detector to fail should logger be\n-\t\t// created mid-test\n-\t\tLOG.info().$(\"begin\").$();\n-\t\troot = temp.newFolder(\"dbRoot\").getAbsolutePath();\n-\t\tconfiguration = new DefaultCairoConfiguration(root);\n+    @BeforeClass\n+    public static void setUp() throws IOException {\n+        // it is necessary to initialise logger before tests start\n+        // logger doesn't relinquish memory until JVM stops\n+        // which causes memory leak detector to fail should logger be\n+        // created mid-test\n+        LOG.info().$(\"begin\").$();\n+        root = temp.newFolder(\"dbRoot\").getAbsolutePath();\n+        configuration = new DefaultCairoConfiguration(root);\n         messageBus = new MessageBusImpl();\n-\t}\n+    }\n \n     @Before\n     public void setUp0() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMjQ1NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400832454", "bodyText": "if we use SQL to backup tables, which is likely, this code can move into SQLCompiler", "author": "bluestreak01", "createdAt": "2020-03-31T11:17:24Z", "path": "core/src/main/java/io/questdb/griffin/TableBackupManager.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.questdb.griffin;\n+\n+import io.questdb.cairo.AppendMemory;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.CairoSecurityContext;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.SymbolMapWriter;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.TableReaderMetadata;\n+import io.questdb.cairo.TableUtils;\n+import io.questdb.cairo.TableWriter;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupManager {", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0MDMzMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400840331", "bodyText": "Yes, I was think of that, but SQLCompiler is already very long ...\nHowever, I am not bothered either way, it does make sense to put it into SQLCompiler", "author": "patrickSpaceSurfer", "createdAt": "2020-03-31T11:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMjQ1NA=="}], "type": "inlineReview", "revised_code": {"commit": "772f09e6c559213791e79601ed7d2cef363bf9e2", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/TableBackupManager.java b/core/src/main/java/io/questdb/griffin/TableBackupManager.java\nindex e70397b93..b0e828c88 100644\n--- a/core/src/main/java/io/questdb/griffin/TableBackupManager.java\n+++ b/core/src/main/java/io/questdb/griffin/TableBackupManager.java\n\n@@ -45,13 +45,13 @@ public class TableBackupManager {\n \tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n \t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n \t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {\n-\t\t\tpath.of(backupRoot).concat(tableName);\n+\t\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n \n \t\t\tif (ff.exists(path)) {\n \t\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');\n \t\t\t}\n \n-\t\t\tif (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n+\t\t\tif (ff.mkdirs(path, mkDirMode) != 0) {\n \t\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n \t\t\t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMzM5NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400833394", "bodyText": "if this becomes part of SQLCompiler, it already has instance of AppendMemory called mem for cases like this.", "author": "bluestreak01", "createdAt": "2020-03-31T11:19:14Z", "path": "core/src/main/java/io/questdb/griffin/TableBackupManager.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.questdb.griffin;\n+\n+import io.questdb.cairo.AppendMemory;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.CairoSecurityContext;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.SymbolMapWriter;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.TableReaderMetadata;\n+import io.questdb.cairo.TableUtils;\n+import io.questdb.cairo.TableWriter;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupManager {\n+\tprivate final CairoConfiguration configuration;\n+\tprivate final CairoEngine engine;\n+\tprivate final SqlCompiler compiler;\n+\n+\tpublic TableBackupManager(CairoConfiguration configuration, CairoEngine engine, SqlCompiler compiler) {\n+\t\tsuper();\n+\t\tthis.configuration = configuration;\n+\t\tthis.engine = engine;\n+\t\tthis.compiler = compiler;\n+\t}\n+\n+\tpublic void backupTable(CairoSecurityContext securityContext, CharSequence tableName, Path path) {\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getFilesFacade(), path, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcompiler.copyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n+\t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n+\t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {\n+\t\t\tpath.of(backupRoot).concat(tableName);\n+\n+\t\t\tif (ff.exists(path)) {\n+\t\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');\n+\t\t\t}\n+\n+\t\t\tif (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n+\t\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+\t\t\t}\n+\n+\t\t\tfinal int rootLen = path.length();\n+\t\t\ttry (AppendMemory backupMem = new AppendMemory()) {", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "772f09e6c559213791e79601ed7d2cef363bf9e2", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/TableBackupManager.java b/core/src/main/java/io/questdb/griffin/TableBackupManager.java\nindex e70397b93..b0e828c88 100644\n--- a/core/src/main/java/io/questdb/griffin/TableBackupManager.java\n+++ b/core/src/main/java/io/questdb/griffin/TableBackupManager.java\n\n@@ -45,13 +45,13 @@ public class TableBackupManager {\n \tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n \t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n \t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {\n-\t\t\tpath.of(backupRoot).concat(tableName);\n+\t\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n \n \t\t\tif (ff.exists(path)) {\n \t\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');\n \t\t\t}\n \n-\t\t\tif (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n+\t\t\tif (ff.mkdirs(path, mkDirMode) != 0) {\n \t\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n \t\t\t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMzc5Ng==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400833796", "bodyText": "CairoException provides methods to avoid string concatenation", "author": "bluestreak01", "createdAt": "2020-03-31T11:20:01Z", "path": "core/src/main/java/io/questdb/griffin/TableBackupManager.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.questdb.griffin;\n+\n+import io.questdb.cairo.AppendMemory;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.CairoSecurityContext;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.SymbolMapWriter;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.TableReaderMetadata;\n+import io.questdb.cairo.TableUtils;\n+import io.questdb.cairo.TableWriter;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupManager {\n+\tprivate final CairoConfiguration configuration;\n+\tprivate final CairoEngine engine;\n+\tprivate final SqlCompiler compiler;\n+\n+\tpublic TableBackupManager(CairoConfiguration configuration, CairoEngine engine, SqlCompiler compiler) {\n+\t\tsuper();\n+\t\tthis.configuration = configuration;\n+\t\tthis.engine = engine;\n+\t\tthis.compiler = compiler;\n+\t}\n+\n+\tpublic void backupTable(CairoSecurityContext securityContext, CharSequence tableName, Path path) {\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getFilesFacade(), path, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcompiler.copyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n+\t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n+\t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {\n+\t\t\tpath.of(backupRoot).concat(tableName);\n+\n+\t\t\tif (ff.exists(path)) {\n+\t\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "772f09e6c559213791e79601ed7d2cef363bf9e2", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/TableBackupManager.java b/core/src/main/java/io/questdb/griffin/TableBackupManager.java\nindex e70397b93..b0e828c88 100644\n--- a/core/src/main/java/io/questdb/griffin/TableBackupManager.java\n+++ b/core/src/main/java/io/questdb/griffin/TableBackupManager.java\n\n@@ -45,13 +45,13 @@ public class TableBackupManager {\n \tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n \t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n \t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {\n-\t\t\tpath.of(backupRoot).concat(tableName);\n+\t\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n \n \t\t\tif (ff.exists(path)) {\n \t\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');\n \t\t\t}\n \n-\t\t\tif (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n+\t\t\tif (ff.mkdirs(path, mkDirMode) != 0) {\n \t\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n \t\t\t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNDM5Nw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400834397", "bodyText": "why not reuse instance of TableReaderMetadata that TableReader has (in a call just above)", "author": "bluestreak01", "createdAt": "2020-03-31T11:21:14Z", "path": "core/src/main/java/io/questdb/griffin/TableBackupManager.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.questdb.griffin;\n+\n+import io.questdb.cairo.AppendMemory;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.CairoSecurityContext;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.SymbolMapWriter;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.TableReaderMetadata;\n+import io.questdb.cairo.TableUtils;\n+import io.questdb.cairo.TableWriter;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupManager {\n+\tprivate final CairoConfiguration configuration;\n+\tprivate final CairoEngine engine;\n+\tprivate final SqlCompiler compiler;\n+\n+\tpublic TableBackupManager(CairoConfiguration configuration, CairoEngine engine, SqlCompiler compiler) {\n+\t\tsuper();\n+\t\tthis.configuration = configuration;\n+\t\tthis.engine = engine;\n+\t\tthis.compiler = compiler;\n+\t}\n+\n+\tpublic void backupTable(CairoSecurityContext securityContext, CharSequence tableName, Path path) {\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getFilesFacade(), path, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcompiler.copyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n+\t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n+\t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "772f09e6c559213791e79601ed7d2cef363bf9e2", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/TableBackupManager.java b/core/src/main/java/io/questdb/griffin/TableBackupManager.java\nindex e70397b93..b0e828c88 100644\n--- a/core/src/main/java/io/questdb/griffin/TableBackupManager.java\n+++ b/core/src/main/java/io/questdb/griffin/TableBackupManager.java\n\n@@ -45,13 +45,13 @@ public class TableBackupManager {\n \tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n \t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n \t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {\n-\t\t\tpath.of(backupRoot).concat(tableName);\n+\t\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n \n \t\t\tif (ff.exists(path)) {\n \t\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');\n \t\t\t}\n \n-\t\t\tif (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n+\t\t\tif (ff.mkdirs(path, mkDirMode) != 0) {\n \t\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n \t\t\t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNDc0OQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400834749", "bodyText": "path is a zero-terminated string. When concatenation is finished it is imperative to terminate path with .$()", "author": "bluestreak01", "createdAt": "2020-03-31T11:21:58Z", "path": "core/src/main/java/io/questdb/griffin/TableBackupManager.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.questdb.griffin;\n+\n+import io.questdb.cairo.AppendMemory;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.CairoSecurityContext;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.SymbolMapWriter;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.TableReaderMetadata;\n+import io.questdb.cairo.TableUtils;\n+import io.questdb.cairo.TableWriter;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupManager {\n+\tprivate final CairoConfiguration configuration;\n+\tprivate final CairoEngine engine;\n+\tprivate final SqlCompiler compiler;\n+\n+\tpublic TableBackupManager(CairoConfiguration configuration, CairoEngine engine, SqlCompiler compiler) {\n+\t\tsuper();\n+\t\tthis.configuration = configuration;\n+\t\tthis.engine = engine;\n+\t\tthis.compiler = compiler;\n+\t}\n+\n+\tpublic void backupTable(CairoSecurityContext securityContext, CharSequence tableName, Path path) {\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getFilesFacade(), path, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcompiler.copyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n+\t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n+\t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {\n+\t\t\tpath.of(backupRoot).concat(tableName);", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "772f09e6c559213791e79601ed7d2cef363bf9e2", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/TableBackupManager.java b/core/src/main/java/io/questdb/griffin/TableBackupManager.java\nindex e70397b93..b0e828c88 100644\n--- a/core/src/main/java/io/questdb/griffin/TableBackupManager.java\n+++ b/core/src/main/java/io/questdb/griffin/TableBackupManager.java\n\n@@ -45,13 +45,13 @@ public class TableBackupManager {\n \tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n \t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n \t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {\n-\t\t\tpath.of(backupRoot).concat(tableName);\n+\t\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n \n \t\t\tif (ff.exists(path)) {\n \t\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');\n \t\t\t}\n \n-\t\t\tif (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n+\t\t\tif (ff.mkdirs(path, mkDirMode) != 0) {\n \t\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n \t\t\t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNTY0Mw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400835643", "bodyText": "path is \"Closeable\", not freeing it up will leak memory in test", "author": "bluestreak01", "createdAt": "2020-03-31T11:23:35Z", "path": "core/src/test/java/io/questdb/griffin/TableBackupTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package io.questdb.griffin;\n+\n+import java.io.IOException;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.questdb.cairo.AbstractCairoTest;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.DefaultCairoConfiguration;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordCursorFactory;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupTest extends AbstractGriffinTest {\n+\tprivate CharSequence backupRoot;\n+\n+\t@Test\n+\tpublic void simpleTableTest1() throws Exception {\n+\t\tString tableName = \"testTable\";\n+\t\tPath path = new Path();", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd81cb5f34d8422f37271c9e1418e570bf97ea24", "chunk": "diff --git a/core/src/test/java/io/questdb/griffin/TableBackupTest.java b/core/src/test/java/io/questdb/griffin/TableBackupTest.java\nindex c1fb5651d..5e61471b5 100644\n--- a/core/src/test/java/io/questdb/griffin/TableBackupTest.java\n+++ b/core/src/test/java/io/questdb/griffin/TableBackupTest.java\n\n@@ -2,53 +2,72 @@ package io.questdb.griffin;\n \n import java.io.IOException;\n \n+import org.junit.AfterClass;\n import org.junit.Assert;\n-import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n \n-import io.questdb.cairo.AbstractCairoTest;\n+import io.questdb.MessageBus;\n+import io.questdb.MessageBusImpl;\n+import io.questdb.cairo.CairoConfiguration;\n import io.questdb.cairo.CairoEngine;\n import io.questdb.cairo.DefaultCairoConfiguration;\n+import io.questdb.cairo.RecordCursorPrinter;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n import io.questdb.cairo.sql.Record;\n import io.questdb.cairo.sql.RecordCursor;\n import io.questdb.cairo.sql.RecordCursorFactory;\n+import io.questdb.griffin.engine.functions.bind.BindVariableService;\n import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.test.tools.TestUtils;\n \n-public class TableBackupTest extends AbstractGriffinTest {\n-\tprivate CharSequence backupRoot;\n+public class TableBackupTest {\n+\tprivate static final StringSink sink = new StringSink();\n+\tprivate static final RecordCursorPrinter printer = new RecordCursorPrinter(sink);\n+\t@ClassRule\n+\tpublic static TemporaryFolder temp = new TemporaryFolder();\n+\n+\tprivate static Path path;\n+\n+\tprivate static CairoConfiguration mainConfiguration;\n+\tprivate static CairoEngine mainEngine;\n+\tprivate static SqlCompiler mainCompiler;\n+\tprivate static SqlExecutionContext mainSqlExecutionContext;\n+\n+\tprivate static CairoEngine backupEngine;\n+\tprivate static SqlCompiler backupCompiler;\n+\tprivate static SqlExecutionContext backupSqlExecutionContext;\n \n \t@Test\n \tpublic void simpleTableTest1() throws Exception {\n-\t\tString tableName = \"testTable\";\n-\t\tPath path = new Path();\n-\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\tassertMemoryLeak(() -> {\n+\t\t\tString tableName = \"testTable1\";\n \t\t\t// @formatter:off\n-\t\t\tcompiler.compile(\"create table \" + tableName + \" as (select\" + \n+\t\t\tmainCompiler.compile(\"create table \" + tableName + \" as (select\" + \n \t\t\t\t\t\" rnd_symbol(4,4,4,2) sym,\" + \n \t\t\t\t\t\" rnd_double(2) d,\" + \n \t\t\t\t\t\" timestamp_sequence(0, 1000000000) ts\" + \n-\t\t\t\t\t\" from long_sequence(10000)) timestamp(ts)\", sqlExecutionContext);\n+\t\t\t\t\t\" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n \t\t\t// @formatter:on\n-\t\t});\n \n-\t\tTableBackupManager tableBackupManager = new TableBackupManager(configuration, engine, compiler);\n-\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n-\t\t\ttableBackupManager.backupTable(sqlExecutionContext.getCairoSecurityContext(), tableName, path);\n-\t\t});\n+\t\t\tTableBackupManager tableBackupManager = new TableBackupManager(mainConfiguration, mainEngine, mainCompiler);\n+\t\t\ttableBackupManager.backupTable(mainSqlExecutionContext.getCairoSecurityContext(), tableName, path);\n \n-\t\tString sourceSelectAll = selectAll(tableName);\n-\t\tsetup(backupRoot, null);\n-\t\tString backupSelectAll = selectAll(tableName);\n-\t\tAssert.assertEquals(sourceSelectAll, backupSelectAll);\n+\t\t\tString sourceSelectAll = selectAll(mainEngine, mainCompiler, mainSqlExecutionContext, tableName);\n+\t\t\tString backupSelectAll = selectAll(backupEngine, backupCompiler, backupSqlExecutionContext, tableName);\n+\t\t\tAssert.assertEquals(sourceSelectAll, backupSelectAll);\n+\t\t});\n \t}\n \n \t@Test\n \tpublic void allTypesPartitionedTableTest1() throws Exception {\n-\t\tString tableName = \"testTable\";\n-\t\tPath path = new Path();\n-\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\tassertMemoryLeak(() -> {\n+\t\t\tString tableName = \"testTable2\";\n \t\t\t// @formatter:off\n-\t\t\tcompiler.compile(\"create table \" + tableName + \" as (\" +\n+\t\t\tmainCompiler.compile(\"create table \" + tableName + \" as (\" +\n                         \"select\" +\n                         \" rnd_char() ch,\" +\n                         \" rnd_long256() ll,\" +\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNTg0Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400835842", "bodyText": "leak test needs to surround entire test", "author": "bluestreak01", "createdAt": "2020-03-31T11:23:57Z", "path": "core/src/test/java/io/questdb/griffin/TableBackupTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package io.questdb.griffin;\n+\n+import java.io.IOException;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.questdb.cairo.AbstractCairoTest;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.DefaultCairoConfiguration;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordCursorFactory;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupTest extends AbstractGriffinTest {\n+\tprivate CharSequence backupRoot;\n+\n+\t@Test\n+\tpublic void simpleTableTest1() throws Exception {\n+\t\tString tableName = \"testTable\";\n+\t\tPath path = new Path();\n+\t\tAbstractGriffinTest.assertMemoryLeak(() -> {", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd81cb5f34d8422f37271c9e1418e570bf97ea24", "chunk": "diff --git a/core/src/test/java/io/questdb/griffin/TableBackupTest.java b/core/src/test/java/io/questdb/griffin/TableBackupTest.java\nindex c1fb5651d..5e61471b5 100644\n--- a/core/src/test/java/io/questdb/griffin/TableBackupTest.java\n+++ b/core/src/test/java/io/questdb/griffin/TableBackupTest.java\n\n@@ -2,53 +2,72 @@ package io.questdb.griffin;\n \n import java.io.IOException;\n \n+import org.junit.AfterClass;\n import org.junit.Assert;\n-import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n \n-import io.questdb.cairo.AbstractCairoTest;\n+import io.questdb.MessageBus;\n+import io.questdb.MessageBusImpl;\n+import io.questdb.cairo.CairoConfiguration;\n import io.questdb.cairo.CairoEngine;\n import io.questdb.cairo.DefaultCairoConfiguration;\n+import io.questdb.cairo.RecordCursorPrinter;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n import io.questdb.cairo.sql.Record;\n import io.questdb.cairo.sql.RecordCursor;\n import io.questdb.cairo.sql.RecordCursorFactory;\n+import io.questdb.griffin.engine.functions.bind.BindVariableService;\n import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.test.tools.TestUtils;\n \n-public class TableBackupTest extends AbstractGriffinTest {\n-\tprivate CharSequence backupRoot;\n+public class TableBackupTest {\n+\tprivate static final StringSink sink = new StringSink();\n+\tprivate static final RecordCursorPrinter printer = new RecordCursorPrinter(sink);\n+\t@ClassRule\n+\tpublic static TemporaryFolder temp = new TemporaryFolder();\n+\n+\tprivate static Path path;\n+\n+\tprivate static CairoConfiguration mainConfiguration;\n+\tprivate static CairoEngine mainEngine;\n+\tprivate static SqlCompiler mainCompiler;\n+\tprivate static SqlExecutionContext mainSqlExecutionContext;\n+\n+\tprivate static CairoEngine backupEngine;\n+\tprivate static SqlCompiler backupCompiler;\n+\tprivate static SqlExecutionContext backupSqlExecutionContext;\n \n \t@Test\n \tpublic void simpleTableTest1() throws Exception {\n-\t\tString tableName = \"testTable\";\n-\t\tPath path = new Path();\n-\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\tassertMemoryLeak(() -> {\n+\t\t\tString tableName = \"testTable1\";\n \t\t\t// @formatter:off\n-\t\t\tcompiler.compile(\"create table \" + tableName + \" as (select\" + \n+\t\t\tmainCompiler.compile(\"create table \" + tableName + \" as (select\" + \n \t\t\t\t\t\" rnd_symbol(4,4,4,2) sym,\" + \n \t\t\t\t\t\" rnd_double(2) d,\" + \n \t\t\t\t\t\" timestamp_sequence(0, 1000000000) ts\" + \n-\t\t\t\t\t\" from long_sequence(10000)) timestamp(ts)\", sqlExecutionContext);\n+\t\t\t\t\t\" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n \t\t\t// @formatter:on\n-\t\t});\n \n-\t\tTableBackupManager tableBackupManager = new TableBackupManager(configuration, engine, compiler);\n-\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n-\t\t\ttableBackupManager.backupTable(sqlExecutionContext.getCairoSecurityContext(), tableName, path);\n-\t\t});\n+\t\t\tTableBackupManager tableBackupManager = new TableBackupManager(mainConfiguration, mainEngine, mainCompiler);\n+\t\t\ttableBackupManager.backupTable(mainSqlExecutionContext.getCairoSecurityContext(), tableName, path);\n \n-\t\tString sourceSelectAll = selectAll(tableName);\n-\t\tsetup(backupRoot, null);\n-\t\tString backupSelectAll = selectAll(tableName);\n-\t\tAssert.assertEquals(sourceSelectAll, backupSelectAll);\n+\t\t\tString sourceSelectAll = selectAll(mainEngine, mainCompiler, mainSqlExecutionContext, tableName);\n+\t\t\tString backupSelectAll = selectAll(backupEngine, backupCompiler, backupSqlExecutionContext, tableName);\n+\t\t\tAssert.assertEquals(sourceSelectAll, backupSelectAll);\n+\t\t});\n \t}\n \n \t@Test\n \tpublic void allTypesPartitionedTableTest1() throws Exception {\n-\t\tString tableName = \"testTable\";\n-\t\tPath path = new Path();\n-\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\tassertMemoryLeak(() -> {\n+\t\t\tString tableName = \"testTable2\";\n \t\t\t// @formatter:off\n-\t\t\tcompiler.compile(\"create table \" + tableName + \" as (\" +\n+\t\t\tmainCompiler.compile(\"create table \" + tableName + \" as (\" +\n                         \"select\" +\n                         \" rnd_char() ch,\" +\n                         \" rnd_long256() ll,\" +\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNjE1Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400836152", "bodyText": "factory is also Closeable", "author": "bluestreak01", "createdAt": "2020-03-31T11:24:34Z", "path": "core/src/test/java/io/questdb/griffin/TableBackupTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package io.questdb.griffin;\n+\n+import java.io.IOException;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.questdb.cairo.AbstractCairoTest;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.DefaultCairoConfiguration;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordCursorFactory;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupTest extends AbstractGriffinTest {\n+\tprivate CharSequence backupRoot;\n+\n+\t@Test\n+\tpublic void simpleTableTest1() throws Exception {\n+\t\tString tableName = \"testTable\";\n+\t\tPath path = new Path();\n+\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\t\t// @formatter:off\n+\t\t\tcompiler.compile(\"create table \" + tableName + \" as (select\" + \n+\t\t\t\t\t\" rnd_symbol(4,4,4,2) sym,\" + \n+\t\t\t\t\t\" rnd_double(2) d,\" + \n+\t\t\t\t\t\" timestamp_sequence(0, 1000000000) ts\" + \n+\t\t\t\t\t\" from long_sequence(10000)) timestamp(ts)\", sqlExecutionContext);\n+\t\t\t// @formatter:on\n+\t\t});\n+\n+\t\tTableBackupManager tableBackupManager = new TableBackupManager(configuration, engine, compiler);\n+\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\t\ttableBackupManager.backupTable(sqlExecutionContext.getCairoSecurityContext(), tableName, path);\n+\t\t});\n+\n+\t\tString sourceSelectAll = selectAll(tableName);\n+\t\tsetup(backupRoot, null);\n+\t\tString backupSelectAll = selectAll(tableName);\n+\t\tAssert.assertEquals(sourceSelectAll, backupSelectAll);\n+\t}\n+\n+\t@Test\n+\tpublic void allTypesPartitionedTableTest1() throws Exception {\n+\t\tString tableName = \"testTable\";\n+\t\tPath path = new Path();\n+\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\t\t// @formatter:off\n+\t\t\tcompiler.compile(\"create table \" + tableName + \" as (\" +\n+                        \"select\" +\n+                        \" rnd_char() ch,\" +\n+                        \" rnd_long256() ll,\" +\n+                        \" rnd_int() a1,\" +\n+                        \" rnd_int(0, 30, 2) a,\" +\n+                        \" rnd_boolean() b,\" +\n+                        \" rnd_str(3,3,2) c,\" +\n+                        \" rnd_double(2) d,\" +\n+                        \" rnd_float(2) e,\" +\n+                        \" rnd_short(10,1024) f,\" +\n+                        \" rnd_short() f1,\" +\n+                        \" rnd_date(to_date('2015', 'yyyy'), to_date('2016', 'yyyy'), 2) g,\" +\n+                        \" rnd_timestamp(to_timestamp('2015', 'yyyy'), to_timestamp('2016', 'yyyy'), 2) h,\" +\n+                        \" rnd_symbol(4,4,4,2) i,\" +\n+                        \" rnd_long(100,200,2) j,\" +\n+                        \" rnd_long() j1,\" +\n+                        \" timestamp_sequence(0, 1000000000) k,\" +\n+                        \" rnd_byte(2,50) l,\" +\n+                        \" rnd_bin(10, 20, 2) m\" +\n+                        \" from long_sequence(1000)\" +\n+                        \")  timestamp(k) partition by DAY\", sqlExecutionContext);\n+\t\t\t// @formatter:on\n+\t\t});\n+\n+\t\tTableBackupManager tableBackupManager = new TableBackupManager(configuration, engine, compiler);\n+\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\t\ttableBackupManager.backupTable(sqlExecutionContext.getCairoSecurityContext(), tableName, path);\n+\t\t});\n+\n+\t\tString sourceSelectAll = selectAll(tableName);\n+\t\tsetup(backupRoot, null);\n+\t\tString backupSelectAll = selectAll(tableName);\n+\t\tAssert.assertEquals(sourceSelectAll, backupSelectAll);\n+\t}\n+\n+\tprivate String selectAll(String tableName) throws Exception {\n+\t\tassertMemoryLeak(() -> {\n+\t\t\tCompiledQuery compiledQuery = compiler.compile(\"select * from \" + tableName, sqlExecutionContext);\n+\t\t\tRecordCursorFactory factory = compiledQuery.getRecordCursorFactory();", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd81cb5f34d8422f37271c9e1418e570bf97ea24", "chunk": "diff --git a/core/src/test/java/io/questdb/griffin/TableBackupTest.java b/core/src/test/java/io/questdb/griffin/TableBackupTest.java\nindex c1fb5651d..5e61471b5 100644\n--- a/core/src/test/java/io/questdb/griffin/TableBackupTest.java\n+++ b/core/src/test/java/io/questdb/griffin/TableBackupTest.java\n\n@@ -2,53 +2,72 @@ package io.questdb.griffin;\n \n import java.io.IOException;\n \n+import org.junit.AfterClass;\n import org.junit.Assert;\n-import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n \n-import io.questdb.cairo.AbstractCairoTest;\n+import io.questdb.MessageBus;\n+import io.questdb.MessageBusImpl;\n+import io.questdb.cairo.CairoConfiguration;\n import io.questdb.cairo.CairoEngine;\n import io.questdb.cairo.DefaultCairoConfiguration;\n+import io.questdb.cairo.RecordCursorPrinter;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n import io.questdb.cairo.sql.Record;\n import io.questdb.cairo.sql.RecordCursor;\n import io.questdb.cairo.sql.RecordCursorFactory;\n+import io.questdb.griffin.engine.functions.bind.BindVariableService;\n import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.test.tools.TestUtils;\n \n-public class TableBackupTest extends AbstractGriffinTest {\n-\tprivate CharSequence backupRoot;\n+public class TableBackupTest {\n+\tprivate static final StringSink sink = new StringSink();\n+\tprivate static final RecordCursorPrinter printer = new RecordCursorPrinter(sink);\n+\t@ClassRule\n+\tpublic static TemporaryFolder temp = new TemporaryFolder();\n+\n+\tprivate static Path path;\n+\n+\tprivate static CairoConfiguration mainConfiguration;\n+\tprivate static CairoEngine mainEngine;\n+\tprivate static SqlCompiler mainCompiler;\n+\tprivate static SqlExecutionContext mainSqlExecutionContext;\n+\n+\tprivate static CairoEngine backupEngine;\n+\tprivate static SqlCompiler backupCompiler;\n+\tprivate static SqlExecutionContext backupSqlExecutionContext;\n \n \t@Test\n \tpublic void simpleTableTest1() throws Exception {\n-\t\tString tableName = \"testTable\";\n-\t\tPath path = new Path();\n-\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\tassertMemoryLeak(() -> {\n+\t\t\tString tableName = \"testTable1\";\n \t\t\t// @formatter:off\n-\t\t\tcompiler.compile(\"create table \" + tableName + \" as (select\" + \n+\t\t\tmainCompiler.compile(\"create table \" + tableName + \" as (select\" + \n \t\t\t\t\t\" rnd_symbol(4,4,4,2) sym,\" + \n \t\t\t\t\t\" rnd_double(2) d,\" + \n \t\t\t\t\t\" timestamp_sequence(0, 1000000000) ts\" + \n-\t\t\t\t\t\" from long_sequence(10000)) timestamp(ts)\", sqlExecutionContext);\n+\t\t\t\t\t\" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n \t\t\t// @formatter:on\n-\t\t});\n \n-\t\tTableBackupManager tableBackupManager = new TableBackupManager(configuration, engine, compiler);\n-\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n-\t\t\ttableBackupManager.backupTable(sqlExecutionContext.getCairoSecurityContext(), tableName, path);\n-\t\t});\n+\t\t\tTableBackupManager tableBackupManager = new TableBackupManager(mainConfiguration, mainEngine, mainCompiler);\n+\t\t\ttableBackupManager.backupTable(mainSqlExecutionContext.getCairoSecurityContext(), tableName, path);\n \n-\t\tString sourceSelectAll = selectAll(tableName);\n-\t\tsetup(backupRoot, null);\n-\t\tString backupSelectAll = selectAll(tableName);\n-\t\tAssert.assertEquals(sourceSelectAll, backupSelectAll);\n+\t\t\tString sourceSelectAll = selectAll(mainEngine, mainCompiler, mainSqlExecutionContext, tableName);\n+\t\t\tString backupSelectAll = selectAll(backupEngine, backupCompiler, backupSqlExecutionContext, tableName);\n+\t\t\tAssert.assertEquals(sourceSelectAll, backupSelectAll);\n+\t\t});\n \t}\n \n \t@Test\n \tpublic void allTypesPartitionedTableTest1() throws Exception {\n-\t\tString tableName = \"testTable\";\n-\t\tPath path = new Path();\n-\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\tassertMemoryLeak(() -> {\n+\t\t\tString tableName = \"testTable2\";\n \t\t\t// @formatter:off\n-\t\t\tcompiler.compile(\"create table \" + tableName + \" as (\" +\n+\t\t\tmainCompiler.compile(\"create table \" + tableName + \" as (\" +\n                         \"select\" +\n                         \" rnd_char() ch,\" +\n                         \" rnd_long256() ll,\" +\n"}}, {"oid": "772f09e6c559213791e79601ed7d2cef363bf9e2", "url": "https://github.com/questdb/questdb/commit/772f09e6c559213791e79601ed7d2cef363bf9e2", "message": "feat(griffin): add table backup\n\tFix incorrect usage of path", "committedDate": "2020-03-31T15:11:16Z", "type": "commit"}, {"oid": "cfa9db8c42a88d945aefca0caf728eef14caff26", "url": "https://github.com/questdb/questdb/commit/cfa9db8c42a88d945aefca0caf728eef14caff26", "message": "feat(griffin): add table backup\n\tAvoid allocating new TableReaderMetadata needlessly", "committedDate": "2020-03-31T15:17:37Z", "type": "commit"}, {"oid": "cd81cb5f34d8422f37271c9e1418e570bf97ea24", "url": "https://github.com/questdb/questdb/commit/cd81cb5f34d8422f37271c9e1418e570bf97ea24", "message": "feat(griffin): add table backup\n\tImprove test\n\tInclude backup writers in cairo engine maintenance job", "committedDate": "2020-04-01T10:04:49Z", "type": "commit"}, {"oid": "95824588567ceac5df614c27e70c12af335effd5", "url": "https://github.com/questdb/questdb/commit/95824588567ceac5df614c27e70c12af335effd5", "message": "feat(griffin): add table backup\n\tMove table backup into SqlCompiler", "committedDate": "2020-04-01T10:34:15Z", "type": "commit"}, {"oid": "4958162f5d69e846fddcbef6ea95f31437f952bc", "url": "https://github.com/questdb/questdb/commit/4958162f5d69e846fddcbef6ea95f31437f952bc", "message": "feat(griffin): add table backup\n\tengine#releaseInactive correctly!", "committedDate": "2020-04-01T10:38:13Z", "type": "commit"}, {"oid": "3b6c0c721c9a80473ed7cec21fbd750b7786e6f3", "url": "https://github.com/questdb/questdb/commit/3b6c0c721c9a80473ed7cec21fbd750b7786e6f3", "message": "feat(griffin): add table backup\n\trefactor CairoEngine.releaseInactive", "committedDate": "2020-04-01T12:43:08Z", "type": "commit"}, {"oid": "ffe3066f232e2941761b2e19fc1ccce7a70ff66c", "url": "https://github.com/questdb/questdb/commit/ffe3066f232e2941761b2e19fc1ccce7a70ff66c", "message": "feat(griffin): add table backup\n\tAdd BACKUP TABLE SQL", "committedDate": "2020-04-01T16:27:37Z", "type": "commit"}, {"oid": "c443829637241dc6e2134a1c2219d584393f6cab", "url": "https://github.com/questdb/questdb/commit/c443829637241dc6e2134a1c2219d584393f6cab", "message": "Merge remote-tracking branch 'origin/master' into table-backup2", "committedDate": "2020-04-01T16:36:55Z", "type": "commit"}, {"oid": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "url": "https://github.com/questdb/questdb/commit/62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "message": "feat(griffin): add table backup\n\tFix merge issue", "committedDate": "2020-04-01T16:43:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg0NTAxNg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401845016", "bodyText": "code formatting is still inconsistent with rest of the code. This isn't the only line.", "author": "bluestreak01", "createdAt": "2020-04-01T19:07:12Z", "path": "core/src/main/java/io/questdb/cairo/CairoEngine.java", "diffHunk": "@@ -199,14 +216,22 @@ public boolean releaseAllReaders() {\n         return readerPool.releaseAll();\n     }\n \n-    public boolean releaseAllWriters() {\n-        return writerPool.releaseAll();\n-    }\n-\n-    public void releaseInactive() {\n-        writerPool.releaseInactive();\n-        readerPool.releaseInactive();\n+    public boolean releaseAllWriters () {\n+    \tboolean released = writerPool.releaseAll();\n+    \tif (null != backupWriterPool && backupWriterPool.releaseAll()) {\n+    \t\treleased = true;\n+    \t}\n+    \treturn released;\n     }\n+    \n+\tpublic boolean releaseInactive() {\n+\t\tboolean useful = writerPool.releaseInactive();\n+\t\tuseful |= readerPool.releaseInactive();\n+\t\tif (null != backupWriterPool) {\n+\t\t\tuseful |= backupWriterPool.releaseInactive();", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cdbc63cbe5be9433a6c9e0ef139e654686a353b1", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/CairoEngine.java b/core/src/main/java/io/questdb/cairo/CairoEngine.java\nindex e01c424b7..208f22286 100644\n--- a/core/src/main/java/io/questdb/cairo/CairoEngine.java\n+++ b/core/src/main/java/io/questdb/cairo/CairoEngine.java\n\n@@ -218,18 +213,12 @@ public class CairoEngine implements Closeable {\n \n     public boolean releaseAllWriters () {\n     \tboolean released = writerPool.releaseAll();\n-    \tif (null != backupWriterPool && backupWriterPool.releaseAll()) {\n-    \t\treleased = true;\n-    \t}\n     \treturn released;\n     }\n     \n \tpublic boolean releaseInactive() {\n \t\tboolean useful = writerPool.releaseInactive();\n \t\tuseful |= readerPool.releaseInactive();\n-\t\tif (null != backupWriterPool) {\n-\t\t\tuseful |= backupWriterPool.releaseInactive();\n-\t\t}\n \t\treturn useful;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg0NzkwMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401847901", "bodyText": "If backup is a regular thing, which it might be, it would make sense to cache copiers. Copier can be cached against table name + structure version.", "author": "bluestreak01", "createdAt": "2020-04-01T19:12:29Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1035,23 +1088,27 @@ private void copyTable(SqlExecutionContext executionContext, CopyModel model) th\n     private TableWriter copyTableData(CharSequence tableName, RecordCursor cursor, RecordMetadata cursorMetadata) {\n         TableWriter writer = new TableWriter(configuration, tableName, messageBus, false, DefaultLifecycleManager.INSTANCE);\n         try {\n-            RecordMetadata writerMetadata = writer.getMetadata();\n-            entityColumnFilter.of(writerMetadata.getColumnCount());\n-            RecordToRowCopier recordToRowCopier = assembleRecordToRowCopier(asm, cursorMetadata, writerMetadata, entityColumnFilter);\n-\n-            int timestampIndex = writerMetadata.getTimestampIndex();\n-            if (timestampIndex == -1) {\n-                copyUnordered(cursor, writer, recordToRowCopier);\n-            } else {\n-                copyOrdered(writer, cursor, recordToRowCopier, timestampIndex);\n-            }\n+            copyTableData(cursor, cursorMetadata, writer);\n             return writer;\n         } catch (CairoException e) {\n             writer.close();\n             throw e;\n         }\n     }\n \n+\tpublic void copyTableData(RecordCursor cursor, RecordMetadata cursorMetadata, TableWriter writer) {\n+\t\tRecordMetadata writerMetadata = writer.getMetadata();\n+\t\tentityColumnFilter.of(writerMetadata.getColumnCount());\n+\t\tRecordToRowCopier recordToRowCopier = assembleRecordToRowCopier(asm, cursorMetadata, writerMetadata, entityColumnFilter);", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "281302eab06515beef3716944aafb6d40355e267", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0147eaee8..37c5f21a4 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1088,7 +1074,10 @@ public class SqlCompiler implements Closeable {\n     private TableWriter copyTableData(CharSequence tableName, RecordCursor cursor, RecordMetadata cursorMetadata) {\n         TableWriter writer = new TableWriter(configuration, tableName, messageBus, false, DefaultLifecycleManager.INSTANCE);\n         try {\n-            copyTableData(cursor, cursorMetadata, writer);\n+            RecordMetadata writerMetadata = writer.getMetadata();\n+            entityColumnFilter.of(writerMetadata.getColumnCount());\n+            RecordToRowCopier recordToRowCopier = assembleRecordToRowCopier(asm, cursorMetadata, writerMetadata, entityColumnFilter);\n+            copyTableData(cursor, writer, writerMetadata, recordToRowCopier);\n             return writer;\n         } catch (CairoException e) {\n             writer.close();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MDEyOQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401850129", "bodyText": "this can be replaced with existing expectKeyword call. It is a fairly standard thing to check in parser/compiler", "author": "bluestreak01", "createdAt": "2020-04-01T19:16:23Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a959e1f6252ef7f3acbcb21232f22285b26dfd", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0147eaee8..21977a554 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1680,7 +1651,7 @@ public class SqlCompiler implements Closeable {\n       }\n     \n \tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n-\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+        ObjHashSet<CharSequence> tableNames = new ObjHashSet<>();\n \t\twhile (true) {\n \t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n \t\t\tif (null == tok) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTIwOQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401851209", "bodyText": "perhaps backup needs its own result", "author": "bluestreak01", "createdAt": "2020-04-01T19:18:26Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {\n+\t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+\t\t\t}\n+\t\t\tCharSequence tableName = GenericLexer.unquote(tok);\n+\t\t\tint status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+\t\t\tif (status != TableUtils.TABLE_EXISTS) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+\t\t\t}\n+\t\t\ttableNames.add(tableName);\n+\n+\t\t\ttok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok || Chars.equals(tok, ';')) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (!Chars.equals(tok, ',')) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tfor (int n=0; n<tableNames.size(); n++) {\n+\t\t\tbackupTable(tableNames.get(n), executionContext);\n+\t\t}\n+\n+\t\treturn compiledQuery.ofRenameTable();", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a959e1f6252ef7f3acbcb21232f22285b26dfd", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0147eaee8..21977a554 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1680,7 +1651,7 @@ public class SqlCompiler implements Closeable {\n       }\n     \n \tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n-\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+        ObjHashSet<CharSequence> tableNames = new ObjHashSet<>();\n \t\twhile (true) {\n \t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n \t\t\tif (null == tok) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTQzNg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401851436", "bodyText": "concatenation remains", "author": "bluestreak01", "createdAt": "2020-04-01T19:18:49Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {\n+\t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+\t\t\t}\n+\t\t\tCharSequence tableName = GenericLexer.unquote(tok);\n+\t\t\tint status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+\t\t\tif (status != TableUtils.TABLE_EXISTS) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+\t\t\t}\n+\t\t\ttableNames.add(tableName);\n+\n+\t\t\ttok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok || Chars.equals(tok, ';')) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (!Chars.equals(tok, ',')) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tfor (int n=0; n<tableNames.size(); n++) {\n+\t\t\tbackupTable(tableNames.get(n), executionContext);\n+\t\t}\n+\n+\t\treturn compiledQuery.ofRenameTable();\n+\t}\n+    \n+\tpublic void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+\t\tLOG.info().$(\"Starting backup of \").$(tableName).$();\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\tCairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode(), (TableReaderMetadata) reader.getMetadata());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcopyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t\tLOG.info().$(\"Completed backup of \").$(tableName).$();\n+\t}\n+\n+\tprivate void cloneMetaData(CharSequence tableName, CharSequence root, CharSequence backupRoot, int mkDirMode, TableReaderMetadata sourceMetaData) {\n+\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n+\n+\t\tif (ff.exists(path)) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a959e1f6252ef7f3acbcb21232f22285b26dfd", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0147eaee8..21977a554 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1680,7 +1651,7 @@ public class SqlCompiler implements Closeable {\n       }\n     \n \tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n-\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+        ObjHashSet<CharSequence> tableNames = new ObjHashSet<>();\n \t\twhile (true) {\n \t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n \t\t\tif (null == tok) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MjcwNg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401852706", "bodyText": "128 and true need to be taken from source metadata", "author": "bluestreak01", "createdAt": "2020-04-01T19:21:12Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {\n+\t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+\t\t\t}\n+\t\t\tCharSequence tableName = GenericLexer.unquote(tok);\n+\t\t\tint status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+\t\t\tif (status != TableUtils.TABLE_EXISTS) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+\t\t\t}\n+\t\t\ttableNames.add(tableName);\n+\n+\t\t\ttok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok || Chars.equals(tok, ';')) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (!Chars.equals(tok, ',')) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tfor (int n=0; n<tableNames.size(); n++) {\n+\t\t\tbackupTable(tableNames.get(n), executionContext);\n+\t\t}\n+\n+\t\treturn compiledQuery.ofRenameTable();\n+\t}\n+    \n+\tpublic void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+\t\tLOG.info().$(\"Starting backup of \").$(tableName).$();\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\tCairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode(), (TableReaderMetadata) reader.getMetadata());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcopyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t\tLOG.info().$(\"Completed backup of \").$(tableName).$();\n+\t}\n+\n+\tprivate void cloneMetaData(CharSequence tableName, CharSequence root, CharSequence backupRoot, int mkDirMode, TableReaderMetadata sourceMetaData) {\n+\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n+\n+\t\tif (ff.exists(path)) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');\n+\t\t}\n+\n+\t\tif (ff.mkdirs(path, mkDirMode) != 0) {\n+\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+\t\t}\n+\n+\t\tint rootLen = path.length();\n+\t\ttry {\n+\t\t\tmem.of(ff, path.trimTo(rootLen).concat(TableUtils.META_FILE_NAME).$(), ff.getPageSize());\n+\t\t\tsourceMetaData.cloneTo(mem);\n+\t\n+\t\t\t// create symbol maps\n+\t\t\tpath.trimTo(rootLen).$();\n+\t\t\tint symbolMapCount = 0;\n+\t\t\tfor (int i = 0; i < sourceMetaData.getColumnCount(); i++) {\n+\t\t\t\tif (sourceMetaData.getColumnType(i) == ColumnType.SYMBOL) {\n+\t\t\t\t\tSymbolMapWriter.createSymbolMapFiles(ff, mem, path, sourceMetaData.getColumnName(i), 128, true);", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a959e1f6252ef7f3acbcb21232f22285b26dfd", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0147eaee8..21977a554 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1680,7 +1651,7 @@ public class SqlCompiler implements Closeable {\n       }\n     \n \tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n-\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+        ObjHashSet<CharSequence> tableNames = new ObjHashSet<>();\n \t\twhile (true) {\n \t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n \t\t\tif (null == tok) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1Nzc3Mw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401857773", "bodyText": "reader.getCursor() is an oddball here. It must not be closed, otherwise it detaches from reader.\nObviously we need a test that shows backup can run multiple times", "author": "bluestreak01", "createdAt": "2020-04-01T19:30:23Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {\n+\t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+\t\t\t}\n+\t\t\tCharSequence tableName = GenericLexer.unquote(tok);\n+\t\t\tint status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+\t\t\tif (status != TableUtils.TABLE_EXISTS) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+\t\t\t}\n+\t\t\ttableNames.add(tableName);\n+\n+\t\t\ttok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok || Chars.equals(tok, ';')) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (!Chars.equals(tok, ',')) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tfor (int n=0; n<tableNames.size(); n++) {\n+\t\t\tbackupTable(tableNames.get(n), executionContext);\n+\t\t}\n+\n+\t\treturn compiledQuery.ofRenameTable();\n+\t}\n+    \n+\tpublic void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+\t\tLOG.info().$(\"Starting backup of \").$(tableName).$();\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\tCairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode(), (TableReaderMetadata) reader.getMetadata());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a959e1f6252ef7f3acbcb21232f22285b26dfd", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0147eaee8..21977a554 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1680,7 +1651,7 @@ public class SqlCompiler implements Closeable {\n       }\n     \n \tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n-\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+        ObjHashSet<CharSequence> tableNames = new ObjHashSet<>();\n \t\twhile (true) {\n \t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n \t\t\tif (null == tok) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1ODMyNg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401858326", "bodyText": "This perhaps need to be a set? What if someone specifies the same table name several times in the list of tables?\nThis needs a test too.", "author": "bluestreak01", "createdAt": "2020-04-01T19:31:25Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a959e1f6252ef7f3acbcb21232f22285b26dfd", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0147eaee8..21977a554 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1680,7 +1651,7 @@ public class SqlCompiler implements Closeable {\n       }\n     \n \tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n-\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+        ObjHashSet<CharSequence> tableNames = new ObjHashSet<>();\n \t\twhile (true) {\n \t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n \t\t\tif (null == tok) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1OTEyNQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401859125", "bodyText": "this is an ok loop, but not the fastest. Loops around our codebase consistently use the following syntax:\nfor (int i = 0, n = obj.size(); i < n; i++) {\n}", "author": "bluestreak01", "createdAt": "2020-04-01T19:32:42Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {\n+\t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+\t\t\t}\n+\t\t\tCharSequence tableName = GenericLexer.unquote(tok);\n+\t\t\tint status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+\t\t\tif (status != TableUtils.TABLE_EXISTS) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+\t\t\t}\n+\t\t\ttableNames.add(tableName);\n+\n+\t\t\ttok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok || Chars.equals(tok, ';')) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (!Chars.equals(tok, ',')) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tfor (int n=0; n<tableNames.size(); n++) {\n+\t\t\tbackupTable(tableNames.get(n), executionContext);\n+\t\t}\n+\n+\t\treturn compiledQuery.ofRenameTable();\n+\t}\n+    \n+\tpublic void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+\t\tLOG.info().$(\"Starting backup of \").$(tableName).$();\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\tCairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode(), (TableReaderMetadata) reader.getMetadata());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcopyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t\tLOG.info().$(\"Completed backup of \").$(tableName).$();\n+\t}\n+\n+\tprivate void cloneMetaData(CharSequence tableName, CharSequence root, CharSequence backupRoot, int mkDirMode, TableReaderMetadata sourceMetaData) {\n+\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n+\n+\t\tif (ff.exists(path)) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');\n+\t\t}\n+\n+\t\tif (ff.mkdirs(path, mkDirMode) != 0) {\n+\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+\t\t}\n+\n+\t\tint rootLen = path.length();\n+\t\ttry {\n+\t\t\tmem.of(ff, path.trimTo(rootLen).concat(TableUtils.META_FILE_NAME).$(), ff.getPageSize());\n+\t\t\tsourceMetaData.cloneTo(mem);\n+\t\n+\t\t\t// create symbol maps\n+\t\t\tpath.trimTo(rootLen).$();\n+\t\t\tint symbolMapCount = 0;\n+\t\t\tfor (int i = 0; i < sourceMetaData.getColumnCount(); i++) {", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a959e1f6252ef7f3acbcb21232f22285b26dfd", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0147eaee8..21977a554 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1680,7 +1651,7 @@ public class SqlCompiler implements Closeable {\n       }\n     \n \tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n-\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+        ObjHashSet<CharSequence> tableNames = new ObjHashSet<>();\n \t\twhile (true) {\n \t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n \t\t\tif (null == tok) {\n"}}, {"oid": "e65cd766bc952fb40a9ae660bc3be7587991f730", "url": "https://github.com/questdb/questdb/commit/e65cd766bc952fb40a9ae660bc3be7587991f730", "message": "Merge remote-tracking branch 'origin/master' into table-backup2", "committedDate": "2020-04-06T08:23:38Z", "type": "commit"}, {"oid": "16a959e1f6252ef7f3acbcb21232f22285b26dfd", "url": "https://github.com/questdb/questdb/commit/16a959e1f6252ef7f3acbcb21232f22285b26dfd", "message": "feat(griffin): add table backup", "committedDate": "2020-04-06T08:43:51Z", "type": "commit"}, {"oid": "f0cf50472cf2bac9f826542ce489156db6239ec9", "url": "https://github.com/questdb/questdb/commit/f0cf50472cf2bac9f826542ce489156db6239ec9", "message": "feat(griffin): add table backup", "committedDate": "2020-04-06T09:01:42Z", "type": "commit"}, {"oid": "cdbc63cbe5be9433a6c9e0ef139e654686a353b1", "url": "https://github.com/questdb/questdb/commit/cdbc63cbe5be9433a6c9e0ef139e654686a353b1", "message": "feat(griffin): add table backup", "committedDate": "2020-04-07T15:34:05Z", "type": "commit"}, {"oid": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "url": "https://github.com/questdb/questdb/commit/e9f78ad9b44a657e8344bbeeff99288c17410dc1", "message": "feat(griffin): add database backup", "committedDate": "2020-04-07T16:21:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwMDc3MQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405500771", "bodyText": "can be simplified, right?", "author": "bluestreak01", "createdAt": "2020-04-08T12:53:29Z", "path": "core/src/main/java/io/questdb/cairo/CairoEngine.java", "diffHunk": "@@ -199,14 +211,16 @@ public boolean releaseAllReaders() {\n         return readerPool.releaseAll();\n     }\n \n-    public boolean releaseAllWriters() {\n-        return writerPool.releaseAll();\n-    }\n-\n-    public void releaseInactive() {\n-        writerPool.releaseInactive();\n-        readerPool.releaseInactive();\n+    public boolean releaseAllWriters () {\n+    \tboolean released = writerPool.releaseAll();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/CairoEngine.java b/core/src/main/java/io/questdb/cairo/CairoEngine.java\nindex 208f22286..2164190ff 100644\n--- a/core/src/main/java/io/questdb/cairo/CairoEngine.java\n+++ b/core/src/main/java/io/questdb/cairo/CairoEngine.java\n\n@@ -212,8 +212,7 @@ public class CairoEngine implements Closeable {\n     }\n \n     public boolean releaseAllWriters () {\n-    \tboolean released = writerPool.releaseAll();\n-    \treturn released;\n+        return writerPool.releaseAll();\n     }\n     \n \tpublic boolean releaseInactive() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwMzA0OQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405503049", "bodyText": "formatting still off", "author": "bluestreak01", "createdAt": "2020-04-08T12:57:12Z", "path": "core/src/main/java/io/questdb/cairo/TableWriter.java", "diffHunk": "@@ -140,6 +140,17 @@ public TableWriter(\n             @Nullable MessageBus messageBus,\n             boolean lock,\n             LifecycleManager lifecycleManager\n+    ) {\n+    \tthis(configuration, name, messageBus, lock, lifecycleManager, configuration.getRoot());", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU0NjM2MQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405546361", "bodyText": "Are you sure? Looks consistent to me. line 143 and 154 are exactly the same", "author": "patrickSpaceSurfer", "createdAt": "2020-04-08T13:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwMzA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3NjUxMg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407976512", "bodyText": "I reformatted the method and something did change other on eclipse it looks the same, I guess there was a tab hidden somewhere...", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T08:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwMzA0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a26ced865d7885399d0d7e9762f44bd9a6bbf463", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/TableWriter.java b/core/src/main/java/io/questdb/cairo/TableWriter.java\nindex 2190769ee..be34a70a1 100644\n--- a/core/src/main/java/io/questdb/cairo/TableWriter.java\n+++ b/core/src/main/java/io/questdb/cairo/TableWriter.java\n\n@@ -141,7 +141,7 @@ public class TableWriter implements Closeable {\n             boolean lock,\n             LifecycleManager lifecycleManager\n     ) {\n-    \tthis(configuration, name, messageBus, lock, lifecycleManager, configuration.getRoot());\n+        this(configuration, name, messageBus, lock, lifecycleManager, configuration.getRoot());\n     }\n \n     public TableWriter(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNDg3Ng==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405504876", "bodyText": "i think it should be lexer.getLastTokenPosition. You are reporting wrong token in SQL, using this code position will be behind this token.", "author": "bluestreak01", "createdAt": "2020-04-08T12:59:56Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 6e19a7c86..fe314a21e 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1662,24 +1666,28 @@ public class SqlCompiler implements Closeable {\n             }\n         }\n \n-        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n     }\n \n-    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n-        setupBackupRenamePath();\n-        // TODO: Cache the nativeLPSZ\n-        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n-        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n-            nativeLPSZ.of(file);\n-            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-                backupTable(nativeLPSZ, executionContext);\n-            }\n-        });\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n \n-        return compiledQuery.ofBackupTable();\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n     }\n \n-\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n         setupBackupRenamePath();\n \n         @SuppressWarnings(\"unchecked\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNTA1OA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405505058", "bodyText": "indeed, lets cache", "author": "bluestreak01", "createdAt": "2020-04-08T13:00:15Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 6e19a7c86..fe314a21e 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1662,24 +1666,28 @@ public class SqlCompiler implements Closeable {\n             }\n         }\n \n-        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n     }\n \n-    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n-        setupBackupRenamePath();\n-        // TODO: Cache the nativeLPSZ\n-        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n-        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n-            nativeLPSZ.of(file);\n-            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-                backupTable(nativeLPSZ, executionContext);\n-            }\n-        });\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n \n-        return compiledQuery.ofBackupTable();\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n     }\n \n-\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n         setupBackupRenamePath();\n \n         @SuppressWarnings(\"unchecked\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNTU1Nw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405505557", "bodyText": "Lambda should be refactored into a method, will play nicely with caching nativeLPSZ", "author": "bluestreak01", "createdAt": "2020-04-08T13:01:00Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1MDU3NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405550574", "bodyText": "True, however I have seen other code where lambdas are used in this way, thats why I did it. Lambdas always allocate unless you have a field set to the method, so I'll change it here and anywhere else I see it", "author": "patrickSpaceSurfer", "createdAt": "2020-04-08T14:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNTU1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 6e19a7c86..fe314a21e 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1662,24 +1666,28 @@ public class SqlCompiler implements Closeable {\n             }\n         }\n \n-        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n     }\n \n-    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n-        setupBackupRenamePath();\n-        // TODO: Cache the nativeLPSZ\n-        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n-        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n-            nativeLPSZ.of(file);\n-            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-                backupTable(nativeLPSZ, executionContext);\n-            }\n-        });\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n \n-        return compiledQuery.ofBackupTable();\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n     }\n \n-\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n         setupBackupRenamePath();\n \n         @SuppressWarnings(\"unchecked\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNjQxMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405506411", "bodyText": "why would this not be typed?", "author": "bluestreak01", "createdAt": "2020-04-08T13:02:18Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -73,6 +129,8 @@\n     private final ExecutableMethod createTableMethod = this::createTable;\n     private final TextLoader textLoader;\n     private final FilesFacade ff;\n+    private final ObjHashSet<?> cachedObjSet = new ObjHashSet<>();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU0ODMxOA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405548318", "bodyText": "The idea is that it can be used for any purpose required, I use it with CharSequence in sqlTableBackup, but it could be used anywhere a ObjHashSet is required, just needs to be cleared when the method completes. I can change this to CharSequence but then maybe change the name too", "author": "patrickSpaceSurfer", "createdAt": "2020-04-08T14:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNjQxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 6e19a7c86..fe314a21e 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -130,6 +131,8 @@ public class SqlCompiler implements Closeable {\n     private final TextLoader textLoader;\n     private final FilesFacade ff;\n     private final ObjHashSet<?> cachedObjSet = new ObjHashSet<>();\n+    private final NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+    private transient SqlExecutionContext currentExecutionContext;\n \n     public SqlCompiler(CairoEngine engine) {\n         this(engine, null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNzM4NQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405507385", "bodyText": "same as before, lastTokenPosition() should be used", "author": "bluestreak01", "createdAt": "2020-04-08T13:03:44Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unquote(tok);\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 6e19a7c86..fe314a21e 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1662,24 +1666,28 @@ public class SqlCompiler implements Closeable {\n             }\n         }\n \n-        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n     }\n \n-    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n-        setupBackupRenamePath();\n-        // TODO: Cache the nativeLPSZ\n-        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n-        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n-            nativeLPSZ.of(file);\n-            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-                backupTable(nativeLPSZ, executionContext);\n-            }\n-        });\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n \n-        return compiledQuery.ofBackupTable();\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n     }\n \n-\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n         setupBackupRenamePath();\n \n         @SuppressWarnings(\"unchecked\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNzgzMg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405507832", "bodyText": "and here", "author": "bluestreak01", "createdAt": "2020-04-08T13:04:19Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNzk1NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405507954", "bodyText": "are there tests?", "author": "bluestreak01", "createdAt": "2020-04-08T13:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNzgzMg=="}], "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 6e19a7c86..fe314a21e 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1662,24 +1666,28 @@ public class SqlCompiler implements Closeable {\n             }\n         }\n \n-        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n     }\n \n-    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n-        setupBackupRenamePath();\n-        // TODO: Cache the nativeLPSZ\n-        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n-        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n-            nativeLPSZ.of(file);\n-            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-                backupTable(nativeLPSZ, executionContext);\n-            }\n-        });\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n \n-        return compiledQuery.ofBackupTable();\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n     }\n \n-\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n         setupBackupRenamePath();\n \n         @SuppressWarnings(\"unchecked\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwODYwMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405508601", "bodyText": "there are date library functions for these", "author": "bluestreak01", "createdAt": "2020-04-08T13:05:28Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unquote(tok);\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+\t}\n+\n+    private void setupBackupRenamePath() {\n+        // TODO: Use a formatter that produces less garbage\n+        DateTimeFormatter formatter = configuration.getBackupDirDateTimeFormatter();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 6e19a7c86..fe314a21e 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1662,24 +1666,28 @@ public class SqlCompiler implements Closeable {\n             }\n         }\n \n-        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n     }\n \n-    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n-        setupBackupRenamePath();\n-        // TODO: Cache the nativeLPSZ\n-        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n-        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n-            nativeLPSZ.of(file);\n-            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-                backupTable(nativeLPSZ, executionContext);\n-            }\n-        });\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n \n-        return compiledQuery.ofBackupTable();\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n     }\n \n-\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n         setupBackupRenamePath();\n \n         @SuppressWarnings(\"unchecked\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwOTE1Mw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405509153", "bodyText": "path should support printing \"int\"", "author": "bluestreak01", "createdAt": "2020-04-08T13:06:23Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unquote(tok);\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+\t}\n+\n+    private void setupBackupRenamePath() {\n+        // TODO: Use a formatter that produces less garbage\n+        DateTimeFormatter formatter = configuration.getBackupDirDateTimeFormatter();\n+        String subDirNm = formatter.format(LocalDate.now());\n+        int n = 0;\n+        // TODO: There is a race here, to threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR).concat(subDirNm);\n+            if (n > 0) {\n+                renamePath.put('.').put(Integer.valueOf(n).toString());", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 6e19a7c86..fe314a21e 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1662,24 +1666,28 @@ public class SqlCompiler implements Closeable {\n             }\n         }\n \n-        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n     }\n \n-    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n-        setupBackupRenamePath();\n-        // TODO: Cache the nativeLPSZ\n-        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n-        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n-            nativeLPSZ.of(file);\n-            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-                backupTable(nativeLPSZ, executionContext);\n-            }\n-        });\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n \n-        return compiledQuery.ofBackupTable();\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n     }\n \n-\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n         setupBackupRenamePath();\n \n         @SuppressWarnings(\"unchecked\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMDE5OA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405510198", "bodyText": "\"tmp\" should probably be a config", "author": "bluestreak01", "createdAt": "2020-04-08T13:07:59Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unquote(tok);\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+\t}\n+\n+    private void setupBackupRenamePath() {\n+        // TODO: Use a formatter that produces less garbage\n+        DateTimeFormatter formatter = configuration.getBackupDirDateTimeFormatter();\n+        String subDirNm = formatter.format(LocalDate.now());\n+        int n = 0;\n+        // TODO: There is a race here, to threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR).concat(subDirNm);\n+            if (n > 0) {\n+                renamePath.put('.').put(Integer.valueOf(n).toString());\n+            }\n+            renamePath.put(Files.SEPARATOR).$();\n+            n++;\n+        } while (ff.exists(renamePath));\n+        if (ff.mkdirs(renamePath, configuration.getMkDirMode()) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"could not create [dir=\").put(renamePath).put(']');\n+        }\n+    }\n+    \n+    private transient String cachedTmpBackupRoot;\n+\n+    private void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+        LOG.info().$(\"Starting backup of \").$(tableName).$();\n+        if (null == cachedTmpBackupRoot) {\n+            if (null == configuration.getBackupRoot()) {\n+                throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+            }\n+            path.of(configuration.getBackupRoot()).concat(\"tmp\").put(Files.SEPARATOR).$();\n+            cachedTmpBackupRoot = path.toString();\n+            if (!ff.exists(path)) {\n+                LOG.info().$(\"Creating backup directory \").$(cachedTmpBackupRoot).$();\n+                if (ff.mkdirs(path, configuration.getMkDirMode()) != 0) {\n+                    throw CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+                }\n+            }\n+        }\n+\n+        CairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+        try (TableReader reader = engine.getReader(securityContext, tableName)) {\n+            cloneMetaData(tableName, configuration.getRoot(), cachedTmpBackupRoot, configuration.getMkDirMode(), reader);\n+            try (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName, cachedTmpBackupRoot)) {\n+                RecordCursor cursor = reader.getCursor();\n+                copyTableData(cursor, reader.getMetadata(), backupWriter);\n+                backupWriter.commit();\n+            }\n+        }\n+\n+        path.of(configuration.getBackupRoot()).concat(\"tmp\").put(Files.SEPARATOR).concat(tableName).$();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 6e19a7c86..fe314a21e 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1662,24 +1666,28 @@ public class SqlCompiler implements Closeable {\n             }\n         }\n \n-        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n     }\n \n-    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n-        setupBackupRenamePath();\n-        // TODO: Cache the nativeLPSZ\n-        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n-        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n-            nativeLPSZ.of(file);\n-            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-                backupTable(nativeLPSZ, executionContext);\n-            }\n-        });\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n \n-        return compiledQuery.ofBackupTable();\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n     }\n \n-\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n         setupBackupRenamePath();\n \n         @SuppressWarnings(\"unchecked\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNTA1NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405515054", "bodyText": "formatting", "author": "bluestreak01", "createdAt": "2020-04-08T13:15:07Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unquote(tok);\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+\t}\n+\n+    private void setupBackupRenamePath() {\n+        // TODO: Use a formatter that produces less garbage\n+        DateTimeFormatter formatter = configuration.getBackupDirDateTimeFormatter();\n+        String subDirNm = formatter.format(LocalDate.now());\n+        int n = 0;\n+        // TODO: There is a race here, to threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR).concat(subDirNm);\n+            if (n > 0) {\n+                renamePath.put('.').put(Integer.valueOf(n).toString());\n+            }\n+            renamePath.put(Files.SEPARATOR).$();\n+            n++;\n+        } while (ff.exists(renamePath));\n+        if (ff.mkdirs(renamePath, configuration.getMkDirMode()) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"could not create [dir=\").put(renamePath).put(']');\n+        }\n+    }\n+    \n+    private transient String cachedTmpBackupRoot;\n+\n+    private void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+        LOG.info().$(\"Starting backup of \").$(tableName).$();\n+        if (null == cachedTmpBackupRoot) {\n+            if (null == configuration.getBackupRoot()) {\n+                throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+            }\n+            path.of(configuration.getBackupRoot()).concat(\"tmp\").put(Files.SEPARATOR).$();\n+            cachedTmpBackupRoot = path.toString();\n+            if (!ff.exists(path)) {\n+                LOG.info().$(\"Creating backup directory \").$(cachedTmpBackupRoot).$();\n+                if (ff.mkdirs(path, configuration.getMkDirMode()) != 0) {\n+                    throw CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+                }\n+            }\n+        }\n+\n+        CairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+        try (TableReader reader = engine.getReader(securityContext, tableName)) {\n+            cloneMetaData(tableName, configuration.getRoot(), cachedTmpBackupRoot, configuration.getMkDirMode(), reader);\n+            try (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName, cachedTmpBackupRoot)) {\n+                RecordCursor cursor = reader.getCursor();\n+                copyTableData(cursor, reader.getMetadata(), backupWriter);\n+                backupWriter.commit();\n+            }\n+        }\n+\n+        path.of(configuration.getBackupRoot()).concat(\"tmp\").put(Files.SEPARATOR).concat(tableName).$();\n+        int renameRootLen = renamePath.length();\n+        try {\n+            renamePath.trimTo(renameRootLen).concat(tableName).$();\n+            if (!ff.rename(path, renamePath)) {\n+                throw CairoException.instance(ff.errno()).put(\"Could not rename [from=\").put(path).put(\", to=\").put(renamePath).put(']');\n+            }\n+            LOG.info().$(\"Completed backup of \").$(tableName).$(\" to \").$(renamePath).$();\n+        } finally {\n+            renamePath.trimTo(renameRootLen).$();\n+        }\n+    }\n+\n+    private void cloneMetaData(CharSequence tableName, CharSequence root, CharSequence backupRoot, int mkDirMode, TableReader reader) {\n+\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n+\n+\t\tif (ff.exists(path)) {\n+            throw CairoException.instance(0).put(\"Backup dir for table \\\"\").put(tableName).put(\"\\\" already exists [dir=\").put(path).put(']');\n+\t\t}\n+\n+\t\tif (ff.mkdirs(path, mkDirMode) != 0) {\n+\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+\t\t}\n+\n+        TableReaderMetadata sourceMetaData = (TableReaderMetadata) reader.getMetadata();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 6e19a7c86..fe314a21e 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1662,24 +1666,28 @@ public class SqlCompiler implements Closeable {\n             }\n         }\n \n-        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n     }\n \n-    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n-        setupBackupRenamePath();\n-        // TODO: Cache the nativeLPSZ\n-        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n-        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n-            nativeLPSZ.of(file);\n-            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-                backupTable(nativeLPSZ, executionContext);\n-            }\n-        });\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n \n-        return compiledQuery.ofBackupTable();\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n     }\n \n-\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n         setupBackupRenamePath();\n \n         @SuppressWarnings(\"unchecked\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNjk4Mw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405516983", "bodyText": "in this instance it isn't necessary to pass table twice", "author": "bluestreak01", "createdAt": "2020-04-08T13:17:56Z", "path": "core/src/test/java/io/questdb/griffin/TableBackupTest.java", "diffHunk": "@@ -0,0 +1,324 @@\n+package io.questdb.griffin;\n+\n+import java.io.IOException;\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import io.questdb.MessageBus;\n+import io.questdb.MessageBusImpl;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.DefaultCairoConfiguration;\n+import io.questdb.cairo.RecordCursorPrinter;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordCursorFactory;\n+import io.questdb.griffin.engine.functions.bind.BindVariableService;\n+import io.questdb.std.Files;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.test.tools.TestUtils;\n+\n+public class TableBackupTest {\n+    private static final StringSink sink = new StringSink();\n+    private static final RecordCursorPrinter printer = new RecordCursorPrinter(sink);\n+    @Rule\n+    public TemporaryFolder temp = new TemporaryFolder();\n+\n+    private CharSequence backupRoot;\n+    private Path finalBackupPath;\n+\n+    private CairoConfiguration mainConfiguration;\n+    private CairoEngine mainEngine;\n+    private SqlCompiler mainCompiler;\n+    private SqlExecutionContext mainSqlExecutionContext;\n+\n+    @Test\n+    public void simpleTableTest1() throws Exception {\n+        assertMemoryLeak(() -> {\n+            String tableName = \"testTable1\";\n+            // @formatter:off\n+            mainCompiler.compile(\"create table \" + tableName + \" as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+            setFinalBackupPath();\n+            String sourceSelectAll = selectAll(tableName, false);\n+            String backupSelectAll = selectAll(tableName, true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+        });\n+    }\n+\n+    @Test\n+    public void allTypesPartitionedTableTest1() throws Exception {\n+        assertMemoryLeak(() -> {\n+            String tableName = \"testTable2\";\n+            // @formatter:off\n+            mainCompiler.compile(\"create table \" + tableName + \" as (\" +\n+                    \"select\" +\n+                    \" rnd_char() ch,\" +\n+                    \" rnd_long256() ll,\" +\n+                    \" rnd_int() a1,\" +\n+                    \" rnd_int(0, 30, 2) a,\" +\n+                    \" rnd_boolean() b,\" +\n+                    \" rnd_str(3,3,2) c,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" rnd_float(2) e,\" +\n+                    \" rnd_short(10,1024) f,\" +\n+                    \" rnd_short() f1,\" +\n+                    \" rnd_date(to_date('2015', 'yyyy'), to_date('2016', 'yyyy'), 2) g,\" +\n+                    \" rnd_timestamp(to_timestamp('2015', 'yyyy'), to_timestamp('2016', 'yyyy'), 2) h,\" +\n+                    \" rnd_symbol(4,4,4,2) i,\" +\n+                    \" rnd_long(100,200,2) j,\" +\n+                    \" rnd_long() j1,\" +\n+                    \" timestamp_sequence(0, 1000000000) k,\" +\n+                    \" rnd_byte(2,50) l,\" +\n+                    \" rnd_bin(10, 20, 2) m\" +\n+                    \" from long_sequence(1000)\" +\n+                    \")  timestamp(k) partition by DAY\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+            setFinalBackupPath();\n+            String sourceSelectAll = selectAll(tableName, false);\n+            String backupSelectAll = selectAll(tableName, true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+        });\n+    }\n+\n+    @Test\n+    public void multipleTableTest() throws Exception {\n+        assertMemoryLeak(() -> {\n+            // @formatter:off\n+            mainCompiler.compile(\"create table tb1 as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+            mainCompiler.compile(\"create table tb2 as (select\" +\n+                    \" rnd_long256() ll,\" +\n+                    \" timestamp_sequence(10000000000, 500000000) ts\" +\n+                    \" from long_sequence(100000)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table tb1, tb2\", mainSqlExecutionContext);\n+\n+            setFinalBackupPath();\n+\n+            String sourceSelectAll = selectAll(\"tb1\", false);\n+            String backupSelectAll = selectAll(\"tb1\", true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+\n+            sourceSelectAll = selectAll(\"tb2\", false);\n+            backupSelectAll = selectAll(\"tb2\", true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+        });\n+    }\n+\n+    @Test\n+    public void successiveBackupsTest() throws Exception {\n+        assertMemoryLeak(() -> {\n+            String tableName = \"testTable1\";\n+            // @formatter:off\n+            mainCompiler.compile(\"create table \" + tableName + \" as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+            setFinalBackupPath();\n+            String sourceSelectAll = selectAll(tableName, false);\n+            String backupSelectAll1 = selectAll(tableName, true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll1);\n+\n+            // @formatter:off\n+            mainCompiler.compile(\"insert into \" + tableName +\n+                    \" select * from (\" +\n+                    \" select rnd_symbol(4,4,4,2) sym, rnd_double(2) d, timestamp_sequence(10000000000, 500000000) ts from long_sequence(5)\" +\n+                    \") timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+\n+            sourceSelectAll = selectAll(tableName, false);\n+            setFinalBackupPath(1);\n+            String backupSelectAll2 = selectAll(tableName, true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll2);\n+\n+            // Check previous backup is unaffected\n+            setFinalBackupPath();\n+            String backupSelectAllOriginal = selectAll(tableName, true);\n+            Assert.assertEquals(backupSelectAll1, backupSelectAllOriginal);\n+        });\n+    }\n+\n+    @Test(expected = SqlException.class)\n+    public void missingTableTest() throws Exception {\n+        assertMemoryLeak(() -> {\n+            // @formatter:off\n+            mainCompiler.compile(\"create table tb1 as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table tb1, tb2\", mainSqlExecutionContext);\n+        });\n+    }\n+\n+    @Test(expected = CairoException.class)\n+    public void incorrectConfigTest() throws Exception {\n+        backupRoot = null;\n+        assertMemoryLeak(() -> {\n+            String tableName = \"testTable1\";\n+            // @formatter:off\n+            mainCompiler.compile(\"create table \" + tableName + \" as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+        });\n+    }\n+\n+    @Test\n+    public void backupDatabaseTest() throws Exception {\n+        assertMemoryLeak(() -> {\n+            // @formatter:off\n+            mainCompiler.compile(\"create table tb1 as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+            mainCompiler.compile(\"create table tb2 as (select\" +\n+                    \" rnd_long256() ll,\" +\n+                    \" timestamp_sequence(10000000000, 500000000) ts\" +\n+                    \" from long_sequence(100000)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup database\", mainSqlExecutionContext);\n+\n+            setFinalBackupPath();\n+\n+            String sourceSelectAll = selectAll(\"tb1\", false);\n+            String backupSelectAll = selectAll(\"tb1\", true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+\n+            sourceSelectAll = selectAll(\"tb2\", false);\n+            backupSelectAll = selectAll(\"tb2\", true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+        });\n+    }\n+\n+    private void setFinalBackupPath() {\n+        setFinalBackupPath(0);\n+    }\n+\n+    private void setFinalBackupPath(int n) {\n+        DateTimeFormatter formatter = mainConfiguration.getBackupDirDateTimeFormatter();\n+        String subDirNm = formatter.format(LocalDate.now());\n+        if (n > 0) {\n+            subDirNm += \".\" + n;\n+        }\n+        finalBackupPath.of(mainConfiguration.getBackupRoot()).put(Files.SEPARATOR).concat(subDirNm).put(Files.SEPARATOR).$();\n+    }\n+\n+    private String selectAll(String tableName, boolean backup) throws Exception {\n+        CairoEngine engine = null;\n+        SqlCompiler compiler = null;\n+        SqlExecutionContext sqlExecutionContext;\n+        try {\n+            if (backup) {\n+                CairoConfiguration backupConfiguration = new DefaultCairoConfiguration(finalBackupPath.toString());\n+                MessageBus backupMessageBus = new MessageBusImpl();\n+                sqlExecutionContext = new SqlExecutionContextImpl().with(AllowAllCairoSecurityContext.INSTANCE, new BindVariableService(), backupMessageBus);\n+                engine = new CairoEngine(backupConfiguration, backupMessageBus);\n+                compiler = new SqlCompiler(engine);\n+            } else {\n+                engine = mainEngine;\n+                compiler = mainCompiler;\n+                sqlExecutionContext = mainSqlExecutionContext;\n+            }\n+            return selectAll(engine, compiler, sqlExecutionContext, tableName);\n+        } finally {\n+            if (backup) {\n+                engine.close();\n+                compiler.close();\n+            }\n+        }\n+    }\n+\n+    private String selectAll(CairoEngine engine, SqlCompiler compiler, SqlExecutionContext sqlExecutionContext, String tableName) throws Exception {\n+        CompiledQuery compiledQuery = compiler.compile(\"select * from \" + tableName, sqlExecutionContext);\n+        try (RecordCursorFactory factory = compiledQuery.getRecordCursorFactory(); RecordCursor cursor = factory.getCursor(sqlExecutionContext)) {\n+            sink.clear();\n+            printer.print(cursor, factory.getMetadata(), true);\n+            cursor.toTop();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "chunk": "diff --git a/core/src/test/java/io/questdb/griffin/TableBackupTest.java b/core/src/test/java/io/questdb/griffin/TableBackupTest.java\nindex e93c4a902..00d5e5a70 100644\n--- a/core/src/test/java/io/questdb/griffin/TableBackupTest.java\n+++ b/core/src/test/java/io/questdb/griffin/TableBackupTest.java\n\n@@ -167,35 +167,47 @@ public class TableBackupTest {\n         });\n     }\n \n-    @Test(expected = SqlException.class)\n+    @Test\n     public void missingTableTest() throws Exception {\n         assertMemoryLeak(() -> {\n-            // @formatter:off\n-            mainCompiler.compile(\"create table tb1 as (select\" +\n-                    \" rnd_symbol(4,4,4,2) sym,\" +\n-                    \" rnd_double(2) d,\" +\n-                    \" timestamp_sequence(0, 1000000000) ts\" +\n-                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n-            // @formatter:on\n-\n-            mainCompiler.compile(\"backup table tb1, tb2\", mainSqlExecutionContext);\n+            try {\n+                // @formatter:off\n+                mainCompiler.compile(\"create table tb1 as (select\" +\n+                        \" rnd_symbol(4,4,4,2) sym,\" +\n+                        \" rnd_double(2) d,\" +\n+                        \" timestamp_sequence(0, 1000000000) ts\" +\n+                        \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+                // @formatter:on\n+\n+                mainCompiler.compile(\"backup table tb1, tb2\", mainSqlExecutionContext);\n+                Assert.assertTrue(false);\n+            } catch (SqlException ex) {\n+                Assert.assertEquals(\"io.questdb.griffin.SqlException: [18]  'tb2' is not  a valid table\", ex.toString());\n+            }\n         });\n     }\n \n-    @Test(expected = CairoException.class)\n+    @Test\n     public void incorrectConfigTest() throws Exception {\n         backupRoot = null;\n         assertMemoryLeak(() -> {\n-            String tableName = \"testTable1\";\n-            // @formatter:off\n-            mainCompiler.compile(\"create table \" + tableName + \" as (select\" +\n-                    \" rnd_symbol(4,4,4,2) sym,\" +\n-                    \" rnd_double(2) d,\" +\n-                    \" timestamp_sequence(0, 1000000000) ts\" +\n-                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n-            // @formatter:on\n-\n-            mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+            try {\n+                String tableName = \"testTable1\";\n+                // @formatter:off\n+                mainCompiler.compile(\"create table \" + tableName + \" as (select\" +\n+                        \" rnd_symbol(4,4,4,2) sym,\" +\n+                        \" rnd_double(2) d,\" +\n+                        \" timestamp_sequence(0, 1000000000) ts\" +\n+                        \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+                // @formatter:on\n+\n+                mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+                Assert.assertTrue(false);\n+            } catch (CairoException ex) {\n+                Assert.assertEquals(\n+                        \"io.questdb.cairo.CairoException: [0] Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\",\n+                        ex.toString());\n+            }\n         });\n     }\n \n"}}, {"oid": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "url": "https://github.com/questdb/questdb/commit/0fd40db31aafe9a8210b9dffe22c9b29567b1534", "message": "feat(griffin): add database backup", "committedDate": "2020-04-08T15:53:43Z", "type": "commit"}, {"oid": "e1a453da2bc6541eaee9ccd6cd969be1c2794452", "url": "https://github.com/questdb/questdb/commit/e1a453da2bc6541eaee9ccd6cd969be1c2794452", "message": "feat(griffin): add database backup\n\treplace java.time.format.DateTimeFormatter with io.questdb.std.microtime.TimestampFormat", "committedDate": "2020-04-08T21:04:40Z", "type": "commit"}, {"oid": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "url": "https://github.com/questdb/questdb/commit/4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "message": "feat(griffin): add database backup", "committedDate": "2020-04-08T21:14:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0ODY3Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407048672", "bodyText": "SqlCompiler is generally not thread safe, Because we have fixed number of threads, each thread is assigned a compiler to use. Does this allow us to remove the todo?", "author": "bluestreak01", "createdAt": "2020-04-11T10:48:56Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+    }\n+\n+    private void setupBackupRenamePath() {\n+        TimestampFormat format = configuration.getBackupDirTimestampFormat();\n+        long epochMicros = configuration.getMicrosecondClock().getTicks();\n+        int n = 0;\n+        // TODO: There is a race here, two threads could try and create the same renamePath, only one will succeed the other will throw", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDM3OQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407990379", "bodyText": "I am happy to remove it. Even if two thread run exactly at the same time one will succeed and one will fail, it should not trash anything, will remove the TODO but leave the comment", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T09:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0ODY3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a26ced865d7885399d0d7e9762f44bd9a6bbf463", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0af003d95..c9390a30f 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1672,7 +1672,11 @@ public class SqlCompiler implements Closeable {\n     private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n         nativeLPSZ.of(file);\n         if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-            backupTable(nativeLPSZ, currentExecutionContext);\n+            try {\n+                backupTable(nativeLPSZ, currentExecutionContext);\n+            } catch (CairoException ex) {\n+                LOG.error().$(\"Failed to backup \").$(nativeLPSZ).$(\": \").$(ex.getFlyweightMessage()).$();\n+            }\n         }\n     };\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0ODkxNA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407048914", "bodyText": "you may not have known this, but to avoid copying the same string to path over and over Path supports trimTo() method. For example this code will do the same thing as original loop:\nrenamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR);\nint plen = renamePath.length();\ndo {\n    renamePath.trimTo(plen);\n    format.format(\n         epochMicros, \n         TimestampLocaleFactory.INSTANCE.getDefaultTimestampLocale(), \n         null, \n         renamePath\n    );\n    if (n > 0) {\n        renamePath.put('.').put(n);\n     }\n     renamePath.put(Files.SEPARATOR).$();\n} while(ff.exists(renamePath));", "author": "bluestreak01", "createdAt": "2020-04-11T10:51:27Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+    }\n+\n+    private void setupBackupRenamePath() {\n+        TimestampFormat format = configuration.getBackupDirTimestampFormat();\n+        long epochMicros = configuration.getMicrosecondClock().getTicks();\n+        int n = 0;\n+        // TODO: There is a race here, two threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR);", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a26ced865d7885399d0d7e9762f44bd9a6bbf463", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0af003d95..c9390a30f 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1672,7 +1672,11 @@ public class SqlCompiler implements Closeable {\n     private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n         nativeLPSZ.of(file);\n         if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-            backupTable(nativeLPSZ, currentExecutionContext);\n+            try {\n+                backupTable(nativeLPSZ, currentExecutionContext);\n+            } catch (CairoException ex) {\n+                LOG.error().$(\"Failed to backup \").$(nativeLPSZ).$(\": \").$(ex.getFlyweightMessage()).$();\n+            }\n         }\n     };\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0OTk3NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407049974", "bodyText": "Caching backup root like this can cause a potential side effect that server will not be able to back a table after backup directory was successfully created by server and then manually removed by user.\nChecking dir for existence is a low overhead generally compared to creating a directory anyway.\nOh, looking down the code, cloneMetaData will create these directories anyway. May be we should not be creating directory upfront like this?", "author": "bluestreak01", "createdAt": "2020-04-11T11:01:36Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+    }\n+\n+    private void setupBackupRenamePath() {\n+        TimestampFormat format = configuration.getBackupDirTimestampFormat();\n+        long epochMicros = configuration.getMicrosecondClock().getTicks();\n+        int n = 0;\n+        // TODO: There is a race here, two threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR);\n+            format.format(epochMicros, TimestampLocaleFactory.INSTANCE.getDefaultTimestampLocale(), null, renamePath);\n+            if (n > 0) {\n+                renamePath.put('.').put(n);\n+            }\n+            renamePath.put(Files.SEPARATOR).$();\n+            n++;\n+        } while (ff.exists(renamePath));\n+        if (ff.mkdirs(renamePath, configuration.getMkDirMode()) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"could not create [dir=\").put(renamePath).put(']');\n+        }\n+    }\n+\n+    private transient String cachedTmpBackupRoot;\n+\n+    private void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+        LOG.info().$(\"Starting backup of \").$(tableName).$();\n+        if (null == cachedTmpBackupRoot) {", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMDE1MQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r408030151", "bodyText": "I cached the tmp backup root because its a string and I dont want to create one every time. We could add yet another Path object to the SqlCompiler but I though the code was clearer with the transient String cachedTmpBackupRoot. However, you are correct that we dont need to create the directory at the same time as populating cachedTmpBackupRoot. The cloneMetaData will do it and its safer to do it there, so I have remove the mkdirs.", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T10:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0OTk3NA=="}], "type": "inlineReview", "revised_code": {"commit": "a26ced865d7885399d0d7e9762f44bd9a6bbf463", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0af003d95..c9390a30f 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1672,7 +1672,11 @@ public class SqlCompiler implements Closeable {\n     private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n         nativeLPSZ.of(file);\n         if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-            backupTable(nativeLPSZ, currentExecutionContext);\n+            try {\n+                backupTable(nativeLPSZ, currentExecutionContext);\n+            } catch (CairoException ex) {\n+                LOG.error().$(\"Failed to backup \").$(nativeLPSZ).$(\": \").$(ex.getFlyweightMessage()).$();\n+            }\n         }\n     };\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MDQzMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407050431", "bodyText": "on the subject of mkdir mode, perhaps we should have separate configuration property for backup mode?\nOriginal mkdirMode is for directories created by server runtime, these are not necessarily need to be readable by other processes and/or users. On other hand backup directory could potentially be picked up by another process, such as tape backup or something similar and thus need to have different permissions than runtime dirs.", "author": "bluestreak01", "createdAt": "2020-04-11T11:06:52Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+    }\n+\n+    private void setupBackupRenamePath() {\n+        TimestampFormat format = configuration.getBackupDirTimestampFormat();\n+        long epochMicros = configuration.getMicrosecondClock().getTicks();\n+        int n = 0;\n+        // TODO: There is a race here, two threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR);\n+            format.format(epochMicros, TimestampLocaleFactory.INSTANCE.getDefaultTimestampLocale(), null, renamePath);\n+            if (n > 0) {\n+                renamePath.put('.').put(n);\n+            }\n+            renamePath.put(Files.SEPARATOR).$();\n+            n++;\n+        } while (ff.exists(renamePath));\n+        if (ff.mkdirs(renamePath, configuration.getMkDirMode()) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"could not create [dir=\").put(renamePath).put(']');\n+        }\n+    }\n+\n+    private transient String cachedTmpBackupRoot;\n+\n+    private void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+        LOG.info().$(\"Starting backup of \").$(tableName).$();\n+        if (null == cachedTmpBackupRoot) {\n+            if (null == configuration.getBackupRoot()) {\n+                throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+            }\n+            path.of(configuration.getBackupRoot()).concat(configuration.getBackupTempDirName()).put(Files.SEPARATOR).$();\n+            cachedTmpBackupRoot = path.toString();\n+            if (!ff.exists(path)) {\n+                LOG.info().$(\"Creating backup directory \").$(cachedTmpBackupRoot).$();\n+                if (ff.mkdirs(path, configuration.getMkDirMode()) != 0) {\n+                    throw CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+                }\n+            }\n+        }\n+\n+        CairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+        try (TableReader reader = engine.getReader(securityContext, tableName)) {\n+            cloneMetaData(tableName, configuration.getRoot(), cachedTmpBackupRoot, configuration.getMkDirMode(), reader);", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMTY1Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r408031652", "bodyText": "I can add one, but I do think we need to be wary of adding a lot of configuration parameters without user input.", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T10:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MDQzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "a26ced865d7885399d0d7e9762f44bd9a6bbf463", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0af003d95..c9390a30f 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1672,7 +1672,11 @@ public class SqlCompiler implements Closeable {\n     private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n         nativeLPSZ.of(file);\n         if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-            backupTable(nativeLPSZ, currentExecutionContext);\n+            try {\n+                backupTable(nativeLPSZ, currentExecutionContext);\n+            } catch (CairoException ex) {\n+                LOG.error().$(\"Failed to backup \").$(nativeLPSZ).$(\": \").$(ex.getFlyweightMessage()).$();\n+            }\n         }\n     };\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MTUyMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407051521", "bodyText": "sorry to be a pain, all other \"for\" loops across the project at limited by constant rather than function. The rationale is to avoid calling function in a loop unnecessarily (which java will do).\nThis may not matter as much here, but still it goes on the assumption that sourceMetaData.getColumnCount() is lightweight, which it is, but only coincidentally.\nMore robust loop would be:\nfor (int i = 0, n = sourceMetaData.getColumnCount(); i < n; i++) {", "author": "bluestreak01", "createdAt": "2020-04-11T11:18:22Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+    }\n+\n+    private void setupBackupRenamePath() {\n+        TimestampFormat format = configuration.getBackupDirTimestampFormat();\n+        long epochMicros = configuration.getMicrosecondClock().getTicks();\n+        int n = 0;\n+        // TODO: There is a race here, two threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR);\n+            format.format(epochMicros, TimestampLocaleFactory.INSTANCE.getDefaultTimestampLocale(), null, renamePath);\n+            if (n > 0) {\n+                renamePath.put('.').put(n);\n+            }\n+            renamePath.put(Files.SEPARATOR).$();\n+            n++;\n+        } while (ff.exists(renamePath));\n+        if (ff.mkdirs(renamePath, configuration.getMkDirMode()) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"could not create [dir=\").put(renamePath).put(']');\n+        }\n+    }\n+\n+    private transient String cachedTmpBackupRoot;\n+\n+    private void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+        LOG.info().$(\"Starting backup of \").$(tableName).$();\n+        if (null == cachedTmpBackupRoot) {\n+            if (null == configuration.getBackupRoot()) {\n+                throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+            }\n+            path.of(configuration.getBackupRoot()).concat(configuration.getBackupTempDirName()).put(Files.SEPARATOR).$();\n+            cachedTmpBackupRoot = path.toString();\n+            if (!ff.exists(path)) {\n+                LOG.info().$(\"Creating backup directory \").$(cachedTmpBackupRoot).$();\n+                if (ff.mkdirs(path, configuration.getMkDirMode()) != 0) {\n+                    throw CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+                }\n+            }\n+        }\n+\n+        CairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+        try (TableReader reader = engine.getReader(securityContext, tableName)) {\n+            cloneMetaData(tableName, configuration.getRoot(), cachedTmpBackupRoot, configuration.getMkDirMode(), reader);\n+            try (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName, cachedTmpBackupRoot)) {\n+                RecordCursor cursor = reader.getCursor();\n+                copyTableData(cursor, reader.getMetadata(), backupWriter);\n+                backupWriter.commit();\n+            }\n+        }\n+\n+        path.of(configuration.getBackupRoot()).concat(configuration.getBackupTempDirName()).put(Files.SEPARATOR).concat(tableName).$();\n+        int renameRootLen = renamePath.length();\n+        try {\n+            renamePath.trimTo(renameRootLen).concat(tableName).$();\n+            if (!ff.rename(path, renamePath)) {\n+                throw CairoException.instance(ff.errno()).put(\"Could not rename [from=\").put(path).put(\", to=\").put(renamePath).put(']');\n+            }\n+            LOG.info().$(\"Completed backup of \").$(tableName).$(\" to \").$(renamePath).$();\n+        } finally {\n+            renamePath.trimTo(renameRootLen).$();\n+        }\n+    }\n+\n+    private void cloneMetaData(CharSequence tableName, CharSequence root, CharSequence backupRoot, int mkDirMode, TableReader reader) {\n+        path.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n+\n+        if (ff.exists(path)) {\n+            throw CairoException.instance(0).put(\"Backup dir for table \\\"\").put(tableName).put(\"\\\" already exists [dir=\").put(path).put(']');\n+        }\n+\n+        if (ff.mkdirs(path, mkDirMode) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+        }\n+\n+        TableReaderMetadata sourceMetaData = (TableReaderMetadata) reader.getMetadata();\n+        int rootLen = path.length();\n+        try {\n+            mem.of(ff, path.trimTo(rootLen).concat(TableUtils.META_FILE_NAME).$(), ff.getPageSize());\n+            sourceMetaData.cloneTo(mem);\n+\n+            // create symbol maps\n+            path.trimTo(rootLen).$();\n+            int symbolMapCount = 0;\n+            for (int i = 0; i < sourceMetaData.getColumnCount(); i++) {", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNDI4Ng==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r408034286", "bodyText": "lol, I am not sure this will make any difference at all, the function call is just a getter and it will be inlined. However, changing the code will make it explicit rather than implicit,I will change this", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T10:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MTUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "a26ced865d7885399d0d7e9762f44bd9a6bbf463", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0af003d95..c9390a30f 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1672,7 +1672,11 @@ public class SqlCompiler implements Closeable {\n     private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n         nativeLPSZ.of(file);\n         if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-            backupTable(nativeLPSZ, currentExecutionContext);\n+            try {\n+                backupTable(nativeLPSZ, currentExecutionContext);\n+            } catch (CairoException ex) {\n+                LOG.error().$(\"Failed to backup \").$(nativeLPSZ).$(\": \").$(ex.getFlyweightMessage()).$();\n+            }\n         }\n     };\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MjAwMg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407052002", "bodyText": "I feel this loop should be robust to directory creating corrupt tables, for example any table on which backupTable  might fail.\nThis would make interface relatively consistent. We should be able to say that backup database will backup everything than can be backed up and will log tables it could not backup.", "author": "bluestreak01", "createdAt": "2020-04-11T11:23:25Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4Nzk1MQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407987951", "bodyText": "Yes, sounds sensible, will log at error levele", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T09:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MjAwMg=="}], "type": "inlineReview", "revised_code": {"commit": "a26ced865d7885399d0d7e9762f44bd9a6bbf463", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0af003d95..c9390a30f 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1672,7 +1672,11 @@ public class SqlCompiler implements Closeable {\n     private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n         nativeLPSZ.of(file);\n         if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-            backupTable(nativeLPSZ, currentExecutionContext);\n+            try {\n+                backupTable(nativeLPSZ, currentExecutionContext);\n+            } catch (CairoException ex) {\n+                LOG.error().$(\"Failed to backup \").$(nativeLPSZ).$(\": \").$(ex.getFlyweightMessage()).$();\n+            }\n         }\n     };\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1Mjc4OQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407052789", "bodyText": "These names should be validated that they don't contain malicious paths. There is GenericLexer.unhack to do that.", "author": "bluestreak01", "createdAt": "2020-04-11T11:32:23Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4OTM0MQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407989341", "bodyText": "tableName is already unhacked after being unquoteded, is that not ok?", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T09:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1Mjc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzODMzNg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r408238336", "bodyText": "it is ok, sorry, overlooked!", "author": "bluestreak01", "createdAt": "2020-04-14T15:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1Mjc4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a26ced865d7885399d0d7e9762f44bd9a6bbf463", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0af003d95..c9390a30f 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1672,7 +1672,11 @@ public class SqlCompiler implements Closeable {\n     private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n         nativeLPSZ.of(file);\n         if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n-            backupTable(nativeLPSZ, currentExecutionContext);\n+            try {\n+                backupTable(nativeLPSZ, currentExecutionContext);\n+            } catch (CairoException ex) {\n+                LOG.error().$(\"Failed to backup \").$(nativeLPSZ).$(\": \").$(ex.getFlyweightMessage()).$();\n+            }\n         }\n     };\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1Mjk4Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407052982", "bodyText": "I feel these checks are unnecessary. The config comes from file on disk, so attacker would have already gotten access to file system.\nAdditionally there are methods like Chars.contains() and others, which would let you check if CharSequence contains \\ without creating a string.", "author": "bluestreak01", "createdAt": "2020-04-11T11:34:24Z", "path": "core/src/main/java/io/questdb/PropServerConfiguration.java", "diffHunk": "@@ -497,6 +527,21 @@ private String getString(Properties properties, String key, String defaultValue)\n         return value;\n     }\n \n+    private TimestampFormat getTimestampFormat(Properties properties, String key, String defaultPattern) throws ServerConfigurationException {\n+        String pattern = properties.getProperty(key);\n+        if (null == pattern) {\n+            pattern = defaultPattern;\n+        }\n+        DateFormatCompiler compiler = new DateFormatCompiler();\n+        if (null != pattern) {\n+            if (pattern.contains(new StringBuilder().append(Files.SEPARATOR).toString()) || pattern.startsWith(\".\")) {", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3MTg1OA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407971858", "bodyText": "True, it is over defensive, I will remove it", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T08:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1Mjk4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a26ced865d7885399d0d7e9762f44bd9a6bbf463", "chunk": "diff --git a/core/src/main/java/io/questdb/PropServerConfiguration.java b/core/src/main/java/io/questdb/PropServerConfiguration.java\nindex 3d6c52cd6..cc1313c83 100644\n--- a/core/src/main/java/io/questdb/PropServerConfiguration.java\n+++ b/core/src/main/java/io/questdb/PropServerConfiguration.java\n\n@@ -534,9 +534,6 @@ public class PropServerConfiguration implements ServerConfiguration {\n         }\n         DateFormatCompiler compiler = new DateFormatCompiler();\n         if (null != pattern) {\n-            if (pattern.contains(new StringBuilder().append(Files.SEPARATOR).toString()) || pattern.startsWith(\".\")) {\n-                throw new ServerConfigurationException(key, pattern);\n-            }\n             return compiler.compile(pattern);\n         }\n         return compiler.compile(\"yyyy-MM-dd\");\n"}}, {"oid": "a26ced865d7885399d0d7e9762f44bd9a6bbf463", "url": "https://github.com/questdb/questdb/commit/a26ced865d7885399d0d7e9762f44bd9a6bbf463", "message": "feat(griffin): add database backup", "committedDate": "2020-04-14T10:34:25Z", "type": "commit"}, {"oid": "0dd5fe7def598c5bf04e611bb492af669223296f", "url": "https://github.com/questdb/questdb/commit/0dd5fe7def598c5bf04e611bb492af669223296f", "message": "Merge branch 'master' into table-backup2", "committedDate": "2020-04-14T10:55:19Z", "type": "commit"}, {"oid": "281302eab06515beef3716944aafb6d40355e267", "url": "https://github.com/questdb/questdb/commit/281302eab06515beef3716944aafb6d40355e267", "message": "feat(griffin): add database backup\n\tcache table copier", "committedDate": "2020-04-14T13:42:20Z", "type": "commit"}, {"oid": "a20b7ecef33ad7f5f1e5bf843ad428d75448bc74", "url": "https://github.com/questdb/questdb/commit/a20b7ecef33ad7f5f1e5bf843ad428d75448bc74", "message": "feat(griffin): add database backup", "committedDate": "2020-04-14T13:50:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3MTcyNw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401771727", "bodyText": "Allocating new ObjList here, probably want to have this as a reusable resource in SqlCompiler. Or maybe there is a better way of parsing the SQL in general", "author": "patrickSpaceSurfer", "createdAt": "2020-04-01T17:04:44Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a959e1f6252ef7f3acbcb21232f22285b26dfd", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCompiler.java b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\nindex 0147eaee8..21977a554 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCompiler.java\n\n@@ -1680,7 +1651,7 @@ public class SqlCompiler implements Closeable {\n       }\n     \n \tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n-\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+        ObjHashSet<CharSequence> tableNames = new ObjHashSet<>();\n \t\twhile (true) {\n \t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n \t\t\tif (null == tok) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3MjQ5Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401772492", "bodyText": "Refactored releaseInactive so that it can also be used by the WriterMaintenanceJob below. Not sure if this is a good idea", "author": "patrickSpaceSurfer", "createdAt": "2020-04-01T17:06:11Z", "path": "core/src/main/java/io/questdb/cairo/CairoEngine.java", "diffHunk": "@@ -199,14 +216,22 @@ public boolean releaseAllReaders() {\n         return readerPool.releaseAll();\n     }\n ", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cdbc63cbe5be9433a6c9e0ef139e654686a353b1", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/CairoEngine.java b/core/src/main/java/io/questdb/cairo/CairoEngine.java\nindex e01c424b7..208f22286 100644\n--- a/core/src/main/java/io/questdb/cairo/CairoEngine.java\n+++ b/core/src/main/java/io/questdb/cairo/CairoEngine.java\n\n@@ -218,18 +213,12 @@ public class CairoEngine implements Closeable {\n \n     public boolean releaseAllWriters () {\n     \tboolean released = writerPool.releaseAll();\n-    \tif (null != backupWriterPool && backupWriterPool.releaseAll()) {\n-    \t\treleased = true;\n-    \t}\n     \treturn released;\n     }\n     \n \tpublic boolean releaseInactive() {\n \t\tboolean useful = writerPool.releaseInactive();\n \t\tuseful |= readerPool.releaseInactive();\n-\t\tif (null != backupWriterPool) {\n-\t\t\tuseful |= backupWriterPool.releaseInactive();\n-\t\t}\n \t\treturn useful;\n \t}\n \n"}}, {"oid": "7361ffa19521f4caf5e9a985f8f606b3769175b2", "url": "https://github.com/questdb/questdb/commit/7361ffa19521f4caf5e9a985f8f606b3769175b2", "message": "feat(griffin): add database backup", "committedDate": "2020-04-14T16:35:58Z", "type": "commit"}]}