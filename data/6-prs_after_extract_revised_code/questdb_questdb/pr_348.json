{"pr_number": 348, "pr_title": "feature(griffin) - LT JOIN ", "pr_createdAt": "2020-06-01T19:24:54Z", "pr_url": "https://github.com/questdb/questdb/pull/348", "timeline": [{"oid": "36ede63a26adec9256a3a3fd96ecec98df9abbdb", "url": "https://github.com/questdb/questdb/commit/36ede63a26adec9256a3a3fd96ecec98df9abbdb", "message": "fix(griffin) - lt join", "committedDate": "2020-06-01T09:06:34Z", "type": "commit"}, {"oid": "1d0697a758d0b4c0657aa003eed4cdf19b55ed0e", "url": "https://github.com/questdb/questdb/commit/1d0697a758d0b4c0657aa003eed4cdf19b55ed0e", "message": "fix(griffin) - lt join", "committedDate": "2020-06-01T11:16:01Z", "type": "commit"}, {"oid": "d2a3bdbf4101bb2f86e632539d05f1d745971604", "url": "https://github.com/questdb/questdb/commit/d2a3bdbf4101bb2f86e632539d05f1d745971604", "message": "fix(griffin) - lt join", "committedDate": "2020-06-01T17:55:10Z", "type": "commit"}, {"oid": "a811f4fe34f239a7904e62dc7e43674b323cf8ec", "url": "https://github.com/questdb/questdb/commit/a811f4fe34f239a7904e62dc7e43674b323cf8ec", "message": "fix(griffin) - lt join", "committedDate": "2020-06-01T19:40:33Z", "type": "commit"}, {"oid": "6e0180a0bb02ad32bf85906fcadcf2a41a61cfe9", "url": "https://github.com/questdb/questdb/commit/6e0180a0bb02ad32bf85906fcadcf2a41a61cfe9", "message": "fix(griffin) - lt join", "committedDate": "2020-06-01T20:48:23Z", "type": "commit"}, {"oid": "0c35b3c935d0051aaff3691a9b7246f27935f200", "url": "https://github.com/questdb/questdb/commit/0c35b3c935d0051aaff3691a9b7246f27935f200", "message": "fix(griffin) - lt join", "committedDate": "2020-06-02T09:00:09Z", "type": "commit"}, {"oid": "cb7aa3df057f6db6453b323a70c8ae5e0649e20a", "url": "https://github.com/questdb/questdb/commit/cb7aa3df057f6db6453b323a70c8ae5e0649e20a", "message": "fix(griffin) - lt join", "committedDate": "2020-06-02T11:01:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3MjIwNw==", "url": "https://github.com/questdb/questdb/pull/348#discussion_r434472207", "bodyText": "This is similar to asof join. Can we make factory constructor a functional interface? These factories take the same args. This way we can remove code duplication", "author": "bluestreak01", "createdAt": "2020-06-03T10:37:04Z", "path": "core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java", "diffHunk": "@@ -242,6 +267,133 @@ private RecordCursorFactory createFullFatAsOfJoin(\n         return master;\n     }\n \n+    @NotNull\n+    private RecordCursorFactory createFullFatLtJoin(", "originalCommit": "cb7aa3df057f6db6453b323a70c8ae5e0649e20a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b48ea73934c21d47565900a2392588263f2ff64", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java b/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\nindex b263dcdfb..e44f0eb70 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\n\n@@ -264,133 +265,6 @@ public class SqlCodeGenerator implements Mutable {\n                 RecordValueSinkFactory.getInstance(asm, slaveMetadata, listColumnFilterB),\n                 columnIndex\n         );\n-        return master;\n-    }\n-\n-    @NotNull\n-    private RecordCursorFactory createFullFatLtJoin(\n-            RecordCursorFactory master,\n-            RecordMetadata masterMetadata,\n-            CharSequence masterAlias,\n-            RecordCursorFactory slave,\n-            RecordMetadata slaveMetadata,\n-            CharSequence slaveAlias,\n-            int joinPosition) throws SqlException {\n-\n-        // create hash set of key columns to easily find them\n-        intHashSet.clear();\n-        for (int i = 0, n = listColumnFilterA.getColumnCount(); i < n; i++) {\n-            intHashSet.add(listColumnFilterA.getColumnIndex(i));\n-        }\n-\n-\n-        // map doesn't support variable length types in map value, which is ok\n-        // when we join tables on strings - technically string is the key\n-        // and we do not need to store it in value, but we will still reject\n-        //\n-        // never mind, this is a stop-gap measure until I understand the problem\n-        // fully\n-\n-        for (int k = 0, m = slaveMetadata.getColumnCount(); k < m; k++) {\n-            if (intHashSet.excludes(k)) {\n-                int type = slaveMetadata.getColumnType(k);\n-                if (type == ColumnType.STRING || type == ColumnType.BINARY) {\n-                    throw SqlException\n-                            .position(joinPosition).put(\"right side column '\")\n-                            .put(slaveMetadata.getColumnName(k)).put(\"' is of unsupported type\");\n-                }\n-            }\n-        }\n-\n-        RecordSink masterSink = RecordSinkFactory.getInstance(\n-                asm,\n-                masterMetadata,\n-                listColumnFilterB,\n-                true\n-        );\n-\n-        JoinRecordMetadata metadata = new JoinRecordMetadata(\n-                configuration,\n-                masterMetadata.getColumnCount() + slaveMetadata.getColumnCount()\n-        );\n-\n-        // metadata will have master record verbatim\n-        metadata.copyColumnMetadataFrom(masterAlias, masterMetadata);\n-\n-        // slave record is split across key and value of map\n-        // the rationale is not to store columns twice\n-        // especially when map value does not support variable\n-        // length types\n-\n-\n-        final IntList columnIndex = new IntList(slaveMetadata.getColumnCount());\n-        // In map record value columns go first, so at this stage\n-        // we add to metadata all slave columns that are not keys.\n-        // Add same columns to filter while we are in this loop.\n-        listColumnFilterB.clear();\n-        valueTypes.reset();\n-        ArrayColumnTypes slaveTypes = new ArrayColumnTypes();\n-        for (int i = 0, n = slaveMetadata.getColumnCount(); i < n; i++) {\n-            if (intHashSet.excludes(i)) {\n-                int type = slaveMetadata.getColumnType(i);\n-                metadata.add(\n-                        slaveAlias,\n-                        slaveMetadata.getColumnName(i),\n-                        type,\n-                        slaveMetadata.isColumnIndexed(i),\n-                        slaveMetadata.getIndexValueBlockCapacity(i),\n-                        slaveMetadata.isSymbolTableStatic(i)\n-                );\n-                listColumnFilterB.add(i);\n-                columnIndex.add(i);\n-                valueTypes.add(type);\n-                slaveTypes.add(type);\n-            }\n-        }\n-\n-        // now add key columns to metadata\n-        for (int i = 0, n = listColumnFilterA.getColumnCount(); i < n; i++) {\n-            int index = listColumnFilterA.getColumnIndex(i);\n-            int type = slaveMetadata.getColumnType(index);\n-            if (type == ColumnType.SYMBOL) {\n-                type = ColumnType.STRING;\n-            }\n-            metadata.add(\n-                    slaveAlias,\n-                    slaveMetadata.getColumnName(index),\n-                    type,\n-                    slaveMetadata.isColumnIndexed(i),\n-                    slaveMetadata.getIndexValueBlockCapacity(i),\n-                    slaveMetadata.isSymbolTableStatic(i)\n-            );\n-            columnIndex.add(index);\n-            slaveTypes.add(type);\n-        }\n-\n-        if (masterMetadata.getTimestampIndex() != -1) {\n-            metadata.setTimestampIndex(masterMetadata.getTimestampIndex());\n-        }\n-\n-        master = new LtJoinRecordCursorFactory(\n-                configuration,\n-                metadata,\n-                master,\n-                slave,\n-                keyTypes,\n-                valueTypes,\n-                slaveTypes,\n-                masterSink,\n-                RecordSinkFactory.getInstance(\n-                        asm,\n-                        slaveMetadata,\n-                        listColumnFilterA,\n-                        true\n-                ),\n-                masterMetadata.getColumnCount(),\n-                RecordValueSinkFactory.getInstance(asm, slaveMetadata, listColumnFilterB),\n-                columnIndex\n-        );\n-        return master;\n     }\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3MjQ5Mw==", "url": "https://github.com/questdb/questdb/pull/348#discussion_r434472493", "bodyText": "this is good candidate for a list lookup and branch removal", "author": "bluestreak01", "createdAt": "2020-06-03T10:37:36Z", "path": "core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java", "diffHunk": "@@ -1607,7 +1803,7 @@ private RecordCursorFactory generateTableQuery(\n                 throw e;\n             }\n \n-            boolean requiresTimestamp = model.getJoinType() == QueryModel.JOIN_ASOF || model.getJoinType() == QueryModel.JOIN_CROSS;\n+            boolean requiresTimestamp = model.getJoinType() == QueryModel.JOIN_ASOF || model.getJoinType() == QueryModel.JOIN_CROSS || model.getJoinType() == QueryModel.JOIN_LT;", "originalCommit": "cb7aa3df057f6db6453b323a70c8ae5e0649e20a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e98e8ff8c9c17160cc4c61c054c458241776b936", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java b/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\nindex b263dcdfb..f280dfc3c 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\n\n@@ -1803,7 +1682,7 @@ public class SqlCodeGenerator implements Mutable {\n                 throw e;\n             }\n \n-            boolean requiresTimestamp = model.getJoinType() == QueryModel.JOIN_ASOF || model.getJoinType() == QueryModel.JOIN_CROSS || model.getJoinType() == QueryModel.JOIN_LT;\n+            boolean requiresTimestamp = requiresTimestamp(model.getJoinType());\n             final GenericRecordMetadata myMeta = new GenericRecordMetadata();\n             boolean framingSupported;\n             try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3MzI5Mg==", "url": "https://github.com/questdb/questdb/pull/348#discussion_r434473292", "bodyText": "another list lookup, also feels that for implied timestamp we should use same joins that participate in requiredTimestamp just above. Do you mind checking why CROSS join isn't present here?", "author": "bluestreak01", "createdAt": "2020-06-03T10:39:03Z", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -609,7 +609,7 @@ private void createImpliedDependencies(QueryModel parent) {\n         JoinContext jc;\n         for (int i = 0, n = models.size(); i < n; i++) {\n             QueryModel m = models.getQuick(i);\n-            if (m.getJoinType() == QueryModel.JOIN_ASOF || m.getJoinType() == QueryModel.JOIN_SPLICE) {\n+            if (m.getJoinType() == QueryModel.JOIN_ASOF || m.getJoinType() == QueryModel.JOIN_SPLICE || m.getJoinType() == QueryModel.JOIN_LT) {", "originalCommit": "cb7aa3df057f6db6453b323a70c8ae5e0649e20a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e98e8ff8c9c17160cc4c61c054c458241776b936", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlOptimiser.java b/core/src/main/java/io/questdb/griffin/SqlOptimiser.java\nindex 3e9315885..f4a9e8de1 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlOptimiser.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlOptimiser.java\n\n@@ -609,7 +610,7 @@ class SqlOptimiser {\n         JoinContext jc;\n         for (int i = 0, n = models.size(); i < n; i++) {\n             QueryModel m = models.getQuick(i);\n-            if (m.getJoinType() == QueryModel.JOIN_ASOF || m.getJoinType() == QueryModel.JOIN_SPLICE || m.getJoinType() == QueryModel.JOIN_LT) {\n+            if (requiresTimestamp(m.getJoinType())) {\n                 linkDependencies(parent, 0, i);\n                 if (m.getContext() == null) {\n                     m.setContext(jc = contextPool.next());\n"}}, {"oid": "8b48ea73934c21d47565900a2392588263f2ff64", "url": "https://github.com/questdb/questdb/commit/8b48ea73934c21d47565900a2392588263f2ff64", "message": "fix(griffin) - lt join", "committedDate": "2020-06-03T11:35:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYwMzAyOQ==", "url": "https://github.com/questdb/questdb/pull/348#discussion_r434603029", "bodyText": "could we make this a static final variable? Annoyingly this is an allocating call in java", "author": "bluestreak01", "createdAt": "2020-06-03T14:18:18Z", "path": "core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java", "diffHunk": "@@ -753,14 +627,15 @@ private RecordCursorFactory generateJoins(QueryModel model, SqlExecutionContext\n                                     );\n                                 }\n                             } else {\n-                                master = createFullFatAsOfJoin(\n+                                master = createFullFatJoin(\n                                         master,\n                                         masterMetadata,\n                                         masterAlias,\n                                         slave,\n                                         slaveMetadata,\n                                         slaveModel.getName(),\n-                                        slaveModel.getJoinKeywordPosition()\n+                                        slaveModel.getJoinKeywordPosition(),\n+                                        SqlCodeGenerator::createFullFatAsOfJoin", "originalCommit": "8b48ea73934c21d47565900a2392588263f2ff64", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e98e8ff8c9c17160cc4c61c054c458241776b936", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java b/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\nindex e44f0eb70..f280dfc3c 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\n\n@@ -635,7 +638,7 @@ public class SqlCodeGenerator implements Mutable {\n                                         slaveMetadata,\n                                         slaveModel.getName(),\n                                         slaveModel.getJoinKeywordPosition(),\n-                                        SqlCodeGenerator::createFullFatAsOfJoin\n+                                        CREATE_FULL_FAT_AS_OF_JOIN\n                                 );\n                             }\n                             masterAlias = null;\n"}}, {"oid": "a5aae4d46b07c7c39cdfe6b3ca1ca52b77ad223a", "url": "https://github.com/questdb/questdb/commit/a5aae4d46b07c7c39cdfe6b3ca1ca52b77ad223a", "message": "test for milli Timestamp", "committedDate": "2020-06-03T19:13:45Z", "type": "commit"}, {"oid": "e98e8ff8c9c17160cc4c61c054c458241776b936", "url": "https://github.com/questdb/questdb/commit/e98e8ff8c9c17160cc4c61c054c458241776b936", "message": "fix(griffin) - lt join", "committedDate": "2020-06-03T20:53:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4MDI5Mw==", "url": "https://github.com/questdb/questdb/pull/348#discussion_r434980293", "bodyText": "I mean sparse array. I wouldn't think loop is faster than || comparison. Probably not. Using sparse array lookup will look like:\nboolean requiresTimeatamp = joinsRequiringTimestamp[model.getJoinType()];", "author": "bluestreak01", "createdAt": "2020-06-04T04:05:25Z", "path": "core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java", "diffHunk": "@@ -1953,6 +2028,15 @@ private RecordCursorFactory generateTableQuery(\n         }\n     }\n \n+    private boolean requiresTimestamp(int joinType) {", "originalCommit": "e98e8ff8c9c17160cc4c61c054c458241776b936", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04862822c59ee73961211e6930791920626c5fe4", "chunk": "diff --git a/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java b/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\nindex f280dfc3c..8bf560d1b 100644\n--- a/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\n+++ b/core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java\n\n@@ -2028,15 +2028,6 @@ public class SqlCodeGenerator implements Mutable {\n         }\n     }\n \n-    private boolean requiresTimestamp(int joinType) {\n-        for (int i = 0; i < joinsRequiringTimestamp.length; i++) {\n-            if (joinType == joinsRequiringTimestamp[i]) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n     private RecordCursorFactory generateUnionAllFactory(QueryModel model, RecordCursorFactory masterFactory, SqlExecutionContext executionContext, RecordCursorFactory slaveFactory) throws SqlException {\n         validateJoinColumnTypes(model, masterFactory, slaveFactory);\n         final RecordCursorFactory unionAllFactory = new UnionAllRecordCursorFactory(masterFactory, slaveFactory);\n"}}, {"oid": "04862822c59ee73961211e6930791920626c5fe4", "url": "https://github.com/questdb/questdb/commit/04862822c59ee73961211e6930791920626c5fe4", "message": "fix(griffin) - lt join", "committedDate": "2020-06-04T08:40:13Z", "type": "commit"}]}