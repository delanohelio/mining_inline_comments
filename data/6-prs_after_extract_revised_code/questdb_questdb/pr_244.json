{"pr_number": 244, "pr_title": "Replication", "pr_createdAt": "2020-04-28T22:10:04Z", "pr_url": "https://github.com/questdb/questdb/pull/244", "timeline": [{"oid": "80b6707228abc015f13f7fc338815ff2ce72e633", "url": "https://github.com/questdb/questdb/commit/80b6707228abc015f13f7fc338815ff2ce72e633", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-07T10:51:47Z", "type": "commit"}, {"oid": "001e1945dac7a1e945e3e6147a96e9aca5b71ab8", "url": "https://github.com/questdb/questdb/commit/001e1945dac7a1e945e3e6147a96e9aca5b71ab8", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-07T12:48:29Z", "type": "commit"}, {"oid": "ca1e22f025ddcc0c9a1529bd19265da5a26c6089", "url": "https://github.com/questdb/questdb/commit/ca1e22f025ddcc0c9a1529bd19265da5a26c6089", "message": "Merge branch 'master' into replication", "committedDate": "2020-10-09T13:23:42Z", "type": "commit"}, {"oid": "ec1b7518dac6240261fa7a43dc3564c8f6e555a7", "url": "https://github.com/questdb/questdb/commit/ec1b7518dac6240261fa7a43dc3564c8f6e555a7", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-13T15:00:47Z", "type": "commit"}, {"oid": "ea2589535b7cd74b6bbbda29446fe99f00cbc664", "url": "https://github.com/questdb/questdb/commit/ea2589535b7cd74b6bbbda29446fe99f00cbc664", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-13T15:47:47Z", "type": "commit"}, {"oid": "df935b839cc9d478799d341b6ce34541a0c70b4d", "url": "https://github.com/questdb/questdb/commit/df935b839cc9d478799d341b6ce34541a0c70b4d", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-13T16:41:58Z", "type": "commit"}, {"oid": "f46e994df2efe1889b85ecbb7e5dda03ad3bfc7f", "url": "https://github.com/questdb/questdb/commit/f46e994df2efe1889b85ecbb7e5dda03ad3bfc7f", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-14T08:02:40Z", "type": "commit"}, {"oid": "5567cf5427f825dbc25e11bf5906d71713bc1ddd", "url": "https://github.com/questdb/questdb/commit/5567cf5427f825dbc25e11bf5906d71713bc1ddd", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-14T09:48:16Z", "type": "commit"}, {"oid": "c32aaf306eb1722197ca4fb0a51422dd1f0013ca", "url": "https://github.com/questdb/questdb/commit/c32aaf306eb1722197ca4fb0a51422dd1f0013ca", "message": "chore(cairo): block writer minor tidy-up, added asserts", "committedDate": "2020-10-15T14:39:29Z", "type": "commit"}, {"oid": "81f166dc8a7c1b6c10d7db692b36768ae998fddd", "url": "https://github.com/questdb/questdb/commit/81f166dc8a7c1b6c10d7db692b36768ae998fddd", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-16T16:41:53Z", "type": "commit"}, {"oid": "b4bc35ff2f0a545f8fe1bd7f2c67078f6e1d8d9a", "url": "https://github.com/questdb/questdb/commit/b4bc35ff2f0a545f8fe1bd7f2c67078f6e1d8d9a", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-19T09:38:14Z", "type": "commit"}, {"oid": "4fa5bf1d92503b8c2b262aa29b75aea610d59943", "url": "https://github.com/questdb/questdb/commit/4fa5bf1d92503b8c2b262aa29b75aea610d59943", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-21T14:16:45Z", "type": "commit"}, {"oid": "0498df790c73816700503d039a69c4e041ae6979", "url": "https://github.com/questdb/questdb/commit/0498df790c73816700503d039a69c4e041ae6979", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-21T14:42:33Z", "type": "commit"}, {"oid": "5549a9d18f2a12d97ab59376b5c21960774d4356", "url": "https://github.com/questdb/questdb/commit/5549a9d18f2a12d97ab59376b5c21960774d4356", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-21T14:52:27Z", "type": "commit"}, {"oid": "8b5037a32936d3f39cab6d094a30c0677a04cd0f", "url": "https://github.com/questdb/questdb/commit/8b5037a32936d3f39cab6d094a30c0677a04cd0f", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-21T14:58:49Z", "type": "commit"}, {"oid": "581df752e14ade1bb4d98c1aec57583375f7723a", "url": "https://github.com/questdb/questdb/commit/581df752e14ade1bb4d98c1aec57583375f7723a", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-21T15:18:46Z", "type": "commit"}, {"oid": "7c4158cd611c6d3fde329c43c3924ad7387390ee", "url": "https://github.com/questdb/questdb/commit/7c4158cd611c6d3fde329c43c3924ad7387390ee", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-22T12:57:23Z", "type": "commit"}, {"oid": "f15fe2039b2c03893cb2e1455e83a58baa5ffc58", "url": "https://github.com/questdb/questdb/commit/f15fe2039b2c03893cb2e1455e83a58baa5ffc58", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-22T13:12:42Z", "type": "commit"}, {"oid": "f1e67609161067d52acd33965979b29f4cff8f34", "url": "https://github.com/questdb/questdb/commit/f1e67609161067d52acd33965979b29f4cff8f34", "message": "chore(cairo): Use factory correctly in TableBlockWriterTest", "committedDate": "2020-10-22T13:20:37Z", "type": "commit"}, {"oid": "ac0ea836641f796a49368303913f3fd4332aff14", "url": "https://github.com/questdb/questdb/commit/ac0ea836641f796a49368303913f3fd4332aff14", "message": "chore(cairo): Refactor PageFrame", "committedDate": "2020-10-22T13:22:22Z", "type": "commit"}, {"oid": "7b7cd9caa6f64cca425bba047f36e5ceaf34448b", "url": "https://github.com/questdb/questdb/commit/7b7cd9caa6f64cca425bba047f36e5ceaf34448b", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-22T16:56:37Z", "type": "commit"}, {"oid": "79d697fcc6b6ec4b0cf9e9a7c788c9b6127d7867", "url": "https://github.com/questdb/questdb/commit/79d697fcc6b6ec4b0cf9e9a7c788c9b6127d7867", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-23T14:37:04Z", "type": "commit"}, {"oid": "f4ab3e83bb9e5299051b4d8a3a204ec31456c7de", "url": "https://github.com/questdb/questdb/commit/f4ab3e83bb9e5299051b4d8a3a204ec31456c7de", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-23T16:40:47Z", "type": "commit"}, {"oid": "c4de88c2956e97ba48bf9ea2b471b792429b1430", "url": "https://github.com/questdb/questdb/commit/c4de88c2956e97ba48bf9ea2b471b792429b1430", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-26T10:29:33Z", "type": "commit"}, {"oid": "f00e66deb3d1fe627aa7be31141df427327bef33", "url": "https://github.com/questdb/questdb/commit/f00e66deb3d1fe627aa7be31141df427327bef33", "message": "Merge branch 'master' into replication", "committedDate": "2020-10-26T11:01:43Z", "type": "commit"}, {"oid": "be0f0ba6cb54553bc1702352dac6b5d7af2281c3", "url": "https://github.com/questdb/questdb/commit/be0f0ba6cb54553bc1702352dac6b5d7af2281c3", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T11:55:36Z", "type": "commit"}, {"oid": "052b1f320df2a66f88bf2059817d596376e10e1d", "url": "https://github.com/questdb/questdb/commit/052b1f320df2a66f88bf2059817d596376e10e1d", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T13:45:22Z", "type": "commit"}, {"oid": "434a006fcba8ce8092fb9c88ebd36987b4961143", "url": "https://github.com/questdb/questdb/commit/434a006fcba8ce8092fb9c88ebd36987b4961143", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T14:09:20Z", "type": "commit"}, {"oid": "c3e9cfd5a8f9dcefcb6f4f2f60ce9bb7f7f975f7", "url": "https://github.com/questdb/questdb/commit/c3e9cfd5a8f9dcefcb6f4f2f60ce9bb7f7f975f7", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T14:32:24Z", "type": "commit"}, {"oid": "47bc7c2ea5663e503f219a29e725a2bfc56687ec", "url": "https://github.com/questdb/questdb/commit/47bc7c2ea5663e503f219a29e725a2bfc56687ec", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T14:46:38Z", "type": "commit"}, {"oid": "63ff73cafd600c43e3c27a4bd30f2b5027801dd2", "url": "https://github.com/questdb/questdb/commit/63ff73cafd600c43e3c27a4bd30f2b5027801dd2", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T15:39:12Z", "type": "commit"}, {"oid": "83512acd018ae7dd9bd7cd8d3789dcfe12362388", "url": "https://github.com/questdb/questdb/commit/83512acd018ae7dd9bd7cd8d3789dcfe12362388", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T15:50:42Z", "type": "commit"}, {"oid": "077120ada123af47e34b91839f957f815fb860b2", "url": "https://github.com/questdb/questdb/commit/077120ada123af47e34b91839f957f815fb860b2", "message": "chore(blockwriter): code tidy up", "committedDate": "2020-10-29T11:53:10Z", "type": "commit"}, {"oid": "4bba3ba39bb9d5d12a84b47e773ba0103afb589f", "url": "https://github.com/questdb/questdb/commit/4bba3ba39bb9d5d12a84b47e773ba0103afb589f", "message": "chore(blockwriter): code tidy up", "committedDate": "2020-10-29T12:32:18Z", "type": "commit"}, {"oid": "b295a701369be3ff6f0ede49384815a36ffccecb", "url": "https://github.com/questdb/questdb/commit/b295a701369be3ff6f0ede49384815a36ffccecb", "message": "Merge branch 'master' into replication", "committedDate": "2020-10-29T12:34:04Z", "type": "commit"}, {"oid": "bacd6360b11ff45f64bb212a20c93dbc67fbc795", "url": "https://github.com/questdb/questdb/commit/bacd6360b11ff45f64bb212a20c93dbc67fbc795", "message": "chore(blockwriter): Reduce test resource usage", "committedDate": "2020-10-29T14:09:15Z", "type": "commit"}, {"oid": "57539df8f1b16979a5e19109f614474fdadeea89", "url": "https://github.com/questdb/questdb/commit/57539df8f1b16979a5e19109f614474fdadeea89", "message": "chore(blockwriter): Add more tests", "committedDate": "2020-10-29T14:13:38Z", "type": "commit"}, {"oid": "59fed07c2580d77e8f734e4449d2268aaf5247a9", "url": "https://github.com/questdb/questdb/commit/59fed07c2580d77e8f734e4449d2268aaf5247a9", "message": "chore(blockwriter): Fix fd leaks on open failure", "committedDate": "2020-10-29T14:50:50Z", "type": "commit"}, {"oid": "4afc5998e2ba0a6c24a199f352d3964848dafb88", "url": "https://github.com/questdb/questdb/commit/4afc5998e2ba0a6c24a199f352d3964848dafb88", "message": "Merge branch 'master' into replication", "committedDate": "2020-10-30T10:26:38Z", "type": "commit"}, {"oid": "784244d0b1a9aa823a0890411c827892393fc8cf", "url": "https://github.com/questdb/questdb/commit/784244d0b1a9aa823a0890411c827892393fc8cf", "message": "chore(cairo): split up DataFrame and PageFrame interfaces, removed redundant calculations for row count", "committedDate": "2020-10-30T13:53:08Z", "type": "commit"}, {"oid": "fe82919d5fb0ccde123d10ded9c1253bde1ec37f", "url": "https://github.com/questdb/questdb/commit/fe82919d5fb0ccde123d10ded9c1253bde1ec37f", "message": "feat(cairo): Replication\n\tAdd VirtualMemory.putRawBytes", "committedDate": "2020-04-29T08:22:29Z", "type": "forcePushed"}, {"oid": "4a648a6d0152e2e8e66a24970ba84928c34079b3", "url": "https://github.com/questdb/questdb/commit/4a648a6d0152e2e8e66a24970ba84928c34079b3", "message": "feat(cairo): Replication", "committedDate": "2020-05-04T22:16:47Z", "type": "forcePushed"}, {"oid": "44ed0c38c5b96ff6f07c5ade908da50f254aa246", "url": "https://github.com/questdb/questdb/commit/44ed0c38c5b96ff6f07c5ade908da50f254aa246", "message": "feat(cairo): Replication\n\tChange ServerMain to integrate pulsar\n\tAdd VirtualMemory.getRawBytes", "committedDate": "2020-05-11T15:41:32Z", "type": "commit"}, {"oid": "b63944dd70e86681a2a020ddfff5d2859416d607", "url": "https://github.com/questdb/questdb/commit/b63944dd70e86681a2a020ddfff5d2859416d607", "message": "feat(cairo): Replication\n\tAdd VirtualMemory.putRawBytes", "committedDate": "2020-05-11T15:41:32Z", "type": "commit"}, {"oid": "b3d620c9dafcc0ac1d5f8672109938d34b8fd51a", "url": "https://github.com/questdb/questdb/commit/b3d620c9dafcc0ac1d5f8672109938d34b8fd51a", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:41:32Z", "type": "commit"}, {"oid": "aecefe2d6de460caecd9b99821fe8e4971a46242", "url": "https://github.com/questdb/questdb/commit/aecefe2d6de460caecd9b99821fe8e4971a46242", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:44:23Z", "type": "commit"}, {"oid": "fb19f5c89ebbd3d9064bada0ff8a6800ba1bbc99", "url": "https://github.com/questdb/questdb/commit/fb19f5c89ebbd3d9064bada0ff8a6800ba1bbc99", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:44:23Z", "type": "commit"}, {"oid": "4b2fc4eee433b3bce4e5ecb43f42c49c38ff2f38", "url": "https://github.com/questdb/questdb/commit/4b2fc4eee433b3bce4e5ecb43f42c49c38ff2f38", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:44:24Z", "type": "commit"}, {"oid": "ef00ad0e92198c95e6cf3900753034c74fc91fa6", "url": "https://github.com/questdb/questdb/commit/ef00ad0e92198c95e6cf3900753034c74fc91fa6", "message": "feat(cairo): Replication\n Allow PGWireServer to be enabled", "committedDate": "2020-05-11T15:44:24Z", "type": "commit"}, {"oid": "ea1d72335b3390bf5d1f9d047aef4625dc4a3473", "url": "https://github.com/questdb/questdb/commit/ea1d72335b3390bf5d1f9d047aef4625dc4a3473", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:46:01Z", "type": "commit"}, {"oid": "ea1d72335b3390bf5d1f9d047aef4625dc4a3473", "url": "https://github.com/questdb/questdb/commit/ea1d72335b3390bf5d1f9d047aef4625dc4a3473", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:46:01Z", "type": "forcePushed"}, {"oid": "1c0bde6b9cb4c833fc103805afc866d6b31371f6", "url": "https://github.com/questdb/questdb/commit/1c0bde6b9cb4c833fc103805afc866d6b31371f6", "message": "feat(cairo): Replication", "committedDate": "2020-07-15T08:46:52Z", "type": "commit"}, {"oid": "ed04f5da398ea7db33c0e998ed4999c92178a4f6", "url": "https://github.com/questdb/questdb/commit/ed04f5da398ea7db33c0e998ed4999c92178a4f6", "message": "Merge tag '5.0.0' into replication", "committedDate": "2020-07-15T09:09:26Z", "type": "commit"}, {"oid": "9cfa8c691d60781d7be45d23d753a95d3f22ab24", "url": "https://github.com/questdb/questdb/commit/9cfa8c691d60781d7be45d23d753a95d3f22ab24", "message": "feat(cairo): Replication, fix memory leak", "committedDate": "2020-07-15T10:11:26Z", "type": "commit"}, {"oid": "10d03f0322b38f56af3b17c070595ae292e708e0", "url": "https://github.com/questdb/questdb/commit/10d03f0322b38f56af3b17c070595ae292e708e0", "message": "Merge branch 'master' into replication", "committedDate": "2020-07-15T13:29:33Z", "type": "commit"}, {"oid": "ac5f5ac831f74bef1b75202b5fd2d961bf1f804b", "url": "https://github.com/questdb/questdb/commit/ac5f5ac831f74bef1b75202b5fd2d961bf1f804b", "message": "feat(cairo): Replication, fix merge issues", "committedDate": "2020-07-15T14:00:06Z", "type": "commit"}, {"oid": "f0c3fed9fb2272cc50fc016c7d34bde7f4b83562", "url": "https://github.com/questdb/questdb/commit/f0c3fed9fb2272cc50fc016c7d34bde7f4b83562", "message": "chore: Improve SOUnboundedCountDownLatchTest efficiency", "committedDate": "2020-07-24T13:02:45Z", "type": "commit"}, {"oid": "e59fe53233b5f9f6dc97bf548d07df3d1d40087f", "url": "https://github.com/questdb/questdb/commit/e59fe53233b5f9f6dc97bf548d07df3d1d40087f", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-07-24T13:07:55Z", "type": "commit"}, {"oid": "d07afed18cd10e7c6381c3dd6a0a014dd2d1b04f", "url": "https://github.com/questdb/questdb/commit/d07afed18cd10e7c6381c3dd6a0a014dd2d1b04f", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-07-27T13:39:59Z", "type": "commit"}, {"oid": "c7f6e8970ce9b80dc89c5d8b635aadcd0ad6cdc6", "url": "https://github.com/questdb/questdb/commit/c7f6e8970ce9b80dc89c5d8b635aadcd0ad6cdc6", "message": "Merge branch 'master' into replication", "committedDate": "2020-07-27T13:57:56Z", "type": "commit"}, {"oid": "2a100e646f62830860bf8c003bf648370d469f47", "url": "https://github.com/questdb/questdb/commit/2a100e646f62830860bf8c003bf648370d469f47", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-07-27T14:34:30Z", "type": "commit"}, {"oid": "8eea2b1d3b4097b759e70c06d3bf13eba4d7f9b1", "url": "https://github.com/questdb/questdb/commit/8eea2b1d3b4097b759e70c06d3bf13eba4d7f9b1", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-07-29T13:32:39Z", "type": "commit"}, {"oid": "105152da243c54241bc9de5c36bc540f92f5e972", "url": "https://github.com/questdb/questdb/commit/105152da243c54241bc9de5c36bc540f92f5e972", "message": "Merge branch 'master' into replication", "committedDate": "2020-07-29T13:35:28Z", "type": "commit"}, {"oid": "b72a7da0e3ba4ca1bb424e22406b0fd08537a6c0", "url": "https://github.com/questdb/questdb/commit/b72a7da0e3ba4ca1bb424e22406b0fd08537a6c0", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-07-29T13:42:56Z", "type": "commit"}, {"oid": "fa92c1c8771d13a6ed5db8a5bdd19c45a7c6e2c3", "url": "https://github.com/questdb/questdb/commit/fa92c1c8771d13a6ed5db8a5bdd19c45a7c6e2c3", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-03T10:48:05Z", "type": "commit"}, {"oid": "1d804cce905c00a07965759e2a316a4f5d69a209", "url": "https://github.com/questdb/questdb/commit/1d804cce905c00a07965759e2a316a4f5d69a209", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-08-03T22:15:33Z", "type": "commit"}, {"oid": "26ef52d982e67650de58c51bc34c791ac91cd44f", "url": "https://github.com/questdb/questdb/commit/26ef52d982e67650de58c51bc34c791ac91cd44f", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-08-03T22:30:54Z", "type": "commit"}, {"oid": "01024a9cef33fddf6963f747a851c9b29d45a7a3", "url": "https://github.com/questdb/questdb/commit/01024a9cef33fddf6963f747a851c9b29d45a7a3", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-08-04T08:25:43Z", "type": "commit"}, {"oid": "5df53f228e199638443c1f7ade2e7780959f903a", "url": "https://github.com/questdb/questdb/commit/5df53f228e199638443c1f7ade2e7780959f903a", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-08-04T08:36:58Z", "type": "commit"}, {"oid": "bad6748f33eee5206bcfa31a107bf05a4d8cdc39", "url": "https://github.com/questdb/questdb/commit/bad6748f33eee5206bcfa31a107bf05a4d8cdc39", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-08-04T08:39:57Z", "type": "commit"}, {"oid": "fbc159a519301326a03fad694c9f932c432247e8", "url": "https://github.com/questdb/questdb/commit/fbc159a519301326a03fad694c9f932c432247e8", "message": "feat(cairo): Replication refactoring", "committedDate": "2020-08-04T08:54:46Z", "type": "commit"}, {"oid": "b5d195112f69aa52c9ab5845445bc2b695339ca1", "url": "https://github.com/questdb/questdb/commit/b5d195112f69aa52c9ab5845445bc2b695339ca1", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-12T07:14:22Z", "type": "commit"}, {"oid": "bf3f089108fd5a321d4832aaa1dba59bf1bfe454", "url": "https://github.com/questdb/questdb/commit/bf3f089108fd5a321d4832aaa1dba59bf1bfe454", "message": "feat(cairo): Replication refactoring", "committedDate": "2020-08-12T08:13:54Z", "type": "commit"}, {"oid": "dade6478de20892db9cc9059cf2917f3a1780085", "url": "https://github.com/questdb/questdb/commit/dade6478de20892db9cc9059cf2917f3a1780085", "message": "chore: Fix merge issues", "committedDate": "2020-08-12T08:14:09Z", "type": "commit"}, {"oid": "22900ed6244df2d2339f49692ed730277f5e8668", "url": "https://github.com/questdb/questdb/commit/22900ed6244df2d2339f49692ed730277f5e8668", "message": "feat(cairo): Add support for String columns to TableBlockWriter", "committedDate": "2020-08-14T10:21:23Z", "type": "commit"}, {"oid": "e36b69f829dca019fdf913005575b9125d41e6e0", "url": "https://github.com/questdb/questdb/commit/e36b69f829dca019fdf913005575b9125d41e6e0", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-14T10:24:34Z", "type": "commit"}, {"oid": "b3e1f1514a150d58b69af820759e9b55dd0236e9", "url": "https://github.com/questdb/questdb/commit/b3e1f1514a150d58b69af820759e9b55dd0236e9", "message": "feat(cairo): Add support for binary columns to TableBlockWriter", "committedDate": "2020-08-14T10:57:32Z", "type": "commit"}, {"oid": "e31427f20014a91faa4bda80c53fff4b88544fd5", "url": "https://github.com/questdb/questdb/commit/e31427f20014a91faa4bda80c53fff4b88544fd5", "message": "feat(cairo): Add support for binary columns to TableBlockWriter", "committedDate": "2020-08-14T13:02:23Z", "type": "commit"}, {"oid": "cf8a8a6cb0c60cac4f78fe36189a932a4516f6ad", "url": "https://github.com/questdb/questdb/commit/cf8a8a6cb0c60cac4f78fe36189a932a4516f6ad", "message": "feat(cairo): Add support for binary columns to TableBlockWriter", "committedDate": "2020-08-17T10:20:41Z", "type": "commit"}, {"oid": "e867e4d9d7f7a27d939e3060f938ffaca62a726b", "url": "https://github.com/questdb/questdb/commit/e867e4d9d7f7a27d939e3060f938ffaca62a726b", "message": "feat(cairo): Add support for binary columns to TableBlockWriter", "committedDate": "2020-08-17T12:41:45Z", "type": "commit"}, {"oid": "41c6ed2b7798508d11094f30b601da19a9940f47", "url": "https://github.com/questdb/questdb/commit/41c6ed2b7798508d11094f30b601da19a9940f47", "message": "chore(cairo): Fix memory leak in LimitRecordCursorFactory", "committedDate": "2020-08-19T11:10:44Z", "type": "commit"}, {"oid": "ee64f1fbc2eb5ed051b2dbaf80e4171aa2f8aa7e", "url": "https://github.com/questdb/questdb/commit/ee64f1fbc2eb5ed051b2dbaf80e4171aa2f8aa7e", "message": "feat(cairo): Fix issues with variable length columns", "committedDate": "2020-08-19T13:11:37Z", "type": "commit"}, {"oid": "0152c89521b944570c0d603ee75f3163df55e551", "url": "https://github.com/questdb/questdb/commit/0152c89521b944570c0d603ee75f3163df55e551", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-19T13:13:50Z", "type": "commit"}, {"oid": "5dd7a62446f27582715eca1d9884af5c45285364", "url": "https://github.com/questdb/questdb/commit/5dd7a62446f27582715eca1d9884af5c45285364", "message": "chore(cairo): Change SymbolMapReader to support symbolCharsAddressOf and replace ReadOnlyMemory with ExtendableOnePageMemory", "committedDate": "2020-08-20T09:31:33Z", "type": "commit"}, {"oid": "64378b1e7d4e2a177574caad948cbe9897f137ce", "url": "https://github.com/questdb/questdb/commit/64378b1e7d4e2a177574caad948cbe9897f137ce", "message": "chore(cairo): Fix exception message in test", "committedDate": "2020-08-20T09:51:52Z", "type": "commit"}, {"oid": "3a815e24130e08b7c0f71a808f9bbba8395bfa16", "url": "https://github.com/questdb/questdb/commit/3a815e24130e08b7c0f71a808f9bbba8395bfa16", "message": "feat(cairo): Add spoort for symbols to TableBlockWriter", "committedDate": "2020-08-20T10:50:07Z", "type": "commit"}, {"oid": "77a5ad4abbe76ce41ac6b783e82863a1e97bb622", "url": "https://github.com/questdb/questdb/commit/77a5ad4abbe76ce41ac6b783e82863a1e97bb622", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-08-20T16:37:34Z", "type": "commit"}, {"oid": "05db13c0e3cef9c909f7e3cd6e7fd4ad8d4194ab", "url": "https://github.com/questdb/questdb/commit/05db13c0e3cef9c909f7e3cd6e7fd4ad8d4194ab", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-08-20T21:20:09Z", "type": "commit"}, {"oid": "f1f7adf435af7afc56bd899f2fc7afb3a759ddb0", "url": "https://github.com/questdb/questdb/commit/f1f7adf435af7afc56bd899f2fc7afb3a759ddb0", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-08-21T13:29:08Z", "type": "commit"}, {"oid": "2f72d66a6918bc8f249d612f3ab36fab45ac8fe2", "url": "https://github.com/questdb/questdb/commit/2f72d66a6918bc8f249d612f3ab36fab45ac8fe2", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-08-21T14:09:17Z", "type": "commit"}, {"oid": "88d6eb4db7d9df1e2bf9192f02a533f10a9c8731", "url": "https://github.com/questdb/questdb/commit/88d6eb4db7d9df1e2bf9192f02a533f10a9c8731", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-21T14:28:51Z", "type": "commit"}, {"oid": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "url": "https://github.com/questdb/questdb/commit/bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-21T19:12:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwMDI1MQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475200251", "bodyText": "this needs fixing a bit more in so far as not checking if string fits the page when len = -1. I would probably make it looks like this emphasising hot path:\n    public final CharSequence getStr0(long offset, CharSequenceView view) {\n        final int len = getInt(offset);\n        if (len > -1 && offset + len * Character.BYTES + Integer.BYTES <= size) {\n            return view.of(offset + VirtualMemory.STRING_LENGTH_BYTES, len);\n        }\n        \n        if (len == TableUtils.NULL_LEN) {\n            return null;\n        }\n\n        throw CairoException.instance(0).put(\"String is outside of file boundary [offset=\").put(offset).put(\", len=\").put(len).put(']');\n    }", "author": "bluestreak01", "createdAt": "2020-08-23T10:10:22Z", "path": "core/src/main/java/io/questdb/cairo/OnePageMemory.java", "diffHunk": "@@ -232,7 +232,7 @@ public void getLong256(long offset, Long256Sink sink) {\n \n     public final CharSequence getStr0(long offset, CharSequenceView view) {\n         final int len = getInt(offset);\n-        if (offset + len + Integer.BYTES < size) {\n+        if (offset + len * 2 + Integer.BYTES <= size) {", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6707228abc015f13f7fc338815ff2ce72e633", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/OnePageMemory.java b/core/src/main/java/io/questdb/cairo/OnePageMemory.java\nindex 9f915fe14..c2794c954 100644\n--- a/core/src/main/java/io/questdb/cairo/OnePageMemory.java\n+++ b/core/src/main/java/io/questdb/cairo/OnePageMemory.java\n\n@@ -232,16 +238,13 @@ public class OnePageMemory implements ReadOnlyColumn, Closeable {\n \n     public final CharSequence getStr0(long offset, CharSequenceView view) {\n         final int len = getInt(offset);\n-        if (offset + len * 2 + Integer.BYTES <= size) {\n-            if (len == TableUtils.NULL_LEN) {\n-                return null;\n-            }\n-\n-            if (len == 0) {\n-                return \"\";\n-            }\n+        if (len > -1 && offset + len * Character.BYTES + Integer.BYTES <= size) {\n             return view.of(offset + VirtualMemory.STRING_LENGTH_BYTES, len);\n         }\n+\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n         throw CairoException.instance(0).put(\"String is outside of file boundary [offset=\").put(offset).put(\", len=\").put(len).put(']');\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNTQwNw==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475205407", "bodyText": "For \"overflown\" symbol index we should just return the high address of underlying memory.", "author": "bluestreak01", "createdAt": "2020-08-23T11:04:42Z", "path": "core/src/main/java/io/questdb/cairo/SymbolMapReaderImpl.java", "diffHunk": "@@ -204,4 +205,19 @@ private void growCharMemToSymbolCount(int symbolCount) {\n     private CharSequence uncachedValue(int key) {\n         return charMem.getStr(offsetMem.getLong(SymbolMapWriter.keyToOffset(key)));\n     }\n+\n+    @Override\n+    public long symbolCharsAddressOf(int symbolIndex) {\n+        if (symbolIndex < symbolCount) {\n+            long offset = offsetMem.getLong(SymbolMapWriter.keyToOffset(symbolIndex));\n+            return charMem.addressOf(offset);\n+        } else if (symbolIndex == symbolCount) {", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6707228abc015f13f7fc338815ff2ce72e633", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/SymbolMapReaderImpl.java b/core/src/main/java/io/questdb/cairo/SymbolMapReaderImpl.java\nindex ef4e37ad9..575df11d3 100644\n--- a/core/src/main/java/io/questdb/cairo/SymbolMapReaderImpl.java\n+++ b/core/src/main/java/io/questdb/cairo/SymbolMapReaderImpl.java\n\n@@ -193,13 +192,15 @@ public class SymbolMapReaderImpl implements Closeable, SymbolMapReader {\n     }\n \n     private void growCharMemToSymbolCount(int symbolCount) {\n+        long charMemLength;\n         if (symbolCount > 0) {\n             long lastSymbolOffset = this.offsetMem.getLong(SymbolMapWriter.keyToOffset(symbolCount - 1));\n             this.charMem.grow(lastSymbolOffset + 4);\n-            this.charMem.grow(lastSymbolOffset + this.charMem.getStrLen(lastSymbolOffset) * 2 + 4);\n+            charMemLength = lastSymbolOffset + this.charMem.getStrLen(lastSymbolOffset) * 2 + 4;\n         } else {\n-            this.charMem.grow(0);\n+            charMemLength = 0;\n         }\n+        this.charMem.grow(charMemLength);\n     }\n \n     private CharSequence uncachedValue(int key) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNjU5Ng==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475206596", "bodyText": "does Hash.hasMem() not work in this case?", "author": "bluestreak01", "createdAt": "2020-08-23T11:16:08Z", "path": "core/src/main/java/io/questdb/cairo/SymbolMapWriter.java", "diffHunk": "@@ -234,4 +243,41 @@ private int put0(CharSequence symbol, int hash) {\n         indexWriter.add(hash, offsetOffset);\n         return offsetToKey(offsetOffset);\n     }\n+\n+    public void appendSymbolCharsBlock(long blockLength, long sourceAddress) {\n+        long appendOffset = charMem.getAppendOffset();\n+        try {\n+            charMem.jumpTo(appendOffset);\n+            charMem.putBlockOfBytes(sourceAddress, blockLength);\n+        } finally {\n+            charMem.jumpTo(appendOffset);\n+        }\n+    }\n+\n+    public void commitAppendedBlock(int nSymbolsAdded) {\n+        long offset = charMem.getAppendOffset();\n+        int symbolIndex = getSymbolCount();\n+        int nSymbols = symbolIndex + nSymbolsAdded;\n+        while (symbolIndex < nSymbols) {\n+            long symCharsOffset = offset;\n+            int symLen = charMem.getInt(offset);\n+            offset += Integer.BYTES;\n+            long symCharsOffsetHi = offset + symLen * Character.BYTES;\n+            tmpSymbol.of(charMem.addressOf(offset), charMem.addressOf(symCharsOffsetHi));\n+\n+            long offsetOffset = offsetMem.getAppendOffset();\n+            offsetMem.putLong(symCharsOffset);\n+            int hash = Hash.boundedHash(tmpSymbol, maxHash);", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2Mjc1NQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r478562755", "bodyText": "The hashes generated are different", "author": "patrickSpaceSurfer", "createdAt": "2020-08-27T16:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNjU5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4fa5bf1d92503b8c2b262aa29b75aea610d59943", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/SymbolMapWriter.java b/core/src/main/java/io/questdb/cairo/SymbolMapWriter.java\nindex 8ec8084a1..aedb3bd28 100644\n--- a/core/src/main/java/io/questdb/cairo/SymbolMapWriter.java\n+++ b/core/src/main/java/io/questdb/cairo/SymbolMapWriter.java\n\n@@ -244,11 +244,11 @@ public class SymbolMapWriter implements Closeable {\n         return offsetToKey(offsetOffset);\n     }\n \n-    public void appendSymbolCharsBlock(long blockLength, long sourceAddress) {\n+    public void appendSymbolCharsBlock(long blockSize, long sourceAddress) {\n         long appendOffset = charMem.getAppendOffset();\n         try {\n             charMem.jumpTo(appendOffset);\n-            charMem.putBlockOfBytes(sourceAddress, blockLength);\n+            charMem.putBlockOfBytes(sourceAddress, blockSize);\n         } finally {\n             charMem.jumpTo(appendOffset);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNzA3OQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475207079", "bodyText": "This is a bad reference ownership. I feel this whole class can be part of TableWriter to avoid issues like this", "author": "bluestreak01", "createdAt": "2020-08-23T11:20:57Z", "path": "core/src/main/java/io/questdb/cairo/TableBlockWriter.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package io.questdb.cairo;\n+\n+import java.io.Closeable;\n+\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.ObjList;\n+import io.questdb.std.str.Path;\n+\n+public class TableBlockWriter implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TableBlockWriter.class);\n+    private TableWriter writer;\n+    private final ObjList<AppendMemory> columns = new ObjList<>();\n+    private final CharSequence root;\n+    private final FilesFacade ff;\n+    private final int mkDirMode;\n+    private final Path path = new Path();\n+\n+    private int rootLen;\n+    private RecordMetadata metadata;\n+    private int columnCount;\n+    private int partitionBy;\n+    private long partitionLo;\n+    private long partitionHi;\n+\n+    public TableBlockWriter(CairoConfiguration configuration) {\n+        root = configuration.getRoot();\n+        this.ff = configuration.getFilesFacade();\n+        this.mkDirMode = configuration.getMkDirMode();\n+    }\n+\n+    public void appendBlock(long timestamp, int columnIndex, long blockLength, long sourceAddress) {\n+        if (timestamp < partitionLo && partitionLo != Long.MAX_VALUE) {\n+            throw CairoException.instance(0).put(\"can only append [timestamp=\").put(timestamp).put(\", partitionLo=\").put(partitionLo).put(']');\n+        }\n+\n+        if (timestamp > partitionHi || partitionLo == Long.MAX_VALUE) {\n+            openPartition(timestamp);\n+        }\n+\n+        AppendMemory mem = columns.getQuick(columnIndex);\n+        long appendOffset = mem.getAppendOffset();\n+        try {\n+            mem.putBlockOfBytes(sourceAddress, blockLength);\n+        } finally {\n+            mem.jumpTo(appendOffset);\n+        }\n+    }\n+\n+    public void appendSymbolCharsBlock(int columnIndex, long blockLength, long sourceAddress) {\n+        writer.getSymbolMapWriter(columnIndex).appendSymbolCharsBlock(blockLength, sourceAddress);\n+    }\n+\n+    public void commitAppendedBlock(long firstTimestamp, long lastTimestamp, long nRowsAdded) {\n+        LOG.info().$(\"committing block write of \").$(nRowsAdded).$(\" rows to \").$(path).$(\" [firstTimestamp=\").$ts(firstTimestamp).$(\", lastTimestamp=\").$ts(lastTimestamp).$(']').$();\n+        writer.commitAppendedBlock(firstTimestamp, lastTimestamp, nRowsAdded);\n+        reset();\n+    }\n+\n+    private void openPartition(long timestamp) {\n+        try {\n+            partitionLo = timestamp;\n+            partitionHi = TableUtils.setPathForPartition(path, partitionBy, timestamp);\n+            int plen = path.length();\n+            if (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n+                throw CairoException.instance(ff.errno()).put(\"Cannot create directory: \").put(path);\n+            }\n+\n+            assert columnCount > 0;\n+            for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                final CharSequence name = metadata.getColumnName(columnIndex);\n+                AppendMemory mem = columns.getQuick(columnIndex);\n+                mem.of(ff, TableUtils.dFile(path.trimTo(plen), name), ff.getMapPageSize());\n+                mem.jumpTo(writer.getPrimaryAppendOffset(timestamp, columnIndex));\n+            }\n+            LOG.info().$(\"switched partition to '\").$(path).$('\\'').$();\n+        } finally {\n+            path.trimTo(rootLen);\n+        }\n+    }\n+\n+    public void of(TableWriter writer) {\n+        clear();\n+        this.writer = writer;\n+        metadata = writer.getMetadata();\n+        path.of(root).concat(writer.getName());\n+        rootLen = path.length();\n+        columnCount = metadata.getColumnCount();\n+        partitionBy = writer.getPartitionBy();\n+        int columnsSize = columns.size();\n+        while (columnsSize < columnCount) {\n+            columns.extendAndSet(columnsSize++, new AppendMemory());\n+        }\n+    }\n+\n+    public void clear() {\n+        if (null != writer) {", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6707228abc015f13f7fc338815ff2ce72e633", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/TableBlockWriter.java b/core/src/main/java/io/questdb/cairo/TableBlockWriter.java\nindex 097461a38..39e781d78 100644\n--- a/core/src/main/java/io/questdb/cairo/TableBlockWriter.java\n+++ b/core/src/main/java/io/questdb/cairo/TableBlockWriter.java\n\n@@ -1,122 +1,624 @@\n package io.questdb.cairo;\n \n+import static io.questdb.cairo.TableUtils.iFile;\n+\n import java.io.Closeable;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.LockSupport;\n \n+import io.questdb.MessageBus;\n import io.questdb.cairo.sql.RecordMetadata;\n import io.questdb.log.Log;\n import io.questdb.log.LogFactory;\n+import io.questdb.mp.Job;\n+import io.questdb.mp.RingQueue;\n+import io.questdb.mp.Sequence;\n import io.questdb.std.Files;\n import io.questdb.std.FilesFacade;\n+import io.questdb.std.LongList;\n+import io.questdb.std.LongObjHashMap;\n import io.questdb.std.ObjList;\n+import io.questdb.std.Unsafe;\n+import io.questdb.std.Vect;\n+import io.questdb.std.microtime.Timestamps;\n import io.questdb.std.str.Path;\n \n public class TableBlockWriter implements Closeable {\n     private static final Log LOG = LogFactory.getLog(TableBlockWriter.class);\n+    private static final Timestamps.TimestampFloorMethod NO_PARTITIONING_FLOOR = (ts) -> {\n+        return 0;\n+    };\n+\n     private TableWriter writer;\n-    private final ObjList<AppendMemory> columns = new ObjList<>();\n     private final CharSequence root;\n     private final FilesFacade ff;\n     private final int mkDirMode;\n-    private final Path path = new Path();\n+    private final RingQueue<TableBlockWriterTaskHolder> queue;\n+    private final Sequence pubSeq;\n+    private final LongList columnRowsAdded = new LongList();\n \n-    private int rootLen;\n     private RecordMetadata metadata;\n     private int columnCount;\n     private int partitionBy;\n-    private long partitionLo;\n-    private long partitionHi;\n+    private Timestamps.TimestampFloorMethod timestampFloorMethod;\n+    private int timestampColumnIndex;\n+    private long firstTimestamp;\n+    private long lastTimestamp;\n \n-    public TableBlockWriter(CairoConfiguration configuration) {\n+    private final LongObjHashMap<PartitionBlockWriter> partitionBlockWriterByTimestamp = new LongObjHashMap<>();\n+    private final ObjList<PartitionBlockWriter> partitionBlockWriters = new ObjList<>();\n+    private int nextPartitionBlockWriterIndex;\n+    private final ObjList<TableBlockWriterTask> concurrentTasks = new ObjList<>();\n+    private int nEnqueuedConcurrentTasks;\n+    private final AtomicInteger nCompletedConcurrentTasks = new AtomicInteger();;\n+    private PartitionBlockWriter partWriter;\n+\n+    TableBlockWriter(CairoConfiguration configuration, MessageBus messageBus) {\n         root = configuration.getRoot();\n         this.ff = configuration.getFilesFacade();\n         this.mkDirMode = configuration.getMkDirMode();\n+        queue = messageBus.getTableBlockWriterQueue();\n+        pubSeq = messageBus.getTableBlockWriterPubSequence();\n     }\n \n-    public void appendBlock(long timestamp, int columnIndex, long blockLength, long sourceAddress) {\n-        if (timestamp < partitionLo && partitionLo != Long.MAX_VALUE) {\n-            throw CairoException.instance(0).put(\"can only append [timestamp=\").put(timestamp).put(\", partitionLo=\").put(partitionLo).put(']');\n-        }\n+    public void startPageFrame(long timestampLo) {\n+        partWriter = getPartitionBlockWriter(timestampLo);\n+        partWriter.startPageFrame(timestampLo);\n+    }\n \n-        if (timestamp > partitionHi || partitionLo == Long.MAX_VALUE) {\n-            openPartition(timestamp);\n+    public void appendPageFrameColumn(int columnIndex, long pageFrameLength, long sourceAddress, long pageFrameNRows) {\n+        LOG.info().$(\"appending data\").$(\" [tableName=\").$(writer.getName()).$(\", columnIndex=\").$(columnIndex).$(\", pageFrameLength=\").$(pageFrameLength).$(\", pageFrameNRows=\")\n+                .$(pageFrameNRows).$(']').$();\n+        if (columnIndex == timestampColumnIndex) {\n+            long firstBlockTimetamp = Unsafe.getUnsafe().getLong(sourceAddress);\n+            if (firstBlockTimetamp < firstTimestamp) {\n+                firstTimestamp = firstBlockTimetamp;\n+            }\n+            long addr = sourceAddress + pageFrameLength - Long.BYTES;\n+            long lastBlockTimestamp = Unsafe.getUnsafe().getLong(addr);\n+            if (lastBlockTimestamp > lastTimestamp) {\n+                lastTimestamp = lastBlockTimestamp;\n+            }\n         }\n+        partWriter.appendPageFrameColumn(columnIndex, pageFrameLength, sourceAddress, pageFrameNRows);\n+    }\n \n-        AppendMemory mem = columns.getQuick(columnIndex);\n-        long appendOffset = mem.getAppendOffset();\n-        try {\n-            mem.putBlockOfBytes(sourceAddress, blockLength);\n-        } finally {\n-            mem.jumpTo(appendOffset);\n+    private TableBlockWriterTask getConcurrentTask() {\n+        if (concurrentTasks.size() <= nEnqueuedConcurrentTasks) {\n+            concurrentTasks.extendAndSet(nEnqueuedConcurrentTasks, new TableBlockWriterTask());\n         }\n+        return concurrentTasks.getQuick(nEnqueuedConcurrentTasks);\n     }\n \n-    public void appendSymbolCharsBlock(int columnIndex, long blockLength, long sourceAddress) {\n-        writer.getSymbolMapWriter(columnIndex).appendSymbolCharsBlock(blockLength, sourceAddress);\n-    }\n+    private void enqueueConcurrentTask(TableBlockWriterTask task) {\n+        assert concurrentTasks.getQuick(nEnqueuedConcurrentTasks) == task;\n+        assert !task.ready.get();\n+        task.ready.set(true);\n+        nEnqueuedConcurrentTasks++;\n \n-    public void commitAppendedBlock(long firstTimestamp, long lastTimestamp, long nRowsAdded) {\n-        LOG.info().$(\"committing block write of \").$(nRowsAdded).$(\" rows to \").$(path).$(\" [firstTimestamp=\").$ts(firstTimestamp).$(\", lastTimestamp=\").$ts(lastTimestamp).$(']').$();\n-        writer.commitAppendedBlock(firstTimestamp, lastTimestamp, nRowsAdded);\n-        reset();\n+        do {\n+            long seq = pubSeq.next();\n+            if (seq >= 0) {\n+                try {\n+                    queue.get(seq).task = task;\n+                } finally {\n+                    pubSeq.done(seq);\n+                }\n+                return;\n+            }\n+            if (seq == -1) {\n+                task.run();\n+                return;\n+            }\n+        } while (true);\n     }\n \n-    private void openPartition(long timestamp) {\n-        try {\n-            partitionLo = timestamp;\n-            partitionHi = TableUtils.setPathForPartition(path, partitionBy, timestamp);\n-            int plen = path.length();\n-            if (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n-                throw CairoException.instance(ff.errno()).put(\"Cannot create directory: \").put(path);\n+    private void completePendingConcurrentTasks(boolean cancel) {\n+        if (nCompletedConcurrentTasks.get() < nEnqueuedConcurrentTasks) {\n+            for (int n = 0; n < nEnqueuedConcurrentTasks; n++) {\n+                TableBlockWriterTask task = concurrentTasks.getQuick(n);\n+                if (cancel) {\n+                    task.cancel();\n+                } else {\n+                    task.run();\n+                }\n             }\n+        }\n \n-            assert columnCount > 0;\n-            for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n-                final CharSequence name = metadata.getColumnName(columnIndex);\n-                AppendMemory mem = columns.getQuick(columnIndex);\n-                mem.of(ff, TableUtils.dFile(path.trimTo(plen), name), ff.getMapPageSize());\n-                mem.jumpTo(writer.getPrimaryAppendOffset(timestamp, columnIndex));\n-            }\n-            LOG.info().$(\"switched partition to '\").$(path).$('\\'').$();\n-        } finally {\n-            path.trimTo(rootLen);\n+        while (nCompletedConcurrentTasks.get() < nEnqueuedConcurrentTasks) {\n+            LockSupport.parkNanos(0);\n+        }\n+        nEnqueuedConcurrentTasks = 0;\n+        nCompletedConcurrentTasks.set(0);\n+    }\n+\n+    public void appendSymbolCharsBlock(int columnIndex, long blockLength, long sourceAddress) {\n+        LOG.info().$(\"appending symbols\").$(\" [tableName=\").$(writer.getName()).$(\", columnIndex=\").$(columnIndex).$(\", blockLength=\").$(blockLength).$(']').$();\n+        writer.getSymbolMapWriter(columnIndex).appendSymbolCharsBlock(blockLength, sourceAddress);\n+    }\n+\n+    public void commit() {\n+        LOG.info().$(\"committing block write\").$(\" [tableName=\").$(writer.getName()).$(\", firstTimestamp=\").$ts(firstTimestamp).$(\", lastTimestamp=\").$ts(lastTimestamp).$(']').$();\n+        // Need to complete all data tasks before we can start index tasks\n+        completePendingConcurrentTasks(false);\n+        long nTotalRowsAdded = 0;\n+        for (int n = 0; n < nextPartitionBlockWriterIndex; n++) {\n+            PartitionBlockWriter partWriter = partitionBlockWriters.get(n);\n+            partWriter.startCommitAppendedBlock();\n+            nTotalRowsAdded += partWriter.nRowsAdded;\n         }\n+        completePendingConcurrentTasks(false);\n+        writer.commitBlock(firstTimestamp, lastTimestamp, nTotalRowsAdded);\n+        LOG.info().$(\"commited new block [table=\").$(writer.getName()).$(']').$();\n+        clear();\n     }\n \n-    public void of(TableWriter writer) {\n+    public void cancel() {\n+        completePendingConcurrentTasks(true);\n+        writer.cancelRow();\n+        LOG.info().$(\"cancelled new block [table=\").$(writer.getName()).$(']').$();\n         clear();\n+    }\n+\n+    void open(TableWriter writer) {\n         this.writer = writer;\n         metadata = writer.getMetadata();\n-        path.of(root).concat(writer.getName());\n-        rootLen = path.length();\n         columnCount = metadata.getColumnCount();\n         partitionBy = writer.getPartitionBy();\n-        int columnsSize = columns.size();\n-        while (columnsSize < columnCount) {\n-            columns.extendAndSet(columnsSize++, new AppendMemory());\n+        columnRowsAdded.ensureCapacity(columnCount);\n+        timestampColumnIndex = metadata.getTimestampIndex();\n+        firstTimestamp = timestampColumnIndex >= 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        lastTimestamp = timestampColumnIndex >= 0 ? Long.MIN_VALUE : 0;\n+        nEnqueuedConcurrentTasks = 0;\n+        nCompletedConcurrentTasks.set(0);\n+        switch (partitionBy) {\n+            case PartitionBy.DAY:\n+                timestampFloorMethod = Timestamps.FLOOR_DD;\n+                break;\n+            case PartitionBy.MONTH:\n+                timestampFloorMethod = Timestamps.FLOOR_MM;\n+                break;\n+            case PartitionBy.YEAR:\n+                timestampFloorMethod = Timestamps.FLOOR_YYYY;\n+                break;\n+            default:\n+                timestampFloorMethod = NO_PARTITIONING_FLOOR;\n+                break;\n         }\n+        LOG.info().$(\"started new block [table=\").$(writer.getName()).$(']').$();\n     }\n \n-    public void clear() {\n-        if (null != writer) {\n-            writer.close();\n-            metadata = null;\n-            writer = null;\n+    void clear() {\n+        if (nCompletedConcurrentTasks.get() < nEnqueuedConcurrentTasks) {\n+            LOG.error().$(\"new block should have been either committed or cancelled [table=\").$(writer.getName()).$(']').$();\n+            completePendingConcurrentTasks(true);\n         }\n-        reset();\n-    }\n-\n-    private void reset() {\n-        for (int i = 0, sz = columns.size(); i < sz; i++) {\n-            columns.getQuick(i).close(false);\n+        metadata = null;\n+        writer = null;\n+        partWriter = null;\n+        for (int i = 0; i < nextPartitionBlockWriterIndex; i++) {\n+            partitionBlockWriters.getQuick(i).clear();\n         }\n-        partitionLo = Long.MAX_VALUE;\n-        partitionHi = Long.MIN_VALUE;\n+        nextPartitionBlockWriterIndex = 0;\n+        partitionBlockWriterByTimestamp.clear();\n     }\n \n     @Override\n     public void close() {\n         clear();\n-        columns.clear();\n-        path.close();\n+        for (int i = 0, sz = partitionBlockWriters.size(); i < sz; i++) {\n+            partitionBlockWriters.getQuick(i).close();\n+        }\n+        partitionBlockWriters.clear();\n+    }\n+\n+    private PartitionBlockWriter getPartitionBlockWriter(long timestamp) {\n+        long timestampLo = timestampFloorMethod.floor(timestamp);\n+        PartitionBlockWriter partWriter = partitionBlockWriterByTimestamp.get(timestampLo);\n+        if (null == partWriter) {\n+            assert nextPartitionBlockWriterIndex <= partitionBlockWriters.size();\n+            if (nextPartitionBlockWriterIndex == partitionBlockWriters.size()) {\n+                partWriter = new PartitionBlockWriter();\n+                partitionBlockWriters.extendAndSet(nextPartitionBlockWriterIndex, partWriter);\n+            } else {\n+                partWriter = partitionBlockWriters.getQuick(nextPartitionBlockWriterIndex);\n+            }\n+            nextPartitionBlockWriterIndex++;\n+            partitionBlockWriterByTimestamp.put(timestampLo, partWriter);\n+            partWriter.of(timestampLo);\n+        }\n+\n+        return partWriter;\n+    }\n+\n+    private class PartitionBlockWriter {\n+        private final LongList columnFds = new LongList();\n+        private final LongList columnMappingStart = new LongList();\n+        private final LongList columnMappingSize = new LongList();\n+        private final LongList additionalMappingStart = new LongList();\n+        private final LongList additionalMappingSize = new LongList();\n+        private final LongList columnStartOffsets = new LongList();\n+        private final LongList columnAppendOffsets = new LongList();\n+        private final LongList columnTops = new LongList();\n+        private final Path path = new Path();\n+        private long timestampLo;\n+        private long timestampHi;\n+        private long nRowsAdded;\n+        private long pageFrameMaxNRows;\n+        private boolean opened;\n+\n+        private void of(long timestampLo) {\n+            this.timestampLo = timestampLo;\n+            opened = false;\n+            columnTops.ensureCapacity(columnCount);\n+            int requiredColumnsSize = columnCount << 1;\n+            columnAppendOffsets.ensureCapacity(requiredColumnsSize);\n+            columnStartOffsets.ensureCapacity(requiredColumnsSize);\n+\n+            columnFds.ensureCapacity(requiredColumnsSize);\n+            columnMappingStart.ensureCapacity(columnCount);\n+            columnMappingSize.ensureCapacity(columnCount);\n+        }\n+\n+        private void startPageFrame(long timestamp) {\n+            if (!opened) {\n+                path.of(root).concat(writer.getName());\n+                timestampHi = TableUtils.setPathForPartition(path, partitionBy, timestampLo);\n+                int plen = path.length();\n+                if (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n+                    throw CairoException.instance(ff.errno()).put(\"Cannot create directory: \").put(path);\n+                }\n+\n+                assert columnCount > 0;\n+                columnTops.setAll(columnCount, -1);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    final CharSequence name = metadata.getColumnName(columnIndex);\n+                    long appendOffset = writer.getPrimaryAppendOffset(timestampLo, columnIndex);\n+                    columnAppendOffsets.setQuick(columnIndex, appendOffset);\n+                    columnStartOffsets.setQuick(columnIndex, appendOffset);\n+\n+                    long fd = ff.openRW(TableUtils.dFile(path.trimTo(plen), name));\n+                    if (fd == -1) {\n+                        throw CairoException.instance(ff.errno()).put(\"Cannot open \").put(name);\n+                    }\n+                    int i = columnIndex * 2;\n+                    columnFds.setQuick(i, fd);\n+                    switch (metadata.getColumnType(columnIndex)) {\n+                        case ColumnType.STRING:\n+                        case ColumnType.BINARY:\n+                            fd = ff.openRW(iFile(path.trimTo(plen), name));\n+                            if (fd == -1) {\n+                                throw CairoException.instance(ff.errno()).put(\"Cannot open \").put(name);\n+                            }\n+                            columnFds.setQuick(i + 1, fd);\n+                            break;\n+                        default:\n+                            columnFds.setQuick(i + 1, -1);\n+                    }\n+                }\n+\n+                nRowsAdded = 0;\n+                pageFrameMaxNRows = 0;\n+                opened = true;\n+                LOG.info().$(\"opened partition to '\").$(path).$('\\'').$();\n+            } else {\n+                nRowsAdded += pageFrameMaxNRows;\n+                pageFrameMaxNRows = 0;\n+            }\n+            assert timestamp == Long.MIN_VALUE || timestamp >= timestampLo;\n+            assert timestamp <= timestampHi;\n+            timestampLo = timestamp;\n+        }\n+\n+        private void appendPageFrameColumn(int columnIndex, long pageFrameLength, long sourceAddress, long pageFrameNRows) {\n+            if (pageFrameNRows > pageFrameMaxNRows) {\n+                pageFrameMaxNRows = pageFrameNRows;\n+            }\n+            if (sourceAddress != 0) {\n+                long appendOffset = columnAppendOffsets.getQuick(columnIndex);\n+                long nextAppendOffset = appendOffset + pageFrameLength;\n+                columnAppendOffsets.setQuick(columnIndex, nextAppendOffset);\n+\n+                long destAddress;\n+                long columnStartAddress = columnMappingStart.getQuick(columnIndex);\n+                if (columnStartAddress == 0) {\n+                    int i = columnIndex << 1;\n+                    long mapSz = pageFrameLength > ff.getMapPageSize() ? pageFrameLength : ff.getMapPageSize();\n+                    long address = mapFile(columnFds.getQuick(i), appendOffset, mapSz);\n+                    columnMappingStart.setQuick(columnIndex, address);\n+                    columnMappingSize.setQuick(columnIndex, mapSz);\n+                    columnStartAddress = address;\n+                    destAddress = columnStartAddress;\n+                } else {\n+                    long initialOffset = columnStartOffsets.getQuick(columnIndex);\n+                    assert initialOffset < appendOffset;\n+                    if ((nextAppendOffset - initialOffset) > columnMappingSize.getQuick(columnIndex)) {\n+                        // TODO\n+                        throw new RuntimeException();\n+                    }\n+                    destAddress = columnMappingStart.getQuick(columnIndex) + appendOffset - initialOffset;\n+                }\n+\n+                TableBlockWriterTask task = getConcurrentTask();\n+                task.assignAppendPageFrameColumn(destAddress, pageFrameLength, sourceAddress);\n+                enqueueConcurrentTask(task);\n+            } else {\n+                partWriter.setColumnTop(columnIndex, pageFrameLength);\n+            }\n+        }\n+\n+        private void setColumnTop(int columnIndex, long columnTop) {\n+            columnTops.set(columnIndex, columnTop);\n+        }\n+\n+        private void startCommitAppendedBlock() {\n+            nRowsAdded += pageFrameMaxNRows;\n+            pageFrameMaxNRows = 0;\n+            long blockLastTimestamp = timestampHi < lastTimestamp ? timestampHi : lastTimestamp;\n+            LOG.info().$(\"committing \").$(nRowsAdded).$(\" rows to partition at \").$(path).$(\" [firstTimestamp=\").$ts(timestampLo).$(\", lastTimestamp=\").$ts(timestampHi).$(']').$();\n+            writer.startAppendedBlock(timestampLo, blockLastTimestamp, nRowsAdded, columnTops);\n+\n+            for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                int columnType = metadata.getColumnType(columnIndex);\n+                long columnTop = columnTops.getQuick(columnIndex);\n+                long colNRowsAdded = columnTop > 0 ? nRowsAdded - columnTop : nRowsAdded;\n+                if (colNRowsAdded > 0) {\n+                    // Add binary and string indexes\n+                    switch (columnType) {\n+                        case ColumnType.STRING:\n+                        case ColumnType.BINARY: {\n+                            TableBlockWriterTask task = getConcurrentTask();\n+                            long offsetLo = columnStartOffsets.getQuick(columnIndex);\n+                            long offsetHi = columnAppendOffsets.getQuick(columnIndex);\n+\n+                            long columnDataAddressLo = columnMappingStart.getQuick(columnIndex);\n+                            assert offsetHi - offsetLo <= columnMappingSize.getQuick(columnIndex);\n+                            long columnDataAddressHi = columnDataAddressLo + offsetHi - offsetLo;\n+                            long columnDataOffsetLo = offsetLo;\n+\n+                            int i = (columnIndex << 1) + 1;\n+                            long indexFd = columnFds.getQuick(i);\n+                            long indexOffsetLo = writer.getSecondaryAppendOffset(timestampLo, columnIndex);\n+                            long indexMappingSz = Long.BYTES * colNRowsAdded;\n+                            long indexMappingStart = mapFile(indexFd, indexOffsetLo, indexMappingSz);\n+                            additionalMappingStart.add(indexMappingStart);\n+                            additionalMappingSize.add(indexMappingSz);\n+\n+                            if (columnType == ColumnType.STRING) {\n+                                task.assignUpdateStringIndex(columnDataAddressLo, columnDataAddressHi, columnDataOffsetLo, indexMappingStart);\n+                            } else {\n+                                task.assignUpdateBinaryIndex(columnDataAddressLo, columnDataAddressHi, columnDataOffsetLo, indexMappingStart);\n+                            }\n+                            enqueueConcurrentTask(task);\n+                            break;\n+                        }\n+\n+                        case ColumnType.SYMBOL: {\n+                            completeUpdateSymbolCache(columnIndex, colNRowsAdded);\n+                            break;\n+                        }\n+\n+                        default:\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void completeUpdateSymbolCache(int columnIndex, long colNRowsAdded) {\n+            long address = columnMappingStart.getQuick(columnIndex);\n+            assert address > 0;\n+            int nSymbols = Vect.maxInt(address, colNRowsAdded);\n+            nSymbols++;\n+            SymbolMapWriter symWriter = writer.getSymbolMapWriter(columnIndex);\n+            if (nSymbols > symWriter.getSymbolCount()) {\n+                symWriter.commitAppendedBlock(nSymbols - symWriter.getSymbolCount());\n+            }\n+        }\n+\n+        private void clear() {\n+            if (opened) {\n+                int i = 0;\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    long fd = columnFds.getQuick(i++);\n+                    ff.close(fd);\n+                    fd = columnFds.getQuick(i++);\n+                    if (fd != -1) {\n+                        ff.close(fd);\n+                    }\n+                    long address = columnMappingStart.getQuick(columnIndex);\n+                    if (address != 0) {\n+                        long sz = columnMappingSize.getQuick(columnIndex);\n+                        unmapFile(address, sz);\n+                        columnMappingStart.setQuick(columnIndex, 0);\n+                    }\n+                }\n+                int nAdditonalMappings = additionalMappingStart.size();\n+                for (i = 0; i < nAdditonalMappings; i++) {\n+                    long address = additionalMappingStart.get(i);\n+                    long sz = additionalMappingSize.getQuick(i);\n+                    unmapFile(address, sz);\n+                }\n+                columnFds.clear();\n+                columnMappingStart.clear();\n+                columnMappingSize.clear();\n+                additionalMappingStart.clear();\n+                additionalMappingSize.clear();\n+            }\n+            opened = false;\n+        }\n+\n+        private long mapFile(long fd, final long mapOffset, final long mapSz) {\n+            long alignedMapOffset = (mapOffset / ff.getPageSize()) * ff.getPageSize();\n+            long addressOffsetDueToAlignment = mapOffset - alignedMapOffset;\n+            long alignedMapSz = mapSz + addressOffsetDueToAlignment;\n+            long fileSz = ff.length(fd);\n+            long minFileSz = mapOffset + alignedMapSz;\n+            if (fileSz < minFileSz) {\n+                if (!ff.truncate(fd, minFileSz)) {\n+                    throw CairoException.instance(ff.errno()).put(\"Could not truncate file for append fd=\").put(fd).put(\", offset=\").put(mapOffset).put(\", size=\")\n+                            .put(mapSz);\n+                }\n+            }\n+            long address = ff.mmap(fd, alignedMapSz, alignedMapOffset, Files.MAP_RW);\n+            if (address == -1) {\n+                int errno = ff.errno();\n+                throw CairoException.instance(ff.errno()).put(\"Could not mmap append fd=\").put(fd).put(\", offset=\").put(mapOffset).put(\", size=\").put(mapSz).put(\", errno=\")\n+                        .put(errno);\n+            }\n+            assert (address / ff.getPageSize()) * ff.getPageSize() == address; // address MUST be page aligned\n+            return address + addressOffsetDueToAlignment;\n+        }\n+\n+        private void unmapFile(final long address, final long mapSz) {\n+            long alignedAddress = (address / ff.getPageSize()) * ff.getPageSize();\n+            long alignedMapSz = mapSz + address - alignedAddress;\n+            ff.munmap(alignedAddress, alignedMapSz);\n+        }\n+\n+        private void close() {\n+            timestampLo = 0;\n+            path.close();\n+            opened = false;\n+        }\n+    }\n+\n+    public static class TableBlockWriterTaskHolder {\n+        private TableBlockWriterTask task;\n+    }\n+\n+    private enum TaskType {\n+        AppendBlock, GenerateStringIndex, GenerateBinaryIndex\n+    };\n+\n+    private class TableBlockWriterTask {\n+        private TaskType taskType;\n+        private final AtomicBoolean ready = new AtomicBoolean(false);\n+        private long sourceAddress;\n+        private long sourceSizeOrEnd;\n+        private long destAddress;\n+        private long sourceInitialOffset;\n+\n+        private boolean run() {\n+            if (ready.compareAndSet(true, false)) {\n+                try {\n+                    switch (taskType) {\n+                        case AppendBlock:\n+                            Unsafe.getUnsafe().copyMemory(sourceAddress, destAddress, sourceSizeOrEnd);\n+                            return true;\n+\n+                        case GenerateStringIndex:\n+                            completeUpdateStringIndex(sourceAddress, sourceSizeOrEnd, sourceInitialOffset, destAddress);\n+                            return true;\n+\n+                        case GenerateBinaryIndex:\n+                            completeUpdateBinaryIndex(sourceAddress, sourceSizeOrEnd, sourceInitialOffset, destAddress);\n+                            return true;\n+                    }\n+                } finally {\n+                    nCompletedConcurrentTasks.incrementAndGet();\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private void cancel() {\n+            if (ready.compareAndSet(true, false)) {\n+                nCompletedConcurrentTasks.incrementAndGet();\n+            }\n+        }\n+\n+        private void assignAppendPageFrameColumn(long destAddress, long pageFrameLength, long sourceAddress) {\n+            taskType = TaskType.AppendBlock;\n+            this.destAddress = destAddress;\n+            this.sourceSizeOrEnd = pageFrameLength;\n+            this.sourceAddress = sourceAddress;\n+        }\n+\n+        private void assignUpdateStringIndex(long columnDataAddressLo, long columnDataAddressHi, long columnDataOffsetLo, long columnIndexAddressLo) {\n+            taskType = TaskType.GenerateStringIndex;\n+            this.sourceAddress = columnDataAddressLo;\n+            this.destAddress = columnIndexAddressLo;\n+            this.sourceSizeOrEnd = columnDataAddressHi;\n+            this.sourceInitialOffset = columnDataOffsetLo;\n+        }\n+\n+        private void completeUpdateStringIndex(long columnDataAddressLo, long columnDataAddressHi, long columnDataOffsetLo, long columnIndexAddressLo) {\n+            long offset = columnDataOffsetLo;\n+            long columnDataAddress = columnDataAddressLo;\n+            long columnIndexAddress = columnIndexAddressLo;\n+            while (columnDataAddress < columnDataAddressHi) {\n+                Unsafe.getUnsafe().putLong(columnIndexAddress, offset);\n+                columnIndexAddress += Long.BYTES;\n+                long strLen = Unsafe.getUnsafe().getInt(columnDataAddress);\n+                long sz;\n+                if (strLen == TableUtils.NULL_LEN) {\n+                    sz = VirtualMemory.STRING_LENGTH_BYTES;\n+                } else {\n+                    sz = VirtualMemory.STRING_LENGTH_BYTES + 2 * strLen;\n+                }\n+                columnDataAddress += sz;\n+                offset += sz;\n+            }\n+        }\n+\n+        private void assignUpdateBinaryIndex(long columnDataAddressLo, long columnDataAddressHi, long columnDataOffsetLo, long columnIndexAddressLo) {\n+            taskType = TaskType.GenerateBinaryIndex;\n+            this.sourceAddress = columnDataAddressLo;\n+            this.destAddress = columnIndexAddressLo;\n+            this.sourceSizeOrEnd = columnDataAddressHi;\n+            this.sourceInitialOffset = columnDataOffsetLo;\n+        }\n+\n+        private void completeUpdateBinaryIndex(long columnDataAddressLo, long columnDataAddressHi, long columnDataOffsetLo, long columnIndexAddressLo) {\n+            long offset = columnDataOffsetLo;\n+            long columnDataAddress = columnDataAddressLo;\n+            long columnIndexAddress = columnIndexAddressLo;\n+            while (columnDataAddress < columnDataAddressHi) {\n+                Unsafe.getUnsafe().putLong(columnIndexAddress, offset);\n+                columnIndexAddress += Long.BYTES;\n+                long binLen = Unsafe.getUnsafe().getLong(columnDataAddress);\n+                long sz;\n+                if (binLen == TableUtils.NULL_LEN) {\n+                    sz = Long.BYTES;\n+                } else {\n+                    sz = Long.BYTES + binLen;\n+                }\n+                columnDataAddress += sz;\n+                offset += sz;\n+            }\n+        }\n+    }\n+\n+    public static class TableBlockWriterJob implements Job {\n+        private final RingQueue<TableBlockWriterTaskHolder> queue;\n+        private final Sequence subSeq;\n+\n+        public TableBlockWriterJob(MessageBus messageBus) {\n+            this.queue = messageBus.getTableBlockWriterQueue();\n+            this.subSeq = messageBus.getTableBlockWriterSubSequence();\n+        }\n+\n+        @Override\n+        public boolean run(int workerId) {\n+            boolean useful = false;\n+            while (true) {\n+                long cursor = subSeq.next();\n+                if (cursor >= 0) {\n+                    try {\n+                        final TableBlockWriterTaskHolder holder = queue.get(cursor);\n+                        useful |= holder.task.run();\n+                        holder.task = null;\n+                    } finally {\n+                        subSeq.done(cursor);\n+                    }\n+                }\n+\n+                if (cursor == -1) {\n+                    return useful;\n+                }\n+            }\n+        }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNzI2NQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475207265", "bodyText": "this algorithm does not take into account column tops. Something that another implementation of framing does. Column top is non-zero when column is added to table after table was populated.", "author": "bluestreak01", "createdAt": "2020-08-23T11:23:03Z", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6707228abc015f13f7fc338815ff2ce72e633", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java b/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\nindex a294d21c0..c3654c5cc 100644\n--- a/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\n+++ b/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\n\n@@ -1,24 +1,20 @@\n package io.questdb.cairo;\n \n-import org.jetbrains.annotations.Nullable;\n-\n import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n-import io.questdb.cairo.sql.PageFrame;\n-import io.questdb.cairo.sql.PageFrameCursor;\n import io.questdb.cairo.sql.RecordCursor;\n import io.questdb.cairo.sql.RecordMetadata;\n-import io.questdb.cairo.sql.SymbolTable;\n import io.questdb.griffin.SqlExecutionContext;\n import io.questdb.std.IntList;\n-import io.questdb.std.LongList;\n import io.questdb.std.Misc;\n import io.questdb.std.Numbers;\n-import io.questdb.std.Unsafe;\n \n public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n-    private final TableReplicationRecordCursor cursor;\n+    private final TablePageFrameCursor cursor;\n     private final CairoEngine engine;\n     private final CharSequence tableName;\n+    private final long maxRowsPerFrame;\n+    private final IntList columnIndexes;\n+    private final IntList columnSizes;\n \n     private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n         try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNzUyNQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475207525", "bodyText": "can max symbol index be calculated from table reader?", "author": "bluestreak01", "createdAt": "2020-08-23T11:25:47Z", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);\n+                        int maxSymbolIndex = nSymbolsProcessed.getQuick(columnIndex) - 1;\n+                        // TODO: Use vector instructions (rosti?) to find max\n+                        for (int nRow = 0; nRow < nRows; nRow++) {\n+                            int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                            symbolIndexAddess += Integer.BYTES;\n+                            maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6707228abc015f13f7fc338815ff2ce72e633", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java b/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\nindex a294d21c0..c3654c5cc 100644\n--- a/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\n+++ b/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\n\n@@ -1,24 +1,20 @@\n package io.questdb.cairo;\n \n-import org.jetbrains.annotations.Nullable;\n-\n import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n-import io.questdb.cairo.sql.PageFrame;\n-import io.questdb.cairo.sql.PageFrameCursor;\n import io.questdb.cairo.sql.RecordCursor;\n import io.questdb.cairo.sql.RecordMetadata;\n-import io.questdb.cairo.sql.SymbolTable;\n import io.questdb.griffin.SqlExecutionContext;\n import io.questdb.std.IntList;\n-import io.questdb.std.LongList;\n import io.questdb.std.Misc;\n import io.questdb.std.Numbers;\n-import io.questdb.std.Unsafe;\n \n public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n-    private final TableReplicationRecordCursor cursor;\n+    private final TablePageFrameCursor cursor;\n     private final CairoEngine engine;\n     private final CharSequence tableName;\n+    private final long maxRowsPerFrame;\n+    private final IntList columnIndexes;\n+    private final IntList columnSizes;\n \n     private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n         try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwODAzMQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475208031", "bodyText": "if we use ContiguousPages the limit of row can be calculated as:\n  if (row < count - 1) \n      hi = getOffset(row+1)\n else \n      hi = pageSize", "author": "bluestreak01", "createdAt": "2020-08-23T11:30:57Z", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);\n+                        int maxSymbolIndex = nSymbolsProcessed.getQuick(columnIndex) - 1;\n+                        // TODO: Use vector instructions (rosti?) to find max\n+                        for (int nRow = 0; nRow < nRows; nRow++) {\n+                            int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                            symbolIndexAddess += Integer.BYTES;\n+                            maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                        }\n+                        nSymbolsProcessed.setQuick(columnIndex, maxSymbolIndex + 1);\n+                    }\n+                }\n+                nRows = -1;\n+            }\n+\n+            return this;\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader) {\n+            this.reader = reader;\n+            columnCount = reader.getMetadata().getColumnCount();\n+            timestampColumnIndex = reader.getMetadata().getTimestampIndex();\n+            columnFrameAddresses.ensureCapacity(columnCount);\n+            columnFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.ensureCapacity(columnCount);\n+            symbolCharsFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.setAll(columnCount, -1);\n+            symbolCharsFrameLengths.setAll(columnCount, 0);\n+            toTop();\n+            return this;\n+        }\n+\n+        @Override\n+        public @Nullable ReplicationPageFrame next() {\n+            while (++partitionIndex < partitionCount) {\n+                nFrameRows = reader.openPartition(partitionIndex);\n+                if (nFrameRows > nFirstFrameRow) {\n+                    final int base = reader.getColumnBase(partitionIndex);\n+                    for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long columnPageAddress = col.getPageAddress(0);\n+                        long columnPageLength;\n+\n+                        int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                        switch (columnType) {\n+                            case ColumnType.STRING: {\n+                                final ReadOnlyColumn strLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateStringPagePosition(col, strLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateStringPagePosition(col, strLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            case ColumnType.BINARY: {\n+                                final ReadOnlyColumn binLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateBinaryPagePosition(col, binLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateBinaryPagePosition(col, binLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            default: {\n+                                int columnSizeBinaryPower = Numbers.msb(ColumnType.sizeOf(reader.getMetadata().getColumnType(columnIndex)));\n+                                columnPageLength = nFrameRows << columnSizeBinaryPower;\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = nFirstFrameRow << columnSizeBinaryPower;\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+                            }\n+                        }\n+\n+                        columnFrameAddresses.setQuick(columnIndex, columnPageAddress);\n+                        columnFrameLengths.setQuick(columnIndex, columnPageLength);\n+\n+                        if (timestampColumnIndex == columnIndex) {\n+                            firstTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress);\n+                            lastTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress + columnPageLength - Long.BYTES);\n+                        }\n+\n+                        if (columnType == ColumnType.SYMBOL) {\n+                            long symbolIndexAddess = columnPageAddress;\n+                            int maxSymbolIndex = 0;\n+                            // TODO: Use vector instructions (rosti?) to find max\n+                            for (int nRow = 0; nRow < nFrameRows; nRow++) {\n+                                int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                                symbolIndexAddess += Integer.BYTES;\n+                                maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                            }\n+\n+                            int nSymbols = nSymbolsProcessed.getQuick(columnIndex);\n+                            if (maxSymbolIndex >= nSymbols) {\n+                                int newNSymbols = maxSymbolIndex + 1;\n+                                SymbolMapReader symReader = reader.getSymbolMapReader(columnIndex);\n+                                long address = symReader.symbolCharsAddressOf(nSymbols);\n+                                long addressHi = symReader.symbolCharsAddressOf(newNSymbols);\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, address);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, addressHi - address);\n+                                nSymbolsProcessed.setQuick(columnIndex, newNSymbols);\n+                            } else {\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, -1);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, 0);\n+                            }\n+                        }\n+                    }\n+\n+                    nFrameRows -= nFirstFrameRow;\n+                    nFirstFrameRow = 0;\n+                    return frame;\n+                }\n+                nFirstFrameRow = 0;\n+            }\n+            return null;\n+        }\n+\n+        private long calculateBinaryPagePosition(final ReadOnlyColumn col, final ReadOnlyColumn binLenCol, long row) {\n+            long columnPageLength;", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6707228abc015f13f7fc338815ff2ce72e633", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java b/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\nindex a294d21c0..c3654c5cc 100644\n--- a/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\n+++ b/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\n\n@@ -1,24 +1,20 @@\n package io.questdb.cairo;\n \n-import org.jetbrains.annotations.Nullable;\n-\n import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n-import io.questdb.cairo.sql.PageFrame;\n-import io.questdb.cairo.sql.PageFrameCursor;\n import io.questdb.cairo.sql.RecordCursor;\n import io.questdb.cairo.sql.RecordMetadata;\n-import io.questdb.cairo.sql.SymbolTable;\n import io.questdb.griffin.SqlExecutionContext;\n import io.questdb.std.IntList;\n-import io.questdb.std.LongList;\n import io.questdb.std.Misc;\n import io.questdb.std.Numbers;\n-import io.questdb.std.Unsafe;\n \n public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n-    private final TableReplicationRecordCursor cursor;\n+    private final TablePageFrameCursor cursor;\n     private final CairoEngine engine;\n     private final CharSequence tableName;\n+    private final long maxRowsPerFrame;\n+    private final IntList columnIndexes;\n+    private final IntList columnSizes;\n \n     private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n         try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwODEzNQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475208135", "bodyText": "symbol for all intents and purposes is an INT column\nSymbolTable is global (not partitioned) so it should not be part of the frame", "author": "bluestreak01", "createdAt": "2020-08-23T11:32:00Z", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);\n+                        int maxSymbolIndex = nSymbolsProcessed.getQuick(columnIndex) - 1;\n+                        // TODO: Use vector instructions (rosti?) to find max\n+                        for (int nRow = 0; nRow < nRows; nRow++) {\n+                            int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                            symbolIndexAddess += Integer.BYTES;\n+                            maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                        }\n+                        nSymbolsProcessed.setQuick(columnIndex, maxSymbolIndex + 1);\n+                    }\n+                }\n+                nRows = -1;\n+            }\n+\n+            return this;\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader) {\n+            this.reader = reader;\n+            columnCount = reader.getMetadata().getColumnCount();\n+            timestampColumnIndex = reader.getMetadata().getTimestampIndex();\n+            columnFrameAddresses.ensureCapacity(columnCount);\n+            columnFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.ensureCapacity(columnCount);\n+            symbolCharsFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.setAll(columnCount, -1);\n+            symbolCharsFrameLengths.setAll(columnCount, 0);\n+            toTop();\n+            return this;\n+        }\n+\n+        @Override\n+        public @Nullable ReplicationPageFrame next() {\n+            while (++partitionIndex < partitionCount) {\n+                nFrameRows = reader.openPartition(partitionIndex);\n+                if (nFrameRows > nFirstFrameRow) {\n+                    final int base = reader.getColumnBase(partitionIndex);\n+                    for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long columnPageAddress = col.getPageAddress(0);\n+                        long columnPageLength;\n+\n+                        int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                        switch (columnType) {\n+                            case ColumnType.STRING: {\n+                                final ReadOnlyColumn strLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateStringPagePosition(col, strLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateStringPagePosition(col, strLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            case ColumnType.BINARY: {\n+                                final ReadOnlyColumn binLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateBinaryPagePosition(col, binLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateBinaryPagePosition(col, binLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            default: {\n+                                int columnSizeBinaryPower = Numbers.msb(ColumnType.sizeOf(reader.getMetadata().getColumnType(columnIndex)));\n+                                columnPageLength = nFrameRows << columnSizeBinaryPower;\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = nFirstFrameRow << columnSizeBinaryPower;\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+                            }\n+                        }\n+\n+                        columnFrameAddresses.setQuick(columnIndex, columnPageAddress);\n+                        columnFrameLengths.setQuick(columnIndex, columnPageLength);\n+\n+                        if (timestampColumnIndex == columnIndex) {\n+                            firstTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress);\n+                            lastTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress + columnPageLength - Long.BYTES);\n+                        }\n+\n+                        if (columnType == ColumnType.SYMBOL) {\n+                            long symbolIndexAddess = columnPageAddress;\n+                            int maxSymbolIndex = 0;\n+                            // TODO: Use vector instructions (rosti?) to find max\n+                            for (int nRow = 0; nRow < nFrameRows; nRow++) {\n+                                int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                                symbolIndexAddess += Integer.BYTES;\n+                                maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                            }\n+\n+                            int nSymbols = nSymbolsProcessed.getQuick(columnIndex);\n+                            if (maxSymbolIndex >= nSymbols) {\n+                                int newNSymbols = maxSymbolIndex + 1;\n+                                SymbolMapReader symReader = reader.getSymbolMapReader(columnIndex);\n+                                long address = symReader.symbolCharsAddressOf(nSymbols);\n+                                long addressHi = symReader.symbolCharsAddressOf(newNSymbols);\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, address);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, addressHi - address);\n+                                nSymbolsProcessed.setQuick(columnIndex, newNSymbols);\n+                            } else {\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, -1);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, 0);\n+                            }\n+                        }\n+                    }\n+\n+                    nFrameRows -= nFirstFrameRow;\n+                    nFirstFrameRow = 0;\n+                    return frame;\n+                }\n+                nFirstFrameRow = 0;\n+            }\n+            return null;\n+        }\n+\n+        private long calculateBinaryPagePosition(final ReadOnlyColumn col, final ReadOnlyColumn binLenCol, long row) {\n+            long columnPageLength;\n+            long lastBinLenOffset = (row - 1) << 3;\n+            long lastBinOffset = binLenCol.getLong(lastBinLenOffset);\n+            long lastBinLen = col.getBinLen(lastBinOffset);\n+            if (lastBinLen == TableUtils.NULL_LEN) {\n+                lastBinLen = 0;\n+            }\n+            columnPageLength = lastBinOffset + Long.BYTES + lastBinLen;\n+            return columnPageLength;\n+        }\n+\n+        private long calculateStringPagePosition(final ReadOnlyColumn col, final ReadOnlyColumn strLenCol, long row) {\n+            long columnPageLength;\n+            long lastStrLenOffset = (row - 1) << 3;\n+            long lastStrOffset = strLenCol.getLong(lastStrLenOffset);\n+            int lastStrLen = col.getStrLen(lastStrOffset);\n+            if (lastStrLen == TableUtils.NULL_LEN) {\n+                lastStrLen = 0;\n+            }\n+            columnPageLength = lastStrOffset + VirtualMemory.STRING_LENGTH_BYTES + lastStrLen * 2;\n+            return columnPageLength;\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            partitionIndex = -1;\n+            partitionCount = reader.getPartitionCount();\n+            firstTimestamp = Long.MIN_VALUE;\n+            lastTimestamp = 0;\n+            nSymbolsProcessed.setAll(columnCount, 0);\n+        }\n+\n+        @Override\n+        public long size() {\n+            return reader.size();\n+        }\n+\n+        public class ReplicationPageFrame implements PageFrame {\n+\n+            @Override\n+            public long getPageAddress(int columnIndex) {\n+                return columnFrameAddresses.getQuick(columnIndex);\n+            }\n+\n+            @Override\n+            public long getPageValueCount(int columnIndex) {\n+                return nFrameRows;\n+            }\n+\n+            @Override\n+            public long getFirstTimestamp() {\n+                return firstTimestamp;\n+            }\n+\n+            @Override\n+            public long getLastTimestamp() {\n+                return lastTimestamp;\n+            }\n+\n+            public int getPartitionIndex() {\n+                return partitionIndex;\n+            }\n+\n+            @Override\n+            public long getPageLength(int columnIndex) {\n+                return columnFrameLengths.getQuick(columnIndex);\n+            }\n+\n+            @Override\n+            public long getSymbolCharsPageAddress(int columnIndex) {\n+                return symbolCharsFrameAddresses.getQuick(columnIndex);\n+            }\n+\n+            @Override\n+            public long getSymbolCharsPageLength(int columnIndex) {", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6707228abc015f13f7fc338815ff2ce72e633", "chunk": "diff --git a/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java b/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\nindex a294d21c0..c3654c5cc 100644\n--- a/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\n+++ b/core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java\n\n@@ -1,24 +1,20 @@\n package io.questdb.cairo;\n \n-import org.jetbrains.annotations.Nullable;\n-\n import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n-import io.questdb.cairo.sql.PageFrame;\n-import io.questdb.cairo.sql.PageFrameCursor;\n import io.questdb.cairo.sql.RecordCursor;\n import io.questdb.cairo.sql.RecordMetadata;\n-import io.questdb.cairo.sql.SymbolTable;\n import io.questdb.griffin.SqlExecutionContext;\n import io.questdb.std.IntList;\n-import io.questdb.std.LongList;\n import io.questdb.std.Misc;\n import io.questdb.std.Numbers;\n-import io.questdb.std.Unsafe;\n \n public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n-    private final TableReplicationRecordCursor cursor;\n+    private final TablePageFrameCursor cursor;\n     private final CairoEngine engine;\n     private final CharSequence tableName;\n+    private final long maxRowsPerFrame;\n+    private final IntList columnIndexes;\n+    private final IntList columnSizes;\n \n     private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n         try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n"}}, {"oid": "a2ed535cf1f5845b974b1f30bd105d556adad6fb", "url": "https://github.com/questdb/questdb/commit/a2ed535cf1f5845b974b1f30bd105d556adad6fb", "message": "feat(cairo): TableBlockWriter - Move symbol replication out of page frame", "committedDate": "2020-08-25T08:46:43Z", "type": "commit"}, {"oid": "f28af765f5acafbee6a6fa598ba1b02269633e1f", "url": "https://github.com/questdb/questdb/commit/f28af765f5acafbee6a6fa598ba1b02269633e1f", "message": "fix(cairo): Fix minor bug in SymbolMapReaderImpl", "committedDate": "2020-08-25T09:21:03Z", "type": "commit"}, {"oid": "a45b1d579eeb9ed901e8686ead1669a370194990", "url": "https://github.com/questdb/questdb/commit/a45b1d579eeb9ed901e8686ead1669a370194990", "message": "fix(cairo): Fix minor bug in SymbolMapReaderImpl", "committedDate": "2020-08-25T09:43:07Z", "type": "commit"}, {"oid": "f1374dd8b6fdc2f92435b81c9a9adc94990292bb", "url": "https://github.com/questdb/questdb/commit/f1374dd8b6fdc2f92435b81c9a9adc94990292bb", "message": "feat(cairo): TableBlockWriter - improvements to symbol table copying", "committedDate": "2020-08-25T10:33:43Z", "type": "commit"}, {"oid": "b94b62db5a8af11742e5aa562c5120182c8707e0", "url": "https://github.com/questdb/questdb/commit/b94b62db5a8af11742e5aa562c5120182c8707e0", "message": "feat(cairo): TableBlockWriter - improvements to variable length field copying", "committedDate": "2020-08-25T11:07:04Z", "type": "commit"}, {"oid": "f6e24f8bfef56e19f0b17839da7bf86b826905fb", "url": "https://github.com/questdb/questdb/commit/f6e24f8bfef56e19f0b17839da7bf86b826905fb", "message": "feat(cairo): TableBlockWriter - add support for added columns", "committedDate": "2020-08-25T14:08:21Z", "type": "commit"}, {"oid": "c2ff856013a7d447e50460c85292b9ae09fabd23", "url": "https://github.com/questdb/questdb/commit/c2ff856013a7d447e50460c85292b9ae09fabd23", "message": "feat(cairo): TableBlockWriter - refactor TableReplicationRecordCursorFactory", "committedDate": "2020-08-26T13:20:31Z", "type": "commit"}, {"oid": "0ef1282fe7e3a69f5fb0a31690ae0e0706cd36e0", "url": "https://github.com/questdb/questdb/commit/0ef1282fe7e3a69f5fb0a31690ae0e0706cd36e0", "message": "feat(cairo): TableBlockWriter - refactor TableReplicationRecordCursor to split frames to prevent column tops straddling a frame", "committedDate": "2020-08-26T15:35:35Z", "type": "commit"}, {"oid": "ff7a08f81ffe24aaf069c27e768ee765b61eaa08", "url": "https://github.com/questdb/questdb/commit/ff7a08f81ffe24aaf069c27e768ee765b61eaa08", "message": "feat(cairo): TableBlockWriter - refactor TableReplicationRecordCursor", "committedDate": "2020-08-27T09:01:33Z", "type": "commit"}, {"oid": "4edb64e57c7e147558a6df3253bccb75d2199f2e", "url": "https://github.com/questdb/questdb/commit/4edb64e57c7e147558a6df3253bccb75d2199f2e", "message": "feat(cairo): TableBlockWriter - refactor TableReplicationRecordCursor, make timestamp column index optional", "committedDate": "2020-08-27T10:47:31Z", "type": "commit"}, {"oid": "9a76b07c2a47f1fe4dd518ee628b0ea20e8a8805", "url": "https://github.com/questdb/questdb/commit/9a76b07c2a47f1fe4dd518ee628b0ea20e8a8805", "message": "feat(cairo): TableBlockWriter - Add grownLength to ExtendableOnePageMemory", "committedDate": "2020-08-27T11:12:47Z", "type": "commit"}, {"oid": "b8d4aec8bb3f1bd2bf7acb26d6a63e4dfb07b890", "url": "https://github.com/questdb/questdb/commit/b8d4aec8bb3f1bd2bf7acb26d6a63e4dfb07b890", "message": "feat(cairo): TableBlockWriter - Changes to TableReaderRecordCursorFactory so that all the tests can be run with the new page frame implementation", "committedDate": "2020-08-27T11:13:47Z", "type": "commit"}, {"oid": "27d78afd27dbaf7f348bf2a7dfd61b948282c9fd", "url": "https://github.com/questdb/questdb/commit/27d78afd27dbaf7f348bf2a7dfd61b948282c9fd", "message": "feat(cairo): TableBlockWriter - Changes to TableReaderRecordCursorFactory so that all the tests can be run with the new page frame implementation", "committedDate": "2020-08-27T13:08:01Z", "type": "commit"}, {"oid": "52aa2f94524c673e49ede753781fce9934997f62", "url": "https://github.com/questdb/questdb/commit/52aa2f94524c673e49ede753781fce9934997f62", "message": "feat(cairo): TableBlockWriter - add getGrownLength to ReadOnlyColumn and change how var length field column lengths are calculated", "committedDate": "2020-08-27T13:45:09Z", "type": "commit"}, {"oid": "d9343b03a4ca1e86e89f0cf5b02371bb2c2261b8", "url": "https://github.com/questdb/questdb/commit/d9343b03a4ca1e86e89f0cf5b02371bb2c2261b8", "message": "chore(cairo): Fix length checks in OnePageMemory#getStr0", "committedDate": "2020-08-27T14:26:03Z", "type": "commit"}, {"oid": "e3f091b6aa2ba4def421cf4e38baf2fe524dde78", "url": "https://github.com/questdb/questdb/commit/e3f091b6aa2ba4def421cf4e38baf2fe524dde78", "message": "feat(cairo): TableBlockWriter - change TableBlockWriter so that it is owned by TableWriter", "committedDate": "2020-08-27T15:43:47Z", "type": "commit"}, {"oid": "4603a01d6201ce272257bde6dce197d34d65b119", "url": "https://github.com/questdb/questdb/commit/4603a01d6201ce272257bde6dce197d34d65b119", "message": "feat(cairo): TableBlockWriter - change TableBlockWriter so that it is owned by TableWriter", "committedDate": "2020-08-27T16:22:21Z", "type": "commit"}, {"oid": "c6595073e91ebf6da822525eb27f0f4c3e68ae09", "url": "https://github.com/questdb/questdb/commit/c6595073e91ebf6da822525eb27f0f4c3e68ae09", "message": "feat(cairo): TableBlockWriter - Move TablePageFrameCursor out of TableReplicationRecordCursorFactory", "committedDate": "2020-08-27T16:53:42Z", "type": "commit"}, {"oid": "74a55edbc3f2898556857e55313ad8a73d9f28b7", "url": "https://github.com/questdb/questdb/commit/74a55edbc3f2898556857e55313ad8a73d9f28b7", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-28T06:50:54Z", "type": "commit"}, {"oid": "01518ada55e5ee77bab3a69172e846e26a86bf59", "url": "https://github.com/questdb/questdb/commit/01518ada55e5ee77bab3a69172e846e26a86bf59", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-07T11:16:00Z", "type": "commit"}, {"oid": "5bfac5cd947cc6e0a9e94f17966e88d61279b5a1", "url": "https://github.com/questdb/questdb/commit/5bfac5cd947cc6e0a9e94f17966e88d61279b5a1", "message": "Merge branch 'master' into replication", "committedDate": "2020-09-07T11:59:47Z", "type": "commit"}, {"oid": "06e935e6fa854df49a543c1f1cb39ef775cc671b", "url": "https://github.com/questdb/questdb/commit/06e935e6fa854df49a543c1f1cb39ef775cc671b", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-07T14:19:04Z", "type": "commit"}, {"oid": "1f1697e53d7681dcdcb2de2be57f0984f296c93c", "url": "https://github.com/questdb/questdb/commit/1f1697e53d7681dcdcb2de2be57f0984f296c93c", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-07T14:48:51Z", "type": "commit"}, {"oid": "aa8fdeae8c5515c65a913dcb283755d0203aaaa8", "url": "https://github.com/questdb/questdb/commit/aa8fdeae8c5515c65a913dcb283755d0203aaaa8", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-07T14:53:30Z", "type": "commit"}, {"oid": "7b0d8004d48f7ec1753413c2dab3dc6b306e26bf", "url": "https://github.com/questdb/questdb/commit/7b0d8004d48f7ec1753413c2dab3dc6b306e26bf", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-07T15:23:19Z", "type": "commit"}, {"oid": "2dd85d8c7ca73055fab5266cf73604678132137d", "url": "https://github.com/questdb/questdb/commit/2dd85d8c7ca73055fab5266cf73604678132137d", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-08T13:32:59Z", "type": "commit"}, {"oid": "fe6ae13917ac46d2b8661a70f3b73724a94761e9", "url": "https://github.com/questdb/questdb/commit/fe6ae13917ac46d2b8661a70f3b73724a94761e9", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-08T14:01:47Z", "type": "commit"}, {"oid": "4b86946f24f67f07a3e201865350282180a21bc4", "url": "https://github.com/questdb/questdb/commit/4b86946f24f67f07a3e201865350282180a21bc4", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-08T16:24:31Z", "type": "commit"}, {"oid": "aef3442b5b8ae12a2ca626d6e02988dd5f4f067c", "url": "https://github.com/questdb/questdb/commit/aef3442b5b8ae12a2ca626d6e02988dd5f4f067c", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-08T16:34:30Z", "type": "commit"}, {"oid": "7b481ff56a16f7805787e331cec4c8a6f4e1570b", "url": "https://github.com/questdb/questdb/commit/7b481ff56a16f7805787e331cec4c8a6f4e1570b", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-08T17:29:55Z", "type": "commit"}, {"oid": "1007d4e63c50c781f8557e1019d223fcbec5f5a6", "url": "https://github.com/questdb/questdb/commit/1007d4e63c50c781f8557e1019d223fcbec5f5a6", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-09T12:24:40Z", "type": "commit"}, {"oid": "e383a7785a696b48d54a78b5e4dbd58b5308de04", "url": "https://github.com/questdb/questdb/commit/e383a7785a696b48d54a78b5e4dbd58b5308de04", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-09T13:28:48Z", "type": "commit"}, {"oid": "1305c152ef2992dde7a62a7815dc8db1ffab87b8", "url": "https://github.com/questdb/questdb/commit/1305c152ef2992dde7a62a7815dc8db1ffab87b8", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-09T20:02:47Z", "type": "commit"}, {"oid": "526a1d25af5b4376616781efee2bc5dd5eba4d2d", "url": "https://github.com/questdb/questdb/commit/526a1d25af5b4376616781efee2bc5dd5eba4d2d", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-10T13:35:06Z", "type": "commit"}, {"oid": "c895ad7009120d94a17c6f3d3cdc5e0bbea637f1", "url": "https://github.com/questdb/questdb/commit/c895ad7009120d94a17c6f3d3cdc5e0bbea637f1", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-10T14:08:16Z", "type": "commit"}, {"oid": "5b14cce50947be1545415c2c87cf84fda517144f", "url": "https://github.com/questdb/questdb/commit/5b14cce50947be1545415c2c87cf84fda517144f", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-10T14:38:40Z", "type": "commit"}, {"oid": "f920e476df1768b8ef6362824695c808707ad580", "url": "https://github.com/questdb/questdb/commit/f920e476df1768b8ef6362824695c808707ad580", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-10T14:51:49Z", "type": "commit"}, {"oid": "a544ebd4662e3d52959f298614eeaaf6558bf0c4", "url": "https://github.com/questdb/questdb/commit/a544ebd4662e3d52959f298614eeaaf6558bf0c4", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-30T13:41:31Z", "type": "commit"}, {"oid": "dd641727842a11d387da0e48d4fc65396b519412", "url": "https://github.com/questdb/questdb/commit/dd641727842a11d387da0e48d4fc65396b519412", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-01T11:45:24Z", "type": "commit"}, {"oid": "95266b90d8ba9367a43bd3f4120372d0fbefd65c", "url": "https://github.com/questdb/questdb/commit/95266b90d8ba9367a43bd3f4120372d0fbefd65c", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-01T13:54:43Z", "type": "commit"}, {"oid": "a8c80064eff5d30265cabbc99d37dbc2c0783517", "url": "https://github.com/questdb/questdb/commit/a8c80064eff5d30265cabbc99d37dbc2c0783517", "message": "Merge branch 'master' into replication", "committedDate": "2020-10-02T08:51:01Z", "type": "commit"}, {"oid": "25cd203f0bbada642890bec5660b59181c6eb925", "url": "https://github.com/questdb/questdb/commit/25cd203f0bbada642890bec5660b59181c6eb925", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-05T15:47:47Z", "type": "commit"}, {"oid": "4a7e0da437bd5a5d46d89ab8630c49062052cf34", "url": "https://github.com/questdb/questdb/commit/4a7e0da437bd5a5d46d89ab8630c49062052cf34", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-06T08:28:15Z", "type": "commit"}, {"oid": "27d9ae0bf3e9a62be6211406d670da70326aedaa", "url": "https://github.com/questdb/questdb/commit/27d9ae0bf3e9a62be6211406d670da70326aedaa", "message": "chore(cairo): Change Files.openRW such that it does not write lock the file in windows", "committedDate": "2020-10-06T14:32:06Z", "type": "commit"}, {"oid": "50407920dceb6150d3072495cda0f973a2a375d2", "url": "https://github.com/questdb/questdb/commit/50407920dceb6150d3072495cda0f973a2a375d2", "message": "chore(cairo): Change Files.openRW such that it does not write lock the file in windows", "committedDate": "2020-10-06T21:07:17Z", "type": "commit"}, {"oid": "72934fb1929a33bf30c0a5e2a91b603f6f71cf47", "url": "https://github.com/questdb/questdb/commit/72934fb1929a33bf30c0a5e2a91b603f6f71cf47", "message": "Merge branch 'master' into windows_open_changes2", "committedDate": "2020-10-06T21:10:02Z", "type": "commit"}, {"oid": "094185e5762d71a889f90630d3b5435084efda53", "url": "https://github.com/questdb/questdb/commit/094185e5762d71a889f90630d3b5435084efda53", "message": "Merge branch 'windows_open_changes2' into replication", "committedDate": "2020-10-06T21:12:16Z", "type": "commit"}]}