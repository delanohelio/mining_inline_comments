{"pr_number": 31, "pr_title": "NdArrays and DataBuffers equality and hash codes", "pr_createdAt": "2020-03-10T13:24:00Z", "pr_url": "https://github.com/tensorflow/java/pull/31", "timeline": [{"oid": "88e1b019acc84c236e9a833590cf35753233540b", "url": "https://github.com/tensorflow/java/commit/88e1b019acc84c236e9a833590cf35753233540b", "message": "NdArrays and DataBuffers equality", "committedDate": "2020-03-10T13:11:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MTMxMA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392351310", "bodyText": "I'd refer to this as providing a view on the same memory, which is the terminology that java.nio.ByteBuffer uses for the equivalent operation.", "author": "Craigacp", "createdAt": "2020-03-13T16:53:01Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/ByteDataBuffer.java", "diffHunk": "@@ -132,6 +132,72 @@ default ByteDataBuffer write(byte[] src) {\n    */\n   ByteDataBuffer write(byte[] src, int offset, int length);\n \n+  /**\n+   * Return this byte buffer as a buffer of ints.\n+   *\n+   * <p>The returned buffer shares the same memory as the original one, meaning that changing a value", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "929acaf56f551bd9500b2b592a893139eb923aed", "chunk": "diff --git a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/ByteDataBuffer.java b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/ByteDataBuffer.java\nindex 547c2540..7bd98a49 100644\n--- a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/ByteDataBuffer.java\n+++ b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/ByteDataBuffer.java\n\n@@ -135,8 +135,8 @@ public interface ByteDataBuffer extends DataBuffer<Byte> {\n   /**\n    * Return this byte buffer as a buffer of ints.\n    *\n-   * <p>The returned buffer shares the same memory as the original one, meaning that changing a value\n-   * in one will affect the other.\n+   * <p>The returned buffer provides a different view on the same memory as the original byte buffer,\n+   * meaning that changing a value in one will affect the other.\n    *\n    * @return this buffer as a {@link IntDataBuffer}\n    * @throws IllegalStateException if this buffer cannot be converted\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MjAyOA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392352028", "bodyText": "type -> types", "author": "Craigacp", "createdAt": "2020-03-13T16:54:19Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java", "diffHunk": "@@ -223,4 +223,37 @@\n    * @throws IllegalArgumentException if size value do not pass validation checks\n    */\n   DataBuffer<T> narrow(long size);\n+\n+  /**\n+   * Visits the backing storage of this buffer.\n+   *\n+   * <p>The buffer implementation is responsible of passing back a reference to the actual data\n+   * storage to the provided visitor. The visitor does not have to handle all possible type of", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "929acaf56f551bd9500b2b592a893139eb923aed", "chunk": "diff --git a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java\nindex b88d6c19..82d8f2cd 100644\n--- a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java\n+++ b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java\n\n@@ -228,10 +228,10 @@ public interface DataBuffer<T> {\n    * Visits the backing storage of this buffer.\n    *\n    * <p>The buffer implementation is responsible of passing back a reference to the actual data\n-   * storage to the provided visitor. The visitor does not have to handle all possible type of\n+   * storage to the provided visitor. The visitor does not have to handle all possible types of\n    * data storage and can override only methods for storage it is actually interested in. For any\n-   * other type of storage, the call will fallback to {@link DataStorageVisitor#otherwise()} so the\n-   * visitor can handle it as a general case.\n+   * other type of storage, this call will fallback to {@link DataStorageVisitor#otherwise()} so the\n+   * visitor can execute some generic routine if needed.\n    *\n    * @param visitor visits the data storage of this buffer\n    * @param <R> type of value returned by the visitor\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MzMzMw==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392353333", "bodyText": "Does this equals also depend on the type of the buffer? i.e. if I do byteDataBuffer.equals(byteDataBuffer.asInts()) what happens? Either way is fine, but it should be documented.", "author": "Craigacp", "createdAt": "2020-03-13T16:56:29Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java", "diffHunk": "@@ -223,4 +223,37 @@\n    * @throws IllegalArgumentException if size value do not pass validation checks\n    */\n   DataBuffer<T> narrow(long size);\n+\n+  /**\n+   * Visits the backing storage of this buffer.\n+   *\n+   * <p>The buffer implementation is responsible of passing back a reference to the actual data\n+   * storage to the provided visitor. The visitor does not have to handle all possible type of\n+   * data storage and can override only methods for storage it is actually interested in. For any\n+   * other type of storage, the call will fallback to {@link DataStorageVisitor#otherwise()} so the\n+   * visitor can handle it as a general case.\n+   *\n+   * @param visitor visits the data storage of this buffer\n+   * @param <R> type of value returned by the visitor\n+   * @return the same value returned by the visitor\n+   */\n+  default <R> R accept(DataStorageVisitor<R> visitor) {\n+    return visitor.otherwise();\n+  }\n+\n+  /**\n+   * Checks equality between data buffers.\n+   *\n+   * <p>A data buffer is equal to another object if this object is another {@link DataBuffer} of the", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYzMjcyNQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392632725", "bodyText": "It does depend on the type as well, that was missing in the doc, I'll add it", "author": "karllessard", "createdAt": "2020-03-15T01:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MzMzMw=="}], "type": "inlineReview", "revised_code": {"commit": "929acaf56f551bd9500b2b592a893139eb923aed", "chunk": "diff --git a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java\nindex b88d6c19..82d8f2cd 100644\n--- a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java\n+++ b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java\n\n@@ -228,10 +228,10 @@ public interface DataBuffer<T> {\n    * Visits the backing storage of this buffer.\n    *\n    * <p>The buffer implementation is responsible of passing back a reference to the actual data\n-   * storage to the provided visitor. The visitor does not have to handle all possible type of\n+   * storage to the provided visitor. The visitor does not have to handle all possible types of\n    * data storage and can override only methods for storage it is actually interested in. For any\n-   * other type of storage, the call will fallback to {@link DataStorageVisitor#otherwise()} so the\n-   * visitor can handle it as a general case.\n+   * other type of storage, this call will fallback to {@link DataStorageVisitor#otherwise()} so the\n+   * visitor can execute some generic routine if needed.\n    *\n    * @param visitor visits the data storage of this buffer\n    * @param <R> type of value returned by the visitor\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NTA0MQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392355041", "bodyText": "Maybe this could be called defaultVisit or something more indicative? What kinds of behaviour would it perform?", "author": "Craigacp", "createdAt": "2020-03-13T16:59:35Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataStorageVisitor.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.tensorflow.tools.buffer;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+import java.util.BitSet;\n+\n+/**\n+ * Visit the backing storage of {@link DataBuffer} instances.\n+ *\n+ * @param <R> value type returned by the visitor\n+ */\n+public interface DataStorageVisitor<R> {\n+\n+  /**\n+   * Visit the {@link ByteBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(ByteBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link ShortBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(ShortBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link IntBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(IntBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link LongBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(LongBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link FloatBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(FloatBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link DoubleBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(DoubleBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the boolean array backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param array underlying array\n+   * @param offset offset of the buffer within the array\n+   * @param length length of the buffer within the array\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(boolean[] array, int offset, int length) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the bit set backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param bitSet underlying bit set\n+   * @param offset offset of the buffer within the bit set\n+   * @param numBits number of bits used to represent the buffer within the bit set\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(BitSet bitSet, int offset, long numBits) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the object array backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param array underlying array\n+   * @param offset offset of the buffer within the array\n+   * @param length length of the buffer within the array\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(Object[] array, int offset, int length) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the raw memory segment of a given instance of a {@link DataBuffer}\n+   *\n+   * @param address native address of the buffer\n+   * @param length length of the buffer\n+   * @param scale number of bytes required to store a single value of this buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(long address, long length, long scale) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Fallback method called if the visitor implementation does not support the type of backing storage\n+   * for a given {@link DataBuffer}\n+   *\n+   * <p>The implementor of this interface must override the {@code visit} methods for type of storage\n+   * it supports. If {@link DataBuffer#accept(DataStorageVisitor)} is called on a buffer\n+   * using a different type of storage, the invocation will fallback to this method.\n+   *\n+   * @return any value\n+   */\n+  R otherwise();", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYzMzA4NA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392633084", "bodyText": "This method is called when the visitor does not handle a given type of data storage, so that it can fallback to a generic task if needed. I still prefer otherwise() to defaultVisit() because basically when this method is called, it means that you are not visiting any data storage. I used it for example like this:\n    return otherBuffer.accept(new DataStorageVisitor<Boolean>() {\n\n      @Override\n      public Boolean visit(DoubleBuffer otherStorage) {\n        return myStorage.equals(otherStorage);\n      }\n\n      @Override\n      public Boolean otherwise() {\n        for (int idx = 0; idx < size(); ++idx) {\n          if (otherBuffer.getDouble(idx) != getDouble(idx)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    });\nSo when otherwise() is call, I can only build a routine using the public API of a DataBuffer and nothing internal like other visit() methods can do.", "author": "karllessard", "createdAt": "2020-03-15T01:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NTA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5MTg5Mw==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393091893", "bodyText": "I'd still consider that to be visiting every index in the storage, but I don't write that many visitors to be honest. Maybe fallback? The name otherwise to me suggests there should be some condition that makes it go down that path that the user could control, or is data dependent. The use case here seems to be type dependent (in that it'll be chosen statically at compile time).", "author": "Craigacp", "createdAt": "2020-03-16T15:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NTA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5MjY1Ng==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393192656", "bodyText": "Ok no problem for \"fallback\", as long as it is not \"visit\" I'm fine.", "author": "karllessard", "createdAt": "2020-03-16T17:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NTA0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "bf2067530031d08c9488e7d1b4d8ae25b405498e", "chunk": "diff --git a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataStorageVisitor.java b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataStorageVisitor.java\nindex 60867572..f3c08e3c 100644\n--- a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataStorageVisitor.java\n+++ b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataStorageVisitor.java\n\n@@ -23,7 +23,7 @@ public interface DataStorageVisitor<R> {\n    * @see DataBuffer#accept(DataStorageVisitor)\n    */\n   default R visit(ByteBuffer buffer) {\n-    return otherwise();\n+    return fallback();\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NzA4OQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392357089", "bodyText": "Can we stash these lambdas in static variables?", "author": "Craigacp", "createdAt": "2020-03-13T17:03:24Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/AbstractDataBuffer.java", "diffHunk": "@@ -38,9 +41,145 @@\n     return this;\n   }\n \n-  protected void slowCopyTo(DataBuffer<T> dst, long size) {\n-    for (long idx = 0; idx < size; ++idx) {\n+  @Override\n+  public DataBuffer<T> copyTo(DataBuffer<T> dst, long size) {\n+    Validator.copyToArgs(this, dst, size);\n+    for (long idx = 0L; idx < size; ++idx) {\n+      dst.setObject(getObject(idx), idx);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    // This hash code computation is generic to all types of data buffers and accurate but not optimized\n+    // for performances, it needs to be improved if there is a present use case for such hash codes.\n+    return slowHashCode();\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (this == obj) {\n+      return true;\n+    }\n+    if (!(obj instanceof DataBuffer)) {\n+      return false;\n+    }\n+    return slowEquals((DataBuffer<?>)obj);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected <U extends DataBuffer<T>> U slowCopyTo(DataBuffer<T> dst, long size) {\n+    Validator.copyToArgs(this, dst, size);\n+    for (long idx = 0L; idx < size; ++idx) {\n       dst.setObject(getObject(idx), idx);\n     }\n+    return (U)this;\n+  }\n+\n+  protected int slowHashCode() {\n+    final int prime = 31;\n+    int result = 1;\n+\n+    // First check from the first non-null element if we are dealing with a buffer of arrays\n+    long idx = 0L;\n+    for (; idx < size(); ++idx) {\n+      T o = getObject(idx);\n+      if (o != null) {\n+        if (o.getClass().isArray()) {\n+          result = prime * result + arrayHashCode(idx, o.getClass()); // compute hash codes based on array elements\n+          return result;\n+        }\n+        result = prime * result + o.hashCode();\n+        break;  // continue hash code computation without array type check\n+      }\n+      result = prime * result;\n+    }\n+    while (++idx < size()) {\n+      result = prime * result + Objects.hashCode(getObject(idx));\n+    }\n+    return result;\n+  }\n+\n+  protected boolean slowEquals(DataBuffer<?> other) {\n+    if (other.size() != size()) {\n+      return false;\n+    }\n+    long idx = 0L;\n+    for (; idx < size(); ++idx) {\n+      Object thisObject = getObject(idx);\n+      if (thisObject != null) {\n+        if (thisObject.getClass().isArray()) {\n+          return arrayEquals(idx, thisObject.getClass(), other);\n+        }\n+        if (!Objects.equals(other.getObject(idx), thisObject)) {\n+          return false;\n+        }\n+        break;  // continue equality comparison without array type check\n+      }\n+      if (other.getObject(idx) != null) {\n+        return false;\n+      }\n+    }\n+    while (++idx < size()) {\n+      if (!Objects.equals(other.getObject(idx), getObject(idx))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private int arrayHashCode(long startIdx, Class<?> arrayClass) {\n+    Function<Long, Integer> hashCoder;", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "929acaf56f551bd9500b2b592a893139eb923aed", "chunk": "diff --git a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/AbstractDataBuffer.java b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/AbstractDataBuffer.java\nindex b6c3b5bf..4e1c7f8a 100644\n--- a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/AbstractDataBuffer.java\n+++ b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/AbstractDataBuffer.java\n\n@@ -130,56 +131,56 @@ public abstract class AbstractDataBuffer<T> implements DataBuffer<T> {\n   }\n \n   private int arrayHashCode(long startIdx, Class<?> arrayClass) {\n-    Function<Long, Integer> hashCoder;\n-    if (arrayClass == byte[].class) {\n-      hashCoder = idx -> Arrays.hashCode((byte[])getObject(idx));\n-    } else if (arrayClass == int[].class) {\n-      hashCoder = idx -> Arrays.hashCode((int[])getObject(idx));\n-    } else if (arrayClass == short[].class) {\n-      hashCoder = idx -> Arrays.hashCode((short[])getObject(idx));\n-    } else if (arrayClass == long[].class) {\n-      hashCoder = idx -> Arrays.hashCode((long[])getObject(idx));\n-    } else if (arrayClass == float[].class) {\n-      hashCoder = idx -> Arrays.hashCode((float[])getObject(idx));\n-    } else if (arrayClass == double[].class) {\n-      hashCoder = idx -> Arrays.hashCode((double[])getObject(idx));\n-    } else if (arrayClass == boolean[].class) {\n-      hashCoder = idx -> Arrays.hashCode((boolean[])getObject(idx));\n-    } else {\n-      hashCoder = idx -> Arrays.deepHashCode((Object[])getObject(idx));\n-    }\n+    ArrayHashCoder hashCoder = ARRAY_HASH_CODERS.getOrDefault(arrayClass, DEFAULT_ARRAY_HASH_CODER);\n     final int prime = 31;\n     int result = 1;\n     for (long idx = startIdx; idx < size(); ++idx) {\n-      result = prime * result + hashCoder.apply(idx);\n+      result = prime * result + hashCoder.hashCode(this, idx);\n     }\n     return result;\n   }\n \n   private boolean arrayEquals(long startIdx, Class<?> arrayClass, DataBuffer<?> other) {\n-    Function<Long, Boolean> comparator;\n-    if (arrayClass == byte[].class) {\n-      comparator = idx -> Arrays.equals((byte[])other.getObject(idx), (byte[])getObject(idx));\n-    } else if (arrayClass == int[].class) {\n-      comparator = idx -> Arrays.equals((int[])other.getObject(idx), (int[])getObject(idx));\n-    } else if (arrayClass == short[].class) {\n-      comparator = idx -> Arrays.equals((short[])other.getObject(idx), (short[])getObject(idx));\n-    } else if (arrayClass == long[].class) {\n-      comparator = idx -> Arrays.equals((long[])other.getObject(idx), (long[])getObject(idx));\n-    } else if (arrayClass == float[].class) {\n-      comparator = idx -> Arrays.equals((float[])other.getObject(idx), (float[])getObject(idx));\n-    } else if (arrayClass == double[].class) {\n-      comparator = idx -> Arrays.equals((double[])other.getObject(idx), (double[])getObject(idx));\n-    } else if (arrayClass == boolean[].class) {\n-      comparator = idx -> Arrays.equals((boolean[]) other.getObject(idx), (boolean[]) getObject(idx));\n-    } else {\n-      comparator = idx -> Arrays.deepEquals((Object[]) other.getObject(idx), (Object[]) getObject(idx));\n-    }\n+    ArrayComparator comparator = ARRAY_COMPARATORS.getOrDefault(arrayClass, DEFAULT_ARRAY_COMPARATOR);\n     for (long idx = startIdx; idx < size(); ++idx) {\n-      if (!comparator.apply(idx)) {\n+      if (!comparator.equals(this, other, idx)) {\n         return false;\n       }\n     }\n     return true;\n   }\n+\n+  @FunctionalInterface\n+  private static interface ArrayHashCoder {\n+    int hashCode(DataBuffer<?> buffer, long index);\n+  }\n+  private static final Map<Class<?>, ArrayHashCoder> ARRAY_HASH_CODERS = new HashMap<>();\n+  private static final ArrayHashCoder DEFAULT_ARRAY_HASH_CODER;\n+\n+  @FunctionalInterface\n+  private static interface ArrayComparator {\n+    boolean equals(DataBuffer<?> buffer, DataBuffer<?> otherBuffer, long index);\n+  }\n+  private static final Map<Class<?>, ArrayComparator> ARRAY_COMPARATORS = new HashMap<>();\n+  private static final ArrayComparator DEFAULT_ARRAY_COMPARATOR;\n+\n+  static {\n+    ARRAY_HASH_CODERS.put(byte[].class, (b, idx) -> Arrays.hashCode((byte[])b.getObject(idx)));\n+    ARRAY_HASH_CODERS.put(int[].class, (b, idx) -> Arrays.hashCode((int[])b.getObject(idx)));\n+    ARRAY_HASH_CODERS.put(short[].class, (b, idx) -> Arrays.hashCode((short[])b.getObject(idx)));\n+    ARRAY_HASH_CODERS.put(long[].class, (b, idx) -> Arrays.hashCode((long[])b.getObject(idx)));\n+    ARRAY_HASH_CODERS.put(float[].class, (b, idx) -> Arrays.hashCode((float[])b.getObject(idx)));\n+    ARRAY_HASH_CODERS.put(double[].class, (b, idx) -> Arrays.hashCode((double[])b.getObject(idx)));\n+    ARRAY_HASH_CODERS.put(boolean[].class, (b, idx) -> Arrays.hashCode((boolean[])b.getObject(idx)));\n+    DEFAULT_ARRAY_HASH_CODER = (b, idx) -> Arrays.deepHashCode((Object[])b.getObject(idx));\n+\n+    ARRAY_COMPARATORS.put(byte[].class, (b1, b2, idx) -> Arrays.equals((byte[])b1.getObject(idx), (byte[])b2.getObject(idx)));\n+    ARRAY_COMPARATORS.put(int[].class, (b1, b2, idx) -> Arrays.equals((int[])b1.getObject(idx), (int[])b2.getObject(idx)));\n+    ARRAY_COMPARATORS.put(short[].class, (b1, b2, idx) -> Arrays.equals((short[])b1.getObject(idx), (short[])b2.getObject(idx)));\n+    ARRAY_COMPARATORS.put(long[].class, (b1, b2, idx) -> Arrays.equals((long[])b1.getObject(idx), (long[])b2.getObject(idx)));\n+    ARRAY_COMPARATORS.put(float[].class, (b1, b2, idx) -> Arrays.equals((float[])b1.getObject(idx), (float[])b2.getObject(idx)));\n+    ARRAY_COMPARATORS.put(double[].class, (b1, b2, idx) -> Arrays.equals((double[])b1.getObject(idx), (double[])b2.getObject(idx)));\n+    ARRAY_COMPARATORS.put(boolean[].class, (b1, b2, idx) -> Arrays.equals((boolean[])b1.getObject(idx), (boolean[])b2.getObject(idx)));\n+    DEFAULT_ARRAY_COMPARATOR = (b1, b2, idx) -> Arrays.deepEquals((Object[])b1.getObject(idx), (Object[])b2.getObject(idx));\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1ODU0Ng==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392358546", "bodyText": "Might be best to hoist the cast out of the for loop in case the JIT doesn't figure it out. Pity we can't use the pattern matching from JDK 14 yet.", "author": "Craigacp", "createdAt": "2020-03-13T17:06:05Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/adapter/DoubleDataBufferAdapter.java", "diffHunk": "@@ -56,16 +56,48 @@ public DoubleDataBuffer write(double[] src, int offset, int length) {\n     return this;\n   }\n \n+  @Override\n+  public DoubleDataBuffer copyTo(DataBuffer<Double> dst, long size) {\n+    Validator.copyToArgs(this, dst, size);\n+    if (dst instanceof DoubleDataBuffer) {\n+      for (long idx = 0L; idx < size; ++idx) {\n+        ((DoubleDataBuffer)dst).setDouble(getDouble(idx), idx);", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "929acaf56f551bd9500b2b592a893139eb923aed", "chunk": "diff --git a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/adapter/DoubleDataBufferAdapter.java b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/adapter/DoubleDataBufferAdapter.java\nindex 4d97d29e..ecd8c36e 100644\n--- a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/adapter/DoubleDataBufferAdapter.java\n+++ b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/adapter/DoubleDataBufferAdapter.java\n\n@@ -60,8 +60,9 @@ class DoubleDataBufferAdapter<S extends DataBuffer<?>> extends AbstractDataBuffe\n   public DoubleDataBuffer copyTo(DataBuffer<Double> dst, long size) {\n     Validator.copyToArgs(this, dst, size);\n     if (dst instanceof DoubleDataBuffer) {\n+      DoubleDataBuffer doubleDst = (DoubleDataBuffer)dst;\n       for (long idx = 0L; idx < size; ++idx) {\n-        ((DoubleDataBuffer)dst).setDouble(getDouble(idx), idx);\n+        doubleDst.setDouble(getDouble(idx), idx);\n       }\n       return this;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2MjM2OA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392362368", "bodyText": "This should probably note \"the same shape, type and the elements are equal and in the same order\".", "author": "Craigacp", "createdAt": "2020-03-13T17:13:45Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/NdArray.java", "diffHunk": "@@ -293,4 +291,20 @@ default long size() {\n    * @see DataBuffer#size()\n    */\n   NdArray<T> write(DataBuffer<T> src);\n+\n+  /**\n+   * Checks equality between n-dimensional arrays.\n+   *\n+   * <p>An array is equal to another object if this object is another {@link NdArray} of the", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "929acaf56f551bd9500b2b592a893139eb923aed", "chunk": "diff --git a/tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/NdArray.java b/tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/NdArray.java\nindex 445597d9..3154886a 100644\n--- a/tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/NdArray.java\n+++ b/tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/NdArray.java\n\n@@ -296,7 +296,19 @@ public interface NdArray<T> {\n    * Checks equality between n-dimensional arrays.\n    *\n    * <p>An array is equal to another object if this object is another {@link NdArray} of the\n-   * same shape and each elements are equal and in the same order.\n+   * same shape, type and the elements are equal and in the same order. For example:\n+   *\n+   * <pre>{@code\n+   * IntNdArray array = NdArrays.ofInts(Shape.of(2, 2))\n+   *    .set(NdArrays.vectorOf(1, 2), 0)\n+   *    .set(NdArrays.vectorOf(3, 4), 1);\n+   *\n+   * assertEquals(array, StdArrays.ndCopyOf(new int[][] {{1, 2}, {3, 4}}));  // true\n+   * assertEquals(array, StdArrays.ndCopyOf(new Integer[][] {{1, 2}, {3, 4}}));  // true, as Integers are equal to ints\n+   * assertNotEquals(array, NdArrays.vectorOf(1, 2, 3, 4));  // false, different shapes\n+   * assertNotEquals(array, StdArrays.ndCopyOf(new int[][] {{3, 4}, {1, 2}}));  // false, different order\n+   * assertNotEquals(array, StdArrays.ndCopyOf(new long[][] {{1L, 2L}, {3L, 4L}}));  // false, different types\n+   * }</pre>\n    *\n    * <p>Note that the computation required to verify equality between two arrays can be expensive\n    * in some cases and therefore, it is recommended to not use this method in a critical path\n"}}, {"oid": "929acaf56f551bd9500b2b592a893139eb923aed", "url": "https://github.com/tensorflow/java/commit/929acaf56f551bd9500b2b592a893139eb923aed", "message": "Improve Javadoc and fix few bugs", "committedDate": "2020-03-15T14:52:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393094652", "bodyText": "This is disappointing, is there no way to make equals and hashCode just look at the view without having to actually perform an operation on them?", "author": "Craigacp", "createdAt": "2020-03-16T15:07:06Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/dense/AbstractDenseNdArray.java", "diffHunk": "@@ -110,6 +113,18 @@ protected AbstractDenseNdArray(DimensionalSpace dimensions) {\n \n   abstract protected DataBuffer<T> buffer();\n \n+  protected DataBuffer<T> trimBuffer() {", "originalCommit": "929acaf56f551bd9500b2b592a893139eb923aed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5NTQzNw==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393195437", "bodyText": "We could avoid it by trimming the buffer every time we slice the array but this function is more on the critical path for performances and I was hesitating changing it only to support equals/hashCode, which should be used less frequently.\nTrimming the buffer when the array is not segmented (caused by the usage of some of the Index classes) is quite easy to do but substantial changes need to be performed in the other case.\nI'm not too happy with this last-minute discovery as well so would you be comfortable if we keep it like that and I'll add a TODO notice to take a deeper look at how to improve this aspect later?", "author": "karllessard", "createdAt": "2020-03-16T17:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1MDg0OQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393250849", "bodyText": "Yeah, I'm fine with it staying as is with a note to fix it later.", "author": "Craigacp", "createdAt": "2020-03-16T19:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1MTMzMA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393251330", "bodyText": "Maybe we could add a flag on the NdArray noting it's not continuous in it's backing store, then have equals and hashcode fall back to something slower?", "author": "Craigacp", "createdAt": "2020-03-16T19:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyOTA4OQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393329089", "bodyText": "Oh, we already have this flag (dimensions.isSegmented()), so I would now assume the buffer is trimmed if this flag is not set? I think it is better but still not perfect, I'll do this but still leave a note to review for later.", "author": "karllessard", "createdAt": "2020-03-16T21:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzcwODc5MQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393708791", "bodyText": "Ok @Craigacp , I just pushed new substantial changes, this was required if I wanted to limit the impact on performances when slicing an array. So I added a new DataBuffer.slice() method, instead of using the double-allocating DataBuffer.offset(i).narrow(s) (running NdArrayBenchmark show a significative improvement by doing this).", "author": "karllessard", "createdAt": "2020-03-17T14:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "bf2067530031d08c9488e7d1b4d8ae25b405498e", "chunk": "diff --git a/tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/dense/AbstractDenseNdArray.java b/tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/dense/AbstractDenseNdArray.java\nindex 9e150a80..28e55b86 100644\n--- a/tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/dense/AbstractDenseNdArray.java\n+++ b/tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/dense/AbstractDenseNdArray.java\n\n@@ -113,18 +114,6 @@ public abstract class AbstractDenseNdArray<T, U extends NdArray<T>> extends Abst\n \n   abstract protected DataBuffer<T> buffer();\n \n-  protected DataBuffer<T> trimBuffer() {\n-    // For optimization, when an array is sliced, we just adjust its offset and give it a new\n-    // dimension space. Therefore, the buffer is not narrowed to the size of the slice, which would\n-    // required some extra computation. But for some operations, like equality check, we need the\n-    // buffer to be trimmed to the actual size of the array (assuming that the array is not\n-    // segmented).\n-    if (dimensions().isSegmented()) {\n-      throw new IllegalStateException(\"Segmented arrays cannot trim their buffers\");\n-    }\n-    return buffer().size() > shape().size() ? buffer().narrow(shape().size()) : buffer();\n-  }\n-\n   abstract U instantiate(DataBuffer<T> buffer, DimensionalSpace dimensions);\n \n   long positionOf(long[] coords, boolean isValue) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg4MTc2MA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393881760", "bodyText": "Looks like some unnecessary imports got dragged in.", "author": "Craigacp", "createdAt": "2020-03-17T18:21:31Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/nio/FloatNioDataBuffer.java", "diffHunk": "@@ -17,9 +17,11 @@\n \n package org.tensorflow.tools.buffer.impl.nio;\n \n+import java.nio.DoubleBuffer;\n import java.nio.FloatBuffer;\n import org.tensorflow.tools.buffer.DataBuffer;\n import org.tensorflow.tools.buffer.DataStorageVisitor;\n+import org.tensorflow.tools.buffer.DoubleDataBuffer;", "originalCommit": "656d771863e75d929698e4be9a0c2a8edf256342", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf2067530031d08c9488e7d1b4d8ae25b405498e", "chunk": "diff --git a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/nio/FloatNioDataBuffer.java b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/nio/FloatNioDataBuffer.java\nindex 127f6978..ff51eaaf 100644\n--- a/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/nio/FloatNioDataBuffer.java\n+++ b/tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/nio/FloatNioDataBuffer.java\n\n@@ -17,11 +17,9 @@\n \n package org.tensorflow.tools.buffer.impl.nio;\n \n-import java.nio.DoubleBuffer;\n import java.nio.FloatBuffer;\n import org.tensorflow.tools.buffer.DataBuffer;\n import org.tensorflow.tools.buffer.DataStorageVisitor;\n-import org.tensorflow.tools.buffer.DoubleDataBuffer;\n import org.tensorflow.tools.buffer.FloatDataBuffer;\n import org.tensorflow.tools.buffer.impl.Validator;\n \n"}}, {"oid": "bf2067530031d08c9488e7d1b4d8ae25b405498e", "url": "https://github.com/tensorflow/java/commit/bf2067530031d08c9488e7d1b4d8ae25b405498e", "message": "Trim array buffers when slicing", "committedDate": "2020-03-18T00:45:07Z", "type": "commit"}, {"oid": "bf2067530031d08c9488e7d1b4d8ae25b405498e", "url": "https://github.com/tensorflow/java/commit/bf2067530031d08c9488e7d1b4d8ae25b405498e", "message": "Trim array buffers when slicing", "committedDate": "2020-03-18T00:45:07Z", "type": "forcePushed"}]}