{"pr_number": 166, "pr_title": "Indexing API", "pr_createdAt": "2020-12-07T23:05:18Z", "pr_url": "https://github.com/tensorflow/java/pull/166", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzMTk4OA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r538931988", "bodyText": "We don't have this kind of overloading in Java, so does it make sense to describe it here in the Java Ops?", "author": "Craigacp", "createdAt": "2020-12-09T01:21:00Z", "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java", "diffHunk": "@@ -5899,6 +5900,61 @@ public StageSize stageSize(List<DataType<?>> dtypes, StageSize.Options... option\n     return StopGradient.create(scope, input);\n   }\n \n+  /**\n+   * Return a strided slice from `input`.\n+   *   <p>\n+   *   The goal of this op is to produce a new tensor with a subset of\n+   *   the elements from the `n` dimensional `input` tensor. The subset is chosen using\n+   *   a sequence of `m` sparse range specifications encoded into the arguments\n+   *   of this function. Note, in some cases\n+   *   `m` could be equal to `n`, but this need not be the case. Each\n+   *   range specification entry can be one of the following:\n+   *   <p>\n+   *   - An ellipsis (...) using {@link Index#ellipses()}. Ellipses are used to imply zero or more\n+   *     dimensions of full-dimension selection and are produced using\n+   *     `ellipsis_mask`. For example, `foo[...]` is the identity slice.", "originalCommit": "8dda060ae4a445d422ce5ff6ab27cb0fb031b7df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NjQ4Mg==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r538966482", "bodyText": "I copied most of this from the stridedSlice docs and tried to keep it as close as possible.  I talk enough about the Python and Java equivalents that I think it's understood to be stridedSlice(foo, Index.ellipsis()).  I'm kind of using it as a generic \"slice notation\" rather than specifically referencing the Python syntax.", "author": "rnett", "createdAt": "2020-12-09T02:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzMTk4OA=="}], "type": "inlineReview", "revised_code": {"commit": "ab6cb65062b040c4e6d1c0077d37084b50278c31", "chunk": "diff --git a/tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java b/tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java\nindex 2248ee67..2264c058 100644\n--- a/tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java\n+++ b/tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java\n\n@@ -5910,15 +5913,15 @@ public final class Ops {\n    *   `m` could be equal to `n`, but this need not be the case. Each\n    *   range specification entry can be one of the following:\n    *   <p>\n-   *   - An ellipsis (...) using {@link Index#ellipses()}. Ellipses are used to imply zero or more\n+   *   - An ellipsis (...) using {@link Indices#ellipsis()}. Ellipses are used to imply zero or more\n    *     dimensions of full-dimension selection and are produced using\n    *     `ellipsis_mask`. For example, `foo[...]` is the identity slice.\n    *   <p>\n-   *   - A new axis using {@link Index#newAxis()}. This is used to insert a new shape=1 dimension and is\n+   *   - A new axis using {@link Indices#newAxis()}. This is used to insert a new shape=1 dimension and is\n    *     produced using `new_axis_mask`. For example, `foo[:, ...]` where\n    *     `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.\n    *   <p>\n-   *   - A range `begin:end:stride` using {@link Index#slice(Singular, Singular, int) Index.slice()} or {@link Index#all()}. This is used to specify how much to choose from\n+   *   - A range `begin:end:stride` using {@link Indices#slice(Long, Long, long)}  Index.slice()}. This is used to specify how much to choose from\n    *     a given dimension. `stride` can be any integer but 0.  `begin` is an integer\n    *     which represents the index of the first value to select while `end` represents\n    *     the index of the last value to select. The number of values selected in each\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzMzkwOQ==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r538933909", "bodyText": "Does this need to be public? Can't it be package private?", "author": "Craigacp", "createdAt": "2020-12-09T01:25:56Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/Indexing.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+package org.tensorflow.op.core;\n+\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Index;\n+import org.tensorflow.op.Index.Singular;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.annotation.Endpoint;\n+import org.tensorflow.op.annotation.Operator;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Helper endpoint methods for Python like indexing.\n+ *\n+ * @see Index\n+ */\n+@Operator\n+public class Indexing {\n+\n+  static class StridedSliceArgs {\n+\n+    final int[] begin;\n+    final int[] end;\n+    final int[] strides;\n+    final long beginMask;\n+    final long endMask;\n+    final long ellipsisMask;\n+    final long newAxisMask;\n+    final long shrinkAxisMask;\n+\n+    public StridedSliceArgs(int[] begin, int[] end, int[] strides, long beginMask, long endMask, long ellipsisMask,", "originalCommit": "8dda060ae4a445d422ce5ff6ab27cb0fb031b7df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NDIzMA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r538964230", "bodyText": "Yeah, it should private.", "author": "rnett", "createdAt": "2020-12-09T02:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzMzkwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ab6cb65062b040c4e6d1c0077d37084b50278c31", "chunk": "diff --git a/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/Indexing.java b/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java\nsimilarity index 81%\nrename from tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/Indexing.java\nrename to tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java\nindex 0d0c0ce5..e2643b41 100644\n--- a/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/Indexing.java\n+++ b/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java\n\n@@ -15,8 +15,8 @@ limitations under the License.\n package org.tensorflow.op.core;\n \n import org.tensorflow.Operand;\n-import org.tensorflow.op.Index;\n-import org.tensorflow.op.Index.Singular;\n+import org.tensorflow.ndarray.index.Indices;\n+import org.tensorflow.ndarray.index.TensorIndex;\n import org.tensorflow.op.Scope;\n import org.tensorflow.op.annotation.Endpoint;\n import org.tensorflow.op.annotation.Operator;\n"}}, {"oid": "ab6cb65062b040c4e6d1c0077d37084b50278c31", "url": "https://github.com/tensorflow/java/commit/ab6cb65062b040c4e6d1c0077d37084b50278c31", "message": "remove old Index class\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2020-12-28T03:23:02Z", "type": "forcePushed"}, {"oid": "5a357124295077fa462d4f35185dd6ed95b50a2d", "url": "https://github.com/tensorflow/java/commit/5a357124295077fa462d4f35185dd6ed95b50a2d", "message": "test fix for rebase\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2020-12-28T21:29:58Z", "type": "forcePushed"}, {"oid": "86056d280814e4ad3550f2bcac2ee75c0efcc5c8", "url": "https://github.com/tensorflow/java/commit/86056d280814e4ad3550f2bcac2ee75c0efcc5c8", "message": "test fix for rebase\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2020-12-28T21:36:41Z", "type": "forcePushed"}, {"oid": "62acf416bc91640667ff7bf54d6356d5540691a8", "url": "https://github.com/tensorflow/java/commit/62acf416bc91640667ff7bf54d6356d5540691a8", "message": "test fix for rebase\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2020-12-30T22:56:00Z", "type": "forcePushed"}, {"oid": "713fb4128e8cdae9daf59b1108086c284ab235af", "url": "https://github.com/tensorflow/java/commit/713fb4128e8cdae9daf59b1108086c284ab235af", "message": "ToString methods\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-05T05:10:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5MDE3Mg==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553090172", "bodyText": "This method is quite critical on the performance path when it comes to access data inside an nd array. With all these additions in it, could you please run the benchmark for NdArray, especially those testing the indexation like this one, and compare the results?", "author": "karllessard", "createdAt": "2021-01-07T03:32:43Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/impl/dimension/DimensionalSpace.java", "diffHunk": "@@ -35,24 +35,42 @@ public static DimensionalSpace create(Shape shape) {\n   }\n \n   public RelativeDimensionalSpace mapTo(Index[] indices) {", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY5NjU3NQ==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553696575", "bodyText": "I ran with @Fork(value = 1) since 0 gave warnings, should I push that?", "author": "rnett", "createdAt": "2021-01-08T01:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5MDE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcyMTAwOA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553721008", "bodyText": "There's a tiny bit of slowdown, but it's marginal:\nOriginal:\nBenchmark                                                  Mode  Cnt   Score   Error  Units\nNdArrayBenchmark.getElementAtIndex                         avgt    5   0.097 \u00b1 0.017   s/op\nNdArrayBenchmark.readingAllPixelsChannelsByIndex           avgt    5  10.035 \u00b1 0.023   s/op\nNdArrayBenchmark.readingAllPixelsChannelsBySequence        avgt    5   0.033 \u00b1 0.002   s/op\nNdArrayBenchmark.readingAllPixelsChannelsBySequenceSlices  avgt    5   0.166 \u00b1 0.011   s/op\nNdArrayBenchmark.slicing                                   avgt    5   0.222 \u00b1 0.049   s/op\nNdArrayBenchmark.writeAllBatchChannels                     avgt    5   0.335 \u00b1 0.048   s/op\nNdArrayBenchmark.writeAllPixelsByIndex                     avgt    5   5.870 \u00b1 0.817   s/op\nNdArrayBenchmark.writeAllPixelsBySlicing                   avgt    5  29.603 \u00b1 1.304   s/op\nNdArrayBenchmark.writeFirstBatchChannels                   avgt    5   0.349 \u00b1 0.102   s/op\nNdArrayBenchmark.writeOnePixelBySlicing                    avgt    5   0.705 \u00b1 0.082   s/op\nNdArrayBenchmark.writeOnePixelsByIndex                     avgt    5   0.131 \u00b1 0.036   s/op\nMine:\nBenchmark                                                  Mode  Cnt   Score    Error  Units\nNdArrayBenchmark.getElementAtIndex                         avgt    5   0.104 \u00b1  0.020   s/op\nNdArrayBenchmark.readingAllPixelsChannelsByIndex           avgt    5  10.037 \u00b1  0.063   s/op\nNdArrayBenchmark.readingAllPixelsChannelsBySequence        avgt    5   0.033 \u00b1  0.001   s/op\nNdArrayBenchmark.readingAllPixelsChannelsBySequenceSlices  avgt    5   0.174 \u00b1  0.009   s/op\nNdArrayBenchmark.slicing                                   avgt    5   0.208 \u00b1  0.001   s/op\nNdArrayBenchmark.writeAllBatchChannels                     avgt    5   0.316 \u00b1  0.061   s/op\nNdArrayBenchmark.writeAllPixelsByIndex                     avgt    5   5.555 \u00b1  0.137   s/op\nNdArrayBenchmark.writeAllPixelsBySlicing                   avgt    5  30.081 \u00b1  3.360   s/op\nNdArrayBenchmark.writeFirstBatchChannels                   avgt    5   0.351 \u00b1  0.099   s/op\nNdArrayBenchmark.writeOnePixelBySlicing                    avgt    5   0.777 \u00b1  0.347   s/op\nNdArrayBenchmark.writeOnePixelsByIndex                     avgt    5   0.122 \u00b1  0.004   s/op", "author": "rnett", "createdAt": "2021-01-08T03:27:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5MDE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzM4MjQ2NA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r563382464", "bodyText": "So as we've discussed, the difference between both implementation is negligible.", "author": "karllessard", "createdAt": "2021-01-24T21:58:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5MDE3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/impl/dimension/DimensionalSpace.java b/ndarray/src/main/java/org/tensorflow/ndarray/impl/dimension/DimensionalSpace.java\nindex 55440b7d..e4bdc53c 100644\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/impl/dimension/DimensionalSpace.java\n+++ b/ndarray/src/main/java/org/tensorflow/ndarray/impl/dimension/DimensionalSpace.java\n\n@@ -35,42 +35,24 @@ public class DimensionalSpace {\n   }\n \n   public RelativeDimensionalSpace mapTo(Index[] indices) {\n-    if (dimensions == null) {\n+    if (dimensions == null || indices.length > dimensions.length) {\n       throw new ArrayIndexOutOfBoundsException();\n     }\n     int dimIdx = 0;\n-    int indexIdx = 0;\n     int newDimIdx = 0;\n     int segmentationIdx = -1;\n     long initialOffset = 0;\n \n-    int newAxes = 0;\n-    boolean seenEllipsis = false;\n-    for(Index idx : indices){\n-      if(idx.isNewAxis()){\n-        newAxes += 1;\n-      }\n-      if(idx.isEllipsis()){\n-        if(seenEllipsis){\n-          throw new IllegalArgumentException(\"Only one ellipsis allowed\");\n-        } else {\n-          seenEllipsis = true;\n-        }\n-      }\n-    }\n-    int newLength = dimensions.length + newAxes;\n-\n-    Dimension[] newDimensions = new Dimension[newLength];\n-    while (indexIdx < indices.length) {\n+    Dimension[] newDimensions = new Dimension[dimensions.length];\n+    while (dimIdx < indices.length) {\n \n-      if (indices[indexIdx].isPoint()) {\n+      if (indices[dimIdx].isPoint()) {\n         // When an index targets a single point in a given dimension, calculate the offset of this\n         // point and cumulate the offset of any subsequent point as well\n         long offset = 0;\n         do {\n-          offset += indices[indexIdx].mapCoordinate(0, dimensions[dimIdx]);\n-          dimIdx++;\n-        } while (++indexIdx < indices.length && indices[indexIdx].isPoint());\n+          offset += indices[dimIdx].mapCoordinate(0, dimensions[dimIdx]);\n+        } while (++dimIdx < indices.length && indices[dimIdx].isPoint());\n \n         // If this is the first index, then the offset is the position of the whole dimension\n         // space within the original one. If not, then we apply the offset to the last vectorial\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5MDY1OA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553090658", "bodyText": "Nit : please add a space after your clauses, like if or for and before opening braces in your code, as recommended by the Google Java Style Guide", "author": "karllessard", "createdAt": "2021-01-07T03:34:53Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/impl/dimension/DimensionalSpace.java", "diffHunk": "@@ -35,24 +35,42 @@ public static DimensionalSpace create(Shape shape) {\n   }\n \n   public RelativeDimensionalSpace mapTo(Index[] indices) {\n-    if (dimensions == null || indices.length > dimensions.length) {\n+    if (dimensions == null) {\n       throw new ArrayIndexOutOfBoundsException();\n     }\n     int dimIdx = 0;\n+    int indexIdx = 0;\n     int newDimIdx = 0;\n     int segmentationIdx = -1;\n     long initialOffset = 0;\n \n-    Dimension[] newDimensions = new Dimension[dimensions.length];\n-    while (dimIdx < indices.length) {\n+    int newAxes = 0;\n+    boolean seenEllipsis = false;\n+    for(Index idx : indices){", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/impl/dimension/DimensionalSpace.java b/ndarray/src/main/java/org/tensorflow/ndarray/impl/dimension/DimensionalSpace.java\nindex 55440b7d..e4bdc53c 100644\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/impl/dimension/DimensionalSpace.java\n+++ b/ndarray/src/main/java/org/tensorflow/ndarray/impl/dimension/DimensionalSpace.java\n\n@@ -35,42 +35,24 @@ public class DimensionalSpace {\n   }\n \n   public RelativeDimensionalSpace mapTo(Index[] indices) {\n-    if (dimensions == null) {\n+    if (dimensions == null || indices.length > dimensions.length) {\n       throw new ArrayIndexOutOfBoundsException();\n     }\n     int dimIdx = 0;\n-    int indexIdx = 0;\n     int newDimIdx = 0;\n     int segmentationIdx = -1;\n     long initialOffset = 0;\n \n-    int newAxes = 0;\n-    boolean seenEllipsis = false;\n-    for(Index idx : indices){\n-      if(idx.isNewAxis()){\n-        newAxes += 1;\n-      }\n-      if(idx.isEllipsis()){\n-        if(seenEllipsis){\n-          throw new IllegalArgumentException(\"Only one ellipsis allowed\");\n-        } else {\n-          seenEllipsis = true;\n-        }\n-      }\n-    }\n-    int newLength = dimensions.length + newAxes;\n-\n-    Dimension[] newDimensions = new Dimension[newLength];\n-    while (indexIdx < indices.length) {\n+    Dimension[] newDimensions = new Dimension[dimensions.length];\n+    while (dimIdx < indices.length) {\n \n-      if (indices[indexIdx].isPoint()) {\n+      if (indices[dimIdx].isPoint()) {\n         // When an index targets a single point in a given dimension, calculate the offset of this\n         // point and cumulate the offset of any subsequent point as well\n         long offset = 0;\n         do {\n-          offset += indices[indexIdx].mapCoordinate(0, dimensions[dimIdx]);\n-          dimIdx++;\n-        } while (++indexIdx < indices.length && indices[indexIdx].isPoint());\n+          offset += indices[dimIdx].mapCoordinate(0, dimensions[dimIdx]);\n+        } while (++dimIdx < indices.length && indices[dimIdx].isPoint());\n \n         // If this is the first index, then the offset is the position of the whole dimension\n         // space within the original one. If not, then we apply the offset to the last vectorial\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5MjE5NQ==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553092195", "bodyText": "I don't understand that TODO anymore, can you please remove it since we are changing the expected behaviour anyway?", "author": "karllessard", "createdAt": "2021-01-07T03:41:11Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/index/At.java", "diffHunk": "@@ -27,22 +28,53 @@ public long numElements(Dimension dim) {\n \n   @Override\n   public long mapCoordinate(long coordinate, Dimension dim) {\n+    long coord = this.coord >= 0 ? this.coord : dim.numElements() + this.coord;\n     return dim.positionOf(coord); // TODO validate coordinate is 0?", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/index/At.java b/ndarray/src/main/java/org/tensorflow/ndarray/index/At.java\nindex 43596beb..5d92ee32 100644\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/index/At.java\n+++ b/ndarray/src/main/java/org/tensorflow/ndarray/index/At.java\n\n@@ -28,53 +27,22 @@ final class At implements TensorIndex {\n \n   @Override\n   public long mapCoordinate(long coordinate, Dimension dim) {\n-    long coord = this.coord >= 0 ? this.coord : dim.numElements() + this.coord;\n     return dim.positionOf(coord); // TODO validate coordinate is 0?\n   }\n \n   @Override\n   public Dimension apply(Dimension dim) {\n-    if(keepDim){\n-      return dim.withIndex(this);\n-    }\n-    else {\n-      throw new IllegalStateException(); // FIXME?\n-    }\n+    throw new IllegalStateException(); // FIXME?\n   }\n \n   @Override\n   public boolean isPoint() {\n-    return !keepDim;\n+    return true;\n   }\n \n-  At(long coord, boolean keepDim) {\n+  At(long coord) {\n     this.coord = coord;\n-    this.keepDim = keepDim;\n   }\n \n   private final long coord;\n-  private final boolean keepDim;\n-\n-  @Override\n-  public long begin() {\n-    return coord;\n-  }\n-\n-  @Override\n-  public long end() {\n-    return coord + 1;\n-  }\n-\n-  @Override\n-  public boolean shrinkAxisMask() {\n-    return !keepDim;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return new StringJoiner(\", \", At.class.getSimpleName() + \"(\", \")\")\n-        .add(\"coord=\" + coord)\n-        .add(\"keepDim=\" + keepDim)\n-        .toString();\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5MjQ3MA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553092470", "bodyText": "Nit: reversing the condition makes it more clear, i.e.\nif (!keepDim) {\n    throw ...\n}\nreturn dim.withIndex(this);", "author": "karllessard", "createdAt": "2021-01-07T03:42:39Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/index/At.java", "diffHunk": "@@ -27,22 +28,53 @@ public long numElements(Dimension dim) {\n \n   @Override\n   public long mapCoordinate(long coordinate, Dimension dim) {\n+    long coord = this.coord >= 0 ? this.coord : dim.numElements() + this.coord;\n     return dim.positionOf(coord); // TODO validate coordinate is 0?\n   }\n \n   @Override\n   public Dimension apply(Dimension dim) {\n-    throw new IllegalStateException(); // FIXME?\n+    if(keepDim){\n+      return dim.withIndex(this);\n+    }\n+    else {", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/index/At.java b/ndarray/src/main/java/org/tensorflow/ndarray/index/At.java\nindex 43596beb..5d92ee32 100644\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/index/At.java\n+++ b/ndarray/src/main/java/org/tensorflow/ndarray/index/At.java\n\n@@ -28,53 +27,22 @@ final class At implements TensorIndex {\n \n   @Override\n   public long mapCoordinate(long coordinate, Dimension dim) {\n-    long coord = this.coord >= 0 ? this.coord : dim.numElements() + this.coord;\n     return dim.positionOf(coord); // TODO validate coordinate is 0?\n   }\n \n   @Override\n   public Dimension apply(Dimension dim) {\n-    if(keepDim){\n-      return dim.withIndex(this);\n-    }\n-    else {\n-      throw new IllegalStateException(); // FIXME?\n-    }\n+    throw new IllegalStateException(); // FIXME?\n   }\n \n   @Override\n   public boolean isPoint() {\n-    return !keepDim;\n+    return true;\n   }\n \n-  At(long coord, boolean keepDim) {\n+  At(long coord) {\n     this.coord = coord;\n-    this.keepDim = keepDim;\n   }\n \n   private final long coord;\n-  private final boolean keepDim;\n-\n-  @Override\n-  public long begin() {\n-    return coord;\n-  }\n-\n-  @Override\n-  public long end() {\n-    return coord + 1;\n-  }\n-\n-  @Override\n-  public boolean shrinkAxisMask() {\n-    return !keepDim;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return new StringJoiner(\", \", At.class.getSimpleName() + \"(\", \")\")\n-        .add(\"coord=\" + coord)\n-        .add(\"keepDim=\" + keepDim)\n-        .toString();\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5MjkyMw==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553092923", "bodyText": "This class is missing documentation\nAlso, the notion of Tensor is deliberately not being used in the ndarray library. A Tensor is a NdArray allocated by TensorFlow, but the ndarray is agnostic of TensorFlow (it will even be moved eventually to a separate repository) so we shouldn't mix concepts.\nDo we really need to distinguish them with \"standard\" indices? What about adding all these methods directly to Index and throw an exception if they are being called on Hyperslab or Sequence?\nI understand that having TensorIndex allows us to enforce at compile time that only these instances can be passed to index a Tensor in TF but I don't think these two indices are used very often and it could be fine doing it.", "author": "karllessard", "createdAt": "2021-01-07T03:44:46Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/index/TensorIndex.java", "diffHunk": "@@ -12,29 +12,39 @@\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n- =======================================================================\n+ ==============================================================================\n  */\n package org.tensorflow.ndarray.index;\n \n-import org.tensorflow.ndarray.impl.dimension.Dimension;\n+public interface TensorIndex extends Index{", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY3NTIwMA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553675200", "bodyText": "I like that better.  For now, I've implemented it as a tensorSupport method, since the other methods have useful defaults and I don't like \"override a method if it doesn't work\", it's too easy to miss when adding indices.  The javadocs of those methods mention tensors too.  Do you think it would be better to call it non-DimensionalSpace or non-NDArray usage, instead of Tensor usage?", "author": "rnett", "createdAt": "2021-01-08T00:44:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5MjkyMw=="}], "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/index/TensorIndex.java b/ndarray/src/main/java/org/tensorflow/ndarray/index/From.java\nsimilarity index 56%\nrename from ndarray/src/main/java/org/tensorflow/ndarray/index/TensorIndex.java\nrename to ndarray/src/main/java/org/tensorflow/ndarray/index/From.java\nindex c66dd18d..c541e837 100644\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/index/TensorIndex.java\n+++ b/ndarray/src/main/java/org/tensorflow/ndarray/index/From.java\n\n@@ -12,39 +12,27 @@\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n- ==============================================================================\n+ =======================================================================\n  */\n package org.tensorflow.ndarray.index;\n \n-public interface TensorIndex extends Index{\n-  default long begin(){\n-    return 0;\n-  }\n-  default long end(){\n-    return 0;\n-  }\n-\n-  default long stride(){\n-    return 1;\n-  }\n+import org.tensorflow.ndarray.impl.dimension.Dimension;\n \n-  default boolean beginMask(){\n-    return false;\n-  }\n+final class From implements Index {\n \n-  default boolean endMask(){\n-    return false;\n+  @Override\n+  public long numElements(Dimension dim) {\n+    return dim.numElements() - start;\n   }\n \n-  default boolean ellipsisMask(){\n-    return false;\n+  @Override\n+  public long mapCoordinate(long coordinate, Dimension dim) {\n+    return start + coordinate;\n   }\n \n-  default boolean newAxisMask(){\n-    return false;\n+  From(long start) {\n+    this.start = start;\n   }\n \n-  default boolean shrinkAxisMask(){\n-    return false;\n-  }\n+  private final long start;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5NjgzMw==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553096833", "bodyText": "I don't think IllegalStateException is the right exception to be thrown here, since there is no state involve. What about UnsupportedOperationException?", "author": "karllessard", "createdAt": "2021-01-07T04:02:51Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/index/Ellipsis.java", "diffHunk": "@@ -12,26 +12,43 @@\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n- =======================================================================\n+ ==============================================================================\n  */\n package org.tensorflow.ndarray.index;\n \n+import java.util.StringJoiner;\n import org.tensorflow.ndarray.impl.dimension.Dimension;\n \n-final class Even implements Index {\n+final class Ellipsis implements TensorIndex{\n \n-  static final Even INSTANCE = new Even();\n+  static final Ellipsis INSTANCE = new Ellipsis();\n+\n+  private Ellipsis(){\n+\n+  }\n \n   @Override\n   public long numElements(Dimension dim) {\n-    return (dim.numElements() >> 1) + (dim.numElements() % 2);\n+    throw new IllegalStateException();\n   }\n \n   @Override\n   public long mapCoordinate(long coordinate, Dimension dim) {\n-    return coordinate << 1;\n+    throw new IllegalStateException();", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/index/Ellipsis.java b/ndarray/src/main/java/org/tensorflow/ndarray/index/Even.java\nsimilarity index 62%\nrename from ndarray/src/main/java/org/tensorflow/ndarray/index/Ellipsis.java\nrename to ndarray/src/main/java/org/tensorflow/ndarray/index/Even.java\nindex 6b05c5a7..54f53853 100644\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/index/Ellipsis.java\n+++ b/ndarray/src/main/java/org/tensorflow/ndarray/index/Even.java\n\n@@ -12,43 +12,26 @@\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n- ==============================================================================\n+ =======================================================================\n  */\n package org.tensorflow.ndarray.index;\n \n-import java.util.StringJoiner;\n import org.tensorflow.ndarray.impl.dimension.Dimension;\n \n-final class Ellipsis implements TensorIndex{\n+final class Even implements Index {\n \n-  static final Ellipsis INSTANCE = new Ellipsis();\n-\n-  private Ellipsis(){\n-\n-  }\n+  static final Even INSTANCE = new Even();\n \n   @Override\n   public long numElements(Dimension dim) {\n-    throw new IllegalStateException();\n+    return (dim.numElements() >> 1) + (dim.numElements() % 2);\n   }\n \n   @Override\n   public long mapCoordinate(long coordinate, Dimension dim) {\n-    throw new IllegalStateException();\n-  }\n-\n-  @Override\n-  public boolean isEllipsis() {\n-    return true;\n+    return coordinate << 1;\n   }\n \n-  @Override\n-  public boolean ellipsisMask() {\n-    return true;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"Ellipsis()\";\n+  private Even() {\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5NzMxNw==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553097317", "bodyText": "in Hyperslab, you use the getClass().getSimpleName() to return that string, should we do it everywhere?", "author": "karllessard", "createdAt": "2021-01-07T04:05:01Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/index/Ellipsis.java", "diffHunk": "@@ -12,26 +12,43 @@\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n- =======================================================================\n+ ==============================================================================\n  */\n package org.tensorflow.ndarray.index;\n \n+import java.util.StringJoiner;\n import org.tensorflow.ndarray.impl.dimension.Dimension;\n \n-final class Even implements Index {\n+final class Ellipsis implements TensorIndex{\n \n-  static final Even INSTANCE = new Even();\n+  static final Ellipsis INSTANCE = new Ellipsis();\n+\n+  private Ellipsis(){\n+\n+  }\n \n   @Override\n   public long numElements(Dimension dim) {\n-    return (dim.numElements() >> 1) + (dim.numElements() % 2);\n+    throw new IllegalStateException();\n   }\n \n   @Override\n   public long mapCoordinate(long coordinate, Dimension dim) {\n-    return coordinate << 1;\n+    throw new IllegalStateException();\n+  }\n+\n+  @Override\n+  public boolean isEllipsis() {\n+    return true;\n   }\n \n-  private Even() {\n+  @Override\n+  public boolean ellipsisMask() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"Ellipsis()\";", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/index/Ellipsis.java b/ndarray/src/main/java/org/tensorflow/ndarray/index/Even.java\nsimilarity index 62%\nrename from ndarray/src/main/java/org/tensorflow/ndarray/index/Ellipsis.java\nrename to ndarray/src/main/java/org/tensorflow/ndarray/index/Even.java\nindex 6b05c5a7..54f53853 100644\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/index/Ellipsis.java\n+++ b/ndarray/src/main/java/org/tensorflow/ndarray/index/Even.java\n\n@@ -12,43 +12,26 @@\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n- ==============================================================================\n+ =======================================================================\n  */\n package org.tensorflow.ndarray.index;\n \n-import java.util.StringJoiner;\n import org.tensorflow.ndarray.impl.dimension.Dimension;\n \n-final class Ellipsis implements TensorIndex{\n+final class Even implements Index {\n \n-  static final Ellipsis INSTANCE = new Ellipsis();\n-\n-  private Ellipsis(){\n-\n-  }\n+  static final Even INSTANCE = new Even();\n \n   @Override\n   public long numElements(Dimension dim) {\n-    throw new IllegalStateException();\n+    return (dim.numElements() >> 1) + (dim.numElements() % 2);\n   }\n \n   @Override\n   public long mapCoordinate(long coordinate, Dimension dim) {\n-    throw new IllegalStateException();\n-  }\n-\n-  @Override\n-  public boolean isEllipsis() {\n-    return true;\n+    return coordinate << 1;\n   }\n \n-  @Override\n-  public boolean ellipsisMask() {\n-    return true;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"Ellipsis()\";\n+  private Even() {\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5ODI2OQ==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553098269", "bodyText": "why having both expand() and ellipsis() if they are the same?", "author": "karllessard", "createdAt": "2021-01-07T04:09:08Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java", "diffHunk": "@@ -216,4 +255,129 @@ public static Index flip() {\n   public static Index hyperslab(long start, long stride, long count, long block) {\n     return new Hyperslab(start, stride, count, block);\n   }\n+\n+  /**\n+   * An index that inserts a new dimension of size 1 into the resulting array.\n+   *\n+   * @return index\n+   */\n+  public static TensorIndex newAxis(){\n+    return NewAxis.INSTANCE;\n+  }\n+\n+  /**\n+   * An index that expands to fill all available source dimensions.\n+   * Works the same as Python's {@code ...}.\n+   * @see #expand()\n+   * @return index\n+   */\n+  public static TensorIndex ellipsis(){\n+    return Ellipsis.INSTANCE;\n+  }\n+\n+  /**\n+   * An index that expands to fill all available source dimensions.\n+   * Works the same as Python's {@code ...}.\n+   *\n+   * @return index\n+   */\n+  public static TensorIndex expand(){", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY3MjY3OA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553672678", "bodyText": "Because it really should be called \"expand\" or similar, but anyone coming from Python will be looking for ellipsis.  I could go with just one.", "author": "rnett", "createdAt": "2021-01-08T00:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5ODI2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java b/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java\nindex 42018dc9..abc72195 100644\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java\n+++ b/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java\n\n@@ -255,129 +216,4 @@ public final class Indices {\n   public static Index hyperslab(long start, long stride, long count, long block) {\n     return new Hyperslab(start, stride, count, block);\n   }\n-\n-  /**\n-   * An index that inserts a new dimension of size 1 into the resulting array.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex newAxis(){\n-    return NewAxis.INSTANCE;\n-  }\n-\n-  /**\n-   * An index that expands to fill all available source dimensions.\n-   * Works the same as Python's {@code ...}.\n-   * @see #expand()\n-   * @return index\n-   */\n-  public static TensorIndex ellipsis(){\n-    return Ellipsis.INSTANCE;\n-  }\n-\n-  /**\n-   * An index that expands to fill all available source dimensions.\n-   * Works the same as Python's {@code ...}.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex expand(){\n-    return ellipsis();\n-  }\n-\n-  /**\n-   * An index that returns elements between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(Long start, Long end){\n-    return slice(start, end, 1);\n-  }\n-\n-  /**\n-   * An index that returns elements between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(long start, Long end){\n-    return slice(start, end, 1);\n-  }\n-\n-  /**\n-   * An index that returns elements between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(Long start, long end){\n-    return slice(start, end, 1);\n-  }\n-\n-  /**\n-   * An index that returns elements between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(long start, long end){\n-    return slice(start, end, 1);\n-  }\n-\n-  /**\n-   * An index that returns every {@code stride}-th element between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(Long start, Long end, long stride){\n-    return new Slice(start, end, stride);\n-  }\n-\n-  /**\n-   * An index that returns every {@code stride}-th element between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(long start, Long end, long stride){\n-    return new Slice(start, end, stride);\n-  }\n-\n-  /**\n-   * An index that returns every {@code stride}-th element between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(Long start, long end, long stride){\n-    return new Slice(start, end, stride);\n-  }\n-\n-  /**\n-   * An index that returns every {@code stride}-th element between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(long start, long end, long stride){\n-    return new Slice(start, end, stride);\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5ODk3OQ==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553098979", "bodyText": "instead of having all those variants with nullable boxed type and primitive long, could we just rename the methods differently so they accept only parameters that matters?\ne.g.\nslice(Long, long) -> sliceTo(long)\nslice(long, Long) -> sliceFrom(long)\nslice(Long, Long) -> do we really need this one, as it just returns all() ultimately?", "author": "karllessard", "createdAt": "2021-01-07T04:12:34Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java", "diffHunk": "@@ -216,4 +255,129 @@ public static Index flip() {\n   public static Index hyperslab(long start, long stride, long count, long block) {\n     return new Hyperslab(start, stride, count, block);\n   }\n+\n+  /**\n+   * An index that inserts a new dimension of size 1 into the resulting array.\n+   *\n+   * @return index\n+   */\n+  public static TensorIndex newAxis(){\n+    return NewAxis.INSTANCE;\n+  }\n+\n+  /**\n+   * An index that expands to fill all available source dimensions.\n+   * Works the same as Python's {@code ...}.\n+   * @see #expand()\n+   * @return index\n+   */\n+  public static TensorIndex ellipsis(){\n+    return Ellipsis.INSTANCE;\n+  }\n+\n+  /**\n+   * An index that expands to fill all available source dimensions.\n+   * Works the same as Python's {@code ...}.\n+   *\n+   * @return index\n+   */\n+  public static TensorIndex expand(){\n+    return ellipsis();\n+  }\n+\n+  /**\n+   * An index that returns elements between {@code start} and {@code end}.\n+   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n+   * <p>\n+   * Analogous to Python's {@code :} slice syntax.\n+   *\n+   * @return index\n+   */\n+  public static TensorIndex slice(Long start, Long end){\n+    return slice(start, end, 1);\n+  }\n+\n+  /**\n+   * An index that returns elements between {@code start} and {@code end}.\n+   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n+   * <p>\n+   * Analogous to Python's {@code :} slice syntax.\n+   *\n+   * @return index\n+   */\n+  public static TensorIndex slice(long start, Long end){\n+    return slice(start, end, 1);\n+  }\n+\n+  /**\n+   * An index that returns elements between {@code start} and {@code end}.\n+   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n+   * <p>\n+   * Analogous to Python's {@code :} slice syntax.\n+   *\n+   * @return index\n+   */\n+  public static TensorIndex slice(Long start, long end){\n+    return slice(start, end, 1);\n+  }\n+\n+  /**\n+   * An index that returns elements between {@code start} and {@code end}.\n+   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n+   * <p>\n+   * Analogous to Python's {@code :} slice syntax.\n+   *\n+   * @return index\n+   */\n+  public static TensorIndex slice(long start, long end){\n+    return slice(start, end, 1);\n+  }", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY3NjE4NA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553676184", "bodyText": "We already have to and from, I'll change them to sliceTo and sliceFrom and add overloads w/ stride.\nThe reason I included the nullable versions there is for calling with maybe-null data (like say from the Kotlin API).  Otherwise the caller would have to decide which one to use based on there parameters, so I think it's worth having a method that does that disambiguation.", "author": "rnett", "createdAt": "2021-01-08T00:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5ODk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY5MTE2Ng==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553691166", "bodyText": "Either way I can reduce the overloads though, they were for literal conversions which won't be an issue any more.", "author": "rnett", "createdAt": "2021-01-08T01:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5ODk3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java b/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java\nindex 42018dc9..abc72195 100644\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java\n+++ b/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java\n\n@@ -255,129 +216,4 @@ public final class Indices {\n   public static Index hyperslab(long start, long stride, long count, long block) {\n     return new Hyperslab(start, stride, count, block);\n   }\n-\n-  /**\n-   * An index that inserts a new dimension of size 1 into the resulting array.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex newAxis(){\n-    return NewAxis.INSTANCE;\n-  }\n-\n-  /**\n-   * An index that expands to fill all available source dimensions.\n-   * Works the same as Python's {@code ...}.\n-   * @see #expand()\n-   * @return index\n-   */\n-  public static TensorIndex ellipsis(){\n-    return Ellipsis.INSTANCE;\n-  }\n-\n-  /**\n-   * An index that expands to fill all available source dimensions.\n-   * Works the same as Python's {@code ...}.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex expand(){\n-    return ellipsis();\n-  }\n-\n-  /**\n-   * An index that returns elements between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(Long start, Long end){\n-    return slice(start, end, 1);\n-  }\n-\n-  /**\n-   * An index that returns elements between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(long start, Long end){\n-    return slice(start, end, 1);\n-  }\n-\n-  /**\n-   * An index that returns elements between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(Long start, long end){\n-    return slice(start, end, 1);\n-  }\n-\n-  /**\n-   * An index that returns elements between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(long start, long end){\n-    return slice(start, end, 1);\n-  }\n-\n-  /**\n-   * An index that returns every {@code stride}-th element between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(Long start, Long end, long stride){\n-    return new Slice(start, end, stride);\n-  }\n-\n-  /**\n-   * An index that returns every {@code stride}-th element between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(long start, Long end, long stride){\n-    return new Slice(start, end, stride);\n-  }\n-\n-  /**\n-   * An index that returns every {@code stride}-th element between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(Long start, long end, long stride){\n-    return new Slice(start, end, stride);\n-  }\n-\n-  /**\n-   * An index that returns every {@code stride}-th element between {@code start} and {@code end}.\n-   * If {@code start} or {@code end} is {@code null}, starts or ends at the beginning or the end, respectively.\n-   * <p>\n-   * Analogous to Python's {@code :} slice syntax.\n-   *\n-   * @return index\n-   */\n-  public static TensorIndex slice(long start, long end, long stride){\n-    return new Slice(start, end, stride);\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5OTQ5NA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553099494", "bodyText": "Nit: no need of else clauses when you return unconditionally in your previous if blocks, I find it improves readability\nAlso not required, most of the code in TF Java follow a reversed order of the elements of a class, where elements with a higher visibility (public) are at the top of the class while those at the bottom has the lower one.", "author": "karllessard", "createdAt": "2021-01-07T04:14:54Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/index/Slice.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+  Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ ==============================================================================\n+ */\n+package org.tensorflow.ndarray.index;\n+\n+import java.util.StringJoiner;\n+import org.tensorflow.ndarray.impl.dimension.Dimension;\n+\n+final class Slice implements TensorIndex {\n+\n+  private final Long start;\n+  private final Long end;\n+  private final long stride;\n+\n+  private long start(Dimension dim){\n+    if(start == null){\n+      if(stride > 0){\n+        return 0;\n+      } else {\n+        return dim.numElements() - 1; // it's inclusive\n+      }\n+    } else if(start < 0){\n+      return dim.numElements() + start;\n+    } else {\n+      return start;\n+    }", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/index/Slice.java b/ndarray/src/main/java/org/tensorflow/ndarray/index/Slice.java\ndeleted file mode 100644\nindex 98f8fe1b..00000000\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/index/Slice.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-/*\n-  Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n-\n- Licensed under the Apache License, Version 2.0 (the \"License\");\n- you may not use this file except in compliance with the License.\n- You may obtain a copy of the License at\n-\n-     http://www.apache.org/licenses/LICENSE-2.0\n-\n- Unless required by applicable law or agreed to in writing, software\n- distributed under the License is distributed on an \"AS IS\" BASIS,\n- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- See the License for the specific language governing permissions and\n- limitations under the License.\n- ==============================================================================\n- */\n-package org.tensorflow.ndarray.index;\n-\n-import java.util.StringJoiner;\n-import org.tensorflow.ndarray.impl.dimension.Dimension;\n-\n-final class Slice implements TensorIndex {\n-\n-  private final Long start;\n-  private final Long end;\n-  private final long stride;\n-\n-  private long start(Dimension dim){\n-    if(start == null){\n-      if(stride > 0){\n-        return 0;\n-      } else {\n-        return dim.numElements() - 1; // it's inclusive\n-      }\n-    } else if(start < 0){\n-      return dim.numElements() + start;\n-    } else {\n-      return start;\n-    }\n-  }\n-\n-  private long end(Dimension dim){\n-    if(end == null){\n-      if(stride > 0){\n-        return dim.numElements();\n-      } else {\n-        return -1; // it's exclusive\n-      }\n-    } else if(end < 0){\n-      return dim.numElements() + end;\n-    } else {\n-      return end;\n-    }\n-  }\n-\n-  Slice(Long start, Long end, long stride) {\n-    this.start = start;\n-    this.end = end;\n-    this.stride = stride;\n-\n-    if(stride == 0){\n-      throw new IllegalArgumentException(\"Can not have a stride of 0\");\n-    }\n-  }\n-\n-  @Override\n-  public long numElements(Dimension dim) {\n-    long length = end(dim) - start(dim);\n-\n-    return (length / stride) + (length % stride != 0 ? 1 : 0);\n-  }\n-\n-  @Override\n-  public long mapCoordinate(long coordinate, Dimension dim) {\n-    return start(dim) + stride * coordinate;\n-  }\n-\n-  @Override\n-  public long begin() {\n-    return start == null ? 0 : start;\n-  }\n-\n-  @Override\n-  public long end() {\n-    return end == null ? 0 : end;\n-  }\n-\n-  @Override\n-  public long stride() {\n-    return stride;\n-  }\n-\n-  @Override\n-  public boolean beginMask() {\n-    return start == null;\n-  }\n-\n-  @Override\n-  public boolean endMask() {\n-    return end == null;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return new StringJoiner(\", \", Slice.class.getSimpleName() + \"(\", \")\")\n-        .add(\"start=\" + start)\n-        .add(\"end=\" + end)\n-        .add(\"stride=\" + stride)\n-        .toString();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzEwMDYxNA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553100614", "bodyText": "If we take the sliceTo/sliceFrom route, having distinct implementation of Index (i.e. SliceTo and SliceFrom) could reduce the complexity/cost of each case and avoid the boxed type conversion. There is not much gain having them all implemented by a single class.", "author": "karllessard", "createdAt": "2021-01-07T04:19:31Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/index/Slice.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+  Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ ==============================================================================\n+ */\n+package org.tensorflow.ndarray.index;\n+\n+import java.util.StringJoiner;\n+import org.tensorflow.ndarray.impl.dimension.Dimension;\n+\n+final class Slice implements TensorIndex {", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/index/Slice.java b/ndarray/src/main/java/org/tensorflow/ndarray/index/Slice.java\ndeleted file mode 100644\nindex 98f8fe1b..00000000\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/index/Slice.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-/*\n-  Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n-\n- Licensed under the Apache License, Version 2.0 (the \"License\");\n- you may not use this file except in compliance with the License.\n- You may obtain a copy of the License at\n-\n-     http://www.apache.org/licenses/LICENSE-2.0\n-\n- Unless required by applicable law or agreed to in writing, software\n- distributed under the License is distributed on an \"AS IS\" BASIS,\n- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- See the License for the specific language governing permissions and\n- limitations under the License.\n- ==============================================================================\n- */\n-package org.tensorflow.ndarray.index;\n-\n-import java.util.StringJoiner;\n-import org.tensorflow.ndarray.impl.dimension.Dimension;\n-\n-final class Slice implements TensorIndex {\n-\n-  private final Long start;\n-  private final Long end;\n-  private final long stride;\n-\n-  private long start(Dimension dim){\n-    if(start == null){\n-      if(stride > 0){\n-        return 0;\n-      } else {\n-        return dim.numElements() - 1; // it's inclusive\n-      }\n-    } else if(start < 0){\n-      return dim.numElements() + start;\n-    } else {\n-      return start;\n-    }\n-  }\n-\n-  private long end(Dimension dim){\n-    if(end == null){\n-      if(stride > 0){\n-        return dim.numElements();\n-      } else {\n-        return -1; // it's exclusive\n-      }\n-    } else if(end < 0){\n-      return dim.numElements() + end;\n-    } else {\n-      return end;\n-    }\n-  }\n-\n-  Slice(Long start, Long end, long stride) {\n-    this.start = start;\n-    this.end = end;\n-    this.stride = stride;\n-\n-    if(stride == 0){\n-      throw new IllegalArgumentException(\"Can not have a stride of 0\");\n-    }\n-  }\n-\n-  @Override\n-  public long numElements(Dimension dim) {\n-    long length = end(dim) - start(dim);\n-\n-    return (length / stride) + (length % stride != 0 ? 1 : 0);\n-  }\n-\n-  @Override\n-  public long mapCoordinate(long coordinate, Dimension dim) {\n-    return start(dim) + stride * coordinate;\n-  }\n-\n-  @Override\n-  public long begin() {\n-    return start == null ? 0 : start;\n-  }\n-\n-  @Override\n-  public long end() {\n-    return end == null ? 0 : end;\n-  }\n-\n-  @Override\n-  public long stride() {\n-    return stride;\n-  }\n-\n-  @Override\n-  public boolean beginMask() {\n-    return start == null;\n-  }\n-\n-  @Override\n-  public boolean endMask() {\n-    return end == null;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return new StringJoiner(\", \", Slice.class.getSimpleName() + \"(\", \")\")\n-        .add(\"start=\" + start)\n-        .add(\"end=\" + end)\n-        .add(\"stride=\" + stride)\n-        .toString();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzEwMTg3MQ==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553101871", "bodyText": "Nit: add a space here", "author": "karllessard", "createdAt": "2021-01-07T04:25:04Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+package org.tensorflow.op.core;\n+\n+import org.tensorflow.Operand;\n+import org.tensorflow.ndarray.index.Indices;\n+import org.tensorflow.ndarray.index.TensorIndex;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.annotation.Endpoint;\n+import org.tensorflow.op.annotation.Operator;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Helper endpoint methods for Python like indexing.\n+ *\n+ * @see org.tensorflow.ndarray.index.Indices\n+ */\n+@Operator\n+public abstract class StridedSliceHelper {\n+\n+  static class StridedSliceArgs {\n+\n+    final int[] begin;\n+    final int[] end;\n+    final int[] strides;\n+    final long beginMask;\n+    final long endMask;\n+    final long ellipsisMask;\n+    final long newAxisMask;\n+    final long shrinkAxisMask;\n+\n+    private StridedSliceArgs(int[] begin, int[] end, int[] strides, long beginMask, long endMask, long ellipsisMask,\n+        long newAxisMask, long shrinkAxisMask) {\n+      this.begin = begin;\n+      this.end = end;\n+      this.strides = strides;\n+      this.beginMask = beginMask;\n+      this.endMask = endMask;\n+      this.ellipsisMask = ellipsisMask;\n+      this.newAxisMask = newAxisMask;\n+      this.shrinkAxisMask = shrinkAxisMask;\n+    }\n+  }\n+\n+  static StridedSliceArgs mergeIndexes(TensorIndex[] indices) {\n+    int[] begin = new int[indices.length];\n+    int[] end = new int[indices.length];\n+    int[] strides = new int[indices.length];\n+    long beginMask = 0;\n+    long endMask = 0;\n+    long ellipsisMask = 0;\n+    long newAxisMask = 0;\n+    long shrinkAxisMask = 0;\n+\n+    for (int i = 0; i < indices.length; i++) {\n+      TensorIndex idx = indices[i];\n+      if (idx == null) {\n+        idx = Indices.all();\n+      }\n+\n+      begin[i] = (int) idx.begin();\n+      if(begin[i] != idx.begin())\n+        throw new IllegalArgumentException(\"Can't convert long begin value to int for index \" + idx + \": Out of bounds\");\n+\n+      end[i] = (int) idx.end();\n+      if(end[i] != idx.end())\n+        throw new IllegalArgumentException(\"Can't convert long end value to int for index \" + idx + \": Out of bounds\");\n+\n+      strides[i] = (int) idx.stride();\n+      if(strides[i] != idx.stride())\n+        throw new IllegalArgumentException(\"Can't convert long stride value to int for index \" + idx + \": Out of bounds\");\n+\n+      if (idx.beginMask()) {\n+        beginMask |= 1L << i;\n+      }\n+\n+      if (idx.endMask()) {\n+        endMask |= 1L << i;\n+      }\n+\n+      if (idx.ellipsisMask()) {\n+        if(ellipsisMask != 0)\n+          throw new IllegalArgumentException(\"Can not have two ellipsis in a slice\");\n+        ellipsisMask |= 1L << i;\n+      }\n+\n+      if (idx.newAxisMask()) {\n+        newAxisMask |= 1L << i;\n+      }\n+\n+      if (idx.shrinkAxisMask()) {\n+        shrinkAxisMask |= 1L << i;\n+      }\n+    }\n+\n+    return new StridedSliceArgs(begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);\n+  }", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java b/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java\ndeleted file mode 100644\nindex 37111979..00000000\n--- a/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java\n+++ /dev/null\n\n@@ -1,214 +0,0 @@\n-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-package org.tensorflow.op.core;\n-\n-import org.tensorflow.Operand;\n-import org.tensorflow.ndarray.index.Indices;\n-import org.tensorflow.ndarray.index.TensorIndex;\n-import org.tensorflow.op.Scope;\n-import org.tensorflow.op.annotation.Endpoint;\n-import org.tensorflow.op.annotation.Operator;\n-import org.tensorflow.types.family.TType;\n-\n-/**\n- * Helper endpoint methods for Python like indexing.\n- *\n- * @see org.tensorflow.ndarray.index.Indices\n- */\n-@Operator\n-public abstract class StridedSliceHelper {\n-\n-  static class StridedSliceArgs {\n-\n-    final int[] begin;\n-    final int[] end;\n-    final int[] strides;\n-    final long beginMask;\n-    final long endMask;\n-    final long ellipsisMask;\n-    final long newAxisMask;\n-    final long shrinkAxisMask;\n-\n-    private StridedSliceArgs(int[] begin, int[] end, int[] strides, long beginMask, long endMask, long ellipsisMask,\n-        long newAxisMask, long shrinkAxisMask) {\n-      this.begin = begin;\n-      this.end = end;\n-      this.strides = strides;\n-      this.beginMask = beginMask;\n-      this.endMask = endMask;\n-      this.ellipsisMask = ellipsisMask;\n-      this.newAxisMask = newAxisMask;\n-      this.shrinkAxisMask = shrinkAxisMask;\n-    }\n-  }\n-\n-  static StridedSliceArgs mergeIndexes(TensorIndex[] indices) {\n-    int[] begin = new int[indices.length];\n-    int[] end = new int[indices.length];\n-    int[] strides = new int[indices.length];\n-    long beginMask = 0;\n-    long endMask = 0;\n-    long ellipsisMask = 0;\n-    long newAxisMask = 0;\n-    long shrinkAxisMask = 0;\n-\n-    for (int i = 0; i < indices.length; i++) {\n-      TensorIndex idx = indices[i];\n-      if (idx == null) {\n-        idx = Indices.all();\n-      }\n-\n-      begin[i] = (int) idx.begin();\n-      if(begin[i] != idx.begin())\n-        throw new IllegalArgumentException(\"Can't convert long begin value to int for index \" + idx + \": Out of bounds\");\n-\n-      end[i] = (int) idx.end();\n-      if(end[i] != idx.end())\n-        throw new IllegalArgumentException(\"Can't convert long end value to int for index \" + idx + \": Out of bounds\");\n-\n-      strides[i] = (int) idx.stride();\n-      if(strides[i] != idx.stride())\n-        throw new IllegalArgumentException(\"Can't convert long stride value to int for index \" + idx + \": Out of bounds\");\n-\n-      if (idx.beginMask()) {\n-        beginMask |= 1L << i;\n-      }\n-\n-      if (idx.endMask()) {\n-        endMask |= 1L << i;\n-      }\n-\n-      if (idx.ellipsisMask()) {\n-        if(ellipsisMask != 0)\n-          throw new IllegalArgumentException(\"Can not have two ellipsis in a slice\");\n-        ellipsisMask |= 1L << i;\n-      }\n-\n-      if (idx.newAxisMask()) {\n-        newAxisMask |= 1L << i;\n-      }\n-\n-      if (idx.shrinkAxisMask()) {\n-        shrinkAxisMask |= 1L << i;\n-      }\n-    }\n-\n-    return new StridedSliceArgs(begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);\n-  }\n-  /**\n-   * Return a strided slice from `input`.\n-   *  <p>\n-   *  The goal of this op is to produce a new tensor with a subset of\n-   *  the elements from the `n` dimensional `input` tensor. The subset is chosen using\n-   *  a sequence of `m` sparse range specifications encoded into the arguments\n-   *  of this function. Note, in some cases\n-   *  `m` could be equal to `n`, but this need not be the case. Each\n-   *  range specification entry can be one of the following:\n-   *  <p>\n-   *  - An ellipsis (...) using {@link Indices#ellipsis()}. Ellipses are used to imply zero or more\n-   *    dimensions of full-dimension selection and are produced using\n-   *    `ellipsis_mask`. For example, `foo[...]` is the identity slice.\n-   *  <p>\n-   *  - A new axis using {@link Indices#newAxis()}. This is used to insert a new shape=1 dimension and is\n-   *    produced using `new_axis_mask`. For example, `foo[:, ...]` where\n-   *    `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.\n-   *  <p>\n-   *  - A range `begin:end:stride` using {@link Indices#slice(Long, Long, long)}  Index.slice()}. This is used to specify how much to choose from\n-   *    a given dimension. `stride` can be any integer but 0.  `begin` is an integer\n-   *    which represents the index of the first value to select while `end` represents\n-   *    the index of the last value to select. The number of values selected in each\n-   *    dimension is `end - begin` if `stride > 0` and `begin - end` if `stride < 0`.\n-   *    `begin` and `end` can be negative where `-1` is the last element, `-2` is\n-   *    the second to last. `begin_mask` controls whether to replace the explicitly\n-   *    given `begin` with an implicit effective value of `0` if `stride > 0` and\n-   *    `-1` if `stride < 0`. `end_mask` is analogous but produces the number\n-   *    required to create the largest open interval. For example, given a shape\n-   *    `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do\n-   *    not assume this is equivalent to `foo[0:-1]` which has an effective `begin`\n-   *    and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the\n-   *    first dimension of a tensor while dropping the last two (in the original\n-   *    order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.\n-   *  <p>\n-   *  - A single index using {@link Indices#at(long)}. This is used to keep only elements that have a given\n-   *    index. For example (`foo[2, :]` on a shape `(5,6)` tensor produces a\n-   *    shape `(6,)` tensor. This is encoded in `begin` and `end` and\n-   *    `shrink_axis_mask`.\n-   *  <p>\n-   *\n-   *  <i>Requirements</i>:\n-   *    `0 != strides[i] for i in [0, m)`\n-   *    Only one ellipsis.\n-   *\n-   * @param scope current scope\n-   * @param <T> data type for {@code output()} output\n-   * @param input\n-   * @param indices The indices to slice.  See {@link Indices}.\n-   * @return a new instance of StridedSlice\n-   * @see Indices\n-   */\n-  @Endpoint(name = \"stridedSlice\")\n-  public static <T extends TType> StridedSlice<T> stridedSlice(Scope scope, Operand<T> input, TensorIndex... indices) {\n-    StridedSliceArgs args = mergeIndexes(indices);\n-    return StridedSlice.create(\n-        scope,\n-        input,\n-        Constant.vectorOf(scope, args.begin),\n-        Constant.vectorOf(scope, args.end),\n-        Constant.vectorOf(scope, args.strides),\n-        StridedSlice.beginMask(args.beginMask),\n-        StridedSlice.endMask(args.endMask),\n-        StridedSlice.ellipsisMask(args.ellipsisMask),\n-        StridedSlice.newAxisMask(args.newAxisMask),\n-        StridedSlice.shrinkAxisMask(args.shrinkAxisMask)\n-    );\n-  }\n-\n-  /**\n-   * Assign `value` to the sliced l-value reference of `ref`.\n-   *  <p>\n-   *  The values of `value` are assigned to the positions in the variable\n-   *  `ref` that are selected by the slice parameters. The slice parameters\n-   *  `begin`, `end`, `strides`, etc. work exactly as in `StridedSlice`.\n-   *  <p>\n-   *  NOTE this op currently does not support broadcasting and so `value`'s\n-   *  shape must be exactly the shape produced by the slice of `ref`.\n-   *\n-   * @param <T> data type for {@code outputRef()} output\n-   * @param scope current scope\n-   * @param ref the tensor to assign to.\n-   * @param value the value to assign.\n-   * @param indices The indices to slice.  See {@link Indices}.\n-   * @return a new instance of StridedSliceAssign\n-   * @see org.tensorflow.op.Ops#stridedSlice(Operand, TensorIndex...)\n-   */\n-  @Endpoint(name = \"stridedSliceAssign\")\n-  public static <T extends TType> StridedSliceAssign<T> stridedSliceAssign(Scope scope, Operand<T> ref, Operand<T> value, TensorIndex... indices) {\n-    StridedSliceArgs args = mergeIndexes(indices);\n-    return StridedSliceAssign.create(\n-        scope,\n-        ref,\n-        Constant.vectorOf(scope, args.begin),\n-        Constant.vectorOf(scope, args.end),\n-        Constant.vectorOf(scope, args.strides),\n-        value,\n-        StridedSliceAssign.beginMask(args.beginMask),\n-        StridedSliceAssign.endMask(args.endMask),\n-        StridedSliceAssign.ellipsisMask(args.ellipsisMask),\n-        StridedSliceAssign.newAxisMask(args.newAxisMask),\n-        StridedSliceAssign.shrinkAxisMask(args.shrinkAxisMask)\n-    );\n-  }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzEwMjEwMg==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553102102", "bodyText": "Documentation in non-generated classes should be converted from Python to Java, meaning that foo[-2::-1] and other examples like that must be converted to their Java equivalent.", "author": "karllessard", "createdAt": "2021-01-07T04:25:58Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+package org.tensorflow.op.core;\n+\n+import org.tensorflow.Operand;\n+import org.tensorflow.ndarray.index.Indices;\n+import org.tensorflow.ndarray.index.TensorIndex;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.annotation.Endpoint;\n+import org.tensorflow.op.annotation.Operator;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Helper endpoint methods for Python like indexing.\n+ *\n+ * @see org.tensorflow.ndarray.index.Indices\n+ */\n+@Operator\n+public abstract class StridedSliceHelper {\n+\n+  static class StridedSliceArgs {\n+\n+    final int[] begin;\n+    final int[] end;\n+    final int[] strides;\n+    final long beginMask;\n+    final long endMask;\n+    final long ellipsisMask;\n+    final long newAxisMask;\n+    final long shrinkAxisMask;\n+\n+    private StridedSliceArgs(int[] begin, int[] end, int[] strides, long beginMask, long endMask, long ellipsisMask,\n+        long newAxisMask, long shrinkAxisMask) {\n+      this.begin = begin;\n+      this.end = end;\n+      this.strides = strides;\n+      this.beginMask = beginMask;\n+      this.endMask = endMask;\n+      this.ellipsisMask = ellipsisMask;\n+      this.newAxisMask = newAxisMask;\n+      this.shrinkAxisMask = shrinkAxisMask;\n+    }\n+  }\n+\n+  static StridedSliceArgs mergeIndexes(TensorIndex[] indices) {\n+    int[] begin = new int[indices.length];\n+    int[] end = new int[indices.length];\n+    int[] strides = new int[indices.length];\n+    long beginMask = 0;\n+    long endMask = 0;\n+    long ellipsisMask = 0;\n+    long newAxisMask = 0;\n+    long shrinkAxisMask = 0;\n+\n+    for (int i = 0; i < indices.length; i++) {\n+      TensorIndex idx = indices[i];\n+      if (idx == null) {\n+        idx = Indices.all();\n+      }\n+\n+      begin[i] = (int) idx.begin();\n+      if(begin[i] != idx.begin())\n+        throw new IllegalArgumentException(\"Can't convert long begin value to int for index \" + idx + \": Out of bounds\");\n+\n+      end[i] = (int) idx.end();\n+      if(end[i] != idx.end())\n+        throw new IllegalArgumentException(\"Can't convert long end value to int for index \" + idx + \": Out of bounds\");\n+\n+      strides[i] = (int) idx.stride();\n+      if(strides[i] != idx.stride())\n+        throw new IllegalArgumentException(\"Can't convert long stride value to int for index \" + idx + \": Out of bounds\");\n+\n+      if (idx.beginMask()) {\n+        beginMask |= 1L << i;\n+      }\n+\n+      if (idx.endMask()) {\n+        endMask |= 1L << i;\n+      }\n+\n+      if (idx.ellipsisMask()) {\n+        if(ellipsisMask != 0)\n+          throw new IllegalArgumentException(\"Can not have two ellipsis in a slice\");\n+        ellipsisMask |= 1L << i;\n+      }\n+\n+      if (idx.newAxisMask()) {\n+        newAxisMask |= 1L << i;\n+      }\n+\n+      if (idx.shrinkAxisMask()) {\n+        shrinkAxisMask |= 1L << i;\n+      }\n+    }\n+\n+    return new StridedSliceArgs(begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);\n+  }\n+  /**\n+   * Return a strided slice from `input`.\n+   *  <p>\n+   *  The goal of this op is to produce a new tensor with a subset of\n+   *  the elements from the `n` dimensional `input` tensor. The subset is chosen using\n+   *  a sequence of `m` sparse range specifications encoded into the arguments\n+   *  of this function. Note, in some cases\n+   *  `m` could be equal to `n`, but this need not be the case. Each\n+   *  range specification entry can be one of the following:\n+   *  <p>\n+   *  - An ellipsis (...) using {@link Indices#ellipsis()}. Ellipses are used to imply zero or more\n+   *    dimensions of full-dimension selection and are produced using\n+   *    `ellipsis_mask`. For example, `foo[...]` is the identity slice.\n+   *  <p>\n+   *  - A new axis using {@link Indices#newAxis()}. This is used to insert a new shape=1 dimension and is\n+   *    produced using `new_axis_mask`. For example, `foo[:, ...]` where\n+   *    `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.\n+   *  <p>\n+   *  - A range `begin:end:stride` using {@link Indices#slice(Long, Long, long)}  Index.slice()}. This is used to specify how much to choose from\n+   *    a given dimension. `stride` can be any integer but 0.  `begin` is an integer\n+   *    which represents the index of the first value to select while `end` represents\n+   *    the index of the last value to select. The number of values selected in each\n+   *    dimension is `end - begin` if `stride > 0` and `begin - end` if `stride < 0`.\n+   *    `begin` and `end` can be negative where `-1` is the last element, `-2` is\n+   *    the second to last. `begin_mask` controls whether to replace the explicitly\n+   *    given `begin` with an implicit effective value of `0` if `stride > 0` and\n+   *    `-1` if `stride < 0`. `end_mask` is analogous but produces the number\n+   *    required to create the largest open interval. For example, given a shape\n+   *    `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do\n+   *    not assume this is equivalent to `foo[0:-1]` which has an effective `begin`\n+   *    and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the\n+   *    first dimension of a tensor while dropping the last two (in the original\n+   *    order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java b/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java\ndeleted file mode 100644\nindex 37111979..00000000\n--- a/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java\n+++ /dev/null\n\n@@ -1,214 +0,0 @@\n-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-package org.tensorflow.op.core;\n-\n-import org.tensorflow.Operand;\n-import org.tensorflow.ndarray.index.Indices;\n-import org.tensorflow.ndarray.index.TensorIndex;\n-import org.tensorflow.op.Scope;\n-import org.tensorflow.op.annotation.Endpoint;\n-import org.tensorflow.op.annotation.Operator;\n-import org.tensorflow.types.family.TType;\n-\n-/**\n- * Helper endpoint methods for Python like indexing.\n- *\n- * @see org.tensorflow.ndarray.index.Indices\n- */\n-@Operator\n-public abstract class StridedSliceHelper {\n-\n-  static class StridedSliceArgs {\n-\n-    final int[] begin;\n-    final int[] end;\n-    final int[] strides;\n-    final long beginMask;\n-    final long endMask;\n-    final long ellipsisMask;\n-    final long newAxisMask;\n-    final long shrinkAxisMask;\n-\n-    private StridedSliceArgs(int[] begin, int[] end, int[] strides, long beginMask, long endMask, long ellipsisMask,\n-        long newAxisMask, long shrinkAxisMask) {\n-      this.begin = begin;\n-      this.end = end;\n-      this.strides = strides;\n-      this.beginMask = beginMask;\n-      this.endMask = endMask;\n-      this.ellipsisMask = ellipsisMask;\n-      this.newAxisMask = newAxisMask;\n-      this.shrinkAxisMask = shrinkAxisMask;\n-    }\n-  }\n-\n-  static StridedSliceArgs mergeIndexes(TensorIndex[] indices) {\n-    int[] begin = new int[indices.length];\n-    int[] end = new int[indices.length];\n-    int[] strides = new int[indices.length];\n-    long beginMask = 0;\n-    long endMask = 0;\n-    long ellipsisMask = 0;\n-    long newAxisMask = 0;\n-    long shrinkAxisMask = 0;\n-\n-    for (int i = 0; i < indices.length; i++) {\n-      TensorIndex idx = indices[i];\n-      if (idx == null) {\n-        idx = Indices.all();\n-      }\n-\n-      begin[i] = (int) idx.begin();\n-      if(begin[i] != idx.begin())\n-        throw new IllegalArgumentException(\"Can't convert long begin value to int for index \" + idx + \": Out of bounds\");\n-\n-      end[i] = (int) idx.end();\n-      if(end[i] != idx.end())\n-        throw new IllegalArgumentException(\"Can't convert long end value to int for index \" + idx + \": Out of bounds\");\n-\n-      strides[i] = (int) idx.stride();\n-      if(strides[i] != idx.stride())\n-        throw new IllegalArgumentException(\"Can't convert long stride value to int for index \" + idx + \": Out of bounds\");\n-\n-      if (idx.beginMask()) {\n-        beginMask |= 1L << i;\n-      }\n-\n-      if (idx.endMask()) {\n-        endMask |= 1L << i;\n-      }\n-\n-      if (idx.ellipsisMask()) {\n-        if(ellipsisMask != 0)\n-          throw new IllegalArgumentException(\"Can not have two ellipsis in a slice\");\n-        ellipsisMask |= 1L << i;\n-      }\n-\n-      if (idx.newAxisMask()) {\n-        newAxisMask |= 1L << i;\n-      }\n-\n-      if (idx.shrinkAxisMask()) {\n-        shrinkAxisMask |= 1L << i;\n-      }\n-    }\n-\n-    return new StridedSliceArgs(begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);\n-  }\n-  /**\n-   * Return a strided slice from `input`.\n-   *  <p>\n-   *  The goal of this op is to produce a new tensor with a subset of\n-   *  the elements from the `n` dimensional `input` tensor. The subset is chosen using\n-   *  a sequence of `m` sparse range specifications encoded into the arguments\n-   *  of this function. Note, in some cases\n-   *  `m` could be equal to `n`, but this need not be the case. Each\n-   *  range specification entry can be one of the following:\n-   *  <p>\n-   *  - An ellipsis (...) using {@link Indices#ellipsis()}. Ellipses are used to imply zero or more\n-   *    dimensions of full-dimension selection and are produced using\n-   *    `ellipsis_mask`. For example, `foo[...]` is the identity slice.\n-   *  <p>\n-   *  - A new axis using {@link Indices#newAxis()}. This is used to insert a new shape=1 dimension and is\n-   *    produced using `new_axis_mask`. For example, `foo[:, ...]` where\n-   *    `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.\n-   *  <p>\n-   *  - A range `begin:end:stride` using {@link Indices#slice(Long, Long, long)}  Index.slice()}. This is used to specify how much to choose from\n-   *    a given dimension. `stride` can be any integer but 0.  `begin` is an integer\n-   *    which represents the index of the first value to select while `end` represents\n-   *    the index of the last value to select. The number of values selected in each\n-   *    dimension is `end - begin` if `stride > 0` and `begin - end` if `stride < 0`.\n-   *    `begin` and `end` can be negative where `-1` is the last element, `-2` is\n-   *    the second to last. `begin_mask` controls whether to replace the explicitly\n-   *    given `begin` with an implicit effective value of `0` if `stride > 0` and\n-   *    `-1` if `stride < 0`. `end_mask` is analogous but produces the number\n-   *    required to create the largest open interval. For example, given a shape\n-   *    `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do\n-   *    not assume this is equivalent to `foo[0:-1]` which has an effective `begin`\n-   *    and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the\n-   *    first dimension of a tensor while dropping the last two (in the original\n-   *    order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.\n-   *  <p>\n-   *  - A single index using {@link Indices#at(long)}. This is used to keep only elements that have a given\n-   *    index. For example (`foo[2, :]` on a shape `(5,6)` tensor produces a\n-   *    shape `(6,)` tensor. This is encoded in `begin` and `end` and\n-   *    `shrink_axis_mask`.\n-   *  <p>\n-   *\n-   *  <i>Requirements</i>:\n-   *    `0 != strides[i] for i in [0, m)`\n-   *    Only one ellipsis.\n-   *\n-   * @param scope current scope\n-   * @param <T> data type for {@code output()} output\n-   * @param input\n-   * @param indices The indices to slice.  See {@link Indices}.\n-   * @return a new instance of StridedSlice\n-   * @see Indices\n-   */\n-  @Endpoint(name = \"stridedSlice\")\n-  public static <T extends TType> StridedSlice<T> stridedSlice(Scope scope, Operand<T> input, TensorIndex... indices) {\n-    StridedSliceArgs args = mergeIndexes(indices);\n-    return StridedSlice.create(\n-        scope,\n-        input,\n-        Constant.vectorOf(scope, args.begin),\n-        Constant.vectorOf(scope, args.end),\n-        Constant.vectorOf(scope, args.strides),\n-        StridedSlice.beginMask(args.beginMask),\n-        StridedSlice.endMask(args.endMask),\n-        StridedSlice.ellipsisMask(args.ellipsisMask),\n-        StridedSlice.newAxisMask(args.newAxisMask),\n-        StridedSlice.shrinkAxisMask(args.shrinkAxisMask)\n-    );\n-  }\n-\n-  /**\n-   * Assign `value` to the sliced l-value reference of `ref`.\n-   *  <p>\n-   *  The values of `value` are assigned to the positions in the variable\n-   *  `ref` that are selected by the slice parameters. The slice parameters\n-   *  `begin`, `end`, `strides`, etc. work exactly as in `StridedSlice`.\n-   *  <p>\n-   *  NOTE this op currently does not support broadcasting and so `value`'s\n-   *  shape must be exactly the shape produced by the slice of `ref`.\n-   *\n-   * @param <T> data type for {@code outputRef()} output\n-   * @param scope current scope\n-   * @param ref the tensor to assign to.\n-   * @param value the value to assign.\n-   * @param indices The indices to slice.  See {@link Indices}.\n-   * @return a new instance of StridedSliceAssign\n-   * @see org.tensorflow.op.Ops#stridedSlice(Operand, TensorIndex...)\n-   */\n-  @Endpoint(name = \"stridedSliceAssign\")\n-  public static <T extends TType> StridedSliceAssign<T> stridedSliceAssign(Scope scope, Operand<T> ref, Operand<T> value, TensorIndex... indices) {\n-    StridedSliceArgs args = mergeIndexes(indices);\n-    return StridedSliceAssign.create(\n-        scope,\n-        ref,\n-        Constant.vectorOf(scope, args.begin),\n-        Constant.vectorOf(scope, args.end),\n-        Constant.vectorOf(scope, args.strides),\n-        value,\n-        StridedSliceAssign.beginMask(args.beginMask),\n-        StridedSliceAssign.endMask(args.endMask),\n-        StridedSliceAssign.ellipsisMask(args.ellipsisMask),\n-        StridedSliceAssign.newAxisMask(args.newAxisMask),\n-        StridedSliceAssign.shrinkAxisMask(args.shrinkAxisMask)\n-    );\n-  }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzEwMjY2OA==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r553102668", "bodyText": "Please add braces around single-line statements", "author": "karllessard", "createdAt": "2021-01-07T04:28:32Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+package org.tensorflow.op.core;\n+\n+import org.tensorflow.Operand;\n+import org.tensorflow.ndarray.index.Indices;\n+import org.tensorflow.ndarray.index.TensorIndex;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.annotation.Endpoint;\n+import org.tensorflow.op.annotation.Operator;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Helper endpoint methods for Python like indexing.\n+ *\n+ * @see org.tensorflow.ndarray.index.Indices\n+ */\n+@Operator\n+public abstract class StridedSliceHelper {\n+\n+  static class StridedSliceArgs {\n+\n+    final int[] begin;\n+    final int[] end;\n+    final int[] strides;\n+    final long beginMask;\n+    final long endMask;\n+    final long ellipsisMask;\n+    final long newAxisMask;\n+    final long shrinkAxisMask;\n+\n+    private StridedSliceArgs(int[] begin, int[] end, int[] strides, long beginMask, long endMask, long ellipsisMask,\n+        long newAxisMask, long shrinkAxisMask) {\n+      this.begin = begin;\n+      this.end = end;\n+      this.strides = strides;\n+      this.beginMask = beginMask;\n+      this.endMask = endMask;\n+      this.ellipsisMask = ellipsisMask;\n+      this.newAxisMask = newAxisMask;\n+      this.shrinkAxisMask = shrinkAxisMask;\n+    }\n+  }\n+\n+  static StridedSliceArgs mergeIndexes(TensorIndex[] indices) {\n+    int[] begin = new int[indices.length];\n+    int[] end = new int[indices.length];\n+    int[] strides = new int[indices.length];\n+    long beginMask = 0;\n+    long endMask = 0;\n+    long ellipsisMask = 0;\n+    long newAxisMask = 0;\n+    long shrinkAxisMask = 0;\n+\n+    for (int i = 0; i < indices.length; i++) {\n+      TensorIndex idx = indices[i];\n+      if (idx == null) {\n+        idx = Indices.all();\n+      }\n+\n+      begin[i] = (int) idx.begin();\n+      if(begin[i] != idx.begin())\n+        throw new IllegalArgumentException(\"Can't convert long begin value to int for index \" + idx + \": Out of bounds\");", "originalCommit": "713fb4128e8cdae9daf59b1108086c284ab235af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "chunk": "diff --git a/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java b/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java\ndeleted file mode 100644\nindex 37111979..00000000\n--- a/tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/StridedSliceHelper.java\n+++ /dev/null\n\n@@ -1,214 +0,0 @@\n-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-package org.tensorflow.op.core;\n-\n-import org.tensorflow.Operand;\n-import org.tensorflow.ndarray.index.Indices;\n-import org.tensorflow.ndarray.index.TensorIndex;\n-import org.tensorflow.op.Scope;\n-import org.tensorflow.op.annotation.Endpoint;\n-import org.tensorflow.op.annotation.Operator;\n-import org.tensorflow.types.family.TType;\n-\n-/**\n- * Helper endpoint methods for Python like indexing.\n- *\n- * @see org.tensorflow.ndarray.index.Indices\n- */\n-@Operator\n-public abstract class StridedSliceHelper {\n-\n-  static class StridedSliceArgs {\n-\n-    final int[] begin;\n-    final int[] end;\n-    final int[] strides;\n-    final long beginMask;\n-    final long endMask;\n-    final long ellipsisMask;\n-    final long newAxisMask;\n-    final long shrinkAxisMask;\n-\n-    private StridedSliceArgs(int[] begin, int[] end, int[] strides, long beginMask, long endMask, long ellipsisMask,\n-        long newAxisMask, long shrinkAxisMask) {\n-      this.begin = begin;\n-      this.end = end;\n-      this.strides = strides;\n-      this.beginMask = beginMask;\n-      this.endMask = endMask;\n-      this.ellipsisMask = ellipsisMask;\n-      this.newAxisMask = newAxisMask;\n-      this.shrinkAxisMask = shrinkAxisMask;\n-    }\n-  }\n-\n-  static StridedSliceArgs mergeIndexes(TensorIndex[] indices) {\n-    int[] begin = new int[indices.length];\n-    int[] end = new int[indices.length];\n-    int[] strides = new int[indices.length];\n-    long beginMask = 0;\n-    long endMask = 0;\n-    long ellipsisMask = 0;\n-    long newAxisMask = 0;\n-    long shrinkAxisMask = 0;\n-\n-    for (int i = 0; i < indices.length; i++) {\n-      TensorIndex idx = indices[i];\n-      if (idx == null) {\n-        idx = Indices.all();\n-      }\n-\n-      begin[i] = (int) idx.begin();\n-      if(begin[i] != idx.begin())\n-        throw new IllegalArgumentException(\"Can't convert long begin value to int for index \" + idx + \": Out of bounds\");\n-\n-      end[i] = (int) idx.end();\n-      if(end[i] != idx.end())\n-        throw new IllegalArgumentException(\"Can't convert long end value to int for index \" + idx + \": Out of bounds\");\n-\n-      strides[i] = (int) idx.stride();\n-      if(strides[i] != idx.stride())\n-        throw new IllegalArgumentException(\"Can't convert long stride value to int for index \" + idx + \": Out of bounds\");\n-\n-      if (idx.beginMask()) {\n-        beginMask |= 1L << i;\n-      }\n-\n-      if (idx.endMask()) {\n-        endMask |= 1L << i;\n-      }\n-\n-      if (idx.ellipsisMask()) {\n-        if(ellipsisMask != 0)\n-          throw new IllegalArgumentException(\"Can not have two ellipsis in a slice\");\n-        ellipsisMask |= 1L << i;\n-      }\n-\n-      if (idx.newAxisMask()) {\n-        newAxisMask |= 1L << i;\n-      }\n-\n-      if (idx.shrinkAxisMask()) {\n-        shrinkAxisMask |= 1L << i;\n-      }\n-    }\n-\n-    return new StridedSliceArgs(begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);\n-  }\n-  /**\n-   * Return a strided slice from `input`.\n-   *  <p>\n-   *  The goal of this op is to produce a new tensor with a subset of\n-   *  the elements from the `n` dimensional `input` tensor. The subset is chosen using\n-   *  a sequence of `m` sparse range specifications encoded into the arguments\n-   *  of this function. Note, in some cases\n-   *  `m` could be equal to `n`, but this need not be the case. Each\n-   *  range specification entry can be one of the following:\n-   *  <p>\n-   *  - An ellipsis (...) using {@link Indices#ellipsis()}. Ellipses are used to imply zero or more\n-   *    dimensions of full-dimension selection and are produced using\n-   *    `ellipsis_mask`. For example, `foo[...]` is the identity slice.\n-   *  <p>\n-   *  - A new axis using {@link Indices#newAxis()}. This is used to insert a new shape=1 dimension and is\n-   *    produced using `new_axis_mask`. For example, `foo[:, ...]` where\n-   *    `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.\n-   *  <p>\n-   *  - A range `begin:end:stride` using {@link Indices#slice(Long, Long, long)}  Index.slice()}. This is used to specify how much to choose from\n-   *    a given dimension. `stride` can be any integer but 0.  `begin` is an integer\n-   *    which represents the index of the first value to select while `end` represents\n-   *    the index of the last value to select. The number of values selected in each\n-   *    dimension is `end - begin` if `stride > 0` and `begin - end` if `stride < 0`.\n-   *    `begin` and `end` can be negative where `-1` is the last element, `-2` is\n-   *    the second to last. `begin_mask` controls whether to replace the explicitly\n-   *    given `begin` with an implicit effective value of `0` if `stride > 0` and\n-   *    `-1` if `stride < 0`. `end_mask` is analogous but produces the number\n-   *    required to create the largest open interval. For example, given a shape\n-   *    `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do\n-   *    not assume this is equivalent to `foo[0:-1]` which has an effective `begin`\n-   *    and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the\n-   *    first dimension of a tensor while dropping the last two (in the original\n-   *    order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.\n-   *  <p>\n-   *  - A single index using {@link Indices#at(long)}. This is used to keep only elements that have a given\n-   *    index. For example (`foo[2, :]` on a shape `(5,6)` tensor produces a\n-   *    shape `(6,)` tensor. This is encoded in `begin` and `end` and\n-   *    `shrink_axis_mask`.\n-   *  <p>\n-   *\n-   *  <i>Requirements</i>:\n-   *    `0 != strides[i] for i in [0, m)`\n-   *    Only one ellipsis.\n-   *\n-   * @param scope current scope\n-   * @param <T> data type for {@code output()} output\n-   * @param input\n-   * @param indices The indices to slice.  See {@link Indices}.\n-   * @return a new instance of StridedSlice\n-   * @see Indices\n-   */\n-  @Endpoint(name = \"stridedSlice\")\n-  public static <T extends TType> StridedSlice<T> stridedSlice(Scope scope, Operand<T> input, TensorIndex... indices) {\n-    StridedSliceArgs args = mergeIndexes(indices);\n-    return StridedSlice.create(\n-        scope,\n-        input,\n-        Constant.vectorOf(scope, args.begin),\n-        Constant.vectorOf(scope, args.end),\n-        Constant.vectorOf(scope, args.strides),\n-        StridedSlice.beginMask(args.beginMask),\n-        StridedSlice.endMask(args.endMask),\n-        StridedSlice.ellipsisMask(args.ellipsisMask),\n-        StridedSlice.newAxisMask(args.newAxisMask),\n-        StridedSlice.shrinkAxisMask(args.shrinkAxisMask)\n-    );\n-  }\n-\n-  /**\n-   * Assign `value` to the sliced l-value reference of `ref`.\n-   *  <p>\n-   *  The values of `value` are assigned to the positions in the variable\n-   *  `ref` that are selected by the slice parameters. The slice parameters\n-   *  `begin`, `end`, `strides`, etc. work exactly as in `StridedSlice`.\n-   *  <p>\n-   *  NOTE this op currently does not support broadcasting and so `value`'s\n-   *  shape must be exactly the shape produced by the slice of `ref`.\n-   *\n-   * @param <T> data type for {@code outputRef()} output\n-   * @param scope current scope\n-   * @param ref the tensor to assign to.\n-   * @param value the value to assign.\n-   * @param indices The indices to slice.  See {@link Indices}.\n-   * @return a new instance of StridedSliceAssign\n-   * @see org.tensorflow.op.Ops#stridedSlice(Operand, TensorIndex...)\n-   */\n-  @Endpoint(name = \"stridedSliceAssign\")\n-  public static <T extends TType> StridedSliceAssign<T> stridedSliceAssign(Scope scope, Operand<T> ref, Operand<T> value, TensorIndex... indices) {\n-    StridedSliceArgs args = mergeIndexes(indices);\n-    return StridedSliceAssign.create(\n-        scope,\n-        ref,\n-        Constant.vectorOf(scope, args.begin),\n-        Constant.vectorOf(scope, args.end),\n-        Constant.vectorOf(scope, args.strides),\n-        value,\n-        StridedSliceAssign.beginMask(args.beginMask),\n-        StridedSliceAssign.endMask(args.endMask),\n-        StridedSliceAssign.ellipsisMask(args.ellipsisMask),\n-        StridedSliceAssign.newAxisMask(args.newAxisMask),\n-        StridedSliceAssign.shrinkAxisMask(args.shrinkAxisMask)\n-    );\n-  }\n-\n-}\n"}}, {"oid": "a1ab52fe15c5a9f20969aff5dce0060f6831523d", "url": "https://github.com/tensorflow/java/commit/a1ab52fe15c5a9f20969aff5dce0060f6831523d", "message": "Start of Indexing api\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:35Z", "type": "commit"}, {"oid": "74ba9b0f384f716989846bd993a831615cadba99", "url": "https://github.com/tensorflow/java/commit/74ba9b0f384f716989846bd993a831615cadba99", "message": "Add javadoc\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:35Z", "type": "commit"}, {"oid": "1c078ef324739f8b7c1f022e0b1f077ebdaa5afb", "url": "https://github.com/tensorflow/java/commit/1c078ef324739f8b7c1f022e0b1f077ebdaa5afb", "message": "codegen\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:35Z", "type": "commit"}, {"oid": "3abac560a6b9c748547083b925d03b1eb692bed5", "url": "https://github.com/tensorflow/java/commit/3abac560a6b9c748547083b925d03b1eb692bed5", "message": "op test\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:35Z", "type": "commit"}, {"oid": "659fd686f6294c8a2ae6ece0988ef76a4f2b7476", "url": "https://github.com/tensorflow/java/commit/659fd686f6294c8a2ae6ece0988ef76a4f2b7476", "message": "fix test\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:35Z", "type": "commit"}, {"oid": "73e88905acae5e4819714c8af5541cb71d940a4a", "url": "https://github.com/tensorflow/java/commit/73e88905acae5e4819714c8af5541cb71d940a4a", "message": "explain expected shape, fix slice input\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:36Z", "type": "commit"}, {"oid": "57dc61111ff6ffc3083ebc37bea6f323c7fc189c", "url": "https://github.com/tensorflow/java/commit/57dc61111ff6ffc3083ebc37bea6f323c7fc189c", "message": "add a final\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:36Z", "type": "commit"}, {"oid": "0f5211dbd80b57f5b6498a786170b04ecde6eec6", "url": "https://github.com/tensorflow/java/commit/0f5211dbd80b57f5b6498a786170b04ecde6eec6", "message": "fix constructor visibility\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:36Z", "type": "commit"}, {"oid": "1c356152ae90e9aad1a00aabc67bc3682ef816ad", "url": "https://github.com/tensorflow/java/commit/1c356152ae90e9aad1a00aabc67bc3682ef816ad", "message": "fix range check\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:36Z", "type": "commit"}, {"oid": "e446f3a1d1bdeb32b4643b8af8ecb237e546bee6", "url": "https://github.com/tensorflow/java/commit/e446f3a1d1bdeb32b4643b8af8ecb237e546bee6", "message": "start of adapting ndarray indexing\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:36Z", "type": "commit"}, {"oid": "0e7aa1768cc9257632cce52447869fd33612c0cf", "url": "https://github.com/tensorflow/java/commit/0e7aa1768cc9257632cce52447869fd33612c0cf", "message": "remove old Index class\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:37Z", "type": "commit"}, {"oid": "6383df43874b029b77673d8a36707150e130e7e9", "url": "https://github.com/tensorflow/java/commit/6383df43874b029b77673d8a36707150e130e7e9", "message": "test fix for rebase\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:37Z", "type": "commit"}, {"oid": "9b1da7713b0e5cf7740f0b755c6c9b41a3eec8fd", "url": "https://github.com/tensorflow/java/commit/9b1da7713b0e5cf7740f0b755c6c9b41a3eec8fd", "message": "test fix for rebase\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:37Z", "type": "commit"}, {"oid": "f2c49661e70122fdd2b90741575844d3743905b4", "url": "https://github.com/tensorflow/java/commit/f2c49661e70122fdd2b90741575844d3743905b4", "message": "Out of bounds warnings\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:37Z", "type": "commit"}, {"oid": "35b7aaaac789948465f1b63abd63544ae1523efd", "url": "https://github.com/tensorflow/java/commit/35b7aaaac789948465f1b63abd63544ae1523efd", "message": "Remove extra classes, plus a few fixes\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:37Z", "type": "commit"}, {"oid": "f496aee8264120fa7f7cc5688f541bbb937caf6e", "url": "https://github.com/tensorflow/java/commit/f496aee8264120fa7f7cc5688f541bbb937caf6e", "message": "Tests\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:38Z", "type": "commit"}, {"oid": "4f58b193fa124b9d67a3d76c79633b6820f224a4", "url": "https://github.com/tensorflow/java/commit/4f58b193fa124b9d67a3d76c79633b6820f224a4", "message": "ToString methods\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:38Z", "type": "commit"}, {"oid": "95909616d49f766ec66ef01f6fed8bb27f2cd508", "url": "https://github.com/tensorflow/java/commit/95909616d49f766ec66ef01f6fed8bb27f2cd508", "message": "Cleanup and formatting\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:38Z", "type": "commit"}, {"oid": "090cfb9c3a987426c5d641fc955cf19427442d87", "url": "https://github.com/tensorflow/java/commit/090cfb9c3a987426c5d641fc955cf19427442d87", "message": "Cleanup and formatting\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:38Z", "type": "commit"}, {"oid": "14e3c549fa6037f1ff934050feb6099b6f75772d", "url": "https://github.com/tensorflow/java/commit/14e3c549fa6037f1ff934050feb6099b6f75772d", "message": "Javadocs cleanup, new names\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:39Z", "type": "commit"}, {"oid": "8636f90954e23139c0c69d31c296e34f94eaf9c6", "url": "https://github.com/tensorflow/java/commit/8636f90954e23139c0c69d31c296e34f94eaf9c6", "message": "Split Slice into nullability cases\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:39Z", "type": "commit"}, {"oid": "fffdabdfd095a7a6e81afca9d066d1ba0c7eacfe", "url": "https://github.com/tensorflow/java/commit/fffdabdfd095a7a6e81afca9d066d1ba0c7eacfe", "message": "Change benchmark to fork once by default\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:39Z", "type": "commit"}, {"oid": "fffdabdfd095a7a6e81afca9d066d1ba0c7eacfe", "url": "https://github.com/tensorflow/java/commit/fffdabdfd095a7a6e81afca9d066d1ba0c7eacfe", "message": "Change benchmark to fork once by default\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-08T22:10:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzM5MDMxMg==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r563390312", "bodyText": "I don't think we need to mention for Tensor conversion in the methods below, as long as the documentation says what the method returns, it can be of any use after that.\nNow for tensorSupport(), what about something more generic like hasBoundaries()?", "author": "karllessard", "createdAt": "2021-01-24T22:08:13Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/index/Index.java", "diffHunk": "@@ -74,4 +70,61 @@ default Dimension apply(Dimension dim) {\n   default boolean isPoint() {\n     return false;\n   }\n+\n+  /**\n+   * Returns true if this index is a new axis, adding a dimension of size 1\n+   */\n+  default boolean isNewAxis() {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns true if this index is an ellipsis, expanding to take as many dimensions as possible (and applying all() to\n+   * them)\n+   */\n+  default boolean isEllipsis() {\n+    return false;\n+  }\n+\n+  /**\n+   * Get whether the Index supports Tensor conversion.", "originalCommit": "fffdabdfd095a7a6e81afca9d066d1ba0c7eacfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzM5NzI4Mg==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r563397282", "bodyText": "Agreed in theory, but I don't like hasBoundaries, because to me that sounds like it would exclude all and sliceTo, etc.  The only things that are excluded are Hyperslab and Sequence.  I went with tensorSupport because I couldn't think of anything better.\nMaybe use \"strided slice conversion\" rather than \"tensor conversion\"?  In theory, it would apply to any library that uses strided slicing.  Or specifiesBoundaries.", "author": "rnett", "createdAt": "2021-01-24T22:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzM5MDMxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQwMzA3MQ==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r563403071", "bodyText": "ok, so let's call it \"strided slice conversion\" and name this method isStridedSlicingCompliant()?", "author": "karllessard", "createdAt": "2021-01-24T23:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzM5MDMxMg=="}], "type": "inlineReview", "revised_code": {"commit": "6e0e86fa7c5f068bb56f143f8fe7da2bfb0d2830", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/index/Index.java b/ndarray/src/main/java/org/tensorflow/ndarray/index/Index.java\nindex 028405ce..617ca4d4 100644\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/index/Index.java\n+++ b/ndarray/src/main/java/org/tensorflow/ndarray/index/Index.java\n\n@@ -87,42 +87,43 @@ public interface Index {\n   }\n \n   /**\n-   * Get whether the Index supports Tensor conversion.\n+   * Get whether the Index supports strided slice style indexing (using start, end, stride, and flags, i.e. <a\n+   * href=\"https://www.tensorflow.org/api_docs/python/tf/strided_slice\">TensorFlow's</a>).\n    */\n-  default boolean tensorSupport() {\n+  default boolean isStridedSlicingCompliant() {\n     return true;\n   }\n \n   /**\n-   * Get the start of the index, for Tensor conversion.\n+   * Get the start of the index, for strided slice style indexing.\n    */\n   default long begin() {\n     return 0;\n   }\n \n   /**\n-   * Get the end of the index, for Tensor conversion.\n+   * Get the end of the index, strided slice style indexing.\n    */\n   default long end() {\n     return 0;\n   }\n \n   /**\n-   * Get the stride of the index, for Tensor conversion.\n+   * Get the stride of the index, for strided slice style indexing.\n    */\n   default long stride() {\n     return 1;\n   }\n \n   /**\n-   * Get whether the Index should start at the beginning of the dimension, for Tensor conversion.\n+   * Get whether the Index should start at the beginning of the dimension, for strided slice style indexing.\n    */\n   default boolean beginMask() {\n     return false;\n   }\n \n   /**\n-   * Get whether the Index should end at the beginning of the dimension, for Tensor conversion.\n+   * Get whether the Index should end at the beginning of the dimension, for strided slice style indexing.\n    */\n   default boolean endMask() {\n     return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzM5MzEwMQ==", "url": "https://github.com/tensorflow/java/pull/166#discussion_r563393101", "bodyText": "Like we've discussed, we probably just want to go with one name, I'm ok with any (we don't need to be too strict to follow what the names in Python so expand is fine if that's what you prefer).", "author": "karllessard", "createdAt": "2021-01-24T22:11:52Z", "path": "ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java", "diffHunk": "@@ -199,21 +265,109 @@ public static Index range(long start, long end) {\n    * @return index\n    */\n   public static Index flip() {\n-    return Flip.INSTANCE;\n+    return slice(null, null, -1);\n   }\n-  \n+\n   /**\n-   * An index that returns elements according to an hyperslab defined by {@code start},\n-   * {@code stride}, {@code count}, {@code block}. See {@link Hyperslab}.\n-   * \n+   * An index that returns elements according to an hyperslab defined by {@code start}, {@code stride}, {@code count},\n+   * {@code block}. See {@link Hyperslab}.\n+   *\n    * @param start Starting location for the hyperslab.\n    * @param stride The number of elements to separate each element or block to be selected.\n    * @param count The number of elements or blocks to select along the dimension.\n    * @param block The size of the block selected from the dimension.\n-   * \n    * @return index\n    */\n   public static Index hyperslab(long start, long stride, long count, long block) {\n     return new Hyperslab(start, stride, count, block);\n   }\n+\n+  /**\n+   * An index that inserts a new dimension of size 1 into the resulting array.\n+   *\n+   * @return index\n+   */\n+  public static Index newAxis() {\n+    return NewAxis.INSTANCE;\n+  }\n+\n+  /**\n+   * An index that expands to fill all available source dimensions. Works the same as Python's {@code ...}.\n+   *\n+   * @return index\n+   * @see #expand()\n+   */\n+  public static Index ellipsis() {\n+    return Ellipsis.INSTANCE;\n+  }\n+\n+  /**\n+   * An index that expands to fill all available source dimensions. Works the same as Python's {@code ...}.\n+   *\n+   * @return index\n+   */\n+  public static Index expand() {\n+    return ellipsis();", "originalCommit": "fffdabdfd095a7a6e81afca9d066d1ba0c7eacfe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3d6c2436f6cb152b9d569f64180e949f07d1120a", "chunk": "diff --git a/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java b/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java\nindex 555d7c1a..346ab705 100644\n--- a/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java\n+++ b/ndarray/src/main/java/org/tensorflow/ndarray/index/Indices.java\n\n@@ -295,21 +295,11 @@ public final class Indices {\n    * An index that expands to fill all available source dimensions. Works the same as Python's {@code ...}.\n    *\n    * @return index\n-   * @see #expand()\n    */\n   public static Index ellipsis() {\n     return Ellipsis.INSTANCE;\n   }\n \n-  /**\n-   * An index that expands to fill all available source dimensions. Works the same as Python's {@code ...}.\n-   *\n-   * @return index\n-   */\n-  public static Index expand() {\n-    return ellipsis();\n-  }\n-\n   /**\n    * An index that returns elements between {@code start} and {@code end}. If {@code start} or {@code end} is {@code\n    * null}, starts or ends at the beginning or the end, respectively.\n"}}, {"oid": "3d6c2436f6cb152b9d569f64180e949f07d1120a", "url": "https://github.com/tensorflow/java/commit/3d6c2436f6cb152b9d569f64180e949f07d1120a", "message": "Remove expand\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-24T22:49:58Z", "type": "commit"}, {"oid": "6e0e86fa7c5f068bb56f143f8fe7da2bfb0d2830", "url": "https://github.com/tensorflow/java/commit/6e0e86fa7c5f068bb56f143f8fe7da2bfb0d2830", "message": "remove tensor references\n\nSigned-off-by: Ryan Nett <rnett@calpoly.edu>", "committedDate": "2021-01-25T01:50:26Z", "type": "commit"}]}