{"pr_number": 4398, "pr_title": "feat: Implement pull query routing to standbys if active is down", "pr_createdAt": "2020-01-28T21:45:05Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4398", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDgzMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372560830", "bodyText": "Is this an outstanding todo?", "author": "big-andy-coates", "createdAt": "2020-01-29T18:40:22Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -165,12 +165,25 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n+  // Shall we remove this config?", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NDUxNQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374494515", "bodyText": "If its not used anymore, yes. lets remove it", "author": "vinothchandar", "createdAt": "2020-02-04T06:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDgzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgyMDQ5NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374820494", "bodyText": "REmoved", "author": "vpapavas", "createdAt": "2020-02-04T17:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDgzMA=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\nindex 1bb5bcec9d..531380bb81 100644\n--- a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n+++ b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n\n@@ -165,16 +167,8 @@ public class KsqlConfig extends AbstractConfig {\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n-  // Shall we remove this config?\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n-      \"ksql.query.pull.routing.timeout.ms\";\n-  public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n-      + \"when waiting for the lookup of the owner of a row key\";\n-\n-\n   public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n-      \"ksql.query.pull.enable.stale.reads\";\n+        \"ksql.query.pull.enable.stale.reads\";\n   private static final String KSQL_QUERY_PULL_ENABLE_STALE_READS_DOC =\n       \"Config to enable/disable forwarding pull queries to standby hosts when the active is dead. \"\n           + \"Effectively, the accuracy of pull queries is sacrificed for higher availability. \"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MTk0MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372561940", "bodyText": "Might be worth briefly mentioning how accuracy is sacrificed when using standbys, i.e. call out that standbys are updated asynchronously from the changelog topic, which the primary produces to on its write path.", "author": "big-andy-coates", "createdAt": "2020-01-29T18:42:36Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -165,12 +165,25 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n+  // Shall we remove this config?\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n       \"ksql.query.pull.routing.timeout.ms\";\n   public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n       + \"when waiting for the lookup of the owner of a row key\";\n \n+\n+  public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n+      \"ksql.query.pull.enable.stale.reads\";\n+  private static final String KSQL_QUERY_PULL_ENABLE_STALE_READS_DOC =\n+      \"Config to enable/disable forwarding pull queries to standby hosts when the active is dead. \"\n+          + \"Effectively, the accuracy of pull queries is sacrificed for higher availability. \"\n+          + \"Possible values are \\\"true\\\", \\\"false\\\". Setting to \\\"true\\\" guarantees high \"\n+          + \"availability for pull queries. If set to \\\"false\\\", pull queries will fail when\"\n+          + \"the active is dead and until a new active is elected. Default value is \\\"false\\\". \";", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\nindex 1bb5bcec9d..531380bb81 100644\n--- a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n+++ b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n\n@@ -165,16 +167,8 @@ public class KsqlConfig extends AbstractConfig {\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n-  // Shall we remove this config?\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n-      \"ksql.query.pull.routing.timeout.ms\";\n-  public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n-      + \"when waiting for the lookup of the owner of a row key\";\n-\n-\n   public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n-      \"ksql.query.pull.enable.stale.reads\";\n+        \"ksql.query.pull.enable.stale.reads\";\n   private static final String KSQL_QUERY_PULL_ENABLE_STALE_READS_DOC =\n       \"Config to enable/disable forwarding pull queries to standby hosts when the active is dead. \"\n           + \"Effectively, the accuracy of pull queries is sacrificed for higher availability. \"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MjM4NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372562384", "bodyText": "Personally, I'd inline this. Nothing else references it. But not biggie either way.", "author": "big-andy-coates", "createdAt": "2020-01-29T18:43:25Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -165,12 +165,25 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n+  // Shall we remove this config?\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n       \"ksql.query.pull.routing.timeout.ms\";\n   public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n       + \"when waiting for the lookup of the owner of a row key\";\n \n+\n+  public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n+      \"ksql.query.pull.enable.stale.reads\";\n+  private static final String KSQL_QUERY_PULL_ENABLE_STALE_READS_DOC =\n+      \"Config to enable/disable forwarding pull queries to standby hosts when the active is dead. \"\n+          + \"Effectively, the accuracy of pull queries is sacrificed for higher availability. \"\n+          + \"Possible values are \\\"true\\\", \\\"false\\\". Setting to \\\"true\\\" guarantees high \"\n+          + \"availability for pull queries. If set to \\\"false\\\", pull queries will fail when\"\n+          + \"the active is dead and until a new active is elected. Default value is \\\"false\\\". \";\n+  public static final boolean KSQL_QUERY_PULL_ENABLE_STALE_READS_DEFAULT = false;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2MDY2MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373560660", "bodyText": "I actually like having it named because otherwise it's hard to know what it stands for in the method call", "author": "agavra", "createdAt": "2020-01-31T16:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MjM4NA=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\nindex 1bb5bcec9d..531380bb81 100644\n--- a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n+++ b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n\n@@ -165,16 +167,8 @@ public class KsqlConfig extends AbstractConfig {\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n-  // Shall we remove this config?\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n-      \"ksql.query.pull.routing.timeout.ms\";\n-  public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n-      + \"when waiting for the lookup of the owner of a row key\";\n-\n-\n   public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n-      \"ksql.query.pull.enable.stale.reads\";\n+        \"ksql.query.pull.enable.stale.reads\";\n   private static final String KSQL_QUERY_PULL_ENABLE_STALE_READS_DOC =\n       \"Config to enable/disable forwarding pull queries to standby hosts when the active is dead. \"\n           + \"Effectively, the accuracy of pull queries is sacrificed for higher availability. \"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MjgwOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372562808", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Send a request to remote Ksql server to inquire to inquire about which state stores the\n          \n          \n            \n               * Send a request to remote Ksql server to inquire about which state stores the", "author": "big-andy-coates", "createdAt": "2020-01-29T18:44:16Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java", "diffHunk": "@@ -55,4 +56,12 @@ void makeAsyncHeartbeatRequest(\n    * @return response containing the cluster status.\n    */\n   RestResponse<ClusterStatusResponse> makeClusterStatusRequest(URI serverEndPoint);\n+\n+  /**\n+   * Send a request to remote Ksql server to inquire to inquire about which state stores the", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java b/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java\nindex bd816d7619..bf60e203fd 100644\n--- a/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java\n+++ b/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java\n\n@@ -58,10 +58,17 @@ public interface SimpleKsqlClient {\n   RestResponse<ClusterStatusResponse> makeClusterStatusRequest(URI serverEndPoint);\n \n   /**\n+<<<<<<< HEAD\n+   * Send lag information to remote Ksql server.\n+=======\n    * Send a request to remote Ksql server to inquire to inquire about which state stores the\n    * remote server maintains as an active and standby.\n+>>>>>>> 9247ecc7c... fixed broken test after kafka merge\n    * @param serverEndPoint the remote destination.\n-   * @return response containing the state stores for which the remote host is active and standby.\n+   * @param lagReportingMessage the host lag data\n    */\n-  RestResponse<ActiveStandbyResponse> makeActiveStandbyRequest(URI serverEndPoint);\n+  void makeAsyncLagReportRequest(\n+      URI serverEndPoint,\n+      LagReportingMessage lagReportingMessage\n+  );\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NDIyMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372564221", "bodyText": "Personally, I'd leave this called hostsStatus.  Generally, avoid naming things by their type or the types attributes, e.g. avoid immutable, final List, Map etc in the name of things.\nThis is especially true in this case as the value the field points to can be changed!  Sure, the map is immutable, but the field isn't.   The map's HostValue type is also currently mutable.\nIn short, this field is not immutable in any way, shape, or form ;)\nIf HostInfo immutable? It probably should be if it's going to be the key of a map.", "author": "big-andy-coates", "createdAt": "2020-01-29T18:47:02Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -76,18 +72,18 @@\n   private static final int SERVICE_TIMEOUT_SEC = 2;\n   private static final int CHECK_HEARTBEAT_DELAY_MS = 1000;\n   private static final int SEND_HEARTBEAT_DELAY_MS = 100;\n+  private static final int DISCOVER_CLUSTER_DELAY_MS = 50;\n   private static final Logger LOG = LoggerFactory.getLogger(HeartbeatAgent.class);\n \n   private final KsqlEngine engine;\n   private final ServiceContext serviceContext;\n   private final HeartbeatConfig config;\n-  private final ConcurrentHashMap<String, TreeMap<Long, HeartbeatInfo>> receivedHeartbeats;\n-  private final ConcurrentHashMap<String, HostStatusEntity> hostsStatus;\n+  private final ConcurrentHashMap<HostInfo, TreeMap<Long, HeartbeatInfo>> receivedHeartbeats;\n+  private final AtomicReference<ImmutableMap<HostInfo, HostStatus>> immutableHostsStatus;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNTg1MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373735850", "bodyText": "I renamed it and created KsqlHost as an immutable class since HostInfo is from KStreams", "author": "vpapavas", "createdAt": "2020-02-01T00:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NDIyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\nindex 646250301c..96c2743fe2 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n\n@@ -78,13 +79,14 @@ public final class HeartbeatAgent {\n   private final KsqlEngine engine;\n   private final ServiceContext serviceContext;\n   private final HeartbeatConfig config;\n-  private final ConcurrentHashMap<HostInfo, TreeMap<Long, HeartbeatInfo>> receivedHeartbeats;\n-  private final AtomicReference<ImmutableMap<HostInfo, HostStatus>> immutableHostsStatus;\n+  private final List<HostStatusListener> hostStatusListeners;\n+  private final ConcurrentHashMap<KsqlHost, TreeMap<Long, HeartbeatInfo>> receivedHeartbeats;\n+  private final ConcurrentHashMap<KsqlHost, HostStatus> hostsStatus;\n   private final ScheduledExecutorService scheduledExecutorService;\n   private final ServiceManager serviceManager;\n   private final Clock clock;\n-  private HostInfo localHostInfo;\n-  private URL localURL;\n+  private KsqlHost localHost;\n+  private URL localUrl;\n \n   public static HeartbeatAgent.Builder builder() {\n     return new HeartbeatAgent.Builder();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NDQ1Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372564452", "bodyText": "this.immutableHostsStatus = new AtomicReference<>(ImmutableMap.of());", "author": "big-andy-coates", "createdAt": "2020-01-29T18:47:30Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -105,7 +101,8 @@ private HeartbeatAgent(final KsqlEngine engine,\n     this.serviceManager = new ServiceManager(Arrays.asList(\n         new DiscoverClusterService(), new SendHeartbeatService(), new CheckHeartbeatService()));\n     this.receivedHeartbeats = new ConcurrentHashMap<>();\n-    this.hostsStatus = new ConcurrentHashMap<>();\n+    this.immutableHostsStatus = new AtomicReference<>();\n+    immutableHostsStatus.set(ImmutableMap.of());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\nindex 646250301c..96c2743fe2 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n\n@@ -92,17 +94,18 @@ public final class HeartbeatAgent {\n \n   private HeartbeatAgent(final KsqlEngine engine,\n                          final ServiceContext serviceContext,\n-                         final HeartbeatConfig config) {\n+                         final HeartbeatConfig config,\n+                         final List<HostStatusListener> hostStatusListeners) {\n \n     this.engine = requireNonNull(engine, \"engine\");\n     this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n     this.config = requireNonNull(config, \"configuration parameters\");\n+    this.hostStatusListeners = requireNonNull(hostStatusListeners, \"heartbeatListeners\");\n     this.scheduledExecutorService = Executors.newScheduledThreadPool(config.threadPoolSize);\n     this.serviceManager = new ServiceManager(Arrays.asList(\n         new DiscoverClusterService(), new SendHeartbeatService(), new CheckHeartbeatService()));\n     this.receivedHeartbeats = new ConcurrentHashMap<>();\n-    this.immutableHostsStatus = new AtomicReference<>();\n-    immutableHostsStatus.set(ImmutableMap.of());\n+    this.hostsStatus = new ConcurrentHashMap<>();\n     this.clock = Clock.systemUTC();\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NDg4MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372564881", "bodyText": "immutableHostsStatus.set(ImmutableMap.copyOf(status);", "author": "big-andy-coates", "createdAt": "2020-01-29T18:48:21Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -128,13 +124,14 @@ public void receiveHeartbeat(final HostInfo hostInfo, final long timestamp) {\n    * Returns the current view of the cluster containing all hosts discovered (whether alive or dead)\n    * @return status of discovered hosts\n    */\n-  public Map<String, HostStatusEntity> getHostsStatus() {\n-    return Collections.unmodifiableMap(hostsStatus);\n+  public Map<HostInfo, HostStatus> getHostsStatus() {\n+    return immutableHostsStatus.get();\n   }\n \n   @VisibleForTesting\n-  void setHostsStatus(final Map<String, HostStatusEntity> status) {\n-    hostsStatus.putAll(status);\n+  void setHostsStatus(final Map<HostInfo, HostStatus> status) {\n+    immutableHostsStatus.set(new ImmutableMap.Builder<HostInfo, HostStatus>()\n+                                 .putAll(status).build());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\nindex 646250301c..96c2743fe2 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n\n@@ -124,14 +127,13 @@ public final class HeartbeatAgent {\n    * Returns the current view of the cluster containing all hosts discovered (whether alive or dead)\n    * @return status of discovered hosts\n    */\n-  public Map<HostInfo, HostStatus> getHostsStatus() {\n-    return immutableHostsStatus.get();\n+  public Map<KsqlHost, HostStatus> getHostsStatus() {\n+    return Collections.unmodifiableMap(hostsStatus);\n   }\n \n   @VisibleForTesting\n-  void setHostsStatus(final Map<HostInfo, HostStatus> status) {\n-    immutableHostsStatus.set(new ImmutableMap.Builder<HostInfo, HostStatus>()\n-                                 .putAll(status).build());\n+  void setHostsStatus(final Map<KsqlHost, HostStatus> status) {\n+    hostsStatus.putAll(status);\n   }\n \n   void startAgent() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NTY1NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372565655", "bodyText": "immutableHostsStatus.set(ImmutableMap.copyOf(copyOnWrite));", "author": "big-andy-coates", "createdAt": "2020-01-29T18:49:51Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -233,42 +211,50 @@ protected ScheduledExecutorService executor() {\n      * @param windowEnd the end time in ms of the current window\n      */\n     private void processHeartbeats(final long windowStart, final long windowEnd) {\n+\n+      final Map<HostInfo, HostStatus> copyOnWrite = new HashMap<>(immutableHostsStatus.get());\n       // No heartbeats received -> mark all hosts as dead\n       if (receivedHeartbeats.isEmpty()) {\n-        hostsStatus.forEach((host, status) -> {\n-          if (!host.equals(localHostString)) {\n+        copyOnWrite.forEach((host, status) -> {\n+          if (!host.equals(localHostInfo)) {\n             status.setHostAlive(false);\n           }\n         });\n+        immutableHostsStatus.set(new ImmutableMap.Builder<HostInfo, HostStatus>()\n+                                     .putAll(copyOnWrite).build());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2NzAyNQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373567025", "bodyText": "we're copying the map twice here (once on L215 and once here). Maybe in this case it makes more sense to use Collections.unmodifiableMap(copyOnWrite) to enforce the immutability instead of actually making a new copy if this is performance critical code (applies generally across the code base here)\nthought note, might be premature optimization given that the map is probably pretty small...", "author": "agavra", "createdAt": "2020-01-31T16:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NTY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNjQyMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373736420", "bodyText": "It is a very small map, as many entries as Ksql servers in the cluster.", "author": "vpapavas", "createdAt": "2020-02-01T00:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NTY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\nindex 646250301c..96c2743fe2 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n\n@@ -212,47 +215,51 @@ public final class HeartbeatAgent {\n      */\n     private void processHeartbeats(final long windowStart, final long windowEnd) {\n \n-      final Map<HostInfo, HostStatus> copyOnWrite = new HashMap<>(immutableHostsStatus.get());\n       // No heartbeats received -> mark all hosts as dead\n       if (receivedHeartbeats.isEmpty()) {\n-        copyOnWrite.forEach((host, status) -> {\n-          if (!host.equals(localHostInfo)) {\n-            status.setHostAlive(false);\n+        hostsStatus.replaceAll((host, status) -> {\n+          if (!host.equals(localHost)) {\n+            return status.withHostAlive(false);\n           }\n+          return status;\n         });\n-        immutableHostsStatus.set(new ImmutableMap.Builder<HostInfo, HostStatus>()\n-                                     .putAll(copyOnWrite).build());\n         return;\n       }\n \n-      for (Entry<HostInfo, HostStatus> hostEntry: copyOnWrite.entrySet()) {\n-        final HostInfo hostInfo = hostEntry.getKey();\n+      for (Entry<KsqlHost, HostStatus> hostEntry: hostsStatus.entrySet()) {\n+        final KsqlHost ksqlHost = hostEntry.getKey();\n         final HostStatus hostStatus = hostEntry.getValue();\n-        if (hostInfo.equals(localHostInfo)) {\n+        if (ksqlHost.equals(localHost)) {\n           continue;\n         }\n-        final TreeMap<Long, HeartbeatInfo> heartbeats = receivedHeartbeats.get(hostInfo);\n+        final TreeMap<Long, HeartbeatInfo> heartbeats = receivedHeartbeats.get(ksqlHost);\n         //For previously discovered hosts, if they have not received any heartbeats, mark them dead\n         if (heartbeats == null || heartbeats.isEmpty()) {\n-          copyOnWrite.get(hostInfo).setHostAlive(false);\n+          hostsStatus.computeIfPresent(ksqlHost, (host, status) -> status.withHostAlive(false));\n         } else {\n           final TreeMap<Long, HeartbeatInfo> copy;\n           synchronized (heartbeats) {\n-            LOG.debug(\"Process heartbeats: {} of host: {}\", heartbeats, hostInfo);\n+            LOG.debug(\"Process heartbeats: {} of host: {}\", heartbeats, ksqlHost);\n             // 1. remove heartbeats older than window\n             heartbeats.headMap(windowStart).clear();\n             copy = new TreeMap<>(heartbeats.subMap(windowStart, true, windowEnd, true));\n           }\n           // 2. count consecutive missed heartbeats and mark as alive or dead\n-          final  boolean isAlive = decideStatus(hostInfo, windowStart, windowEnd, copy);\n-          hostStatus.setHostAlive(isAlive);\n-          hostStatus.setLastStatusUpdateMs(windowEnd);\n+          final  boolean isAlive = decideStatus(ksqlHost, windowStart, windowEnd, copy);\n+          if (!isAlive) {\n+            LOG.info(\"Host: {} marked as dead.\", ksqlHost);\n+          }\n+          hostsStatus.computeIfPresent(ksqlHost, (host, status) -> status\n+              .withHostAlive(isAlive).withLastStatusUpdateMs(windowEnd));\n         }\n       }\n+      for (HostStatusListener listener : hostStatusListeners) {\n+        listener.onHostStatusUpdated(getHostsStatus());\n+      }\n     }\n \n     private boolean decideStatus(\n-        final HostInfo hostInfo, final long windowStart, final long windowEnd,\n+        final KsqlHost ksqlHost, final long windowStart, final long windowEnd,\n         final TreeMap<Long, HeartbeatInfo> heartbeats\n     ) {\n       long missedCount = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NzUxMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372567512", "bodyText": "Is HostStatus being updated/read from multiple threads?\nYou may be better making this an immutable type, which avoids race-conditions and threading issues, where the setters return new instances, e.g.\n@Immutable\npublic final class HostStatus {\n  \n  private final boolean hostAlive;\n  private final long lastStatusUpdateMs;\n\n  public HostStatus(\n      final boolean hostAlive,\n      final long lastStatusUpdateMs\n  ) {\n    this.hostAlive = hostAlive;\n    this.lastStatusUpdateMs = lastStatusUpdateMs;\n  }\n\n  public HostStatus withHostAlive(final boolean hostAlive) {\n    return new HostStatus(hostAlive, lastStatusUpdateMs);\n  }\n\n  public HostStatus setLastStatusUpdateMs(final long lastStatusUpdateMs) {\n    return new HostStatus(hostAlive, lastStatusUpdateMs);\n  }\n\n  public long getLastStatusUpdateMs() {\n    return lastStatusUpdateMs;\n  }\n\n  public boolean isHostAlive() {\n    return hostAlive;\n  }\n\n  @Override\n  public String toString() {\n    return hostAlive + \",\" + lastStatusUpdateMs;\n  }\n}", "author": "big-andy-coates", "createdAt": "2020-01-29T18:53:24Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/HostStatus.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.util;\n+\n+/**\n+ * Represent the status of a ksql host in the cluster as determined by the Heartbeat agent.\n+ * A host can alive or dead annotated with the timestamp of the last update in status.\n+ */\n+public class HostStatus {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY5NDg5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373694896", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-01-31T21:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NzUxMg=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-common/src/main/java/io/confluent/ksql/util/HostStatus.java b/ksql-common/src/main/java/io/confluent/ksql/util/HostStatus.java\nindex 2f2d6d9f44..3ea7af0fbc 100644\n--- a/ksql-common/src/main/java/io/confluent/ksql/util/HostStatus.java\n+++ b/ksql-common/src/main/java/io/confluent/ksql/util/HostStatus.java\n\n@@ -15,14 +15,18 @@\n \n package io.confluent.ksql.util;\n \n+import com.google.errorprone.annotations.Immutable;\n+import java.util.Objects;\n+\n /**\n  * Represent the status of a ksql host in the cluster as determined by the Heartbeat agent.\n  * A host can alive or dead annotated with the timestamp of the last update in status.\n  */\n+@Immutable\n public class HostStatus {\n \n-  private boolean hostAlive;\n-  private long lastStatusUpdateMs;\n+  private final boolean hostAlive;\n+  private final long lastStatusUpdateMs;\n \n   public HostStatus(\n       final boolean hostAlive,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzNzgzOQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373437839", "bodyText": "Note: Without my suggested change to make HostStatus immutable, this is still leaking mutable state.", "author": "big-andy-coates", "createdAt": "2020-01-31T11:35:01Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -128,13 +124,14 @@ public void receiveHeartbeat(final HostInfo hostInfo, final long timestamp) {\n    * Returns the current view of the cluster containing all hosts discovered (whether alive or dead)\n    * @return status of discovered hosts\n    */\n-  public Map<String, HostStatusEntity> getHostsStatus() {\n-    return Collections.unmodifiableMap(hostsStatus);\n+  public Map<HostInfo, HostStatus> getHostsStatus() {\n+    return immutableHostsStatus.get();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNjEyNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373736127", "bodyText": "@AlanConfluent made HostStatus immutable in his PR. I thought we would only make the change in one place but I realize now that was not a good decision as it makes reviewing hard and messy. I made HostStatus immutable as well.", "author": "vpapavas", "createdAt": "2020-02-01T00:05:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzNzgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\nindex 646250301c..96c2743fe2 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n\n@@ -124,14 +127,13 @@ public final class HeartbeatAgent {\n    * Returns the current view of the cluster containing all hosts discovered (whether alive or dead)\n    * @return status of discovered hosts\n    */\n-  public Map<HostInfo, HostStatus> getHostsStatus() {\n-    return immutableHostsStatus.get();\n+  public Map<KsqlHost, HostStatus> getHostsStatus() {\n+    return Collections.unmodifiableMap(hostsStatus);\n   }\n \n   @VisibleForTesting\n-  void setHostsStatus(final Map<HostInfo, HostStatus> status) {\n-    immutableHostsStatus.set(new ImmutableMap.Builder<HostInfo, HostStatus>()\n-                                 .putAll(status).build());\n+  void setHostsStatus(final Map<KsqlHost, HostStatus> status) {\n+    hostsStatus.putAll(status);\n   }\n \n   void startAgent() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTA5MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373439091", "bodyText": "Wondering why you've moved this to a field?\nIMHO, making it a field makes it more likely people will try to access it before its being initialized. Explicitly passing it around makes this impossible...", "author": "big-andy-coates", "createdAt": "2020-01-31T11:38:33Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -160,6 +161,10 @@\n   private final Consumer<KsqlConfig> rocksDBConfigSetterHandler;\n   private final Optional<HeartbeatAgent> heartbeatAgent;\n \n+  // Cannot be set in constructor, depends on parent server start\n+  private KsqlConfig ksqlConfigWithPort;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4MjI1Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374482252", "bodyText": "Changed it back to how it was", "author": "vpapavas", "createdAt": "2020-02-04T05:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTA5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\nindex 77f6f15a2e..fcef3a6ef7 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\n\n@@ -160,9 +162,7 @@ public final class KsqlRestApplication extends ExecutableApplication<KsqlRestCon\n   private final List<KsqlConfigurable> configurables;\n   private final Consumer<KsqlConfig> rocksDBConfigSetterHandler;\n   private final Optional<HeartbeatAgent> heartbeatAgent;\n-\n-  // Cannot be set in constructor, depends on parent server start\n-  private KsqlConfig ksqlConfigWithPort;\n+  private final Optional<LagReportingAgent> lagReportingAgent;\n \n \n   public static SourceName getCommandsStreamName() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTQ2Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373439466", "bodyText": "Why only if null?\nIf I were to have auto-port configuration, i.e. set the port to 0 so its auto allocated on startup, and then was to start-stop-start the server, the second start may well get a different port, so we'd need to always build the config with the port.", "author": "big-andy-coates", "createdAt": "2020-01-31T11:39:47Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -233,21 +238,28 @@ public void setupResources(final Configurable<?> config, final KsqlRestConfig ap\n   @Override\n   public void startAsync() {\n     log.info(\"KSQL RESTful API listening on {}\", StringUtils.join(getListeners(), \", \"));\n-    final KsqlConfig ksqlConfigWithPort = buildConfigWithPort();\n+    if (ksqlConfigWithPort == null) {\n+      ksqlConfigWithPort = buildConfigWithPort();\n+    }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU3MDIxNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373570214", "bodyText": "@big-andy-coates - the Guava Service model doesn't allow start-stop-start, the error/sthudown states are terminal", "author": "agavra", "createdAt": "2020-01-31T16:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTQ2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\nindex 77f6f15a2e..fcef3a6ef7 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\n\n@@ -238,28 +246,21 @@ public final class KsqlRestApplication extends ExecutableApplication<KsqlRestCon\n   @Override\n   public void startAsync() {\n     log.info(\"KSQL RESTful API listening on {}\", StringUtils.join(getListeners(), \", \"));\n-    if (ksqlConfigWithPort == null) {\n-      ksqlConfigWithPort = buildConfigWithPort();\n-    }\n+    final KsqlConfig ksqlConfigWithPort = buildConfigWithPort();\n     configurables.forEach(c -> c.configure(ksqlConfigWithPort));\n-    startKsql();\n+    startKsql(ksqlConfigWithPort);\n     final Properties metricsProperties = new Properties();\n     metricsProperties.putAll(getConfiguration().getOriginals());\n     if (versionCheckerAgent != null) {\n       versionCheckerAgent.start(KsqlModuleType.SERVER, metricsProperties);\n     }\n-    if (heartbeatAgent.isPresent()) {\n-      heartbeatAgent.get().setLocalAddress((String)ksqlConfigWithPort\n-          .getKsqlStreamConfigProps().get(StreamsConfig.APPLICATION_SERVER_CONFIG));\n-      heartbeatAgent.get().startAgent();\n-    }\n     displayWelcomeMessage();\n   }\n \n   @VisibleForTesting\n-  void startKsql() {\n+  void startKsql(final KsqlConfig ksqlConfigWithPort) {\n     waitForPreconditions();\n-    initialize();\n+    initialize(ksqlConfigWithPort);\n   }\n \n   @VisibleForTesting\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTYyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373439628", "bodyText": "super nit: remove.", "author": "big-andy-coates", "createdAt": "2020-01-31T11:40:20Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java", "diffHunk": "@@ -151,6 +151,7 @@\n   private static final String KSQL_HEARTBEAT_THREAD_POOL_SIZE_CONFIG_DOC =\n       \"Size of thread pool used for sending / processing heartbeats and cluster discovery.\";\n \n+", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java\nindex 5ce8a19e6a..9ca55dfa30 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java\n\n@@ -151,6 +149,20 @@ public class KsqlRestConfig extends RestConfig {\n   private static final String KSQL_HEARTBEAT_THREAD_POOL_SIZE_CONFIG_DOC =\n       \"Size of thread pool used for sending / processing heartbeats and cluster discovery.\";\n \n+  public static final String KSQL_LAG_REPORTING_ENABLE_CONFIG =\n+      KSQL_CONFIG_PREFIX + \"lag.reporting.enable\";\n+  private static final String KSQL_LAG_REPORTING_ENABLE_DOC =\n+      \"Whether lag reporting is enabled or not. It is disabled by default.\";\n+  public static final String KSQL_LAG_REPORTING_SEND_INTERVAL_MS_CONFIG =\n+      KSQL_CONFIG_PREFIX + \"lag.reporting.send.interval.ms\";\n+  private static final String KSQL_LAG_REPORTING_SEND_INTERVAL_MS_DOC =\n+      \"Interval at which lag reports are broadcasted to servers.\";\n+\n+  public static final String KSQL_QUERY_STANDBY_ENABLE_CONFIG =\n+      KSQL_CONFIG_PREFIX + \"query.standby.enable\";\n+  private static final String KSQL_QUERY_STANDBY_ENABLE_DOC =\n+      \"Whether the queries are forwarded to standby hosts when the active is down.\"\n+          + \" It is disabled by default.\";\n \n   private static final ConfigDef CONFIG_DEF;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0MDg0OA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373440848", "bodyText": "This can be simplified to:\n    final HostStatus  status = allHostsStatus.get(hostInfo);\n    return status == null\n           ? true\n            : status.isHostAlive();\nwhich avoids the double lookup.\nNo biggie if you want to leave as is, but do remove the redundant allHostsStatus.isEmpty() || .\nOut of interest, how come we assume a host is alive if we have no info on it?  Naively, it would of assumed the opposite.", "author": "big-andy-coates", "createdAt": "2020-01-31T11:44:07Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.util.HostStatus;\n+import java.util.Map;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Filters ksql hosts based on whether they are alive or dead.\n+ */\n+public class LivenessFilter implements RoutingFilter {\n+\n+  public LivenessFilter() {\n+  }\n+\n+  /**\n+   * Returns true if the host is alive. If the heartbeat agent is not enabled, all hosts are\n+   * assumed to be alive.\n+   * @param hostInfo The host for which the status is checked\n+   * @param storeName Ignored\n+   * @param partition Ignored\n+   * @return true if the host is alive, false otherwise.\n+   */\n+  @Override\n+  public boolean filter(\n+      final Map<HostInfo, HostStatus> allHostsStatus,\n+      final HostInfo hostInfo,\n+      final String storeName,\n+      final int partition) {\n+\n+    if (allHostsStatus.isEmpty() || !allHostsStatus.containsKey(hostInfo)) {\n+      return true;\n+    }\n+    return allHostsStatus.get(hostInfo).isHostAlive();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java\nindex 874f646773..bd3791a3f4 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java\n\n@@ -17,6 +17,7 @@ package io.confluent.ksql.rest.server;\n \n import io.confluent.ksql.execution.streams.RoutingFilter;\n import io.confluent.ksql.util.HostStatus;\n+import io.confluent.ksql.util.KsqlHost;\n import java.util.Map;\n import org.apache.kafka.streams.state.HostInfo;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0MzkxOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373443918", "bodyText": "I'd avoid logging at info for every pull query. That's a lot of noise in the logs!", "author": "big-andy-coates", "createdAt": "2020-01-31T11:53:18Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,20 +63,54 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final Map<HostInfo, HostStatus> allHostsStatus,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+\n+    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NDQ2MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375574461", "bodyText": "lets move this to DEBUG or TRACE please", "author": "vinothchandar", "createdAt": "2020-02-05T23:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0MzkxOA=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\nindex 877da8d207..514427d78f 100644\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n+++ b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n\n@@ -65,8 +66,8 @@ final class KsLocator implements Locator {\n   @Override\n   public List<KsqlNode> locate(\n       final Struct key,\n-      final Map<HostInfo, HostStatus> allHostsStatus,\n-      final List<RoutingFilter> routingFilters\n+      final Map<KsqlHost, HostStatus> allHostsStatus,\n+      final RoutingFilter routingFilters\n   ) {\n     final KeyQueryMetadata metadata = kafkaStreams\n         .queryMetadataForKey(stateStoreName, key, keySerializer);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NDg2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373444863", "bodyText": "FYI, rather than allocating a new buffer (twice) to hold all the entries, when all you want to do is iterate around them, you can just do:\nStreams.concat(Stream.of(activeHost), standByHosts.stream())", "author": "big-andy-coates", "createdAt": "2020-01-31T11:55:53Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,20 +63,54 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final Map<HostInfo, HostStatus> allHostsStatus,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+\n+    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n+\n+    final List<HostInfo> hosts = new ArrayList<>();\n+    hosts.add(activeHost);\n+    hosts.addAll(standByHosts);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\nindex 877da8d207..514427d78f 100644\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n+++ b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n\n@@ -65,8 +66,8 @@ final class KsLocator implements Locator {\n   @Override\n   public List<KsqlNode> locate(\n       final Struct key,\n-      final Map<HostInfo, HostStatus> allHostsStatus,\n-      final List<RoutingFilter> routingFilters\n+      final Map<KsqlHost, HostStatus> allHostsStatus,\n+      final RoutingFilter routingFilters\n   ) {\n     final KeyQueryMetadata metadata = kafkaStreams\n         .queryMetadataForKey(stateStoreName, key, keySerializer);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MDI2MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373450260", "bodyText": "Rather that passing a List<RoutingFilter> around, requiring all users to handle the iteration, you could just pass a single RoutingFilter which internally handles the iteration.\nThere are two main ways of achieving this:\n\nThe classic way of implementing a type that handles the iteration:\n\npublic final class RoutingFilters implements RoutingFilter {\n   \n    public RoutingFilters(final List<? extends RoutingFilter> filters) {\n         this.filters = ImmutableList.copyOf(requireNonNull(filters));\n    }\n\n   public  boolean filter(\n      Map<HostInfo, HostStatus> allHostsStatus,\n      HostInfo hostInfo,\n      String storeName,\n      int partition\n  ) {\n     return filters.stream()\n        .allMatch(f -> f.filter(allHostsStatus, hostInfo, storeName, partition));\n  }\n}\n\nThe more functional way of handling filter composition:\n\n@FunctionalInterface\npublic interface RoutingFilter {\n\n  boolean filter(\n      Map<HostInfo, HostStatus> allHostsStatus,\n      HostInfo hostInfo,\n      String storeName,\n      int partition);\n\n  default RoutingFilter and(final RoutingFilter other) {\n    Objects.requireNonNull(other);\n    return (allHostsStatus, hostInfo, storeName, partition) -> \n        filter(allHostsStatus, hostInfo, storeName, partition) \n            && other.filter(allHostsStatus, hostInfo, storeName, partition);\n  }\n}\nThen you can compose a list of filters into a single filter with:\nfinal Optional<RoutingFilter> reduce = filters.stream()\n        .reduce(RoutingFilter::and);\nNote, the result is an Optional to handle the case where filters is empty.  If the list is not empty you can just call get().  If the list may be empty then you could use a no-op filter as the default:\nfinal RoutingFilter filter = filters.stream()\n        .reduce(RoutingFilter::and)\n        .orElse(RoutingFilter.always());\nWhere always() is:\nstatic RoutingFilter always() {\n    return (allHostsStatus, hostInfo, storeName, partition) -> true;\n  }", "author": "big-andy-coates", "createdAt": "2020-01-31T12:11:31Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,20 +63,54 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final Map<HostInfo, HostStatus> allHostsStatus,\n+      final List<RoutingFilter> routingFilters", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\nindex 877da8d207..514427d78f 100644\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n+++ b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n\n@@ -65,8 +66,8 @@ final class KsLocator implements Locator {\n   @Override\n   public List<KsqlNode> locate(\n       final Struct key,\n-      final Map<HostInfo, HostStatus> allHostsStatus,\n-      final List<RoutingFilter> routingFilters\n+      final Map<KsqlHost, HostStatus> allHostsStatus,\n+      final RoutingFilter routingFilters\n   ) {\n     final KeyQueryMetadata metadata = kafkaStreams\n         .queryMetadataForKey(stateStoreName, key, keySerializer);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MDgyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373450828", "bodyText": "Maybe call it LivelinessFilter?", "author": "big-andy-coates", "createdAt": "2020-01-31T12:13:11Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.util.HostStatus;\n+import java.util.Map;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Filters ksql hosts based on whether they are alive or dead.\n+ */\n+public class LivenessFilter implements RoutingFilter {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU3MTgxOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373571818", "bodyText": "If I understand correctly, Liveness is a technical term (and I believe it's somewhat correctly used here): https://en.wikipedia.org/wiki/Liveness", "author": "agavra", "createdAt": "2020-01-31T16:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU3MjQ2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373572463", "bodyText": "I think Liveness is a technical term which applies (somewhat) to this situation: https://en.wikipedia.org/wiki/Liveness", "author": "agavra", "createdAt": "2020-01-31T16:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MDgyOA=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java\nindex 874f646773..bd3791a3f4 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java\n\n@@ -17,6 +17,7 @@ package io.confluent.ksql.rest.server;\n \n import io.confluent.ksql.execution.streams.RoutingFilter;\n import io.confluent.ksql.util.HostStatus;\n+import io.confluent.ksql.util.KsqlHost;\n import java.util.Map;\n import org.apache.kafka.streams.state.HostInfo;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MTY5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373451696", "bodyText": "var name suggests these are 'ordered', but they don't seem to be ordered by lag yet.  Though I see the primary is first in the list, if alive.   Is the ordering coming later, or am I missing something?", "author": "big-andy-coates", "createdAt": "2020-01-31T12:15:46Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY4MDY0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373680645", "bodyText": "Yes, the ordering is coming in a later PR", "author": "vpapavas", "createdAt": "2020-01-31T20:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MTY5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex deb6ffefb2..e0cfa7875c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -185,9 +194,7 @@ public final class PullQueryExecutor {\n           statement,\n           executionContext,\n           serviceContext,\n-          pullQueryContext,\n-          heartbeatAgent,\n-          routingFilters\n+          pullQueryContext\n       );\n \n     } catch (final Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1Mjc1NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373452755", "bodyText": "This if statement would be better handled as a filter, i.e. if stale reads are not enabled you install a filter at the start of the filter chain that filters out all but the primary.\nThis would massively simplify this method: all this method would need to do is iterate around the returned list.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:18:33Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5MTgwMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374991801", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T23:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1Mjc1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex deb6ffefb2..e0cfa7875c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -185,9 +194,7 @@ public final class PullQueryExecutor {\n           statement,\n           executionContext,\n           serviceContext,\n-          pullQueryContext,\n-          heartbeatAgent,\n-          routingFilters\n+          pullQueryContext\n       );\n \n     } catch (final Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MzEzNg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373453136", "bodyText": "potential bug: If the primary is dead filteredAndOrderedNodes.get(0) might not return the primary!\nIf you switch KSQL_QUERY_PULL_ENABLE_STALE_READS handling to a filter, as I suggest above, this would fix this issue.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:19:40Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5OTEyMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374499121", "bodyText": "+1 would be good to push that into a filter.. and keep the single loop here.", "author": "vinothchandar", "createdAt": "2020-02-04T06:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MzEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5MTY5NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374991694", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T23:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MzEzNg=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex deb6ffefb2..e0cfa7875c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -185,9 +194,7 @@ public final class PullQueryExecutor {\n           statement,\n           executionContext,\n           serviceContext,\n-          pullQueryContext,\n-          heartbeatAgent,\n-          routingFilters\n+          pullQueryContext\n       );\n \n     } catch (final Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MzY4OA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373453688", "bodyText": "don't catch Throwable as it includes errors.  This is bad practice.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      } catch (Throwable t) {\n          \n          \n            \n                      } catch (final Exception t) {", "author": "big-andy-coates", "createdAt": "2020-01-31T12:21:14Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex deb6ffefb2..e0cfa7875c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -185,9 +194,7 @@ public final class PullQueryExecutor {\n           statement,\n           executionContext,\n           serviceContext,\n-          pullQueryContext,\n-          heartbeatAgent,\n-          routingFilters\n+          pullQueryContext\n       );\n \n     } catch (final Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NDkxNQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373454915", "bodyText": "I would be tempted to change this log line to a debug as its kind of expected behaviour during a bounce of the cluster.\nI'd also throw a MaterializationException after the iteration to avoid trying the first element of filteredAndOrderedNodes twice.  (Though this becomes a moot point if you add the filter I'm suggesting).", "author": "big-andy-coates", "createdAt": "2020-01-31T12:24:56Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex deb6ffefb2..e0cfa7875c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -185,9 +194,7 @@ public final class PullQueryExecutor {\n           statement,\n           executionContext,\n           serviceContext,\n-          pullQueryContext,\n-          heartbeatAgent,\n-          routingFilters\n+          pullQueryContext\n       );\n \n     } catch (final Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTA2MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373455060", "bodyText": "I'd avoid logging at info for each pull query.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:25:24Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory.buildSchema(result.schema, mat.windowType());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis);\n+    } catch (Throwable t) {\n+      throw new MaterializationException(String.format(\n+          \"Unable to execute pull query: %s. Error: %s\", statement.getStatementText(),\n+          t.getMessage()), t);\n+    }\n+  }\n \n-        rows = handleSelects(\n-            result,\n+  private static TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    try {\n+      if (node.isLocal()) {\n+        LOG.info(\"Query {} executed locally at host {}.\",\n+                 statement.getStatementText(), node.location());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex deb6ffefb2..e0cfa7875c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -185,9 +194,7 @@ public final class PullQueryExecutor {\n           statement,\n           executionContext,\n           serviceContext,\n-          pullQueryContext,\n-          heartbeatAgent,\n-          routingFilters\n+          pullQueryContext\n       );\n \n     } catch (final Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTEwMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373455101", "bodyText": "I'd avoid logging at info for each pull query.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:25:31Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory.buildSchema(result.schema, mat.windowType());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis);\n+    } catch (Throwable t) {\n+      throw new MaterializationException(String.format(\n+          \"Unable to execute pull query: %s. Error: %s\", statement.getStatementText(),\n+          t.getMessage()), t);\n+    }\n+  }\n \n-        rows = handleSelects(\n-            result,\n+  private static TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    try {\n+      if (node.isLocal()) {\n+        LOG.info(\"Query {} executed locally at host {}.\",\n+                 statement.getStatementText(), node.location());\n+        return queryRowsLocally(\n             statement,\n             executionContext,\n-            analysis,\n-            outputSchema,\n-            queryId,\n-            contextStacker\n-        );\n+            pullQueryContext);\n+      } else {\n+        LOG.info(\"Query {} routed to host {}.\", statement.getStatementText(), node.location());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex deb6ffefb2..e0cfa7875c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -185,9 +194,7 @@ public final class PullQueryExecutor {\n           statement,\n           executionContext,\n           serviceContext,\n-          pullQueryContext,\n-          heartbeatAgent,\n-          routingFilters\n+          pullQueryContext\n       );\n \n     } catch (final Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTIyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373455228", "bodyText": "As above, don't catch Throwable.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:25:50Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory.buildSchema(result.schema, mat.windowType());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis);\n+    } catch (Throwable t) {\n+      throw new MaterializationException(String.format(\n+          \"Unable to execute pull query: %s. Error: %s\", statement.getStatementText(),\n+          t.getMessage()), t);\n+    }\n+  }\n \n-        rows = handleSelects(\n-            result,\n+  private static TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    try {\n+      if (node.isLocal()) {\n+        LOG.info(\"Query {} executed locally at host {}.\",\n+                 statement.getStatementText(), node.location());\n+        return queryRowsLocally(\n             statement,\n             executionContext,\n-            analysis,\n-            outputSchema,\n-            queryId,\n-            contextStacker\n-        );\n+            pullQueryContext);\n+      } else {\n+        LOG.info(\"Query {} routed to host {}.\", statement.getStatementText(), node.location());\n+        return forwardTo(node, statement, serviceContext);\n       }\n+    } catch (Throwable t) {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex deb6ffefb2..e0cfa7875c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -185,9 +194,7 @@ public final class PullQueryExecutor {\n           statement,\n           executionContext,\n           serviceContext,\n-          pullQueryContext,\n-          heartbeatAgent,\n-          routingFilters\n+          pullQueryContext\n       );\n \n     } catch (final Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTQxMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373455411", "bodyText": "nit: move this throw into the catch block.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:26:21Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory.buildSchema(result.schema, mat.windowType());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis);\n+    } catch (Throwable t) {\n+      throw new MaterializationException(String.format(\n+          \"Unable to execute pull query: %s. Error: %s\", statement.getStatementText(),\n+          t.getMessage()), t);\n+    }\n+  }\n \n-        rows = handleSelects(\n-            result,\n+  private static TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    try {\n+      if (node.isLocal()) {\n+        LOG.info(\"Query {} executed locally at host {}.\",\n+                 statement.getStatementText(), node.location());\n+        return queryRowsLocally(\n             statement,\n             executionContext,\n-            analysis,\n-            outputSchema,\n-            queryId,\n-            contextStacker\n-        );\n+            pullQueryContext);\n+      } else {\n+        LOG.info(\"Query {} routed to host {}.\", statement.getStatementText(), node.location());\n+        return forwardTo(node, statement, serviceContext);\n       }\n+    } catch (Throwable t) {\n+      LOG.info(\"Error routing query \" + statement.getStatementText() + \" to \" + node, t);\n+    }\n+    throw new MaterializationException(\n+        \"Unable to execute pull query :\" + statement.getStatementText());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5MTYwOQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374991609", "bodyText": "I removed the try-catch altogether. I think it is cleaner now", "author": "vpapavas", "createdAt": "2020-02-04T23:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTQxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex deb6ffefb2..e0cfa7875c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -185,9 +194,7 @@ public final class PullQueryExecutor {\n           statement,\n           executionContext,\n           serviceContext,\n-          pullQueryContext,\n-          heartbeatAgent,\n-          routingFilters\n+          pullQueryContext\n       );\n \n     } catch (final Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTc2Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373455766", "bodyText": "Generally, avoid the 'log and throw' pattern. It's an anti-pattern that generally results in the same error being logged multiple times.  Better just to throw the exception and allow the exception to bubble up. The caller can determine if this is an error worth logging or not.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:27:30Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory.buildSchema(result.schema, mat.windowType());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis);\n+    } catch (Throwable t) {\n+      throw new MaterializationException(String.format(\n+          \"Unable to execute pull query: %s. Error: %s\", statement.getStatementText(),\n+          t.getMessage()), t);\n+    }\n+  }\n \n-        rows = handleSelects(\n-            result,\n+  private static TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    try {\n+      if (node.isLocal()) {\n+        LOG.info(\"Query {} executed locally at host {}.\",\n+                 statement.getStatementText(), node.location());\n+        return queryRowsLocally(\n             statement,\n             executionContext,\n-            analysis,\n-            outputSchema,\n-            queryId,\n-            contextStacker\n-        );\n+            pullQueryContext);\n+      } else {\n+        LOG.info(\"Query {} routed to host {}.\", statement.getStatementText(), node.location());\n+        return forwardTo(node, statement, serviceContext);\n       }\n+    } catch (Throwable t) {\n+      LOG.info(\"Error routing query \" + statement.getStatementText() + \" to \" + node, t);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5MTM3NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374991375", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T23:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTc2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex deb6ffefb2..e0cfa7875c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -185,9 +194,7 @@ public final class PullQueryExecutor {\n           statement,\n           executionContext,\n           serviceContext,\n-          pullQueryContext,\n-          heartbeatAgent,\n-          routingFilters\n+          pullQueryContext\n       );\n \n     } catch (final Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1Njc4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373456789", "bodyText": "nice :D", "author": "big-andy-coates", "createdAt": "2020-01-31T12:30:43Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -247,6 +335,55 @@ private static ImmutableAnalysis analyze(\n     return queryAnalyzer.analyze(statement.getStatement(), Optional.empty());\n   }\n \n+  private static final class PullQueryContext {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NjkwMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373456902", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:31:01Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -34,9 +49,11 @@\n @Produces({Versions.KSQL_V1_JSON, MediaType.APPLICATION_JSON})\n public class ClusterStatusResource {\n \n+  private final KsqlEngine engine;\n   private final HeartbeatAgent heartbeatAgent;\n \n-  public ClusterStatusResource(final HeartbeatAgent heartbeatAgent) {\n+  public ClusterStatusResource(final KsqlEngine engine,final HeartbeatAgent heartbeatAgent) {\n+    this.engine = engine;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\nindex db3d24c2ff..9467478069 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n\n@@ -51,10 +56,17 @@ public class ClusterStatusResource {\n \n   private final KsqlEngine engine;\n   private final HeartbeatAgent heartbeatAgent;\n+  private final Optional<LagReportingAgent> lagReportingAgent;\n+  private static final HostStoreLags EMPTY_HOST_STORE_LAGS =\n+      new HostStoreLags(ImmutableMap.of(), 0);\n \n-  public ClusterStatusResource(final KsqlEngine engine,final HeartbeatAgent heartbeatAgent) {\n-    this.engine = engine;\n-    this.heartbeatAgent = heartbeatAgent;\n+  public ClusterStatusResource(\n+      final KsqlEngine engine,\n+      final HeartbeatAgent heartbeatAgent,\n+      final Optional<LagReportingAgent> lagReportingAgent) {\n+    this.engine = Objects.requireNonNull(engine, \"engine\");\n+    this.heartbeatAgent = Objects.requireNonNull(heartbeatAgent, \"heartbeatAgent\");\n+    this.lagReportingAgent = Objects.requireNonNull(lagReportingAgent, \"lagReportingAgent\");\n   }\n \n   @GET\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NzU1Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373457557", "bodyText": "I'd be tempted to have the HostInfoEntity constructor take a HostInfo and the HostStatusEntity take a HostStatus.  Purely so that this code doesn't need to change if/when we add more fields to either source type.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:32:48Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -47,6 +64,51 @@ public Response checkClusterStatus() {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    return new ClusterStatusResponse(heartbeatAgent.getHostsStatus());\n+    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+\n+    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+        .entrySet()\n+        .stream()\n+        .collect(Collectors.toMap(\n+            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n+                                          entry.getValue().getLastStatusUpdateMs(),", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAwNzU0OA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r376007548", "bodyText": "Since these are JSON entities, If they take the objects as arguments, I would need to write a serializer/deserializer which means they would depend on changes in the source. At least now, they are independent of additions of new fields.", "author": "vpapavas", "createdAt": "2020-02-06T18:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NzU1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\nindex db3d24c2ff..9467478069 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n\n@@ -64,21 +76,28 @@ public class ClusterStatusResource {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+    final Map<KsqlHost, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n \n-    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+    final Map<KsqlHostEntity, HostStatusEntity> response = allHostStatus\n         .entrySet()\n         .stream()\n         .collect(Collectors.toMap(\n-            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new KsqlHostEntity(entry.getKey().host(), entry.getKey().port()) ,\n             entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n                                           entry.getValue().getLastStatusUpdateMs(),\n-                                          getActiveStandbyInformation(entry.getKey()))));\n+                                          getHostStoreLags(entry.getKey()))\n+        ));\n \n     return new ClusterStatusResponse(response);\n   }\n \n-  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {\n+\n+  private HostStoreLags getHostStoreLags(final KsqlHost ksqlHost) {\n+    return lagReportingAgent\n+      .flatMap(agent -> agent.getLagPerHost(ksqlHost))\n+        .orElse(EMPTY_HOST_STORE_LAGS);\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final KsqlHost ksqlHost) {\n     final List<PersistentQueryMetadata> currentQueries = engine.getPersistentQueries();\n     if (currentQueries.isEmpty()) {\n       // empty response\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1ODMxMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373458312", "bodyText": "Avoid null checks like this by ensuring getAllMetadata returns an empty list, not null!  This puts the null check in one place - inside getAllMetadata. Otherwise we have to duplicate that null check everywhere that calls that method.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:34:58Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -47,6 +64,51 @@ public Response checkClusterStatus() {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    return new ClusterStatusResponse(heartbeatAgent.getHostsStatus());\n+    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+\n+    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+        .entrySet()\n+        .stream()\n+        .collect(Collectors.toMap(\n+            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n+                                          entry.getValue().getLastStatusUpdateMs(),\n+                                          getActiveStandbyInformation(entry.getKey()))));\n+\n+    return new ClusterStatusResponse(response);\n+  }\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {\n+    final List<PersistentQueryMetadata> currentQueries = engine.getPersistentQueries();\n+    if (currentQueries.isEmpty()) {\n+      // empty response\n+      return Collections.emptyMap();\n+    }\n+\n+    final Map<String, ActiveStandbyEntity> perQueryMap = new HashMap<>();\n+    for (PersistentQueryMetadata persistentMetadata: currentQueries) {\n+      for (StreamsMetadata streamsMetadata : persistentMetadata\n+          .getAllMetadata()) {\n+        if (streamsMetadata == null || !streamsMetadata.hostInfo().equals(hostInfo)) {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\nindex db3d24c2ff..9467478069 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n\n@@ -64,21 +76,28 @@ public class ClusterStatusResource {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+    final Map<KsqlHost, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n \n-    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+    final Map<KsqlHostEntity, HostStatusEntity> response = allHostStatus\n         .entrySet()\n         .stream()\n         .collect(Collectors.toMap(\n-            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new KsqlHostEntity(entry.getKey().host(), entry.getKey().port()) ,\n             entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n                                           entry.getValue().getLastStatusUpdateMs(),\n-                                          getActiveStandbyInformation(entry.getKey()))));\n+                                          getHostStoreLags(entry.getKey()))\n+        ));\n \n     return new ClusterStatusResponse(response);\n   }\n \n-  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {\n+\n+  private HostStoreLags getHostStoreLags(final KsqlHost ksqlHost) {\n+    return lagReportingAgent\n+      .flatMap(agent -> agent.getLagPerHost(ksqlHost))\n+        .orElse(EMPTY_HOST_STORE_LAGS);\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final KsqlHost ksqlHost) {\n     final List<PersistentQueryMetadata> currentQueries = engine.getPersistentQueries();\n     if (currentQueries.isEmpty()) {\n       // empty response\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1OTAzMw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373459033", "bodyText": "Covered already by if (... !streamsMetadata.hostInfo().equals(hostInfo)), right?", "author": "big-andy-coates", "createdAt": "2020-01-31T12:37:03Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -47,6 +64,51 @@ public Response checkClusterStatus() {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    return new ClusterStatusResponse(heartbeatAgent.getHostsStatus());\n+    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+\n+    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+        .entrySet()\n+        .stream()\n+        .collect(Collectors.toMap(\n+            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n+                                          entry.getValue().getLastStatusUpdateMs(),\n+                                          getActiveStandbyInformation(entry.getKey()))));\n+\n+    return new ClusterStatusResponse(response);\n+  }\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {\n+    final List<PersistentQueryMetadata> currentQueries = engine.getPersistentQueries();\n+    if (currentQueries.isEmpty()) {\n+      // empty response\n+      return Collections.emptyMap();\n+    }\n+\n+    final Map<String, ActiveStandbyEntity> perQueryMap = new HashMap<>();\n+    for (PersistentQueryMetadata persistentMetadata: currentQueries) {\n+      for (StreamsMetadata streamsMetadata : persistentMetadata\n+          .getAllMetadata()) {\n+        if (streamsMetadata == null || !streamsMetadata.hostInfo().equals(hostInfo)) {\n+          continue;\n+        }\n+        if (streamsMetadata == StreamsMetadata.NOT_AVAILABLE) {\n+          continue;\n+        }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\nindex db3d24c2ff..9467478069 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n\n@@ -64,21 +76,28 @@ public class ClusterStatusResource {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+    final Map<KsqlHost, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n \n-    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+    final Map<KsqlHostEntity, HostStatusEntity> response = allHostStatus\n         .entrySet()\n         .stream()\n         .collect(Collectors.toMap(\n-            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new KsqlHostEntity(entry.getKey().host(), entry.getKey().port()) ,\n             entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n                                           entry.getValue().getLastStatusUpdateMs(),\n-                                          getActiveStandbyInformation(entry.getKey()))));\n+                                          getHostStoreLags(entry.getKey()))\n+        ));\n \n     return new ClusterStatusResponse(response);\n   }\n \n-  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {\n+\n+  private HostStoreLags getHostStoreLags(final KsqlHost ksqlHost) {\n+    return lagReportingAgent\n+      .flatMap(agent -> agent.getLagPerHost(ksqlHost))\n+        .orElse(EMPTY_HOST_STORE_LAGS);\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final KsqlHost ksqlHost) {\n     final List<PersistentQueryMetadata> currentQueries = engine.getPersistentQueries();\n     if (currentQueries.isEmpty()) {\n       // empty response\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MzAyNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373463027", "bodyText": "There's nothing wrong with the implementation here.  However, you may find its more readable if you make use of streams, e.g. what do you think of this:\nprivate Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {\n\n    return engine.getPersistentQueries().stream()\n        .flatMap(query -> query.getAllMetadata().stream()\n            .map(md -> new AppIdAndSteamMetadata(query.getQueryApplicationId(), md)))\n        .filter(md -> md.streamsMetadata.hostInfo().equals(hostInfo))\n        .collect(Collectors.toMap(\n            md -> md.applicationId,\n            AppIdAndSteamMetadata::toActiveStandbyEntity\n        ));\n  }\n\n  private static final class AppIdAndSteamMetadata {\n\n    final String applicationId;\n    final StreamsMetadata streamsMetadata;\n\n    AppIdAndSteamMetadata(\n        final String applicationId,\n        final StreamsMetadata streamsMetadata\n    ) {\n      this.applicationId = requireNonNull(applicationId, \"applicationId\");\n      this.streamsMetadata = requireNonNull(streamsMetadata, \"md\");\n    }\n\n    public ActiveStandbyEntity toActiveStandbyEntity() {\n      final Set<String> activePartitions = streamsMetadata.topicPartitions()\n          .stream()\n          .map(TopicPartition::toString)\n          .collect(Collectors.toSet());\n\n      final Set<String> standByPartitions = streamsMetadata.standbyTopicPartitions()\n          .stream()\n          .map(TopicPartition::toString)\n          .collect(Collectors.toSet());\n\n      return new ActiveStandbyEntity(\n          streamsMetadata.stateStoreNames(),\n          activePartitions,\n          streamsMetadata.standbyStateStoreNames(),\n          standByPartitions);\n    }\n  }", "author": "big-andy-coates", "createdAt": "2020-01-31T12:48:12Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -47,6 +64,51 @@ public Response checkClusterStatus() {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    return new ClusterStatusResponse(heartbeatAgent.getHostsStatus());\n+    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+\n+    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+        .entrySet()\n+        .stream()\n+        .collect(Collectors.toMap(\n+            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n+                                          entry.getValue().getLastStatusUpdateMs(),\n+                                          getActiveStandbyInformation(entry.getKey()))));\n+\n+    return new ClusterStatusResponse(response);\n+  }\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ1OTUyNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375459527", "bodyText": "Agreed and done", "author": "vpapavas", "createdAt": "2020-02-05T19:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MzAyNw=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\nindex db3d24c2ff..9467478069 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n\n@@ -64,21 +76,28 @@ public class ClusterStatusResource {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+    final Map<KsqlHost, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n \n-    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+    final Map<KsqlHostEntity, HostStatusEntity> response = allHostStatus\n         .entrySet()\n         .stream()\n         .collect(Collectors.toMap(\n-            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new KsqlHostEntity(entry.getKey().host(), entry.getKey().port()) ,\n             entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n                                           entry.getValue().getLastStatusUpdateMs(),\n-                                          getActiveStandbyInformation(entry.getKey()))));\n+                                          getHostStoreLags(entry.getKey()))\n+        ));\n \n     return new ClusterStatusResponse(response);\n   }\n \n-  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {\n+\n+  private HostStoreLags getHostStoreLags(final KsqlHost ksqlHost) {\n+    return lagReportingAgent\n+      .flatMap(agent -> agent.getLagPerHost(ksqlHost))\n+        .orElse(EMPTY_HOST_STORE_LAGS);\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final KsqlHost ksqlHost) {\n     final List<PersistentQueryMetadata> currentQueries = engine.getPersistentQueries();\n     if (currentQueries.isEmpty()) {\n       // empty response\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MzU3Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373463576", "bodyText": "Rather than passing these down, it may be time to change PullQueryExecutor to take these in its constructor...\nYou can probably pass in ksqlEngine in the constructor too.   Though I think serviceContext needs to be per-call to support running queries under the security context of the calling user.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:49:39Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/PullQueryPublisher.java", "diffHunk": "@@ -40,33 +43,43 @@\n   private final ServiceContext serviceContext;\n   private final ConfiguredStatement<Query> query;\n   private final TheQueryExecutor pullQueryExecutor;\n+  private final Optional<HeartbeatAgent> heartbeatAgent;\n+  private final List<RoutingFilter> routingFilters;\n \n   PullQueryPublisher(\n       final KsqlEngine ksqlEngine,\n       final ServiceContext serviceContext,\n-      final ConfiguredStatement<Query> query\n+      final ConfiguredStatement<Query> query,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3OTAzMw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374979033", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T23:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MzU3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/PullQueryPublisher.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/PullQueryPublisher.java\nindex 35b3a8a986..55e3bc457d 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/PullQueryPublisher.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/PullQueryPublisher.java\n\n@@ -20,66 +20,40 @@ import static java.util.Objects.requireNonNull;\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import io.confluent.ksql.GenericRow;\n-import io.confluent.ksql.KsqlExecutionContext;\n-import io.confluent.ksql.engine.KsqlEngine;\n-import io.confluent.ksql.execution.streams.RoutingFilter;\n import io.confluent.ksql.parser.tree.Query;\n import io.confluent.ksql.rest.entity.StreamedRow;\n import io.confluent.ksql.rest.entity.TableRowsEntity;\n-import io.confluent.ksql.rest.server.HeartbeatAgent;\n import io.confluent.ksql.rest.server.execution.PullQueryExecutor;\n import io.confluent.ksql.rest.server.resources.streaming.Flow.Subscriber;\n import io.confluent.ksql.services.ServiceContext;\n import io.confluent.ksql.statement.ConfiguredStatement;\n import java.util.Collection;\n import java.util.List;\n-import java.util.Optional;\n import java.util.concurrent.Callable;\n import java.util.stream.Collectors;\n \n class PullQueryPublisher implements Flow.Publisher<Collection<StreamedRow>> {\n \n-  private final KsqlEngine ksqlEngine;\n   private final ServiceContext serviceContext;\n   private final ConfiguredStatement<Query> query;\n-  private final TheQueryExecutor pullQueryExecutor;\n-  private final Optional<HeartbeatAgent> heartbeatAgent;\n-  private final List<RoutingFilter> routingFilters;\n-\n-  PullQueryPublisher(\n-      final KsqlEngine ksqlEngine,\n-      final ServiceContext serviceContext,\n-      final ConfiguredStatement<Query> query,\n-      final Optional<HeartbeatAgent> heartbeatAgent,\n-      final List<RoutingFilter> routingFilters\n-  ) {\n-    this(ksqlEngine, serviceContext, query, heartbeatAgent, routingFilters,\n-         PullQueryExecutor::execute);\n-  }\n+  private final PullQueryExecutor pullQueryExecutor;\n \n   @VisibleForTesting\n   PullQueryPublisher(\n-      final KsqlEngine ksqlEngine,\n       final ServiceContext serviceContext,\n       final ConfiguredStatement<Query> query,\n-      final Optional<HeartbeatAgent> heartbeatAgent,\n-      final List<RoutingFilter> routingFilters,\n-      final TheQueryExecutor pullQueryExecutor\n+      final PullQueryExecutor pullQueryExecutor\n   ) {\n-    this.ksqlEngine = requireNonNull(ksqlEngine, \"ksqlEngine\");\n     this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n     this.query = requireNonNull(query, \"query\");\n     this.pullQueryExecutor = requireNonNull(pullQueryExecutor, \"pullQueryExecutor\");\n-    this.heartbeatAgent = requireNonNull(heartbeatAgent, \"heartbeatAgent\");\n-    this.routingFilters = requireNonNull(routingFilters, \"routingFilters\");\n   }\n \n   @Override\n   public synchronized void subscribe(final Subscriber<Collection<StreamedRow>> subscriber) {\n     final PullQuerySubscription subscription = new PullQuerySubscription(\n         subscriber,\n-        () -> pullQueryExecutor.execute(\n-            query, ksqlEngine, serviceContext, heartbeatAgent, routingFilters)\n+        () -> pullQueryExecutor.execute(query, serviceContext)\n     );\n \n     subscriber.onSubscribe(subscription);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NDU1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373464556", "bodyText": "As above - it looks like it's time to for PullQueryExecutor to have a constructor.  Adding these here is just unnecessary coupling.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:52:10Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/StreamedQueryResource.java", "diffHunk": "@@ -99,20 +105,26 @@ public StreamedQueryResource(\n         commandQueueCatchupTimeout,\n         activenessRegistrar,\n         authorizationValidator,\n-        errorHandler\n+        errorHandler,\n+        heartbeatAgent,\n+        routingFilters\n     );\n   }\n \n   @VisibleForTesting\n+  // CHECKSTYLE_RULES.OFF: ParameterNumberCheck\n   StreamedQueryResource(\n+      // CHECKSTYLE_RULES.OFF: ParameterNumberCheck\n       final KsqlEngine ksqlEngine,\n       final StatementParser statementParser,\n       final CommandQueue commandQueue,\n       final Duration disconnectCheckInterval,\n       final Duration commandQueueCatchupTimeout,\n       final ActivenessRegistrar activenessRegistrar,\n       final Optional<KsqlAuthorizationValidator> authorizationValidator,\n-      final Errors errorHandler\n+      final Errors errorHandler,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1OTIzMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375059231", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T04:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NDU1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/StreamedQueryResource.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/StreamedQueryResource.java\nindex b3e100638d..5d715536a7 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/StreamedQueryResource.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/StreamedQueryResource.java\n\n@@ -124,7 +124,7 @@ public class StreamedQueryResource implements KsqlConfigurable {\n       final Optional<KsqlAuthorizationValidator> authorizationValidator,\n       final Errors errorHandler,\n       final Optional<HeartbeatAgent> heartbeatAgent,\n-      final List<RoutingFilter> routingFilters\n+      final RoutingFilter routingFilters\n   ) {\n     this.ksqlEngine = Objects.requireNonNull(ksqlEngine, \"ksqlEngine\");\n     this.statementParser = Objects.requireNonNull(statementParser, \"statementParser\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NDc1Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373464757", "bodyText": "As above.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:52:42Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/WSQueryEndpoint.java", "diffHunk": "@@ -119,7 +123,9 @@ public WSQueryEndpoint(\n       final Errors errorHandler,\n       final KsqlSecurityExtension securityExtension,\n       final ServerState serverState,\n-      final Supplier<SchemaRegistryClient> schemaRegistryClientFactory\n+      final Supplier<SchemaRegistryClient> schemaRegistryClientFactory,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/WSQueryEndpoint.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/WSQueryEndpoint.java\nindex 6dcd609093..155a1513a5 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/WSQueryEndpoint.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/WSQueryEndpoint.java\n\n@@ -125,7 +126,7 @@ public class WSQueryEndpoint {\n       final ServerState serverState,\n       final Supplier<SchemaRegistryClient> schemaRegistryClientFactory,\n       final Optional<HeartbeatAgent> heartbeatAgent,\n-      final List<RoutingFilter> routingFilters\n+      final RoutingFilter routingFilters\n   ) {\n     this(ksqlConfig,\n         mapper,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NTMyMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373465320", "bodyText": "would be nice to factor this out into a method, e.g. target. At the moment its duplicated in every method.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:54:09Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -126,4 +127,15 @@ public void makeAsyncHeartbeatRequest(\n         .orElse(target)\n         .getClusterStatus();\n   }\n+\n+  @Override\n+  public RestResponse<ActiveStandbyResponse> makeActiveStandbyRequest(final URI serverEndPoint) {\n+    final KsqlTarget target = sharedClient\n+        .target(serverEndPoint);\n+\n+    return authHeader\n+        .map(target::authorizationHeader)", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MjkwOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374952908", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T22:13:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NTMyMA=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java\nindex a6e7e10c61..e13cebb55c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java\n\n@@ -122,20 +115,23 @@ final class DefaultKsqlClient implements SimpleKsqlClient {\n     final KsqlTarget target = sharedClient\n         .target(serverEndPoint);\n \n-    return authHeader\n-        .map(target::authorizationHeader)\n-        .orElse(target)\n-        .getClusterStatus();\n+    return getTarget(target, authHeader).getClusterStatus();\n   }\n \n   @Override\n-  public RestResponse<ActiveStandbyResponse> makeActiveStandbyRequest(final URI serverEndPoint) {\n+  public void makeAsyncLagReportRequest(\n+      final URI serverEndPoint,\n+      final LagReportingMessage lagReportingMessage\n+  ) {\n     final KsqlTarget target = sharedClient\n         .target(serverEndPoint);\n \n+    getTarget(target, authHeader).postAsyncLagReportingRequest(lagReportingMessage);\n+  }\n+\n+  private KsqlTarget getTarget(final KsqlTarget target, final Optional<String> authHeader) {\n     return authHeader\n         .map(target::authorizationHeader)\n-        .orElse(target)\n-        .getActiveStandByInformation();\n+        .orElse(target);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NTY1OA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373465658", "bodyText": "static imports would make these tests more readable IMHO", "author": "big-andy-coates", "createdAt": "2020-01-31T12:55:03Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/HeartbeatAgentFunctionalTest.java", "diffHunk": "@@ -107,156 +102,63 @@ public void tearDown() {\n   @Test(timeout = 60000)\n   public void shouldMarkServersAsUp() {\n     // Given:\n-    waitForClusterToBeDiscovered();\n-    waitForRemoteServerToChangeStatus(this::remoteServerIsDown);\n+    HighAvailabilityTestUtil.waitForClusterToBeDiscovered(REST_APP_0, 2);\n+    HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus(\n+        REST_APP_0, host1, HighAvailabilityTestUtil::remoteServerIsDown);\n \n     // When:\n-    sendHeartbeartsEveryIntervalForWindowLength(100, 3000);\n-    final ClusterStatusResponse clusterStatusResponseUp = waitForRemoteServerToChangeStatus(\n-        this::remoteServerIsUp);\n+    HighAvailabilityTestUtil.sendHeartbeartsForWindowLength(REST_APP_0, host1, 3000);\n+    final ClusterStatusResponse clusterStatusResponseUp = HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus(\n+        REST_APP_0, host1, HighAvailabilityTestUtil::remoteServerIsUp);\n \n     // Then:\n-    assertThat(clusterStatusResponseUp.getClusterStatus().get(host0.toString()).getHostAlive(), is(true));\n-    assertThat(clusterStatusResponseUp.getClusterStatus().get(host1.toString()).getHostAlive(), is(true));\n+    assertThat(clusterStatusResponseUp.getClusterStatus().get(host0).getHostAlive(), is(true));\n+    assertThat(clusterStatusResponseUp.getClusterStatus().get(host1).getHostAlive(), is(true));\n   }\n \n   @Test(timeout = 60000)\n   public void shouldMarkRemoteServerAsDown() {\n     // Given:\n-    waitForClusterToBeDiscovered();\n+    HighAvailabilityTestUtil.waitForClusterToBeDiscovered(REST_APP_0, 2);\n \n     // When:\n-    ClusterStatusResponse clusterStatusResponse = waitForRemoteServerToChangeStatus(\n-        this::remoteServerIsDown);\n+    ClusterStatusResponse clusterStatusResponse = HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus(\n+        REST_APP_0, host1, HighAvailabilityTestUtil::remoteServerIsDown);\n \n     // Then:\n-    assertThat(clusterStatusResponse.getClusterStatus().get(host0.toString()).getHostAlive(), is(true));\n-    assertThat(clusterStatusResponse.getClusterStatus().get(host1.toString()).getHostAlive(), is(false));\n+    assertThat(clusterStatusResponse.getClusterStatus().get(host0).getHostAlive(), is(true));\n+    assertThat(clusterStatusResponse.getClusterStatus().get(host1).getHostAlive(), is(false));\n   }\n \n   @Test(timeout = 60000)\n   public void shouldMarkRemoteServerAsUpThenDownThenUp() {\n     // Given:\n-    waitForClusterToBeDiscovered();\n-    sendHeartbeartsEveryIntervalForWindowLength(100, 2000);\n+    HighAvailabilityTestUtil.waitForClusterToBeDiscovered(REST_APP_0, 2);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MTI2Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374951267", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T22:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NTY1OA=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/HeartbeatAgentFunctionalTest.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/HeartbeatAgentFunctionalTest.java\nindex 521698d5f1..fe58fd4fe9 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/HeartbeatAgentFunctionalTest.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/HeartbeatAgentFunctionalTest.java\n\n@@ -102,13 +107,13 @@ public class HeartbeatAgentFunctionalTest {\n   @Test(timeout = 60000)\n   public void shouldMarkServersAsUp() {\n     // Given:\n-    HighAvailabilityTestUtil.waitForClusterToBeDiscovered(REST_APP_0, 2);\n-    HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus(\n+    waitForClusterToBeDiscovered(REST_APP_0, 2);\n+    waitForRemoteServerToChangeStatus(\n         REST_APP_0, host1, HighAvailabilityTestUtil::remoteServerIsDown);\n \n     // When:\n-    HighAvailabilityTestUtil.sendHeartbeartsForWindowLength(REST_APP_0, host1, 3000);\n-    final ClusterStatusResponse clusterStatusResponseUp = HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus(\n+    sendHeartbeartsForWindowLength(REST_APP_0, host1, 3000);\n+    final ClusterStatusResponse clusterStatusResponseUp = waitForRemoteServerToChangeStatus(\n         REST_APP_0, host1, HighAvailabilityTestUtil::remoteServerIsUp);\n \n     // Then:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NzAwNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373467007", "bodyText": "Using a TemporaryFolder this way means it will never be cleaned up - i.e. the data on disk will never be deleted.\nIt think it should work if you add:\n@AfterClass\n  public static void classTearDown() {\n    TMP.delete();\n  }", "author": "big-andy-coates", "createdAt": "2020-01-31T12:58:49Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzMjkxNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375432914", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T18:33:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NzAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\nindex 61e01ca790..3e404ef57e 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n\n@@ -15,6 +15,10 @@\n \n package io.confluent.ksql.rest.integration;\n \n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendHeartbeartsForWindowLength;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize;\n import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.hasSize;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2ODMyMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373468321", "bodyText": "consider pulling common config out:\nprivate static final Map<String, Object> COMMON_CONFIG = ImmutableMap.<String, Object>builder()\n      .put(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n      .put(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n      .put(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n      .put(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n      .put(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n      .put(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n      .put(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n      .build();\n\n  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n      .builder(TEST_HARNESS::kafkaBootstrapServers)\n      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n      .withProperties(COMMON_CONFIG)\n      .build();\n\n  private static final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n      .builder(TEST_HARNESS::kafkaBootstrapServers)\n      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n      .withProperties(COMMON_CONFIG)\n      .build();\n\n  private static final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n      .builder(TEST_HARNESS::kafkaBootstrapServers)\n      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n      .withProperties(COMMON_CONFIG)\n      .build();", "author": "big-andy-coates", "createdAt": "2020-01-31T13:02:15Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+  private static final HostInfoEntity host0 = new HostInfoEntity(\"localhost\", 8088);\n+  private static final HostInfoEntity host1 = new HostInfoEntity(\"localhost\",8089);\n+  private static final HostInfoEntity host2 = new HostInfoEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static String output;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private static final String QUERY_ID = \"_confluent-ksql-default_query_CTAS_ID_0_0\";\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1OTY4NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375059684", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T04:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2ODMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\nindex 61e01ca790..3e404ef57e 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n\n@@ -15,6 +15,10 @@\n \n package io.confluent.ksql.rest.integration;\n \n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendHeartbeartsForWindowLength;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize;\n import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.hasSize;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2OTI3MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373469271", "bodyText": "why do you stop / start the servers on each test? This is going to make the tests run a lot slower!\nIf you truly need them to start / stop on each test, then change them to be a @Rule rather than a @ClassRule.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:04:52Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+  private static final HostInfoEntity host0 = new HostInfoEntity(\"localhost\", 8088);\n+  private static final HostInfoEntity host1 = new HostInfoEntity(\"localhost\",8089);\n+  private static final HostInfoEntity host2 = new HostInfoEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static String output;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private static final String QUERY_ID = \"_confluent-ksql-default_query_CTAS_ID_0_0\";\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS)\n+      .around(REST_APP_0)\n+      .around(REST_APP_1)\n+      .around(REST_APP_2);\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+\n+    //Create stream\n+    makeAdminRequest(\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    REST_APP_0.start();\n+    REST_APP_1.start();\n+    REST_APP_2.start();\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.stop();\n+    REST_APP_1.stop();\n+    REST_APP_2.stop();\n+  }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzMjg0MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375432840", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T18:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2OTI3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\nindex 61e01ca790..3e404ef57e 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n\n@@ -15,6 +15,10 @@\n \n package io.confluent.ksql.rest.integration;\n \n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendHeartbeartsForWindowLength;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize;\n import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.hasSize;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2OTY0OA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373469648", "bodyText": "Rather than having timeouts on each test us a:\n@Rule\n  @Rule\n  public final Timeout timeout = Timeout.builder()\n      .withTimeout(1, TimeUnit.MINUTE)\n      .withLookingForStuckThread(true) <-- optional.\n      .build();", "author": "big-andy-coates", "createdAt": "2020-01-31T13:05:56Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+  private static final HostInfoEntity host0 = new HostInfoEntity(\"localhost\", 8088);\n+  private static final HostInfoEntity host1 = new HostInfoEntity(\"localhost\",8089);\n+  private static final HostInfoEntity host2 = new HostInfoEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static String output;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private static final String QUERY_ID = \"_confluent-ksql-default_query_CTAS_ID_0_0\";\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS)\n+      .around(REST_APP_0)\n+      .around(REST_APP_1)\n+      .around(REST_APP_2);\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+\n+    //Create stream\n+    makeAdminRequest(\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    REST_APP_0.start();\n+    REST_APP_1.start();\n+    REST_APP_2.start();\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.stop();\n+    REST_APP_1.stop();\n+    REST_APP_2.stop();\n+  }\n+\n+  @Test(timeout = 60000)", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzNjIzMw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375436233", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T18:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2OTY0OA=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\nindex 61e01ca790..3e404ef57e 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n\n@@ -15,6 +15,10 @@\n \n package io.confluent.ksql.rest.integration;\n \n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendHeartbeartsForWindowLength;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize;\n import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.hasSize;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MDU3Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373470576", "bodyText": "This is common to each test.  Moving it to setUp would make your tests much more readable.\nIn general, try to make your tests read like a storey.  The test body should only have the important bits in the Given section, i.e. the bits that set up this test in a specific way, not the general setup.  This makes it much easier to see what it is about the test setup that is different and influencing the result.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:08:33Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+  private static final HostInfoEntity host0 = new HostInfoEntity(\"localhost\", 8088);\n+  private static final HostInfoEntity host1 = new HostInfoEntity(\"localhost\",8089);\n+  private static final HostInfoEntity host2 = new HostInfoEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static String output;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private static final String QUERY_ID = \"_confluent-ksql-default_query_CTAS_ID_0_0\";\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS)\n+      .around(REST_APP_0)\n+      .around(REST_APP_1)\n+      .around(REST_APP_2);\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+\n+    //Create stream\n+    makeAdminRequest(\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    REST_APP_0.start();\n+    REST_APP_1.start();\n+    REST_APP_2.start();\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.stop();\n+    REST_APP_1.stop();\n+    REST_APP_2.stop();\n+  }\n+\n+  @Test(timeout = 60000)\n+  public void shouldQueryActiveWhenActiveAliveQueryIssuedToStandby() {\n+    // Given:\n+    final String key = Iterables.get(USER_PROVIDER.data().keySet(), 0);\n+    final String sql = \"SELECT * FROM \" + output + \" WHERE ROWKEY = '\" + key + \"';\";\n+    makeAdminRequest(\n+        \"CREATE TABLE \" + output + \" AS\"\n+            + \" SELECT COUNT(1) AS COUNT FROM \" + USERS_STREAM\n+            + \" GROUP BY \" + USER_PROVIDER.key() + \";\"\n+    );\n+    waitForTableRows();\n+    HighAvailabilityTestUtil.waitForClusterToBeDiscovered(REST_APP_0, 3);\n+    HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize(\n+        REST_APP_0, ImmutableList.of(host0, host1, host2), QUERY_ID);\n+    ClusterFormation clusterFormation = findClusterFormation();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzNjMyNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375436324", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T18:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MDU3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\nindex 61e01ca790..3e404ef57e 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n\n@@ -15,6 +15,10 @@\n \n package io.confluent.ksql.rest.integration;\n \n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendHeartbeartsForWindowLength;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize;\n import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.hasSize;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MTQ5NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373471495", "bodyText": "how about:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(heartbeatAgent.getHostsStatus().containsKey(remoteHostInfo), is(true));\n          \n          \n            \n                assertThat(heartbeatAgent.getHostsStatus(), hasKey(remoteHostInfo));", "author": "big-andy-coates", "createdAt": "2020-01-31T13:10:56Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/HeartbeatAgentTest.java", "diffHunk": "@@ -100,7 +97,7 @@ public void shouldDiscoverServersInCluster() {\n     discoverService.runOneIteration();\n \n     // Then:\n-    assertThat(heartbeatAgent.getHostsStatus().keySet().contains(remoteHostInfo.toString()), is(true));\n+    assertThat(heartbeatAgent.getHostsStatus().containsKey(remoteHostInfo), is(true));", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/HeartbeatAgentTest.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/HeartbeatAgentTest.java\nindex 47b490e404..78ff1c57d9 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/HeartbeatAgentTest.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/HeartbeatAgentTest.java\n\n@@ -97,7 +103,7 @@ public class HeartbeatAgentTest {\n     discoverService.runOneIteration();\n \n     // Then:\n-    assertThat(heartbeatAgent.getHostsStatus().containsKey(remoteHostInfo), is(true));\n+    assertThat(heartbeatAgent.getHostsStatus(), hasKey(remoteHost));\n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MTc1NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373471754", "bodyText": "nit: remove.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:11:35Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/TestKsqlRestApp.java", "diffHunk": "@@ -400,6 +400,7 @@ private static KsqlRestConfig buildConfig(\n \n     config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers.get());\n     config.putIfAbsent(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:0,https://localhost:0\");\n+    //config.putIfAbsent(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:1234\");", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/TestKsqlRestApp.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/TestKsqlRestApp.java\nindex 2ea7fdc97d..508a9308c9 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/TestKsqlRestApp.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/TestKsqlRestApp.java\n\n@@ -400,7 +399,6 @@ public class TestKsqlRestApp extends ExternalResource {\n \n     config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers.get());\n     config.putIfAbsent(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:0,https://localhost:0\");\n-    //config.putIfAbsent(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:1234\");\n     return new KsqlRestConfig(config);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MzIyNQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373473225", "bodyText": "this is actually storing topic-partitions, right?  In the form <topic-name>-<partition-number> and its relying on TopicPartition.toString()` to build that string, which we don't control.\nMuch better to have Set<TopicPartitionEntity> so we / others don't need to parse the string and we're decoupled from any changes to TopicPartition.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:15:02Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.entity;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class ActiveStandbyEntity {\n+\n+  private final Set<String> activeStores;\n+  private final Set<String> activePartitions;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0OTU4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374949589", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T22:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MzIyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java\nindex 18d4ed36c0..35fb4726c9 100644\n--- a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java\n+++ b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java\n\n@@ -21,23 +21,25 @@ import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.google.common.collect.ImmutableSet;\n+import com.google.errorprone.annotations.Immutable;\n import java.util.Objects;\n import java.util.Set;\n \n+@Immutable\n @JsonIgnoreProperties(ignoreUnknown = true)\n public class ActiveStandbyEntity {\n \n-  private final Set<String> activeStores;\n-  private final Set<String> activePartitions;\n-  private final Set<String> standByStores;\n-  private final Set<String> standByPartitions;\n+  private final ImmutableSet<String> activeStores;\n+  private final ImmutableSet<TopicPartitionEntity> activePartitions;\n+  private final ImmutableSet<String> standByStores;\n+  private final ImmutableSet<TopicPartitionEntity> standByPartitions;\n \n   @JsonCreator\n   public ActiveStandbyEntity(\n       @JsonProperty(\"activeStores\") final Set<String> activeStores,\n-      @JsonProperty(\"activePartitions\") final Set<String> activePartitions,\n+      @JsonProperty(\"activePartitions\") final Set<TopicPartitionEntity> activePartitions,\n       @JsonProperty(\"standByStores\") final Set<String> standByStores,\n-      @JsonProperty(\"standByPartitions\") final Set<String> standByPartitions\n+      @JsonProperty(\"standByPartitions\") final Set<TopicPartitionEntity> standByPartitions\n   ) {\n     this.activeStores = ImmutableSet.copyOf(requireNonNull(activeStores));\n     this.activePartitions = ImmutableSet.copyOf(requireNonNull(activePartitions));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MzYxMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373473612", "bodyText": "Can we make this immutable please?\nYou'll need to make the fields ImmutableSet.\n(Run ImmutableTest to ensure everything is good)", "author": "big-andy-coates", "createdAt": "2020-01-31T13:16:02Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.entity;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class ActiveStandbyEntity {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1NTc3OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375055779", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T04:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MzYxMg=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java\nindex 18d4ed36c0..35fb4726c9 100644\n--- a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java\n+++ b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java\n\n@@ -21,23 +21,25 @@ import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.google.common.collect.ImmutableSet;\n+import com.google.errorprone.annotations.Immutable;\n import java.util.Objects;\n import java.util.Set;\n \n+@Immutable\n @JsonIgnoreProperties(ignoreUnknown = true)\n public class ActiveStandbyEntity {\n \n-  private final Set<String> activeStores;\n-  private final Set<String> activePartitions;\n-  private final Set<String> standByStores;\n-  private final Set<String> standByPartitions;\n+  private final ImmutableSet<String> activeStores;\n+  private final ImmutableSet<TopicPartitionEntity> activePartitions;\n+  private final ImmutableSet<String> standByStores;\n+  private final ImmutableSet<TopicPartitionEntity> standByPartitions;\n \n   @JsonCreator\n   public ActiveStandbyEntity(\n       @JsonProperty(\"activeStores\") final Set<String> activeStores,\n-      @JsonProperty(\"activePartitions\") final Set<String> activePartitions,\n+      @JsonProperty(\"activePartitions\") final Set<TopicPartitionEntity> activePartitions,\n       @JsonProperty(\"standByStores\") final Set<String> standByStores,\n-      @JsonProperty(\"standByPartitions\") final Set<String> standByPartitions\n+      @JsonProperty(\"standByPartitions\") final Set<TopicPartitionEntity> standByPartitions\n   ) {\n     this.activeStores = ImmutableSet.copyOf(requireNonNull(activeStores));\n     this.activePartitions = ImmutableSet.copyOf(requireNonNull(activePartitions));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3Mzc2Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373473762", "bodyText": "to be immutable ActiveStandbyEntity must be immutable too.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:16:29Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyResponse.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.entity;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.Immutable;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Immutable", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2327c7a98e878b3278785170a6ce004859f2db7c", "chunk": "diff --git a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyResponse.java b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/LagReportingResponse.java\nsimilarity index 63%\nrename from ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyResponse.java\nrename to ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/LagReportingResponse.java\nindex 8ad1925335..fb241d42d8 100644\n--- a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyResponse.java\n+++ b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/LagReportingResponse.java\n\n@@ -15,30 +15,27 @@\n \n package io.confluent.ksql.rest.entity;\n \n-import static java.util.Objects.requireNonNull;\n-\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import com.google.common.collect.ImmutableMap;\n import com.google.errorprone.annotations.Immutable;\n-import java.util.Map;\n import java.util.Objects;\n \n-@JsonIgnoreProperties(ignoreUnknown = true)\n @Immutable\n-public class ActiveStandbyResponse {\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class LagReportingResponse {\n \n-  private final ImmutableMap<String, ActiveStandbyEntity> perQueryInfo;\n+  private final boolean isOk;\n \n   @JsonCreator\n-  public ActiveStandbyResponse(\n-      @JsonProperty(\"perQueryInfo\") final Map<String, ActiveStandbyEntity> perQueryInfo) {\n-    this.perQueryInfo = ImmutableMap.copyOf(requireNonNull(perQueryInfo, \"perQueryInfo\"));\n+  public LagReportingResponse(\n+      @JsonProperty(\"ok\") final boolean ok\n+  ) {\n+    this.isOk = ok;\n   }\n \n-  public Map<String, ActiveStandbyEntity> getPerQueryInfo() {\n-    return perQueryInfo;\n+  public boolean getIsOk() {\n+    return isOk;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NTIyMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373475222", "bodyText": "This will throw a number parsing error if the second part is not a number, which ain't nice.\nHow about:\nCan we throw a more descriptive exception here? e.g. \n\n```java\nfinal String [] parts = serializedPair.split(\":\");\nif (parts.length != 2) {\n   throw new KsqlException(\"Invalid host info. Expected format: <hostname>:<port>, but was \" + seirlizedPair;\n}\n\nthis.host = Objects.requireNonNull(parts[0], \"host\");\n\ntry {\n   this.port = Integer.parseInt(parts[1]);\n} catch (final Exception e) {\n   throw new KsqlException(\"Invalid host info. Expected format: <hostname>:<port>, but was \" + seirlizedPair, e);\n}", "author": "big-andy-coates", "createdAt": "2020-01-31T13:20:32Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostInfoEntity.java", "diffHunk": "@@ -26,15 +27,22 @@\n   private final String host;\n   private final int port;\n \n-  @JsonCreator\n   public HostInfoEntity(\n-      @JsonProperty(\"host\") final String host,\n-      @JsonProperty(\"port\") final int port\n+      final String host,\n+      final int port\n   ) {\n     this.host = Objects.requireNonNull(host, \"host\");\n     this.port = Objects.requireNonNull(port, \"port\");\n   }\n \n+  @JsonCreator\n+  public HostInfoEntity(final String serializedPair) {\n+    final String [] parts = serializedPair.split(\":\");\n+    Preconditions.checkArgument(parts.length == 2);\n+    this.host = Objects.requireNonNull(parts[0], \"host\");\n+    this.port = Integer.parseInt(parts[1]);\n+  }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostInfoEntity.java b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/KsqlHostEntity.java\nsimilarity index 66%\nrename from ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostInfoEntity.java\nrename to ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/KsqlHostEntity.java\nindex 6ed227de08..06853bddb5 100644\n--- a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostInfoEntity.java\n+++ b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/KsqlHostEntity.java\n\n@@ -18,29 +18,42 @@ package io.confluent.ksql.rest.entity;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n import com.fasterxml.jackson.annotation.JsonValue;\n-import com.google.common.base.Preconditions;\n+import com.google.errorprone.annotations.Immutable;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlHost;\n import java.util.Objects;\n \n+@Immutable\n @JsonIgnoreProperties(ignoreUnknown = true)\n-public class HostInfoEntity {\n+public class KsqlHostEntity {\n \n   private final String host;\n   private final int port;\n \n-  public HostInfoEntity(\n+  public KsqlHostEntity(\n       final String host,\n       final int port\n   ) {\n     this.host = Objects.requireNonNull(host, \"host\");\n-    this.port = Objects.requireNonNull(port, \"port\");\n+    this.port = port;\n   }\n \n   @JsonCreator\n-  public HostInfoEntity(final String serializedPair) {\n+  public KsqlHostEntity(final String serializedPair) {\n     final String [] parts = serializedPair.split(\":\");\n-    Preconditions.checkArgument(parts.length == 2);\n+    if (parts.length != 2) {\n+      throw new KsqlException(\"Invalid host info. Expected format: <hostname>:<port>, but was \"\n+                                  + serializedPair);\n+    }\n+\n     this.host = Objects.requireNonNull(parts[0], \"host\");\n-    this.port = Integer.parseInt(parts[1]);\n+\n+    try {\n+      this.port = Integer.parseInt(parts[1]);\n+    } catch (final Exception e) {\n+      throw new KsqlException(\"Invalid port. Expected format: <hostname>:<port>, but was \"\n+                                  + serializedPair, e);\n+    }\n   }\n \n   public String getHost() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NTM1NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373475354", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:20:53Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java", "diffHunk": "@@ -18,28 +18,26 @@\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.Map;\n import java.util.Objects;\n \n @JsonIgnoreProperties(ignoreUnknown = true)\n public class HostStatusEntity {\n \n-  private HostInfoEntity hostInfoEntity;\n   private boolean hostAlive;\n   private long lastStatusUpdateMs;\n+  private Map<String, ActiveStandbyEntity> perQueryActiveStandbyEntity;\n \n   @JsonCreator\n   public HostStatusEntity(\n-      @JsonProperty(\"hostInfoEntity\") final HostInfoEntity hostInfoEntity,\n       @JsonProperty(\"hostAlive\") final boolean hostAlive,\n-      @JsonProperty(\"lastStatusUpdateMs\") final long lastStatusUpdateMs\n+      @JsonProperty(\"lastStatusUpdateMs\") final long lastStatusUpdateMs,\n+      @JsonProperty(\"perQueryActiveStandbyEntity\")\n+      final Map<String, ActiveStandbyEntity> perQueryActiveStandbyEntity\n   ) {\n-    this.hostInfoEntity = Objects.requireNonNull(hostInfoEntity, \"hostInfoEntity\");\n     this.hostAlive = hostAlive;\n     this.lastStatusUpdateMs = lastStatusUpdateMs;\n-  }\n-\n-  public HostInfoEntity getHostInfoEntity() {\n-    return hostInfoEntity;\n+    this.perQueryActiveStandbyEntity = perQueryActiveStandbyEntity;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1NTgyMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375055822", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T04:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NTM1NA=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java\nindex 9aff60d12f..488ddacc0d 100644\n--- a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java\n+++ b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java\n\n@@ -18,26 +18,33 @@ package io.confluent.ksql.rest.entity;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.Immutable;\n import java.util.Map;\n import java.util.Objects;\n \n+@Immutable\n @JsonIgnoreProperties(ignoreUnknown = true)\n public class HostStatusEntity {\n \n   private boolean hostAlive;\n   private long lastStatusUpdateMs;\n-  private Map<String, ActiveStandbyEntity> perQueryActiveStandbyEntity;\n+  private ImmutableMap<String, ActiveStandbyEntity> activeStandbyPerQuery;\n+  private HostStoreLags hostStoreLags;\n \n   @JsonCreator\n   public HostStatusEntity(\n       @JsonProperty(\"hostAlive\") final boolean hostAlive,\n       @JsonProperty(\"lastStatusUpdateMs\") final long lastStatusUpdateMs,\n-      @JsonProperty(\"perQueryActiveStandbyEntity\")\n-      final Map<String, ActiveStandbyEntity> perQueryActiveStandbyEntity\n+      @JsonProperty(\"activeStandbyPerQuery\")\n+      final Map<String, ActiveStandbyEntity> activeStandbyPerQuery,\n+      @JsonProperty(\"hostStoreLags\") final HostStoreLags hostStoreLags\n   ) {\n     this.hostAlive = hostAlive;\n     this.lastStatusUpdateMs = lastStatusUpdateMs;\n-    this.perQueryActiveStandbyEntity = perQueryActiveStandbyEntity;\n+    this.activeStandbyPerQuery = ImmutableMap.copyOf(Objects.requireNonNull(\n+        activeStandbyPerQuery, \"activeStandbyPerQuery\"));\n+    this.hostStoreLags = Objects.requireNonNull(hostStoreLags, \"hostStoreLags\");\n   }\n \n   public boolean getHostAlive() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NTcyMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373475720", "bodyText": "Can we make this type immutable please?\nChange this to a withPerQueryActiveStandbyEntity that returns a new instance.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:21:48Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java", "diffHunk": "@@ -62,6 +60,11 @@ public void setLastStatusUpdateMs(final long lastStatusUpdateMs) {\n     this.lastStatusUpdateMs = lastStatusUpdateMs;\n   }\n \n+  public void setPerQueryActiveStandbyEntity(\n+      final Map<String, ActiveStandbyEntity> perQueryActiveStandbyEntity) {\n+    this.perQueryActiveStandbyEntity = perQueryActiveStandbyEntity;\n+  }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java\nindex 9aff60d12f..488ddacc0d 100644\n--- a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java\n+++ b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java\n\n@@ -48,21 +55,12 @@ public class HostStatusEntity {\n     return lastStatusUpdateMs;\n   }\n \n-  public Map<String, ActiveStandbyEntity> getPerQueryActiveStandbyEntity() {\n-    return perQueryActiveStandbyEntity;\n+  public ImmutableMap<String, ActiveStandbyEntity> getActiveStandbyPerQuery() {\n+    return activeStandbyPerQuery;\n   }\n \n-  public void setHostAlive(final boolean hostAlive) {\n-    this.hostAlive = hostAlive;\n-  }\n-\n-  public void setLastStatusUpdateMs(final long lastStatusUpdateMs) {\n-    this.lastStatusUpdateMs = lastStatusUpdateMs;\n-  }\n-\n-  public void setPerQueryActiveStandbyEntity(\n-      final Map<String, ActiveStandbyEntity> perQueryActiveStandbyEntity) {\n-    this.perQueryActiveStandbyEntity = perQueryActiveStandbyEntity;\n+  public HostStoreLags getHostStoreLags() {\n+    return hostStoreLags;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NjU5Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373476593", "bodyText": "Can we avoid StringBuilder in toString please:\n@Override\n  public String toString() {\n    return \"ActiveAndStandByNodes{\" +\n        \"active=\" + active +\n        \", standBys=\" + standBys +\n        '}';\n  }", "author": "big-andy-coates", "createdAt": "2020-01-31T13:24:14Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/ActiveAndStandByNodes.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams.materialization.ks;\n+\n+import io.confluent.ksql.execution.streams.materialization.Locator.KsqlNode;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ActiveAndStandByNodes {\n+\n+  private final KsqlNode active;\n+  private final Set<KsqlNode> standBys;\n+\n+  public ActiveAndStandByNodes(final KsqlNode active) {\n+    this.active = Objects.requireNonNull(active, \"active\");\n+    this.standBys = new HashSet<>();\n+  }\n+\n+  public KsqlNode getActive() {\n+    return active;\n+  }\n+\n+  public Set<KsqlNode> getStandBys() {\n+    return standBys;\n+  }\n+\n+  public void addStandBy(final KsqlNode standBy) {\n+    this.standBys.add(standBy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return new StringBuilder()\n+        .append(String.format(\"active = %s ,\", active))\n+        .append(String.format(\"stanbys = %s .\", standBys))\n+        .toString();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4NzQ5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374487496", "bodyText": "This class no longer exists", "author": "vpapavas", "createdAt": "2020-02-04T06:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NjU5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/ActiveAndStandByNodes.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/ActiveAndStandByNodes.java\ndeleted file mode 100644\nindex 0d836a786a..0000000000\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/ActiveAndStandByNodes.java\n+++ /dev/null\n\n@@ -1,52 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.execution.streams.materialization.ks;\n-\n-import io.confluent.ksql.execution.streams.materialization.Locator.KsqlNode;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-public class ActiveAndStandByNodes {\n-\n-  private final KsqlNode active;\n-  private final Set<KsqlNode> standBys;\n-\n-  public ActiveAndStandByNodes(final KsqlNode active) {\n-    this.active = Objects.requireNonNull(active, \"active\");\n-    this.standBys = new HashSet<>();\n-  }\n-\n-  public KsqlNode getActive() {\n-    return active;\n-  }\n-\n-  public Set<KsqlNode> getStandBys() {\n-    return standBys;\n-  }\n-\n-  public void addStandBy(final KsqlNode standBy) {\n-    this.standBys.add(standBy);\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return new StringBuilder()\n-        .append(String.format(\"active = %s ,\", active))\n-        .append(String.format(\"stanbys = %s .\", standBys))\n-        .toString();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3Njg1OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373476859", "bodyText": "Is it possible to make this type immutable?  e.g. use a builder pattern, or have this return a new instance?\nIs this method called?", "author": "big-andy-coates", "createdAt": "2020-01-31T13:24:58Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/ActiveAndStandByNodes.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams.materialization.ks;\n+\n+import io.confluent.ksql.execution.streams.materialization.Locator.KsqlNode;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ActiveAndStandByNodes {\n+\n+  private final KsqlNode active;\n+  private final Set<KsqlNode> standBys;\n+\n+  public ActiveAndStandByNodes(final KsqlNode active) {\n+    this.active = Objects.requireNonNull(active, \"active\");\n+    this.standBys = new HashSet<>();\n+  }\n+\n+  public KsqlNode getActive() {\n+    return active;\n+  }\n+\n+  public Set<KsqlNode> getStandBys() {\n+    return standBys;\n+  }\n+\n+  public void addStandBy(final KsqlNode standBy) {\n+    this.standBys.add(standBy);\n+  }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/ActiveAndStandByNodes.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/ActiveAndStandByNodes.java\ndeleted file mode 100644\nindex 0d836a786a..0000000000\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/ActiveAndStandByNodes.java\n+++ /dev/null\n\n@@ -1,52 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.execution.streams.materialization.ks;\n-\n-import io.confluent.ksql.execution.streams.materialization.Locator.KsqlNode;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-public class ActiveAndStandByNodes {\n-\n-  private final KsqlNode active;\n-  private final Set<KsqlNode> standBys;\n-\n-  public ActiveAndStandByNodes(final KsqlNode active) {\n-    this.active = Objects.requireNonNull(active, \"active\");\n-    this.standBys = new HashSet<>();\n-  }\n-\n-  public KsqlNode getActive() {\n-    return active;\n-  }\n-\n-  public Set<KsqlNode> getStandBys() {\n-    return standBys;\n-  }\n-\n-  public void addStandBy(final KsqlNode standBy) {\n-    this.standBys.add(standBy);\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return new StringBuilder()\n-        .append(String.format(\"active = %s ,\", active))\n-        .append(String.format(\"stanbys = %s .\", standBys))\n-        .toString();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NzAwMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373477002", "bodyText": "Use string concat.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:25:18Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -114,5 +160,34 @@ public boolean isLocal() {\n     public URI location() {\n       return location;\n     }\n+\n+    @Override\n+    public String toString() {\n+      return new StringBuilder()\n+          .append(String.format(\"local = %s ,\", local))\n+          .append(String.format(\"location = %s ,\", location))\n+          .toString();\n+    }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\nindex 877da8d207..514427d78f 100644\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n+++ b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n\n@@ -163,10 +164,10 @@ final class KsLocator implements Locator {\n \n     @Override\n     public String toString() {\n-      return new StringBuilder()\n-          .append(String.format(\"local = %s ,\", local))\n-          .append(String.format(\"location = %s ,\", location))\n-          .toString();\n+      return \"Node{\"\n+          + \"local = \" + local\n+          + \", location = \" + location\n+          + \"}\";\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NzgyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373477828", "bodyText": "add a test that the third boolean parameter is actually being passed correctly.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:27:22Z", "path": "ksql-streams/src/test/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStoreTest.java", "diffHunk": "@@ -211,7 +213,7 @@ public void shouldReturnSessionStore() {\n   public void shouldReturnWindowStore() {\n     // Given:\n     final ReadOnlyWindowStore<?, ?> windowStore = mock(ReadOnlyWindowStore.class);\n-    when(kafkaStreams.store(any(), any())).thenReturn(windowStore);\n+    when(kafkaStreams.store(any(), any(), anyBoolean())).thenReturn(windowStore);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-streams/src/test/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStoreTest.java b/ksql-streams/src/test/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStoreTest.java\nindex cc2fa08d8d..efd7a6399a 100644\n--- a/ksql-streams/src/test/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStoreTest.java\n+++ b/ksql-streams/src/test/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStoreTest.java\n\n@@ -213,7 +211,7 @@ public class KsStateStoreTest {\n   public void shouldReturnWindowStore() {\n     // Given:\n     final ReadOnlyWindowStore<?, ?> windowStore = mock(ReadOnlyWindowStore.class);\n-    when(kafkaStreams.store(any(), any(), anyBoolean())).thenReturn(windowStore);\n+    when(kafkaStreams.store(any())).thenReturn(windowStore);\n \n     // When:\n     final ReadOnlyWindowStore<Boolean, String> result = store\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2MDMxNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373560314", "bodyText": "I feel like we should change this config to something like enable.standby.reads because (optimistically) in the future we may have some stronger sense of consistency and define what \"stale\" means. It also may not be stale if the update rate is slow and the standbys are caught up", "author": "agavra", "createdAt": "2020-01-31T16:13:05Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -165,12 +165,25 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n+  // Shall we remove this config?\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n       \"ksql.query.pull.routing.timeout.ms\";\n   public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n       + \"when waiting for the lookup of the owner of a row key\";\n \n+\n+  public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n+      \"ksql.query.pull.enable.stale.reads\";", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NDM5Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374494392", "bodyText": "+1 standbys can actually be caught up.not necessarily stale", "author": "vinothchandar", "createdAt": "2020-02-04T06:32:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2MDMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA2MzA2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375063063", "bodyText": "Changed to standby", "author": "vpapavas", "createdAt": "2020-02-05T05:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2MDMxNA=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\nindex 1bb5bcec9d..531380bb81 100644\n--- a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n+++ b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n\n@@ -165,16 +167,8 @@ public class KsqlConfig extends AbstractConfig {\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n-  // Shall we remove this config?\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n-      \"ksql.query.pull.routing.timeout.ms\";\n-  public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n-      + \"when waiting for the lookup of the owner of a row key\";\n-\n-\n   public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n-      \"ksql.query.pull.enable.stale.reads\";\n+        \"ksql.query.pull.enable.stale.reads\";\n   private static final String KSQL_QUERY_PULL_ENABLE_STALE_READS_DOC =\n       \"Config to enable/disable forwarding pull queries to standby hosts when the active is dead. \"\n           + \"Effectively, the accuracy of pull queries is sacrificed for higher availability. \"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2NDU2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373564563", "bodyText": "nit: instead of writing this in a comment, enforce it \ud83d\ude04\nPreconditions.ensureState(immutableHostsStatus.get().isEmpty(), \"expected empty host info on startup\");", "author": "agavra", "createdAt": "2020-01-31T16:21:30Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -157,37 +154,18 @@ void stopAgent() {\n \n   void setLocalAddress(final String applicationServer) {\n \n-    this.localHostInfo = parseHostInfo(applicationServer);\n-    this.localHostString = localHostInfo.toString();\n+    this.localHostInfo = ServerUtil.parseHostInfo(applicationServer);\n     try {\n       this.localURL = new URL(applicationServer);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Failed to convert remote host info to URL.\"\n                                           + \" remoteInfo: \" + localHostInfo.host() + \":\"\n                                           + localHostInfo.host());\n     }\n-    this.hostsStatus.putIfAbsent(localHostString, new HostStatusEntity(\n-        new HostInfoEntity(localHostInfo.host(), localHostInfo.port()),\n-        true,\n-        clock.millis()));\n+    //This is called on startup of the heartbeat agent, no other entries should exist in the map", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\nindex 646250301c..96c2743fe2 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n\n@@ -153,17 +155,18 @@ public final class HeartbeatAgent {\n   }\n \n   void setLocalAddress(final String applicationServer) {\n-\n-    this.localHostInfo = ServerUtil.parseHostInfo(applicationServer);\n+    final HostInfo hostInfo = ServerUtil.parseHostInfo(applicationServer);\n+    this.localHost = new KsqlHost(hostInfo.host(), hostInfo.port());\n     try {\n-      this.localURL = new URL(applicationServer);\n+      this.localUrl = new URL(applicationServer);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Failed to convert remote host info to URL.\"\n-                                          + \" remoteInfo: \" + localHostInfo.host() + \":\"\n-                                          + localHostInfo.host());\n+                                          + \" remoteInfo: \" + localHost.host() + \":\"\n+                                          + localHost.host());\n     }\n     //This is called on startup of the heartbeat agent, no other entries should exist in the map\n-    immutableHostsStatus.set(ImmutableMap.of(localHostInfo, new HostStatus(true, clock.millis())));\n+    Preconditions.checkState(hostsStatus.isEmpty(), \"expected empty host status map on startup\");\n+    hostsStatus.putIfAbsent(localHost, new HostStatus(true, clock.millis()));\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2NTU1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373565556", "bodyText": "note that this doesn't do a deep copy, so andy's comment (https://github.com/confluentinc/ksql/pull/4398/files#r372567512) is extra important, otherwise even though the map is immutable the entries within the map would be mutable (e.g. L220 actually affects the source map too!)", "author": "agavra", "createdAt": "2020-01-31T16:23:26Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -233,42 +211,50 @@ protected ScheduledExecutorService executor() {\n      * @param windowEnd the end time in ms of the current window\n      */\n     private void processHeartbeats(final long windowStart, final long windowEnd) {\n+\n+      final Map<HostInfo, HostStatus> copyOnWrite = new HashMap<>(immutableHostsStatus.get());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxMTgxMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373711812", "bodyText": "Yes, @AlanConfluent's PR and the subsequent merge of our both PR's adds the immutable internal objects. We wanted to do it one place to make merging easier but I guess it doesn't because it complicates reviewing. I am making all the internal ones immutable as well", "author": "vpapavas", "createdAt": "2020-01-31T22:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2NTU1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\nindex 646250301c..96c2743fe2 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n\n@@ -212,47 +215,51 @@ public final class HeartbeatAgent {\n      */\n     private void processHeartbeats(final long windowStart, final long windowEnd) {\n \n-      final Map<HostInfo, HostStatus> copyOnWrite = new HashMap<>(immutableHostsStatus.get());\n       // No heartbeats received -> mark all hosts as dead\n       if (receivedHeartbeats.isEmpty()) {\n-        copyOnWrite.forEach((host, status) -> {\n-          if (!host.equals(localHostInfo)) {\n-            status.setHostAlive(false);\n+        hostsStatus.replaceAll((host, status) -> {\n+          if (!host.equals(localHost)) {\n+            return status.withHostAlive(false);\n           }\n+          return status;\n         });\n-        immutableHostsStatus.set(new ImmutableMap.Builder<HostInfo, HostStatus>()\n-                                     .putAll(copyOnWrite).build());\n         return;\n       }\n \n-      for (Entry<HostInfo, HostStatus> hostEntry: copyOnWrite.entrySet()) {\n-        final HostInfo hostInfo = hostEntry.getKey();\n+      for (Entry<KsqlHost, HostStatus> hostEntry: hostsStatus.entrySet()) {\n+        final KsqlHost ksqlHost = hostEntry.getKey();\n         final HostStatus hostStatus = hostEntry.getValue();\n-        if (hostInfo.equals(localHostInfo)) {\n+        if (ksqlHost.equals(localHost)) {\n           continue;\n         }\n-        final TreeMap<Long, HeartbeatInfo> heartbeats = receivedHeartbeats.get(hostInfo);\n+        final TreeMap<Long, HeartbeatInfo> heartbeats = receivedHeartbeats.get(ksqlHost);\n         //For previously discovered hosts, if they have not received any heartbeats, mark them dead\n         if (heartbeats == null || heartbeats.isEmpty()) {\n-          copyOnWrite.get(hostInfo).setHostAlive(false);\n+          hostsStatus.computeIfPresent(ksqlHost, (host, status) -> status.withHostAlive(false));\n         } else {\n           final TreeMap<Long, HeartbeatInfo> copy;\n           synchronized (heartbeats) {\n-            LOG.debug(\"Process heartbeats: {} of host: {}\", heartbeats, hostInfo);\n+            LOG.debug(\"Process heartbeats: {} of host: {}\", heartbeats, ksqlHost);\n             // 1. remove heartbeats older than window\n             heartbeats.headMap(windowStart).clear();\n             copy = new TreeMap<>(heartbeats.subMap(windowStart, true, windowEnd, true));\n           }\n           // 2. count consecutive missed heartbeats and mark as alive or dead\n-          final  boolean isAlive = decideStatus(hostInfo, windowStart, windowEnd, copy);\n-          hostStatus.setHostAlive(isAlive);\n-          hostStatus.setLastStatusUpdateMs(windowEnd);\n+          final  boolean isAlive = decideStatus(ksqlHost, windowStart, windowEnd, copy);\n+          if (!isAlive) {\n+            LOG.info(\"Host: {} marked as dead.\", ksqlHost);\n+          }\n+          hostsStatus.computeIfPresent(ksqlHost, (host, status) -> status\n+              .withHostAlive(isAlive).withLastStatusUpdateMs(windowEnd));\n         }\n       }\n+      for (HostStatusListener listener : hostStatusListeners) {\n+        listener.onHostStatusUpdated(getHostsStatus());\n+      }\n     }\n \n     private boolean decideStatus(\n-        final HostInfo hostInfo, final long windowStart, final long windowEnd,\n+        final KsqlHost ksqlHost, final long windowStart, final long windowEnd,\n         final TreeMap<Long, HeartbeatInfo> heartbeats\n     ) {\n       long missedCount = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2ODUyNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373568524", "bodyText": "I would be more comfortable if we split this into two PRs: the first makes the concurrency model clearer (avoiding concurrent maps, doing copy-on-write) and the second implementing the pull query routing. that way we can focus on each individual problem", "author": "agavra", "createdAt": "2020-01-31T16:29:09Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -105,7 +101,8 @@ private HeartbeatAgent(final KsqlEngine engine,\n     this.serviceManager = new ServiceManager(Arrays.asList(\n         new DiscoverClusterService(), new SendHeartbeatService(), new CheckHeartbeatService()));\n     this.receivedHeartbeats = new ConcurrentHashMap<>();\n-    this.hostsStatus = new ConcurrentHashMap<>();\n+    this.immutableHostsStatus = new AtomicReference<>();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\nindex 646250301c..96c2743fe2 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n\n@@ -92,17 +94,18 @@ public final class HeartbeatAgent {\n \n   private HeartbeatAgent(final KsqlEngine engine,\n                          final ServiceContext serviceContext,\n-                         final HeartbeatConfig config) {\n+                         final HeartbeatConfig config,\n+                         final List<HostStatusListener> hostStatusListeners) {\n \n     this.engine = requireNonNull(engine, \"engine\");\n     this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n     this.config = requireNonNull(config, \"configuration parameters\");\n+    this.hostStatusListeners = requireNonNull(hostStatusListeners, \"heartbeatListeners\");\n     this.scheduledExecutorService = Executors.newScheduledThreadPool(config.threadPoolSize);\n     this.serviceManager = new ServiceManager(Arrays.asList(\n         new DiscoverClusterService(), new SendHeartbeatService(), new CheckHeartbeatService()));\n     this.receivedHeartbeats = new ConcurrentHashMap<>();\n-    this.immutableHostsStatus = new AtomicReference<>();\n-    immutableHostsStatus.set(ImmutableMap.of());\n+    this.hostsStatus = new ConcurrentHashMap<>();\n     this.clock = Clock.systemUTC();\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NTY4MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374495680", "bodyText": "reword: Effectively, stale values may be returned for some keys sacrificing consistency for higher availability. ?", "author": "vinothchandar", "createdAt": "2020-02-04T06:37:31Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -165,12 +165,25 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n+  // Shall we remove this config?\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n       \"ksql.query.pull.routing.timeout.ms\";\n   public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n       + \"when waiting for the lookup of the owner of a row key\";\n \n+\n+  public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n+      \"ksql.query.pull.enable.stale.reads\";\n+  private static final String KSQL_QUERY_PULL_ENABLE_STALE_READS_DOC =\n+      \"Config to enable/disable forwarding pull queries to standby hosts when the active is dead. \"\n+          + \"Effectively, the accuracy of pull queries is sacrificed for higher availability. \"", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\nindex 1bb5bcec9d..531380bb81 100644\n--- a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n+++ b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n\n@@ -165,16 +167,8 @@ public class KsqlConfig extends AbstractConfig {\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n-  // Shall we remove this config?\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n-      \"ksql.query.pull.routing.timeout.ms\";\n-  public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n-      + \"when waiting for the lookup of the owner of a row key\";\n-\n-\n   public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n-      \"ksql.query.pull.enable.stale.reads\";\n+        \"ksql.query.pull.enable.stale.reads\";\n   private static final String KSQL_QUERY_PULL_ENABLE_STALE_READS_DOC =\n       \"Config to enable/disable forwarding pull queries to standby hosts when the active is dead. \"\n           + \"Effectively, the accuracy of pull queries is sacrificed for higher availability. \"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NjkwMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374496902", "bodyText": "I had left an earlier suggestion to munge this into the cluster status endpoint.. if you want to keep this separate, thats fine as well. but can we give this a better name than ActiveStandby[Request|Response]?  May be TablePartitionStatus or TableReplicaStatus? something that denotes this is returning status information.", "author": "vinothchandar", "createdAt": "2020-02-04T06:42:23Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java", "diffHunk": "@@ -55,4 +56,12 @@ void makeAsyncHeartbeatRequest(\n    * @return response containing the cluster status.\n    */\n   RestResponse<ClusterStatusResponse> makeClusterStatusRequest(URI serverEndPoint);\n+\n+  /**\n+   * Send a request to remote Ksql server to inquire to inquire about which state stores the\n+   * remote server maintains as an active and standby.\n+   * @param serverEndPoint the remote destination.\n+   * @return response containing the state stores for which the remote host is active and standby.\n+   */\n+  RestResponse<ActiveStandbyResponse> makeActiveStandbyRequest(URI serverEndPoint);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgxNzk5MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374817991", "bodyText": "It is already part of ClusterStatusResource/Response", "author": "vpapavas", "createdAt": "2020-02-04T17:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NjkwMg=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java b/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java\nindex bd816d7619..bf60e203fd 100644\n--- a/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java\n+++ b/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java\n\n@@ -58,10 +58,17 @@ public interface SimpleKsqlClient {\n   RestResponse<ClusterStatusResponse> makeClusterStatusRequest(URI serverEndPoint);\n \n   /**\n+<<<<<<< HEAD\n+   * Send lag information to remote Ksql server.\n+=======\n    * Send a request to remote Ksql server to inquire to inquire about which state stores the\n    * remote server maintains as an active and standby.\n+>>>>>>> 9247ecc7c... fixed broken test after kafka merge\n    * @param serverEndPoint the remote destination.\n-   * @return response containing the state stores for which the remote host is active and standby.\n+   * @param lagReportingMessage the host lag data\n    */\n-  RestResponse<ActiveStandbyResponse> makeActiveStandbyRequest(URI serverEndPoint);\n+  void makeAsyncLagReportRequest(\n+      URI serverEndPoint,\n+      LagReportingMessage lagReportingMessage\n+  );\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5ODAxMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374498012", "bodyText": "locate is doing more than just locating... Can we rename Locator to Router (and its implementations) and change locate() to route()?", "author": "vinothchandar", "createdAt": "2020-02-04T06:46:31Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1NDE0Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374954142", "bodyText": "Locator is not routing, it is locating and filtering. I feel the name serves the purpose better than Router", "author": "vpapavas", "createdAt": "2020-02-04T22:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5ODAxMg=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex deb6ffefb2..e0cfa7875c 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -185,9 +194,7 @@ public final class PullQueryExecutor {\n           statement,\n           executionContext,\n           serviceContext,\n-          pullQueryContext,\n-          heartbeatAgent,\n-          routingFilters\n+          pullQueryContext\n       );\n \n     } catch (final Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMTM3MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374501371", "bodyText": "Given the LivenessFilter object is created together with the heartbeat agent, does it make sense to pass the agent into constructor... Having the allHostsStatus map here in the filter() method seems very specific to the liveness filter implementation.. (e.g there could be another filter implementation which just filters based on host datacenter say)..\nIn this model, PullQueryExecutor need not obtain this map everytime and instead just invoke filter(hostInfo, storeName, partition) and let the LivenessFilter class interact with the agent and obtain the information it needs to do the filtering..", "author": "vinothchandar", "createdAt": "2020-02-04T06:59:41Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.util.HostStatus;\n+import java.util.Map;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Filters ksql hosts based on whether they are alive or dead.\n+ */\n+public class LivenessFilter implements RoutingFilter {\n+\n+  public LivenessFilter() {\n+  }\n+\n+  /**\n+   * Returns true if the host is alive. If the heartbeat agent is not enabled, all hosts are\n+   * assumed to be alive.\n+   * @param hostInfo The host for which the status is checked\n+   * @param storeName Ignored\n+   * @param partition Ignored\n+   * @return true if the host is alive, false otherwise.\n+   */\n+  @Override\n+  public boolean filter(\n+      final Map<HostInfo, HostStatus> allHostsStatus,", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5NjYwMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374996600", "bodyText": "If I do what you say, then then we create a new map per host per filter that may use the map. Whereas with what I did, we use a single map per query.", "author": "vpapavas", "createdAt": "2020-02-05T00:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMTM3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f331862a48140db4d3eedc12e66e6002312bb8c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java\nindex 874f646773..bd3791a3f4 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java\n\n@@ -17,6 +17,7 @@ package io.confluent.ksql.rest.server;\n \n import io.confluent.ksql.execution.streams.RoutingFilter;\n import io.confluent.ksql.util.HostStatus;\n+import io.confluent.ksql.util.KsqlHost;\n import java.util.Map;\n import org.apache.kafka.streams.state.HostInfo;\n \n"}}, {"oid": "6f331862a48140db4d3eedc12e66e6002312bb8c", "url": "https://github.com/confluentinc/ksql/commit/6f331862a48140db4d3eedc12e66e6002312bb8c", "message": "mock heartbeat for standby routing\n\nprogress\n\nAdded functional test for routing and endpoint for active standby info\n\nundo changes to log files\n\nfixing tests\n\nfixed tests\n\naddressed vinoth's comments\n\nfixed tests\n\nfixed broken test after kafka merge\n\naddress alans comments\n\nadd missed file\n\nmade hostStatus map atomic reference, changed copy-on-read to copy-on-write\n\nfix dead store bug?\n\napplying andy's comments\n\nsuccessful rebase\n\nrebase and apply comments", "committedDate": "2020-02-05T01:53:48Z", "type": "commit"}, {"oid": "626b7ef2dcd973245b9a329aa37543085c248e8f", "url": "https://github.com/confluentinc/ksql/commit/626b7ef2dcd973245b9a329aa37543085c248e8f", "message": "all tests pass", "committedDate": "2020-02-05T04:41:42Z", "type": "commit"}, {"oid": "626b7ef2dcd973245b9a329aa37543085c248e8f", "url": "https://github.com/confluentinc/ksql/commit/626b7ef2dcd973245b9a329aa37543085c248e8f", "message": "all tests pass", "committedDate": "2020-02-05T04:41:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ0NDczNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375444737", "bodyText": "Bad merge", "author": "AlanConfluent", "createdAt": "2020-02-05T18:56:40Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java", "diffHunk": "@@ -58,7 +58,12 @@ void makeAsyncHeartbeatRequest(\n   RestResponse<ClusterStatusResponse> makeClusterStatusRequest(URI serverEndPoint);\n \n   /**\n+<<<<<<< HEAD", "originalCommit": "626b7ef2dcd973245b9a329aa37543085c248e8f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58f3691b8654ef33b0c93b2b0f51ac48b75e5282", "chunk": "diff --git a/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java b/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java\nindex bf60e203fd..706c9601db 100644\n--- a/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java\n+++ b/ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java\n\n@@ -58,12 +58,8 @@ public interface SimpleKsqlClient {\n   RestResponse<ClusterStatusResponse> makeClusterStatusRequest(URI serverEndPoint);\n \n   /**\n-<<<<<<< HEAD\n-   * Send lag information to remote Ksql server.\n-=======\n    * Send a request to remote Ksql server to inquire to inquire about which state stores the\n    * remote server maintains as an active and standby.\n->>>>>>> 9247ecc7c... fixed broken test after kafka merge\n    * @param serverEndPoint the remote destination.\n    * @param lagReportingMessage the host lag data\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ0OTI4Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375449282", "bodyText": "I will likely similarly add a max end offset to this interface for lag purposes.\nAlso applicationQueryId, since this is how lags are keyed.", "author": "AlanConfluent", "createdAt": "2020-02-05T19:05:33Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/RoutingFilter.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.util.HostStatus;\n+import io.confluent.ksql.util.KsqlHost;\n+import java.util.Map;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Used to filter ksql hosts based on criteria specified in implementing classes.\n+ * One such example is a filter that checks whether hosts are alive or dead as determined\n+ * by the heartbeat agent.\n+ */\n+public interface RoutingFilter {\n+\n+  boolean filter(\n+      Map<KsqlHost, HostStatus> allHostsStatus,", "originalCommit": "626b7ef2dcd973245b9a329aa37543085c248e8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2NzQxOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375467418", "bodyText": "I removed the map", "author": "vpapavas", "createdAt": "2020-02-05T19:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ0OTI4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "58f3691b8654ef33b0c93b2b0f51ac48b75e5282", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/RoutingFilter.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/RoutingFilter.java\nindex cdd4a52338..55da7ea9ca 100644\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/RoutingFilter.java\n+++ b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/RoutingFilter.java\n\n@@ -1,4 +1,4 @@\n-/*\n+/*o\n  * Copyright 2020 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"; you may not use\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ1NDc1Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375454753", "bodyText": "extra parens? asKsqlHost((activeHost))", "author": "AlanConfluent", "createdAt": "2020-02-05T19:16:15Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,27 +64,61 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final Map<KsqlHost, HostStatus> allHostsStatus,\n+      final RoutingFilter routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n+\n+    final Stream<KsqlHost> active = Stream.of(asKsqlHost((activeHost)));", "originalCommit": "626b7ef2dcd973245b9a329aa37543085c248e8f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58f3691b8654ef33b0c93b2b0f51ac48b75e5282", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\nindex 514427d78f..7069249bd0 100644\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n+++ b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n\n@@ -66,7 +64,6 @@ final class KsLocator implements Locator {\n   @Override\n   public List<KsqlNode> locate(\n       final Struct key,\n-      final Map<KsqlHost, HostStatus> allHostsStatus,\n       final RoutingFilter routingFilters\n   ) {\n     final KeyQueryMetadata metadata = kafkaStreams\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ1Njc2NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375456765", "bodyText": "host.equals(activeHost)?", "author": "AlanConfluent", "createdAt": "2020-02-05T19:19:56Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.util.HostStatus;\n+import io.confluent.ksql.util.KsqlHost;\n+import java.util.Map;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Filters for the active host.\n+ */\n+public class ActiveHostFilter implements RoutingFilter {\n+\n+  public ActiveHostFilter() {\n+  }\n+\n+  /**\n+   * Returns true if the host is alive. If the heartbeat agent is not enabled, all hosts are\n+   * assumed to be alive.\n+   * @param allHostsStatus status of all hosts as provided by heartbeat agent\n+   * @param activeHost the active host for a particular state store\n+   * @param host The host for which the status is checked\n+   * @param storeName Ignored\n+   * @param partition Ignored\n+   * @return true if the host is alive, false otherwise.\n+   */\n+  @Override\n+  public boolean filter(\n+      final Map<KsqlHost, HostStatus> allHostsStatus,\n+      final HostInfo activeHost,\n+      final KsqlHost host,\n+      final String storeName,\n+      final int partition) {\n+\n+    return host.host().equals(activeHost.host()) && host.port() == activeHost.port();", "originalCommit": "626b7ef2dcd973245b9a329aa37543085c248e8f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58f3691b8654ef33b0c93b2b0f51ac48b75e5282", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java\nindex 20b16f884d..7aa0370443 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java\n\n@@ -16,9 +16,7 @@\n package io.confluent.ksql.rest.server;\n \n import io.confluent.ksql.execution.streams.RoutingFilter;\n-import io.confluent.ksql.util.HostStatus;\n import io.confluent.ksql.util.KsqlHost;\n-import java.util.Map;\n import org.apache.kafka.streams.state.HostInfo;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2MjIwMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375462202", "bodyText": "One last pitch for the factory idea here.  You could have something like List<RoutingFilter> routingFilters = factory.createRoutingFilters(activeHost, standByHosts); or if using the new composition, a single RoutingFilter\nWithin this factory, you could get allHostsStatus and pass it into the constructor of the filter, removing the need to pipe this all the way through.  Also, for lags, I could compute the max end offset from that same info and pass that into the constructor of the lag filter.\nThen we would modify a single factory which would register all of the filters and set them up.  Just an idea which would generalize fairly well.", "author": "AlanConfluent", "createdAt": "2020-02-05T19:29:57Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,27 +64,61 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final Map<KsqlHost, HostStatus> allHostsStatus,", "originalCommit": "626b7ef2dcd973245b9a329aa37543085c248e8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2NjgxOQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375466819", "bodyText": "I can also do this in a followup with my lags change.", "author": "AlanConfluent", "createdAt": "2020-02-05T19:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2MjIwMg=="}], "type": "inlineReview", "revised_code": {"commit": "58f3691b8654ef33b0c93b2b0f51ac48b75e5282", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\nindex 514427d78f..7069249bd0 100644\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n+++ b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n\n@@ -66,7 +64,6 @@ final class KsLocator implements Locator {\n   @Override\n   public List<KsqlNode> locate(\n       final Struct key,\n-      final Map<KsqlHost, HostStatus> allHostsStatus,\n       final RoutingFilter routingFilters\n   ) {\n     final KeyQueryMetadata metadata = kafkaStreams\n"}}, {"oid": "58f3691b8654ef33b0c93b2b0f51ac48b75e5282", "url": "https://github.com/confluentinc/ksql/commit/58f3691b8654ef33b0c93b2b0f51ac48b75e5282", "message": "Applied all comments", "committedDate": "2020-02-05T20:59:22Z", "type": "commit"}, {"oid": "2327c7a98e878b3278785170a6ce004859f2db7c", "url": "https://github.com/confluentinc/ksql/commit/2327c7a98e878b3278785170a6ce004859f2db7c", "message": "minor fixes", "committedDate": "2020-02-05T21:43:43Z", "type": "commit"}, {"oid": "98a397131093a6ddea14deaf0ab90c58540be4a4", "url": "https://github.com/confluentinc/ksql/commit/98a397131093a6ddea14deaf0ab90c58540be4a4", "message": "added timestamp to log, removed system.out", "committedDate": "2020-02-05T22:40:24Z", "type": "commit"}, {"oid": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "url": "https://github.com/confluentinc/ksql/commit/37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "message": "changed back log files", "committedDate": "2020-02-05T22:42:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2MzgxNg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375563816", "bodyText": "we should also add a note that for this to work, standby replicas must be turned on using ksql.streams.num.standby.replicas >= 1 . Ideally we should auto set the standby replication.. Thats another way to go about it.. May be file an issue for later?", "author": "vinothchandar", "createdAt": "2020-02-05T23:20:51Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -167,11 +167,19 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n-      \"ksql.query.pull.routing.timeout.ms\";\n-  public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n-      + \"when waiting for the lookup of the owner of a row key\";\n+  public static final String KSQL_QUERY_PULL_ENABLE_STANDBY_READS =\n+        \"ksql.query.pull.enable.stale.reads\";\n+  private static final String KSQL_QUERY_PULL_ENABLE_STANDBY_READS_DOC =", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MDQ2Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375580467", "bodyText": "#4454 4454", "author": "vpapavas", "createdAt": "2020-02-06T00:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2MzgxNg=="}], "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\nindex 53367d89a6..1e5ad8b22e 100644\n--- a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n+++ b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n\n@@ -177,7 +177,9 @@ public class KsqlConfig extends AbstractConfig {\n           + \"consistency for higher availability.  \"\n           + \"Possible values are \\\"true\\\", \\\"false\\\". Setting to \\\"true\\\" guarantees high \"\n           + \"availability for pull queries. If set to \\\"false\\\", pull queries will fail when\"\n-          + \"the active is dead and until a new active is elected. Default value is \\\"false\\\". \";\n+          + \"the active is dead and until a new active is elected. Default value is \\\"false\\\". \"\n+          + \"For using this functionality, the server must be configured with \"\n+          + \"to ksql.streams.num.standby.replicas >= 1\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_STANDBY_READS_DEFAULT = false;\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NDQyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375564428", "bodyText": "can we rename host to otherHost or thatHost for better readability?", "author": "vinothchandar", "createdAt": "2020-02-05T23:22:39Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlHost.java", "diffHunk": "@@ -42,8 +43,8 @@ public boolean equals(final Object o) {\n       return false;\n     }\n \n-    final KsqlHost hostInfo = (KsqlHost) o;\n-    return port == hostInfo.port && host.equals(hostInfo.host);\n+    final KsqlHost host = (KsqlHost) o;\n+    return this.host.equals(host.host) && port == host.port;", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NTI1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375565251", "bodyText": "Another suggestion.. Can we name this class KsqlHostPort or KsqlHostInfo, since it already has a member host", "author": "vinothchandar", "createdAt": "2020-02-05T23:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NDQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MTA0Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375581043", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-06T00:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NDQyOA=="}], "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlHost.java b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlHostInfo.java\nsimilarity index 82%\nrename from ksql-common/src/main/java/io/confluent/ksql/util/KsqlHost.java\nrename to ksql-common/src/main/java/io/confluent/ksql/util/KsqlHostInfo.java\nindex 581146210d..5e65da19be 100644\n--- a/ksql-common/src/main/java/io/confluent/ksql/util/KsqlHost.java\n+++ b/ksql-common/src/main/java/io/confluent/ksql/util/KsqlHostInfo.java\n\n@@ -43,8 +43,8 @@ public class KsqlHost {\n       return false;\n     }\n \n-    final KsqlHost host = (KsqlHost) o;\n-    return this.host.equals(host.host) && port == host.port;\n+    final KsqlHostInfo other = (KsqlHostInfo) o;\n+    return this.host.equals(other.host) && port == other.port;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NDc5Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375564797", "bodyText": "change the javadocs based on what this filter() implementation does?", "author": "vinothchandar", "createdAt": "2020-02-05T23:23:46Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.util.KsqlHost;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Filters for the active host.\n+ */\n+public class ActiveHostFilter implements RoutingFilter {\n+\n+  public ActiveHostFilter() {\n+  }\n+\n+  /**\n+   * Returns true if the host is alive. If the heartbeat agent is not enabled, all hosts are", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java\nindex 7aa0370443..5d7daeed8d 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java\n\n@@ -16,7 +16,7 @@\n package io.confluent.ksql.rest.server;\n \n import io.confluent.ksql.execution.streams.RoutingFilter;\n-import io.confluent.ksql.util.KsqlHost;\n+import io.confluent.ksql.util.KsqlHostInfo;\n import org.apache.kafka.streams.state.HostInfo;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NTYyNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375565624", "bodyText": "nit: remove extra line?", "author": "vinothchandar", "createdAt": "2020-02-05T23:26:08Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -191,6 +195,7 @@ public static SourceName getCommandsStreamName() {\n       final Consumer<KsqlConfig> rocksDBConfigSetterHandler,\n       final Optional<HeartbeatAgent> heartbeatAgent,\n       final Optional<LagReportingAgent> lagReportingAgent\n+", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\nindex 4fac898c84..59271504fb 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\n\n@@ -195,7 +194,6 @@ public final class KsqlRestApplication extends ExecutableApplication<KsqlRestCon\n       final Consumer<KsqlConfig> rocksDBConfigSetterHandler,\n       final Optional<HeartbeatAgent> heartbeatAgent,\n       final Optional<LagReportingAgent> lagReportingAgent\n-\n   ) {\n     super(restConfig);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NTY5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375565696", "bodyText": "extra line?", "author": "vinothchandar", "createdAt": "2020-02-05T23:26:21Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -163,6 +166,7 @@\n   private final Optional<HeartbeatAgent> heartbeatAgent;\n   private final Optional<LagReportingAgent> lagReportingAgent;\n \n+", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\nindex 4fac898c84..59271504fb 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\n\n@@ -166,7 +166,6 @@ public final class KsqlRestApplication extends ExecutableApplication<KsqlRestCon\n   private final Optional<HeartbeatAgent> heartbeatAgent;\n   private final Optional<LagReportingAgent> lagReportingAgent;\n \n-\n   public static SourceName getCommandsStreamName() {\n     return COMMANDS_STREAM_NAME;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NjI2MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375566261", "bodyText": "file a follow up for fixing this? I understand doing that in this PR will balloon scope", "author": "vinothchandar", "createdAt": "2020-02-05T23:28:01Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -528,6 +541,7 @@ static KsqlRestApplication buildApplication(\n             new KsqlSecurityContextBinder(config, securityExtension, schemaRegistryClientFactory));\n   }\n \n+  @SuppressWarnings(\"checkstyle:MethodLength\")", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MTY4Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375581687", "bodyText": "Actually, not needed. I had already fixed it but forgot the supress", "author": "vpapavas", "createdAt": "2020-02-06T00:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NjI2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\nindex 4fac898c84..59271504fb 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java\n\n@@ -541,7 +539,6 @@ public final class KsqlRestApplication extends ExecutableApplication<KsqlRestCon\n             new KsqlSecurityContextBinder(config, securityExtension, schemaRegistryClientFactory));\n   }\n \n-  @SuppressWarnings(\"checkstyle:MethodLength\")\n   static KsqlRestApplication buildApplication(\n       final String metricsPrefix,\n       final KsqlRestConfig restConfig,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NzMxOQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375567319", "bodyText": "this could be set per request? is that why we have this here in addition to KsqlConfig?", "author": "vinothchandar", "createdAt": "2020-02-05T23:31:19Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java", "diffHunk": "@@ -153,12 +153,17 @@\n       KSQL_CONFIG_PREFIX + \"lag.reporting.enable\";\n   private static final String KSQL_LAG_REPORTING_ENABLE_DOC =\n       \"Whether lag reporting is enabled or not. It is disabled by default.\";\n-\n   public static final String KSQL_LAG_REPORTING_SEND_INTERVAL_MS_CONFIG =\n       KSQL_CONFIG_PREFIX + \"lag.reporting.send.interval.ms\";\n   private static final String KSQL_LAG_REPORTING_SEND_INTERVAL_MS_DOC =\n       \"Interval at which lag reports are broadcasted to servers.\";\n \n+  public static final String KSQL_QUERY_STANDBY_ENABLE_CONFIG =", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MjI0MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375582240", "bodyText": "No . It got wrongly added with the rebase. Good catch", "author": "vpapavas", "createdAt": "2020-02-06T00:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NzMxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MjgzMw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375582833", "bodyText": "It seems like you could just use KSQL_QUERY_PULL_ENABLE_STANDBY_READS rather than both.", "author": "AlanConfluent", "createdAt": "2020-02-06T00:25:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NzMxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java\nindex a433abe3f0..dcb0dec09a 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java\n\n@@ -158,12 +158,6 @@ public class KsqlRestConfig extends RestConfig {\n   private static final String KSQL_LAG_REPORTING_SEND_INTERVAL_MS_DOC =\n       \"Interval at which lag reports are broadcasted to servers.\";\n \n-  public static final String KSQL_QUERY_STANDBY_ENABLE_CONFIG =\n-      KSQL_CONFIG_PREFIX + \"query.standby.enable\";\n-  private static final String KSQL_QUERY_STANDBY_ENABLE_DOC =\n-      \"Whether the queries are forwarded to standby hosts when the active is down.\"\n-          + \" It is disabled by default.\";\n-\n   private static final ConfigDef CONFIG_DEF;\n \n   static {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2OTc3NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375569775", "bodyText": "Nice work on cleaning up this class!", "author": "vinothchandar", "createdAt": "2020-02-05T23:39:24Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -251,6 +329,55 @@ private static ImmutableAnalysis analyze(\n     return queryAnalyzer.analyze(statement.getStatement(), Optional.empty());\n   }\n \n+  private static final class PullQueryContext {", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MDA5MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375570090", "bodyText": "typo: StreamsMetadata?", "author": "vinothchandar", "createdAt": "2020-02-05T23:40:27Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -71,15 +83,70 @@ private ClusterStatusResponse getResponse() {\n             entry -> new KsqlHostEntity(entry.getKey().host(), entry.getKey().port()) ,\n             entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n                                           entry.getValue().getLastStatusUpdateMs(),\n+                                          getActiveStandbyInformation(entry.getKey()),\n                                           getHostStoreLags(entry.getKey()))\n         ));\n \n     return new ClusterStatusResponse(response);\n   }\n \n+\n   private HostStoreLags getHostStoreLags(final KsqlHost ksqlHost) {\n     return lagReportingAgent\n-      .flatMap(agent -> agent.getLagPerHost(ksqlHost))\n+        .flatMap(agent -> agent.getLagPerHost(ksqlHost))\n         .orElse(EMPTY_HOST_STORE_LAGS);\n   }\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final KsqlHost ksqlHost) {\n+    return engine.getPersistentQueries().stream()\n+    .flatMap(persistentQueryMetadata -> persistentQueryMetadata.getAllMetadata()\n+        .stream()\n+        .map(streamsMetadata -> new QueryIdAndSteamMetadata(\n+            persistentQueryMetadata.getQueryId().toString(), streamsMetadata)))\n+        .filter(queryIdAndSteamMetadata ->\n+                    queryIdAndSteamMetadata.streamsMetadata != StreamsMetadata.NOT_AVAILABLE)\n+        .filter(queryIdAndSteamMetadata ->\n+                    queryIdAndSteamMetadata.streamsMetadata.hostInfo().equals(asHostInfo(ksqlHost)))\n+        .collect(Collectors.toMap(queryIdAndSteamMetadata ->\n+                                      queryIdAndSteamMetadata.queryId ,\n+                                      QueryIdAndSteamMetadata::toActiveStandbyEntity));\n+  }\n+\n+  private static final class QueryIdAndSteamMetadata {", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\nindex b2f5106923..aa43755e5e 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java\n\n@@ -74,13 +74,13 @@ public class ClusterStatusResource {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    final Map<KsqlHost, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+    final Map<KsqlHostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n \n-    final Map<KsqlHostEntity, HostStatusEntity> response = allHostStatus\n+    final Map<KsqlHostInfoEntity, HostStatusEntity> response = allHostStatus\n         .entrySet()\n         .stream()\n         .collect(Collectors.toMap(\n-            entry -> new KsqlHostEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new KsqlHostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n             entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n                                           entry.getValue().getLastStatusUpdateMs(),\n                                           getActiveStandbyInformation(entry.getKey()),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MTQ1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375571456", "bodyText": "nice!", "author": "vinothchandar", "createdAt": "2020-02-05T23:45:09Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendHeartbeartsForWindowLength;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize;\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.KsqlHostEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.regex.Pattern;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.Timeout;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+\n+  private static final Pattern QUERY_ID_PATTERN = Pattern.compile(\"with query ID: (\\\\S+)\");\n+  private static final KsqlHostEntity host0 = new KsqlHostEntity(\"localhost\", 8088);\n+  private static final KsqlHostEntity host1 = new KsqlHostEntity(\"localhost\",8089);\n+  private static final KsqlHostEntity host2 = new KsqlHostEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private final static String KEY = Iterables.get(USER_PROVIDER.data().keySet(), 0);\n+  private String output;\n+  private String QUERY_ID;\n+  private String sql;\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final Map<String, Object> COMMON_CONFIG = ImmutableMap.<String, Object>builder()\n+      .put(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .put(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS, true)\n+      .put(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .put(KsqlConfig.KSQL_SHUTDOWN_TIMEOUT_MS_CONFIG, 1000)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS);\n+\n+  @Rule\n+  public final Timeout timeout = Timeout.builder()\n+      .withTimeout(1, TimeUnit.MINUTES)\n+      .withLookingForStuckThread(true)\n+      .build();\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    //Create stream\n+    makeAdminRequest(\n+        REST_APP_0,\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+    //Create table\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+    sql = \"SELECT * FROM \" + output + \" WHERE ROWKEY = '\" + KEY + \"';\";\n+    List<KsqlEntity> res = makeAdminRequestWithResponse(\n+        REST_APP_0,\n+        \"CREATE TABLE \" + output + \" AS\"\n+            + \" SELECT COUNT(1) AS COUNT FROM \" + USERS_STREAM\n+            + \" GROUP BY \" + USER_PROVIDER.key() + \";\"\n+    );\n+    QUERY_ID = extractQueryId(res.get(0).toString());\n+    QUERY_ID = QUERY_ID.substring(0, QUERY_ID.length()-1);\n+    waitForTableRows();\n+    waitForStreamsMetadataToInitialize(\n+        REST_APP_0, ImmutableList.of(host0, host1, host2), QUERY_ID);\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.closePersistentQueries();\n+    REST_APP_0.dropSourcesExcept();\n+  }\n+\n+  @AfterClass\n+  public static void classTearDown() {\n+    TMP.delete();\n+  }\n+\n+  @Test\n+  public void shouldQueryActiveWhenActiveAliveQueryIssuedToStandby() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.standBy.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.standBy.right, clusterFormation.active.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.standBy.right, clusterFormation.active.left, HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.standBy.right, sql);\n+\n+    // Then:\n+    assertThat(rows_0, hasSize(HEADER + 1));\n+    assertThat(rows_0.get(1).getRow(), is(not(Optional.empty())));\n+    assertThat(rows_0.get(1).getRow().get().values(), is(ImmutableList.of(KEY, BASE_TIME, 1)));\n+  }\n+\n+\n+  @Test\n+  public void shouldQueryActiveWhenActiveAliveStandbyDeadQueryIssuedToRouter() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.router.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.router.right, clusterFormation.active.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.router.right,\n+        clusterFormation.active.left,\n+        HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.router.right, sql);\n+\n+    // Then:\n+    assertThat(rows_0, hasSize(HEADER + 1));\n+    assertThat(rows_0.get(1).getRow(), is(not(Optional.empty())));\n+    assertThat(rows_0.get(1).getRow().get().values(), is(ImmutableList.of(KEY, BASE_TIME, 1)));\n+  }\n+\n+  @Test\n+  public void shouldQueryStandbyWhenActiveDeadStandbyAliveQueryIssuedToRouter() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.router.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.router.right, clusterFormation.standBy.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.router.right,\n+        clusterFormation.standBy.left,\n+        HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.router.right, sql);\n+\n+    // Then:\n+    assertThat(rows_0, hasSize(HEADER + 1));\n+    assertThat(rows_0.get(1).getRow(), is(not(Optional.empty())));\n+    assertThat(rows_0.get(1).getRow().get().values(), is(ImmutableList.of(KEY, BASE_TIME, 1)));\n+  }\n+\n+  private List<StreamedRow> makePullQueryRequest(\n+      final TestKsqlRestApp target,\n+      final String sql\n+  ) {\n+    return RestIntegrationTestUtil.makeQueryRequest(target, sql, Optional.empty());\n+  }\n+\n+  private static void makeAdminRequest(TestKsqlRestApp restApp, final String sql) {\n+    RestIntegrationTestUtil.makeKsqlRequest(restApp, sql, Optional.empty());\n+  }\n+\n+  private List<KsqlEntity> makeAdminRequestWithResponse(\n+      TestKsqlRestApp restApp, final String sql) {\n+    return RestIntegrationTestUtil.makeKsqlRequest(restApp, sql, Optional.empty());\n+  }\n+\n+  private ClusterFormation findClusterFormation(", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\nindex 9c8480b302..0a3c811d16 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n\n@@ -35,7 +35,7 @@ import io.confluent.ksql.name.ColumnName;\n import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n import io.confluent.ksql.rest.entity.KsqlEntity;\n-import io.confluent.ksql.rest.entity.KsqlHostEntity;\n+import io.confluent.ksql.rest.entity.KsqlHostInfoEntity;\n import io.confluent.ksql.rest.entity.StreamedRow;\n import io.confluent.ksql.rest.server.KsqlRestConfig;\n import io.confluent.ksql.rest.server.TestKsqlRestApp;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375572692", "bodyText": "IIUC since there is just 1 partition, a query to standby returning should mean it was answered by active? Technically, it can be answered by standby locally as well right? Let's assume we introduce a bug that we query locally first always before proxying.. Would this test still pass then?", "author": "vinothchandar", "createdAt": "2020-02-05T23:49:08Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendHeartbeartsForWindowLength;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize;\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.KsqlHostEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.regex.Pattern;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.Timeout;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+\n+  private static final Pattern QUERY_ID_PATTERN = Pattern.compile(\"with query ID: (\\\\S+)\");\n+  private static final KsqlHostEntity host0 = new KsqlHostEntity(\"localhost\", 8088);\n+  private static final KsqlHostEntity host1 = new KsqlHostEntity(\"localhost\",8089);\n+  private static final KsqlHostEntity host2 = new KsqlHostEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private final static String KEY = Iterables.get(USER_PROVIDER.data().keySet(), 0);\n+  private String output;\n+  private String QUERY_ID;\n+  private String sql;\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final Map<String, Object> COMMON_CONFIG = ImmutableMap.<String, Object>builder()\n+      .put(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .put(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS, true)\n+      .put(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .put(KsqlConfig.KSQL_SHUTDOWN_TIMEOUT_MS_CONFIG, 1000)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS);\n+\n+  @Rule\n+  public final Timeout timeout = Timeout.builder()\n+      .withTimeout(1, TimeUnit.MINUTES)\n+      .withLookingForStuckThread(true)\n+      .build();\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    //Create stream\n+    makeAdminRequest(\n+        REST_APP_0,\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+    //Create table\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+    sql = \"SELECT * FROM \" + output + \" WHERE ROWKEY = '\" + KEY + \"';\";\n+    List<KsqlEntity> res = makeAdminRequestWithResponse(\n+        REST_APP_0,\n+        \"CREATE TABLE \" + output + \" AS\"\n+            + \" SELECT COUNT(1) AS COUNT FROM \" + USERS_STREAM\n+            + \" GROUP BY \" + USER_PROVIDER.key() + \";\"\n+    );\n+    QUERY_ID = extractQueryId(res.get(0).toString());\n+    QUERY_ID = QUERY_ID.substring(0, QUERY_ID.length()-1);\n+    waitForTableRows();\n+    waitForStreamsMetadataToInitialize(\n+        REST_APP_0, ImmutableList.of(host0, host1, host2), QUERY_ID);\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.closePersistentQueries();\n+    REST_APP_0.dropSourcesExcept();\n+  }\n+\n+  @AfterClass\n+  public static void classTearDown() {\n+    TMP.delete();\n+  }\n+\n+  @Test\n+  public void shouldQueryActiveWhenActiveAliveQueryIssuedToStandby() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.standBy.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.standBy.right, clusterFormation.active.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.standBy.right, clusterFormation.active.left, HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.standBy.right, sql);", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NTgxNQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375585815", "bodyText": "Correct, there is no way of checking which server serves a query. We could introduce this information in the response?", "author": "vpapavas", "createdAt": "2020-02-06T00:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4OTM1NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375589355", "bodyText": "yes.. how much work would that be? This would also be incredibly useful debug information", "author": "vinothchandar", "createdAt": "2020-02-06T00:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MDc5Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375590793", "bodyText": "This might be a breaking change? Not sure if any applications use the response and expect it to be of certain format. How much work? Not sure. Don't know that code path", "author": "vpapavas", "createdAt": "2020-02-06T00:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MzQ1Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375593452", "bodyText": "I was saying this a few days ago.  For the lag sorting functionality where you expect that either of two standbys could answer a query (and they're both alive and not too behind), a functional test for it couldn't know which was the one that answered.  It would be impossible to test that it was the lower lag host.\nThis would be a nice thing to add at some point.", "author": "AlanConfluent", "createdAt": "2020-02-06T01:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5NjAwNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375596007", "bodyText": "Adding a new response header won't be a breaking change .. its actually a good backwards compatible change... But I can see there is some non-trivial work here.. So lets file few another follow up.. For now, the tests definitely cover the happy path and if we have other tests that guard against (KsLocatorTest may be already has them) the bug I used as an example, we might be fine.", "author": "vinothchandar", "createdAt": "2020-02-06T01:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5NzI3MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375597271", "bodyText": "Tracked here: #4455", "author": "vpapavas", "createdAt": "2020-02-06T01:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\nindex 9c8480b302..0a3c811d16 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n\n@@ -35,7 +35,7 @@ import io.confluent.ksql.name.ColumnName;\n import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n import io.confluent.ksql.rest.entity.KsqlEntity;\n-import io.confluent.ksql.rest.entity.KsqlHostEntity;\n+import io.confluent.ksql.rest.entity.KsqlHostInfoEntity;\n import io.confluent.ksql.rest.entity.StreamedRow;\n import io.confluent.ksql.rest.server.KsqlRestConfig;\n import io.confluent.ksql.rest.server.TestKsqlRestApp;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjkwMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375572900", "bodyText": "how are we sure that the standby is dead here?", "author": "vinothchandar", "createdAt": "2020-02-05T23:49:52Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendHeartbeartsForWindowLength;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize;\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.KsqlHostEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.regex.Pattern;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.Timeout;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+\n+  private static final Pattern QUERY_ID_PATTERN = Pattern.compile(\"with query ID: (\\\\S+)\");\n+  private static final KsqlHostEntity host0 = new KsqlHostEntity(\"localhost\", 8088);\n+  private static final KsqlHostEntity host1 = new KsqlHostEntity(\"localhost\",8089);\n+  private static final KsqlHostEntity host2 = new KsqlHostEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private final static String KEY = Iterables.get(USER_PROVIDER.data().keySet(), 0);\n+  private String output;\n+  private String QUERY_ID;\n+  private String sql;\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final Map<String, Object> COMMON_CONFIG = ImmutableMap.<String, Object>builder()\n+      .put(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .put(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS, true)\n+      .put(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .put(KsqlConfig.KSQL_SHUTDOWN_TIMEOUT_MS_CONFIG, 1000)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS);\n+\n+  @Rule\n+  public final Timeout timeout = Timeout.builder()\n+      .withTimeout(1, TimeUnit.MINUTES)\n+      .withLookingForStuckThread(true)\n+      .build();\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    //Create stream\n+    makeAdminRequest(\n+        REST_APP_0,\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+    //Create table\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+    sql = \"SELECT * FROM \" + output + \" WHERE ROWKEY = '\" + KEY + \"';\";\n+    List<KsqlEntity> res = makeAdminRequestWithResponse(\n+        REST_APP_0,\n+        \"CREATE TABLE \" + output + \" AS\"\n+            + \" SELECT COUNT(1) AS COUNT FROM \" + USERS_STREAM\n+            + \" GROUP BY \" + USER_PROVIDER.key() + \";\"\n+    );\n+    QUERY_ID = extractQueryId(res.get(0).toString());\n+    QUERY_ID = QUERY_ID.substring(0, QUERY_ID.length()-1);\n+    waitForTableRows();\n+    waitForStreamsMetadataToInitialize(\n+        REST_APP_0, ImmutableList.of(host0, host1, host2), QUERY_ID);\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.closePersistentQueries();\n+    REST_APP_0.dropSourcesExcept();\n+  }\n+\n+  @AfterClass\n+  public static void classTearDown() {\n+    TMP.delete();\n+  }\n+\n+  @Test\n+  public void shouldQueryActiveWhenActiveAliveQueryIssuedToStandby() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.standBy.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.standBy.right, clusterFormation.active.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.standBy.right, clusterFormation.active.left, HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.standBy.right, sql);\n+\n+    // Then:\n+    assertThat(rows_0, hasSize(HEADER + 1));\n+    assertThat(rows_0.get(1).getRow(), is(not(Optional.empty())));\n+    assertThat(rows_0.get(1).getRow().get().values(), is(ImmutableList.of(KEY, BASE_TIME, 1)));\n+  }\n+\n+\n+  @Test\n+  public void shouldQueryActiveWhenActiveAliveStandbyDeadQueryIssuedToRouter() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.router.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.router.right, clusterFormation.active.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.router.right,\n+        clusterFormation.active.left,\n+        HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.router.right, sql);", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MzA2MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375573061", "bodyText": "I see you are waiting till route and active or up.. but standby could also be up by then. no?", "author": "vinothchandar", "createdAt": "2020-02-05T23:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NTQwMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375585400", "bodyText": "Standby is not heartbeating, it cannot be up", "author": "vpapavas", "createdAt": "2020-02-06T00:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjkwMA=="}], "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\nindex 9c8480b302..0a3c811d16 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n\n@@ -35,7 +35,7 @@ import io.confluent.ksql.name.ColumnName;\n import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n import io.confluent.ksql.rest.entity.KsqlEntity;\n-import io.confluent.ksql.rest.entity.KsqlHostEntity;\n+import io.confluent.ksql.rest.entity.KsqlHostInfoEntity;\n import io.confluent.ksql.rest.entity.StreamedRow;\n import io.confluent.ksql.rest.server.KsqlRestConfig;\n import io.confluent.ksql.rest.server.TestKsqlRestApp;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MzI4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375573289", "bodyText": "remove?", "author": "vinothchandar", "createdAt": "2020-02-05T23:51:17Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/RestIntegrationTestUtil.java", "diffHunk": "@@ -67,6 +67,7 @@ private RestIntegrationTestUtil() {\n \n       final RestResponse<KsqlEntityList> res = restClient.makeKsqlRequest(sql);\n \n+      System.out.println(\"------------> Create stream response = \" + res);", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/RestIntegrationTestUtil.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/RestIntegrationTestUtil.java\nindex b2d4c376d2..3612c9cd02 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/RestIntegrationTestUtil.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/RestIntegrationTestUtil.java\n\n@@ -67,7 +67,6 @@ final class RestIntegrationTestUtil {\n \n       final RestResponse<KsqlEntityList> res = restClient.makeKsqlRequest(sql);\n \n-      System.out.println(\"------------> Create stream response = \" + res);\n       throwOnError(res);\n \n       return awaitResults(restClient, res.getResponse());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NDIyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375574228", "bodyText": "I would have had a List passed in here and have the KsLocator make use of RoutingFilters. But okay with this as well, in the interest of moving forward", "author": "vinothchandar", "createdAt": "2020-02-05T23:54:33Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/Locator.java", "diffHunk": "@@ -28,16 +30,18 @@\n public interface Locator {\n \n   /**\n-   * Locate which KSQL node stores the supplied {@code key}.\n+   * Locate which KSQL nodes store the supplied {@code key}.\n    *\n    * <p>Implementations are free to return {@link Optional#empty()} if the location is not known at\n    * this time.\n    *\n    * @param key the required key.\n-   * @return the owning node, if known.\n+   * @return the list of nodes, that can potentially serve the key.\n    */\n-  Optional<KsqlNode> locate(Struct key);\n-\n+  List<KsqlNode> locate(\n+      Struct key,\n+      RoutingFilter routingFilters", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MzM3OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375583379", "bodyText": "Look at Andy's comment here: #4398 (comment)", "author": "vpapavas", "createdAt": "2020-02-06T00:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NDM5Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375584397", "bodyText": "ha ha", "author": "vinothchandar", "createdAt": "2020-02-06T00:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NDIyOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NDc0MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375574741", "bodyText": "nit: better to avoid comments/variable naming that represents future work.. and have them just on the current PR ?", "author": "vinothchandar", "createdAt": "2020-02-05T23:56:26Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,27 +62,59 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final RoutingFilter routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n+\n+    final Stream<KsqlHost> active = Stream.of(asKsqlHost(activeHost));\n+    final Stream<KsqlHost> standby = standByHosts\n+        .stream()\n+        .map(this::asKsqlHost);\n+    final Stream<KsqlHost> hostStream = Stream.concat(active, standby);\n+\n+    // Filter out hosts based on liveness and lag filters.\n+    // The list is ordered by routing preference: active node is first, then standby nodes", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\nindex 28608f32d1..ef7f28c8f0 100644\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n+++ b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n\n@@ -79,17 +79,16 @@ final class KsLocator implements Locator {\n \n     final HostInfo activeHost = metadata.getActiveHost();\n     final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n-    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n+    LOG.debug(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n \n-    final Stream<KsqlHost> active = Stream.of(asKsqlHost(activeHost));\n-    final Stream<KsqlHost> standby = standByHosts\n+    final Stream<KsqlHostInfo> active = Stream.of(asKsqlHost(activeHost));\n+    final Stream<KsqlHostInfo> standby = standByHosts\n         .stream()\n         .map(this::asKsqlHost);\n-    final Stream<KsqlHost> hostStream = Stream.concat(active, standby);\n+    final Stream<KsqlHostInfo> hostStream = Stream.concat(active, standby);\n \n-    // Filter out hosts based on liveness and lag filters.\n-    // The list is ordered by routing preference: active node is first, then standby nodes\n-    // in order of increasing lag.\n+    // Filter out hosts based on active and liveness filters.\n+    // The list is ordered by routing preference: active node is first, then standby nodes.\n     // If heartbeat is not enabled, all hosts are considered alive.\n     final List<KsqlNode> filteredHosts = hostStream\n         .filter(hostInfo -> routingFilters.filter(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTA0OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375575049", "bodyText": "lets also move this to DEBUG or TRACE.. can you please make a pass and remove any INFO level log statements from the pull query execution path", "author": "vinothchandar", "createdAt": "2020-02-05T23:57:30Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,27 +62,59 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final RoutingFilter routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n+\n+    final Stream<KsqlHost> active = Stream.of(asKsqlHost(activeHost));\n+    final Stream<KsqlHost> standby = standByHosts\n+        .stream()\n+        .map(this::asKsqlHost);\n+    final Stream<KsqlHost> hostStream = Stream.concat(active, standby);\n+\n+    // Filter out hosts based on liveness and lag filters.\n+    // The list is ordered by routing preference: active node is first, then standby nodes\n+    // in order of increasing lag.\n+    // If heartbeat is not enabled, all hosts are considered alive.\n+    final List<KsqlNode> filteredHosts = hostStream\n+        .filter(hostInfo -> routingFilters.filter(\n+              activeHost, hostInfo, stateStoreName, metadata.getPartition()))\n+        .map(this::asNode)\n+        .collect(Collectors.toList());\n+\n+    LOG.info(\"Filtered and ordered hosts: {}\", filteredHosts);", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\nindex 28608f32d1..ef7f28c8f0 100644\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n+++ b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java\n\n@@ -79,17 +79,16 @@ final class KsLocator implements Locator {\n \n     final HostInfo activeHost = metadata.getActiveHost();\n     final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n-    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n+    LOG.debug(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n \n-    final Stream<KsqlHost> active = Stream.of(asKsqlHost(activeHost));\n-    final Stream<KsqlHost> standby = standByHosts\n+    final Stream<KsqlHostInfo> active = Stream.of(asKsqlHost(activeHost));\n+    final Stream<KsqlHostInfo> standby = standByHosts\n         .stream()\n         .map(this::asKsqlHost);\n-    final Stream<KsqlHost> hostStream = Stream.concat(active, standby);\n+    final Stream<KsqlHostInfo> hostStream = Stream.concat(active, standby);\n \n-    // Filter out hosts based on liveness and lag filters.\n-    // The list is ordered by routing preference: active node is first, then standby nodes\n-    // in order of increasing lag.\n+    // Filter out hosts based on active and liveness filters.\n+    // The list is ordered by routing preference: active node is first, then standby nodes.\n     // If heartbeat is not enabled, all hosts are considered alive.\n     final List<KsqlNode> filteredHosts = hostStream\n         .filter(hostInfo -> routingFilters.filter(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTI2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375575263", "bodyText": "how is the KsqlRestConfig entry used", "author": "vinothchandar", "createdAt": "2020-02-05T23:58:11Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java", "diffHunk": "@@ -72,9 +72,15 @@ LogicalSchema schema() {\n     awaitRunning();\n \n     try {\n-\n-      return kafkaStreams\n-          .store(StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType));\n+      if (ksqlConfig.getBoolean(KsqlConfig.KSQL_PULL_QUERIES_ENABLE_CONFIG)) {", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MjI0Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375582246", "bodyText": "I assume this is meant to be KSQL_QUERY_PULL_ENABLE_STANDBY_READS", "author": "AlanConfluent", "createdAt": "2020-02-06T00:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MzcwMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375583700", "bodyText": "It's not", "author": "vpapavas", "createdAt": "2020-02-06T00:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4Njg5Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375586892", "bodyText": "Actually @AlanConfluent is right.. we should tie the standby routing to this, right?  not the pull query feature itself.", "author": "vinothchandar", "createdAt": "2020-02-06T00:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4OTcyNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375589724", "bodyText": "Yes, the rebase overwrote my change. Fixed it now (again!)", "author": "vpapavas", "createdAt": "2020-02-06T00:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTI2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java\nindex e828c4b432..c338fd1f28 100644\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java\n+++ b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java\n\n@@ -72,15 +72,16 @@ class KsStateStore {\n     awaitRunning();\n \n     try {\n-      if (ksqlConfig.getBoolean(KsqlConfig.KSQL_PULL_QUERIES_ENABLE_CONFIG)) {\n+      if (ksqlConfig.getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS)) {\n         // True flag allows queries on standby and replica state stores\n         return kafkaStreams.store(\n             StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType)\n                 .enableStaleStores());\n+      } else {\n+        // False flag allows queries only on active state store\n+        return kafkaStreams.store(\n+            StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType));\n       }\n-      // False flag allows queries only on active state store\n-      return kafkaStreams.store(\n-          StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType));\n     } catch (final Exception e) {\n       final State state = kafkaStreams.state();\n       if (state != State.RUNNING) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTM1Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375575352", "bodyText": "move to an else block?", "author": "vinothchandar", "createdAt": "2020-02-05T23:58:31Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java", "diffHunk": "@@ -72,9 +72,15 @@ LogicalSchema schema() {\n     awaitRunning();\n \n     try {\n-\n-      return kafkaStreams\n-          .store(StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType));\n+      if (ksqlConfig.getBoolean(KsqlConfig.KSQL_PULL_QUERIES_ENABLE_CONFIG)) {\n+        // True flag allows queries on standby and replica state stores\n+        return kafkaStreams.store(\n+            StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType)\n+                .enableStaleStores());\n+      }\n+      // False flag allows queries only on active state store\n+      return kafkaStreams.store(", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "chunk": "diff --git a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java\nindex e828c4b432..c338fd1f28 100644\n--- a/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java\n+++ b/ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java\n\n@@ -72,15 +72,16 @@ class KsStateStore {\n     awaitRunning();\n \n     try {\n-      if (ksqlConfig.getBoolean(KsqlConfig.KSQL_PULL_QUERIES_ENABLE_CONFIG)) {\n+      if (ksqlConfig.getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS)) {\n         // True flag allows queries on standby and replica state stores\n         return kafkaStreams.store(\n             StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType)\n                 .enableStaleStores());\n+      } else {\n+        // False flag allows queries only on active state store\n+        return kafkaStreams.store(\n+            StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType));\n       }\n-      // False flag allows queries only on active state store\n-      return kafkaStreams.store(\n-          StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType));\n     } catch (final Exception e) {\n       final State state = kafkaStreams.state();\n       if (state != State.RUNNING) {\n"}}, {"oid": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "url": "https://github.com/confluentinc/ksql/commit/1349579b3b1941cd209d9e8e58dfd49e4934629c", "message": "applied vinoth's comments", "committedDate": "2020-02-06T01:20:40Z", "type": "commit"}, {"oid": "5344fe6cef9900e71e9f7cc4bdc22345ce62a054", "url": "https://github.com/confluentinc/ksql/commit/5344fe6cef9900e71e9f7cc4bdc22345ce62a054", "message": "fixed tests", "committedDate": "2020-02-06T02:48:58Z", "type": "commit"}, {"oid": "ed85a69ee3269eb2a88db6feabc7c2ba76e83a62", "url": "https://github.com/confluentinc/ksql/commit/ed85a69ee3269eb2a88db6feabc7c2ba76e83a62", "message": "added extra check in routing test", "committedDate": "2020-02-06T02:55:20Z", "type": "commit"}, {"oid": "78c6b2fb3db6b637564ea83c4001c853bfc53b3f", "url": "https://github.com/confluentinc/ksql/commit/78c6b2fb3db6b637564ea83c4001c853bfc53b3f", "message": "nit", "committedDate": "2020-02-06T03:01:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MDYxNg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375650616", "bodyText": "remove or move to logger.debug??", "author": "vinothchandar", "createdAt": "2020-02-06T05:47:32Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -175,70 +183,140 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n \n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    // Get active and standby nodes for this key\n+    final Locator locator = pullQueryContext.mat.locator();\n+    final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+        pullQueryContext.rowKey,\n+        routingFilters\n+    );\n \n-        result = new Result(mat.schema(), rows);\n-      }\n+    if (filteredAndOrderedNodes.isEmpty()) {\n+      throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+    }\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory\n-            .buildSchema(result.schema, mat.windowType().isPresent());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis, mat.windowType());\n-\n-        rows = handleSelects(\n-            result,\n-            statement,\n-            executionContext,\n-            analysis,\n-            outputSchema,\n-            mat.windowType(),\n-            queryId,\n-            contextStacker\n-        );\n+    // Nodes are ordered by preference: active is first if alive then standby nodes in\n+    // increasing order of lag.\n+    for (KsqlNode node : filteredAndOrderedNodes) {\n+      try {\n+        return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+      } catch (Exception t) {\n+        LOG.debug(\"Error routing query {} to host {} at timestamp {}\",\n+                 statement.getStatementText(), node, System.currentTimeMillis());\n       }\n+    }\n+    throw new MaterializationException(String.format(\n+        \"Unable to execute pull query: %s\", statement.getStatementText()));\n+  }\n \n-      return new TableRowsEntity(\n-          statement.getStatementText(),\n-          queryId,\n+  private TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+\n+    if (node.isLocal()) {\n+      LOG.debug(\"Query {} executed locally at host {} at timestamp {}.\",\n+               statement.getStatementText(), node.location(), System.currentTimeMillis());\n+      return queryRowsLocally(\n+          statement,\n+          executionContext,\n+          pullQueryContext);\n+    } else {\n+      LOG.debug(\"Query {} routed to host {} at timestamp {}.\",\n+                statement.getStatementText(), node.location(), System.currentTimeMillis());\n+      return forwardTo(node, statement, serviceContext);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  TableRowsEntity queryRowsLocally(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    final Result result;\n+    if (pullQueryContext.whereInfo.windowStartBounds.isPresent()) {\n+      final Range<Instant> windowStart = pullQueryContext.whereInfo.windowStartBounds.get();\n+\n+      final List<? extends TableRow> rows = pullQueryContext.mat.windowed()\n+          .get(pullQueryContext.rowKey, windowStart);\n+\n+      result = new Result(pullQueryContext.mat.schema(), rows);\n+    } else {\n+      final List<? extends TableRow> rows = pullQueryContext.mat.nonWindowed()\n+          .get(pullQueryContext.rowKey)\n+          .map(ImmutableList::of)\n+          .orElse(ImmutableList.of());\n+\n+      result = new Result(pullQueryContext.mat.schema(), rows);\n+    }\n+\n+    final LogicalSchema outputSchema;\n+    final List<List<?>> rows;\n+    if (isSelectStar(statement.getStatement().getSelect())) {\n+      outputSchema = TableRowsEntityFactory.buildSchema(\n+          result.schema, pullQueryContext.mat.windowType().isPresent());\n+      rows = TableRowsEntityFactory.createRows(result.rows);\n+    } else {\n+      outputSchema = selectOutputSchema(\n+          result, executionContext, pullQueryContext.analysis, pullQueryContext.mat.windowType());\n+      rows = handleSelects(\n+          result,\n+          statement,\n+          executionContext,\n+          pullQueryContext.analysis,\n           outputSchema,\n-          rows\n-      );\n-    } catch (final Exception e) {\n-      throw new KsqlStatementException(\n-          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n-          statement.getStatementText(),\n-          e\n+          pullQueryContext.mat.windowType(),\n+          pullQueryContext.queryId,\n+          pullQueryContext.contextStacker\n       );\n     }\n+    System.out.println(\"Result of pull query = \" + rows);", "originalCommit": "78c6b2fb3db6b637564ea83c4001c853bfc53b3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NDgxNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375654817", "bodyText": "Sorry, intellij indexing doesn't work. I have searched to remove all System.out but nothing came up", "author": "vpapavas", "createdAt": "2020-02-06T06:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MDYxNg=="}], "type": "inlineReview", "revised_code": {"commit": "053b99a134437e4665748bf3166c17288d6d93d3", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\nindex dbc951e4fb..f9623175cc 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java\n\n@@ -303,7 +303,6 @@ public final class PullQueryExecutor {\n           pullQueryContext.contextStacker\n       );\n     }\n-    System.out.println(\"Result of pull query = \" + rows);\n     return new TableRowsEntity(\n         statement.getStatementText(),\n         pullQueryContext.queryId,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MTYyMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375651621", "bodyText": "can we use Objects.equals instead to be safe on null handling", "author": "vinothchandar", "createdAt": "2020-02-06T05:52:26Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.entity;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.errorprone.annotations.Immutable;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@Immutable\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class ActiveStandbyEntity {\n+\n+  private final ImmutableSet<String> activeStores;\n+  private final ImmutableSet<TopicPartitionEntity> activePartitions;\n+  private final ImmutableSet<String> standByStores;\n+  private final ImmutableSet<TopicPartitionEntity> standByPartitions;\n+\n+  @JsonCreator\n+  public ActiveStandbyEntity(\n+      @JsonProperty(\"activeStores\") final Set<String> activeStores,\n+      @JsonProperty(\"activePartitions\") final Set<TopicPartitionEntity> activePartitions,\n+      @JsonProperty(\"standByStores\") final Set<String> standByStores,\n+      @JsonProperty(\"standByPartitions\") final Set<TopicPartitionEntity> standByPartitions\n+  ) {\n+    this.activeStores = ImmutableSet.copyOf(requireNonNull(activeStores));\n+    this.activePartitions = ImmutableSet.copyOf(requireNonNull(activePartitions));\n+    this.standByStores = ImmutableSet.copyOf(requireNonNull(standByStores));\n+    this.standByPartitions = ImmutableSet.copyOf(requireNonNull(standByPartitions));\n+  }\n+\n+  public Set<String> getActiveStores() {\n+    return activeStores;\n+  }\n+\n+  public Set<String> getStandByStores() {\n+    return standByStores;\n+  }\n+\n+  public Set<TopicPartitionEntity> getActivePartitions() {\n+    return activePartitions;\n+  }\n+\n+  public Set<TopicPartitionEntity> getStandByPartitions() {\n+    return standByPartitions;\n+  }\n+\n+  @Override\n+  public boolean equals(final Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    final ActiveStandbyEntity that = (ActiveStandbyEntity) o;\n+    return activeStores.equals(that.activeStores)", "originalCommit": "78c6b2fb3db6b637564ea83c4001c853bfc53b3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NTc1NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375655754", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-06T06:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MTYyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "053b99a134437e4665748bf3166c17288d6d93d3", "chunk": "diff --git a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java\nindex d870686126..a3d990f826 100644\n--- a/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java\n+++ b/ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java\n\n@@ -74,10 +74,10 @@ public class ActiveStandbyEntity {\n     }\n \n     final ActiveStandbyEntity that = (ActiveStandbyEntity) o;\n-    return activeStores.equals(that.activeStores)\n-        && standByStores.equals(that.standByStores)\n-        && activePartitions.equals(that.activePartitions)\n-        && standByPartitions.equals(that.standByPartitions);\n+    return Objects.equals(activeStores, that.activeStores)\n+        && Objects.equals(standByStores, that.standByStores)\n+        && Objects.equals(activePartitions, that.activePartitions)\n+        && Objects.equals(standByPartitions, that.standByPartitions);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MTk5Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375651993", "bodyText": "do we have a queryId to log here as well? it might help trace a query through the routing.. if we can include it for all log statements", "author": "vinothchandar", "createdAt": "2020-02-06T05:54:18Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,27 +62,58 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final RoutingFilter routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+    LOG.debug(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);", "originalCommit": "78c6b2fb3db6b637564ea83c4001c853bfc53b3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NTcyNg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375655726", "bodyText": "No, we don't have access to the query, only KafkaStreams", "author": "vpapavas", "createdAt": "2020-02-06T06:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MTk5Mw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "053b99a134437e4665748bf3166c17288d6d93d3", "url": "https://github.com/confluentinc/ksql/commit/053b99a134437e4665748bf3166c17288d6d93d3", "message": "last comments", "committedDate": "2020-02-06T06:12:24Z", "type": "commit"}]}