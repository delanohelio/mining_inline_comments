{"pr_number": 4653, "pr_title": "fix: CommandRunner metric has correct metric displayed when thread dies", "pr_createdAt": "2020-02-27T00:06:38Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4653", "timeline": [{"oid": "6d5be45a44999d20fa56bedbae547ab21cd5ef2f", "url": "https://github.com/confluentinc/ksql/commit/6d5be45a44999d20fa56bedbae547ab21cd5ef2f", "message": "fix: CommandRunner metric correctly reports status of thread if it's dead", "committedDate": "2020-02-27T00:09:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTE5MA==", "url": "https://github.com/confluentinc/ksql/pull/4653#discussion_r384855190", "bodyText": "Can we just get rid of this and set the status to ERROR if we haven't polled in a while?", "author": "rodesai", "createdAt": "2020-02-27T00:50:33Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java", "diffHunk": "@@ -262,12 +266,15 @@ private void terminateCluster(final Command command) {\n   CommandRunnerStatus checkCommandRunnerStatus() {\n     final Pair<QueuedCommand, Instant> currentCommand = currentCommandRef.get();\n     if (currentCommand == null) {\n-      return CommandRunnerStatus.RUNNING;\n+      return lastPollTime.get() == null ||\n+          Duration.between(lastPollTime.get(), clock.instant()).toMillis()\n+              < NEW_CMDS_TIMEOUT.toMillis() * 3\n+              ? CommandRunnerStatus.RUNNING : CommandRunnerStatus.ERROR;", "originalCommit": "6d5be45a44999d20fa56bedbae547ab21cd5ef2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI5NDc2MQ==", "url": "https://github.com/confluentinc/ksql/pull/4653#discussion_r385294761", "bodyText": "We only start polling after we processPriorCommands so this could still be useful in the case of the CommandRunner getting stuck on start up.", "author": "stevenpyzhang", "createdAt": "2020-02-27T18:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTE5MA=="}], "type": "inlineReview", "revised_code": {"commit": "9251d032407d07d8dd98933a62d46dcbe7b608a8", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java\nindex cf26643e5e..8a7e938fc3 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java\n\n@@ -266,8 +266,8 @@ public class CommandRunner implements Closeable {\n   CommandRunnerStatus checkCommandRunnerStatus() {\n     final Pair<QueuedCommand, Instant> currentCommand = currentCommandRef.get();\n     if (currentCommand == null) {\n-      return lastPollTime.get() == null ||\n-          Duration.between(lastPollTime.get(), clock.instant()).toMillis()\n+      return lastPollTime.get() == null\n+          || Duration.between(lastPollTime.get(), clock.instant()).toMillis()\n               < NEW_CMDS_TIMEOUT.toMillis() * 3\n               ? CommandRunnerStatus.RUNNING : CommandRunnerStatus.ERROR;\n     }\n"}}, {"oid": "9251d032407d07d8dd98933a62d46dcbe7b608a8", "url": "https://github.com/confluentinc/ksql/commit/9251d032407d07d8dd98933a62d46dcbe7b608a8", "message": "fix: CommandRunner metric correctly reports status of thread if it's dead", "committedDate": "2020-02-27T20:40:23Z", "type": "forcePushed"}, {"oid": "11155cf8812cab889acfd8d0543e42471fe02bda", "url": "https://github.com/confluentinc/ksql/commit/11155cf8812cab889acfd8d0543e42471fe02bda", "message": "fix: CommandRunner metric correctly reports status of thread if it's dead", "committedDate": "2020-02-27T23:26:53Z", "type": "forcePushed"}, {"oid": "235f5bdf83b4586825a4c871ff5afcea46b94cc5", "url": "https://github.com/confluentinc/ksql/commit/235f5bdf83b4586825a4c871ff5afcea46b94cc5", "message": "fix: CommandRunner metric correctly reports status of thread if it's dead", "committedDate": "2020-02-28T00:38:11Z", "type": "forcePushed"}, {"oid": "eda865dbdd2d9d75438991912a0a619045dd7133", "url": "https://github.com/confluentinc/ksql/commit/eda865dbdd2d9d75438991912a0a619045dd7133", "message": "fix: CommandRunner metric correctly reports status of thread if it's dead", "committedDate": "2020-03-02T20:05:01Z", "type": "forcePushed"}, {"oid": "aef463889aa45bffeddfa292b21a5a66fb0953cc", "url": "https://github.com/confluentinc/ksql/commit/aef463889aa45bffeddfa292b21a5a66fb0953cc", "message": "fix: CommandRunner metric correctly reports status of thread if it's dead", "committedDate": "2020-03-02T21:24:41Z", "type": "forcePushed"}, {"oid": "310350de5286cbfea06c125e649fab82cabf575d", "url": "https://github.com/confluentinc/ksql/commit/310350de5286cbfea06c125e649fab82cabf575d", "message": "fix: CommandRunner metric correctly reports status of thread if it's dead", "committedDate": "2020-03-02T21:51:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIzODk0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4653#discussion_r387238945", "bodyText": "why do we need this additional status? Once it's here we have to support it forever. Why is it not enough to know that the runner is up or down?", "author": "rodesai", "createdAt": "2020-03-03T19:20:05Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java", "diffHunk": "@@ -64,11 +64,13 @@\n \n   private final CommandRunnerStatusMetric commandRunnerStatusMetric;\n   private final AtomicReference<Pair<QueuedCommand, Instant>> currentCommandRef;\n+  private final AtomicReference<Instant> lastPollTime;\n   private final Duration commandRunnerHealthTimeout;\n   private final Clock clock;\n \n   public enum CommandRunnerStatus {\n     RUNNING,\n+    STUCK,", "originalCommit": "310350de5286cbfea06c125e649fab82cabf575d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5MTU1OA==", "url": "https://github.com/confluentinc/ksql/pull/4653#discussion_r387891558", "bodyText": "I thought it would be helpful to be able to tell the difference between if the CommandRunner thread is stuck on a particular Command or the thread itself has died.\nIf we do force the server to shut down whenever the CommandRunner thread dies, then this additional status won't be needed.", "author": "stevenpyzhang", "createdAt": "2020-03-04T19:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIzODk0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "11c084996cca1669fbe9e59bcfd98a6644b1c74f", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java\ndeleted file mode 100644\nindex 8a7e938fc3..0000000000\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java\n+++ /dev/null\n\n@@ -1,298 +0,0 @@\n-/*\n- * Copyright 2018 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.rest.server.computation;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import io.confluent.ksql.rest.entity.ClusterTerminateRequest;\n-import io.confluent.ksql.rest.server.state.ServerState;\n-import io.confluent.ksql.rest.util.ClusterTerminator;\n-import io.confluent.ksql.rest.util.TerminateCluster;\n-import io.confluent.ksql.util.Pair;\n-import io.confluent.ksql.util.PersistentQueryMetadata;\n-import io.confluent.ksql.util.RetryUtil;\n-import java.io.Closeable;\n-import java.time.Clock;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import org.apache.kafka.common.errors.WakeupException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Handles the logic of reading distributed commands, including pre-existing commands that were\n- * issued before being initialized, and then delegating their execution to a {@link\n- * InteractiveStatementExecutor}. Also responsible for taking care of any exceptions that occur in\n- * the process.\n- */\n-public class CommandRunner implements Closeable {\n-\n-  private static final Logger LOG = LoggerFactory.getLogger(CommandRunner.class);\n-\n-  private static final int STATEMENT_RETRY_MS = 100;\n-  private static final int MAX_STATEMENT_RETRY_MS = 5 * 1000;\n-  private static final Duration NEW_CMDS_TIMEOUT = Duration.ofMillis(MAX_STATEMENT_RETRY_MS);\n-  private static final int SHUTDOWN_TIMEOUT_MS = 3 * MAX_STATEMENT_RETRY_MS;\n-\n-  private final InteractiveStatementExecutor statementExecutor;\n-  private final CommandQueue commandStore;\n-  private final ExecutorService executor;\n-  private volatile boolean closed = false;\n-  private final int maxRetries;\n-  private final ClusterTerminator clusterTerminator;\n-  private final ServerState serverState;\n-\n-  private final CommandRunnerStatusMetric commandRunnerStatusMetric;\n-  private final AtomicReference<Pair<QueuedCommand, Instant>> currentCommandRef;\n-  private final AtomicReference<Instant> lastPollTime;\n-  private final Duration commandRunnerHealthTimeout;\n-  private final Clock clock;\n-\n-  public enum CommandRunnerStatus {\n-    RUNNING,\n-    STUCK,\n-    ERROR\n-  }\n-\n-  public CommandRunner(\n-      final InteractiveStatementExecutor statementExecutor,\n-      final CommandQueue commandStore,\n-      final int maxRetries,\n-      final ClusterTerminator clusterTerminator,\n-      final ServerState serverState,\n-      final String ksqlServiceId,\n-      final Duration commandRunnerHealthTimeout,\n-      final String metricsGroupPrefix\n-  ) {\n-    this(\n-        statementExecutor,\n-        commandStore,\n-        maxRetries,\n-        clusterTerminator,\n-        Executors.newSingleThreadExecutor(r -> new Thread(r, \"CommandRunner\")),\n-        serverState,\n-        ksqlServiceId,\n-        commandRunnerHealthTimeout,\n-        metricsGroupPrefix,\n-        Clock.systemUTC()\n-    );\n-  }\n-\n-  @VisibleForTesting\n-  CommandRunner(\n-      final InteractiveStatementExecutor statementExecutor,\n-      final CommandQueue commandStore,\n-      final int maxRetries,\n-      final ClusterTerminator clusterTerminator,\n-      final ExecutorService executor,\n-      final ServerState serverState,\n-      final String ksqlServiceId,\n-      final Duration commandRunnerHealthTimeout,\n-      final String metricsGroupPrefix,\n-      final Clock clock\n-  ) {\n-    this.statementExecutor = Objects.requireNonNull(statementExecutor, \"statementExecutor\");\n-    this.commandStore = Objects.requireNonNull(commandStore, \"commandStore\");\n-    this.maxRetries = maxRetries;\n-    this.clusterTerminator = Objects.requireNonNull(clusterTerminator, \"clusterTerminator\");\n-    this.executor = Objects.requireNonNull(executor, \"executor\");\n-    this.serverState = Objects.requireNonNull(serverState, \"serverState\");\n-    this.commandRunnerHealthTimeout =\n-        Objects.requireNonNull(commandRunnerHealthTimeout, \"commandRunnerHealthTimeout\");\n-    this.currentCommandRef = new AtomicReference<>(null);\n-    this.lastPollTime = new AtomicReference<>(null);\n-    this.commandRunnerStatusMetric =\n-        new CommandRunnerStatusMetric(ksqlServiceId, this, metricsGroupPrefix);\n-    this.clock = clock;\n-  }\n-\n-  /**\n-   * Begin a continuous poll-execute loop for the command topic, stopping only if either a\n-   * {@link WakeupException} is thrown or the {@link #close()} method is called.\n-   */\n-  public void start() {\n-    executor.execute(new Runner());\n-    executor.shutdown();\n-  }\n-\n-  /**\n-   * Halt the poll-execute loop.\n-   */\n-  @Override\n-  public void close() {\n-    try {\n-      closed = true;\n-      commandStore.wakeup();\n-      executor.awaitTermination(SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-    } catch (final InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-    }\n-    commandRunnerStatusMetric.close();\n-  }\n-\n-  /**\n-   * Read and execute all commands on the command topic, starting at the earliest offset.\n-   */\n-  public void processPriorCommands() {\n-    try {\n-      final List<QueuedCommand> restoreCommands = commandStore.getRestoreCommands();\n-\n-      LOG.info(\"Restoring previous state from {} commands.\", restoreCommands.size());\n-\n-      final Optional<QueuedCommand> terminateCmd = findTerminateCommand(restoreCommands);\n-      if (terminateCmd.isPresent()) {\n-        LOG.info(\"Cluster previously terminated: terminating.\");\n-        terminateCluster(terminateCmd.get().getCommand());\n-        return;\n-      }\n-\n-      restoreCommands.forEach(\n-          command -> {\n-            currentCommandRef.set(new Pair<>(command, clock.instant()));\n-            RetryUtil.retryWithBackoff(\n-                maxRetries,\n-                STATEMENT_RETRY_MS,\n-                MAX_STATEMENT_RETRY_MS,\n-                () -> statementExecutor.handleRestore(command),\n-                WakeupException.class\n-            );\n-            currentCommandRef.set(null);\n-          }\n-      );\n-\n-      final List<PersistentQueryMetadata> queries = statementExecutor\n-          .getKsqlEngine()\n-          .getPersistentQueries();\n-\n-      LOG.info(\"Restarting {} queries.\", queries.size());\n-\n-      queries.forEach(PersistentQueryMetadata::start);\n-\n-      LOG.info(\"Restore complete\");\n-\n-    } catch (final Exception e) {\n-      LOG.error(\"Error during restore\", e);\n-      throw e;\n-    }\n-  }\n-\n-  void fetchAndRunCommands() {\n-    lastPollTime.set(clock.instant());\n-    final List<QueuedCommand> commands = commandStore.getNewCommands(NEW_CMDS_TIMEOUT);\n-    if (commands.isEmpty()) {\n-      return;\n-    }\n-\n-    final Optional<QueuedCommand> terminateCmd = findTerminateCommand(commands);\n-    if (terminateCmd.isPresent()) {\n-      terminateCluster(terminateCmd.get().getCommand());\n-      return;\n-    }\n-\n-    LOG.debug(\"Found {} new writes to command topic\", commands.size());\n-    for (final QueuedCommand command : commands) {\n-      if (closed) {\n-        return;\n-      }\n-\n-      executeStatement(command);\n-    }\n-  }\n-\n-  private void executeStatement(final QueuedCommand queuedCommand) {\n-    LOG.info(\"Executing statement: \" + queuedCommand.getCommand().getStatement());\n-\n-    final Runnable task = () -> {\n-      if (closed) {\n-        LOG.info(\"Execution aborted as system is closing down\");\n-      } else {\n-        statementExecutor.handleStatement(queuedCommand);\n-        LOG.info(\"Executed statement: \" + queuedCommand.getCommand().getStatement());\n-      }\n-    };\n-\n-    currentCommandRef.set(new Pair<>(queuedCommand, clock.instant()));\n-    RetryUtil.retryWithBackoff(\n-        maxRetries,\n-        STATEMENT_RETRY_MS,\n-        MAX_STATEMENT_RETRY_MS,\n-        task,\n-        WakeupException.class\n-    );\n-    currentCommandRef.set(null);\n-  }\n-\n-  private static Optional<QueuedCommand> findTerminateCommand(\n-      final List<QueuedCommand> restoreCommands\n-  ) {\n-    return restoreCommands.stream()\n-        .filter(command -> command.getCommand().getStatement()\n-            .equalsIgnoreCase(TerminateCluster.TERMINATE_CLUSTER_STATEMENT_TEXT))\n-        .findFirst();\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  private void terminateCluster(final Command command) {\n-    serverState.setTerminating();\n-    LOG.info(\"Terminating the KSQL server.\");\n-    this.close();\n-    final List<String> deleteTopicList = (List<String>) command.getOverwriteProperties()\n-        .getOrDefault(ClusterTerminateRequest.DELETE_TOPIC_LIST_PROP, Collections.emptyList());\n-\n-    clusterTerminator.terminateCluster(deleteTopicList);\n-    LOG.info(\"The KSQL server was terminated.\");\n-  }\n-\n-  CommandRunnerStatus checkCommandRunnerStatus() {\n-    final Pair<QueuedCommand, Instant> currentCommand = currentCommandRef.get();\n-    if (currentCommand == null) {\n-      return lastPollTime.get() == null\n-          || Duration.between(lastPollTime.get(), clock.instant()).toMillis()\n-              < NEW_CMDS_TIMEOUT.toMillis() * 3\n-              ? CommandRunnerStatus.RUNNING : CommandRunnerStatus.ERROR;\n-    }\n-    \n-    return Duration.between(currentCommand.right, clock.instant()).toMillis()\n-        < commandRunnerHealthTimeout.toMillis()\n-        ? CommandRunnerStatus.RUNNING : CommandRunnerStatus.STUCK;\n-  }\n-\n-  private class Runner implements Runnable {\n-\n-    @Override\n-    public void run() {\n-      try {\n-        while (!closed) {\n-          LOG.trace(\"Polling for new writes to command topic\");\n-          fetchAndRunCommands();\n-        }\n-      } catch (final WakeupException wue) {\n-        if (!closed) {\n-          throw wue;\n-        }\n-      } finally {\n-        commandStore.close();\n-      }\n-    }\n-  }\n-}\n"}}, {"oid": "b69ad12a61c3309dadeca5422bcd6b976f2163ab", "url": "https://github.com/confluentinc/ksql/commit/b69ad12a61c3309dadeca5422bcd6b976f2163ab", "message": "fix: CommandRunner metric has correct metric displayed when thread dies", "committedDate": "2020-03-18T22:03:07Z", "type": "commit"}, {"oid": "b69ad12a61c3309dadeca5422bcd6b976f2163ab", "url": "https://github.com/confluentinc/ksql/commit/b69ad12a61c3309dadeca5422bcd6b976f2163ab", "message": "fix: CommandRunner metric has correct metric displayed when thread dies", "committedDate": "2020-03-18T22:03:07Z", "type": "forcePushed"}, {"oid": "11c084996cca1669fbe9e59bcfd98a6644b1c74f", "url": "https://github.com/confluentinc/ksql/commit/11c084996cca1669fbe9e59bcfd98a6644b1c74f", "message": "get rid of the stuck status", "committedDate": "2020-03-20T18:40:48Z", "type": "commit"}, {"oid": "11c084996cca1669fbe9e59bcfd98a6644b1c74f", "url": "https://github.com/confluentinc/ksql/commit/11c084996cca1669fbe9e59bcfd98a6644b1c74f", "message": "get rid of the stuck status", "committedDate": "2020-03-20T18:40:48Z", "type": "forcePushed"}]}