{"pr_number": 6278, "pr_title": "fix: don't use queryId of last terminate command after restore", "pr_createdAt": "2020-09-22T22:28:25Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6278", "timeline": [{"oid": "3a2aa6223d3b8e4eb1fe0f5b3396e26e4389d85d", "url": "https://github.com/confluentinc/ksql/commit/3a2aa6223d3b8e4eb1fe0f5b3396e26e4389d85d", "message": "rebase", "committedDate": "2020-09-22T22:32:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY5NTYzOQ==", "url": "https://github.com/confluentinc/ksql/pull/6278#discussion_r493695639", "bodyText": "making this static is a design smell. if we need to access information from within this class we have two options (1) we can make compact return an object that is a pair of greatestQueryId and the List<QueuedCommand> (2) we can make RestoreCommandsCompactor non-static, and create the instance where we need it\nyou can read along https://stackoverflow.com/questions/7026507/why-are-static-variables-considered-evil for more reasons why", "author": "agavra", "createdAt": "2020-09-23T15:40:48Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java", "diffHunk": "@@ -24,12 +24,17 @@\n import java.util.Map;\n import java.util.Optional;\n import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Util for compacting the restore commands\n  */\n public final class RestoreCommandsCompactor {\n \n+  static QueryId greatestQueryId;", "originalCommit": "1b6b3ddb8ad738e14c1a093b768e94fc3ecebc98", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c7aaca98df597b12f7f44612041e60cfa5663d02", "chunk": "diff --git a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java\nindex 4bce4fd74e..255181bcdf 100644\n--- a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java\n+++ b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java\n\n@@ -32,7 +32,7 @@ import org.slf4j.LoggerFactory;\n  */\n public final class RestoreCommandsCompactor {\n \n-  static QueryId greatestQueryId;\n+  static QueryId lastTerminateQueryId;\n   private static final Logger LOG = LoggerFactory.getLogger(RestoreCommandsCompactor.class);\n \n   private RestoreCommandsCompactor() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY5NTgyOA==", "url": "https://github.com/confluentinc/ksql/pull/6278#discussion_r493695828", "bodyText": "nit: not used", "author": "agavra", "createdAt": "2020-09-23T15:41:05Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java", "diffHunk": "@@ -86,6 +91,8 @@ public static CompactedNode maybeAppend(\n       if (queued.getAndDeserializeCommandId().getType() == Type.TERMINATE) {\n         final QueryId queryId = new QueryId(queued.getAndDeserializeCommandId().getEntity());\n         markShouldSkip(queryId, latestNodeWithId);\n+        //keep track of the last terminate command\n+        //lastTerminateQueryId = queryId;", "originalCommit": "1b6b3ddb8ad738e14c1a093b768e94fc3ecebc98", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c7aaca98df597b12f7f44612041e60cfa5663d02", "chunk": "diff --git a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java\nindex 4bce4fd74e..255181bcdf 100644\n--- a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java\n+++ b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java\n\n@@ -92,7 +92,7 @@ public final class RestoreCommandsCompactor {\n         final QueryId queryId = new QueryId(queued.getAndDeserializeCommandId().getEntity());\n         markShouldSkip(queryId, latestNodeWithId);\n         //keep track of the last terminate command\n-        //lastTerminateQueryId = queryId;\n+        lastTerminateQueryId = queryId;\n \n         // terminate commands don't get added to the list of commands to execute\n         // because we \"execute\" them in this class by removing query plans from\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY5NzkzOQ==", "url": "https://github.com/confluentinc/ksql/pull/6278#discussion_r493697939", "bodyText": "this is breaking an abstraction barrier - we're relying on internal implementations of the string representation of the QueryId which doesn't guarantee that it will match the format that you assume here", "author": "agavra", "createdAt": "2020-09-23T15:44:00Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java", "diffHunk": "@@ -241,6 +254,13 @@ private void executePlan(\n         new CommandStatus(CommandStatus.Status.EXECUTING, \"Executing statement\")\n     );\n     final ExecuteResult result = ksqlEngine.execute(serviceContext, configured);\n+    long queryID = Long.MIN_VALUE;\n+    if (greatestQueryId.isPresent() && mode == Mode.RESTORE) {\n+      final String ltq = greatestQueryId.get().toString();\n+      final int lastIndex = ltq.lastIndexOf(\"_\");\n+      queryID = Long.parseLong(ltq.substring(lastIndex + 1));", "originalCommit": "1b6b3ddb8ad738e14c1a093b768e94fc3ecebc98", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c7aaca98df597b12f7f44612041e60cfa5663d02", "chunk": "diff --git a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java\nindex 5a66ef7630..f21143f7ad 100644\n--- a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java\n+++ b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java\n\n@@ -254,15 +254,20 @@ public class InteractiveStatementExecutor implements KsqlConfigurable {\n         new CommandStatus(CommandStatus.Status.EXECUTING, \"Executing statement\")\n     );\n     final ExecuteResult result = ksqlEngine.execute(serviceContext, configured);\n-    long queryID = Long.MIN_VALUE;\n-    if (greatestQueryId.isPresent() && mode == Mode.RESTORE) {\n-      final String ltq = greatestQueryId.get().toString();\n-      final int lastIndex = ltq.lastIndexOf(\"_\");\n-      queryID = Long.parseLong(ltq.substring(lastIndex + 1));\n-      queryIdGenerator.setNextId(queryID + 1);\n-    }\n     if (result.getQuery().isPresent()) {\n-      queryIdGenerator.setNextId(offset + 1);\n+      long queryID = Long.MIN_VALUE;\n+      if (lastTerminateQueryId.isPresent()) {\n+        final String ltq = lastTerminateQueryId.get().toString();\n+        final int lastIndex = ltq.lastIndexOf(\"_\");\n+        queryID = Long.parseLong(ltq.substring(lastIndex + 1));\n+      }\n+      // We increase the queryID by 1 if the last command was a terminate,\n+      // to avoid the new command getting the same queryId.\n+      if (offset > 0 && offset == queryID - 1) {\n+        queryIdGenerator.setNextId(queryID + 1);\n+      } else {\n+        queryIdGenerator.setNextId(offset + 1);\n+      }\n       if (mode == Mode.EXECUTE) {\n         result.getQuery().get().start();\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkzNzk1Mw==", "url": "https://github.com/confluentinc/ksql/pull/6278#discussion_r493937953", "bodyText": "I'm guessing you didn't mean to keep all of these? This PR doesn't change the handleRestore syntax anymore (same throughout the PR)", "author": "agavra", "createdAt": "2020-09-23T22:50:22Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/CommandRunnerTest.java", "diffHunk": "@@ -160,9 +159,9 @@ public void shouldRunThePriorCommandsCorrectly() {\n \n     // Then:\n     final InOrder inOrder = inOrder(statementExecutor);\n-    inOrder.verify(statementExecutor).handleRestore(eq(queuedCommand1));\n-    inOrder.verify(statementExecutor).handleRestore(eq(queuedCommand2));\n-    inOrder.verify(statementExecutor).handleRestore(eq(queuedCommand3));\n+    inOrder.verify(statementExecutor).handleRestore(eq(queuedCommand1), any());", "originalCommit": "90366a1a21769727398268f42a89d2d390cec238", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db65dcd19ab6214a775dc891e7c251db984ea36f", "chunk": "diff --git a/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/CommandRunnerTest.java b/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/CommandRunnerTest.java\nindex 957a7b92d8..0dc7068f82 100644\n--- a/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/CommandRunnerTest.java\n+++ b/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/CommandRunnerTest.java\n\n@@ -159,9 +165,9 @@ public class CommandRunnerTest {\n \n     // Then:\n     final InOrder inOrder = inOrder(statementExecutor);\n-    inOrder.verify(statementExecutor).handleRestore(eq(queuedCommand1), any());\n-    inOrder.verify(statementExecutor).handleRestore(eq(queuedCommand2), any());\n-    inOrder.verify(statementExecutor).handleRestore(eq(queuedCommand3), any());\n+    inOrder.verify(statementExecutor).handleRestore(queuedCommand1);\n+    inOrder.verify(statementExecutor).handleRestore(queuedCommand2);\n+    inOrder.verify(statementExecutor).handleRestore(queuedCommand3);\n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkzODE3NA==", "url": "https://github.com/confluentinc/ksql/pull/6278#discussion_r493938174", "bodyText": "I feel like I'm blind, what's the difference between these two tests?", "author": "agavra", "createdAt": "2020-09-23T22:51:06Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/RecoveryTest.java", "diffHunk": "@@ -707,9 +704,42 @@ public void shouldRecoverQueryIDs() {\n     final Set<QueryId> queryIdNames = queriesById(server.ksqlEngine.getPersistentQueries())\n         .keySet();\n \n-    assertThat(queryIdNames, contains(new QueryId(\"CSAS_C_0\")));\n+    assertThat(queryIdNames, contains(new QueryId(\"CSAS_C_1\")));\n   }\n \n+  @Test\n+  public void shouldIncrementQueryIDsNoPlans() {\n+    server1.submitCommands(\n+        \"CREATE STREAM A (COLUMN STRING) WITH (KAFKA_TOPIC='A', VALUE_FORMAT='JSON');\",\n+        \"CREATE STREAM B AS SELECT * FROM A;\",\n+        \"TERMINATE CSAS_B_1;\");\n+\n+    final KsqlServer server = new KsqlServer(commands);\n+    server.recover();\n+    server.submitCommands(\"CREATE STREAM C AS SELECT * FROM A;\");\n+    final Set<QueryId> queryIdNames = queriesById(server.ksqlEngine.getPersistentQueries())\n+        .keySet();\n+\n+    assertThat(queryIdNames, contains(new QueryId(\"CSAS_C_2\")));\n+  }\n+\n+  @Test\n+  public void shouldIncrementQueryIDsWithPlan() {", "originalCommit": "90366a1a21769727398268f42a89d2d390cec238", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk0ODIyMA==", "url": "https://github.com/confluentinc/ksql/pull/6278#discussion_r493948220", "bodyText": "No you are not blind, I messes it up somehow. Fixed it though", "author": "vpapavas", "createdAt": "2020-09-23T23:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkzODE3NA=="}], "type": "inlineReview", "revised_code": {"commit": "c7aaca98df597b12f7f44612041e60cfa5663d02", "chunk": "diff --git a/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/RecoveryTest.java b/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/RecoveryTest.java\nindex b2825f20c5..6c7eb843b1 100644\n--- a/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/RecoveryTest.java\n+++ b/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/RecoveryTest.java\n\n@@ -704,42 +710,9 @@ public class RecoveryTest {\n     final Set<QueryId> queryIdNames = queriesById(server.ksqlEngine.getPersistentQueries())\n         .keySet();\n \n-    assertThat(queryIdNames, contains(new QueryId(\"CSAS_C_1\")));\n-  }\n-\n-  @Test\n-  public void shouldIncrementQueryIDsNoPlans() {\n-    server1.submitCommands(\n-        \"CREATE STREAM A (COLUMN STRING) WITH (KAFKA_TOPIC='A', VALUE_FORMAT='JSON');\",\n-        \"CREATE STREAM B AS SELECT * FROM A;\",\n-        \"TERMINATE CSAS_B_1;\");\n-\n-    final KsqlServer server = new KsqlServer(commands);\n-    server.recover();\n-    server.submitCommands(\"CREATE STREAM C AS SELECT * FROM A;\");\n-    final Set<QueryId> queryIdNames = queriesById(server.ksqlEngine.getPersistentQueries())\n-        .keySet();\n-\n-    assertThat(queryIdNames, contains(new QueryId(\"CSAS_C_2\")));\n+    assertThat(queryIdNames, contains(new QueryId(\"CSAS_C_0\")));\n   }\n \n-  @Test\n-  public void shouldIncrementQueryIDsWithPlan() {\n-    server1.submitCommands(\n-        \"CREATE STREAM A (COLUMN STRING) WITH (KAFKA_TOPIC='A', VALUE_FORMAT='JSON');\",\n-        \"CREATE STREAM B AS SELECT * FROM A;\",\n-        \"TERMINATE CSAS_B_1;\");\n-\n-    final KsqlServer server = new KsqlServer(commands);\n-    server.recover();\n-    server.submitCommands(\"CREATE STREAM C AS SELECT * FROM A;\");\n-    final Set<QueryId> queryIdNames = queriesById(server.ksqlEngine.getPersistentQueries())\n-        .keySet();\n-\n-    assertThat(queryIdNames, contains(new QueryId(\"CSAS_C_2\")));\n-  }\n-\n-\n   // Simulate bad commands that have been introduced due to race condition in logic producing to cmd topic\n   private void addDuplicateOfLastCommand() {\n     final QueuedCommand original = commands.get(commands.size() - 1);\n"}}, {"oid": "c7aaca98df597b12f7f44612041e60cfa5663d02", "url": "https://github.com/confluentinc/ksql/commit/c7aaca98df597b12f7f44612041e60cfa5663d02", "message": "rebase", "committedDate": "2020-09-23T22:56:08Z", "type": "commit"}, {"oid": "814c5fe8497d7f479ed469c8a5700004af58ea31", "url": "https://github.com/confluentinc/ksql/commit/814c5fe8497d7f479ed469c8a5700004af58ea31", "message": "increase queryID only for queries, handle all terminate", "committedDate": "2020-09-23T22:57:05Z", "type": "commit"}, {"oid": "eea5ef3f007de0d429c13df28eb5d2bbaf3f6b33", "url": "https://github.com/confluentinc/ksql/commit/eea5ef3f007de0d429c13df28eb5d2bbaf3f6b33", "message": "always increase query id", "committedDate": "2020-09-23T22:57:08Z", "type": "commit"}, {"oid": "db65dcd19ab6214a775dc891e7c251db984ea36f", "url": "https://github.com/confluentinc/ksql/commit/db65dcd19ab6214a775dc891e7c251db984ea36f", "message": "fix compilation", "committedDate": "2020-09-23T22:58:22Z", "type": "commit"}, {"oid": "ae22c0466d1e62d2166bed55c2800402070076ca", "url": "https://github.com/confluentinc/ksql/commit/ae22c0466d1e62d2166bed55c2800402070076ca", "message": "remove my changes", "committedDate": "2020-09-23T23:01:38Z", "type": "commit"}, {"oid": "ae22c0466d1e62d2166bed55c2800402070076ca", "url": "https://github.com/confluentinc/ksql/commit/ae22c0466d1e62d2166bed55c2800402070076ca", "message": "remove my changes", "committedDate": "2020-09-23T23:01:38Z", "type": "forcePushed"}, {"oid": "fcc8bec7281cd37bb8e3b12ec5b394102224289e", "url": "https://github.com/confluentinc/ksql/commit/fcc8bec7281cd37bb8e3b12ec5b394102224289e", "message": "remove my changes", "committedDate": "2020-09-23T23:03:01Z", "type": "commit"}, {"oid": "e82785dc14342eb65bb60d16b7e7846376549bb7", "url": "https://github.com/confluentinc/ksql/commit/e82785dc14342eb65bb60d16b7e7846376549bb7", "message": "remove my changes, fix test case", "committedDate": "2020-09-23T23:11:47Z", "type": "commit"}, {"oid": "44f9da0e755091c357e7a1e5e813ee70d3996118", "url": "https://github.com/confluentinc/ksql/commit/44f9da0e755091c357e7a1e5e813ee70d3996118", "message": "remove print", "committedDate": "2020-09-23T23:13:36Z", "type": "commit"}]}