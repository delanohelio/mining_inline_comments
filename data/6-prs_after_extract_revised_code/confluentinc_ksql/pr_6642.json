{"pr_number": 6642, "pr_title": "chore: make StreamSelectKey generic to handle window repartitions", "pr_createdAt": "2020-11-19T00:25:49Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6642", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MTI2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r527971262", "bodyText": "For my own edification, what's the purpose of marking this EffectivelyImmutable? Is it just as a clue to the reader, or is it necessary since KStreamHolder is marked as Immutable?", "author": "vcrfxia", "createdAt": "2020-11-20T21:10:08Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License; you may not use this file\n+ * except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.serde.WindowInfo;\n+import io.confluent.ksql.testing.EffectivelyImmutable;\n+import java.util.Objects;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Windowed;\n+\n+/**\n+ * The {@code ExecutionKeyFactory} is in charge of creating the keys\n+ * and the Serdes for the keys of any particular execution step.\n+ *\n+ * @param <K> the type of the key, usually either {@code Struct}\n+ *            or {@code Windowed<Struct>}\n+ */\n+@EffectivelyImmutable", "originalCommit": "156027493a902e576d65572d68c8ce69a8009c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4NjgyOQ==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528786829", "bodyText": "The latter (also I just copied it over from KeySerdeFactory, GH couldn't keep track that it's actually the same file because I made so many changes", "author": "agavra", "createdAt": "2020-11-23T15:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MTI2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "chunk": "diff --git a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java\nindex f50f302a4e..86b649a013 100644\n--- a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java\n+++ b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java\n\n@@ -47,9 +47,14 @@ public interface ExecutionKeyFactory<K> {\n   ExecutionKeyFactory<K> withQueryBuilder(KsqlQueryBuilder builder);\n \n   /**\n-   * @return a new key of type {@code K} given the struct conents of the key\n+   * This method can construct a new key given the contents of the old key and the\n+   * desired Struct representation of the new key. This is helpful if we intended\n+   * to maintain information from the previous key (e.g. the windowing information)\n+   * when constructing a new key.\n+   *\n+   * @return a new key of type {@code K} given the struct contents of the new key\n    */\n-  K constructKey(K oldKey, Struct newKey);\n+  K constructNewKey(K oldKey, Struct newKey);\n \n   static ExecutionKeyFactory<Struct> unwindowed(final KsqlQueryBuilder queryBuilder) {\n     return new UnwindowedFactory(queryBuilder);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MjE0Mw==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r527972143", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return a new key of type {@code K} given the struct conents of the key\n          \n          \n            \n               * @return a new key of type {@code K} given the struct contents of the new key and the old key being updated\n          \n      \n    \n    \n  \n\nWould it make more sense to rename this to something like updateKey? I was surprised to see the old key required in a method called constructKey, but maybe updateKey is even more confusing. getNewKey? constructNewKey?", "author": "vcrfxia", "createdAt": "2020-11-20T21:12:17Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License; you may not use this file\n+ * except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.serde.WindowInfo;\n+import io.confluent.ksql.testing.EffectivelyImmutable;\n+import java.util.Objects;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Windowed;\n+\n+/**\n+ * The {@code ExecutionKeyFactory} is in charge of creating the keys\n+ * and the Serdes for the keys of any particular execution step.\n+ *\n+ * @param <K> the type of the key, usually either {@code Struct}\n+ *            or {@code Windowed<Struct>}\n+ */\n+@EffectivelyImmutable\n+public interface ExecutionKeyFactory<K> {\n+\n+  Serde<K> buildKeySerde(\n+      FormatInfo format,\n+      PhysicalSchema physicalSchema,\n+      QueryContext queryContext\n+  );\n+\n+  /**\n+   * @return a new {@code ExecutionKeyFactory}\n+   */\n+  ExecutionKeyFactory<K> withQueryBuilder(KsqlQueryBuilder builder);\n+\n+  /**\n+   * @return a new key of type {@code K} given the struct conents of the key", "originalCommit": "156027493a902e576d65572d68c8ce69a8009c39", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "chunk": "diff --git a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java\nindex f50f302a4e..86b649a013 100644\n--- a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java\n+++ b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java\n\n@@ -47,9 +47,14 @@ public interface ExecutionKeyFactory<K> {\n   ExecutionKeyFactory<K> withQueryBuilder(KsqlQueryBuilder builder);\n \n   /**\n-   * @return a new key of type {@code K} given the struct conents of the key\n+   * This method can construct a new key given the contents of the old key and the\n+   * desired Struct representation of the new key. This is helpful if we intended\n+   * to maintain information from the previous key (e.g. the windowing information)\n+   * when constructing a new key.\n+   *\n+   * @return a new key of type {@code K} given the struct contents of the new key\n    */\n-  K constructKey(K oldKey, Struct newKey);\n+  K constructNewKey(K oldKey, Struct newKey);\n \n   static ExecutionKeyFactory<Struct> unwindowed(final KsqlQueryBuilder queryBuilder) {\n     return new UnwindowedFactory(queryBuilder);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MjMwNg==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r527972306", "bodyText": "Rename to getKeyFactory() or getExecutionKeyFactory()?", "author": "vcrfxia", "createdAt": "2020-11-20T21:12:42Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/KStreamHolder.java", "diffHunk": "@@ -25,21 +25,21 @@\n public final class KStreamHolder<K> {\n \n   private final KStream<K, GenericRow> stream;\n-  private final KeySerdeFactory<K> keySerdeFactory;\n+  private final ExecutionKeyFactory<K> executionKeyFactory;\n   private final LogicalSchema schema;\n \n   public KStreamHolder(\n       final KStream<K, GenericRow> stream,\n       final LogicalSchema schema,\n-      final KeySerdeFactory<K> keySerdeFactory\n+      final ExecutionKeyFactory<K> executionKeyFactory\n   ) {\n     this.stream = Objects.requireNonNull(stream, \"stream\");\n-    this.keySerdeFactory = Objects.requireNonNull(keySerdeFactory, \"keySerdeFactory\");\n+    this.executionKeyFactory = Objects.requireNonNull(executionKeyFactory, \"keySerdeFactory\");\n     this.schema = Objects.requireNonNull(schema, \"schema\");\n   }\n \n-  public KeySerdeFactory<K> getKeySerdeFactory() {\n-    return keySerdeFactory;\n+  public ExecutionKeyFactory<K> getKeySerdeFactory() {", "originalCommit": "156027493a902e576d65572d68c8ce69a8009c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NjY3NA==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528876674", "bodyText": "It doesn't look like changes were made even though this comment was resolved?", "author": "vcrfxia", "createdAt": "2020-11-23T17:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MjMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyMjE1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528922155", "bodyText": "ah oops! I had made this change somewhere else and just assumed that was the place this was pointing at. I'll update it", "author": "agavra", "createdAt": "2020-11-23T18:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MjMwNg=="}], "type": "inlineReview", "revised_code": {"commit": "4874c2b1abb1dc71fb78aa1b4a1566d178b5a147", "chunk": "diff --git a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/KStreamHolder.java b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/KStreamHolder.java\nindex 09b11a419c..6b1f227421 100644\n--- a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/KStreamHolder.java\n+++ b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/KStreamHolder.java\n\n@@ -38,7 +38,7 @@ public final class KStreamHolder<K> {\n     this.schema = Objects.requireNonNull(schema, \"schema\");\n   }\n \n-  public ExecutionKeyFactory<K> getKeySerdeFactory() {\n+  public ExecutionKeyFactory<K> getExecutionKeyFactory() {\n     return executionKeyFactory;\n   }\n \n"}}, {"oid": "9dcc4b79de97caaa578d8ffc23b163a2546de610", "url": "https://github.com/confluentinc/ksql/commit/9dcc4b79de97caaa578d8ffc23b163a2546de610", "message": "chore: make StreamSelectKey generic to handle window repartitions", "committedDate": "2020-11-20T23:56:28Z", "type": "commit"}, {"oid": "207dc4e94ae2260b112e1c000767aae8f8fea467", "url": "https://github.com/confluentinc/ksql/commit/207dc4e94ae2260b112e1c000767aae8f8fea467", "message": "chore: rebase and update for table select key", "committedDate": "2020-11-23T15:48:39Z", "type": "forcePushed"}, {"oid": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "url": "https://github.com/confluentinc/ksql/commit/d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "message": "chore: rebase and update for table select key", "committedDate": "2020-11-23T15:52:06Z", "type": "commit"}, {"oid": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "url": "https://github.com/confluentinc/ksql/commit/d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "message": "chore: rebase and update for table select key", "committedDate": "2020-11-23T15:52:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NDMwNw==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528874307", "bodyText": "Out of curiosity, what's the thinking for removing this conditional? Even though it's currently the case that this block can only be entered if forceRepartition is true, that may not be the case in the future.\nIf you're going to remove this, you should be able to remove the UC_USELESS_CONDITION suppression at the top of the method as well.", "author": "vcrfxia", "createdAt": "2020-11-23T17:25:42Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -175,12 +173,11 @@ public SchemaKTable(\n     if (keyFormat.isWindowed()) {\n       final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n           + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n-      final String additionalMsg = forceRepartition", "originalCommit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNDYxOQ==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528924619", "bodyText": "I just blindly followed IntelliJ's recommendations. I'll change it back", "author": "agavra", "createdAt": "2020-11-23T18:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NDMwNw=="}], "type": "inlineReview", "revised_code": {"commit": "4874c2b1abb1dc71fb78aa1b4a1566d178b5a147", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java b/ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java\nindex 2fffd1eab2..b594923fae 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java\n\n@@ -173,14 +173,14 @@ public class SchemaKTable<K> extends SchemaKStream<K> {\n     if (keyFormat.isWindowed()) {\n       final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n           + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n-      final String additionalMsg =\n-          \" As a result, ksqlDB does not support joins on windowed sources with \"\n-              + \"Schema-Registry-enabled key formats (AVRO, JSON_SR, PROTOBUF) at this time. \"\n-              + \"Please repartition your sources to use a different key format before performing \"\n-              + \"the join.\";\n+      final String additionalMsg = forceRepartition\n+          ? \" As a result, ksqlDB does not support joins on windowed sources with \"\n+          + \"Schema-Registry-enabled key formats (AVRO, JSON_SR, PROTOBUF) at this time. \"\n+          + \"Please repartition your sources to use a different key format before performing \"\n+          + \"the join.\"\n+          : \"\";\n       throw new KsqlException(errorMsg + additionalMsg);\n     }\n-\n     final KeyFormat newKeyFormat = forceInternalKeyFormat\n         .map(newFmt -> KeyFormat.of(\n             newFmt,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NjYzMQ==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528876631", "bodyText": "Hm, the word \"representation\" is confusing to me. I don't think I'd understand this comment without the context in this PR. This makes more sense to me:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * This method can construct a new key given the contents of the old key and the\n          \n          \n            \n               * desired Struct representation of the new key. This is helpful if we intended\n          \n          \n            \n               * This method can construct a new key given the old key and the\n          \n          \n            \n               * desired contents of the new key. This is helpful if we intended\n          \n      \n    \n    \n  \n\nbut I guess \"contents\" means different things to different people. The number of calls to this method are relatively few so it's probably fine if the comment isn't crystal clear.", "author": "vcrfxia", "createdAt": "2020-11-23T17:29:19Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License; you may not use this file\n+ * except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.serde.WindowInfo;\n+import io.confluent.ksql.testing.EffectivelyImmutable;\n+import java.util.Objects;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Windowed;\n+\n+/**\n+ * The {@code ExecutionKeyFactory} is in charge of creating the keys\n+ * and the Serdes for the keys of any particular execution step.\n+ *\n+ * @param <K> the type of the key, usually either {@code Struct}\n+ *            or {@code Windowed<Struct>}\n+ */\n+@EffectivelyImmutable\n+public interface ExecutionKeyFactory<K> {\n+\n+  Serde<K> buildKeySerde(\n+      FormatInfo format,\n+      PhysicalSchema physicalSchema,\n+      QueryContext queryContext\n+  );\n+\n+  /**\n+   * @return a new {@code ExecutionKeyFactory}\n+   */\n+  ExecutionKeyFactory<K> withQueryBuilder(KsqlQueryBuilder builder);\n+\n+  /**\n+   * This method can construct a new key given the contents of the old key and the\n+   * desired Struct representation of the new key. This is helpful if we intended", "originalCommit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4874c2b1abb1dc71fb78aa1b4a1566d178b5a147", "chunk": "diff --git a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java\nindex 86b649a013..79f8741d67 100644\n--- a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java\n+++ b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java\n\n@@ -47,8 +47,8 @@ public interface ExecutionKeyFactory<K> {\n   ExecutionKeyFactory<K> withQueryBuilder(KsqlQueryBuilder builder);\n \n   /**\n-   * This method can construct a new key given the contents of the old key and the\n-   * desired Struct representation of the new key. This is helpful if we intended\n+   * This method can construct a new key given the old key and the\n+   * desired contents of the new key. This is helpful if we intended\n    * to maintain information from the previous key (e.g. the windowing information)\n    * when constructing a new key.\n    *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NjcxNg==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528876716", "bodyText": "nit: spacing", "author": "vcrfxia", "createdAt": "2020-11-23T17:29:28Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -181,15 +183,15 @@ private static LogicalSchema buildSchema(\n \n     final KeyBuilder keyBuilder = StructKeyUtil.keyBuilder(resultSchema);\n \n-    return (k, v) -> {\n-      final Object newKey = evaluator.evaluate(k, v);\n-      final Struct structKey = keyBuilder.build(newKey, 0);\n+    return (oldK, row) -> {\n+      final Object newKey = evaluator.evaluate(oldK, row);\n+      final K key = executionKeyFactory.constructNewKey(oldK ,keyBuilder.build(newKey, 0));", "originalCommit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4874c2b1abb1dc71fb78aa1b4a1566d178b5a147", "chunk": "diff --git a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java\nindex 412fd256aa..b026882225 100644\n--- a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java\n+++ b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java\n\n@@ -185,7 +185,7 @@ public final class PartitionByParamsFactory {\n \n     return (oldK, row) -> {\n       final Object newKey = evaluator.evaluate(oldK, row);\n-      final K key = executionKeyFactory.constructNewKey(oldK ,keyBuilder.build(newKey, 0));\n+      final K key = executionKeyFactory.constructNewKey(oldK, keyBuilder.build(newKey, 0));\n \n       if (row != null && appendNewKey) {\n         row.append(newKey);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3Njc0NQ==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528876745", "bodyText": "How come we create a new ExecutionKeyFactory implementation here rather than using ExecutionKeyFactory.unwindowed() with a mock query builder?", "author": "vcrfxia", "createdAt": "2020-11-23T17:29:33Z", "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/PartitionByParamsFactoryTest.java", "diffHunk": "@@ -396,9 +400,35 @@ public void shouldNotChangeValueIfPartitioningByNull() {\n     assertThat(result.value, is(GenericRow.fromList(originals)));\n   }\n \n-  private PartitionByParams partitionBy(final Expression expression) {\n+  private PartitionByParams<Struct> partitionBy(final Expression expression) {\n+    final ExecutionKeyFactory<Struct> factory = new ExecutionKeyFactory<Struct>() {", "originalCommit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNjgwMA==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528926800", "bodyText": "No good reason, I've changed it to do this.", "author": "agavra", "createdAt": "2020-11-23T18:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3Njc0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4874c2b1abb1dc71fb78aa1b4a1566d178b5a147", "chunk": "diff --git a/ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/PartitionByParamsFactoryTest.java b/ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/PartitionByParamsFactoryTest.java\nindex 46f11be120..af674f3b78 100644\n--- a/ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/PartitionByParamsFactoryTest.java\n+++ b/ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/PartitionByParamsFactoryTest.java\n\n@@ -401,25 +403,7 @@ public class PartitionByParamsFactoryTest {\n   }\n \n   private PartitionByParams<Struct> partitionBy(final Expression expression) {\n-    final ExecutionKeyFactory<Struct> factory = new ExecutionKeyFactory<Struct>() {\n-      @Override\n-      public Serde<Struct> buildKeySerde(\n-          final FormatInfo format,\n-          final PhysicalSchema physicalSchema,\n-          final QueryContext queryContext) {\n-        return null;\n-      }\n-\n-      @Override\n-      public ExecutionKeyFactory<Struct> withQueryBuilder(final KsqlQueryBuilder builder) {\n-        return null;\n-      }\n-\n-      @Override\n-      public Struct constructNewKey(final Struct oldKey, final Struct newKey) {\n-        return newKey;\n-      }\n-    };\n+    final ExecutionKeyFactory<Struct> factory = ExecutionKeyFactory.unwindowed(queryBuilder);\n \n     return PartitionByParamsFactory\n         .build(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3Njc3OA==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528876778", "bodyText": "nit: spacing", "author": "vcrfxia", "createdAt": "2020-11-23T17:29:36Z", "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/StreamSelectKeyBuilderTest.java", "diffHunk": "@@ -148,7 +157,7 @@ public void shouldPassCorrectArgsToParamBuilder() {\n     // Then:\n     verify(paramBuilder).build(\n         SOURCE_SCHEMA,\n-        KEY,\n+        stream.getKeySerdeFactory(), KEY,", "originalCommit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNzEwMg==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528927102", "bodyText": ":) auto-refactoring - thanks for catching", "author": "agavra", "createdAt": "2020-11-23T18:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3Njc3OA=="}], "type": "inlineReview", "revised_code": {"commit": "4874c2b1abb1dc71fb78aa1b4a1566d178b5a147", "chunk": "diff --git a/ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/StreamSelectKeyBuilderTest.java b/ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/StreamSelectKeyBuilderTest.java\nindex d1d8978919..9ed9e3663c 100644\n--- a/ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/StreamSelectKeyBuilderTest.java\n+++ b/ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/StreamSelectKeyBuilderTest.java\n\n@@ -157,7 +157,8 @@ public class StreamSelectKeyBuilderTest {\n     // Then:\n     verify(paramBuilder).build(\n         SOURCE_SCHEMA,\n-        stream.getKeySerdeFactory(), KEY,\n+        stream.getExecutionKeyFactory(),\n+        KEY,\n         CONFIG,\n         functionRegistry,\n         processingLogger\n"}}, {"oid": "4874c2b1abb1dc71fb78aa1b4a1566d178b5a147", "url": "https://github.com/confluentinc/ksql/commit/4874c2b1abb1dc71fb78aa1b4a1566d178b5a147", "message": "chore: some minor updates", "committedDate": "2020-11-23T18:57:35Z", "type": "commit"}, {"oid": "ab156b9857b475cc51de51003af027da21a7b065", "url": "https://github.com/confluentinc/ksql/commit/ab156b9857b475cc51de51003af027da21a7b065", "message": "test me", "committedDate": "2020-11-23T19:45:23Z", "type": "commit"}]}