{"pr_number": 6014, "pr_title": "feat: latest and earliest ByOffset UDFs to capture N values", "pr_createdAt": "2020-08-13T08:43:24Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6014", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMTIyNw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469911227", "bodyText": "Would you mind backing out formatting changes such as this. It causes unnecessary churn in the code base, (making merges and diffs harder) and adds unnecessary code changes that need reviewing. Thanks.\n(I think some of these formatting changes may also make the build fail!)\nI'll take other formatting changes in the PR that should be backed out to with 'revert formatting please'", "author": "big-andy-coates", "createdAt": "2020-08-13T12:23:41Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -1,16 +1,15 @@\n /*\n  * Copyright 2020 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use this file except", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -1,15 +1,16 @@\n /*\n  * Copyright 2020 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n  *\n  * http://www.confluent.io/confluent-community-license\n  *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and limitations under the\n- * License.\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n  */\n \n package io.confluent.ksql.function.udaf.offset;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMTI3Nw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469911277", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:23:47Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -1,16 +1,15 @@\n /*\n  * Copyright 2020 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n  *\n  * http://www.confluent.io/confluent-community-license\n  *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and limitations under the\n+ * License.", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -1,15 +1,16 @@\n /*\n  * Copyright 2020 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n  *\n  * http://www.confluent.io/confluent-community-license\n  *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and limitations under the\n- * License.\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n  */\n \n package io.confluent.ksql.function.udaf.offset;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMTM0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469911349", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:23:55Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -27,86 +28,53 @@ import io.confluent.ksql.function.udaf.Udaf;\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n-import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR)\n+@UdafDescription(\n+    name = \"EARLIEST_BY_OFFSET\",\n+    description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR\n+)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest N value for the column, computed by offset.\";\n+      \"This function returns the oldest value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {}\n+  private EarliestByOffset() {\n+  }\n \n   static AtomicLong sequence = new AtomicLong();\n \n-  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n-\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n-  @UdafFactory(description = \"return the earliest n values of an integer column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n-  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n-    return earliestN(STRUCT_INTEGER, topNSize);\n-  }\n-\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of an long column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n-  public static Udaf<Long, List<Struct>, List<Long>> earliestLong(final int topNSize) {\n-    return earliestN(STRUCT_LONG, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a double column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> earliestDouble() {\n     return earliest(STRUCT_DOUBLE);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a double column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n-  public static Udaf<Double, List<Struct>, List<Double>> earliestDouble(final int topNSize) {\n-    return earliestN(STRUCT_DOUBLE, topNSize);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a boolean column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n   public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {\n     return earliest(STRUCT_BOOLEAN);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a boolean column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\")\n-  public static Udaf<Boolean, List<Struct>, List<Boolean>> earliestBoolean(final int topNSize) {\n-    return earliestN(STRUCT_BOOLEAN, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a string column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL STRING>\")\n   public static Udaf<String, Struct, String> earliestString() {\n     return earliest(STRUCT_STRING);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a string column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL STRING>>\")\n-  public static Udaf<String, List<Struct>, List<String>> earliestString(final int topNSize) {\n-    return earliestN(STRUCT_STRING, topNSize);\n-  }\n \n   static <T> Struct createStruct(final Schema schema, final T val) {\n     final Struct struct = new Struct(schema);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMTYwNw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469911607", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:24:20Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {\n-  }\n+  private EarliestByOffset() {}", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -27,86 +28,53 @@ import io.confluent.ksql.function.udaf.Udaf;\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n-import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR)\n+@UdafDescription(\n+    name = \"EARLIEST_BY_OFFSET\",\n+    description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR\n+)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest N value for the column, computed by offset.\";\n+      \"This function returns the oldest value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {}\n+  private EarliestByOffset() {\n+  }\n \n   static AtomicLong sequence = new AtomicLong();\n \n-  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n-\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n-  @UdafFactory(description = \"return the earliest n values of an integer column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n-  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n-    return earliestN(STRUCT_INTEGER, topNSize);\n-  }\n-\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of an long column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n-  public static Udaf<Long, List<Struct>, List<Long>> earliestLong(final int topNSize) {\n-    return earliestN(STRUCT_LONG, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a double column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> earliestDouble() {\n     return earliest(STRUCT_DOUBLE);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a double column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n-  public static Udaf<Double, List<Struct>, List<Double>> earliestDouble(final int topNSize) {\n-    return earliestN(STRUCT_DOUBLE, topNSize);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a boolean column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n   public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {\n     return earliest(STRUCT_BOOLEAN);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a boolean column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\")\n-  public static Udaf<Boolean, List<Struct>, List<Boolean>> earliestBoolean(final int topNSize) {\n-    return earliestN(STRUCT_BOOLEAN, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a string column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL STRING>\")\n   public static Udaf<String, Struct, String> earliestString() {\n     return earliest(STRUCT_STRING);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a string column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL STRING>>\")\n-  public static Udaf<String, List<Struct>, List<String>> earliestString(final int topNSize) {\n-    return earliestN(STRUCT_STRING, topNSize);\n-  }\n \n   static <T> Struct createStruct(final Schema schema, final T val) {\n     final Struct struct = new Struct(schema);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjExNQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912115", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:10Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -1,16 +1,15 @@\n /*\n  * Copyright 2019 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\nindex d48b66915c..3a46a51d3e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n\n@@ -1,15 +1,16 @@\n /*\n  * Copyright 2019 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n  *\n  * http://www.confluent.io/confluent-community-license\n  *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and limitations under the\n- * License.\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n  */\n \n package io.confluent.ksql.function.udaf.offset;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjE1Nw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912157", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:14Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -1,16 +1,15 @@\n /*\n  * Copyright 2019 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n  *\n  * http://www.confluent.io/confluent-community-license\n  *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and limitations under the\n+ * License.", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\nindex d48b66915c..3a46a51d3e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n\n@@ -1,15 +1,16 @@\n /*\n  * Copyright 2019 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n  *\n  * http://www.confluent.io/confluent-community-license\n  *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and limitations under the\n- * License.\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n  */\n \n package io.confluent.ksql.function.udaf.offset;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjIzNg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912236", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:24Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -35,8 +36,7 @@\n   @Test\n   public void shouldInitialize() {\n     // Given:\n-    final Udaf<Integer, Struct, Integer> udaf = LatestByOffset\n-        .latest(STRUCT_LONG);\n+    final Udaf<Integer, Struct, Integer> udaf = LatestByOffset.latest(STRUCT_LONG);", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\nindex d48b66915c..3a46a51d3e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n\n@@ -36,7 +35,8 @@ public class LatestByOffsetUdafTest {\n   @Test\n   public void shouldInitialize() {\n     // Given:\n-    final Udaf<Integer, Struct, Integer> udaf = LatestByOffset.latest(STRUCT_LONG);\n+    final Udaf<Integer, Struct, Integer> udaf = LatestByOffset\n+        .latest(STRUCT_LONG);\n \n     // When:\n     Struct init = udaf.initialize();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjM1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912355", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:38Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -45,19 +45,48 @@ public void shouldInitialize() {\n     assertThat(init, is(notNullValue()));\n   }\n \n+  @Test\n+  public void shouldInitializeLatest2Integers() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestN(STRUCT_LONG, 2);\n+\n+    // When:\n+    List<Struct> init = udaf.initialize();\n+\n+    // Then:\n+    assertThat(init, is(notNullValue()));\n+  }\n+\n   @Test\n   public void shouldComputeLatestInteger() {\n     // Given:\n     final Udaf<Integer, Struct, Integer> udaf = LatestByOffset.latestInteger();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123, LatestByOffset.createStruct(STRUCT_INTEGER, 321));\n+    Struct res = udaf.aggregate(123, LatestByOffset.createStruct(STRUCT_INTEGER, 321));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\nindex d48b66915c..3a46a51d3e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n\n@@ -45,48 +45,19 @@ public class LatestByOffsetUdafTest {\n     assertThat(init, is(notNullValue()));\n   }\n \n-  @Test\n-  public void shouldInitializeLatest2Integers() {\n-    // Given:\n-    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestN(STRUCT_LONG, 2);\n-\n-    // When:\n-    List<Struct> init = udaf.initialize();\n-\n-    // Then:\n-    assertThat(init, is(notNullValue()));\n-  }\n-\n   @Test\n   public void shouldComputeLatestInteger() {\n     // Given:\n     final Udaf<Integer, Struct, Integer> udaf = LatestByOffset.latestInteger();\n \n     // When:\n-    Struct res = udaf.aggregate(123, LatestByOffset.createStruct(STRUCT_INTEGER, 321));\n+    Struct res = udaf\n+        .aggregate(123, LatestByOffset.createStruct(STRUCT_INTEGER, 321));\n \n     // Then:\n     assertThat(res.get(VAL_FIELD), is(123));\n   }\n \n-  @Test\n-  public void shouldComputeLatest2Integers() {\n-    // Given:\n-    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(2);\n-\n-    List<Struct> list = new ArrayList<>();\n-    list.add(LatestByOffset.createStruct(STRUCT_INTEGER, 321));\n-\n-    // When:\n-    List<Struct> res = udaf.aggregate(123, list);\n-\n-    assertThat(list.size(), is(2));\n-    // Then:\n-    assertThat(res.get(0).get(VAL_FIELD), is(321));\n-    assertThat(res.get(1).get(VAL_FIELD), is(123));\n-\n-  }\n-\n   @Test\n   public void shouldMerge() {\n     // Given:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjQwMw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912403", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:43Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -96,57 +148,150 @@ public void shouldMergeWithOverflow() {\n     assertThat(merged2, is(agg2));\n   }\n \n+  @Test\n+  public void shouldMergeWithOverflow1Integer() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n+\n+    LatestByOffset.sequence.set(Long.MAX_VALUE);\n+\n+    List<Struct> agg1 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n+    List<Struct> agg2 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n+    List<Struct> agg3 =\n+        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n+\n+    // When:\n+    List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n+    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n+    assertThat(merged1, is(agg2));\n+    assertThat(merged2, is(agg2));\n+  }\n+\n \n   @Test\n   public void shouldComputeLatestLong() {\n     // Given:\n     final Udaf<Long, Struct, Long> udaf = LatestByOffset.latestLong();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+    Struct res = udaf.aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\nindex d48b66915c..3a46a51d3e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n\n@@ -148,31 +96,6 @@ public class LatestByOffsetUdafTest {\n     assertThat(merged2, is(agg2));\n   }\n \n-  @Test\n-  public void shouldMergeWithOverflow1Integer() {\n-    // Given:\n-    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n-\n-    LatestByOffset.sequence.set(Long.MAX_VALUE);\n-\n-    List<Struct> agg1 =\n-        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n-    List<Struct> agg2 =\n-        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n-    List<Struct> agg3 =\n-        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n-\n-    // When:\n-    List<Struct> merged1 = udaf.merge(agg1, agg2);\n-    List<Struct> merged2 = udaf.merge(agg2, agg1);\n-\n-    // Then:\n-    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n-    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n-    assertThat(merged1, is(agg2));\n-    assertThat(merged2, is(agg2));\n-  }\n-\n \n   @Test\n   public void shouldComputeLatestLong() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjQzMg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912432", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:47Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -96,57 +148,150 @@ public void shouldMergeWithOverflow() {\n     assertThat(merged2, is(agg2));\n   }\n \n+  @Test\n+  public void shouldMergeWithOverflow1Integer() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n+\n+    LatestByOffset.sequence.set(Long.MAX_VALUE);\n+\n+    List<Struct> agg1 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n+    List<Struct> agg2 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n+    List<Struct> agg3 =\n+        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n+\n+    // When:\n+    List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n+    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n+    assertThat(merged1, is(agg2));\n+    assertThat(merged2, is(agg2));\n+  }\n+\n \n   @Test\n   public void shouldComputeLatestLong() {\n     // Given:\n     final Udaf<Long, Struct, Long> udaf = LatestByOffset.latestLong();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+    Struct res = udaf.aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n \n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(123L));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Longs() {\n+    // Given:\n+    final Udaf<Long, List<Struct>, List<Long>> udaf = LatestByOffset.latestLong(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(123L, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(321L));\n+    assertThat(res.get(1).get(VAL_FIELD), is(123L));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestDouble() {\n     // Given:\n     final Udaf<Double, Struct, Double> udaf = LatestByOffset.latestDouble();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n+    Struct res = udaf.aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\nindex d48b66915c..3a46a51d3e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n\n@@ -148,31 +96,6 @@ public class LatestByOffsetUdafTest {\n     assertThat(merged2, is(agg2));\n   }\n \n-  @Test\n-  public void shouldMergeWithOverflow1Integer() {\n-    // Given:\n-    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n-\n-    LatestByOffset.sequence.set(Long.MAX_VALUE);\n-\n-    List<Struct> agg1 =\n-        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n-    List<Struct> agg2 =\n-        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n-    List<Struct> agg3 =\n-        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n-\n-    // When:\n-    List<Struct> merged1 = udaf.merge(agg1, agg2);\n-    List<Struct> merged2 = udaf.merge(agg2, agg1);\n-\n-    // Then:\n-    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n-    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n-    assertThat(merged1, is(agg2));\n-    assertThat(merged2, is(agg2));\n-  }\n-\n \n   @Test\n   public void shouldComputeLatestLong() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjQ1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912455", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:50Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -96,57 +148,150 @@ public void shouldMergeWithOverflow() {\n     assertThat(merged2, is(agg2));\n   }\n \n+  @Test\n+  public void shouldMergeWithOverflow1Integer() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n+\n+    LatestByOffset.sequence.set(Long.MAX_VALUE);\n+\n+    List<Struct> agg1 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n+    List<Struct> agg2 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n+    List<Struct> agg3 =\n+        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n+\n+    // When:\n+    List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n+    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n+    assertThat(merged1, is(agg2));\n+    assertThat(merged2, is(agg2));\n+  }\n+\n \n   @Test\n   public void shouldComputeLatestLong() {\n     // Given:\n     final Udaf<Long, Struct, Long> udaf = LatestByOffset.latestLong();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+    Struct res = udaf.aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n \n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(123L));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Longs() {\n+    // Given:\n+    final Udaf<Long, List<Struct>, List<Long>> udaf = LatestByOffset.latestLong(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(123L, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(321L));\n+    assertThat(res.get(1).get(VAL_FIELD), is(123L));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestDouble() {\n     // Given:\n     final Udaf<Double, Struct, Double> udaf = LatestByOffset.latestDouble();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n+    Struct res = udaf.aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n \n     // Then:\n     assertThat(res.getFloat64(VAL_FIELD), is(1.1d));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Doubles() {\n+    // Given:\n+    final Udaf<Double, List<Struct>, List<Double>> udaf = LatestByOffset.latestDouble(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(1.1d, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(2.2d));\n+    assertThat(res.get(1).get(VAL_FIELD), is(1.1d));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestBoolean() {\n     // Given:\n     final Udaf<Boolean, Struct, Boolean> udaf = LatestByOffset.latestBoolean();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(true, LatestByOffset.createStruct(STRUCT_BOOLEAN, false));\n+    Struct res = udaf.aggregate(true, LatestByOffset.createStruct(STRUCT_BOOLEAN, false));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\nindex d48b66915c..3a46a51d3e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n\n@@ -148,31 +96,6 @@ public class LatestByOffsetUdafTest {\n     assertThat(merged2, is(agg2));\n   }\n \n-  @Test\n-  public void shouldMergeWithOverflow1Integer() {\n-    // Given:\n-    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n-\n-    LatestByOffset.sequence.set(Long.MAX_VALUE);\n-\n-    List<Struct> agg1 =\n-        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n-    List<Struct> agg2 =\n-        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n-    List<Struct> agg3 =\n-        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n-\n-    // When:\n-    List<Struct> merged1 = udaf.merge(agg1, agg2);\n-    List<Struct> merged2 = udaf.merge(agg2, agg1);\n-\n-    // Then:\n-    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n-    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n-    assertThat(merged1, is(agg2));\n-    assertThat(merged2, is(agg2));\n-  }\n-\n \n   @Test\n   public void shouldComputeLatestLong() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjQ3Nw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912477", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:53Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -96,57 +148,150 @@ public void shouldMergeWithOverflow() {\n     assertThat(merged2, is(agg2));\n   }\n \n+  @Test\n+  public void shouldMergeWithOverflow1Integer() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n+\n+    LatestByOffset.sequence.set(Long.MAX_VALUE);\n+\n+    List<Struct> agg1 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n+    List<Struct> agg2 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n+    List<Struct> agg3 =\n+        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n+\n+    // When:\n+    List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n+    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n+    assertThat(merged1, is(agg2));\n+    assertThat(merged2, is(agg2));\n+  }\n+\n \n   @Test\n   public void shouldComputeLatestLong() {\n     // Given:\n     final Udaf<Long, Struct, Long> udaf = LatestByOffset.latestLong();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+    Struct res = udaf.aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n \n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(123L));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Longs() {\n+    // Given:\n+    final Udaf<Long, List<Struct>, List<Long>> udaf = LatestByOffset.latestLong(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(123L, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(321L));\n+    assertThat(res.get(1).get(VAL_FIELD), is(123L));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestDouble() {\n     // Given:\n     final Udaf<Double, Struct, Double> udaf = LatestByOffset.latestDouble();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n+    Struct res = udaf.aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n \n     // Then:\n     assertThat(res.getFloat64(VAL_FIELD), is(1.1d));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Doubles() {\n+    // Given:\n+    final Udaf<Double, List<Struct>, List<Double>> udaf = LatestByOffset.latestDouble(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(1.1d, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(2.2d));\n+    assertThat(res.get(1).get(VAL_FIELD), is(1.1d));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestBoolean() {\n     // Given:\n     final Udaf<Boolean, Struct, Boolean> udaf = LatestByOffset.latestBoolean();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(true, LatestByOffset.createStruct(STRUCT_BOOLEAN, false));\n+    Struct res = udaf.aggregate(true, LatestByOffset.createStruct(STRUCT_BOOLEAN, false));\n \n     // Then:\n     assertThat(res.getBoolean(VAL_FIELD), is(true));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Booleans() {\n+    // Given:\n+    final Udaf<Boolean, List<Struct>, List<Boolean>> udaf = LatestByOffset.latestBoolean(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_BOOLEAN, true));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(false, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(true));\n+    assertThat(res.get(1).get(VAL_FIELD), is(false));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestString() {\n     // Given:\n     final Udaf<String, Struct, String> udaf = LatestByOffset.latestString();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(\"foo\", LatestByOffset.createStruct(STRUCT_STRING, \"bar\"));\n+    Struct res = udaf.aggregate(\"foo\", LatestByOffset.createStruct(STRUCT_STRING, \"bar\"));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\nindex d48b66915c..3a46a51d3e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n\n@@ -148,31 +96,6 @@ public class LatestByOffsetUdafTest {\n     assertThat(merged2, is(agg2));\n   }\n \n-  @Test\n-  public void shouldMergeWithOverflow1Integer() {\n-    // Given:\n-    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n-\n-    LatestByOffset.sequence.set(Long.MAX_VALUE);\n-\n-    List<Struct> agg1 =\n-        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n-    List<Struct> agg2 =\n-        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n-    List<Struct> agg3 =\n-        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n-\n-    // When:\n-    List<Struct> merged1 = udaf.merge(agg1, agg2);\n-    List<Struct> merged2 = udaf.merge(agg2, agg1);\n-\n-    // Then:\n-    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n-    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n-    assertThat(merged1, is(agg2));\n-    assertThat(merged2, is(agg2));\n-  }\n-\n \n   @Test\n   public void shouldComputeLatestLong() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxNTAyNA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469915024", "bodyText": "nit: can be private.", "author": "big-andy-coates", "createdAt": "2020-08-13T12:30:12Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {\n-  }\n+  private EarliestByOffset() {}\n \n   static AtomicLong sequence = new AtomicLong();\n \n+  static final Comparator<Struct> structComparator = new EarliestStructComparator();", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -27,86 +28,53 @@ import io.confluent.ksql.function.udaf.Udaf;\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n-import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR)\n+@UdafDescription(\n+    name = \"EARLIEST_BY_OFFSET\",\n+    description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR\n+)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest N value for the column, computed by offset.\";\n+      \"This function returns the oldest value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {}\n+  private EarliestByOffset() {\n+  }\n \n   static AtomicLong sequence = new AtomicLong();\n \n-  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n-\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n-  @UdafFactory(description = \"return the earliest n values of an integer column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n-  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n-    return earliestN(STRUCT_INTEGER, topNSize);\n-  }\n-\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of an long column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n-  public static Udaf<Long, List<Struct>, List<Long>> earliestLong(final int topNSize) {\n-    return earliestN(STRUCT_LONG, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a double column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> earliestDouble() {\n     return earliest(STRUCT_DOUBLE);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a double column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n-  public static Udaf<Double, List<Struct>, List<Double>> earliestDouble(final int topNSize) {\n-    return earliestN(STRUCT_DOUBLE, topNSize);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a boolean column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n   public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {\n     return earliest(STRUCT_BOOLEAN);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a boolean column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\")\n-  public static Udaf<Boolean, List<Struct>, List<Boolean>> earliestBoolean(final int topNSize) {\n-    return earliestN(STRUCT_BOOLEAN, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a string column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL STRING>\")\n   public static Udaf<String, Struct, String> earliestString() {\n     return earliest(STRUCT_STRING);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a string column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL STRING>>\")\n-  public static Udaf<String, List<Struct>, List<String>> earliestString(final int topNSize) {\n-    return earliestN(STRUCT_STRING, topNSize);\n-  }\n \n   static <T> Struct createStruct(final Schema schema, final T val) {\n     final Struct struct = new Struct(schema);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxNTA2OA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469915068", "bodyText": "nit: can be private.", "author": "big-andy-coates", "createdAt": "2020-08-13T12:30:17Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java", "diffHunk": "@@ -40,43 +45,75 @@\n public final class LatestByOffset {\n \n   static final String DESCRIPTION =\n-      \"This function returns the most recent value for the column, computed by offset.\";\n+      \"This function returns the most recent n values for the column, computed by offset.\";\n \n   private LatestByOffset() {\n   }\n \n   static AtomicLong sequence = new AtomicLong();\n+  \n+  static final Comparator<Struct> structComparator  = new LatestStructComparator();", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2bbaf7afb2fc85b5801a5c544f8d9943dc7bc241", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\nindex 9b843252d7..37692acf29 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\n\n@@ -55,60 +55,70 @@ public final class LatestByOffset {\n   static final Comparator<Struct> structComparator  = new LatestStructComparator();\n \n   @UdafFactory(description = \"return the latest value of an integer column\",\n+      paramSchema = \"STRUCT<SEQ BIGINT, VAL INT>\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> latestInteger() {\n     return latest(STRUCT_INTEGER);\n   }\n   \n   @UdafFactory(description = \"return the latest value of an integer column\",\n+      paramSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\",\n       aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n   public static Udaf<Integer, List<Struct>, List<Integer>> latestInteger(final int topNSize) {\n     return latestN(STRUCT_INTEGER, topNSize);\n   }\n \n   @UdafFactory(description = \"return the latest value of an big integer column\",\n+      paramSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> latestLong() {\n     return latest(STRUCT_LONG);\n   }\n   \n   @UdafFactory(description = \"return the latest value of an big integer column\",\n+      paramSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\",\n       aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n   public static Udaf<Long, List<Struct>, List<Long>> latestLong(final int topNSize) {\n     return latestN(STRUCT_LONG, topNSize);\n   }\n \n   @UdafFactory(description = \"return the latest value of a double column\",\n+      paramSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> latestDouble() {\n     return latest(STRUCT_DOUBLE);\n   }\n   \n   @UdafFactory(description = \"return the latest value of a double column\",\n+      paramSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\",\n       aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n   public static Udaf<Double, List<Struct>, List<Double>> latestDouble(final int topNSize) {\n     return latestN(STRUCT_DOUBLE, topNSize);\n   }\n \n   @UdafFactory(description = \"return the latest value of a boolean column\",\n+      paramSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n   public static Udaf<Boolean, Struct, Boolean> latestBoolean() {\n     return latest(STRUCT_BOOLEAN);\n   }\n   \n   @UdafFactory(description = \"return the latest value of a boolean column\",\n+      paramSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\",\n       aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\")\n   public static Udaf<Boolean, List<Struct>, List<Boolean>> latestBoolean(final int topNSize) {\n     return latestN(STRUCT_BOOLEAN, topNSize);\n   }\n \n   @UdafFactory(description = \"return the latest value of a string column\",\n+      paramSchema = \"STRUCT<SEQ BIGINT, VAL STRING>\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL STRING>\")\n   public static Udaf<String, Struct, String> latestString() {\n     return latest(STRUCT_STRING);\n   }\n   \n   @UdafFactory(description = \"return the latest value of a string column\",\n+      paramSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL STRING>>\",\n       aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL STRING>>\")\n   public static Udaf<String, List<Struct>, List<String>> latestString(final int topNSize) {\n     return latestN(STRUCT_STRING, topNSize);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxNzc2Ng==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469917766", "bodyText": "Can I request two changes to each of these new methods please?\n\nCan we make these new methods plural, please? e.g. earliestIntegers given they return multiple. (The method name can be logged in some places and this will help differentiate from the existing method).\nCan we rename the parameter topNSize to something like earliestN?. (The parameter is output during a DESCRIBE of the function and this name is more intuitive.  topNSize suggests functionality akin to TOPK method, which this is not).\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n          \n          \n            \n              public static Udaf<Integer, List<Struct>, List<Integer>> earliestIntegers(final int earliestN) {\n          \n      \n    \n    \n  \n\nCan you make the same changes to each of the methods in this class and LatestByOffset please, (obviously changing the param to latestN.", "author": "big-andy-coates", "createdAt": "2020-08-13T12:35:17Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {\n-  }\n+  private EarliestByOffset() {}\n \n   static AtomicLong sequence = new AtomicLong();\n \n+  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n+\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n+  @UdafFactory(description = \"return the earliest n values of an integer column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n+  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -27,86 +28,53 @@ import io.confluent.ksql.function.udaf.Udaf;\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n-import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR)\n+@UdafDescription(\n+    name = \"EARLIEST_BY_OFFSET\",\n+    description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR\n+)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest N value for the column, computed by offset.\";\n+      \"This function returns the oldest value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {}\n+  private EarliestByOffset() {\n+  }\n \n   static AtomicLong sequence = new AtomicLong();\n \n-  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n-\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n-  @UdafFactory(description = \"return the earliest n values of an integer column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n-  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n-    return earliestN(STRUCT_INTEGER, topNSize);\n-  }\n-\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of an long column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n-  public static Udaf<Long, List<Struct>, List<Long>> earliestLong(final int topNSize) {\n-    return earliestN(STRUCT_LONG, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a double column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> earliestDouble() {\n     return earliest(STRUCT_DOUBLE);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a double column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n-  public static Udaf<Double, List<Struct>, List<Double>> earliestDouble(final int topNSize) {\n-    return earliestN(STRUCT_DOUBLE, topNSize);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a boolean column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n   public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {\n     return earliest(STRUCT_BOOLEAN);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a boolean column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\")\n-  public static Udaf<Boolean, List<Struct>, List<Boolean>> earliestBoolean(final int topNSize) {\n-    return earliestN(STRUCT_BOOLEAN, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a string column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL STRING>\")\n   public static Udaf<String, Struct, String> earliestString() {\n     return earliest(STRUCT_STRING);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a string column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL STRING>>\")\n-  public static Udaf<String, List<Struct>, List<String>> earliestString(final int topNSize) {\n-    return earliestN(STRUCT_STRING, topNSize);\n-  }\n \n   static <T> Struct createStruct(final Schema schema, final T val) {\n     final Struct struct = new Struct(schema);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxODAwOQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469918009", "bodyText": "Bug!\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return earliestN(STRUCT_LONG, 2);\n          \n          \n            \n                return earliestN(STRUCT_LONG, topNSize);", "author": "big-andy-coates", "createdAt": "2020-08-13T12:35:45Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {\n-  }\n+  private EarliestByOffset() {}\n \n   static AtomicLong sequence = new AtomicLong();\n \n+  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n+\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n+  @UdafFactory(description = \"return the earliest n values of an integer column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n+  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n+    return earliestN(STRUCT_INTEGER, topNSize);\n+  }\n+\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest n values of an long column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n+  public static Udaf<Long, List<Struct>, List<Long>> earliestLong(final int topNSize) {\n+    return earliestN(STRUCT_LONG, 2);", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -27,86 +28,53 @@ import io.confluent.ksql.function.udaf.Udaf;\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n-import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR)\n+@UdafDescription(\n+    name = \"EARLIEST_BY_OFFSET\",\n+    description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR\n+)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest N value for the column, computed by offset.\";\n+      \"This function returns the oldest value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {}\n+  private EarliestByOffset() {\n+  }\n \n   static AtomicLong sequence = new AtomicLong();\n \n-  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n-\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n-  @UdafFactory(description = \"return the earliest n values of an integer column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n-  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n-    return earliestN(STRUCT_INTEGER, topNSize);\n-  }\n-\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of an long column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n-  public static Udaf<Long, List<Struct>, List<Long>> earliestLong(final int topNSize) {\n-    return earliestN(STRUCT_LONG, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a double column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> earliestDouble() {\n     return earliest(STRUCT_DOUBLE);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a double column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n-  public static Udaf<Double, List<Struct>, List<Double>> earliestDouble(final int topNSize) {\n-    return earliestN(STRUCT_DOUBLE, topNSize);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a boolean column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n   public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {\n     return earliest(STRUCT_BOOLEAN);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a boolean column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\")\n-  public static Udaf<Boolean, List<Struct>, List<Boolean>> earliestBoolean(final int topNSize) {\n-    return earliestN(STRUCT_BOOLEAN, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a string column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL STRING>\")\n   public static Udaf<String, Struct, String> earliestString() {\n     return earliest(STRUCT_STRING);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a string column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL STRING>>\")\n-  public static Udaf<String, List<Struct>, List<String>> earliestString(final int topNSize) {\n-    return earliestN(STRUCT_STRING, topNSize);\n-  }\n \n   static <T> Struct createStruct(final Schema schema, final T val) {\n     final Struct struct = new Struct(schema);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxODE1NA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469918154", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return earliestN(STRUCT_BOOLEAN, 2);\n          \n          \n            \n                return earliestN(STRUCT_BOOLEAN, topNSize);", "author": "big-andy-coates", "createdAt": "2020-08-13T12:36:02Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {\n-  }\n+  private EarliestByOffset() {}\n \n   static AtomicLong sequence = new AtomicLong();\n \n+  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n+\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n+  @UdafFactory(description = \"return the earliest n values of an integer column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n+  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n+    return earliestN(STRUCT_INTEGER, topNSize);\n+  }\n+\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest n values of an long column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n+  public static Udaf<Long, List<Struct>, List<Long>> earliestLong(final int topNSize) {\n+    return earliestN(STRUCT_LONG, 2);\n+  }\n \n   @UdafFactory(description = \"return the earliest value of a double column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> earliestDouble() {\n     return earliest(STRUCT_DOUBLE);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest n values of a double column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n+  public static Udaf<Double, List<Struct>, List<Double>> earliestDouble(final int topNSize) {\n+    return earliestN(STRUCT_DOUBLE, topNSize);\n+  }\n \n   @UdafFactory(description = \"return the earliest value of a boolean column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n   public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {\n     return earliest(STRUCT_BOOLEAN);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest n values of a boolean column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\")\n+  public static Udaf<Boolean, List<Struct>, List<Boolean>> earliestBoolean(final int topNSize) {\n+    return earliestN(STRUCT_BOOLEAN, 2);", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -27,86 +28,53 @@ import io.confluent.ksql.function.udaf.Udaf;\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n-import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR)\n+@UdafDescription(\n+    name = \"EARLIEST_BY_OFFSET\",\n+    description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR\n+)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest N value for the column, computed by offset.\";\n+      \"This function returns the oldest value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {}\n+  private EarliestByOffset() {\n+  }\n \n   static AtomicLong sequence = new AtomicLong();\n \n-  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n-\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n-  @UdafFactory(description = \"return the earliest n values of an integer column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n-  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n-    return earliestN(STRUCT_INTEGER, topNSize);\n-  }\n-\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of an long column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n-  public static Udaf<Long, List<Struct>, List<Long>> earliestLong(final int topNSize) {\n-    return earliestN(STRUCT_LONG, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a double column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> earliestDouble() {\n     return earliest(STRUCT_DOUBLE);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a double column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n-  public static Udaf<Double, List<Struct>, List<Double>> earliestDouble(final int topNSize) {\n-    return earliestN(STRUCT_DOUBLE, topNSize);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a boolean column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n   public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {\n     return earliest(STRUCT_BOOLEAN);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a boolean column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\")\n-  public static Udaf<Boolean, List<Struct>, List<Boolean>> earliestBoolean(final int topNSize) {\n-    return earliestN(STRUCT_BOOLEAN, 2);\n-  }\n \n   @UdafFactory(description = \"return the earliest value of a string column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL STRING>\")\n   public static Udaf<String, Struct, String> earliestString() {\n     return earliest(STRUCT_STRING);\n   }\n-  \n-  @UdafFactory(description = \"return the earliest n values of a string column\",\n-      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL STRING>>\")\n-  public static Udaf<String, List<Struct>, List<String>> earliestString(final int topNSize) {\n-    return earliestN(STRUCT_STRING, topNSize);\n-  }\n \n   static <T> Struct createStruct(final Schema schema, final T val) {\n     final Struct struct = new Struct(schema);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyMDUxMQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469920511", "bodyText": "Can preallocate and also don't need the generics:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new ArrayList<Struct>();\n          \n          \n            \n                    return new ArrayList<>(topNSize);", "author": "big-andy-coates", "createdAt": "2020-08-13T12:40:14Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -123,4 +155,54 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+\n+\n+  @UdafFactory(description = \"Earliest N by offset\")\n+  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n+      final int topNSize) {\n+    return new Udaf<T, List<Struct>, List<T>>() {\n+      @Override\n+      public List<Struct> initialize() {\n+        return new ArrayList<Struct>();", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -155,54 +123,4 @@ public final class EarliestByOffset {\n       }\n     };\n   }\n-\n-\n-  @UdafFactory(description = \"Earliest N by offset\")\n-  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n-      final int topNSize) {\n-    return new Udaf<T, List<Struct>, List<T>>() {\n-      @Override\n-      public List<Struct> initialize() {\n-        return new ArrayList<Struct>();\n-      }\n-\n-      @Override\n-      public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n-        final int currentSize = aggregate.size();\n-        if (currentSize == topNSize) {\n-          return aggregate;\n-        } else {\n-\n-          if (current == null) {\n-            return aggregate;\n-          }\n-\n-          aggregate.add(createStruct(structSchema, current));\n-          return aggregate.subList(0, aggregate.size());\n-        }\n-\n-\n-      }\n-\n-      @Override\n-      public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n-        final List<Struct> merged = new ArrayList<>();\n-        merged.addAll(aggOne);\n-        merged.addAll(aggTwo);\n-        final int currentSize = merged.size();\n-        Collections.sort(merged, structComparator);\n-        if (currentSize <= topNSize) {\n-          return merged;\n-        } else {\n-          return merged.subList(0, topNSize);\n-        }\n-      }\n-\n-      @Override\n-      @SuppressWarnings(\"unchecked\")\n-      public List<T> map(final List<Struct> agg) {\n-        return (List<T>) agg.stream().map(s -> s.get(VAL_FIELD)).collect(Collectors.toList());\n-      }\n-    };\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyNTAxMA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469925010", "bodyText": "Formatting + subList call isn't needed.\nHow about:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  @Override\n          \n          \n            \n                  public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n          \n          \n            \n                    final int currentSize = aggregate.size();\n          \n          \n            \n                    if (currentSize == topNSize) {\n          \n          \n            \n                      return aggregate;\n          \n          \n            \n                    } else {\n          \n          \n            \n            \n          \n          \n            \n                      if (current == null) {\n          \n          \n            \n                        return aggregate;\n          \n          \n            \n                      }\n          \n          \n            \n            \n          \n          \n            \n                      aggregate.add(createStruct(structSchema, current));\n          \n          \n            \n                      return aggregate.subList(0, aggregate.size());\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n                  }\n          \n          \n            \n                  @Override\n          \n          \n            \n                  public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n          \n          \n            \n                    if (current == null) {\n          \n          \n            \n                      return aggregate;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (aggregate.size() < topNSize) {\n          \n          \n            \n                      aggregate.add(createStruct(structSchema, current));\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return aggregate;\n          \n          \n            \n                  }", "author": "big-andy-coates", "createdAt": "2020-08-13T12:47:48Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -123,4 +155,54 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+\n+\n+  @UdafFactory(description = \"Earliest N by offset\")\n+  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n+      final int topNSize) {\n+    return new Udaf<T, List<Struct>, List<T>>() {\n+      @Override\n+      public List<Struct> initialize() {\n+        return new ArrayList<Struct>();\n+      }\n+\n+      @Override\n+      public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n+        final int currentSize = aggregate.size();\n+        if (currentSize == topNSize) {\n+          return aggregate;\n+        } else {\n+\n+          if (current == null) {\n+            return aggregate;\n+          }\n+\n+          aggregate.add(createStruct(structSchema, current));\n+          return aggregate.subList(0, aggregate.size());\n+        }\n+\n+\n+      }", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -155,54 +123,4 @@ public final class EarliestByOffset {\n       }\n     };\n   }\n-\n-\n-  @UdafFactory(description = \"Earliest N by offset\")\n-  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n-      final int topNSize) {\n-    return new Udaf<T, List<Struct>, List<T>>() {\n-      @Override\n-      public List<Struct> initialize() {\n-        return new ArrayList<Struct>();\n-      }\n-\n-      @Override\n-      public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n-        final int currentSize = aggregate.size();\n-        if (currentSize == topNSize) {\n-          return aggregate;\n-        } else {\n-\n-          if (current == null) {\n-            return aggregate;\n-          }\n-\n-          aggregate.add(createStruct(structSchema, current));\n-          return aggregate.subList(0, aggregate.size());\n-        }\n-\n-\n-      }\n-\n-      @Override\n-      public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n-        final List<Struct> merged = new ArrayList<>();\n-        merged.addAll(aggOne);\n-        merged.addAll(aggTwo);\n-        final int currentSize = merged.size();\n-        Collections.sort(merged, structComparator);\n-        if (currentSize <= topNSize) {\n-          return merged;\n-        } else {\n-          return merged.subList(0, topNSize);\n-        }\n-      }\n-\n-      @Override\n-      @SuppressWarnings(\"unchecked\")\n-      public List<T> map(final List<Struct> agg) {\n-        return (List<T>) agg.stream().map(s -> s.get(VAL_FIELD)).collect(Collectors.toList());\n-      }\n-    };\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyNTUyMQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469925521", "bodyText": "Not required - this line can be deleted. This is not a UDAF factory. (The function above you copied is wrong too in case you were wondering).", "author": "big-andy-coates", "createdAt": "2020-08-13T12:48:41Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -123,4 +155,54 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+\n+\n+  @UdafFactory(description = \"Earliest N by offset\")", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxNDM5Ng==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r470614396", "bodyText": "will remove. it was in the original methods for earliest() and latest(). will remove those too.", "author": "sarwarbhuiyan", "createdAt": "2020-08-14T13:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyNTUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -155,54 +123,4 @@ public final class EarliestByOffset {\n       }\n     };\n   }\n-\n-\n-  @UdafFactory(description = \"Earliest N by offset\")\n-  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n-      final int topNSize) {\n-    return new Udaf<T, List<Struct>, List<T>>() {\n-      @Override\n-      public List<Struct> initialize() {\n-        return new ArrayList<Struct>();\n-      }\n-\n-      @Override\n-      public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n-        final int currentSize = aggregate.size();\n-        if (currentSize == topNSize) {\n-          return aggregate;\n-        } else {\n-\n-          if (current == null) {\n-            return aggregate;\n-          }\n-\n-          aggregate.add(createStruct(structSchema, current));\n-          return aggregate.subList(0, aggregate.size());\n-        }\n-\n-\n-      }\n-\n-      @Override\n-      public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n-        final List<Struct> merged = new ArrayList<>();\n-        merged.addAll(aggOne);\n-        merged.addAll(aggTwo);\n-        final int currentSize = merged.size();\n-        Collections.sort(merged, structComparator);\n-        if (currentSize <= topNSize) {\n-          return merged;\n-        } else {\n-          return merged.subList(0, topNSize);\n-        }\n-      }\n-\n-      @Override\n-      @SuppressWarnings(\"unchecked\")\n-      public List<T> map(final List<Struct> agg) {\n-        return (List<T>) agg.stream().map(s -> s.get(VAL_FIELD)).collect(Collectors.toList());\n-      }\n-    };\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNDMyMg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469934322", "bodyText": "Can pre-allocate the array and simplify the code:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  @Override\n          \n          \n            \n                  public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n          \n          \n            \n                    final List<Struct> merged = new ArrayList<>();\n          \n          \n            \n                    merged.addAll(aggOne);\n          \n          \n            \n                    merged.addAll(aggTwo);\n          \n          \n            \n                    final int currentSize = merged.size();\n          \n          \n            \n                    Collections.sort(merged, structComparator);\n          \n          \n            \n                    if (currentSize <= topNSize) {\n          \n          \n            \n                      return merged;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      return merged.subList(0, topNSize);\n          \n          \n            \n                    }\n          \n          \n            \n                  }\n          \n          \n            \n                  @Override\n          \n          \n            \n                  public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n          \n          \n            \n                    final List<Struct> merged = new ArrayList<>(aggOne.size() + aggTwo.size());\n          \n          \n            \n                    merged.addAll(aggOne);\n          \n          \n            \n                    merged.addAll(aggTwo);\n          \n          \n            \n                    merged.sort(structComparator);\n          \n          \n            \n                    return merged.subList(0, Math.min(topNSize, merged.size()));\n          \n          \n            \n                  }\n          \n      \n    \n    \n  \n\nPlus, I noticed there's not test to cover the code path where the merged array is smaller than topNSize. Worth adding that.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:03:23Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -123,4 +155,54 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+\n+\n+  @UdafFactory(description = \"Earliest N by offset\")\n+  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n+      final int topNSize) {\n+    return new Udaf<T, List<Struct>, List<T>>() {\n+      @Override\n+      public List<Struct> initialize() {\n+        return new ArrayList<Struct>();\n+      }\n+\n+      @Override\n+      public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n+        final int currentSize = aggregate.size();\n+        if (currentSize == topNSize) {\n+          return aggregate;\n+        } else {\n+\n+          if (current == null) {\n+            return aggregate;\n+          }\n+\n+          aggregate.add(createStruct(structSchema, current));\n+          return aggregate.subList(0, aggregate.size());\n+        }\n+\n+\n+      }\n+\n+      @Override\n+      public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n+        final List<Struct> merged = new ArrayList<>();\n+        merged.addAll(aggOne);\n+        merged.addAll(aggTwo);\n+        final int currentSize = merged.size();\n+        Collections.sort(merged, structComparator);\n+        if (currentSize <= topNSize) {\n+          return merged;\n+        } else {\n+          return merged.subList(0, topNSize);\n+        }\n+      }", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxOTQ0NQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r470619445", "bodyText": "added", "author": "sarwarbhuiyan", "createdAt": "2020-08-14T13:21:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNDMyMg=="}], "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -155,54 +123,4 @@ public final class EarliestByOffset {\n       }\n     };\n   }\n-\n-\n-  @UdafFactory(description = \"Earliest N by offset\")\n-  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n-      final int topNSize) {\n-    return new Udaf<T, List<Struct>, List<T>>() {\n-      @Override\n-      public List<Struct> initialize() {\n-        return new ArrayList<Struct>();\n-      }\n-\n-      @Override\n-      public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n-        final int currentSize = aggregate.size();\n-        if (currentSize == topNSize) {\n-          return aggregate;\n-        } else {\n-\n-          if (current == null) {\n-            return aggregate;\n-          }\n-\n-          aggregate.add(createStruct(structSchema, current));\n-          return aggregate.subList(0, aggregate.size());\n-        }\n-\n-\n-      }\n-\n-      @Override\n-      public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n-        final List<Struct> merged = new ArrayList<>();\n-        merged.addAll(aggOne);\n-        merged.addAll(aggTwo);\n-        final int currentSize = merged.size();\n-        Collections.sort(merged, structComparator);\n-        if (currentSize <= topNSize) {\n-          return merged;\n-        } else {\n-          return merged.subList(0, topNSize);\n-        }\n-      }\n-\n-      @Override\n-      @SuppressWarnings(\"unchecked\")\n-      public List<T> map(final List<Struct> agg) {\n-        return (List<T>) agg.stream().map(s -> s.get(VAL_FIELD)).collect(Collectors.toList());\n-      }\n-    };\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NTE0MQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469945141", "bodyText": "This class is duplicate LatestStructComparator, i.e. the code is the same!  And the function below duplicates the exist KudafByOffsetUtils.compareStructs.\nCan I suggest deleting these two new comparator files, and instead replacing the compareStructs method in KudafByOffsetUtils with a comparator, e.g.\nclass  KudafByOffsetUtils {\n  ...\n  public static final Comparator<Struct> INTERMEDIATE_STRUCT_COMPARATOR = (struct1, struct2) -> {\n    // Deal with overflow - we assume if one is positive and the other negative then the sequence\n    // has overflowed - in which case the latest is the one with the smallest sequence\n    final long sequence1 = struct1.getInt64(SEQ_FIELD);\n    final long sequence2 = struct2.getInt64(SEQ_FIELD);\n    if (sequence1 < 0 && sequence2 >= 0) {\n      return 1;\n    } else if (sequence2 < 0 && sequence1 >= 0) {\n      return -1;\n    } else {\n      return Long.compare(sequence1, sequence2);\n    }\n  };\n  ...\n}\nAnd then use this everywhere, including replacing the current use of compareStructs with INTERMEDIATE_STRUCT_COMPARATOR.compare.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:20:11Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestStructComparator.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function.udaf.offset;\n+\n+import static io.confluent.ksql.function.udaf.KudafByOffsetUtils.SEQ_FIELD;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+import org.apache.kafka.connect.data.Struct;\n+\n+public class EarliestStructComparator implements Comparator<Struct>, Serializable {", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxOTYyNw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r470619627", "bodyText": "done", "author": "sarwarbhuiyan", "createdAt": "2020-08-14T13:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NTE0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestStructComparator.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestStructComparator.java\ndeleted file mode 100644\nindex c1650e2a1a..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestStructComparator.java\n+++ /dev/null\n\n@@ -1,42 +0,0 @@\n-/*\n- * Copyright 2019 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.function.udaf.offset;\n-\n-import static io.confluent.ksql.function.udaf.KudafByOffsetUtils.SEQ_FIELD;\n-\n-import java.io.Serializable;\n-import java.util.Comparator;\n-import org.apache.kafka.connect.data.Struct;\n-\n-public class EarliestStructComparator implements Comparator<Struct>, Serializable {\n-\n-  private static final long serialVersionUID = 1L;\n-\n-  @Override\n-  public int compare(final Struct struct1, final Struct struct2) {\n-    // Deal with overflow - we assume if one is positive and the other negative then the sequence\n-    // has overflowed - in which case the latest is the one with the smallest sequence\n-    final long sequence1 = struct1.getInt64(SEQ_FIELD);\n-    final long sequence2 = struct2.getInt64(SEQ_FIELD);\n-    if (sequence1 < 0 && sequence2 >= 0) {\n-      return 1;\n-    } else if (sequence2 < 0 && sequence1 >= 0) {\n-      return -1;\n-    } else {\n-      return Long.compare(sequence1, sequence2);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NTYwMg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469945602", "bodyText": "As above, delete this.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:20:53Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestStructComparator.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function.udaf.offset;\n+\n+import static io.confluent.ksql.function.udaf.KudafByOffsetUtils.SEQ_FIELD;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+import org.apache.kafka.connect.data.Struct;\n+\n+public class LatestStructComparator implements Comparator<Struct>, Serializable {", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2f37f9bbbb7c46924b0fdcc8e2f70be3249542c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestStructComparator.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestStructComparator.java\ndeleted file mode 100644\nindex 91dc0eb5e5..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestStructComparator.java\n+++ /dev/null\n\n@@ -1,40 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.function.udaf.offset;\n-\n-import static io.confluent.ksql.function.udaf.KudafByOffsetUtils.SEQ_FIELD;\n-\n-import java.io.Serializable;\n-import java.util.Comparator;\n-import org.apache.kafka.connect.data.Struct;\n-\n-public class LatestStructComparator implements Comparator<Struct>, Serializable {\n-  \n-  private static final long serialVersionUID = 1L;\n-\n-  @Override\n-  public int compare(final Struct struct1, final Struct struct2) {\n-    final long sequence1 = struct1.getInt64(SEQ_FIELD);\n-    final long sequence2 = struct2.getInt64(SEQ_FIELD);\n-    if (sequence1 < 0 && sequence2 >= 0) {\n-      return 1;\n-    } else if (sequence2 < 0 && sequence1 >= 0) {\n-      return -1;\n-    } else {\n-      return Long.compare(sequence1, sequence2);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NjI5NA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469946294", "bodyText": "Same changes to the new functions in this file, as were done to the ones in EarliestByOffset, i.e. plural method names and param names changes to latestN.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:21:53Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java", "diffHunk": "@@ -40,43 +45,75 @@\n public final class LatestByOffset {\n \n   static final String DESCRIPTION =\n-      \"This function returns the most recent value for the column, computed by offset.\";\n+      \"This function returns the most recent n values for the column, computed by offset.\";\n \n   private LatestByOffset() {\n   }\n \n   static AtomicLong sequence = new AtomicLong();\n+  \n+  static final Comparator<Struct> structComparator  = new LatestStructComparator();\n \n   @UdafFactory(description = \"return the latest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> latestInteger() {\n     return latest(STRUCT_INTEGER);\n   }\n+  \n+  @UdafFactory(description = \"return the latest value of an integer column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n+  public static Udaf<Integer, List<Struct>, List<Integer>> latestInteger(final int topNSize) {\n+    return latestN(STRUCT_INTEGER, topNSize);\n+  }", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2bbaf7afb2fc85b5801a5c544f8d9943dc7bc241", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\nindex 9b843252d7..37692acf29 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\n\n@@ -55,60 +55,70 @@ public final class LatestByOffset {\n   static final Comparator<Struct> structComparator  = new LatestStructComparator();\n \n   @UdafFactory(description = \"return the latest value of an integer column\",\n+      paramSchema = \"STRUCT<SEQ BIGINT, VAL INT>\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> latestInteger() {\n     return latest(STRUCT_INTEGER);\n   }\n   \n   @UdafFactory(description = \"return the latest value of an integer column\",\n+      paramSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\",\n       aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n   public static Udaf<Integer, List<Struct>, List<Integer>> latestInteger(final int topNSize) {\n     return latestN(STRUCT_INTEGER, topNSize);\n   }\n \n   @UdafFactory(description = \"return the latest value of an big integer column\",\n+      paramSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> latestLong() {\n     return latest(STRUCT_LONG);\n   }\n   \n   @UdafFactory(description = \"return the latest value of an big integer column\",\n+      paramSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\",\n       aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n   public static Udaf<Long, List<Struct>, List<Long>> latestLong(final int topNSize) {\n     return latestN(STRUCT_LONG, topNSize);\n   }\n \n   @UdafFactory(description = \"return the latest value of a double column\",\n+      paramSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> latestDouble() {\n     return latest(STRUCT_DOUBLE);\n   }\n   \n   @UdafFactory(description = \"return the latest value of a double column\",\n+      paramSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\",\n       aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n   public static Udaf<Double, List<Struct>, List<Double>> latestDouble(final int topNSize) {\n     return latestN(STRUCT_DOUBLE, topNSize);\n   }\n \n   @UdafFactory(description = \"return the latest value of a boolean column\",\n+      paramSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n   public static Udaf<Boolean, Struct, Boolean> latestBoolean() {\n     return latest(STRUCT_BOOLEAN);\n   }\n   \n   @UdafFactory(description = \"return the latest value of a boolean column\",\n+      paramSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\",\n       aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\")\n   public static Udaf<Boolean, List<Struct>, List<Boolean>> latestBoolean(final int topNSize) {\n     return latestN(STRUCT_BOOLEAN, topNSize);\n   }\n \n   @UdafFactory(description = \"return the latest value of a string column\",\n+      paramSchema = \"STRUCT<SEQ BIGINT, VAL STRING>\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL STRING>\")\n   public static Udaf<String, Struct, String> latestString() {\n     return latest(STRUCT_STRING);\n   }\n   \n   @UdafFactory(description = \"return the latest value of a string column\",\n+      paramSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL STRING>>\",\n       aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL STRING>>\")\n   public static Udaf<String, List<Struct>, List<String>> latestString(final int topNSize) {\n     return latestN(STRUCT_STRING, topNSize);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NzU2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469947562", "bodyText": "We'd want to validate topNSize (please add unit test for this too):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n          \n          \n            \n                  final int topNSize) {\n          \n          \n            \n                return new Udaf<T, List<Struct>, List<T>>() {\n          \n          \n            \n              static <T> Udaf<T, List<Struct>, List<T>> earliestN(\n          \n          \n            \n                  final Schema structSchema,\n          \n          \n            \n                  final int earliestN\n          \n          \n            \n                ) {\n          \n          \n            \n                \n          \n          \n            \n                if (earliestN <= 0) {\n          \n          \n            \n                  throw new KsqlFunctionException(\"earliestN must be 1 or greater\");\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                return new Udaf<T, List<Struct>, List<T>>() {", "author": "big-andy-coates", "createdAt": "2020-08-13T13:23:55Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -123,4 +155,54 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+\n+\n+  @UdafFactory(description = \"Earliest N by offset\")\n+  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n+      final int topNSize) {\n+    return new Udaf<T, List<Struct>, List<T>>() {", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0ODkxOQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r470048919", "bodyText": "Good point. Should there be an upper limit too?", "author": "sarwarbhuiyan", "createdAt": "2020-08-13T15:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NzU2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 98210bdc92..17df49cb69 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -155,54 +123,4 @@ public final class EarliestByOffset {\n       }\n     };\n   }\n-\n-\n-  @UdafFactory(description = \"Earliest N by offset\")\n-  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n-      final int topNSize) {\n-    return new Udaf<T, List<Struct>, List<T>>() {\n-      @Override\n-      public List<Struct> initialize() {\n-        return new ArrayList<Struct>();\n-      }\n-\n-      @Override\n-      public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n-        final int currentSize = aggregate.size();\n-        if (currentSize == topNSize) {\n-          return aggregate;\n-        } else {\n-\n-          if (current == null) {\n-            return aggregate;\n-          }\n-\n-          aggregate.add(createStruct(structSchema, current));\n-          return aggregate.subList(0, aggregate.size());\n-        }\n-\n-\n-      }\n-\n-      @Override\n-      public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n-        final List<Struct> merged = new ArrayList<>();\n-        merged.addAll(aggOne);\n-        merged.addAll(aggTwo);\n-        final int currentSize = merged.size();\n-        Collections.sort(merged, structComparator);\n-        if (currentSize <= topNSize) {\n-          return merged;\n-        } else {\n-          return merged.subList(0, topNSize);\n-        }\n-      }\n-\n-      @Override\n-      @SuppressWarnings(\"unchecked\")\n-      public List<T> map(final List<Struct> agg) {\n-        return (List<T>) agg.stream().map(s -> s.get(VAL_FIELD)).collect(Collectors.toList());\n-      }\n-    };\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0ODE2NQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469948165", "bodyText": "Please make corresponding changes to this code, as were suggested for the EarliestByOffset code.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:24:50Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java", "diffHunk": "@@ -124,5 +161,50 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+  \n+  @UdafFactory(description = \"Latest N by offset\")\n+  static <T> Udaf<T, List<Struct>, List<T>> latestN(final Schema structSchema, final int topNSize) {\n+    return new Udaf<T, List<Struct>, List<T>>() {\n+      @Override\n+      public List<Struct> initialize() {\n+        return new ArrayList<Struct>();\n+      }\n+\n+      @Override\n+      public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n+        if (current == null) {\n+          return aggregate;\n+        }\n+\n+        aggregate.add(createStruct(structSchema, current));\n+        final int currentSize = aggregate.size();\n+        if (currentSize <= topNSize) {\n+          return aggregate;\n+        } else {\n+          return aggregate.subList(currentSize - topNSize, currentSize);\n+        }\n+      }\n+\n+      @Override\n+      public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n+        final List<Struct> merged = new ArrayList<>();\n+        merged.addAll(aggOne);\n+        merged.addAll(aggTwo);\n+        final int currentSize = merged.size();\n+        Collections.sort(merged, structComparator);\n+        if (currentSize <= topNSize) {\n+          return merged;\n+        } else {\n+          return merged.subList(currentSize - topNSize, currentSize);\n+        }\n+      }\n+\n+      @Override\n+      @SuppressWarnings(\"unchecked\")\n+      public List<T> map(final List<Struct> agg) {\n+        return (List<T>) agg.stream().map(s -> s.get(VAL_FIELD)).collect(Collectors.toList());\n+      }\n+    };\n+  }", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2f37f9bbbb7c46924b0fdcc8e2f70be3249542c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\nindex 9b843252d7..33ed0d0f22 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\n\n@@ -161,13 +157,20 @@ public final class LatestByOffset {\n       }\n     };\n   }\n-  \n-  @UdafFactory(description = \"Latest N by offset\")\n-  static <T> Udaf<T, List<Struct>, List<T>> latestN(final Schema structSchema, final int topNSize) {\n+\n+  static <T> Udaf<T, List<Struct>, List<T>> latestN(\n+      final Schema structSchema,\n+      final int latestN\n+      ) {\n+    \n+    if (latestN <= 0) {\n+      throw new KsqlFunctionException(\"earliestN must be 1 or greater\");\n+    }\n+    \n     return new Udaf<T, List<Struct>, List<T>>() {\n       @Override\n       public List<Struct> initialize() {\n-        return new ArrayList<Struct>();\n+        return new ArrayList<Struct>(latestN);\n       }\n \n       @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MDQyNA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469950424", "bodyText": "FYI: Just Arrays.asList needed. No need for the new ArrayList<>( bit.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:28:17Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -55,6 +70,29 @@ public void shouldComputeEarliestInteger() {\n \n     // Then:\n     assertThat(res.get(VAL_FIELD), is(321));\n+  }\n+  \n+  @Test\n+  public void shouldComputeEarliest2Integers() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n+\n+    // When:\n+    List<Struct> res = udaf\n+        .aggregate(123, new ArrayList<>(Arrays.asList(EarliestByOffset.createStruct(STRUCT_INTEGER, 321))));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\nindex 5df2307a60..cc6eca719c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n\n@@ -70,29 +55,6 @@ public class EarliestByOffsetUdafTest {\n \n     // Then:\n     assertThat(res.get(VAL_FIELD), is(321));\n-  }\n-  \n-  @Test\n-  public void shouldComputeEarliest2Integers() {\n-    // Given:\n-    final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n-\n-    // When:\n-    List<Struct> res = udaf\n-        .aggregate(123, new ArrayList<>(Arrays.asList(EarliestByOffset.createStruct(STRUCT_INTEGER, 321))));\n-\n-    // Then:\n-    assertThat(res.get(0).get(VAL_FIELD), is(321));\n-    assertThat(res.get(1).get(VAL_FIELD), is(123));\n-    \n-    List<Struct> res2 = udaf\n-        .aggregate(543, res);\n-    assertThat(res2.size(), is(2));\n-    assertThat(res2.get(0).get(VAL_FIELD), is(321));\n-    assertThat(res2.get(1).get(VAL_FIELD), is(123));\n-    \n-    \n-    \n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MjU4NA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469952584", "bodyText": "Probably better structured as two tests:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Test\n          \n          \n            \n              public void shouldComputeEarliest2Integers() {\n          \n          \n            \n                // Given:\n          \n          \n            \n                final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n          \n          \n            \n            \n          \n          \n            \n                // When:\n          \n          \n            \n                List<Struct> res = udaf\n          \n          \n            \n                    .aggregate(123, new ArrayList<>(Arrays.asList(EarliestByOffset.createStruct(STRUCT_INTEGER, 321))));\n          \n          \n            \n            \n          \n          \n            \n                // Then:\n          \n          \n            \n                assertThat(res.get(0).get(VAL_FIELD), is(321));\n          \n          \n            \n                assertThat(res.get(1).get(VAL_FIELD), is(123));\n          \n          \n            \n                \n          \n          \n            \n                List<Struct> res2 = udaf\n          \n          \n            \n                    .aggregate(543, res);\n          \n          \n            \n                assertThat(res2.size(), is(2));\n          \n          \n            \n                assertThat(res2.get(0).get(VAL_FIELD), is(321));\n          \n          \n            \n                assertThat(res2.get(1).get(VAL_FIELD), is(123));\n          \n          \n            \n                \n          \n          \n            \n                \n          \n          \n            \n                \n          \n          \n            \n            @Test\n          \n          \n            \n              public void shouldCaptureValuesUpToN() {\n          \n          \n            \n                // Given:\n          \n          \n            \n                final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n          \n          \n            \n            \n          \n          \n            \n                // When:\n          \n          \n            \n                List<Struct> res0 = udaf.aggregate(321, new ArrayList<>());\n          \n          \n            \n                List<Struct> res1 = udaf.aggregate(123, res0);\n          \n          \n            \n            \n          \n          \n            \n                assertThat(res1, hasSize(2));\n          \n          \n            \n                assertThat(res1.get(0).get(VAL_FIELD), is(321));\n          \n          \n            \n                assertThat(res1.get(1).get(VAL_FIELD), is(123));\n          \n          \n            \n              }\n          \n          \n            \n            \n          \n          \n            \n              @Test\n          \n          \n            \n              public void shouldIgnoreValuesPastN() {\n          \n          \n            \n                // Given:\n          \n          \n            \n                final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n          \n          \n            \n            \n          \n          \n            \n                final List<Struct> aggregate = Arrays.asList(\n          \n          \n            \n                    EarliestByOffset.createStruct(STRUCT_INTEGER, 10),\n          \n          \n            \n                    EarliestByOffset.createStruct(STRUCT_INTEGER, 3)\n          \n          \n            \n                );\n          \n          \n            \n            \n          \n          \n            \n                // When:\n          \n          \n            \n                final List<Struct> result = udaf.aggregate(2, aggregate);\n          \n          \n            \n            \n          \n          \n            \n                assertThat(result, hasSize(2));\n          \n          \n            \n                assertThat(result.get(0).get(VAL_FIELD), is(10));\n          \n          \n            \n                assertThat(result.get(1).get(VAL_FIELD), is(3));\n          \n          \n            \n              }```", "author": "big-andy-coates", "createdAt": "2020-08-13T13:31:14Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -55,6 +70,29 @@ public void shouldComputeEarliestInteger() {\n \n     // Then:\n     assertThat(res.get(VAL_FIELD), is(321));\n+  }\n+  \n+  @Test\n+  public void shouldComputeEarliest2Integers() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n+\n+    // When:\n+    List<Struct> res = udaf\n+        .aggregate(123, new ArrayList<>(Arrays.asList(EarliestByOffset.createStruct(STRUCT_INTEGER, 321))));\n+\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(321));\n+    assertThat(res.get(1).get(VAL_FIELD), is(123));\n+    \n+    List<Struct> res2 = udaf\n+        .aggregate(543, res);\n+    assertThat(res2.size(), is(2));\n+    assertThat(res2.get(0).get(VAL_FIELD), is(321));\n+    assertThat(res2.get(1).get(VAL_FIELD), is(123));\n+    \n+    \n+    ", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\nindex 5df2307a60..cc6eca719c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n\n@@ -70,29 +55,6 @@ public class EarliestByOffsetUdafTest {\n \n     // Then:\n     assertThat(res.get(VAL_FIELD), is(321));\n-  }\n-  \n-  @Test\n-  public void shouldComputeEarliest2Integers() {\n-    // Given:\n-    final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n-\n-    // When:\n-    List<Struct> res = udaf\n-        .aggregate(123, new ArrayList<>(Arrays.asList(EarliestByOffset.createStruct(STRUCT_INTEGER, 321))));\n-\n-    // Then:\n-    assertThat(res.get(0).get(VAL_FIELD), is(321));\n-    assertThat(res.get(1).get(VAL_FIELD), is(123));\n-    \n-    List<Struct> res2 = udaf\n-        .aggregate(543, res);\n-    assertThat(res2.size(), is(2));\n-    assertThat(res2.get(0).get(VAL_FIELD), is(321));\n-    assertThat(res2.get(1).get(VAL_FIELD), is(123));\n-    \n-    \n-    \n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2MDAyNg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469960026", "bodyText": "A better test would be if the structs in each parameter had interleaved sequence numbers, as this ensures the sort is happening:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Test\n          \n          \n            \n              public void shouldMerge2Integers() {\n          \n          \n            \n                // Given:\n          \n          \n            \n                final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n          \n          \n            \n            \n          \n          \n            \n                Struct struct1 = EarliestByOffset.createStruct(STRUCT_INTEGER, 123);\n          \n          \n            \n                Struct struct2 = EarliestByOffset.createStruct(STRUCT_INTEGER, 321);\n          \n          \n            \n                List<Struct> agg1 = new ArrayList<>(Arrays.asList(struct1, struct2));\n          \n          \n            \n                \n          \n          \n            \n                Struct struct3 = EarliestByOffset.createStruct(STRUCT_INTEGER, 543);\n          \n          \n            \n                Struct struct4 = EarliestByOffset.createStruct(STRUCT_INTEGER, 654);\n          \n          \n            \n                List<Struct> agg2 = new ArrayList<>(Arrays.asList(struct3, struct4));\n          \n          \n            \n                \n          \n          \n            \n                // When:\n          \n          \n            \n                List<Struct> merged1 = udaf.merge(agg1, agg2);\n          \n          \n            \n                List<Struct> merged2 = udaf.merge(agg2, agg1);\n          \n          \n            \n            \n          \n          \n            \n                // Then:\n          \n          \n            \n                assertThat(merged1, is(agg1));\n          \n          \n            \n                assertThat(merged2, is(agg1));\n          \n          \n            \n              }\n          \n          \n            \n              @Test\n          \n          \n            \n              public void shouldMergeIntegers() {\n          \n          \n            \n                // Given:\n          \n          \n            \n                final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n          \n          \n            \n            \n          \n          \n            \n                final Struct struct1 = EarliestByOffset.createStruct(STRUCT_INTEGER, 123);\n          \n          \n            \n                final Struct struct2 = EarliestByOffset.createStruct(STRUCT_INTEGER, 321);\n          \n          \n            \n                final Struct struct3 = EarliestByOffset.createStruct(STRUCT_INTEGER, 543);\n          \n          \n            \n                final Struct struct4 = EarliestByOffset.createStruct(STRUCT_INTEGER, 654);\n          \n          \n            \n                final List<Struct> agg1 = new ArrayList<>(Arrays.asList(struct1, struct4));\n          \n          \n            \n                final List<Struct> agg2 = new ArrayList<>(Arrays.asList(struct2, struct3));\n          \n          \n            \n                \n          \n          \n            \n                // When:\n          \n          \n            \n                final List<Struct> merged1 = udaf.merge(agg1, agg2);\n          \n          \n            \n                final List<Struct> merged2 = udaf.merge(agg2, agg1);\n          \n          \n            \n            \n          \n          \n            \n                // Then:\n          \n          \n            \n                assertThat(merged1, contains(struct1, struct2));\n          \n          \n            \n                assertThat(merged2, contains(struct1, struct2));\n          \n          \n            \n              }", "author": "big-andy-coates", "createdAt": "2020-08-13T13:42:01Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -73,6 +111,28 @@ public void shouldMerge() {\n     assertThat(merged1, is(agg1));\n     assertThat(merged2, is(agg1));\n   }\n+  \n+  @Test\n+  public void shouldMerge2Integers() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n+\n+    Struct struct1 = EarliestByOffset.createStruct(STRUCT_INTEGER, 123);\n+    Struct struct2 = EarliestByOffset.createStruct(STRUCT_INTEGER, 321);\n+    List<Struct> agg1 = new ArrayList<>(Arrays.asList(struct1, struct2));\n+    \n+    Struct struct3 = EarliestByOffset.createStruct(STRUCT_INTEGER, 543);\n+    Struct struct4 = EarliestByOffset.createStruct(STRUCT_INTEGER, 654);\n+    List<Struct> agg2 = new ArrayList<>(Arrays.asList(struct3, struct4));\n+    \n+    // When:\n+    List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(merged1, is(agg1));\n+    assertThat(merged2, is(agg1));\n+  }", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\nindex 5df2307a60..cc6eca719c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n\n@@ -111,28 +73,6 @@ public class EarliestByOffsetUdafTest {\n     assertThat(merged1, is(agg1));\n     assertThat(merged2, is(agg1));\n   }\n-  \n-  @Test\n-  public void shouldMerge2Integers() {\n-    // Given:\n-    final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n-\n-    Struct struct1 = EarliestByOffset.createStruct(STRUCT_INTEGER, 123);\n-    Struct struct2 = EarliestByOffset.createStruct(STRUCT_INTEGER, 321);\n-    List<Struct> agg1 = new ArrayList<>(Arrays.asList(struct1, struct2));\n-    \n-    Struct struct3 = EarliestByOffset.createStruct(STRUCT_INTEGER, 543);\n-    Struct struct4 = EarliestByOffset.createStruct(STRUCT_INTEGER, 654);\n-    List<Struct> agg2 = new ArrayList<>(Arrays.asList(struct3, struct4));\n-    \n-    // When:\n-    List<Struct> merged1 = udaf.merge(agg1, agg2);\n-    List<Struct> merged2 = udaf.merge(agg2, agg1);\n-\n-    // Then:\n-    assertThat(merged1, is(agg1));\n-    assertThat(merged2, is(agg1));\n-  }\n \n   @Test\n   public void shouldMergeWithOverflow() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2MDkwOA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469960908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldComputeEarliest2Longs() {\n          \n          \n            \n              public void shouldComputeEarliestLongs() {\n          \n      \n    \n    \n  \n\nSame for other new methods.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:43:15Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -108,6 +194,26 @@ public void shouldComputeEarliestLong() {\n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(321L));\n   }\n+  \n+  @Test\n+  public void shouldComputeEarliest2Longs() {", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\nindex 5df2307a60..cc6eca719c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n\n@@ -194,26 +108,6 @@ public class EarliestByOffsetUdafTest {\n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(321L));\n   }\n-  \n-  @Test\n-  public void shouldComputeEarliest2Longs() {\n-    // Given:\n-    final Udaf<Long, List<Struct>, List<Long>> udaf = EarliestByOffset.earliestLong(2);\n-\n-    // When:\n-    List<Struct> res = udaf\n-        .aggregate(123L, new ArrayList<>(Arrays.asList(EarliestByOffset.createStruct(STRUCT_LONG, 321L))));\n-\n-    // Then:\n-    assertThat(res.get(0).get(VAL_FIELD), is(321L));\n-    assertThat(res.get(1).get(VAL_FIELD), is(123L));\n-    \n-    List<Struct> res2 = udaf\n-        .aggregate(543L, res);\n-    assertThat(res2.size(), is(2));\n-    assertThat(res2.get(0).get(VAL_FIELD), is(321L));\n-    assertThat(res2.get(1).get(VAL_FIELD), is(123L));\n-  }\n \n   @Test\n   public void shouldComputeEarliestDouble() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2MTUzOA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469961538", "bodyText": "Consider changing the value of earlestN, so not all tests use 2.  Alternate between 1, 2 & 3, maybe?", "author": "big-andy-coates", "createdAt": "2020-08-13T13:44:09Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -108,6 +194,26 @@ public void shouldComputeEarliestLong() {\n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(321L));\n   }\n+  \n+  @Test\n+  public void shouldComputeEarliest2Longs() {\n+    // Given:\n+    final Udaf<Long, List<Struct>, List<Long>> udaf = EarliestByOffset.earliestLong(2);", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\nindex 5df2307a60..cc6eca719c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n\n@@ -194,26 +108,6 @@ public class EarliestByOffsetUdafTest {\n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(321L));\n   }\n-  \n-  @Test\n-  public void shouldComputeEarliest2Longs() {\n-    // Given:\n-    final Udaf<Long, List<Struct>, List<Long>> udaf = EarliestByOffset.earliestLong(2);\n-\n-    // When:\n-    List<Struct> res = udaf\n-        .aggregate(123L, new ArrayList<>(Arrays.asList(EarliestByOffset.createStruct(STRUCT_LONG, 321L))));\n-\n-    // Then:\n-    assertThat(res.get(0).get(VAL_FIELD), is(321L));\n-    assertThat(res.get(1).get(VAL_FIELD), is(123L));\n-    \n-    List<Struct> res2 = udaf\n-        .aggregate(543L, res);\n-    assertThat(res2.size(), is(2));\n-    assertThat(res2.get(0).get(VAL_FIELD), is(321L));\n-    assertThat(res2.get(1).get(VAL_FIELD), is(123L));\n-  }\n \n   @Test\n   public void shouldComputeEarliestDouble() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2MjI1MQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469962251", "bodyText": "Apply same changes to this file as were made to the EarliestByOffsetTest file.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:45:08Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -45,19 +45,48 @@ public void shouldInitialize() {\n     assertThat(init, is(notNullValue()));\n   }\n \n+  @Test", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\nindex d48b66915c..3a46a51d3e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n\n@@ -45,48 +45,19 @@ public class LatestByOffsetUdafTest {\n     assertThat(init, is(notNullValue()));\n   }\n \n-  @Test\n-  public void shouldInitializeLatest2Integers() {\n-    // Given:\n-    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestN(STRUCT_LONG, 2);\n-\n-    // When:\n-    List<Struct> init = udaf.initialize();\n-\n-    // Then:\n-    assertThat(init, is(notNullValue()));\n-  }\n-\n   @Test\n   public void shouldComputeLatestInteger() {\n     // Given:\n     final Udaf<Integer, Struct, Integer> udaf = LatestByOffset.latestInteger();\n \n     // When:\n-    Struct res = udaf.aggregate(123, LatestByOffset.createStruct(STRUCT_INTEGER, 321));\n+    Struct res = udaf\n+        .aggregate(123, LatestByOffset.createStruct(STRUCT_INTEGER, 321));\n \n     // Then:\n     assertThat(res.get(VAL_FIELD), is(123));\n   }\n \n-  @Test\n-  public void shouldComputeLatest2Integers() {\n-    // Given:\n-    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(2);\n-\n-    List<Struct> list = new ArrayList<>();\n-    list.add(LatestByOffset.createStruct(STRUCT_INTEGER, 321));\n-\n-    // When:\n-    List<Struct> res = udaf.aggregate(123, list);\n-\n-    assertThat(list.size(), is(2));\n-    // Then:\n-    assertThat(res.get(0).get(VAL_FIELD), is(321));\n-    assertThat(res.get(1).get(VAL_FIELD), is(123));\n-\n-  }\n-\n   @Test\n   public void shouldMerge() {\n     // Given:\n"}}, {"oid": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "url": "https://github.com/confluentinc/ksql/commit/6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "message": "Merged code for Latest N", "committedDate": "2020-09-04T16:09:02Z", "type": "commit"}, {"oid": "2bbaf7afb2fc85b5801a5c544f8d9943dc7bc241", "url": "https://github.com/confluentinc/ksql/commit/2bbaf7afb2fc85b5801a5c544f8d9943dc7bc241", "message": "Added explicit paramSchema in @UdafFactory annotation for latestbyoffset udaf", "committedDate": "2020-09-04T16:09:02Z", "type": "commit"}, {"oid": "ed7eb40071f83e22cce5b397bf2d9ce66bcab45d", "url": "https://github.com/confluentinc/ksql/commit/ed7eb40071f83e22cce5b397bf2d9ce66bcab45d", "message": "Removed paramSchema as that had no effect on UDFIndex", "committedDate": "2020-09-04T16:09:02Z", "type": "commit"}, {"oid": "061a26025491be147f2e0df077943c5478ea18ca", "url": "https://github.com/confluentinc/ksql/commit/061a26025491be147f2e0df077943c5478ea18ca", "message": "Updated unit tests and functional tests for LatestByOffset and EarliestByOffset", "committedDate": "2020-09-04T16:09:02Z", "type": "commit"}, {"oid": "c2f37f9bbbb7c46924b0fdcc8e2f70be3249542c", "url": "https://github.com/confluentinc/ksql/commit/c2f37f9bbbb7c46924b0fdcc8e2f70be3249542c", "message": "Fixed tests according to PR review comments", "committedDate": "2020-09-04T18:30:12Z", "type": "commit"}, {"oid": "c2f37f9bbbb7c46924b0fdcc8e2f70be3249542c", "url": "https://github.com/confluentinc/ksql/commit/c2f37f9bbbb7c46924b0fdcc8e2f70be3249542c", "message": "Fixed tests according to PR review comments", "committedDate": "2020-09-04T18:30:12Z", "type": "forcePushed"}, {"oid": "dead8472fa492043ff4652efca08dfa36929e9ea", "url": "https://github.com/confluentinc/ksql/commit/dead8472fa492043ff4652efca08dfa36929e9ea", "message": "Fixed checkstyle errors", "committedDate": "2020-09-07T09:21:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4NjQ2OQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484486469", "bodyText": "Fix spot bugs issue:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset\n          \n          \n            \n                  EarliestByOffset", "author": "big-andy-coates", "createdAt": "2020-09-07T15:12:17Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -23,39 +23,110 @@\n import static io.confluent.ksql.function.udaf.KudafByOffsetUtils.STRUCT_STRING;\n import static io.confluent.ksql.function.udaf.KudafByOffsetUtils.VAL_FIELD;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.notNullValue;\n \n+import com.google.common.collect.Lists;\n import io.confluent.ksql.function.udaf.Udaf;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.ArrayList;\n+import java.util.List;\n import org.apache.kafka.connect.data.Struct;\n import org.junit.Test;\n \n+\n public class EarliestByOffsetUdafTest {\n+  \n   @Test\n   public void shouldInitialize() {\n     // Given:\n-    final Udaf<Integer, Struct, Integer> udaf = EarliestByOffset\n-        .earliest(STRUCT_LONG);\n+    final Udaf<Integer, Struct, Integer> udaf = EarliestByOffset.earliest(STRUCT_LONG);\n \n     // When:\n     Struct init = udaf.initialize();\n \n     // Then:\n     assertThat(init, is(notNullValue()));\n   }\n+  \n+  @Test\n+  public void shouldInitializeN() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestN(STRUCT_LONG, 2);\n+\n+    // When:\n+    List<Struct> init = udaf.initialize();\n+\n+    // Then:\n+    assertThat(init, is(notNullValue()));\n+  }\n+  \n+  @Test\n+  public void shouldThrowExceptionForInvalidN() {\n+    try {\n+      final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c32270252cb1efd1661528c91fc0028a53cd749", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\nindex 374881d87b..fccebb9684 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java\n\n@@ -66,7 +66,7 @@ public class EarliestByOffsetUdafTest {\n   @Test\n   public void shouldThrowExceptionForInvalidN() {\n     try {\n-      final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset\n+      EarliestByOffset\n           // Given:\n           .earliestN(STRUCT_LONG, -1);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4Njg0NA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484486844", "bodyText": "Fix spot bugs issue:\nEither asset the contents of res and res2 or remove them as variables.", "author": "big-andy-coates", "createdAt": "2020-09-07T15:13:06Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -96,57 +209,146 @@ public void shouldMergeWithOverflow() {\n     assertThat(merged2, is(agg2));\n   }\n \n+  @Test\n+  public void shouldMergeWithOverflowNIntegers() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestIntegers(2);\n+\n+    LatestByOffset.sequence.set(Long.MAX_VALUE - 1);\n+\n+    Struct struct1 = LatestByOffset.createStruct(STRUCT_INTEGER, 123);\n+    Struct struct2 = LatestByOffset.createStruct(STRUCT_INTEGER, 321);\n+    Struct struct3 = LatestByOffset.createStruct(STRUCT_INTEGER, 543);\n+    Struct struct4 = LatestByOffset.createStruct(STRUCT_INTEGER, 654);\n+    \n+    List<Struct> agg1 = Lists.newArrayList(struct1, struct2);\n+    List<Struct> agg2 = Lists.newArrayList(struct3, struct4);\n+\n+    // When:\n+    final List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    final List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE - 1));\n+    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n+    assertThat(merged1, contains(struct3, struct4));\n+    assertThat(merged2, contains(struct3, struct4));\n+  }\n \n   @Test\n   public void shouldComputeLatestLong() {\n     // Given:\n     final Udaf<Long, Struct, Long> udaf = LatestByOffset.latestLong();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+    Struct res = udaf.aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n \n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(123L));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatestNLongs() {\n+    // Given:\n+    final Udaf<Long, List<Struct>, List<Long>> udaf = LatestByOffset.latestLong(3);\n+\n+    // When:\n+    List<Struct> res = udaf\n+        .aggregate(123L, Lists.newArrayList(LatestByOffset.createStruct(STRUCT_LONG, 321L)));\n+    \n+    List<Struct> res2 = udaf\n+        .aggregate(543L, res);\n+    \n+    List<Struct> res3 = udaf\n+        .aggregate(654L, res);", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c32270252cb1efd1661528c91fc0028a53cd749", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\nindex 138e33538b..5293af778c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n\n@@ -260,7 +260,7 @@ public class LatestByOffsetUdafTest {\n         .aggregate(543L, res);\n     \n     List<Struct> res3 = udaf\n-        .aggregate(654L, res);\n+        .aggregate(654L, res2);\n     \n     // Then:\n     assertThat(res3.size(), is(3));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4NzAxNA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484487014", "bodyText": "Fix spot bugs error:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset\n          \n          \n            \n                  LatestByOffset", "author": "big-andy-coates", "createdAt": "2020-09-07T15:13:29Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -45,19 +51,83 @@ public void shouldInitialize() {\n     assertThat(init, is(notNullValue()));\n   }\n \n+  @Test\n+  public void shouldInitializeLatestN() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestN(STRUCT_LONG, 2);\n+\n+    // When:\n+    List<Struct> init = udaf.initialize();\n+\n+    // Then:\n+    assertThat(init, is(notNullValue()));\n+  }\n+  \n+  @Test\n+  public void shouldThrowExceptionForInvalidN() {\n+    try {\n+      final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c32270252cb1efd1661528c91fc0028a53cd749", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\nindex 138e33538b..5293af778c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java\n\n@@ -66,7 +66,7 @@ public class LatestByOffsetUdafTest {\n   @Test\n   public void shouldThrowExceptionForInvalidN() {\n     try {\n-      final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset\n+      LatestByOffset\n           // Given:\n           .latestN(STRUCT_LONG, -1);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4OTQ4NQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484489485", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  \"This function returns the oldest N value for the column, computed by offset.\";\n          \n          \n            \n                  \"This function returns the oldest N values for the column, computed by offset.\";", "author": "big-andy-coates", "createdAt": "2020-09-07T15:19:10Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -38,8 +42,9 @@\n     author = KsqlConstants.CONFLUENT_AUTHOR\n )\n public final class EarliestByOffset {\n+\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3d7c7d1a2bb5cf28e859f713d00a61d0fb0289ee", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 9f3d0fd3bd..4f5a86bd90 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -44,7 +44,7 @@ import org.apache.kafka.connect.data.Struct;\n public final class EarliestByOffset {\n \n   static final String DESCRIPTION =\n-      \"This function returns the oldest N value for the column, computed by offset.\";\n+      \"This function returns the oldest N values for the column, computed by offset.\";\n \n   private EarliestByOffset() {\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4OTY2OA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484489668", "bodyText": "please don't update existing copyright dates", "author": "big-andy-coates", "createdAt": "2020-09-07T15:19:34Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2019 Confluent Inc.\n+ * Copyright 2020 Confluent Inc.", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3d7c7d1a2bb5cf28e859f713d00a61d0fb0289ee", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\nindex 55c859f4f7..c10594af5d 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020 Confluent Inc.\n+ * Copyright 2019 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"; you may not use\n  * this file except in compliance with the License. You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5MDMxNw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484490317", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static Udaf<Boolean, Struct, Boolean> earliestBooleans() {\n          \n          \n            \n              public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {", "author": "big-andy-coates", "createdAt": "2020-09-07T15:21:02Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -52,30 +57,60 @@ private EarliestByOffset() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n+  @UdafFactory(description = \"return the earliest N values of an integer column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n+  public static Udaf<Integer, List<Struct>, List<Integer>> earliestIntegers(final int earliestN) {\n+    return earliestN(STRUCT_INTEGER, earliestN);\n+  }\n+\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest N values of an long column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n+  public static Udaf<Long, List<Struct>, List<Long>> earliestLongs(final int earliestN) {\n+    return earliestN(STRUCT_LONG, earliestN);\n+  }\n \n   @UdafFactory(description = \"return the earliest value of a double column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> earliestDouble() {\n     return earliest(STRUCT_DOUBLE);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest N values of a double column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n+  public static Udaf<Double, List<Struct>, List<Double>> earliestDoubles(final int earliestN) {\n+    return earliestN(STRUCT_DOUBLE, earliestN);\n+  }\n \n   @UdafFactory(description = \"return the earliest value of a boolean column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n-  public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {\n+  public static Udaf<Boolean, Struct, Boolean> earliestBooleans() {", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3d7c7d1a2bb5cf28e859f713d00a61d0fb0289ee", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\nindex 9f3d0fd3bd..4f5a86bd90 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java\n\n@@ -89,7 +89,7 @@ public final class EarliestByOffset {\n \n   @UdafFactory(description = \"return the earliest value of a boolean column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n-  public static Udaf<Boolean, Struct, Boolean> earliestBooleans() {\n+  public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {\n     return earliest(STRUCT_BOOLEAN);\n   }\n   \n"}}, {"oid": "1c32270252cb1efd1661528c91fc0028a53cd749", "url": "https://github.com/confluentinc/ksql/commit/1c32270252cb1efd1661528c91fc0028a53cd749", "message": "Updated fixed for spotbugs and updated reference", "committedDate": "2020-09-07T16:09:30Z", "type": "commit"}, {"oid": "5dd4ed72b1a53932821884b4fd40898c41af53a7", "url": "https://github.com/confluentinc/ksql/commit/5dd4ed72b1a53932821884b4fd40898c41af53a7", "message": "fixed ksqldb-functional-tests", "committedDate": "2020-09-07T19:55:47Z", "type": "commit"}, {"oid": "db667b683e99e3eda8e2e7333113f3fb4e3f7af5", "url": "https://github.com/confluentinc/ksql/commit/db667b683e99e3eda8e2e7333113f3fb4e3f7af5", "message": "Removed ksqbdb-function-tests doc folder", "committedDate": "2020-09-08T08:51:44Z", "type": "commit"}, {"oid": "3d7c7d1a2bb5cf28e859f713d00a61d0fb0289ee", "url": "https://github.com/confluentinc/ksql/commit/3d7c7d1a2bb5cf28e859f713d00a61d0fb0289ee", "message": "Fixed some pluralization and reverted copyright year to 2019", "committedDate": "2020-09-08T09:00:57Z", "type": "commit"}, {"oid": "9627c2afd8d37d2b459889234619c33b6b5c61fa", "url": "https://github.com/confluentinc/ksql/commit/9627c2afd8d37d2b459889234619c33b6b5c61fa", "message": "Fixed compilation error due to refactoring plural", "committedDate": "2020-09-08T10:00:06Z", "type": "commit"}]}