{"pr_number": 6803, "pr_title": "feat: support PARTITION BY on multiple expressions", "pr_createdAt": "2020-12-18T07:27:15Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6803", "timeline": [{"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "url": "https://github.com/confluentinc/ksql/commit/09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "message": "chore: syntax changes", "committedDate": "2020-12-18T01:01:53Z", "type": "commit"}, {"oid": "27844a82ef43ea083000058e16c62ac7be3cd846", "url": "https://github.com/confluentinc/ksql/commit/27844a82ef43ea083000058e16c62ac7be3cd846", "message": "chore: null handling", "committedDate": "2020-12-18T03:36:58Z", "type": "commit"}, {"oid": "7af9b8e6d3f9450695124b7c61b68a2aae1c7adb", "url": "https://github.com/confluentinc/ksql/commit/7af9b8e6d3f9450695124b7c61b68a2aae1c7adb", "message": "chore: cleanup", "committedDate": "2020-12-18T07:22:37Z", "type": "commit"}, {"oid": "aa4ce584257966cbce8b57f4cfe373f8f2d30a06", "url": "https://github.com/confluentinc/ksql/commit/aa4ce584257966cbce8b57f4cfe373f8f2d30a06", "message": "chore: historic plans", "committedDate": "2020-12-18T07:26:48Z", "type": "commit"}, {"oid": "52533b65c56d1a8aad15e0cf83ad26dd14616251", "url": "https://github.com/confluentinc/ksql/commit/52533b65c56d1a8aad15e0cf83ad26dd14616251", "message": "test: fix test", "committedDate": "2020-12-18T08:20:08Z", "type": "commit"}, {"oid": "73bc73ed761e4391bcd4a8452ed49e2e0f8a06c0", "url": "https://github.com/confluentinc/ksql/commit/73bc73ed761e4391bcd4a8452ed49e2e0f8a06c0", "message": "chore: switch List to ImmutableList", "committedDate": "2020-12-18T14:24:27Z", "type": "commit"}, {"oid": "b8030febe31fd17efd1d9b20e18ac3d604e27704", "url": "https://github.com/confluentinc/ksql/commit/b8030febe31fd17efd1d9b20e18ac3d604e27704", "message": "test: fix tests", "committedDate": "2020-12-18T15:30:08Z", "type": "commit"}, {"oid": "bf93e158f221f42371c77ded6f0b07ba53d2de54", "url": "https://github.com/confluentinc/ksql/commit/bf93e158f221f42371c77ded6f0b07ba53d2de54", "message": "chore: fix required fields", "committedDate": "2020-12-18T17:02:10Z", "type": "commit"}, {"oid": "6d4302daba861a0f1ef8283c011272338a423cf7", "url": "https://github.com/confluentinc/ksql/commit/6d4302daba861a0f1ef8283c011272338a423cf7", "message": "test: remove obsolete test", "committedDate": "2020-12-18T18:36:05Z", "type": "commit"}, {"oid": "043f12d5094715b64875a987e637bbff3ec52976", "url": "https://github.com/confluentinc/ksql/commit/043f12d5094715b64875a987e637bbff3ec52976", "message": "Merge branch 'master' into partition-by-multi", "committedDate": "2020-12-18T18:36:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNDgwOA==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546004808", "bodyText": "i think this is OK", "author": "agavra", "createdAt": "2020-12-18T18:15:12Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -663,7 +665,7 @@ private LogicalSchema buildAggregateSchema(\n \n   private LogicalSchema buildRepartitionedSchema(\n       final PlanNode sourceNode,\n-      final Expression partitionBy\n+      final List<Expression> partitionBy // TODO: rename?", "originalCommit": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0NTAzOA==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546045038", "bodyText": "Already renamed. Sorry for not squashing my pre-cleanup commits as I usually do. Not worth your time looking at my intermediate thought process while drafting, haha.", "author": "vcrfxia", "createdAt": "2020-12-18T19:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNDgwOA=="}], "type": "inlineReview", "revised_code": {"commit": "6d4302daba861a0f1ef8283c011272338a423cf7", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java\nindex a017610aef..44adf48098 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java\n\n@@ -665,13 +665,13 @@ public class LogicalPlanner {\n \n   private LogicalSchema buildRepartitionedSchema(\n       final PlanNode sourceNode,\n-      final List<Expression> partitionBy // TODO: rename?\n+      final List<Expression> partitionBys\n   ) {\n     final LogicalSchema sourceSchema = sourceNode.getSchema();\n \n     return PartitionByParamsFactory.buildSchema(\n         sourceSchema,\n-        partitionBy,\n+        partitionBys,\n         metaStore\n     );\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzE3Mg==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546007172", "bodyText": "nit: since we already import ImmutableList let's just use ImmutableList.of here", "author": "agavra", "createdAt": "2020-12-18T18:18:16Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -405,7 +407,7 @@ private PreJoinRepartitionNode buildInternalRepartitionNode(\n         ExpressionTreeRewriter.rewriteWith(plugin, joinExpression);\n \n     final LogicalSchema schema =\n-        buildRepartitionedSchema(source, rewrittenPartitionBy);\n+        buildRepartitionedSchema(source, Collections.singletonList(rewrittenPartitionBy));", "originalCommit": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0MTk4Mg==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546041982", "bodyText": "You mean we import ImmutableList in this file or in the module? I don't see it in the file but I can add it.", "author": "vcrfxia", "createdAt": "2020-12-18T19:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MjI1MQ==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546072251", "bodyText": "oh huh, I must've been looking at a separate file. - in PreJoinRepartitionNode for example it was already there before this PR. It's nice to just standardize on one (and most of hte code uses ImmutableList#of, though there isn't really any good reason to use that over Collections.singletonList except for mabye that ImmutableList has more general usages)", "author": "agavra", "createdAt": "2020-12-18T20:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzE3Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzQ4NQ==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546007485", "bodyText": "nit: same thing about ImmutableList", "author": "agavra", "createdAt": "2020-12-18T18:18:38Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -111,7 +112,7 @@ public void setKeyFormat(final KeyFormat format) {\n     return getSource().buildStream(builder)\n         .selectKey(\n             valueFormat.getFormatInfo(),\n-            partitionBy,\n+            Collections.singletonList(partitionBy),", "originalCommit": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0MjM0MA==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546042340", "bodyText": "Sure. For my edification, why is ImmutableList preferred?", "author": "vcrfxia", "createdAt": "2020-12-18T19:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "5e816621741c697242b7602624e7cd1d5692103f", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java\nindex 9b007b3835..ad81df5f89 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java\n\n@@ -112,7 +111,7 @@ public class PreJoinRepartitionNode extends SingleSourcePlanNode implements Join\n     return getSource().buildStream(builder)\n         .selectKey(\n             valueFormat.getFormatInfo(),\n-            Collections.singletonList(partitionBy),\n+            ImmutableList.of(partitionBy),\n             forcedInternalKeyFormat,\n             builder.buildNodeContext(getId().toString()),\n             forceRepartition\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODc0MA==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546008740", "bodyText": "do we still need to make a copy of the original partition by now that it's a list?", "author": "agavra", "createdAt": "2020-12-18T18:20:57Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/UserRepartitionNode.java", "diffHunk": "@@ -103,9 +107,19 @@ public Expression resolveSelect(final int idx, final Expression expression) {\n \n   @Override\n   void validateKeyPresent(final SourceName sinkName, final Projection projection) {\n-    if (!(partitionBy instanceof NullLiteral) && !projection.containsExpression(partitionBy)) {\n-      final ImmutableList<Expression> keys = ImmutableList.of(originalPartitionBy);\n+    if (!PartitionByParamsFactory.isPartitionByNull(partitionBy)\n+        && !containsExpressions(projection, partitionBy)) {\n+      final ImmutableList<Expression> keys = ImmutableList.copyOf(originalPartitionBy);", "originalCommit": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0NDEyNA==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546044124", "bodyText": "Nope, removed.", "author": "vcrfxia", "createdAt": "2020-12-18T19:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODc0MA=="}], "type": "inlineReview", "revised_code": {"commit": "6d4302daba861a0f1ef8283c011272338a423cf7", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/UserRepartitionNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/UserRepartitionNode.java\nindex fd14be1aa9..8a604dd499 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/UserRepartitionNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/UserRepartitionNode.java\n\n@@ -107,15 +105,13 @@ public class UserRepartitionNode extends SingleSourcePlanNode {\n \n   @Override\n   void validateKeyPresent(final SourceName sinkName, final Projection projection) {\n-    if (!PartitionByParamsFactory.isPartitionByNull(partitionBy)\n-        && !containsExpressions(projection, partitionBy)) {\n-      final ImmutableList<Expression> keys = ImmutableList.copyOf(originalPartitionBy);\n-      // TODO: fix error message to only mention the ones that are missing\n+    if (!PartitionByParamsFactory.isPartitionByNull(partitionBys)\n+        && !containsExpressions(projection, partitionBys)) {\n+      final ImmutableList<Expression> keys = ImmutableList.copyOf(originalPartitionBys);\n       throwKeysNotIncludedError(sinkName, \"partitioning expression\", keys);\n     }\n   }\n \n-  // TODO: clean this up\n   private static boolean containsExpressions(\n       final Projection projection,\n       final List<Expression> expressions\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODk3MQ==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546008971", "bodyText": "ditto: no need for the copy", "author": "agavra", "createdAt": "2020-12-18T18:21:27Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -314,15 +314,15 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n    */\n   public SchemaKStream<K> selectKey(\n       final FormatInfo valueFormat,\n-      final Expression keyExpression,\n+      final List<Expression> keyExpression,\n       final Optional<KeyFormat> forceInternalKeyFormat,\n       final Stacker contextStacker,\n       final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat);\n \n-    final boolean repartitionNeeded = repartitionNeeded(ImmutableList.of(keyExpression));\n+    final boolean repartitionNeeded = repartitionNeeded(ImmutableList.copyOf(keyExpression));", "originalCommit": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5e816621741c697242b7602624e7cd1d5692103f", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java b/ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java\nindex a60e09b3d5..7d34401789 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java\n\n@@ -322,7 +321,7 @@ public class SchemaKStream<K> {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat);\n \n-    final boolean repartitionNeeded = repartitionNeeded(ImmutableList.copyOf(keyExpression));\n+    final boolean repartitionNeeded = repartitionNeeded(keyExpression);\n     if (!keyFormatChange && !forceRepartition && !repartitionNeeded) {\n       return this;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDY3Nw==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546014677", "bodyText": "what's wrong with a duplicate partition by expression? I don't see any reason why a user might want it, but I don't see why not either (e.g. maybe their output data expects userId, userSpecialId in the key and this stream always has the same value for both)\nI get that the key name conflicts might be a little weird, so we can do this in a follow-up PR, but I don't think we should prohibit it", "author": "agavra", "createdAt": "2020-12-18T18:32:22Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java", "diffHunk": "@@ -17,27 +17,43 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.errorprone.annotations.Immutable;\n import io.confluent.ksql.execution.expression.tree.Expression;\n import io.confluent.ksql.parser.NodeLocation;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.Objects;\n import java.util.Optional;\n \n @Immutable\n public class PartitionBy extends AstNode {\n \n-  private final Expression expression;\n+  private final List<Expression> partitionByExpressions;\n \n   public PartitionBy(\n       final Optional<NodeLocation> location,\n-      final Expression partitionBy\n+      final List<Expression> partitionByExpressions\n   ) {\n     super(location);\n-    this.expression = requireNonNull(partitionBy, \"partitionBy\");\n+    this.partitionByExpressions = ImmutableList\n+        .copyOf(requireNonNull(partitionByExpressions, \"partitionByExpressions\"));\n+\n+    if (partitionByExpressions.isEmpty()) {\n+      throw new KsqlException(\"PARTITION BY requires at least one expression\");\n+    }\n+\n+    final HashSet<Object> partitionBys = new HashSet<>(partitionByExpressions.size());\n+    partitionByExpressions.forEach(exp -> {\n+      if (!partitionBys.add(exp)) {\n+        throw new KsqlException(\"Duplicate PARTITION BY expression: \" + exp);", "originalCommit": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0Mzg2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546043863", "bodyText": "This is consistent with what we do for multi-column GROUP BY (which has been around for a long time): \n  \n    \n      ksql/ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/GroupBy.java\n    \n    \n        Lines 49 to 53\n      in\n      e7f1f47\n    \n    \n    \n    \n\n        \n          \n           groupingExpressions.forEach(exp -> { \n        \n\n        \n          \n             if (!groupBys.add(exp)) { \n        \n\n        \n          \n               throw new KsqlException(\"Duplicate GROUP BY expression: \" + exp); \n        \n\n        \n          \n             } \n        \n\n        \n          \n           }); \n        \n    \n  \n\n\nI believe the reason indeed has to do with naming.", "author": "vcrfxia", "createdAt": "2020-12-18T19:21:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MjUyNg==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546072526", "bodyText": "sounds good, we can keep it like that for now", "author": "agavra", "createdAt": "2020-12-18T20:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDY3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6d4302daba861a0f1ef8283c011272338a423cf7", "chunk": "diff --git a/ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java b/ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java\nindex 9b5599b0f8..32c6df1c9c 100644\n--- a/ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java\n+++ b/ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java\n\n@@ -30,7 +30,7 @@ import java.util.Optional;\n @Immutable\n public class PartitionBy extends AstNode {\n \n-  private final List<Expression> partitionByExpressions;\n+  private final ImmutableList<Expression> partitionByExpressions;\n \n   public PartitionBy(\n       final Optional<NodeLocation> location,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNTI3Nw==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546015277", "bodyText": "not your code, but can we rename this partitionBy?", "author": "agavra", "createdAt": "2020-12-18T18:33:35Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java", "diffHunk": "@@ -54,18 +70,18 @@ public boolean equals(final Object o) {\n       return false;\n     }\n     final PartitionBy groupBy = (PartitionBy) o;", "originalCommit": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d4302daba861a0f1ef8283c011272338a423cf7", "chunk": "diff --git a/ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java b/ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java\nindex 9b5599b0f8..32c6df1c9c 100644\n--- a/ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java\n+++ b/ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java\n\n@@ -69,8 +69,8 @@ public class PartitionBy extends AstNode {\n     if (o == null || getClass() != o.getClass()) {\n       return false;\n     }\n-    final PartitionBy groupBy = (PartitionBy) o;\n-    return Objects.equals(partitionByExpressions, groupBy.partitionByExpressions);\n+    final PartitionBy partitionBy = (PartitionBy) o;\n+    return Objects.equals(partitionByExpressions, partitionBy.partitionByExpressions);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNDc0MA==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546024740", "bodyText": "instead of relying on the implicit ordering of the partition by, it might make sense to lookup the partitionByCol.name in the resultSchema at the cost of a bit of performance. thoughts?", "author": "agavra", "createdAt": "2020-12-18T18:51:45Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -76,118 +79,168 @@ private PartitionByParamsFactory() {\n   public static <K> PartitionByParams<K> build(\n       final LogicalSchema sourceSchema,\n       final ExecutionKeyFactory<K> serdeFactory,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final KsqlConfig ksqlConfig,\n       final FunctionRegistry functionRegistry,\n       final ProcessingLogger logger\n   ) {\n-    final Optional<ColumnName> partitionByCol = getPartitionByColumnName(sourceSchema, partitionBy);\n+    final List<PartitionByColumn> partitionByCols =\n+        getPartitionByColumnName(sourceSchema, partitionBy);\n \n     final LogicalSchema resultSchema =\n-        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n \n     final Mapper<K> mapper;\n-    if (partitionBy instanceof NullLiteral) {\n+    if (isPartitionByNull(partitionBy)) {\n       // In case of PARTITION BY NULL, it is sufficient to set the new key to null as the old key\n       // is already present in the current value\n       mapper = (k, v) -> new KeyValue<>(null, v);\n     } else {\n-      final Set<? extends ColumnReferenceExp> partitionByCols =\n-          ColumnExtractor.extractColumns(partitionBy);\n-      final boolean partitionByInvolvesKeyColsOnly = partitionByCols.stream()\n+      final Set<? extends ColumnReferenceExp> sourceColsInPartitionBy = partitionBy.stream()\n+          .flatMap(pby -> ColumnExtractor.extractColumns(pby).stream())\n+          .collect(Collectors.toSet());\n+      final boolean partitionByInvolvesKeyColsOnly = sourceColsInPartitionBy.stream()\n           .map(ColumnReferenceExp::getColumnName)\n           .allMatch(sourceSchema::isKeyColumn);\n \n-      final PartitionByExpressionEvaluator evaluator = buildExpressionEvaluator(\n-          sourceSchema,\n-          partitionBy,\n-          ksqlConfig,\n-          functionRegistry,\n-          logger,\n-          partitionByInvolvesKeyColsOnly\n-      );\n-      mapper = buildMapper(resultSchema, partitionByCol, evaluator, serdeFactory);\n+      // TODO: what should be the behavior if some partition by expressions involve value columns but others don't, and a tombstone is received? should we drop the entire record? that's what's currently happening in this implementation. I think -- check\n+      final List<PartitionByExpressionEvaluator> evaluators = partitionBy.stream()\n+          .map(pby -> buildExpressionEvaluator(\n+              sourceSchema,\n+              pby,\n+              ksqlConfig,\n+              functionRegistry,\n+              logger,\n+              partitionByInvolvesKeyColsOnly\n+          )).collect(Collectors.toList());\n+      mapper = buildMapper(resultSchema, partitionByCols, evaluators, serdeFactory);\n     }\n \n-    return new PartitionByParams<K>(resultSchema, mapper);\n+    return new PartitionByParams<K>(resultSchema, mapper); // TODO: remove K\n   }\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry\n   ) {\n-    final Optional<ColumnName> partitionByCol =\n+    final List<PartitionByColumn> partitionByCols =\n         getPartitionByColumnName(sourceSchema, partitionBy);\n \n-    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n+  }\n+\n+  // TODO: move\n+  public static boolean isPartitionByNull(final List<Expression> partitionBys) {\n+    final boolean nullExpressionPresent = partitionBys.stream()\n+        .anyMatch(pb -> pb instanceof NullLiteral);\n+\n+    if (!nullExpressionPresent) {\n+      return false;\n+    }\n+\n+    if (partitionBys.size() > 1) {\n+      throw new KsqlException(\"Cannot PARTITION BY multiple columns including NULL\");\n+    }\n+\n+    return true;\n   }\n \n   private static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry,\n-      final Optional<ColumnName> partitionByCol\n+      final List<PartitionByColumn> partitionByCols\n   ) {\n     final ExpressionTypeManager expressionTypeManager =\n         new ExpressionTypeManager(sourceSchema, functionRegistry);\n \n-    final SqlType keyType = expressionTypeManager\n-        .getExpressionSqlType(partitionBy);\n+    final List<SqlType> keyTypes = partitionBy.stream()\n+        .map(expressionTypeManager::getExpressionSqlType)\n+        .collect(Collectors.toList());\n \n-    final ColumnName newKeyName = partitionByCol\n-        .orElseGet(() -> ColumnNames.uniqueAliasFor(partitionBy, sourceSchema));\n+    if (isPartitionByNull(partitionBy)) {\n+      final Builder builder = LogicalSchema.builder();\n+      builder.valueColumns(sourceSchema.value());\n+      return builder.build();\n+    } else {\n+      final Builder builder = LogicalSchema.builder();\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        builder.keyColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+      }\n \n-    final Builder builder = LogicalSchema.builder();\n-    if (keyType != null) {\n-      builder.keyColumn(newKeyName, keyType);\n-    }\n-    builder.valueColumns(sourceSchema.value());\n+      builder.valueColumns(sourceSchema.value());\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        if (partitionByCols.get(i).shouldAppend) {\n+          // New key column added, copy in to value schema:\n+          builder.valueColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+        }\n+      }\n \n-    if (keyType != null && !partitionByCol.isPresent()) {\n-      // New key column added, copy in to value schema:\n-      builder.valueColumn(newKeyName, keyType);\n+      return builder.build();\n     }\n-\n-    return builder.build();\n   }\n \n-  private static Optional<ColumnName> getPartitionByColumnName(\n-      final LogicalSchema sourceSchema,\n-      final Expression partitionBy\n-  ) {\n-    if (partitionBy instanceof ColumnReferenceExp) {\n-      // PARTITION BY column:\n-      final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n-\n-      final Column column = sourceSchema\n-          .findValueColumn(columnName)\n-          .orElseThrow(() ->\n-              new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+  // TODO: move, add accessors?\n+  private static class PartitionByColumn {\n+    final ColumnName name;\n+    final boolean shouldAppend;\n \n-      return Optional.of(column.name());\n+    PartitionByColumn(final ColumnName name, final boolean shouldAppend) {\n+      this.name = Objects.requireNonNull(name, \"name\");\n+      this.shouldAppend = shouldAppend;\n     }\n+  }\n \n-    return Optional.empty();\n+  private static List<PartitionByColumn> getPartitionByColumnName(\n+      final LogicalSchema sourceSchema,\n+      final List<Expression> partitionByExpressions\n+  ) {\n+    final ColumnAliasGenerator columnAliasGenerator =\n+        ColumnNames.columnAliasGenerator(Stream.of(sourceSchema));\n+    return partitionByExpressions.stream()\n+        .map(partitionBy -> {\n+          if (partitionBy instanceof ColumnReferenceExp) {\n+            // PARTITION BY column:\n+            final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n+\n+            final Column column = sourceSchema\n+                .findValueColumn(columnName)\n+                .orElseThrow(() ->\n+                    new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+\n+            return new PartitionByColumn(column.name(), false);\n+          } else {\n+            return new PartitionByColumn(columnAliasGenerator.uniqueAliasFor(partitionBy), true);\n+          }\n+        })\n+        .collect(Collectors.toList());\n   }\n \n   private static <K> Mapper<K> buildMapper(\n-      final LogicalSchema resultSchema,\n-      final Optional<ColumnName> partitionByCol,\n-      final PartitionByExpressionEvaluator evaluator,\n+      final LogicalSchema resultSchema, // TODO: remove dead param (and simplify build())\n+      final List<PartitionByColumn> partitionByCol,\n+      final List<PartitionByExpressionEvaluator> evaluators,\n       final ExecutionKeyFactory<K> executionKeyFactory\n   ) {\n-    // If partitioning by something other than an existing column, then a new key will have\n-    // been synthesized. This new key must be appended to the value to make it available for\n-    // stream processing, in the same way SourceBuilder appends the key and rowtime to the value:\n-    final boolean appendNewKey = !partitionByCol.isPresent();\n-\n     return (oldK, row) -> {\n-      final Object newKey = evaluator.evaluate(oldK, row);\n-      final K key = executionKeyFactory.constructNewKey(oldK, genericKey(newKey));\n-\n-      if (row != null && appendNewKey) {\n-        row.append(newKey);\n+      final List<Object> newKeyComponents = evaluators.stream()\n+          .map(evaluator -> evaluator.evaluate(oldK, row))\n+          .collect(Collectors.toList());\n+\n+      final K key =\n+          executionKeyFactory.constructNewKey(oldK, GenericKey.fromList(newKeyComponents));\n+\n+      if (row != null) {\n+        for (int i = 0; i < partitionByCol.size(); i++) {\n+          if (partitionByCol.get(i).shouldAppend) {", "originalCommit": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0OTQyMg==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546049422", "bodyText": "Do you mean replacing shouldAppend with a check to see whether the partitionByCol.name is present in the resultSchema as a value column, or do you mean iterating through resultSchema rather than partitionByCols? The former doesn't seem like an improvement to me, if we're still relying on the ordering of partitionByCols in the iteration. To remove reliance on ordering, we can do the latter and replace the lists (of columns and evaluators) with maps keyed on column name instead, but it's not clear to me that's better. It feels slightly harder to reason about code-wise but I wouldn't mind making the change.\nWhat's your concern regarding relying the ordering? Are you worried it's brittle, or something else?", "author": "vcrfxia", "createdAt": "2020-12-18T19:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNDc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3NTY4Ng==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546075686", "bodyText": "When I was reviewing the code I thought we could just set it at the index (e.g. row.set(resultSchema.get(partitionCol.name).index())). So we still keep the iteration on partitionByCol but we set it in the row based on it's index in the schema.\n\nWhat's your concern regarding relying the ordering? Are you worried it's brittle, or something else?\n\nyeah - I'm worried that it's brittle.", "author": "agavra", "createdAt": "2020-12-18T20:29:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNDc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMDE2MA==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546110160", "bodyText": "Ah, interesting. (We'd have to first re-size the row before calling .set() but that's an implementation detail.) The advantage of your proposal is that we can change the details of the result schema without needing to update the logic here. If we extended that further, really we should also be setting the existing value fields in the new row based on the result schema, rather than leaving those intact and appending key columns.\nI guess I'm not convinced this change is necessary since our test coverage in this area is quite good -- lots of tests would break if someone modified the result schema without corresponding updates here. OTOH, it's very possible I'm biased towards thinking this code is understandable as is since I've been working on it for a while. If your assessment differs as someone who hasn't worked with this code as much, I'm inclined to go with your judgment.\nAs for performance, LogicalSchema stores a list of columns so finding a particular column might be slow. If we implemented this we'd want to build the index mapping outside the creation of the actual mapper, and have the mapper use the index mapping directly. I'm not opposed to this. If you think it's preferable I can open a follow-up PR.", "author": "vcrfxia", "createdAt": "2020-12-18T21:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNDc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMjQ3NA==", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546112474", "bodyText": "I'm happy to leave it as is, though I suspect we'll run into this discussion again if/when we stop copying things from the key into the value", "author": "agavra", "createdAt": "2020-12-18T22:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNDc0MA=="}], "type": "inlineReview", "revised_code": {"commit": "5e816621741c697242b7602624e7cd1d5692103f", "chunk": "diff --git a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java\nindex 45637283e1..edb4f8099f 100644\n--- a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java\n+++ b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java\n\n@@ -79,98 +79,82 @@ public final class PartitionByParamsFactory {\n   public static <K> PartitionByParams<K> build(\n       final LogicalSchema sourceSchema,\n       final ExecutionKeyFactory<K> serdeFactory,\n-      final List<Expression> partitionBy, // TODO: rename?\n+      final List<Expression> partitionBys,\n       final KsqlConfig ksqlConfig,\n       final FunctionRegistry functionRegistry,\n       final ProcessingLogger logger\n   ) {\n     final List<PartitionByColumn> partitionByCols =\n-        getPartitionByColumnName(sourceSchema, partitionBy);\n+        getPartitionByColumnName(sourceSchema, partitionBys);\n \n     final LogicalSchema resultSchema =\n-        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n+        buildSchema(sourceSchema, partitionBys, functionRegistry, partitionByCols);\n \n     final Mapper<K> mapper;\n-    if (isPartitionByNull(partitionBy)) {\n+    if (isPartitionByNull(partitionBys)) {\n       // In case of PARTITION BY NULL, it is sufficient to set the new key to null as the old key\n       // is already present in the current value\n       mapper = (k, v) -> new KeyValue<>(null, v);\n     } else {\n-      final Set<? extends ColumnReferenceExp> sourceColsInPartitionBy = partitionBy.stream()\n-          .flatMap(pby -> ColumnExtractor.extractColumns(pby).stream())\n-          .collect(Collectors.toSet());\n-      final boolean partitionByInvolvesKeyColsOnly = sourceColsInPartitionBy.stream()\n-          .map(ColumnReferenceExp::getColumnName)\n-          .allMatch(sourceSchema::isKeyColumn);\n-\n-      // TODO: what should be the behavior if some partition by expressions involve value columns but others don't, and a tombstone is received? should we drop the entire record? that's what's currently happening in this implementation. I think -- check\n-      final List<PartitionByExpressionEvaluator> evaluators = partitionBy.stream()\n-          .map(pby -> buildExpressionEvaluator(\n-              sourceSchema,\n-              pby,\n-              ksqlConfig,\n-              functionRegistry,\n-              logger,\n-              partitionByInvolvesKeyColsOnly\n-          )).collect(Collectors.toList());\n-      mapper = buildMapper(resultSchema, partitionByCols, evaluators, serdeFactory);\n+      final List<PartitionByExpressionEvaluator> evaluators = partitionBys.stream()\n+          .map(pby -> {\n+            final Set<? extends ColumnReferenceExp> sourceColsInPartitionBy =\n+                ColumnExtractor.extractColumns(pby);\n+            final boolean partitionByInvolvesKeyColsOnly = sourceColsInPartitionBy.stream()\n+                .map(ColumnReferenceExp::getColumnName)\n+                .allMatch(sourceSchema::isKeyColumn);\n+\n+            return buildExpressionEvaluator(\n+                sourceSchema,\n+                pby,\n+                ksqlConfig,\n+                functionRegistry,\n+                logger,\n+                partitionByInvolvesKeyColsOnly\n+            );\n+          }).collect(Collectors.toList());\n+      mapper = buildMapper(partitionByCols, evaluators, serdeFactory);\n     }\n \n-    return new PartitionByParams<K>(resultSchema, mapper); // TODO: remove K\n+    return new PartitionByParams<>(resultSchema, mapper);\n   }\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final List<Expression> partitionBy, // TODO: rename?\n+      final List<Expression> partitionBys,\n       final FunctionRegistry functionRegistry\n   ) {\n     final List<PartitionByColumn> partitionByCols =\n-        getPartitionByColumnName(sourceSchema, partitionBy);\n+        getPartitionByColumnName(sourceSchema, partitionBys);\n \n-    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n-  }\n-\n-  // TODO: move\n-  public static boolean isPartitionByNull(final List<Expression> partitionBys) {\n-    final boolean nullExpressionPresent = partitionBys.stream()\n-        .anyMatch(pb -> pb instanceof NullLiteral);\n-\n-    if (!nullExpressionPresent) {\n-      return false;\n-    }\n-\n-    if (partitionBys.size() > 1) {\n-      throw new KsqlException(\"Cannot PARTITION BY multiple columns including NULL\");\n-    }\n-\n-    return true;\n+    return buildSchema(sourceSchema, partitionBys, functionRegistry, partitionByCols);\n   }\n \n   private static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final List<Expression> partitionBy, // TODO: rename?\n+      final List<Expression> partitionBys,\n       final FunctionRegistry functionRegistry,\n       final List<PartitionByColumn> partitionByCols\n   ) {\n     final ExpressionTypeManager expressionTypeManager =\n         new ExpressionTypeManager(sourceSchema, functionRegistry);\n \n-    final List<SqlType> keyTypes = partitionBy.stream()\n+    final List<SqlType> keyTypes = partitionBys.stream()\n         .map(expressionTypeManager::getExpressionSqlType)\n         .collect(Collectors.toList());\n \n-    if (isPartitionByNull(partitionBy)) {\n+    if (isPartitionByNull(partitionBys)) {\n       final Builder builder = LogicalSchema.builder();\n       builder.valueColumns(sourceSchema.value());\n       return builder.build();\n     } else {\n       final Builder builder = LogicalSchema.builder();\n-      for (int i = 0; i < partitionBy.size(); i++) {\n+      for (int i = 0; i < partitionBys.size(); i++) {\n         builder.keyColumn(partitionByCols.get(i).name, keyTypes.get(i));\n       }\n \n       builder.valueColumns(sourceSchema.value());\n-      for (int i = 0; i < partitionBy.size(); i++) {\n+      for (int i = 0; i < partitionBys.size(); i++) {\n         if (partitionByCols.get(i).shouldAppend) {\n           // New key column added, copy in to value schema:\n           builder.valueColumn(partitionByCols.get(i).name, keyTypes.get(i));\n"}}, {"oid": "5e816621741c697242b7602624e7cd1d5692103f", "url": "https://github.com/confluentinc/ksql/commit/5e816621741c697242b7602624e7cd1d5692103f", "message": "chore: feedback", "committedDate": "2020-12-18T19:43:28Z", "type": "commit"}]}