{"pr_number": 5465, "pr_title": "chore: switch synthetic join key to use ROWKEY", "pr_createdAt": "2020-05-22T19:29:47Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5465", "timeline": [{"oid": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "url": "https://github.com/confluentinc/ksql/commit/bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "message": "chore: switch synthetic join key to use ROWKEY\n\nThis change switching the naming of the synthetic key column created by some joins to use the name `ROWKEY`, or `ROWKEY_1`, `ROWKEY_2` etc if the is a name clash.\n\nThe change also contains tidy up and refactoring. Specifically, realizing that the validation `Analyzer` does is shared with pull queries, so it doesn't make sense to move this validation.  Instead, given the synthetic key column is a short to medium term problem only, i.e. it will go away with time, switched the design so that all validation returns to `Analyzer`, except is now won't through on an unknown column is it _might_ be a synthetic key column.  Validation of potential synthetic key columns are handled by the logic model. This works because pull queries don't (yet) have this problem.\n\n - There was duplicate logic between `AstSantizer` and `Analayzer` around reporting ambiguous and unknown columns.\n    - Changed so that, for now, `AstSanitzer` reports ambiguous columns and `Analyzer` reports unknown columns. Not perfect, but better than both attempting to do both.\n - It puts back the validation of Selects in `Analyser` and enhanced it and `ColumnReferenceValidator` to know when a synthetic key column is possible and to not throw on one. False positives are possible, but are caught by the logical model.\n - Simplified the logical model to only worry about validating synthetic key columns in projections.\n - Split `RepartitionNode` into classes specific for its two use-cases.", "committedDate": "2020-05-22T19:28:47Z", "type": "commit"}, {"oid": "f71f852804cc9570179e7d3532f5ab7e2af60dba", "url": "https://github.com/confluentinc/ksql/commit/f71f852804cc9570179e7d3532f5ab7e2af60dba", "message": "test: test code", "committedDate": "2020-05-22T19:30:59Z", "type": "commit"}, {"oid": "0a6a8013a5fb0b52eb79a3a699e4833d5e7aadeb", "url": "https://github.com/confluentinc/ksql/commit/0a6a8013a5fb0b52eb79a3a699e4833d5e7aadeb", "message": "test: historical plans", "committedDate": "2020-05-22T19:31:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzU2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429487565", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // AstSanitizer should catches ambiguous columns\n          \n          \n            \n                        // AstSanitizer should catch ambiguous columns", "author": "agavra", "createdAt": "2020-05-22T23:23:39Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java", "diffHunk": "@@ -85,46 +83,55 @@ public Void visitQualifiedColumnReference(\n         final QualifiedColumnReferenceExp node,\n         final Object context\n     ) {\n-      getSource(node.getLocation(), Optional.of(node.getQualifier()), node.getColumnName())\n-          .ifPresent(referencedSources::add);\n+      validateColumn(node);\n       return null;\n     }\n \n-    private Optional<SourceName> getSource(\n-        final Optional<NodeLocation> location,\n-        final Optional<SourceName> sourceName,\n-        final ColumnName name\n-    ) {\n-      final Set<SourceName> sourcesWithField = sourceSchemas.sourcesWithField(sourceName, name);\n+    private void validateColumn(final ColumnReferenceExp colRef) {\n+      final Set<SourceName> sourcesWithField = sourceSchemas\n+          .sourcesWithField(colRef.maybeQualifier(), colRef.getColumnName());\n+\n       if (sourcesWithField.isEmpty()) {\n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + sourceName.map(n -> n.text() + KsqlConstants.DOT + name.text())\n-            .orElse(name.text())\n-            + \"' cannot be resolved.\");\n+        if (couldBeSyntheticJoinColumn(colRef)) {\n+          // Validating this is handled in the logical model.\n+          return;\n+        }\n+\n+        throw new UnknownColumnException(clauseType, colRef);\n       }\n \n-      if (sourcesWithField.size() > 1) {\n-        final String possibilities = sourcesWithField.stream()\n-            .map(source -> new QualifiedColumnReferenceExp(source, name))\n-            .map(Objects::toString)\n-            .sorted()\n-            .collect(Collectors.joining(\", \"));\n+      final SourceName source = colRef.maybeQualifier()\n+          .orElseGet(() -> {\n+            // AstSanitizer should catches ambiguous columns", "originalCommit": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b1d5bbdbaa4861f579825099865fe2ce5d87887d", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java b/ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java\nindex 08c0544c6c..72c5f67e66 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java\n\n@@ -102,7 +102,7 @@ class ColumnReferenceValidator {\n \n       final SourceName source = colRef.maybeQualifier()\n           .orElseGet(() -> {\n-            // AstSanitizer should catches ambiguous columns\n+            // AstSanitizer catches ambiguous columns\n             return Iterables.getOnlyElement(sourcesWithField);\n           });\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzcxMw==", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429487713", "bodyText": "seems like if we're checking equality it should be made either an enum or a constant", "author": "agavra", "createdAt": "2020-05-22T23:24:49Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java", "diffHunk": "@@ -85,46 +83,55 @@ public Void visitQualifiedColumnReference(\n         final QualifiedColumnReferenceExp node,\n         final Object context\n     ) {\n-      getSource(node.getLocation(), Optional.of(node.getQualifier()), node.getColumnName())\n-          .ifPresent(referencedSources::add);\n+      validateColumn(node);\n       return null;\n     }\n \n-    private Optional<SourceName> getSource(\n-        final Optional<NodeLocation> location,\n-        final Optional<SourceName> sourceName,\n-        final ColumnName name\n-    ) {\n-      final Set<SourceName> sourcesWithField = sourceSchemas.sourcesWithField(sourceName, name);\n+    private void validateColumn(final ColumnReferenceExp colRef) {\n+      final Set<SourceName> sourcesWithField = sourceSchemas\n+          .sourcesWithField(colRef.maybeQualifier(), colRef.getColumnName());\n+\n       if (sourcesWithField.isEmpty()) {\n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + sourceName.map(n -> n.text() + KsqlConstants.DOT + name.text())\n-            .orElse(name.text())\n-            + \"' cannot be resolved.\");\n+        if (couldBeSyntheticJoinColumn(colRef)) {\n+          // Validating this is handled in the logical model.\n+          return;\n+        }\n+\n+        throw new UnknownColumnException(clauseType, colRef);\n       }\n \n-      if (sourcesWithField.size() > 1) {\n-        final String possibilities = sourcesWithField.stream()\n-            .map(source -> new QualifiedColumnReferenceExp(source, name))\n-            .map(Objects::toString)\n-            .sorted()\n-            .collect(Collectors.joining(\", \"));\n+      final SourceName source = colRef.maybeQualifier()\n+          .orElseGet(() -> {\n+            // AstSanitizer should catches ambiguous columns\n+            return Iterables.getOnlyElement(sourcesWithField);\n+          });\n+\n+      referencedSources.add(source);\n+    }\n \n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + name.text() + \"' is ambiguous. \"\n-            + \"Could be any of: \" + possibilities);\n+    private boolean couldBeSyntheticJoinColumn(final ColumnReferenceExp colRef) {\n+      if (!possibleSyntheticColumns) {\n+        // Some queries never have synthetic columns, e.g. pull or aggregations.\n+        return false;\n       }\n \n-      return Optional.of(Iterables.getOnlyElement(sourcesWithField));\n-    }\n+      if (!sourceSchemas.isJoin()) {\n+        // Synthetic join columns only occur in joins... duh!\n+        return false;\n+      }\n \n-    private String errorPrefix(final Optional<NodeLocation> location) {\n-      final String loc = location\n-          .map(Objects::toString)\n-          .map(text -> text + \": \")\n-          .orElse(\"\");\n+      if (colRef instanceof QualifiedColumnReferenceExp) {\n+        // Synthetic join columns can't be qualified, as they don't belong to any source\n+        return false;\n+      }\n+\n+      if (!clauseType.equals(\"SELECT\")) {", "originalCommit": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5Mzk5NQ==", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429493995", "bodyText": "Normally I'd agree, but it's only short term code and there are tests to ensure it does what we need.", "author": "big-andy-coates", "createdAt": "2020-05-23T00:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzcxMw=="}], "type": "inlineReview", "revised_code": {"commit": "b1d5bbdbaa4861f579825099865fe2ce5d87887d", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java b/ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java\nindex 08c0544c6c..72c5f67e66 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java\n\n@@ -102,7 +102,7 @@ class ColumnReferenceValidator {\n \n       final SourceName source = colRef.maybeQualifier()\n           .orElseGet(() -> {\n-            // AstSanitizer should catches ambiguous columns\n+            // AstSanitizer catches ambiguous columns\n             return Iterables.getOnlyElement(sourcesWithField);\n           });\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4ODE1OA==", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429488158", "bodyText": "would be nice to javadoc", "author": "agavra", "createdAt": "2020-05-22T23:27:38Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+\n+public class PreJoinRepartitionNode extends RepartitionNode {", "originalCommit": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b1d5bbdbaa4861f579825099865fe2ce5d87887d", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java\nindex d71ec56e07..fc66c8903b 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java\n\n@@ -18,6 +18,12 @@ package io.confluent.ksql.planner.plan;\n import io.confluent.ksql.execution.expression.tree.Expression;\n import io.confluent.ksql.schema.ksql.LogicalSchema;\n \n+/**\n+ * Node to handle an implicit repartition required to enable a join.\n+ *\n+ * <p>Any join that is not on the key of the stream requires ksql to perform an\n+ * implicit repartition step before joining.\n+ */\n public class PreJoinRepartitionNode extends RepartitionNode {\n \n   public PreJoinRepartitionNode(\n"}}, {"oid": "b1d5bbdbaa4861f579825099865fe2ce5d87887d", "url": "https://github.com/confluentinc/ksql/commit/b1d5bbdbaa4861f579825099865fe2ce5d87887d", "message": "chore: almog's requested changes", "committedDate": "2020-05-23T00:10:51Z", "type": "commit"}]}