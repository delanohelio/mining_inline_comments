{"pr_number": 4376, "pr_title": "feat: Support JSON format for responses and other refactorings", "pr_createdAt": "2020-01-23T20:42:08Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4376", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NDc1Mw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370574753", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T10:49:52Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -31,21 +30,22 @@\n  */\n public class AcksSubscriber extends ReactiveSubscriber<JsonObject> {\n \n-  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer()\n-      .appendString(\"\\n\");\n   private static final Logger log = LoggerFactory.getLogger(AcksSubscriber.class);\n   private static final int REQUEST_BATCH_SIZE = 1000;\n \n   private final HttpServerResponse response;\n+  private final InsertsStreamResponseWriter insertsStreamResponseWriter;\n   private Long insertsSent;\n   private long acksSent;\n   private boolean drainHandlerSet;\n   private Subscription subscription;\n   private boolean cancelled;\n \n-  public AcksSubscriber(final Context context, final HttpServerResponse response) {\n+  public AcksSubscriber(final Context context, final HttpServerResponse response,\n+      final InsertsStreamResponseWriter insertsStreamResponseWriter) {\n     super(context);\n     this.response = response;\n+    this.insertsStreamResponseWriter = insertsStreamResponseWriter;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYyOTgyNA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370629824", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NDc1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\nindex ffdad1cee4..edf9d53491 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\n\n@@ -44,8 +45,8 @@ public class AcksSubscriber extends ReactiveSubscriber<JsonObject> {\n   public AcksSubscriber(final Context context, final HttpServerResponse response,\n       final InsertsStreamResponseWriter insertsStreamResponseWriter) {\n     super(context);\n-    this.response = response;\n-    this.insertsStreamResponseWriter = insertsStreamResponseWriter;\n+    this.response = Objects.requireNonNull(response);\n+    this.insertsStreamResponseWriter = Objects.requireNonNull(insertsStreamResponseWriter);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NTE5Mw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370575193", "bodyText": "If this is specifically only for push queries, as per java-doc above, maybe it should have Push in the name?", "author": "big-andy-coates", "createdAt": "2020-01-24T10:50:54Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java", "diffHunk": "@@ -15,46 +15,39 @@\n \n package io.confluent.ksql.api.server;\n \n-import java.util.Objects;\n import java.util.UUID;\n \n /**\n- * Handle to a query that is passed to the client on query creation and can subsequently be used to\n- * close a query. Uses UUID.randomUUID() which internally uses SecureRandom - this makes the id\n+ * Holder for a push query running on the server.\n+ *\n+ * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n  * cryptographically secure. This is important as we don't want random users guessing query IDs and\n  * closing other peoples queries.\n  */\n-public final class ApiQueryID {\n+public class ApiQuery {", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYzMDIxNQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370630215", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NTE5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java\nindex 5cde801fdb..48234b2ef5 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java\n\n@@ -15,26 +15,20 @@\n \n package io.confluent.ksql.api.server;\n \n-import java.util.UUID;\n-\n /**\n- * Holder for a push query running on the server.\n- *\n- * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n- * cryptographically secure. This is important as we don't want random users guessing query IDs and\n- * closing other peoples queries.\n+ * Holder for a push query running on the server\n  */\n public class ApiQuery {\n \n   private final Server server;\n-  private final String id;\n+  private final ApiQueryID id;\n   private final ConnectionQueries connectionQueries;\n   private final QuerySubscriber querySubscriber;\n \n   public ApiQuery(final Server server, final ConnectionQueries connectionQueries,\n       final QuerySubscriber querySubscriber) {\n     this.server = server;\n-    this.id = UUID.randomUUID().toString();\n+    this.id = new ApiQueryID();\n     this.connectionQueries = connectionQueries;\n     this.querySubscriber = querySubscriber;\n     connectionQueries.addQuery(this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NTI5OA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370575298", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T10:51:08Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java", "diffHunk": "@@ -15,46 +15,39 @@\n \n package io.confluent.ksql.api.server;\n \n-import java.util.Objects;\n import java.util.UUID;\n \n /**\n- * Handle to a query that is passed to the client on query creation and can subsequently be used to\n- * close a query. Uses UUID.randomUUID() which internally uses SecureRandom - this makes the id\n+ * Holder for a push query running on the server.\n+ *\n+ * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n  * cryptographically secure. This is important as we don't want random users guessing query IDs and\n  * closing other peoples queries.\n  */\n-public final class ApiQueryID {\n+public class ApiQuery {\n \n+  private final Server server;\n   private final String id;\n+  private final ConnectionQueries connectionQueries;\n+  private final QuerySubscriber querySubscriber;\n \n-  public ApiQueryID() {\n+  public ApiQuery(final Server server, final ConnectionQueries connectionQueries,\n+      final QuerySubscriber querySubscriber) {\n+    this.server = server;\n     this.id = UUID.randomUUID().toString();\n+    this.connectionQueries = connectionQueries;\n+    this.querySubscriber = querySubscriber;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYzMDkzMA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370630930", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NTI5OA=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java\nindex 5cde801fdb..48234b2ef5 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java\n\n@@ -15,26 +15,20 @@\n \n package io.confluent.ksql.api.server;\n \n-import java.util.UUID;\n-\n /**\n- * Holder for a push query running on the server.\n- *\n- * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n- * cryptographically secure. This is important as we don't want random users guessing query IDs and\n- * closing other peoples queries.\n+ * Holder for a push query running on the server\n  */\n public class ApiQuery {\n \n   private final Server server;\n-  private final String id;\n+  private final ApiQueryID id;\n   private final ConnectionQueries connectionQueries;\n   private final QuerySubscriber querySubscriber;\n \n   public ApiQuery(final Server server, final ConnectionQueries connectionQueries,\n       final QuerySubscriber querySubscriber) {\n     this.server = server;\n-    this.id = UUID.randomUUID().toString();\n+    this.id = new ApiQueryID();\n     this.connectionQueries = connectionQueries;\n     this.querySubscriber = querySubscriber;\n     connectionQueries.addQuery(this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NjE5Mw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370576193", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T10:53:21Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handles requests to the close-query endpoint\n+ */\n+public class CloseQueryHandler implements Handler<RoutingContext> {\n+\n+  private final Server server;\n+\n+  public CloseQueryHandler(final Server server) {\n+    this.server = server;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYzMDk1Nw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370630957", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NjE5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java\nindex 0bfbd44481..de6d21a969 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java\n\n@@ -37,12 +37,13 @@ public class CloseQueryHandler implements Handler<RoutingContext> {\n   @Override\n   public void handle(final RoutingContext routingContext) {\n     final JsonObject requestBody = routingContext.getBodyAsJson();\n-    final String queryID = requestBody.getString(\"queryID\");\n-    if (queryID == null) {\n+    final String queryIDArg = requestBody.getString(\"queryID\");\n+    if (queryIDArg == null) {\n       handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n           \"No queryID in arguments\");\n       return;\n     }\n+    final ApiQueryID queryID = new ApiQueryID(queryIDArg);\n     final ApiQuery query = server.removeQuery(queryID);\n     if (query == null) {\n       handleError(routingContext.response(), 400, ERROR_CODE_UNKNOWN_QUERY_ID,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NjUwMw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370576503", "bodyText": "As with other PR, our convention would have it as queryId. Best to be consistent.", "author": "big-andy-coates", "createdAt": "2020-01-24T10:53:56Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handles requests to the close-query endpoint\n+ */\n+public class CloseQueryHandler implements Handler<RoutingContext> {\n+\n+  private final Server server;\n+\n+  public CloseQueryHandler(final Server server) {\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    final JsonObject requestBody = routingContext.getBodyAsJson();\n+    final String queryID = requestBody.getString(\"queryID\");", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYzMzg2MA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370633860", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NjUwMw=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java\nindex 0bfbd44481..de6d21a969 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java\n\n@@ -37,12 +37,13 @@ public class CloseQueryHandler implements Handler<RoutingContext> {\n   @Override\n   public void handle(final RoutingContext routingContext) {\n     final JsonObject requestBody = routingContext.getBodyAsJson();\n-    final String queryID = requestBody.getString(\"queryID\");\n-    if (queryID == null) {\n+    final String queryIDArg = requestBody.getString(\"queryID\");\n+    if (queryIDArg == null) {\n       handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n           \"No queryID in arguments\");\n       return;\n     }\n+    final ApiQueryID queryID = new ApiQueryID(queryIDArg);\n     final ApiQuery query = server.removeQuery(queryID);\n     if (query == null) {\n       handleError(routingContext.response(), 400, ERROR_CODE_UNKNOWN_QUERY_ID,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NzExNQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370577115", "bodyText": "still think queryId would benefit from being a concrete type other than String, as it was before. This will help disambiguate this query id from others in the system.", "author": "big-andy-coates", "createdAt": "2020-01-24T10:55:24Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handles requests to the close-query endpoint\n+ */\n+public class CloseQueryHandler implements Handler<RoutingContext> {\n+\n+  private final Server server;\n+\n+  public CloseQueryHandler(final Server server) {\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    final JsonObject requestBody = routingContext.getBodyAsJson();\n+    final String queryID = requestBody.getString(\"queryID\");\n+    if (queryID == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n+          \"No queryID in arguments\");\n+      return;\n+    }\n+    final ApiQuery query = server.removeQuery(queryID);", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYzODg1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370638851", "bodyText": "maybe overkill, but ok.", "author": "purplefox", "createdAt": "2020-01-24T13:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NzExNQ=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java\nindex 0bfbd44481..de6d21a969 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/CloseQueryHandler.java\n\n@@ -37,12 +37,13 @@ public class CloseQueryHandler implements Handler<RoutingContext> {\n   @Override\n   public void handle(final RoutingContext routingContext) {\n     final JsonObject requestBody = routingContext.getBodyAsJson();\n-    final String queryID = requestBody.getString(\"queryID\");\n-    if (queryID == null) {\n+    final String queryIDArg = requestBody.getString(\"queryID\");\n+    if (queryIDArg == null) {\n       handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n           \"No queryID in arguments\");\n       return;\n     }\n+    final ApiQueryID queryID = new ApiQueryID(queryIDArg);\n     final ApiQuery query = server.removeQuery(queryID);\n     if (query == null) {\n       handleError(routingContext.response(), 400, ERROR_CODE_UNKNOWN_QUERY_ID,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NzI3Mw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370577273", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T10:55:49Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Keeps track of which queries are owned by which connection so we can close them when the\n+ * connection is closed\n+ */\n+public class ConnectionQueries implements Handler<Void> {\n+\n+  private final HttpConnection conn;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+\n+  private final Set<ApiQuery> queries = new HashSet<>();\n+\n+  public ConnectionQueries(final HttpConnection conn, final Server server,\n+      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n+    this.conn = conn;\n+    this.server = server;\n+    this.connectionsMap = connectionsMap;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYzOTA0OQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370639049", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NzI3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java\ndeleted file mode 100644\nindex d959d536fc..0000000000\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java\n+++ /dev/null\n\n@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.api.server;\n-\n-import io.vertx.core.Handler;\n-import io.vertx.core.http.HttpConnection;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n- * Keeps track of which queries are owned by which connection so we can close them when the\n- * connection is closed\n- */\n-public class ConnectionQueries implements Handler<Void> {\n-\n-  private final HttpConnection conn;\n-  private final Server server;\n-  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n-\n-  private final Set<ApiQuery> queries = new HashSet<>();\n-\n-  public ConnectionQueries(final HttpConnection conn, final Server server,\n-      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n-    this.conn = conn;\n-    this.server = server;\n-    this.connectionsMap = connectionsMap;\n-    conn.closeHandler(this);\n-    server.registerQueryConnection(conn);\n-  }\n-\n-  public void addQuery(final ApiQuery query) {\n-    queries.add(query);\n-  }\n-\n-  public void removeQuery(final ApiQuery query) {\n-    queries.remove(query);\n-  }\n-\n-  @Override\n-  public void handle(final Void v) {\n-    for (ApiQuery query : queries) {\n-      query.close();\n-    }\n-    connectionsMap.remove(conn);\n-    server.removeQueryConnection(conn);\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NzM0Mw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370577343", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T10:56:00Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Keeps track of which queries are owned by which connection so we can close them when the\n+ * connection is closed\n+ */\n+public class ConnectionQueries implements Handler<Void> {\n+\n+  private final HttpConnection conn;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+\n+  private final Set<ApiQuery> queries = new HashSet<>();\n+\n+  public ConnectionQueries(final HttpConnection conn, final Server server,\n+      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n+    this.conn = conn;\n+    this.server = server;\n+    this.connectionsMap = connectionsMap;\n+    conn.closeHandler(this);\n+    server.registerQueryConnection(conn);\n+  }\n+\n+  public void addQuery(final ApiQuery query) {\n+    queries.add(query);", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYzOTQ1NA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370639454", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:44:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3NzM0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java\ndeleted file mode 100644\nindex d959d536fc..0000000000\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java\n+++ /dev/null\n\n@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.api.server;\n-\n-import io.vertx.core.Handler;\n-import io.vertx.core.http.HttpConnection;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n- * Keeps track of which queries are owned by which connection so we can close them when the\n- * connection is closed\n- */\n-public class ConnectionQueries implements Handler<Void> {\n-\n-  private final HttpConnection conn;\n-  private final Server server;\n-  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n-\n-  private final Set<ApiQuery> queries = new HashSet<>();\n-\n-  public ConnectionQueries(final HttpConnection conn, final Server server,\n-      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n-    this.conn = conn;\n-    this.server = server;\n-    this.connectionsMap = connectionsMap;\n-    conn.closeHandler(this);\n-    server.registerQueryConnection(conn);\n-  }\n-\n-  public void addQuery(final ApiQuery query) {\n-    queries.add(query);\n-  }\n-\n-  public void removeQuery(final ApiQuery query) {\n-    queries.remove(query);\n-  }\n-\n-  @Override\n-  public void handle(final Void v) {\n-    for (ApiQuery query : queries) {\n-      query.close();\n-    }\n-    connectionsMap.remove(conn);\n-    server.removeQueryConnection(conn);\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3ODg0OQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370578849", "bodyText": "Take defensive, ideally immutable, copy.  At the moment any change to the connectionsMap  constructor parameter by forces outside this instance will change the state of this object, i.e. it breaks encapsulation.\nIf the intent is to share state between multiple actors in the system then this is best achieved by having a type that owns the data, and changing the others that need to view / modify the data to call methods on the owning type.", "author": "big-andy-coates", "createdAt": "2020-01-24T10:59:57Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Keeps track of which queries are owned by which connection so we can close them when the\n+ * connection is closed\n+ */\n+public class ConnectionQueries implements Handler<Void> {\n+\n+  private final HttpConnection conn;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+\n+  private final Set<ApiQuery> queries = new HashSet<>();\n+\n+  public ConnectionQueries(final HttpConnection conn, final Server server,\n+      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n+    this.conn = conn;\n+    this.server = server;\n+    this.connectionsMap = connectionsMap;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYzOTYzNQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370639635", "bodyText": "i've encapsulated this in a new type", "author": "purplefox", "createdAt": "2020-01-24T13:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3ODg0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java\ndeleted file mode 100644\nindex d959d536fc..0000000000\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java\n+++ /dev/null\n\n@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.api.server;\n-\n-import io.vertx.core.Handler;\n-import io.vertx.core.http.HttpConnection;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n- * Keeps track of which queries are owned by which connection so we can close them when the\n- * connection is closed\n- */\n-public class ConnectionQueries implements Handler<Void> {\n-\n-  private final HttpConnection conn;\n-  private final Server server;\n-  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n-\n-  private final Set<ApiQuery> queries = new HashSet<>();\n-\n-  public ConnectionQueries(final HttpConnection conn, final Server server,\n-      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n-    this.conn = conn;\n-    this.server = server;\n-    this.connectionsMap = connectionsMap;\n-    conn.closeHandler(this);\n-    server.registerQueryConnection(conn);\n-  }\n-\n-  public void addQuery(final ApiQuery query) {\n-    queries.add(query);\n-  }\n-\n-  public void removeQuery(final ApiQuery query) {\n-    queries.remove(query);\n-  }\n-\n-  @Override\n-  public void handle(final Void v) {\n-    for (ApiQuery query : queries) {\n-      query.close();\n-    }\n-    connectionsMap.remove(conn);\n-    server.removeQueryConnection(conn);\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3OTQzNA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370579434", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:01:37Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedInsertsStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the inserts response stream in delimited format.\n+ *\n+ * <p>Each insert in the incoming stream will have a corresponding entry in the response stream, in\n+ * the same order as the inserts.\n+ *\n+ * <p>Each entry is a JSON object, separated by newline. The overall response does not form a\n+ * single JSON object or array. This makes it easier to parse at the client without recourse to\n+ * streaming JSON parsers.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class DelimitedInsertsStreamResponseWriter implements InsertsStreamResponseWriter {\n+\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer()\n+      .appendString(\"\\n\");\n+\n+  private final HttpServerResponse response;\n+\n+  public DelimitedInsertsStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MDA0OQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370640049", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3OTQzNA=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedInsertsStreamResponseWriter.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedInsertsStreamResponseWriter.java\nindex 6d7800d205..710c2f9344 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedInsertsStreamResponseWriter.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedInsertsStreamResponseWriter.java\n\n@@ -20,16 +20,7 @@ import io.vertx.core.http.HttpServerResponse;\n import io.vertx.core.json.JsonObject;\n \n /**\n- * Writes the inserts response stream in delimited format.\n- *\n- * <p>Each insert in the incoming stream will have a corresponding entry in the response stream, in\n- * the same order as the inserts.\n- *\n- * <p>Each entry is a JSON object, separated by newline. The overall response does not form a\n- * single JSON object or array. This makes it easier to parse at the client without recourse to\n- * streaming JSON parsers.\n- *\n- * <p>Please consult the API documentation for a full description of the format.\n+ * TODO describe format with example\n  */\n public class DelimitedInsertsStreamResponseWriter implements InsertsStreamResponseWriter {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3OTY0OA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370579648", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:02:14Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the query response stream in delimited format.\n+ *\n+ * <p>The response comprises a sequence of elements, separated by newline. The overall response\n+ * does\n+ * not form a single JSON object or array. This makes it easier to parse at the client without\n+ * recourse to a streaming JSON parser.\n+ *\n+ * <p>The first entry in the response is a JSON object representing the metadata of the query.\n+ * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n+ * query).\n+ *\n+ * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n+ * returned by the query.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {\n+\n+  private final HttpServerResponse response;\n+\n+  public DelimitedQueryStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MDA4Mg==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370640082", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3OTY0OA=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\nindex b2f5a8d51e..2db1f179b7 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\n\n@@ -20,21 +20,7 @@ import io.vertx.core.json.JsonArray;\n import io.vertx.core.json.JsonObject;\n \n /**\n- * Writes the query response stream in delimited format.\n- *\n- * <p>The response comprises a sequence of elements, separated by newline. The overall response\n- * does\n- * not form a single JSON object or array. This makes it easier to parse at the client without\n- * recourse to a streaming JSON parser.\n- *\n- * <p>The first entry in the response is a JSON object representing the metadata of the query.\n- * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n- * query).\n- *\n- * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n- * returned by the query.\n- *\n- * <p>Please consult the API documentation for a full description of the format.\n+ * TODO show format with example\n  */\n public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MDAyNQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370580025", "bodyText": "would benefit from parameters being more strongly typed.  But assuming you'll be doing that in your Pojo PR?", "author": "big-andy-coates", "createdAt": "2020-01-24T11:03:17Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the query response stream in delimited format.\n+ *\n+ * <p>The response comprises a sequence of elements, separated by newline. The overall response\n+ * does\n+ * not form a single JSON object or array. This makes it easier to parse at the client without\n+ * recourse to a streaming JSON parser.\n+ *\n+ * <p>The first entry in the response is a JSON object representing the metadata of the query.\n+ * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n+ * query).\n+ *\n+ * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n+ * returned by the query.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {\n+\n+  private final HttpServerResponse response;\n+\n+  public DelimitedQueryStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;\n+  }\n+\n+  @Override\n+  public QueryStreamResponseWriter writeMetadata(final JsonObject metaData) {\n+    response.write(metaData.toBuffer().appendString(\"\\n\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public QueryStreamResponseWriter writeRow(final JsonArray row) {\n+    response.write(row.toBuffer().appendString(\"\\n\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public QueryStreamResponseWriter writeError(final JsonObject error) {", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\nindex b2f5a8d51e..2db1f179b7 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\n\n@@ -20,21 +20,7 @@ import io.vertx.core.json.JsonArray;\n import io.vertx.core.json.JsonObject;\n \n /**\n- * Writes the query response stream in delimited format.\n- *\n- * <p>The response comprises a sequence of elements, separated by newline. The overall response\n- * does\n- * not form a single JSON object or array. This makes it easier to parse at the client without\n- * recourse to a streaming JSON parser.\n- *\n- * <p>The first entry in the response is a JSON object representing the metadata of the query.\n- * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n- * query).\n- *\n- * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n- * returned by the query.\n- *\n- * <p>Please consult the API documentation for a full description of the format.\n+ * TODO show format with example\n  */\n public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MjQzMQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370582431", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:09:59Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.decodeJsonObject;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Map;\n+\n+/**\n+ * Handles requests to the query-stream endpoint\n+ */\n+public class QueryStreamHandler implements Handler<RoutingContext> {\n+\n+  static final String JSON_CONTENT_TYPE = \"application/json\";\n+  static final String DELIMITED_CONTENT_TYPE = \"application/vnd.ksqlapi.delimited.v1\";\n+\n+  private final Endpoints endpoints;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+\n+  public QueryStreamHandler(final Endpoints endpoints, final Server server,\n+      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n+    this.endpoints = endpoints;\n+    this.server = server;\n+    this.connectionsMap = connectionsMap;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MDc2MA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370640760", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MjQzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java\nindex 4b3f2bd3b3..f19e7a3807 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java\n\n@@ -22,28 +22,24 @@ import static io.confluent.ksql.api.server.ServerUtils.handleError;\n import io.confluent.ksql.api.spi.Endpoints;\n import io.confluent.ksql.api.spi.QueryPublisher;\n import io.vertx.core.Handler;\n-import io.vertx.core.http.HttpConnection;\n import io.vertx.core.json.JsonObject;\n import io.vertx.ext.web.RoutingContext;\n-import java.util.Map;\n+import java.util.Objects;\n \n /**\n  * Handles requests to the query-stream endpoint\n  */\n public class QueryStreamHandler implements Handler<RoutingContext> {\n \n-  static final String JSON_CONTENT_TYPE = \"application/json\";\n   static final String DELIMITED_CONTENT_TYPE = \"application/vnd.ksqlapi.delimited.v1\";\n \n   private final Endpoints endpoints;\n-  private final Server server;\n-  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+  private final ConnectionQueryManager connectionQueryManager;\n \n-  public QueryStreamHandler(final Endpoints endpoints, final Server server,\n-      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n-    this.endpoints = endpoints;\n-    this.server = server;\n-    this.connectionsMap = connectionsMap;\n+  public QueryStreamHandler(final Endpoints endpoints,\n+      final ConnectionQueryManager connectionQueryManager) {\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.connectionQueryManager = Objects.requireNonNull(connectionQueryManager);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MzI0MQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370583241", "bodyText": "connectionsMap is only used here. Could it not be a created by QueryStreamHandler, rather than created here and passed in.   Or do you envisage this state being used by others later?", "author": "big-andy-coates", "createdAt": "2020-01-24T11:12:07Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -85,123 +73,18 @@ public void stop(final Promise<Void> stopPromise) {\n \n   private Router setupRouter() {\n     final Router router = Router.router(vertx);\n-    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n-        .handler(this::handleQueryStream);\n-    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/query-stream\")\n+        .produces(\"application/vnd.ksqlapi.delimited.v1\")\n+        .produces(\"application/json\")\n+        .handler(BodyHandler.create())\n+        .handler(new QueryStreamHandler(endpoints, server, connectionsMap));", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MDg0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370640845", "bodyText": "refactored", "author": "purplefox", "createdAt": "2020-01-24T13:47:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MzI0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java\nindex ee87452b14..3bad817273 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java\n\n@@ -77,7 +75,7 @@ public class ServerVerticle extends AbstractVerticle {\n         .produces(\"application/vnd.ksqlapi.delimited.v1\")\n         .produces(\"application/json\")\n         .handler(BodyHandler.create())\n-        .handler(new QueryStreamHandler(endpoints, server, connectionsMap));\n+        .handler(new QueryStreamHandler(endpoints, server, connectionQueryManager));\n     router.route(HttpMethod.POST, \"/inserts-stream\")\n         .produces(\"application/vnd.ksqlapi.delimited.v1\")\n         .produces(\"application/json\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NDc2OA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370584768", "bodyText": "Consider using computeIfAbscent for this kind of operation, as it leads to less, and makes it easier to switch to concurrent/atomic types and operations in the future, if needed:\nfinal ConnectionQueries connectionQueries = connectionsMap\n        .computeIfAbsent(conn, k -> new ConnectionQueries(k, server, connectionsMap));```", "author": "big-andy-coates", "createdAt": "2020-01-24T11:16:35Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.decodeJsonObject;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Map;\n+\n+/**\n+ * Handles requests to the query-stream endpoint\n+ */\n+public class QueryStreamHandler implements Handler<RoutingContext> {\n+\n+  static final String JSON_CONTENT_TYPE = \"application/json\";\n+  static final String DELIMITED_CONTENT_TYPE = \"application/vnd.ksqlapi.delimited.v1\";\n+\n+  private final Endpoints endpoints;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+\n+  public QueryStreamHandler(final Endpoints endpoints, final Server server,\n+      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n+    this.endpoints = endpoints;\n+    this.server = server;\n+    this.connectionsMap = connectionsMap;\n+  }\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+\n+    final String contentType = routingContext.getAcceptableContentType();\n+    final QueryStreamResponseWriter queryStreamResponseWriter;\n+    if (DELIMITED_CONTENT_TYPE.equals(contentType) || contentType == null) {\n+      // Default\n+      queryStreamResponseWriter =\n+          new DelimitedQueryStreamResponseWriter(routingContext.response());\n+    } else {\n+      queryStreamResponseWriter = new JsonQueryStreamResponseWriter(routingContext.response());\n+    }\n+\n+    final JsonObject requestBody = decodeJsonObject(routingContext.getBody(), routingContext);\n+    if (requestBody == null) {\n+      return;\n+    }\n+    final String sql = requestBody.getString(\"sql\");\n+    if (sql == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No sql in arguments\");\n+      return;\n+    }\n+    final Boolean push = requestBody.getBoolean(\"push\");\n+    if (push == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No push in arguments\");\n+      return;\n+    }\n+    final JsonObject properties = requestBody.getJsonObject(\"properties\");\n+    final QueryPublisher queryPublisher = endpoints.createQueryPublisher(sql, push, properties);\n+\n+    final QuerySubscriber querySubscriber = new QuerySubscriber(routingContext.response(),\n+        queryStreamResponseWriter);\n+\n+    final HttpConnection conn = routingContext.request().connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn, server, connectionsMap);\n+      connectionsMap.put(conn, connectionQueries);\n+    }", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MTE0OA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370641148", "bodyText": "It's single threaded, imo I find the current a bit clearer", "author": "purplefox", "createdAt": "2020-01-24T13:48:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NDc2OA=="}], "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java\nindex 4b3f2bd3b3..f19e7a3807 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java\n\n@@ -22,28 +22,24 @@ import static io.confluent.ksql.api.server.ServerUtils.handleError;\n import io.confluent.ksql.api.spi.Endpoints;\n import io.confluent.ksql.api.spi.QueryPublisher;\n import io.vertx.core.Handler;\n-import io.vertx.core.http.HttpConnection;\n import io.vertx.core.json.JsonObject;\n import io.vertx.ext.web.RoutingContext;\n-import java.util.Map;\n+import java.util.Objects;\n \n /**\n  * Handles requests to the query-stream endpoint\n  */\n public class QueryStreamHandler implements Handler<RoutingContext> {\n \n-  static final String JSON_CONTENT_TYPE = \"application/json\";\n   static final String DELIMITED_CONTENT_TYPE = \"application/vnd.ksqlapi.delimited.v1\";\n \n   private final Endpoints endpoints;\n-  private final Server server;\n-  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+  private final ConnectionQueryManager connectionQueryManager;\n \n-  public QueryStreamHandler(final Endpoints endpoints, final Server server,\n-      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n-    this.endpoints = endpoints;\n-    this.server = server;\n-    this.connectionsMap = connectionsMap;\n+  public QueryStreamHandler(final Endpoints endpoints,\n+      final ConnectionQueryManager connectionQueryManager) {\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.connectionQueryManager = Objects.requireNonNull(connectionQueryManager);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NTUzNA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370585534", "bodyText": "consider having these flow methods return DelimitedQueryStreamResponseWriter, rather than the interface type.  This would, in the future, allow chaining of methods not on the interface.\nNot biggie though.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:18:46Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the query response stream in delimited format.\n+ *\n+ * <p>The response comprises a sequence of elements, separated by newline. The overall response\n+ * does\n+ * not form a single JSON object or array. This makes it easier to parse at the client without\n+ * recourse to a streaming JSON parser.\n+ *\n+ * <p>The first entry in the response is a JSON object representing the metadata of the query.\n+ * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n+ * query).\n+ *\n+ * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n+ * returned by the query.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {\n+\n+  private final HttpServerResponse response;\n+\n+  public DelimitedQueryStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;\n+  }\n+\n+  @Override\n+  public QueryStreamResponseWriter writeMetadata(final JsonObject metaData) {", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\nindex b2f5a8d51e..2db1f179b7 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\n\n@@ -20,21 +20,7 @@ import io.vertx.core.json.JsonArray;\n import io.vertx.core.json.JsonObject;\n \n /**\n- * Writes the query response stream in delimited format.\n- *\n- * <p>The response comprises a sequence of elements, separated by newline. The overall response\n- * does\n- * not form a single JSON object or array. This makes it easier to parse at the client without\n- * recourse to a streaming JSON parser.\n- *\n- * <p>The first entry in the response is a JSON object representing the metadata of the query.\n- * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n- * query).\n- *\n- * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n- * returned by the query.\n- *\n- * <p>Please consult the API documentation for a full description of the format.\n+ * TODO show format with example\n  */\n public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NjM3Nw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370586377", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:21:11Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java", "diffHunk": "@@ -38,39 +40,60 @@\n  * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n  * followed by a new-line.\n  */\n-public class InsertsBodyHandler {\n+public class InsertsStreamHandler implements Handler<RoutingContext> {\n \n   private final Context ctx;\n   private final Endpoints endpoints;\n-  private final RoutingContext routingContext;\n-  private final RecordParser recordParser;\n-  private boolean hasReadArguments;\n-  private BufferedPublisher<JsonObject> publisher;\n-  private long rowsReceived;\n-  private AcksSubscriber acksSubscriber;\n-\n-  public InsertsBodyHandler(final Context ctx, final Endpoints endpoints,\n-      final RoutingContext routingContext) {\n+\n+  public InsertsStreamHandler(final Context ctx, final Endpoints endpoints) {", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MTY3Mg==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370641672", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NjM3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java\nindex 9990891f5f..3c9461d7cf 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java\n\n@@ -46,7 +46,7 @@ public class InsertsStreamHandler implements Handler<RoutingContext> {\n   private final Endpoints endpoints;\n \n   public InsertsStreamHandler(final Context ctx, final Endpoints endpoints) {\n-    this.ctx = ctx;\n+    this.ctx = Objects.requireNonNull(ctx);\n     this.endpoints = Objects.requireNonNull(endpoints);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NjY0Nw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370586647", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:21:52Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java", "diffHunk": "@@ -38,39 +40,60 @@\n  * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n  * followed by a new-line.\n  */\n-public class InsertsBodyHandler {\n+public class InsertsStreamHandler implements Handler<RoutingContext> {\n \n   private final Context ctx;\n   private final Endpoints endpoints;\n-  private final RoutingContext routingContext;\n-  private final RecordParser recordParser;\n-  private boolean hasReadArguments;\n-  private BufferedPublisher<JsonObject> publisher;\n-  private long rowsReceived;\n-  private AcksSubscriber acksSubscriber;\n-\n-  public InsertsBodyHandler(final Context ctx, final Endpoints endpoints,\n-      final RoutingContext routingContext) {\n+\n+  public InsertsStreamHandler(final Context ctx, final Endpoints endpoints) {\n     this.ctx = ctx;\n     this.endpoints = Objects.requireNonNull(endpoints);\n-    this.routingContext = Objects.requireNonNull(routingContext);\n-    this.recordParser = RecordParser.newDelimited(\"\\n\", routingContext.request());\n   }\n \n-  public void handleBodyEnd(final Void v) {\n-    if (publisher != null) {\n-      publisher.complete();\n-      if (acksSubscriber == null) {\n-        routingContext.response().end();\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    // The record parser takes in potentially fragmented buffers from the request and spits\n+    // out the chunks delimited by \\n\n+    final RecordParser recordParser = RecordParser.newDelimited(\"\\n\", routingContext.request());\n+    final RequestHandler requestHandler = new RequestHandler(routingContext, recordParser);\n+    recordParser.handler(requestHandler::handleBodyBuffer);\n+    recordParser.endHandler(requestHandler::handleBodyEnd);\n+  }\n+\n+  private class RequestHandler {\n+\n+    private final RoutingContext routingContext;\n+    private final RecordParser recordParser;\n+    private final InsertsStreamResponseWriter insertsStreamResponseWriter;\n+    private boolean hasReadArguments;\n+    private BufferedPublisher<JsonObject> publisher;\n+    private long rowsReceived;\n+    private AcksSubscriber acksSubscriber;\n+\n+    RequestHandler(final RoutingContext routingContext,\n+        final RecordParser recordParser) {\n+      this.routingContext = routingContext;\n+      this.recordParser = recordParser;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MjA4OA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370642088", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:50:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NjY0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java\nindex 9990891f5f..3c9461d7cf 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java\n\n@@ -46,7 +46,7 @@ public class InsertsStreamHandler implements Handler<RoutingContext> {\n   private final Endpoints endpoints;\n \n   public InsertsStreamHandler(final Context ctx, final Endpoints endpoints) {\n-    this.ctx = ctx;\n+    this.ctx = Objects.requireNonNull(ctx);\n     this.endpoints = Objects.requireNonNull(endpoints);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NzM2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370587363", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:23:52Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the inserts response stream in JSON format.\n+ *\n+ * <p>The completed response will form a single JSON array, and each insert in the incoming stream\n+ * will have a corresponding entry in the response stream, in the same order as the inserts.\n+ *\n+ * <p>Providing the response as a single valid JSON array can make it easier to parse with some\n+ * clients. However this should be used with caution with very large responses when not using a\n+ * streaming JSON parser as the entire response will have to be stored in memory.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class JsonInsertsStreamResponseWriter implements InsertsStreamResponseWriter {\n+\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer();\n+\n+  protected final HttpServerResponse response;\n+  private boolean dataWritten;\n+\n+  public JsonInsertsStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MjE1Mw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370642153", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4NzM2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java\nindex 94d371daf8..c3c8698945 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java\n\n@@ -20,16 +20,7 @@ import io.vertx.core.http.HttpServerResponse;\n import io.vertx.core.json.JsonObject;\n \n /**\n- * Writes the inserts response stream in JSON format.\n- *\n- * <p>The completed response will form a single JSON array, and each insert in the incoming stream\n- * will have a corresponding entry in the response stream, in the same order as the inserts.\n- *\n- * <p>Providing the response as a single valid JSON array can make it easier to parse with some\n- * clients. However this should be used with caution with very large responses when not using a\n- * streaming JSON parser as the entire response will have to be stored in memory.\n- *\n- * <p>Please consult the API documentation for a full description of the format.\n+ * TODO show format with example\n  */\n public class JsonInsertsStreamResponseWriter implements InsertsStreamResponseWriter {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4ODI5NA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370588294", "bodyText": "Can we avoid the dup code? e.g. something like:\nprivate void writeBuffer(final Buffer buffer) {\n    final Buffer buff = dataWritten\n        ? Buffer.buffer().appendByte((byte) ',')\n        : Buffer.buffer().appendByte((byte) '[');\n\n    dataWritten = true;\n\n    buff.appendBuffer(buffer);\n    response.write(buff);\n  }", "author": "big-andy-coates", "createdAt": "2020-01-24T11:26:26Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the inserts response stream in JSON format.\n+ *\n+ * <p>The completed response will form a single JSON array, and each insert in the incoming stream\n+ * will have a corresponding entry in the response stream, in the same order as the inserts.\n+ *\n+ * <p>Providing the response as a single valid JSON array can make it easier to parse with some\n+ * clients. However this should be used with caution with very large responses when not using a\n+ * streaming JSON parser as the entire response will have to be stored in memory.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class JsonInsertsStreamResponseWriter implements InsertsStreamResponseWriter {\n+\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer();\n+\n+  protected final HttpServerResponse response;\n+  private boolean dataWritten;\n+\n+  public JsonInsertsStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;\n+  }\n+\n+  @Override\n+  public InsertsStreamResponseWriter writeInsertResponse() {\n+    writeBuffer(ACK_RESPONSE_LINE);\n+    return this;\n+  }\n+\n+  @Override\n+  public InsertsStreamResponseWriter writeError(final JsonObject error) {\n+    writeBuffer(error.toBuffer());\n+    return this;\n+  }\n+\n+  @Override\n+  public void end() {\n+    if (!dataWritten) {\n+      response.write(\"[]\").end();\n+    } else {\n+      response.write(\"]\").end();\n+    }\n+  }\n+\n+  private void writeBuffer(final Buffer buffer) {\n+    if (dataWritten) {\n+      final Buffer buff = Buffer.buffer().appendByte((byte) ',');\n+      buff.appendBuffer(buffer);\n+      response.write(buff);\n+    } else {\n+      final Buffer buff = Buffer.buffer().appendByte((byte) '[');\n+      buff.appendBuffer(buffer);\n+      response.write(buff);\n+      dataWritten = true;\n+    }\n+  }", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MjM2NA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370642364", "bodyText": "This will probably change during optimisation so don't want to make it too perfect yet", "author": "purplefox", "createdAt": "2020-01-24T13:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4ODI5NA=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java\nindex 94d371daf8..c3c8698945 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonInsertsStreamResponseWriter.java\n\n@@ -20,16 +20,7 @@ import io.vertx.core.http.HttpServerResponse;\n import io.vertx.core.json.JsonObject;\n \n /**\n- * Writes the inserts response stream in JSON format.\n- *\n- * <p>The completed response will form a single JSON array, and each insert in the incoming stream\n- * will have a corresponding entry in the response stream, in the same order as the inserts.\n- *\n- * <p>Providing the response as a single valid JSON array can make it easier to parse with some\n- * clients. However this should be used with caution with very large responses when not using a\n- * streaming JSON parser as the entire response will have to be stored in memory.\n- *\n- * <p>Please consult the API documentation for a full description of the format.\n+ * TODO show format with example\n  */\n public class JsonInsertsStreamResponseWriter implements InsertsStreamResponseWriter {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4ODM2Nw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370588367", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:26:37Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/JsonQueryStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the query response stream in JSON format.\n+ *\n+ * <p>The completed response will form a single JSON array.\n+ *\n+ * <p>Providing the response as a single valid JSON array can make it easier to parse with some\n+ * clients. However this should be used with caution with very large responses when not using a\n+ * streaming JSON parser as the entire response will have to be stored in memory.\n+ *\n+ * <p>The first entry in the array is a JSON object representing the metadata of the query.\n+ * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n+ * query).\n+ *\n+ * <p>Each subsequent entry in the array is a JSON array representing the values of the columns\n+ * returned by the query.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class JsonQueryStreamResponseWriter implements QueryStreamResponseWriter {\n+\n+  private final HttpServerResponse response;\n+\n+  public JsonQueryStreamResponseWriter(final HttpServerResponse response) {\n+    this.response = response;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MjQzNg==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370642436", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:50:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4ODM2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonQueryStreamResponseWriter.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonQueryStreamResponseWriter.java\nindex bd003619ff..b52be4dfde 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonQueryStreamResponseWriter.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/JsonQueryStreamResponseWriter.java\n\n@@ -21,22 +21,7 @@ import io.vertx.core.json.JsonArray;\n import io.vertx.core.json.JsonObject;\n \n /**\n- * Writes the query response stream in JSON format.\n- *\n- * <p>The completed response will form a single JSON array.\n- *\n- * <p>Providing the response as a single valid JSON array can make it easier to parse with some\n- * clients. However this should be used with caution with very large responses when not using a\n- * streaming JSON parser as the entire response will have to be stored in memory.\n- *\n- * <p>The first entry in the array is a JSON object representing the metadata of the query.\n- * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n- * query).\n- *\n- * <p>Each subsequent entry in the array is a JSON array representing the values of the columns\n- * returned by the query.\n- *\n- * <p>Please consult the API documentation for a full description of the format.\n+ * Show format with example\n  */\n public class JsonQueryStreamResponseWriter implements QueryStreamResponseWriter {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4OTAzNg==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370589036", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:28:26Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QuerySubscriber.java", "diffHunk": "@@ -35,13 +35,16 @@\n   private static final Logger log = LoggerFactory.getLogger(QuerySubscriber.class);\n \n   private final HttpServerResponse response;\n+  private final QueryStreamResponseWriter queryStreamResponseWriter;\n   private Subscription subscription;\n   private long tokens;\n \n   private static final int BATCH_SIZE = 4;\n \n-  public QuerySubscriber(final HttpServerResponse response) {\n-    this.response = Objects.requireNonNull(response);\n+  public QuerySubscriber(final HttpServerResponse response,\n+      final QueryStreamResponseWriter queryStreamResponseWriter) {\n+    this.response = response;\n+    this.queryStreamResponseWriter = queryStreamResponseWriter;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0Mjg1OQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370642859", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4OTAzNg=="}], "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/QuerySubscriber.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/QuerySubscriber.java\nindex 7462a69994..f55c4c51fe 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/QuerySubscriber.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/QuerySubscriber.java\n\n@@ -43,8 +43,8 @@ public class QuerySubscriber implements Subscriber<JsonArray> {\n \n   public QuerySubscriber(final HttpServerResponse response,\n       final QueryStreamResponseWriter queryStreamResponseWriter) {\n-    this.response = response;\n-    this.queryStreamResponseWriter = queryStreamResponseWriter;\n+    this.response = Objects.requireNonNull(response);\n+    this.queryStreamResponseWriter = Objects.requireNonNull(queryStreamResponseWriter);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4OTI5Nw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370589297", "bodyText": "I think removing ApiQueryId is a bad thing.  It helps disambiguate between it and other queryIds we have in the system.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:29:14Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -44,7 +44,7 @@\n   private final JsonObject config;\n   private final Endpoints endpoints;\n   private final HttpServerOptions httpServerOptions;\n-  private final Map<ApiQueryID, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Map<String, ApiQuery> queries = new ConcurrentHashMap<>();", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MjgxNg==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370642816", "bodyText": "ok", "author": "purplefox", "createdAt": "2020-01-24T13:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4OTI5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java\nindex 7d6b4b62bc..bcdb9cfca2 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java\n\n@@ -44,7 +44,7 @@ public class Server {\n   private final JsonObject config;\n   private final Endpoints endpoints;\n   private final HttpServerOptions httpServerOptions;\n-  private final Map<String, ApiQuery> queries = new ConcurrentHashMap<>();\n+  private final Map<ApiQueryID, ApiQuery> queries = new ConcurrentHashMap<>();\n   private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n   private String deploymentID;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4OTg0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370589845", "bodyText": "This method will currently return null if the queryId can not be found.\nIf this is expected, then better to encode the optionality into the return value, i.e. Optional<ApiQuery>, rather than relying on engineers checking the implementation to realize this is the case.\nAlternatively, if it not existing is an error, then consider throwing an exception.\nReturning nulls tends to lead to either null checks all over the code, or NPEs", "author": "big-andy-coates", "createdAt": "2020-01-24T11:30:51Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -93,22 +93,20 @@ public synchronized void stop() {\n     }\n   }\n \n-  ApiQueryID registerQuery(final QuerySubscriber querySubscriber) {\n-    Objects.requireNonNull(querySubscriber);\n-    final ApiQueryID queryID = new ApiQueryID();\n-    if (queries.putIfAbsent(queryID, querySubscriber) != null) {\n+  void registerQuery(final ApiQuery query) {\n+    Objects.requireNonNull(query);\n+    if (queries.putIfAbsent(query.getId(), query) != null) {\n       // It should never happen\n       // https://stackoverflow.com/questions/2513573/how-good-is-javas-uuid-randomuuid\n       throw new IllegalStateException(\"Glitch in the matrix\");\n     }\n-    return queryID;\n   }\n \n-  QuerySubscriber removeQuery(final ApiQueryID queryID) {\n+  ApiQuery removeQuery(final String queryID) {", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MzczOA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370643738", "bodyText": "Well. this is a wrapper around map.remove which returns null, I think that's a pretty standard api for this kind of thing.", "author": "purplefox", "createdAt": "2020-01-24T13:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4OTg0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java\nindex 7d6b4b62bc..bcdb9cfca2 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java\n\n@@ -102,11 +102,11 @@ public class Server {\n     }\n   }\n \n-  ApiQuery removeQuery(final String queryID) {\n+  ApiQuery removeQuery(final ApiQueryID queryID) {\n     return queries.remove(queryID);\n   }\n \n-  public Set<String> getQueryIDs() {\n+  public Set<ApiQueryID> getQueryIDs() {\n     return new HashSet<>(queries.keySet());\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5MDQ3OQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370590479", "bodyText": "Use of specific types here is much nicer :D", "author": "big-andy-coates", "createdAt": "2020-01-24T11:32:32Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -85,123 +73,18 @@ public void stop(final Promise<Void> stopPromise) {\n \n   private Router setupRouter() {\n     final Router router = Router.router(vertx);\n-    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n-        .handler(this::handleQueryStream);\n-    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/query-stream\")\n+        .produces(\"application/vnd.ksqlapi.delimited.v1\")\n+        .produces(\"application/json\")\n+        .handler(BodyHandler.create())\n+        .handler(new QueryStreamHandler(endpoints, server, connectionsMap));\n+    router.route(HttpMethod.POST, \"/inserts-stream\")\n+        .produces(\"application/vnd.ksqlapi.delimited.v1\")\n+        .produces(\"application/json\")\n+        .handler(new InsertsStreamHandler(context, endpoints));\n     router.route(HttpMethod.POST, \"/close-query\").handler(BodyHandler.create())\n-        .handler(this::handleCloseQuery);\n+        .handler(new CloseQueryHandler(server));", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java\nindex ee87452b14..3bad817273 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java\n\n@@ -77,7 +75,7 @@ public class ServerVerticle extends AbstractVerticle {\n         .produces(\"application/vnd.ksqlapi.delimited.v1\")\n         .produces(\"application/json\")\n         .handler(BodyHandler.create())\n-        .handler(new QueryStreamHandler(endpoints, server, connectionsMap));\n+        .handler(new QueryStreamHandler(endpoints, server, connectionQueryManager));\n     router.route(HttpMethod.POST, \"/inserts-stream\")\n         .produces(\"application/vnd.ksqlapi.delimited.v1\")\n         .produces(\"application/json\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5MzgwMw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370593803", "bodyText": "Unnecessary coupling to Server, QuerySubscriber and ConnectionQueries?\nSeems that this class could be decoupled from these types by having the QueryStreamHandler perform these two steps after constructing the ApiQuery:\n connectionQueries.addQuery(this);\n    server.registerQuery(this);\nAnd having ApiQuery constructor take a callback that will be called on close.  QueryStreamHandler can then pass in a lambda that does :\nconnectionQueries.removeQuery(this);\nserver.removeQuery(id);\n querySubscriber.close();\nWhich would result in less coupling (and more easily unit tested code)", "author": "big-andy-coates", "createdAt": "2020-01-24T11:42:08Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java", "diffHunk": "@@ -15,46 +15,39 @@\n \n package io.confluent.ksql.api.server;\n \n-import java.util.Objects;\n import java.util.UUID;\n \n /**\n- * Handle to a query that is passed to the client on query creation and can subsequently be used to\n- * close a query. Uses UUID.randomUUID() which internally uses SecureRandom - this makes the id\n+ * Holder for a push query running on the server.\n+ *\n+ * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n  * cryptographically secure. This is important as we don't want random users guessing query IDs and\n  * closing other peoples queries.\n  */\n-public final class ApiQueryID {\n+public class ApiQuery {\n \n+  private final Server server;\n   private final String id;\n+  private final ConnectionQueries connectionQueries;\n+  private final QuerySubscriber querySubscriber;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0NDE2Ng==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370644166", "bodyText": "I refactored this anyway", "author": "purplefox", "createdAt": "2020-01-24T13:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5MzgwMw=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java\nindex 5cde801fdb..48234b2ef5 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQuery.java\n\n@@ -15,26 +15,20 @@\n \n package io.confluent.ksql.api.server;\n \n-import java.util.UUID;\n-\n /**\n- * Holder for a push query running on the server.\n- *\n- * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n- * cryptographically secure. This is important as we don't want random users guessing query IDs and\n- * closing other peoples queries.\n+ * Holder for a push query running on the server\n  */\n public class ApiQuery {\n \n   private final Server server;\n-  private final String id;\n+  private final ApiQueryID id;\n   private final ConnectionQueries connectionQueries;\n   private final QuerySubscriber querySubscriber;\n \n   public ApiQuery(final Server server, final ConnectionQueries connectionQueries,\n       final QuerySubscriber querySubscriber) {\n     this.server = server;\n-    this.id = UUID.randomUUID().toString();\n+    this.id = new ApiQueryID();\n     this.connectionQueries = connectionQueries;\n     this.querySubscriber = querySubscriber;\n     connectionQueries.addQuery(this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5Mzk2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370593963", "bodyText": "nit: used.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:42:35Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.decodeJsonObject;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Map;\n+\n+/**\n+ * Handles requests to the query-stream endpoint\n+ */\n+public class QueryStreamHandler implements Handler<RoutingContext> {\n+\n+  static final String JSON_CONTENT_TYPE = \"application/json\";", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java\nindex 4b3f2bd3b3..f19e7a3807 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/QueryStreamHandler.java\n\n@@ -22,28 +22,24 @@ import static io.confluent.ksql.api.server.ServerUtils.handleError;\n import io.confluent.ksql.api.spi.Endpoints;\n import io.confluent.ksql.api.spi.QueryPublisher;\n import io.vertx.core.Handler;\n-import io.vertx.core.http.HttpConnection;\n import io.vertx.core.json.JsonObject;\n import io.vertx.ext.web.RoutingContext;\n-import java.util.Map;\n+import java.util.Objects;\n \n /**\n  * Handles requests to the query-stream endpoint\n  */\n public class QueryStreamHandler implements Handler<RoutingContext> {\n \n-  static final String JSON_CONTENT_TYPE = \"application/json\";\n   static final String DELIMITED_CONTENT_TYPE = \"application/vnd.ksqlapi.delimited.v1\";\n \n   private final Endpoints endpoints;\n-  private final Server server;\n-  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n+  private final ConnectionQueryManager connectionQueryManager;\n \n-  public QueryStreamHandler(final Endpoints endpoints, final Server server,\n-      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n-    this.endpoints = endpoints;\n-    this.server = server;\n-    this.connectionsMap = connectionsMap;\n+  public QueryStreamHandler(final Endpoints endpoints,\n+      final ConnectionQueryManager connectionQueryManager) {\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.connectionQueryManager = Objects.requireNonNull(connectionQueryManager);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5NjUzNA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370596534", "bodyText": "Do we really need to duplicate each response writer to have a delimited vs Json one?  two for queries, two for inserts, etc.\nWhy not have two classes that handle the JSON vs Delimited bit, and then compose that with one class for each type of response? e.g. to DelimitedQueryStreamResponseWriter you'd compose a DelimitedResponseWriter with a QueryStreamResponseWriter.\n(The DelimitedResponseWriter could be more of a DelimitedResponseFormatter or some such, rather than a ResponseRwriter.)", "author": "big-andy-coates", "createdAt": "2020-01-24T11:49:40Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * Writes the query response stream in delimited format.\n+ *\n+ * <p>The response comprises a sequence of elements, separated by newline. The overall response\n+ * does\n+ * not form a single JSON object or array. This makes it easier to parse at the client without\n+ * recourse to a streaming JSON parser.\n+ *\n+ * <p>The first entry in the response is a JSON object representing the metadata of the query.\n+ * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n+ * query).\n+ *\n+ * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n+ * returned by the query.\n+ *\n+ * <p>Please consult the API documentation for a full description of the format.\n+ */\n+public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY1NjU5Mw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370656593", "bodyText": "I think I'm going to leave this one for now", "author": "purplefox", "createdAt": "2020-01-24T14:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5NjUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwMjgyMA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370702820", "bodyText": "OK, np.", "author": "big-andy-coates", "createdAt": "2020-01-24T15:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5NjUzNA=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\nindex b2f5a8d51e..2db1f179b7 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/DelimitedQueryStreamResponseWriter.java\n\n@@ -20,21 +20,7 @@ import io.vertx.core.json.JsonArray;\n import io.vertx.core.json.JsonObject;\n \n /**\n- * Writes the query response stream in delimited format.\n- *\n- * <p>The response comprises a sequence of elements, separated by newline. The overall response\n- * does\n- * not form a single JSON object or array. This makes it easier to parse at the client without\n- * recourse to a streaming JSON parser.\n- *\n- * <p>The first entry in the response is a JSON object representing the metadata of the query.\n- * It contains the column names, column types, query ID, and number of rows (in the case of a pull\n- * query).\n- *\n- * <p>Each subsequent entry in the stream is a JSON array representing the values of the columns\n- * returned by the query.\n- *\n- * <p>Please consult the API documentation for a full description of the format.\n+ * TODO show format with example\n  */\n public class DelimitedQueryStreamResponseWriter implements QueryStreamResponseWriter {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5NzA4Mg==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370597082", "bodyText": "Unnecessary coupling.\nAs with ApiQuery, the calling code could be response for registering, and the constructor could take a callback thats called on close.  This would decouple the code better.", "author": "big-andy-coates", "createdAt": "2020-01-24T11:51:15Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpConnection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Keeps track of which queries are owned by which connection so we can close them when the\n+ * connection is closed\n+ */\n+public class ConnectionQueries implements Handler<Void> {\n+\n+  private final HttpConnection conn;\n+  private final Server server;", "originalCommit": "37bfe38df4f957e7db2a156167ffb2e217550e4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0NDgxOA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370644818", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T13:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5NzA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "8e6178aab9821fff844559d14831ca46967170da", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java\ndeleted file mode 100644\nindex d959d536fc..0000000000\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueries.java\n+++ /dev/null\n\n@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.api.server;\n-\n-import io.vertx.core.Handler;\n-import io.vertx.core.http.HttpConnection;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n- * Keeps track of which queries are owned by which connection so we can close them when the\n- * connection is closed\n- */\n-public class ConnectionQueries implements Handler<Void> {\n-\n-  private final HttpConnection conn;\n-  private final Server server;\n-  private final Map<HttpConnection, ConnectionQueries> connectionsMap;\n-\n-  private final Set<ApiQuery> queries = new HashSet<>();\n-\n-  public ConnectionQueries(final HttpConnection conn, final Server server,\n-      final Map<HttpConnection, ConnectionQueries> connectionsMap) {\n-    this.conn = conn;\n-    this.server = server;\n-    this.connectionsMap = connectionsMap;\n-    conn.closeHandler(this);\n-    server.registerQueryConnection(conn);\n-  }\n-\n-  public void addQuery(final ApiQuery query) {\n-    queries.add(query);\n-  }\n-\n-  public void removeQuery(final ApiQuery query) {\n-    queries.remove(query);\n-  }\n-\n-  @Override\n-  public void handle(final Void v) {\n-    for (ApiQuery query : queries) {\n-      query.close();\n-    }\n-    connectionsMap.remove(conn);\n-    server.removeQueryConnection(conn);\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5NDIzMg==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370694232", "bodyText": "We see this method in a lot of places. Shame Vert.x Context doesn't have a method that does this ;) e.g. context.throwIfDifferentContext().\nI guess we could have a VertxUtils class that had this as a util method. I know its only small, but maybe worth it.", "author": "big-andy-coates", "createdAt": "2020-01-24T15:31:42Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Context;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerRequest;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ConnectionQueryManager {\n+\n+  private final Context context;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+\n+  public ConnectionQueryManager(final Context context, final Server server) {\n+    this.context = Objects.requireNonNull(context);\n+    this.server = Objects.requireNonNull(server);\n+  }\n+\n+  public PushQueryHolder createApiQuery(final QuerySubscriber querySubscriber,\n+      final HttpServerRequest request) {\n+    checkContext();\n+    final ConnectionQueries connectionQueries = getConnectionQueries(request);\n+    final PushQueryHolder query = new PushQueryHolder(server, querySubscriber,\n+        connectionQueries::removeQuery);\n+    connectionQueries.addQuery(query);\n+    return query;\n+  }\n+\n+  private ConnectionQueries getConnectionQueries(final HttpServerRequest request) {\n+    final HttpConnection conn = request.connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+    }\n+    return connectionQueries;\n+  }\n+\n+  private void checkContext() {\n+    if (Vertx.currentContext() != context) {\n+      throw new IllegalStateException(\"On wrong context\");\n+    }\n+  }", "originalCommit": "3b6eb9047dc25136665851a72d567ca82fa71930", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java\ndeleted file mode 100644\nindex 49d07d9149..0000000000\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java\n+++ /dev/null\n\n@@ -1,98 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.api.server;\n-\n-import io.vertx.core.Context;\n-import io.vertx.core.Handler;\n-import io.vertx.core.Vertx;\n-import io.vertx.core.http.HttpConnection;\n-import io.vertx.core.http.HttpServerRequest;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-public class ConnectionQueryManager {\n-\n-  private final Context context;\n-  private final Server server;\n-  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n-\n-  public ConnectionQueryManager(final Context context, final Server server) {\n-    this.context = Objects.requireNonNull(context);\n-    this.server = Objects.requireNonNull(server);\n-  }\n-\n-  public PushQueryHolder createApiQuery(final QuerySubscriber querySubscriber,\n-      final HttpServerRequest request) {\n-    checkContext();\n-    final ConnectionQueries connectionQueries = getConnectionQueries(request);\n-    final PushQueryHolder query = new PushQueryHolder(server, querySubscriber,\n-        connectionQueries::removeQuery);\n-    connectionQueries.addQuery(query);\n-    return query;\n-  }\n-\n-  private ConnectionQueries getConnectionQueries(final HttpServerRequest request) {\n-    final HttpConnection conn = request.connection();\n-    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n-    if (connectionQueries == null) {\n-      connectionQueries = new ConnectionQueries(conn);\n-      connectionsMap.put(conn, connectionQueries);\n-    }\n-    return connectionQueries;\n-  }\n-\n-  private void checkContext() {\n-    if (Vertx.currentContext() != context) {\n-      throw new IllegalStateException(\"On wrong context\");\n-    }\n-  }\n-\n-  private class ConnectionQueries implements Handler<Void> {\n-\n-    private final HttpConnection conn;\n-    private final Set<PushQueryHolder> queries = new HashSet<>();\n-\n-    ConnectionQueries(final HttpConnection conn) {\n-      this.conn = conn;\n-      conn.closeHandler(this);\n-      server.registerQueryConnection(conn);\n-    }\n-\n-    void addQuery(final PushQueryHolder query) {\n-      checkContext();\n-      queries.add(Objects.requireNonNull(query));\n-    }\n-\n-    void removeQuery(final PushQueryHolder query) {\n-      checkContext();\n-      queries.remove(Objects.requireNonNull(query));\n-    }\n-\n-    @Override\n-    public void handle(final Void v) {\n-      checkContext();\n-      for (PushQueryHolder query : queries) {\n-        query.close();\n-      }\n-      connectionsMap.remove(conn);\n-      server.removeQueryConnection(conn);\n-    }\n-  }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5NDQ4Nw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370694487", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T15:32:09Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryId.java", "diffHunk": "@@ -16,24 +16,21 @@\n package io.confluent.ksql.api.server;\n \n import java.util.Objects;\n-import java.util.UUID;\n \n /**\n- * Handle to a query that is passed to the client on query creation and can subsequently be used to\n- * close a query. Uses UUID.randomUUID() which internally uses SecureRandom - this makes the id\n- * cryptographically secure. This is important as we don't want random users guessing query IDs and\n- * closing other peoples queries.\n+ * Surprisingly, the id of a push query\n  */\n-public final class ApiQueryID {\n+public class PushQueryId {\n \n   private final String id;\n \n-  public ApiQueryID() {\n-    this.id = UUID.randomUUID().toString();\n+  public PushQueryId(final String id) {\n+    this.id = id;", "originalCommit": "3b6eb9047dc25136665851a72d567ca82fa71930", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDczOTQ4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370739489", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-24T16:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5NDQ4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryId.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQueryID.java\nsimilarity index 60%\nrename from ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryId.java\nrename to ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQueryID.java\nindex 9c624c317d..383a27957c 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryId.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/ApiQueryID.java\n\n@@ -16,21 +16,24 @@\n package io.confluent.ksql.api.server;\n \n import java.util.Objects;\n+import java.util.UUID;\n \n /**\n- * Surprisingly, the id of a push query\n+ * Handle to a query that is passed to the client on query creation and can subsequently be used to\n+ * close a query. Uses UUID.randomUUID() which internally uses SecureRandom - this makes the id\n+ * cryptographically secure. This is important as we don't want random users guessing query IDs and\n+ * closing other peoples queries.\n  */\n-public class PushQueryId {\n+public final class ApiQueryID {\n \n   private final String id;\n \n-  public PushQueryId(final String id) {\n-    this.id = id;\n+  public ApiQueryID() {\n+    this.id = UUID.randomUUID().toString();\n   }\n \n-  @Override\n-  public String toString() {\n-    return id;\n+  public ApiQueryID(final String id) {\n+    this.id = Objects.requireNonNull(id);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5NjM1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370696351", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-24T15:35:47Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Context;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerRequest;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ConnectionQueryManager {\n+\n+  private final Context context;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+\n+  public ConnectionQueryManager(final Context context, final Server server) {\n+    this.context = Objects.requireNonNull(context);\n+    this.server = Objects.requireNonNull(server);\n+  }\n+\n+  public PushQueryHolder createApiQuery(final QuerySubscriber querySubscriber,\n+      final HttpServerRequest request) {\n+    checkContext();\n+    final ConnectionQueries connectionQueries = getConnectionQueries(request);\n+    final PushQueryHolder query = new PushQueryHolder(server, querySubscriber,\n+        connectionQueries::removeQuery);\n+    connectionQueries.addQuery(query);\n+    return query;\n+  }\n+\n+  private ConnectionQueries getConnectionQueries(final HttpServerRequest request) {\n+    final HttpConnection conn = request.connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+    }\n+    return connectionQueries;\n+  }\n+\n+  private void checkContext() {\n+    if (Vertx.currentContext() != context) {\n+      throw new IllegalStateException(\"On wrong context\");\n+    }\n+  }\n+\n+  private class ConnectionQueries implements Handler<Void> {\n+\n+    private final HttpConnection conn;\n+    private final Set<PushQueryHolder> queries = new HashSet<>();\n+\n+    ConnectionQueries(final HttpConnection conn) {\n+      this.conn = conn;", "originalCommit": "3b6eb9047dc25136665851a72d567ca82fa71930", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java\ndeleted file mode 100644\nindex 49d07d9149..0000000000\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java\n+++ /dev/null\n\n@@ -1,98 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.api.server;\n-\n-import io.vertx.core.Context;\n-import io.vertx.core.Handler;\n-import io.vertx.core.Vertx;\n-import io.vertx.core.http.HttpConnection;\n-import io.vertx.core.http.HttpServerRequest;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-public class ConnectionQueryManager {\n-\n-  private final Context context;\n-  private final Server server;\n-  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n-\n-  public ConnectionQueryManager(final Context context, final Server server) {\n-    this.context = Objects.requireNonNull(context);\n-    this.server = Objects.requireNonNull(server);\n-  }\n-\n-  public PushQueryHolder createApiQuery(final QuerySubscriber querySubscriber,\n-      final HttpServerRequest request) {\n-    checkContext();\n-    final ConnectionQueries connectionQueries = getConnectionQueries(request);\n-    final PushQueryHolder query = new PushQueryHolder(server, querySubscriber,\n-        connectionQueries::removeQuery);\n-    connectionQueries.addQuery(query);\n-    return query;\n-  }\n-\n-  private ConnectionQueries getConnectionQueries(final HttpServerRequest request) {\n-    final HttpConnection conn = request.connection();\n-    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n-    if (connectionQueries == null) {\n-      connectionQueries = new ConnectionQueries(conn);\n-      connectionsMap.put(conn, connectionQueries);\n-    }\n-    return connectionQueries;\n-  }\n-\n-  private void checkContext() {\n-    if (Vertx.currentContext() != context) {\n-      throw new IllegalStateException(\"On wrong context\");\n-    }\n-  }\n-\n-  private class ConnectionQueries implements Handler<Void> {\n-\n-    private final HttpConnection conn;\n-    private final Set<PushQueryHolder> queries = new HashSet<>();\n-\n-    ConnectionQueries(final HttpConnection conn) {\n-      this.conn = conn;\n-      conn.closeHandler(this);\n-      server.registerQueryConnection(conn);\n-    }\n-\n-    void addQuery(final PushQueryHolder query) {\n-      checkContext();\n-      queries.add(Objects.requireNonNull(query));\n-    }\n-\n-    void removeQuery(final PushQueryHolder query) {\n-      checkContext();\n-      queries.remove(Objects.requireNonNull(query));\n-    }\n-\n-    @Override\n-    public void handle(final Void v) {\n-      checkContext();\n-      for (PushQueryHolder query : queries) {\n-        query.close();\n-      }\n-      connectionsMap.remove(conn);\n-      server.removeQueryConnection(conn);\n-    }\n-  }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5ODE4NA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370698184", "bodyText": "FYI, with reference to #4376 (comment), using computeIfAbsent does only a single lookup into the map, where as this code does two: one in get and one in put.\nBit surprised you prefer the more verbose / old-school approach, rather than making use of the newer features of the language, given you're the one pushing for using a more modern JDK version :p", "author": "big-andy-coates", "createdAt": "2020-01-24T15:39:13Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Context;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerRequest;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ConnectionQueryManager {\n+\n+  private final Context context;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+\n+  public ConnectionQueryManager(final Context context, final Server server) {\n+    this.context = Objects.requireNonNull(context);\n+    this.server = Objects.requireNonNull(server);\n+  }\n+\n+  public PushQueryHolder createApiQuery(final QuerySubscriber querySubscriber,\n+      final HttpServerRequest request) {\n+    checkContext();\n+    final ConnectionQueries connectionQueries = getConnectionQueries(request);\n+    final PushQueryHolder query = new PushQueryHolder(server, querySubscriber,\n+        connectionQueries::removeQuery);\n+    connectionQueries.addQuery(query);\n+    return query;\n+  }\n+\n+  private ConnectionQueries getConnectionQueries(final HttpServerRequest request) {\n+    final HttpConnection conn = request.connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+    }", "originalCommit": "3b6eb9047dc25136665851a72d567ca82fa71930", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0MTMyOA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370741328", "bodyText": "It's just that if I was to use computeIfAbsent I would probably spend at least 30 seconds looking up the API to figure out what to pass it, whereas with this I can knock it out from memory in about 5 seconds. Yes, I'm old school ;)", "author": "purplefox", "createdAt": "2020-01-24T17:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5ODE4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyMTExNQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r371021115", "bodyText": "Spending 30 seconds now will pay dividends in the future.", "author": "big-andy-coates", "createdAt": "2020-01-26T18:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5ODE4NA=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java\ndeleted file mode 100644\nindex 49d07d9149..0000000000\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java\n+++ /dev/null\n\n@@ -1,98 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.api.server;\n-\n-import io.vertx.core.Context;\n-import io.vertx.core.Handler;\n-import io.vertx.core.Vertx;\n-import io.vertx.core.http.HttpConnection;\n-import io.vertx.core.http.HttpServerRequest;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-public class ConnectionQueryManager {\n-\n-  private final Context context;\n-  private final Server server;\n-  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n-\n-  public ConnectionQueryManager(final Context context, final Server server) {\n-    this.context = Objects.requireNonNull(context);\n-    this.server = Objects.requireNonNull(server);\n-  }\n-\n-  public PushQueryHolder createApiQuery(final QuerySubscriber querySubscriber,\n-      final HttpServerRequest request) {\n-    checkContext();\n-    final ConnectionQueries connectionQueries = getConnectionQueries(request);\n-    final PushQueryHolder query = new PushQueryHolder(server, querySubscriber,\n-        connectionQueries::removeQuery);\n-    connectionQueries.addQuery(query);\n-    return query;\n-  }\n-\n-  private ConnectionQueries getConnectionQueries(final HttpServerRequest request) {\n-    final HttpConnection conn = request.connection();\n-    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n-    if (connectionQueries == null) {\n-      connectionQueries = new ConnectionQueries(conn);\n-      connectionsMap.put(conn, connectionQueries);\n-    }\n-    return connectionQueries;\n-  }\n-\n-  private void checkContext() {\n-    if (Vertx.currentContext() != context) {\n-      throw new IllegalStateException(\"On wrong context\");\n-    }\n-  }\n-\n-  private class ConnectionQueries implements Handler<Void> {\n-\n-    private final HttpConnection conn;\n-    private final Set<PushQueryHolder> queries = new HashSet<>();\n-\n-    ConnectionQueries(final HttpConnection conn) {\n-      this.conn = conn;\n-      conn.closeHandler(this);\n-      server.registerQueryConnection(conn);\n-    }\n-\n-    void addQuery(final PushQueryHolder query) {\n-      checkContext();\n-      queries.add(Objects.requireNonNull(query));\n-    }\n-\n-    void removeQuery(final PushQueryHolder query) {\n-      checkContext();\n-      queries.remove(Objects.requireNonNull(query));\n-    }\n-\n-    @Override\n-    public void handle(final Void v) {\n-      checkContext();\n-      for (PushQueryHolder query : queries) {\n-        query.close();\n-      }\n-      connectionsMap.remove(conn);\n-      server.removeQueryConnection(conn);\n-    }\n-  }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5ODM2NQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370698365", "bodyText": "IMHO this is a lot better - thanks!", "author": "big-andy-coates", "createdAt": "2020-01-24T15:39:37Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Context;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerRequest;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ConnectionQueryManager {", "originalCommit": "3b6eb9047dc25136665851a72d567ca82fa71930", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java\ndeleted file mode 100644\nindex 49d07d9149..0000000000\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ConnectionQueryManager.java\n+++ /dev/null\n\n@@ -1,98 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.api.server;\n-\n-import io.vertx.core.Context;\n-import io.vertx.core.Handler;\n-import io.vertx.core.Vertx;\n-import io.vertx.core.http.HttpConnection;\n-import io.vertx.core.http.HttpServerRequest;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-public class ConnectionQueryManager {\n-\n-  private final Context context;\n-  private final Server server;\n-  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n-\n-  public ConnectionQueryManager(final Context context, final Server server) {\n-    this.context = Objects.requireNonNull(context);\n-    this.server = Objects.requireNonNull(server);\n-  }\n-\n-  public PushQueryHolder createApiQuery(final QuerySubscriber querySubscriber,\n-      final HttpServerRequest request) {\n-    checkContext();\n-    final ConnectionQueries connectionQueries = getConnectionQueries(request);\n-    final PushQueryHolder query = new PushQueryHolder(server, querySubscriber,\n-        connectionQueries::removeQuery);\n-    connectionQueries.addQuery(query);\n-    return query;\n-  }\n-\n-  private ConnectionQueries getConnectionQueries(final HttpServerRequest request) {\n-    final HttpConnection conn = request.connection();\n-    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n-    if (connectionQueries == null) {\n-      connectionQueries = new ConnectionQueries(conn);\n-      connectionsMap.put(conn, connectionQueries);\n-    }\n-    return connectionQueries;\n-  }\n-\n-  private void checkContext() {\n-    if (Vertx.currentContext() != context) {\n-      throw new IllegalStateException(\"On wrong context\");\n-    }\n-  }\n-\n-  private class ConnectionQueries implements Handler<Void> {\n-\n-    private final HttpConnection conn;\n-    private final Set<PushQueryHolder> queries = new HashSet<>();\n-\n-    ConnectionQueries(final HttpConnection conn) {\n-      this.conn = conn;\n-      conn.closeHandler(this);\n-      server.registerQueryConnection(conn);\n-    }\n-\n-    void addQuery(final PushQueryHolder query) {\n-      checkContext();\n-      queries.add(Objects.requireNonNull(query));\n-    }\n-\n-    void removeQuery(final PushQueryHolder query) {\n-      checkContext();\n-      queries.remove(Objects.requireNonNull(query));\n-    }\n-\n-    @Override\n-    public void handle(final Void v) {\n-      checkContext();\n-      for (PushQueryHolder query : queries) {\n-        query.close();\n-      }\n-      connectionsMap.remove(conn);\n-      server.removeQueryConnection(conn);\n-    }\n-  }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5OTM3Nw==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370699377", "bodyText": "Can the querySubscriber.close() call not be part of the closeHandler call?", "author": "big-andy-coates", "createdAt": "2020-01-24T15:41:31Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryHolder.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Holder for a push query running on the server.\n+ *\n+ * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n+ * cryptographically secure. This is important as we don't want random users guessing query IDs and\n+ * closing other peoples queries.\n+ */\n+public class PushQueryHolder {\n+\n+  private final Server server;\n+  private final PushQueryId id;\n+  private final QuerySubscriber querySubscriber;\n+  private final Consumer<PushQueryHolder> closeHandler;\n+\n+  PushQueryHolder(final Server server, final QuerySubscriber querySubscriber,\n+      final Consumer<PushQueryHolder> closeHandler) {\n+    this.server = Objects.requireNonNull(server);\n+    this.querySubscriber = Objects.requireNonNull(querySubscriber);\n+    this.closeHandler = Objects.requireNonNull(closeHandler);\n+    this.id = new PushQueryId(UUID.randomUUID().toString());\n+    server.registerQuery(this);\n+  }\n+\n+  public void close() {\n+    server.removeQuery(id);\n+    querySubscriber.close();\n+    closeHandler.accept(this);", "originalCommit": "3b6eb9047dc25136665851a72d567ca82fa71930", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryHolder.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryHolder.java\ndeleted file mode 100644\nindex bcc24e2a3a..0000000000\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryHolder.java\n+++ /dev/null\n\n@@ -1,54 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.api.server;\n-\n-import java.util.Objects;\n-import java.util.UUID;\n-import java.util.function.Consumer;\n-\n-/**\n- * Holder for a push query running on the server.\n- *\n- * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n- * cryptographically secure. This is important as we don't want random users guessing query IDs and\n- * closing other peoples queries.\n- */\n-public class PushQueryHolder {\n-\n-  private final Server server;\n-  private final PushQueryId id;\n-  private final QuerySubscriber querySubscriber;\n-  private final Consumer<PushQueryHolder> closeHandler;\n-\n-  PushQueryHolder(final Server server, final QuerySubscriber querySubscriber,\n-      final Consumer<PushQueryHolder> closeHandler) {\n-    this.server = Objects.requireNonNull(server);\n-    this.querySubscriber = Objects.requireNonNull(querySubscriber);\n-    this.closeHandler = Objects.requireNonNull(closeHandler);\n-    this.id = new PushQueryId(UUID.randomUUID().toString());\n-    server.registerQuery(this);\n-  }\n-\n-  public void close() {\n-    server.removeQuery(id);\n-    querySubscriber.close();\n-    closeHandler.accept(this);\n-  }\n-\n-  public PushQueryId getId() {\n-    return id;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5OTU2OQ==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370699569", "bodyText": "consider having the caller do this call, decoupling this class from Server.", "author": "big-andy-coates", "createdAt": "2020-01-24T15:41:50Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryHolder.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Holder for a push query running on the server.\n+ *\n+ * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n+ * cryptographically secure. This is important as we don't want random users guessing query IDs and\n+ * closing other peoples queries.\n+ */\n+public class PushQueryHolder {\n+\n+  private final Server server;\n+  private final PushQueryId id;\n+  private final QuerySubscriber querySubscriber;\n+  private final Consumer<PushQueryHolder> closeHandler;\n+\n+  PushQueryHolder(final Server server, final QuerySubscriber querySubscriber,\n+      final Consumer<PushQueryHolder> closeHandler) {\n+    this.server = Objects.requireNonNull(server);\n+    this.querySubscriber = Objects.requireNonNull(querySubscriber);\n+    this.closeHandler = Objects.requireNonNull(closeHandler);\n+    this.id = new PushQueryId(UUID.randomUUID().toString());\n+    server.registerQuery(this);", "originalCommit": "3b6eb9047dc25136665851a72d567ca82fa71930", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryHolder.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryHolder.java\ndeleted file mode 100644\nindex bcc24e2a3a..0000000000\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/PushQueryHolder.java\n+++ /dev/null\n\n@@ -1,54 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.api.server;\n-\n-import java.util.Objects;\n-import java.util.UUID;\n-import java.util.function.Consumer;\n-\n-/**\n- * Holder for a push query running on the server.\n- *\n- * <p>Uses UUID.randomUUID() for the id which internally uses SecureRandom - this makes the id\n- * cryptographically secure. This is important as we don't want random users guessing query IDs and\n- * closing other peoples queries.\n- */\n-public class PushQueryHolder {\n-\n-  private final Server server;\n-  private final PushQueryId id;\n-  private final QuerySubscriber querySubscriber;\n-  private final Consumer<PushQueryHolder> closeHandler;\n-\n-  PushQueryHolder(final Server server, final QuerySubscriber querySubscriber,\n-      final Consumer<PushQueryHolder> closeHandler) {\n-    this.server = Objects.requireNonNull(server);\n-    this.querySubscriber = Objects.requireNonNull(querySubscriber);\n-    this.closeHandler = Objects.requireNonNull(closeHandler);\n-    this.id = new PushQueryId(UUID.randomUUID().toString());\n-    server.registerQuery(this);\n-  }\n-\n-  public void close() {\n-    server.removeQuery(id);\n-    querySubscriber.close();\n-    closeHandler.accept(this);\n-  }\n-\n-  public PushQueryId getId() {\n-    return id;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwMTg2NA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370701864", "bodyText": "QQ: does the use of BodyHandler here mean the user can't provide a stream of query requests, as its trying to \"gather the entire request body\"?", "author": "big-andy-coates", "createdAt": "2020-01-24T15:46:13Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -85,123 +71,18 @@ public void stop(final Promise<Void> stopPromise) {\n \n   private Router setupRouter() {\n     final Router router = Router.router(vertx);\n-    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n-        .handler(this::handleQueryStream);\n-    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/query-stream\")\n+        .produces(\"application/vnd.ksqlapi.delimited.v1\")\n+        .produces(\"application/json\")\n+        .handler(BodyHandler.create())", "originalCommit": "3b6eb9047dc25136665851a72d567ca82fa71930", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0NTEzNA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370745134", "bodyText": "Yes, BodyHandler gathers up the entire request body as a single buffer.", "author": "purplefox", "createdAt": "2020-01-24T17:12:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwMTg2NA=="}], "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java\nindex 3bad817273..ee87452b14 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java\n\n@@ -75,7 +77,7 @@ public class ServerVerticle extends AbstractVerticle {\n         .produces(\"application/vnd.ksqlapi.delimited.v1\")\n         .produces(\"application/json\")\n         .handler(BodyHandler.create())\n-        .handler(new QueryStreamHandler(endpoints, server, connectionQueryManager));\n+        .handler(new QueryStreamHandler(endpoints, server, connectionsMap));\n     router.route(HttpMethod.POST, \"/inserts-stream\")\n         .produces(\"application/vnd.ksqlapi.delimited.v1\")\n         .produces(\"application/json\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwNjAzOA==", "url": "https://github.com/confluentinc/ksql/pull/4376#discussion_r370706038", "bodyText": "with reference to this comment: #4376 (comment)\nWe really do try and avoid returning nulls in the code by encoding optionality into the type system.  Please use Optional. Pretty please?", "author": "big-andy-coates", "createdAt": "2020-01-24T15:53:50Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -93,22 +93,20 @@ public synchronized void stop() {\n     }\n   }\n \n-  ApiQueryID registerQuery(final QuerySubscriber querySubscriber) {\n-    Objects.requireNonNull(querySubscriber);\n-    final ApiQueryID queryID = new ApiQueryID();\n-    if (queries.putIfAbsent(queryID, querySubscriber) != null) {\n+  void registerQuery(final PushQueryHolder query) {\n+    Objects.requireNonNull(query);\n+    if (queries.putIfAbsent(query.getId(), query) != null) {\n       // It should never happen\n       // https://stackoverflow.com/questions/2513573/how-good-is-javas-uuid-randomuuid\n       throw new IllegalStateException(\"Glitch in the matrix\");\n     }\n-    return queryID;\n   }\n \n-  QuerySubscriber removeQuery(final ApiQueryID queryID) {\n-    return queries.remove(queryID);\n+  PushQueryHolder removeQuery(final PushQueryId queryId) {\n+    return queries.remove(queryId);", "originalCommit": "3b6eb9047dc25136665851a72d567ca82fa71930", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java\nindex 666b304383..bcdb9cfca2 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java\n\n@@ -93,7 +93,7 @@ public class Server {\n     }\n   }\n \n-  void registerQuery(final PushQueryHolder query) {\n+  void registerQuery(final ApiQuery query) {\n     Objects.requireNonNull(query);\n     if (queries.putIfAbsent(query.getId(), query) != null) {\n       // It should never happen\n"}}, {"oid": "bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "url": "https://github.com/confluentinc/ksql/commit/bd85cb684df3ab8f7a3aa05bdba2779dd36ccfd0", "message": "Factor different endpoints into their own handler classes and abstract out the writing of responses. Support both JSON and delimited response format", "committedDate": "2020-01-24T18:08:41Z", "type": "commit"}, {"oid": "5b77c75c0182a56d11e7588a36a52b695fa50b99", "url": "https://github.com/confluentinc/ksql/commit/5b77c75c0182a56d11e7588a36a52b695fa50b99", "message": "More refactoring + more javadoc", "committedDate": "2020-01-24T18:08:41Z", "type": "commit"}, {"oid": "8e6178aab9821fff844559d14831ca46967170da", "url": "https://github.com/confluentinc/ksql/commit/8e6178aab9821fff844559d14831ca46967170da", "message": "updates after review", "committedDate": "2020-01-24T18:08:41Z", "type": "commit"}, {"oid": "e4fdc0e723d613ef680ca354abdc1668294e4037", "url": "https://github.com/confluentinc/ksql/commit/e4fdc0e723d613ef680ca354abdc1668294e4037", "message": "updates after review", "committedDate": "2020-01-24T18:08:41Z", "type": "commit"}, {"oid": "e4fdc0e723d613ef680ca354abdc1668294e4037", "url": "https://github.com/confluentinc/ksql/commit/e4fdc0e723d613ef680ca354abdc1668294e4037", "message": "updates after review", "committedDate": "2020-01-24T18:08:41Z", "type": "forcePushed"}]}