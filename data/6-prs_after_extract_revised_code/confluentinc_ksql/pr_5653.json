{"pr_number": 5653, "pr_title": "test: Pull queries correctness tests", "pr_createdAt": "2020-06-19T16:56:45Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5653", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NDU5MQ==", "url": "https://github.com/confluentinc/ksql/pull/5653#discussion_r442984591", "bodyText": "I feel like it would be better to add a keyword to the query itself, like DEBUG instead of using a server config. This way, we have a control know per pull query and we can add more debug information in the future, like amount of lag, or routing information, etc.", "author": "vpapavas", "createdAt": "2020-06-19T18:19:40Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -215,6 +215,13 @@\n   public static final String KSQL_QUERY_PULL_MAX_QPS_DOC = \"The maximum qps allowed for pull \"\n       + \"queries. Once the limit is hit, queries will fail immediately\";\n \n+  public static final String KSQL_QUERY_PULL_SET_REPLYING_HOST_CONFIG =", "originalCommit": "017b125d99683436858e8bdd873b0b3f71a855f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MzU5NA==", "url": "https://github.com/confluentinc/ksql/pull/5653#discussion_r443053594", "bodyText": "Alright.  I was considering whether we wanted to expose this per request, but I guess that seems reasonable.  It's possible we might want to still allow this to have a server config, in case the server doesn't want to expose debug info, but that can be a followup", "author": "AlanConfluent", "createdAt": "2020-06-19T21:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NDU5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3fe1fee53181117886df9b776a69febc541e651e", "chunk": "diff --git a/ksqldb-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java b/ksqldb-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\nindex 0396124435..fd7a1fbc69 100644\n--- a/ksqldb-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n+++ b/ksqldb-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java\n\n@@ -215,13 +215,6 @@ public class KsqlConfig extends AbstractConfig {\n   public static final String KSQL_QUERY_PULL_MAX_QPS_DOC = \"The maximum qps allowed for pull \"\n       + \"queries. Once the limit is hit, queries will fail immediately\";\n \n-  public static final String KSQL_QUERY_PULL_SET_REPLYING_HOST_CONFIG =\n-      \"ksql.query.pull.set.responding.host\";\n-  public static final boolean KSQL_QUERY_PULL_SET_REPLYING_HOST_DEFAULT = false;\n-  public static final String KSQL_QUERY_PULL_SET_REPLYING_HOST_DOC = \"Controls whether the \"\n-      + \"header X-KSQL-Replying-Node is set with the endpoint of the replying node when responding \"\n-      + \"to a pull query.  This is useful for debugging network setup when deploying pull queries\";\n-\n   public static final Collection<CompatibilityBreakingConfigDef> COMPATIBLY_BREAKING_CONFIG_DEFS\n       = ImmutableList.of();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NjMwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5653#discussion_r442986301", "bodyText": "I think it makes sense to have a new type of response, that consists of the debug information and the list of rows. Basically, make it a class so that we can add more debug info in the future", "author": "vpapavas", "createdAt": "2020-06-19T18:23:46Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -102,14 +103,14 @@\n         .target(serverEndPoint)\n         .properties(configOverrides);\n \n-    final RestResponse<List<StreamedRow>> resp = getTarget(target, authHeader)\n+    final RestResponse<Pair<Optional<URI>, List<StreamedRow>>> resp = getTarget(target, authHeader)", "originalCommit": "017b125d99683436858e8bdd873b0b3f71a855f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NDQzOA==", "url": "https://github.com/confluentinc/ksql/pull/5653#discussion_r443054438", "bodyText": "I was debating whether to try to try to introduce a whole different response, which would be a backwards incompatible change.  I'm still up for doing that if you don't like my solution.  I ended up adding a new optional field to StreamedRow called sourceHost.  I think this actually makes sense when we introduce scatter-gather requests for non-key pull queries since each row can have a different sourceHost.  Tell me what you think.", "author": "AlanConfluent", "createdAt": "2020-06-19T21:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NjMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3ODI1Mg==", "url": "https://github.com/confluentinc/ksql/pull/5653#discussion_r443078252", "bodyText": "It shouldn't be backwards incompatible as we introduce a new feature, no? We won't change the response for regular pull queries, especially if we introduce a per request flag.", "author": "vpapavas", "createdAt": "2020-06-19T23:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NjMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA4MDkxNQ==", "url": "https://github.com/confluentinc/ksql/pull/5653#discussion_r443080915", "bodyText": "If we introduce a whole new endpoint (e.g. /query_debug), then we could change the request type and response, adding whatever new fields we want.  That seems not great since it would unnecessarily duplicate a lot of code.  And what if we introduce another mode?  We can't create the cross-product of flags, each as a new endpoint.  I would rather just have optional fields on json, where some are not set if not in debug mode, which is effectively what I did above.  The only issue is that /query returns an array of rows and it's not wrapped in anything.  If we wanted, we could wrap that in a response object where we could add fields, but I've held off on doing that now since I didn't require any non row-based fields.", "author": "AlanConfluent", "createdAt": "2020-06-19T23:58:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NjMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4NjcxNA==", "url": "https://github.com/confluentinc/ksql/pull/5653#discussion_r443886714", "bodyText": "The only issue is that /query returns an array of rows and it's not wrapped in anything. If we wanted, we could wrap that in a response object where we could add fields, but I've held off on doing that now since I didn't require any non row-based fields.\n\nThat's what I meant with my comment. It's fine if you want to leave it for another PR", "author": "vpapavas", "createdAt": "2020-06-22T23:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NjMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "3fe1fee53181117886df9b776a69febc541e651e", "chunk": "diff --git a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java\nindex c70f182c8e..630a8d8f3d 100644\n--- a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java\n+++ b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java\n\n@@ -103,7 +103,7 @@ final class DefaultKsqlClient implements SimpleKsqlClient {\n         .target(serverEndPoint)\n         .properties(configOverrides);\n \n-    final RestResponse<Pair<Optional<URI>, List<StreamedRow>>> resp = getTarget(target, authHeader)\n+    final RestResponse<Pair<URI, List<StreamedRow>>> resp = getTarget(target, authHeader)\n         .postQueryRequest(sql, requestProperties, Optional.empty());\n \n     if (resp.isErroneous()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4OTk4Nw==", "url": "https://github.com/confluentinc/ksql/pull/5653#discussion_r442989987", "bodyText": "This stops all incoming/outgoing traffic to simulate that a node is dead? Does it actually cause rebalancing?", "author": "vpapavas", "createdAt": "2020-06-19T18:33:08Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -480,5 +553,94 @@ private String extractQueryId(final String outputString) {\n     assertThat(\"Could not find query id in: \" + outputString, matcher.find());\n     return matcher.group(1);\n   }\n+\n+  public static class TestApp {\n+\n+    private final KsqlHostInfoEntity host;\n+    private final TestKsqlRestApp app;\n+    private final Shutoffs shutoffs;\n+\n+    public TestApp(KsqlHostInfoEntity host, TestKsqlRestApp app, Shutoffs shutoffs) {\n+      this.host = host;\n+      this.app = app;\n+      this.shutoffs = shutoffs;\n+    }\n+\n+    public KsqlHostInfoEntity getHost() {\n+      return host;\n+    }\n+\n+    public TestKsqlRestApp getApp() {\n+      return app;\n+    }\n+\n+    public Shutoffs getShutoffs() {\n+      return shutoffs;\n+    }\n+  }\n+\n+  public static class Shutoffs {\n+    private final AtomicBoolean ksqlOutgoing = new AtomicBoolean(false);\n+    private final AtomicBoolean kafkaIncoming = new AtomicBoolean(false);\n+\n+    public void shutOffAll() {", "originalCommit": "017b125d99683436858e8bdd873b0b3f71a855f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2NDkxMQ==", "url": "https://github.com/confluentinc/ksql/pull/5653#discussion_r443064911", "bodyText": "No, it doesn't technically stop all traffic to kafka.  I couldn't figure out a very simple way to do that.  My understanding given https://www.confluent.io/blog/cooperative-rebalancing-in-kafka-streams-consumer-ksqldb/ is that JoinGroup is another request type used to coordinate groups, which is different from consumption.\nWhile this test isn't 100% true to a production environment, I also didn't want a pause in the test to result in rebalancing and weird, unpredictable results.  Also, it's hard to both kill off a server, and know that it will take effect immediately.  You can call stop, which will potentially block a bit or you can run it in a background thread, in which case you don't know when it will take effect.\nFor that reason, I chose to simulate things in this way, but tell me if you disagree.", "author": "AlanConfluent", "createdAt": "2020-06-19T22:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4OTk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3OTU3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5653#discussion_r443079576", "bodyText": "Yes, that makes sense.\nI was trying to see if we can test everything using these functional tests and avoid creating cloud tests. But it seems, that if we cannot test the actual rebalancing and measure for example how long it takes for the heartbeat to find a host is down, how long it takes for pull queries to succeed at standby, find that routing correctly works after rebalancing completes (first go to standby, then go to new active) etc, we may still need to perform cloud tests.", "author": "vpapavas", "createdAt": "2020-06-19T23:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4OTk4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "3fe1fee53181117886df9b776a69febc541e651e", "chunk": "diff --git a/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java b/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\nindex 781963ddb8..19729f8a30 100644\n--- a/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n+++ b/ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java\n\n@@ -554,93 +557,8 @@ public class PullQueryRoutingFunctionalTest {\n     return matcher.group(1);\n   }\n \n-  public static class TestApp {\n-\n-    private final KsqlHostInfoEntity host;\n-    private final TestKsqlRestApp app;\n-    private final Shutoffs shutoffs;\n-\n-    public TestApp(KsqlHostInfoEntity host, TestKsqlRestApp app, Shutoffs shutoffs) {\n-      this.host = host;\n-      this.app = app;\n-      this.shutoffs = shutoffs;\n-    }\n-\n-    public KsqlHostInfoEntity getHost() {\n-      return host;\n-    }\n-\n-    public TestKsqlRestApp getApp() {\n-      return app;\n-    }\n-\n-    public Shutoffs getShutoffs() {\n-      return shutoffs;\n-    }\n-  }\n-\n-  public static class Shutoffs {\n-    private final AtomicBoolean ksqlOutgoing = new AtomicBoolean(false);\n-    private final AtomicBoolean kafkaIncoming = new AtomicBoolean(false);\n-\n-    public void shutOffAll() {\n-      ksqlOutgoing.set(true);\n-      kafkaIncoming.set(true);\n-    }\n-\n-    public void reset() {\n-      ksqlOutgoing.set(false);\n-      kafkaIncoming.set(false);\n-    }\n-  }\n-\n-  static boolean lagsExist(\n-      final KsqlHostInfoEntity remoteServer,\n-      final Map<KsqlHostInfoEntity, HostStatusEntity> clusterStatus\n-  ) {\n-    if (clusterStatus.size() == 3) {\n-      int numWithLag = 0;\n-      for (Map.Entry<KsqlHostInfoEntity, HostStatusEntity> e : clusterStatus.entrySet()) {\n-        if (e.getValue().getHostStoreLags().getStateStoreLags().size() > 0) {\n-          numWithLag++;\n-        }\n-      }\n-      if (numWithLag >= 2) {\n-        LOG.info(\"Found expected lags: {}\", clusterStatus.toString());\n-        return true;\n-      }\n-    }\n-    LOG.info(\"Didn't yet find expected lags: {}\", clusterStatus.toString());\n-    return false;\n-  }\n-\n-  static BiFunction<KsqlHostInfoEntity, Map<KsqlHostInfoEntity, HostStatusEntity>, Boolean>\n-  lagsExist(\n-      final KsqlHostInfoEntity server,\n-      final long endOffset\n-  ) {\n-    return (remote, clusterStatus) -> {\n-      if (clusterStatus.size() == 3) {\n-        HostStatusEntity hostStatusEntity = clusterStatus.get(server);\n-        if (hostStatusEntity == null) {\n-          LOG.info(\"Didn't find {}\", server.toString());\n-          return false;\n-        }\n-        long end = hostStatusEntity.getHostStoreLags().getStateStoreLags().values().stream()\n-            .flatMap(stateStoreLags -> stateStoreLags.getLagByPartition().values().stream())\n-            .mapToLong(LagInfoEntity::getEndOffsetPosition)\n-            .max()\n-            .orElse(0);\n-        if (end >= endOffset) {\n-          LOG.info(\"Found expected end offset {} for {}: {}\", endOffset, server,\n-              clusterStatus.toString());\n-          return true;\n-        }\n-      }\n-      LOG.info(\"Didn't yet find expected end offset {} for {}: {}\", endOffset, server,\n-          clusterStatus.toString());\n-      return false;\n-    };\n-  }\n+  public static class KafkaInterceptor0<K, V> extends KafkaInterceptor<K, V> {}\n+  public static class KafkaInterceptor1<K, V> extends KafkaInterceptor<K, V> {}\n+  public static class KafkaInterceptor2<K, V> extends KafkaInterceptor<K, V> {}\n }\n \n"}}, {"oid": "3fe1fee53181117886df9b776a69febc541e651e", "url": "https://github.com/confluentinc/ksql/commit/3fe1fee53181117886df9b776a69febc541e651e", "message": "pull queries correctness test", "committedDate": "2020-06-29T23:13:10Z", "type": "commit"}, {"oid": "e256953f704b4379c3ba7bc10d3c0018351a354c", "url": "https://github.com/confluentinc/ksql/commit/e256953f704b4379c3ba7bc10d3c0018351a354c", "message": "Gets everything working", "committedDate": "2020-06-29T23:13:11Z", "type": "commit"}, {"oid": "941a2c351884f7a6a834d68b97d44d9f4fb3e611", "url": "https://github.com/confluentinc/ksql/commit/941a2c351884f7a6a834d68b97d44d9f4fb3e611", "message": "Gets things in better order", "committedDate": "2020-06-29T23:13:11Z", "type": "commit"}, {"oid": "b49132d016c8d4fb32fbb775f186a00809b33f55", "url": "https://github.com/confluentinc/ksql/commit/b49132d016c8d4fb32fbb775f186a00809b33f55", "message": "Fix lint errors", "committedDate": "2020-06-29T23:13:12Z", "type": "commit"}, {"oid": "e70c3544da4ef4675821405291f6c6969ded21a8", "url": "https://github.com/confluentinc/ksql/commit/e70c3544da4ef4675821405291f6c6969ded21a8", "message": "Remove log", "committedDate": "2020-06-29T23:13:12Z", "type": "commit"}, {"oid": "1ce5c03ba9b5a969bdab1a0bb84fe87b26de79fd", "url": "https://github.com/confluentinc/ksql/commit/1ce5c03ba9b5a969bdab1a0bb84fe87b26de79fd", "message": "Feedback", "committedDate": "2020-06-29T23:14:57Z", "type": "commit"}, {"oid": "1ce5c03ba9b5a969bdab1a0bb84fe87b26de79fd", "url": "https://github.com/confluentinc/ksql/commit/1ce5c03ba9b5a969bdab1a0bb84fe87b26de79fd", "message": "Feedback", "committedDate": "2020-06-29T23:14:57Z", "type": "forcePushed"}, {"oid": "af015f48f917f922926a77f4e794e3faae0bbb56", "url": "https://github.com/confluentinc/ksql/commit/af015f48f917f922926a77f4e794e3faae0bbb56", "message": "Bad merge", "committedDate": "2020-06-29T23:42:31Z", "type": "commit"}, {"oid": "d8b763fe8f6641c845ccc5a6919e9ba31aa904b4", "url": "https://github.com/confluentinc/ksql/commit/d8b763fe8f6641c845ccc5a6919e9ba31aa904b4", "message": "Bad merge part 2", "committedDate": "2020-06-29T23:58:11Z", "type": "commit"}]}