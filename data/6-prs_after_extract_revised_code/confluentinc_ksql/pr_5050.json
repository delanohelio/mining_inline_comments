{"pr_number": 5050, "pr_title": "chore: add JoinTree in preparation for multi-way join support", "pr_createdAt": "2020-04-10T22:16:04Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5050", "timeline": [{"oid": "a2436b1c0bcb85045e38c6f0cbc0e0fe35cb48aa", "url": "https://github.com/confluentinc/ksql/commit/a2436b1c0bcb85045e38c6f0cbc0e0fe35cb48aa", "message": "chore: add JoinTree in preparation for multi-way join support", "committedDate": "2020-04-10T23:11:51Z", "type": "forcePushed"}, {"oid": "052c2abad29ffc5c0aa1c336d71b1d77da2ef694", "url": "https://github.com/confluentinc/ksql/commit/052c2abad29ffc5c0aa1c336d71b1d77da2ef694", "message": "chore: add JoinTree in preparation for multi-way join support", "committedDate": "2020-04-10T23:12:29Z", "type": "forcePushed"}, {"oid": "14df72f6013e694f60b964ff38c5a0abf82ebc47", "url": "https://github.com/confluentinc/ksql/commit/14df72f6013e694f60b964ff38c5a0abf82ebc47", "message": "chore: add JoinTree in preparation for multi-way join support", "committedDate": "2020-04-10T23:13:10Z", "type": "forcePushed"}, {"oid": "c88b2bbee1e883d726ae83398cd26ea8702e4723", "url": "https://github.com/confluentinc/ksql/commit/c88b2bbee1e883d726ae83398cd26ea8702e4723", "message": "chore: add JoinTree in preparation for multi-way join support", "committedDate": "2020-04-10T23:30:35Z", "type": "forcePushed"}, {"oid": "5dfeb3a052cd7f5ef395994a5d8a3a718a53d0c3", "url": "https://github.com/confluentinc/ksql/commit/5dfeb3a052cd7f5ef395994a5d8a3a718a53d0c3", "message": "chore: add JoinTree in preparation for multi-way join support", "committedDate": "2020-04-10T23:36:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3OTI4Ng==", "url": "https://github.com/confluentinc/ksql/pull/5050#discussion_r406979286", "bodyText": "in the next PR, we will recurse here instead of throwing an exception\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new KsqlException(\n          \n          \n            \n                      \"Invalid join criteria specified; KSQL does not support multi-way joins.\");\n          \n          \n            \n                  left = buildJoin(root.getLeft());", "author": "agavra", "createdAt": "2020-04-10T23:14:29Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -431,52 +433,57 @@ private PlanNode buildSourceForJoin(\n   }\n \n   private PlanNode buildSourceNode() {\n-\n-    final List<AliasedDataSource> sources = analysis.getAllDataSources();\n-\n     if (!analysis.isJoin()) {\n-      return buildNonJoinNode(sources);\n+      return buildNonJoinNode(analysis.getFrom());\n     }\n \n-    if (sources.size() == 1) {\n-      throw new IllegalStateException(\"Expected more than one source. Got \" + sources.size());\n-    } else if (sources.size() != 2) {\n-      throw new KsqlException(\n-          \"Invalid join criteria specified; KSQL does not support multi-way joins.\");\n+    final List<JoinInfo> joinInfo = analysis.getOriginal().getJoin();\n+    final JoinTree.Node tree = JoinTree.build(joinInfo);\n+    if (tree instanceof JoinTree.Leaf) {\n+      throw new IllegalStateException(\"Expected more than one source:\"\n+          + analysis.getAllDataSources());\n     }\n \n-    final AliasedDataSource left = sources.get(0);\n-    final AliasedDataSource right = sources.get(1);\n+    return buildJoin((Join) tree);\n+  }\n \n-    final List<JoinInfo> joinInfo = analysis.getOriginal().getJoin();\n \n-    final PlanNode leftSourceNode = buildSourceForJoin(\n-        left,\n-        \"Left\",\n-        joinInfo.get(0).getLeftJoinExpression()\n-    );\n+  /**\n+   * @param root  the root of the Join Tree\n+   * @return the PlanNode representing this Join Tree\n+   */\n+  private PlanNode buildJoin(final Join root) {\n+    final PlanNode left;\n+    if (root.getLeft() instanceof JoinTree.Join) {\n+      throw new KsqlException(\n+          \"Invalid join criteria specified; KSQL does not support multi-way joins.\");", "originalCommit": "14df72f6013e694f60b964ff38c5a0abf82ebc47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3OTQyOQ==", "url": "https://github.com/confluentinc/ksql/pull/5050#discussion_r406979429", "bodyText": "The next PR will also change the IDs of the plan nodes - this will make sure that they are unique when we generate multi-join topologies. This will require updating the historical plans.", "author": "agavra", "createdAt": "2020-04-10T23:15:08Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -431,52 +433,57 @@ private PlanNode buildSourceForJoin(\n   }\n \n   private PlanNode buildSourceNode() {\n-\n-    final List<AliasedDataSource> sources = analysis.getAllDataSources();\n-\n     if (!analysis.isJoin()) {\n-      return buildNonJoinNode(sources);\n+      return buildNonJoinNode(analysis.getFrom());\n     }\n \n-    if (sources.size() == 1) {\n-      throw new IllegalStateException(\"Expected more than one source. Got \" + sources.size());\n-    } else if (sources.size() != 2) {\n-      throw new KsqlException(\n-          \"Invalid join criteria specified; KSQL does not support multi-way joins.\");\n+    final List<JoinInfo> joinInfo = analysis.getOriginal().getJoin();\n+    final JoinTree.Node tree = JoinTree.build(joinInfo);\n+    if (tree instanceof JoinTree.Leaf) {\n+      throw new IllegalStateException(\"Expected more than one source:\"\n+          + analysis.getAllDataSources());\n     }\n \n-    final AliasedDataSource left = sources.get(0);\n-    final AliasedDataSource right = sources.get(1);\n+    return buildJoin((Join) tree);\n+  }\n \n-    final List<JoinInfo> joinInfo = analysis.getOriginal().getJoin();\n \n-    final PlanNode leftSourceNode = buildSourceForJoin(\n-        left,\n-        \"Left\",\n-        joinInfo.get(0).getLeftJoinExpression()\n-    );\n+  /**\n+   * @param root  the root of the Join Tree\n+   * @return the PlanNode representing this Join Tree\n+   */\n+  private PlanNode buildJoin(final Join root) {\n+    final PlanNode left;\n+    if (root.getLeft() instanceof JoinTree.Join) {\n+      throw new KsqlException(\n+          \"Invalid join criteria specified; KSQL does not support multi-way joins.\");\n+    } else {\n+      final JoinTree.Leaf leaf = (Leaf) root.getLeft();\n+      left = buildSourceForJoin(\n+          leaf.getSource(), \"Left\", root.getInfo().getLeftJoinExpression());", "originalCommit": "14df72f6013e694f60b964ff38c5a0abf82ebc47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "0fb953aa25a3150aff048ddf864d68fa1651434d", "url": "https://github.com/confluentinc/ksql/commit/0fb953aa25a3150aff048ddf864d68fa1651434d", "message": "chore: add JoinTree in preparation for multi-way join support", "committedDate": "2020-04-13T16:03:15Z", "type": "commit"}, {"oid": "0fb953aa25a3150aff048ddf864d68fa1651434d", "url": "https://github.com/confluentinc/ksql/commit/0fb953aa25a3150aff048ddf864d68fa1651434d", "message": "chore: add JoinTree in preparation for multi-way join support", "committedDate": "2020-04-13T16:03:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NTU3OA==", "url": "https://github.com/confluentinc/ksql/pull/5050#discussion_r408375578", "bodyText": "I don't understand the rational behind this. Why create a right-deep tree here?", "author": "vpapavas", "createdAt": "2020-04-14T19:16:54Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner;\n+\n+import io.confluent.ksql.analyzer.Analysis.AliasedDataSource;\n+import io.confluent.ksql.analyzer.Analysis.JoinInfo;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.commons.lang3.StringUtils;\n+\n+/**\n+ * {@code JoinTree} constructs the logical order for which the\n+ * joins should be executed. At the moment, there is no optimization\n+ * done and it simply follows the order of execution that the user\n+ * indicates.\n+ *\n+ * <p>The algorithm is simple: the root is the very first source that\n+ * we encounter (in the case of a single join, we ensure that the left\n+ * root is the FROM source). From then on, any join that happens will\n+ * check if either the left or right source is within the join tree and\n+ * add the other to the corresponding side of the join tree.</p>\n+ *\n+ * <p>For example, take the following join statement:\n+ * <pre>\n+ * {@code\n+ *    SELECT * FROM a\n+ *      JOIN b ON a.id = b.id\n+ *      JOIN c ON a.id = c.id;\n+ * }\n+ * </pre>\n+ * The resulting join tree would look like:\n+ * <pre>\n+ * {@code\n+ *       \u22c8\n+ *      / \\\n+ *     \u22c8   C\n+ *    / \\\n+ *   A   B\n+ * }\n+ * </pre>\n+ * If the statement was modified so that the final expression was\n+ * {@code JOIN c ON c.id = a.id} (note that {@code c.id} has moved\n+ * to the left side of the join), then the resulting join tree would\n+ * look like:\n+ * <pre>\n+ * {@code\n+ *     \u22c8", "originalCommit": "0fb953aa25a3150aff048ddf864d68fa1651434d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMTMxNQ==", "url": "https://github.com/confluentinc/ksql/pull/5050#discussion_r408421315", "bodyText": "this just let's the user express it however they'd like - it's not necessarily \"right deep\". If i write:\nSELECT * FROM A \n  JOIN B ON b.id = a.id\n  JOIN C on b.id = c.id\n  JOIN D on d.id = b.id\nI would get:\n   \u22c8\n  / \\\n D   \u22c8\n    / \\\n   \u22c8   C\n  / \\\n B   A\n\nThe short of it is that I put the right expression on the right side and the left expression on the left side.\n\nReally, it just made the code easier to write (I don't have to \"flip\" any of the expressions) and it gives more control to the user (which isn't a bad thing, given we don't do any optimizations)", "author": "agavra", "createdAt": "2020-04-14T20:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NTU3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1ODIwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5050#discussion_r408458201", "bodyText": "Nevermind... I just realized that these are the same trees. I Don't think it matters which source is on the left and which source is on the right in the join tree. I can rewrite it to always be left deep.", "author": "agavra", "createdAt": "2020-04-14T21:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NTU3OA=="}], "type": "inlineReview", "revised_code": {"commit": "ace4242675f3230b6341500339913c29af43b8e0", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java\nindex 56bc67cc17..613b2135a4 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java\n\n@@ -32,8 +32,7 @@ import org.apache.commons.lang3.StringUtils;\n  * <p>The algorithm is simple: the root is the very first source that\n  * we encounter (in the case of a single join, we ensure that the left\n  * root is the FROM source). From then on, any join that happens will\n- * check if either the left or right source is within the join tree and\n- * add the other to the corresponding side of the join tree.</p>\n+ * happen on the right, creating a left-deep tree.\n  *\n  * <p>For example, take the following join statement:\n  * <pre>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM4MDQxMw==", "url": "https://github.com/confluentinc/ksql/pull/5050#discussion_r408380413", "bodyText": "<3", "author": "vpapavas", "createdAt": "2020-04-14T19:25:18Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner;\n+\n+import io.confluent.ksql.analyzer.Analysis.AliasedDataSource;\n+import io.confluent.ksql.analyzer.Analysis.JoinInfo;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.commons.lang3.StringUtils;\n+\n+/**\n+ * {@code JoinTree} constructs the logical order for which the\n+ * joins should be executed. At the moment, there is no optimization\n+ * done and it simply follows the order of execution that the user\n+ * indicates.\n+ *\n+ * <p>The algorithm is simple: the root is the very first source that\n+ * we encounter (in the case of a single join, we ensure that the left\n+ * root is the FROM source). From then on, any join that happens will\n+ * check if either the left or right source is within the join tree and\n+ * add the other to the corresponding side of the join tree.</p>\n+ *\n+ * <p>For example, take the following join statement:\n+ * <pre>\n+ * {@code\n+ *    SELECT * FROM a\n+ *      JOIN b ON a.id = b.id\n+ *      JOIN c ON a.id = c.id;\n+ * }\n+ * </pre>\n+ * The resulting join tree would look like:\n+ * <pre>\n+ * {@code\n+ *       \u22c8\n+ *      / \\\n+ *     \u22c8   C\n+ *    / \\\n+ *   A   B\n+ * }\n+ * </pre>\n+ * If the statement was modified so that the final expression was\n+ * {@code JOIN c ON c.id = a.id} (note that {@code c.id} has moved\n+ * to the left side of the join), then the resulting join tree would\n+ * look like:\n+ * <pre>\n+ * {@code\n+ *     \u22c8\n+ *   /   \\\n+ *  C    \u22c8\n+ *      / \\\n+ *     A   B\n+ * }\n+ * </pre>\n+ * </p>\n+ */\n+final class JoinTree {\n+\n+  private JoinTree() {\n+  }\n+\n+  /**\n+   * Constructs the join tree given a list of {@code JoinInfo}\n+   *\n+   * @param joins the joins\n+   * @return the tree indicating the order of the join\n+   * @see JoinTree\n+   */\n+  public static Node build(final List<JoinInfo> joins) {\n+    Node root = null;\n+\n+    for (final JoinInfo join : joins) {\n+      if (root == null) {\n+        root = new Leaf(join.getLeftSource());\n+      }\n+\n+      if (root.containsSource(join.getRightSource()) && root.containsSource(join.getLeftSource())) {\n+        throw new KsqlException(\"Cannot perform circular join - both \" + join.getRightSource()\n+            + \" and \" + join.getLeftJoinExpression()\n+            + \" are already included in the current join tree: \" + root.debugString(0));\n+      } else if (root.containsSource(join.getLeftSource())) {\n+        root = new Join(root, new Leaf(join.getRightSource()), join);\n+      } else if (root.containsSource(join.getRightSource())) {\n+        root = new Join(new Leaf(join.getLeftSource()), root, join);\n+      } else {\n+        throw new KsqlException(\n+            \"Cannot build JOIN tree; neither source in the join is the FROM source or included \"\n+                + \"in a previous JOIN: \" + join + \". The current join tree is \"\n+                + root.debugString(0)\n+        );\n+      }\n+    }\n+\n+    return root;\n+  }\n+\n+  /**\n+   * A node in the {@code JoinTree} that represents either a Leaf node or a Join\n+   * node.\n+   */\n+  interface Node {\n+\n+    /**\n+     * @param dataSource the data source to search for\n+     * @return whether or not this node already references the {@code dataSource}\n+     */\n+    boolean containsSource(AliasedDataSource dataSource);\n+\n+    /**\n+     * @return a debug string that pretty prints the tree\n+     */\n+    String debugString(int indent);\n+  }\n+\n+  static class Join implements Node {\n+\n+    private final Node left;\n+    private final Node right;\n+    private final JoinInfo info;\n+\n+    Join(final Node left, final Node right, final JoinInfo info) {\n+      this.left = left;\n+      this.right = right;\n+      this.info = info;\n+    }\n+\n+    public JoinInfo getInfo() {\n+      return info;\n+    }\n+\n+    public Node getLeft() {\n+      return left;\n+    }\n+\n+    public Node getRight() {\n+      return right;\n+    }\n+\n+    @Override\n+    public boolean containsSource(final AliasedDataSource dataSource) {\n+      return left.containsSource(dataSource) || right.containsSource(dataSource);\n+    }\n+\n+    @Override\n+    public String debugString(final int indent) {\n+      return \"\u22c8\\n\"", "originalCommit": "0fb953aa25a3150aff048ddf864d68fa1651434d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ace4242675f3230b6341500339913c29af43b8e0", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java\nindex 56bc67cc17..613b2135a4 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java\n\n@@ -32,8 +32,7 @@ import org.apache.commons.lang3.StringUtils;\n  * <p>The algorithm is simple: the root is the very first source that\n  * we encounter (in the case of a single join, we ensure that the left\n  * root is the FROM source). From then on, any join that happens will\n- * check if either the left or right source is within the join tree and\n- * add the other to the corresponding side of the join tree.</p>\n+ * happen on the right, creating a left-deep tree.\n  *\n  * <p>For example, take the following join statement:\n  * <pre>\n"}}, {"oid": "ace4242675f3230b6341500339913c29af43b8e0", "url": "https://github.com/confluentinc/ksql/commit/ace4242675f3230b6341500339913c29af43b8e0", "message": "chore: always build left deep tree", "committedDate": "2020-04-15T00:09:07Z", "type": "commit"}, {"oid": "ace4242675f3230b6341500339913c29af43b8e0", "url": "https://github.com/confluentinc/ksql/commit/ace4242675f3230b6341500339913c29af43b8e0", "message": "chore: always build left deep tree", "committedDate": "2020-04-15T00:09:07Z", "type": "forcePushed"}]}