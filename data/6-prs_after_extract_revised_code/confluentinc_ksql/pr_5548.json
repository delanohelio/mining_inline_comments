{"pr_number": 5548, "pr_title": "feat: new UDFs for set-like operations on Arrays", "pr_createdAt": "2020-06-04T05:53:20Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5548", "timeline": [{"oid": "b45b3020864aa7832837a84cf0e7397098e91d5f", "url": "https://github.com/confluentinc/ksql/commit/b45b3020864aa7832837a84cf0e7397098e91d5f", "message": "initial version", "committedDate": "2020-06-04T05:45:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUxNDY5Mg==", "url": "https://github.com/confluentinc/ksql/pull/5548#discussion_r435514692", "bodyText": "You are missing a test case where the arrays contain null values", "author": "vpapavas", "createdAt": "2020-06-04T19:58:25Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udf/array/ArrayExceptTest.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License; you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and limitations under the\n+ * License.\n+ */\n+\n+package io.confluent.ksql.function.udf.array;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Test;\n+\n+public class ArrayExceptTest {", "originalCommit": "b45b3020864aa7832837a84cf0e7397098e91d5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3OTU0NA==", "url": "https://github.com/confluentinc/ksql/pull/5548#discussion_r435579544", "bodyText": "argh, good catch - thanks! will add", "author": "blueedgenick", "createdAt": "2020-06-04T22:07:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUxNDY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c6b1fb5cda8f72841801749a6c46902b73b1e2f7", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udf/array/ArrayExceptTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udf/array/ArrayExceptTest.java\nindex 5204b8e9e1..63cf0ecc08 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/function/udf/array/ArrayExceptTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/function/udf/array/ArrayExceptTest.java\n\n@@ -66,6 +66,22 @@ public class ArrayExceptTest {\n     assertThat(result, contains(\"foo\", \"bar\"));\n   }\n \n+  @Test\n+  public void shouldExceptFromArrayContainingNulls() {\n+    final List<String> input1 = Arrays.asList(\"foo\", null, \"foo\", \"bar\");\n+    final List<String> input2 = Arrays.asList(\"foo\");\n+    final List<String> result = udf.except(input1, input2);\n+    assertThat(result, contains(null, \"bar\"));\n+  }\n+\n+  @Test\n+  public void shouldExceptNulls() {\n+    final List<String> input1 = Arrays.asList(\"foo\", null, \"foo\", \"bar\");\n+    final List<String> input2 = Arrays.asList(null, \"foo\");\n+    final List<String> result = udf.except(input1, input2);\n+    assertThat(result, contains(\"bar\"));\n+  }\n+\n   @Test\n   public void shouldReturnNullForNullLeftInput() {\n     final List<String> input1 = Arrays.asList(\"foo\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUxNTU5NQ==", "url": "https://github.com/confluentinc/ksql/pull/5548#discussion_r435515595", "bodyText": "This is a bit confusing behavior for me. Why does the test right above contain a null value in the resulting array but this test returns null?", "author": "vpapavas", "createdAt": "2020-06-04T20:00:16Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udf/array/ArrayUnionTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License; you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and limitations under the\n+ * License.\n+ */\n+\n+package io.confluent.ksql.function.udf.array;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+\n+import com.google.common.collect.ImmutableMap;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+public class ArrayUnionTest {\n+\n+  private final ArrayUnion udf = new ArrayUnion();\n+\n+  @Test\n+  public void shouldUnionArraysOfLikeType() {\n+    final List<String> input1 = Arrays.asList(\"foo\", \" \", \"bar\");\n+    final List<String> input2 = Arrays.asList(\"baz\");\n+    final List<String> result = udf.union(input1, input2);\n+    assertThat(result, contains(\"foo\", \" \", \"bar\", \"baz\"));\n+  }\n+\n+  @Test\n+  public void shouldReturnDistinctValues() {\n+    final List<String> input1 = Arrays.asList(\"foo\", \"foo\", \"bar\");\n+    final List<String> input2 = Arrays.asList(\"baz\", \"foo\");\n+    final List<String> result = udf.union(input1, input2);\n+    assertThat(result, contains(\"foo\", \"bar\", \"baz\"));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Test\n+  public void shouldIntersectArraysOfMaps() {\n+    final Map<String, Integer> map1 = ImmutableMap.of(\"foo\", 1, \"bar\", 2, \"baz\", 3);\n+    final Map<String, Integer> map2 = ImmutableMap.of(\"foo\", 10, \"baz\", 3);\n+    final Map<String, Integer> map3 = ImmutableMap.of(\"foo\", 1, \"bar\", 2, \"baz\", 3);\n+    final List<Map<String, Integer>> input1 = Arrays.asList(map1, map2);\n+    final List<Map<String, Integer>> input2 = Arrays.asList(map2, map3);\n+    final List<Map<String, Integer>> result = udf.union(input1, input2);\n+    assertThat(result, contains(map1, map2));\n+  }\n+\n+  @Test\n+  public void shouldUnionArraysContainingNulls() {\n+    final List<String> input1 = Arrays.asList(null, \"bar\");\n+    final List<String> input2 = Arrays.asList(\"foo\");\n+    final List<String> result = udf.union(input1, input2);\n+    assertThat(result, contains(null, \"bar\", \"foo\"));\n+  }\n+\n+  @Test\n+  public void shouldUnionArraysBothContainingNulls() {\n+    final List<String> input1 = Arrays.asList(null, \"foo\", \"bar\");\n+    final List<String> input2 = Arrays.asList(\"foo\", null);\n+    final List<String> result = udf.union(input1, input2);\n+    assertThat(result, contains((String) null, \"foo\", \"bar\"));\n+  }\n+\n+  @Test\n+  public void shouldReturnNullForArraysOfOnlyNulls() {\n+    final List<String> input1 = Arrays.asList(null, null);\n+    final List<String> input2 = Arrays.asList(null, null, null);\n+    final List<String> result = udf.union(input1, input2);\n+    assertThat(result, contains(nullValue()));", "originalCommit": "b45b3020864aa7832837a84cf0e7397098e91d5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5MzUzOA==", "url": "https://github.com/confluentinc/ksql/pull/5548#discussion_r435593538", "bodyText": "there's a subtlety here - in this case the udf doesn't really return null, instead it returns an array containing a single null - which i think is what the function should do in this case, on the grounds that the only distinct value found in either of the input arrays is a null.  This is different than the case that we pass in an actual null, as compared to array-of-nulls which is what we have here, and that other case is tested below.\nDoes that make sense, or am i misunderstanding the question ?", "author": "blueedgenick", "createdAt": "2020-06-04T22:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUxNTU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzMzgyNA==", "url": "https://github.com/confluentinc/ksql/pull/5548#discussion_r435633824", "bodyText": "Oh sorry, I just noticed the contains. I thought it was equals that's why I asked. Your answer and the code totally make sense. Sorry about that", "author": "vpapavas", "createdAt": "2020-06-05T00:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUxNTU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxNjgyMw==", "url": "https://github.com/confluentinc/ksql/pull/5548#discussion_r436016823", "bodyText": "yeah, this new matcher-naming throws me off regularly too - i think i liked \"contains\" much better as something like \"isArrayContaining\", especially when you're scanning through a whole set of tests  :)", "author": "blueedgenick", "createdAt": "2020-06-05T16:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUxNTU5NQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "c6b1fb5cda8f72841801749a6c46902b73b1e2f7", "url": "https://github.com/confluentinc/ksql/commit/c6b1fb5cda8f72841801749a6c46902b73b1e2f7", "message": "Vicky's requested change", "committedDate": "2020-06-04T23:28:33Z", "type": "commit"}, {"oid": "8d7769e33b2172095fa06412a00f3eb46572e2cd", "url": "https://github.com/confluentinc/ksql/commit/8d7769e33b2172095fa06412a00f3eb46572e2cd", "message": "Jim's suggeseted doc tweaks", "committedDate": "2020-06-05T16:04:36Z", "type": "commit"}]}