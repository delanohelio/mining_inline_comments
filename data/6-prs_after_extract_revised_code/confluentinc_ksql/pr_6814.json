{"pr_number": 6814, "pr_title": "feat: Move WHERE clause handling for pull queries into logical plan", "pr_createdAt": "2020-12-22T18:39:43Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6814", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0NzA4Ng==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551447086", "bodyText": "Why catch everything here?  There's already a catch all above in HARouting:\ntry {\n  future.get();\n} catch (ExecutionException e) {\n  LOG.warn(\"Error routing query {} to host {} at timestamp {} with exception {}\",\n     statement.getStatementText(), node, System.currentTimeMillis(), e.getCause());\n nextRoundRemaining.addAll(groupedByHost.get(node));\n}", "author": "AlanConfluent", "createdAt": "2021-01-04T17:06:41Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/HARouting.java", "diffHunk": "@@ -246,17 +246,37 @@ static PullQueryResult executeOrRouteQuery(\n   ) {\n     List<List<?>> rows = null;\n     if (node.isLocal()) {\n-      LOG.debug(\"Query {} executed locally at host {} at timestamp {}.\",\n-                statement.getStatementText(), node.location(), System.currentTimeMillis());\n-      pullQueryMetrics\n-          .ifPresent(queryExecutorMetrics -> queryExecutorMetrics.recordLocalRequests(1));\n-      rows = pullPhysicalPlan.execute(locations);\n+      try {\n+        LOG.debug(\"Query {} executed locally at host {} at timestamp {}.\",\n+                  statement.getStatementText(), node.location(), System.currentTimeMillis());\n+        pullQueryMetrics\n+            .ifPresent(queryExecutorMetrics -> queryExecutorMetrics.recordLocalRequests(1));\n+        rows = pullPhysicalPlan.execute(locations);\n+      } catch (Exception e) {", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3ODEzNw==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553078137", "bodyText": "It catches all because I don't know what kind of exceptions can be throw, it can be from materialization, from streams, from the code gen, from ksql. Also, It catches and then throws a KsqlException so what is the problem? We know that the exception has to do only with physical plan execution so it's not like it will catch something it shouldn't", "author": "vpapavas", "createdAt": "2021-01-07T02:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0NzA4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/HARouting.java b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/HARouting.java\nindex 8448c84c80..16be466d5c 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/HARouting.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/HARouting.java\n\n@@ -246,37 +246,17 @@ public final class HARouting implements AutoCloseable {\n   ) {\n     List<List<?>> rows = null;\n     if (node.isLocal()) {\n-      try {\n-        LOG.debug(\"Query {} executed locally at host {} at timestamp {}.\",\n-                  statement.getStatementText(), node.location(), System.currentTimeMillis());\n-        pullQueryMetrics\n-            .ifPresent(queryExecutorMetrics -> queryExecutorMetrics.recordLocalRequests(1));\n-        rows = pullPhysicalPlan.execute(locations);\n-      } catch (Exception e) {\n-        LOG.error(\"Error executing query {} locally at node {} with exception {}\",\n-                 statement.getStatementText(), node, e.getCause());\n-        throw new KsqlException(\n-            String.format(\"Error executing query %s locally at node %s\",\n-                          statement.getStatementText(), node),\n-            e\n-        );\n-      }\n+      LOG.debug(\"Query {} executed locally at host {} at timestamp {}.\",\n+                statement.getStatementText(), node.location(), System.currentTimeMillis());\n+      pullQueryMetrics\n+          .ifPresent(queryExecutorMetrics -> queryExecutorMetrics.recordLocalRequests(1));\n+      rows = pullPhysicalPlan.execute(locations);\n     } else {\n-      try {\n-        LOG.debug(\"Query {} routed to host {} at timestamp {}.\",\n-                  statement.getStatementText(), node.location(), System.currentTimeMillis());\n-        pullQueryMetrics\n-            .ifPresent(queryExecutorMetrics -> queryExecutorMetrics.recordRemoteRequests(1));\n-        rows = forwardTo(node, locations, statement, serviceContext);\n-      } catch (Exception e) {\n-        LOG.error(\"Error forwarding query {} to node {} with exception {}\",\n-                  statement.getStatementText(), node, e.getCause());\n-        throw new KsqlException(\n-            String.format(\"Error forwarding query %s to node %s\",\n-                          statement.getStatementText(), node),\n-            e\n-        );\n-      }\n+      LOG.debug(\"Query {} routed to host {} at timestamp {}.\",\n+                statement.getStatementText(), node.location(), System.currentTimeMillis());\n+      pullQueryMetrics\n+          .ifPresent(queryExecutorMetrics -> queryExecutorMetrics.recordRemoteRequests(1));\n+      rows = forwardTo(node, locations, statement, serviceContext);\n     }\n     final Optional<List<KsqlNode>> debugNodes = Optional.ofNullable(\n         routingOptions.getIsDebugRequest()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0NzY4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551447681", "bodyText": "Is this a check for Row.EMPTY_ROW?  Why not check equality with that object if it's a special value?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:07:49Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlan.java", "diffHunk": "@@ -68,7 +68,9 @@ public PullPhysicalPlan(\n     final List<List<?>> localResult = new ArrayList<>();\n     List<?> row = null;\n     while ((row = (List<?>)next()) != null) {\n-      localResult.add(row);\n+      if (!row.isEmpty()) {", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3OTQ0NA==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553079444", "bodyText": "Removed the empty row", "author": "vpapavas", "createdAt": "2021-01-07T02:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0NzY4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlan.java b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlan.java\nindex 6043086559..8d6f24ab0d 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlan.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlan.java\n\n@@ -68,9 +68,7 @@ public class PullPhysicalPlan {\n     final List<List<?>> localResult = new ArrayList<>();\n     List<?> row = null;\n     while ((row = (List<?>)next()) != null) {\n-      if (!row.isEmpty()) {\n-        localResult.add(row);\n-      }\n+      localResult.add(row);\n     }\n     close();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MDAyMQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551450021", "bodyText": "I personally find it a little confusing that in some areas, we use DB language (e.g. select) and in others we use functional programming language (e.g. filter).  Can we try to be consistent?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:11:56Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java", "diffHunk": "@@ -179,30 +161,27 @@ private ProjectOperator translateProjectNode(final PullProjectNode logicalNode)\n     );\n   }\n \n-  private SelectOperator translateFilterNode(final FilterNode logicalNode) {\n-    final boolean windowed = persistentQueryMetadata.getResultTopic().getKeyFormat().isWindowed();\n-    whereInfo = WhereInfo.extractWhereInfo(\n-        analysis.getWhereExpression().orElseThrow(\n-            () -> WhereInfo.invalidWhereClauseException(\"Missing WHERE clause\", windowed)),\n-        persistentQueryMetadata.getLogicalSchema(),\n-        windowed,\n-        metaStore,\n-        config);\n-    return new SelectOperator(logicalNode);\n+  private SelectOperator translateFilterNode(final PullFilterNode logicalNode) {\n+    isWindowed = logicalNode.isWindowed();\n+    keys = logicalNode.getKeyValues();\n+    windowBounds = logicalNode.getWindowBounds();\n+\n+    final ProcessingLogger logger = processingLogContext\n+        .getLoggerFactory()\n+        .getLogger(\n+            QueryLoggerUtil.queryLoggerName(\n+                QueryType.PULL_QUERY, contextStacker.push(\"SELECT\").getQueryContext())", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3NzU1Ng==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553077556", "bodyText": "Yeah I agree but this is what the existing code already does so I am trying to be consistent with persistent queries", "author": "vpapavas", "createdAt": "2021-01-07T02:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MDAyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java\nindex 6dd3dca888..97b8465f66 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java\n\n@@ -161,27 +178,43 @@ public class PullPhysicalPlanBuilder {\n     );\n   }\n \n-  private SelectOperator translateFilterNode(final PullFilterNode logicalNode) {\n-    isWindowed = logicalNode.isWindowed();\n-    keys = logicalNode.getKeyValues();\n-    windowBounds = logicalNode.getWindowBounds();\n-\n-    final ProcessingLogger logger = processingLogContext\n-        .getLoggerFactory()\n-        .getLogger(\n-            QueryLoggerUtil.queryLoggerName(\n-                QueryType.PULL_QUERY, contextStacker.push(\"SELECT\").getQueryContext())\n-        );\n-    return new SelectOperator(logicalNode, logger);\n+  private SelectOperator translateFilterNode(final FilterNode logicalNode) {\n+    final boolean windowed = persistentQueryMetadata.getResultTopic().getKeyFormat().isWindowed();\n+    whereInfo = WhereInfo.extractWhereInfo(\n+        analysis.getWhereExpression().orElseThrow(\n+            () -> WhereInfo.invalidWhereClauseException(\"Missing WHERE clause\", windowed)),\n+        persistentQueryMetadata.getLogicalSchema(),\n+        windowed,\n+        metaStore,\n+        config);\n+    return new SelectOperator(logicalNode);\n   }\n \n   private AbstractPhysicalOperator translateDataSourceNode(\n       final DataSourceNode logicalNode\n   ) {\n-    if (!isWindowed) {\n+    final boolean windowed = persistentQueryMetadata.getResultTopic().getKeyFormat().isWindowed();\n+    if (whereInfo == null) {\n+      if (!config.getBoolean(KsqlConfig.KSQL_QUERY_PULL_TABLE_SCAN_ENABLED)) {\n+        throw WhereInfo.invalidWhereClauseException(\"Missing WHERE clause\", windowed);\n+      }\n+      // Full table scan has no keys\n+      keys = Collections.emptyList();\n+    } else {\n+      keys = whereInfo.getKeysBound();\n+    }\n+\n+    if (keys.isEmpty()) {\n+      if (!windowed) {\n+        return new TableScanOperator(mat, logicalNode);\n+      } else {\n+        return new WindowedTableScanOperator(mat, logicalNode);\n+      }\n+    } else if (!windowed) {\n       return new KeyedTableLookupOperator(mat, logicalNode);\n     } else {\n-      return new KeyedWindowedTableLookupOperator(mat, logicalNode, windowBounds.get());\n+      return new KeyedWindowedTableLookupOperator(\n+          mat, logicalNode, whereInfo.getWindowBounds().get());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MTQ1OQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551451459", "bodyText": "nit: space after cast?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:14:32Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java", "diffHunk": "@@ -15,28 +15,82 @@\n \n package io.confluent.ksql.physical.pull.operators;\n \n-import io.confluent.ksql.planner.plan.FilterNode;\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.streams.SqlPredicateFactory;\n+import io.confluent.ksql.execution.streams.materialization.PullProcessingContext;\n+import io.confluent.ksql.execution.streams.materialization.Row;\n+import io.confluent.ksql.execution.streams.materialization.TableRow;\n+import io.confluent.ksql.execution.streams.materialization.WindowedRow;\n+import io.confluent.ksql.execution.transform.KsqlTransformer;\n+import io.confluent.ksql.execution.transform.sqlpredicate.SqlPredicate;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n import io.confluent.ksql.planner.plan.PlanNode;\n+import io.confluent.ksql.planner.plan.PullFilterNode;\n import java.util.List;\n import java.util.Objects;\n+import java.util.Optional;\n \n public class SelectOperator extends AbstractPhysicalOperator implements UnaryPhysicalOperator {\n \n-  private final FilterNode logicalNode;\n+  private final PullFilterNode logicalNode;\n+  private final ProcessingLogger logger;\n+  private final SqlPredicate predicate;\n+\n   private AbstractPhysicalOperator child;\n+  private KsqlTransformer<Object, Optional<GenericRow>> transformer;\n+  private TableRow row;\n+\n+  public SelectOperator(final PullFilterNode logicalNode, final ProcessingLogger logger) {\n+    this(logicalNode, logger, SqlPredicate::new);\n+  }\n \n-  public SelectOperator(final FilterNode logicalNode) {\n-    this.logicalNode = Objects.requireNonNull(logicalNode);\n+  @VisibleForTesting\n+  SelectOperator(\n+      final PullFilterNode logicalNode,\n+      final ProcessingLogger logger,\n+      final SqlPredicateFactory predicateFactory\n+  ) {\n+    this.logicalNode = Objects.requireNonNull(logicalNode, \"logicalNode\");\n+    this.logger = Objects.requireNonNull(logger, \"logger\");\n+    this.predicate = predicateFactory.create(\n+        logicalNode.getRewrittenPredicate(),\n+        logicalNode.getCompiledWhereClause()\n+    );\n   }\n \n+\n   @Override\n   public void open() {\n+    transformer = predicate.getTransformer(logger);\n     child.open();\n   }\n \n   @Override\n   public Object next() {\n-    return child.next();\n+    row = (TableRow)child.next();", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java\nindex 14d27c18f8..f4baa79b34 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java\n\n@@ -15,82 +15,28 @@\n \n package io.confluent.ksql.physical.pull.operators;\n \n-import com.google.common.annotations.VisibleForTesting;\n-import io.confluent.ksql.GenericRow;\n-import io.confluent.ksql.execution.streams.SqlPredicateFactory;\n-import io.confluent.ksql.execution.streams.materialization.PullProcessingContext;\n-import io.confluent.ksql.execution.streams.materialization.Row;\n-import io.confluent.ksql.execution.streams.materialization.TableRow;\n-import io.confluent.ksql.execution.streams.materialization.WindowedRow;\n-import io.confluent.ksql.execution.transform.KsqlTransformer;\n-import io.confluent.ksql.execution.transform.sqlpredicate.SqlPredicate;\n-import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.planner.plan.FilterNode;\n import io.confluent.ksql.planner.plan.PlanNode;\n-import io.confluent.ksql.planner.plan.PullFilterNode;\n import java.util.List;\n import java.util.Objects;\n-import java.util.Optional;\n \n public class SelectOperator extends AbstractPhysicalOperator implements UnaryPhysicalOperator {\n \n-  private final PullFilterNode logicalNode;\n-  private final ProcessingLogger logger;\n-  private final SqlPredicate predicate;\n-\n+  private final FilterNode logicalNode;\n   private AbstractPhysicalOperator child;\n-  private KsqlTransformer<Object, Optional<GenericRow>> transformer;\n-  private TableRow row;\n-\n-  public SelectOperator(final PullFilterNode logicalNode, final ProcessingLogger logger) {\n-    this(logicalNode, logger, SqlPredicate::new);\n-  }\n \n-  @VisibleForTesting\n-  SelectOperator(\n-      final PullFilterNode logicalNode,\n-      final ProcessingLogger logger,\n-      final SqlPredicateFactory predicateFactory\n-  ) {\n-    this.logicalNode = Objects.requireNonNull(logicalNode, \"logicalNode\");\n-    this.logger = Objects.requireNonNull(logger, \"logger\");\n-    this.predicate = predicateFactory.create(\n-        logicalNode.getRewrittenPredicate(),\n-        logicalNode.getCompiledWhereClause()\n-    );\n+  public SelectOperator(final FilterNode logicalNode) {\n+    this.logicalNode = Objects.requireNonNull(logicalNode);\n   }\n \n-\n   @Override\n   public void open() {\n-    transformer = predicate.getTransformer(logger);\n     child.open();\n   }\n \n   @Override\n   public Object next() {\n-    row = (TableRow)child.next();\n-    if (row == null) {\n-      return null;\n-    }\n-\n-    final GenericRow intermediate = PullPhysicalOperatorUtil.getIntermediateRow(\n-        row, logicalNode.getAddAdditionalColumnsToIntermediateSchema());\n-\n-    return transformer.transform(\n-        row.key(),\n-        intermediate,\n-        new PullProcessingContext(row.rowTime()))\n-        .map(r -> {\n-          if (logicalNode.isWindowed()) {\n-            return WindowedRow.of(\n-                logicalNode.getIntermediateSchema(),\n-                ((WindowedRow) row).windowedKey(),\n-                r,\n-                row.rowTime());\n-          }\n-          return Row.of(logicalNode.getIntermediateSchema(), row.key(), r, row.rowTime());\n-        })\n-        .orElse(Row.EMPTY_ROW);\n+    return child.next();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MzgxNg==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551453816", "bodyText": "Why not return null if we're at the end, or child.next if not.  That way you don't have to introduce another \"special\" value to check for.  You can put the whole block in a while (row != null) and return null otherwise.  We already do this in the other operators.\nOtherwise, you're exposing internal state that isn't meaningful to the caller.", "author": "AlanConfluent", "createdAt": "2021-01-04T17:18:34Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java", "diffHunk": "@@ -15,28 +15,82 @@\n \n package io.confluent.ksql.physical.pull.operators;\n \n-import io.confluent.ksql.planner.plan.FilterNode;\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.streams.SqlPredicateFactory;\n+import io.confluent.ksql.execution.streams.materialization.PullProcessingContext;\n+import io.confluent.ksql.execution.streams.materialization.Row;\n+import io.confluent.ksql.execution.streams.materialization.TableRow;\n+import io.confluent.ksql.execution.streams.materialization.WindowedRow;\n+import io.confluent.ksql.execution.transform.KsqlTransformer;\n+import io.confluent.ksql.execution.transform.sqlpredicate.SqlPredicate;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n import io.confluent.ksql.planner.plan.PlanNode;\n+import io.confluent.ksql.planner.plan.PullFilterNode;\n import java.util.List;\n import java.util.Objects;\n+import java.util.Optional;\n \n public class SelectOperator extends AbstractPhysicalOperator implements UnaryPhysicalOperator {\n \n-  private final FilterNode logicalNode;\n+  private final PullFilterNode logicalNode;\n+  private final ProcessingLogger logger;\n+  private final SqlPredicate predicate;\n+\n   private AbstractPhysicalOperator child;\n+  private KsqlTransformer<Object, Optional<GenericRow>> transformer;\n+  private TableRow row;\n+\n+  public SelectOperator(final PullFilterNode logicalNode, final ProcessingLogger logger) {\n+    this(logicalNode, logger, SqlPredicate::new);\n+  }\n \n-  public SelectOperator(final FilterNode logicalNode) {\n-    this.logicalNode = Objects.requireNonNull(logicalNode);\n+  @VisibleForTesting\n+  SelectOperator(\n+      final PullFilterNode logicalNode,\n+      final ProcessingLogger logger,\n+      final SqlPredicateFactory predicateFactory\n+  ) {\n+    this.logicalNode = Objects.requireNonNull(logicalNode, \"logicalNode\");\n+    this.logger = Objects.requireNonNull(logger, \"logger\");\n+    this.predicate = predicateFactory.create(\n+        logicalNode.getRewrittenPredicate(),\n+        logicalNode.getCompiledWhereClause()\n+    );\n   }\n \n+\n   @Override\n   public void open() {\n+    transformer = predicate.getTransformer(logger);\n     child.open();\n   }\n \n   @Override\n   public Object next() {\n-    return child.next();\n+    row = (TableRow)child.next();\n+    if (row == null) {\n+      return null;\n+    }\n+\n+    final GenericRow intermediate = PullPhysicalOperatorUtil.getIntermediateRow(\n+        row, logicalNode.getAddAdditionalColumnsToIntermediateSchema());\n+\n+    return transformer.transform(\n+        row.key(),\n+        intermediate,\n+        new PullProcessingContext(row.rowTime()))\n+        .map(r -> {\n+          if (logicalNode.isWindowed()) {\n+            return WindowedRow.of(\n+                logicalNode.getIntermediateSchema(),\n+                ((WindowedRow) row).windowedKey(),\n+                r,\n+                row.rowTime());\n+          }\n+          return Row.of(logicalNode.getIntermediateSchema(), row.key(), r, row.rowTime());\n+        })\n+        .orElse(Row.EMPTY_ROW);", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3OTU0Mw==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553079543", "bodyText": "Yes, I agree. I changed it", "author": "vpapavas", "createdAt": "2021-01-07T02:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MzgxNg=="}], "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java\nindex 14d27c18f8..f4baa79b34 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java\n\n@@ -15,82 +15,28 @@\n \n package io.confluent.ksql.physical.pull.operators;\n \n-import com.google.common.annotations.VisibleForTesting;\n-import io.confluent.ksql.GenericRow;\n-import io.confluent.ksql.execution.streams.SqlPredicateFactory;\n-import io.confluent.ksql.execution.streams.materialization.PullProcessingContext;\n-import io.confluent.ksql.execution.streams.materialization.Row;\n-import io.confluent.ksql.execution.streams.materialization.TableRow;\n-import io.confluent.ksql.execution.streams.materialization.WindowedRow;\n-import io.confluent.ksql.execution.transform.KsqlTransformer;\n-import io.confluent.ksql.execution.transform.sqlpredicate.SqlPredicate;\n-import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.planner.plan.FilterNode;\n import io.confluent.ksql.planner.plan.PlanNode;\n-import io.confluent.ksql.planner.plan.PullFilterNode;\n import java.util.List;\n import java.util.Objects;\n-import java.util.Optional;\n \n public class SelectOperator extends AbstractPhysicalOperator implements UnaryPhysicalOperator {\n \n-  private final PullFilterNode logicalNode;\n-  private final ProcessingLogger logger;\n-  private final SqlPredicate predicate;\n-\n+  private final FilterNode logicalNode;\n   private AbstractPhysicalOperator child;\n-  private KsqlTransformer<Object, Optional<GenericRow>> transformer;\n-  private TableRow row;\n-\n-  public SelectOperator(final PullFilterNode logicalNode, final ProcessingLogger logger) {\n-    this(logicalNode, logger, SqlPredicate::new);\n-  }\n \n-  @VisibleForTesting\n-  SelectOperator(\n-      final PullFilterNode logicalNode,\n-      final ProcessingLogger logger,\n-      final SqlPredicateFactory predicateFactory\n-  ) {\n-    this.logicalNode = Objects.requireNonNull(logicalNode, \"logicalNode\");\n-    this.logger = Objects.requireNonNull(logger, \"logger\");\n-    this.predicate = predicateFactory.create(\n-        logicalNode.getRewrittenPredicate(),\n-        logicalNode.getCompiledWhereClause()\n-    );\n+  public SelectOperator(final FilterNode logicalNode) {\n+    this.logicalNode = Objects.requireNonNull(logicalNode);\n   }\n \n-\n   @Override\n   public void open() {\n-    transformer = predicate.getTransformer(logger);\n     child.open();\n   }\n \n   @Override\n   public Object next() {\n-    row = (TableRow)child.next();\n-    if (row == null) {\n-      return null;\n-    }\n-\n-    final GenericRow intermediate = PullPhysicalOperatorUtil.getIntermediateRow(\n-        row, logicalNode.getAddAdditionalColumnsToIntermediateSchema());\n-\n-    return transformer.transform(\n-        row.key(),\n-        intermediate,\n-        new PullProcessingContext(row.rowTime()))\n-        .map(r -> {\n-          if (logicalNode.isWindowed()) {\n-            return WindowedRow.of(\n-                logicalNode.getIntermediateSchema(),\n-                ((WindowedRow) row).windowedKey(),\n-                r,\n-                row.rowTime());\n-          }\n-          return Row.of(logicalNode.getIntermediateSchema(), row.key(), r, row.rowTime());\n-        })\n-        .orElse(Row.EMPTY_ROW);\n+    return child.next();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2MDE0Ng==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551460146", "bodyText": "I don't think you need to add this.", "author": "AlanConfluent", "createdAt": "2021-01-04T17:30:39Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/Row.java", "diffHunk": "@@ -27,6 +27,8 @@\n \n public final class Row implements TableRow {\n \n+  public static final Row EMPTY_ROW = new Row();", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/Row.java b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/Row.java\nindex f4976e028f..c4a35bac92 100644\n--- a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/Row.java\n+++ b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/Row.java\n\n@@ -27,8 +27,6 @@ import java.util.Optional;\n \n public final class Row implements TableRow {\n \n-  public static final Row EMPTY_ROW = new Row();\n-\n   private final LogicalSchema schema;\n   private final GenericKey key;\n   private final GenericRow value;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NTIwOA==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551465208", "bodyText": "nit: unnecessary parens?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:40:43Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());\n+    final Validator validator = new Validator();\n+    validator.process(rewrittenPredicate, null);\n+    if (!isKeyedQuery) {\n+      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n+    }\n+\n+    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n+      final List<ColumnName> seenKeyNames = seenKeys\n+          .stream()\n+          .boxed()\n+          .map(i -> schema.key().get(i))\n+          .map(Column::name)\n+          .collect(Collectors.toList());\n+      throw invalidWhereClauseException(\n+          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n+              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n+    }\n+  }\n+\n+  private void extractKeysAndSystemCols() {\n+    keyColumns = new HashSet<>();\n+    systemColumns = new HashSet<>();\n+    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n+  }\n+\n+  private List<GenericKey> extractKeyValues() {\n+    inKeys = new ArrayList<>();\n+    keyContents = new Object[schema.key().size()];\n+    seenKeys = new BitSet(schema.key().size());\n+\n+    new KeyValueExtractor().process(rewrittenPredicate, null);\n+    if (!inKeys.isEmpty()) {\n+      return (inKeys);", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\ndeleted file mode 100644\nindex 13d9328c3b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\n+++ /dev/null\n\n@@ -1,823 +0,0 @@\n-/*\n- * Copyright 2019 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.collect.BoundType;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Range;\n-import io.confluent.ksql.GenericKey;\n-import io.confluent.ksql.analyzer.PullQueryValidator;\n-import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n-import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n-import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n-import io.confluent.ksql.execution.expression.tree.Expression;\n-import io.confluent.ksql.execution.expression.tree.InPredicate;\n-import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n-import io.confluent.ksql.execution.expression.tree.Literal;\n-import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n-import io.confluent.ksql.execution.expression.tree.LongLiteral;\n-import io.confluent.ksql.execution.expression.tree.NullLiteral;\n-import io.confluent.ksql.execution.expression.tree.StringLiteral;\n-import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n-import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.name.ColumnName;\n-import io.confluent.ksql.schema.ksql.Column;\n-import io.confluent.ksql.schema.ksql.Column.Namespace;\n-import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.utils.FormatOptions;\n-import io.confluent.ksql.structured.SchemaKStream;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class PullFilterNode extends SingleSourcePlanNode {\n-\n-  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n-      Type.EQUAL,\n-      Type.GREATER_THAN,\n-      Type.GREATER_THAN_OR_EQUAL,\n-      Type.LESS_THAN,\n-      Type.LESS_THAN_OR_EQUAL\n-  );\n-\n-  private final boolean isWindowed;\n-  private final ExpressionMetadata compiledWhereClause;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final MetaStore metaStore;\n-  private final KsqlConfig ksqlConfig;\n-  private final LogicalSchema schema = getSource().getSchema();\n-\n-  private Expression rewrittenPredicate;\n-  private boolean isKeyedQuery = false;\n-  private Optional<WindowBounds> windowBounds;\n-  private List<GenericKey> keyValues;\n-  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n-  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n-  private List<GenericKey> inKeys;\n-  private BitSet seenKeys;\n-  private Object[] keyContents;\n-  private boolean containsINkeys;\n-\n-  public PullFilterNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final Expression predicate,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final boolean isWindowed\n-  ) {\n-    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n-\n-    Objects.requireNonNull(predicate, \"predicate\");\n-    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n-    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n-    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n-    this.isWindowed = isWindowed;\n-\n-    // Basic validation of WHERE clause\n-    validateWhereClause();\n-\n-    // Validation and extractions of window bounds\n-    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n-\n-    // Extraction of key and system columns\n-    extractKeysAndSystemCols();\n-\n-    // Extraction of key values\n-    keyValues = extractKeyValues();\n-\n-    // Compiling expression into byte code\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n-        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n-    compiledWhereClause = CodeGenRunner.compileExpression(\n-        rewrittenPredicate,\n-        \"Predicate\",\n-        intermediateSchema,\n-        ksqlConfig,\n-        metaStore\n-    );\n-\n-  }\n-\n-  public Expression getRewrittenPredicate() {\n-    return rewrittenPredicate;\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return getSource().getSchema();\n-  }\n-\n-  @Override\n-  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  public ExpressionMetadata getCompiledWhereClause() {\n-    return compiledWhereClause;\n-  }\n-\n-  public boolean isKeyedQuery() {\n-    return isKeyedQuery;\n-  }\n-\n-  public boolean isWindowed() {\n-    return isWindowed;\n-  }\n-\n-  public List<GenericKey> getKeyValues() {\n-    return keyValues;\n-  }\n-\n-  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n-    return keyColumns;\n-  }\n-\n-  public Optional<WindowBounds> getWindowBounds() {\n-    return windowBounds;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  private void validateWhereClause() {\n-    seenKeys = new BitSet(schema.key().size());\n-    final Validator validator = new Validator();\n-    validator.process(rewrittenPredicate, null);\n-    if (!isKeyedQuery) {\n-      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n-    }\n-\n-    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n-      final List<ColumnName> seenKeyNames = seenKeys\n-          .stream()\n-          .boxed()\n-          .map(i -> schema.key().get(i))\n-          .map(Column::name)\n-          .collect(Collectors.toList());\n-      throw invalidWhereClauseException(\n-          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n-              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n-    }\n-  }\n-\n-  private void extractKeysAndSystemCols() {\n-    keyColumns = new HashSet<>();\n-    systemColumns = new HashSet<>();\n-    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n-  }\n-\n-  private List<GenericKey> extractKeyValues() {\n-    inKeys = new ArrayList<>();\n-    keyContents = new Object[schema.key().size()];\n-    seenKeys = new BitSet(schema.key().size());\n-\n-    new KeyValueExtractor().process(rewrittenPredicate, null);\n-    if (!inKeys.isEmpty()) {\n-      return (inKeys);\n-    }\n-\n-    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n-  }\n-\n-  private WindowBounds extractWindowBounds() {\n-    final WindowBounds windowBounds = new WindowBounds();\n-\n-    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n-    return windowBounds;\n-  }\n-\n-  /**\n-   * Validate the WHERE clause for pull queries.\n-   * 1. There must be exactly one equality condition per key\n-   * or one IN predicate that involves a key.\n-   * 2. An IN predicate can refer to a single key.\n-   * 3. The IN predicate cannot be combined with other conditions.\n-   * 4. Only AND is allowed.\n-   * 5. If there is a multi-key, conditions on all keys must be specified.\n-   * 6. The IN predicate cannot use multi-keys.\n-   */\n-  private final class Validator extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void process(final Expression node, final Object context) {\n-      if (!(node instanceof  LogicalBinaryExpression)\n-          && !(node instanceof  ComparisonExpression)\n-          && !(node instanceof  InPredicate)) {\n-        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n-      }\n-      super.process(node, context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitLogicalBinaryExpression(\n-        final LogicalBinaryExpression node,\n-        final Object context\n-    ) {\n-      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n-        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n-      }\n-      process(node.getLeft(), context);\n-      process(node.getRight(), context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final Object context\n-    ) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-\n-      final ColumnName columnName = column.getColumnName();\n-      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n-          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n-        final Type type = node.getType();\n-        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n-          throw invalidWhereClauseException(\n-              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n-        }\n-        if (!isWindowed) {\n-          throw invalidWhereClauseException(\n-              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n-              false);\n-        }\n-        return null;\n-      } else {\n-        final Column col = schema.findColumn(columnName)\n-            .orElseThrow(() -> invalidWhereClauseException(\n-                \"Bound on non-key column \" + columnName, isWindowed));\n-\n-        if (col.namespace() == Namespace.KEY) {\n-          if (node.getType() != Type.EQUAL) {\n-            throw invalidWhereClauseException(\n-                \"Bound on key columns '\" + getSource().getSchema().key()\n-                    + \"' must currently be '='\",\n-                isWindowed);\n-          }\n-          if (containsINkeys || seenKeys.get(col.index())) {\n-            throw invalidWhereClauseException(\n-                \"An equality condition on the key column cannot be combined with other comparisons\"\n-                    + \" such as an IN predicate\",\n-                isWindowed);\n-          }\n-          seenKeys.set(col.index());\n-          isKeyedQuery = true;\n-          return null;\n-        }\n-\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on non-key column: \" + columnName.text(),\n-            false\n-        );\n-      }\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node,\n-        final Object context\n-    ) {\n-      if (schema.key().size() > 1) {\n-        throw invalidWhereClauseException(\n-            \"Schemas with multiple KEY columns are not supported for IN predicates\", false);\n-      }\n-\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        if (!seenKeys.isEmpty()) {\n-          throw invalidWhereClauseException(\n-              \"The IN predicate cannot be combined with other comparisons on the key column\",\n-              isWindowed);\n-        }\n-        containsINkeys = true;\n-        isKeyedQuery = true;\n-      } else {\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on unsupported column: \" + column.getColumnName().text(),\n-            false\n-        );\n-      }\n-      return null;\n-    }\n-  }\n-\n-  private UnqualifiedColumnReferenceExp getColumnRefSide(final ComparisonExpression comp) {\n-    return (UnqualifiedColumnReferenceExp)\n-        (comp.getRight() instanceof UnqualifiedColumnReferenceExp\n-            ? comp.getRight() : comp.getLeft());\n-  }\n-\n-  private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-    return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-        ? comparison.getLeft()\n-        : comparison.getRight();\n-  }\n-\n-  /**\n-   * Extracts the key and system columns that appear in the WHERE clause.\n-   */\n-  private final class KeyAndSystemColsExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitUnqualifiedColumnReference(\n-        final UnqualifiedColumnReferenceExp node, final Object context) {\n-      final Optional<Column> col = schema.findColumn(node.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        keyColumns.add(node);\n-      } else if (SystemColumns.isSystemColumn(node.getColumnName())) {\n-        systemColumns.add(node);\n-      }\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * Extracts the values for the keys that appear in the WHERE clause.\n-   * Necessary so that we can do key lookups when scanning the data stores.\n-   */\n-  private final class KeyValueExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-      final Expression other = getNonColumnRefSide(node);\n-      final ColumnName columnName = column.getColumnName();\n-\n-      final Optional<Column> col = schema.findColumn(columnName);\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        final Object key = resolveKey(other, col.get(), metaStore, ksqlConfig, node);\n-        keyContents[col.get().index()] = key;\n-        seenKeys.set(col.get().index());\n-      }\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        inKeys.addAll(node.getValueList()\n-            .getValues()\n-            .stream()\n-            .map(expression -> resolveKey(expression, col.get(), metaStore, ksqlConfig, node))\n-            .map(GenericKey::genericKey)\n-            .collect(Collectors.toList()));\n-      }\n-      return null;\n-    }\n-\n-    private Object resolveKey(\n-        final Expression exp,\n-        final Column keyColumn,\n-        final MetaStore metaStore,\n-        final KsqlConfig config,\n-        final Expression errorMessageHint\n-    ) {\n-      final Object obj;\n-      if (exp instanceof NullLiteral) {\n-        obj = null;\n-      } else if (exp instanceof Literal) {\n-        // skip the GenericExpressionResolver because this is\n-        // a critical code path executed once-per-query\n-        obj = ((Literal) exp).getValue();\n-      } else {\n-        obj = new GenericExpressionResolver(\n-            keyColumn.type(),\n-            keyColumn.name(),\n-            metaStore,\n-            config,\n-            \"pull query\"\n-        ).resolve(exp);\n-      }\n-\n-      if (obj == null) {\n-        throw new KsqlException(\"Primary key columns can not be NULL: \" + errorMessageHint);\n-      }\n-\n-      return DefaultSqlValueCoercer.STRICT.coerce(obj, keyColumn.type())\n-          .orElseThrow(() -> new KsqlException(\n-              \"'\" + obj + \"' can not be converted \"\n-                  + \"to the type of the key column: \"\n-                  + keyColumn.toString(\n-                  FormatOptions.noEscape())))\n-          .orElse(null);\n-    }\n-  }\n-\n-\n-  /**\n-   * Extracts the upper and lower bounds on windowstart/windowend columns.\n-   * Performs the following validations on the window bounds:\n-   * 1. An equality bound cannot be combined with other bounds.\n-   * 2. No duplicate bounds are allowed, such as multiple greater than bounds.\n-   */\n-  private final class WindowBoundsExtractor extends TraversalExpressionVisitor<WindowBounds> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final WindowBounds windowBounds\n-    ) {\n-      final UnqualifiedColumnReferenceExp column;\n-      if (node.getRight() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getRight();\n-      } else if (node.getLeft() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getLeft();\n-      } else {\n-        return null;\n-      }\n-\n-      if (!column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)\n-          && !column.getColumnName().equals(SystemColumns.WINDOWEND_NAME)) {\n-        return null;\n-      }\n-      boolean result = false;\n-      if (node.getType().equals(Type.EQUAL)) {\n-        final Range<Instant> instant = Range.singleton(asInstant(getNonColumnRefSide(node)));\n-        result = windowBounds.setEquality(column, instant);\n-      }\n-      final Type type = getSimplifiedBoundType(node);\n-\n-      if (type.equals(Type.LESS_THAN)) {\n-        final Instant upper = asInstant(getNonColumnRefSide(node));\n-        final BoundType upperType = getRangeBoundType(node);\n-        result = windowBounds.setUpper(column, Range.upTo(upper, upperType));\n-      } else if (type.equals(Type.GREATER_THAN)) {\n-        final Instant lower = asInstant(getNonColumnRefSide(node));\n-        final BoundType lowerType = getRangeBoundType(node);\n-        result = windowBounds.setLower(column, Range.downTo(lower, lowerType));\n-      }\n-      validateEqualityBound(windowBounds, node, column);\n-      if (!result) {\n-        throw invalidWhereClauseException(\n-            \"Duplicate \" + column.getColumnName() + \" bounds on: \" + type, true);\n-      }\n-      return null;\n-    }\n-\n-    private void validateEqualityBound(\n-        final WindowBounds bound,\n-        final ComparisonExpression expression,\n-        final UnqualifiedColumnReferenceExp column\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (bound.getStart().getEqual() != null\n-            && (bound.getStart().getUpper() != null || bound.getStart().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-        }\n-      } else {\n-        if (bound.getEnd().getEqual() != null\n-            && (bound.getEnd().getUpper() != null || bound.getEnd().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-\n-        }\n-      }\n-    }\n-\n-    private Type getSimplifiedBoundType(final ComparisonExpression comparison) {\n-      final Type type = comparison.getType();\n-      final boolean inverted = comparison.getRight() instanceof UnqualifiedColumnReferenceExp;\n-\n-      switch (type) {\n-        case LESS_THAN:\n-        case LESS_THAN_OR_EQUAL:\n-          return inverted ? Type.GREATER_THAN : Type.LESS_THAN;\n-        case GREATER_THAN:\n-        case GREATER_THAN_OR_EQUAL:\n-          return inverted ? Type.LESS_THAN : Type.GREATER_THAN;\n-        default:\n-          return type;\n-      }\n-    }\n-\n-    private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-      return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-          ? comparison.getLeft()\n-          : comparison.getRight();\n-    }\n-\n-    private Instant asInstant(final Expression other) {\n-      if (other instanceof IntegerLiteral) {\n-        return Instant.ofEpochMilli(((IntegerLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof LongLiteral) {\n-        return Instant.ofEpochMilli(((LongLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof StringLiteral) {\n-        final String text = ((StringLiteral) other).getValue();\n-        try {\n-          final long timestamp = new PartialStringToTimestampParser()\n-              .parse(text);\n-\n-          return Instant.ofEpochMilli(timestamp);\n-        } catch (final Exception e) {\n-          throw invalidWhereClauseException(\"Failed to parse datetime: \" + text, true);\n-        }\n-      }\n-\n-      throw invalidWhereClauseException(\n-          \"Window bounds must be an INT, BIGINT or STRING containing a datetime.\",\n-          true\n-      );\n-    }\n-\n-    private BoundType getRangeBoundType(final ComparisonExpression lowerComparison) {\n-      final boolean openBound = lowerComparison.getType() == Type.LESS_THAN\n-          || lowerComparison.getType() == Type.GREATER_THAN;\n-\n-      return openBound\n-          ? BoundType.OPEN\n-          : BoundType.CLOSED;\n-    }\n-  }\n-\n-  private KsqlException invalidWhereClauseException(\n-      final String msg,\n-      final boolean windowed\n-  ) {\n-    final String additional = !windowed\n-        ? \"\"\n-        : System.lineSeparator()\n-            + \" - (optionally) limits the time bounds of the windowed table.\"\n-            + System.lineSeparator()\n-            + \"\\t Bounds on \" + SystemColumns.windowBoundsColumnNames() + \" are supported\"\n-            + System.lineSeparator()\n-            + \"\\t Supported operators are \" + VALID_WINDOW_BOUND_COMPARISONS;\n-\n-    return new KsqlException(\n-        msg\n-            + \". \"\n-            + PullQueryValidator.PULL_QUERY_SYNTAX_HELP\n-            + System.lineSeparator()\n-            + \"Pull queries require a WHERE clause that:\"\n-            + System.lineSeparator()\n-            + \" - limits the query to keys only, e.g. `SELECT * FROM X WHERE <key-column>=Y;`.\"\n-            + System.lineSeparator()\n-            + \" - specifies an equality condition that is a conjunction of equality expressions \"\n-            + \"that cover all keys.\"\n-            + additional\n-    );\n-  }\n-\n-  public static final class WindowBounds {\n-\n-    private WindowRange start;\n-    private WindowRange end;\n-\n-    public WindowBounds(final WindowRange start, final WindowRange end) {\n-      this.start = Objects.requireNonNull(start, \"startBounds\");\n-      this.end = Objects.requireNonNull(end, \"endBounds\");\n-    }\n-\n-    public WindowBounds() {\n-      this.start = new WindowRange();\n-      this.end = new WindowRange();\n-    }\n-\n-    boolean setEquality(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.equal != null) {\n-          return false;\n-        }\n-        start.equal = range;\n-      } else {\n-        if (end.equal != null) {\n-          return false;\n-        }\n-        end.equal = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setUpper(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.upper != null) {\n-          return false;\n-        }\n-        start.upper = range;\n-      } else {\n-        if (end.upper != null) {\n-          return false;\n-        }\n-        end.upper = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setLower(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.lower != null) {\n-          return false;\n-        }\n-        start.lower = range;\n-      } else {\n-        if (end.lower != null) {\n-          return false;\n-        }\n-        end.lower = range;\n-      }\n-      return true;\n-    }\n-\n-    public WindowRange getStart() {\n-      return start;\n-    }\n-\n-    public WindowRange getEnd() {\n-      return end;\n-    }\n-\n-    public Range<Instant> getMergedStart() {\n-      return start.getMergedRange();\n-    }\n-\n-    public Range<Instant> getMergedEnd() {\n-      return end.getMergedRange();\n-    }\n-\n-\n-    @Override\n-    public boolean equals(final Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      final WindowBounds that = (WindowBounds) o;\n-      return Objects.equals(start, that.start)\n-          && Objects.equals(end, that.end);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hash(start, end);\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"WindowBounds{\"\n-          + \"start=\" + start\n-          + \", end=\" + end\n-          + '}';\n-    }\n-\n-    static final class WindowRange {\n-      private Range<Instant> equal;\n-      private Range<Instant> upper;\n-      private Range<Instant> lower;\n-\n-      WindowRange(\n-          final Range<Instant> equal,\n-          final Range<Instant> upper,\n-          final Range<Instant> lower\n-      ) {\n-        this.equal = equal;\n-        this.upper = upper;\n-        this.lower = lower;\n-      }\n-\n-      WindowRange() {\n-      }\n-\n-      public Range<Instant> getEqual() {\n-        return equal;\n-      }\n-\n-      public Range<Instant> getUpper() {\n-        return upper;\n-      }\n-\n-      public Range<Instant> getLower() {\n-        return lower;\n-      }\n-\n-      Range<Instant> getMergedRange() {\n-        if (lower == null && upper == null && equal == null) {\n-          return Range.all();\n-        }\n-        if (lower != null && upper != null) {\n-          return Range.range(\n-              lower.lowerEndpoint(), lower.lowerBoundType(),\n-              upper.upperEndpoint(), upper.upperBoundType()\n-          );\n-        }\n-        if (upper != null) {\n-          return upper;\n-        }\n-        if (lower != null) {\n-          return lower;\n-        }\n-        return equal;\n-      }\n-\n-      @Override\n-      public boolean equals(final Object o) {\n-        if (this == o) {\n-          return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-          return false;\n-        }\n-\n-        final WindowRange that = (WindowRange) o;\n-        return Objects.equals(equal, that.equal)\n-            && Objects.equals(upper, that.upper)\n-            && Objects.equals(lower, that.lower);\n-      }\n-\n-      @Override\n-      public int hashCode() {\n-        return Objects.hash(equal, upper, lower);\n-      }\n-\n-      @Override\n-      public String toString() {\n-        return \"WindowRange{\"\n-            + \"equal=\" + equal\n-            + \", upper=\" + upper\n-            + \", lower=\" + lower\n-            + '}';\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = !systemColumns.isEmpty();\n-\n-    final boolean hasKeyColumns = !keyColumns.isEmpty();\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3MDUwNw==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551470507", "bodyText": "From my understanding of reading the code, this is the list of possible in predicate values since just one in predicate is allowed whereas keyContents and seenKeys are solely set for comparisons, right?\nAlso, presumably, as before this change, multi column lookups are still only supported with comparisons, right?\nIt would be good to get a bit more comments that state these things because it's getting a bit hard to follow.", "author": "AlanConfluent", "createdAt": "2021-01-04T17:50:58Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());\n+    final Validator validator = new Validator();\n+    validator.process(rewrittenPredicate, null);\n+    if (!isKeyedQuery) {\n+      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n+    }\n+\n+    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n+      final List<ColumnName> seenKeyNames = seenKeys\n+          .stream()\n+          .boxed()\n+          .map(i -> schema.key().get(i))\n+          .map(Column::name)\n+          .collect(Collectors.toList());\n+      throw invalidWhereClauseException(\n+          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n+              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n+    }\n+  }\n+\n+  private void extractKeysAndSystemCols() {\n+    keyColumns = new HashSet<>();\n+    systemColumns = new HashSet<>();\n+    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n+  }\n+\n+  private List<GenericKey> extractKeyValues() {\n+    inKeys = new ArrayList<>();", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\ndeleted file mode 100644\nindex 13d9328c3b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\n+++ /dev/null\n\n@@ -1,823 +0,0 @@\n-/*\n- * Copyright 2019 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.collect.BoundType;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Range;\n-import io.confluent.ksql.GenericKey;\n-import io.confluent.ksql.analyzer.PullQueryValidator;\n-import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n-import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n-import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n-import io.confluent.ksql.execution.expression.tree.Expression;\n-import io.confluent.ksql.execution.expression.tree.InPredicate;\n-import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n-import io.confluent.ksql.execution.expression.tree.Literal;\n-import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n-import io.confluent.ksql.execution.expression.tree.LongLiteral;\n-import io.confluent.ksql.execution.expression.tree.NullLiteral;\n-import io.confluent.ksql.execution.expression.tree.StringLiteral;\n-import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n-import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.name.ColumnName;\n-import io.confluent.ksql.schema.ksql.Column;\n-import io.confluent.ksql.schema.ksql.Column.Namespace;\n-import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.utils.FormatOptions;\n-import io.confluent.ksql.structured.SchemaKStream;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class PullFilterNode extends SingleSourcePlanNode {\n-\n-  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n-      Type.EQUAL,\n-      Type.GREATER_THAN,\n-      Type.GREATER_THAN_OR_EQUAL,\n-      Type.LESS_THAN,\n-      Type.LESS_THAN_OR_EQUAL\n-  );\n-\n-  private final boolean isWindowed;\n-  private final ExpressionMetadata compiledWhereClause;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final MetaStore metaStore;\n-  private final KsqlConfig ksqlConfig;\n-  private final LogicalSchema schema = getSource().getSchema();\n-\n-  private Expression rewrittenPredicate;\n-  private boolean isKeyedQuery = false;\n-  private Optional<WindowBounds> windowBounds;\n-  private List<GenericKey> keyValues;\n-  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n-  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n-  private List<GenericKey> inKeys;\n-  private BitSet seenKeys;\n-  private Object[] keyContents;\n-  private boolean containsINkeys;\n-\n-  public PullFilterNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final Expression predicate,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final boolean isWindowed\n-  ) {\n-    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n-\n-    Objects.requireNonNull(predicate, \"predicate\");\n-    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n-    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n-    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n-    this.isWindowed = isWindowed;\n-\n-    // Basic validation of WHERE clause\n-    validateWhereClause();\n-\n-    // Validation and extractions of window bounds\n-    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n-\n-    // Extraction of key and system columns\n-    extractKeysAndSystemCols();\n-\n-    // Extraction of key values\n-    keyValues = extractKeyValues();\n-\n-    // Compiling expression into byte code\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n-        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n-    compiledWhereClause = CodeGenRunner.compileExpression(\n-        rewrittenPredicate,\n-        \"Predicate\",\n-        intermediateSchema,\n-        ksqlConfig,\n-        metaStore\n-    );\n-\n-  }\n-\n-  public Expression getRewrittenPredicate() {\n-    return rewrittenPredicate;\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return getSource().getSchema();\n-  }\n-\n-  @Override\n-  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  public ExpressionMetadata getCompiledWhereClause() {\n-    return compiledWhereClause;\n-  }\n-\n-  public boolean isKeyedQuery() {\n-    return isKeyedQuery;\n-  }\n-\n-  public boolean isWindowed() {\n-    return isWindowed;\n-  }\n-\n-  public List<GenericKey> getKeyValues() {\n-    return keyValues;\n-  }\n-\n-  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n-    return keyColumns;\n-  }\n-\n-  public Optional<WindowBounds> getWindowBounds() {\n-    return windowBounds;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  private void validateWhereClause() {\n-    seenKeys = new BitSet(schema.key().size());\n-    final Validator validator = new Validator();\n-    validator.process(rewrittenPredicate, null);\n-    if (!isKeyedQuery) {\n-      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n-    }\n-\n-    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n-      final List<ColumnName> seenKeyNames = seenKeys\n-          .stream()\n-          .boxed()\n-          .map(i -> schema.key().get(i))\n-          .map(Column::name)\n-          .collect(Collectors.toList());\n-      throw invalidWhereClauseException(\n-          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n-              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n-    }\n-  }\n-\n-  private void extractKeysAndSystemCols() {\n-    keyColumns = new HashSet<>();\n-    systemColumns = new HashSet<>();\n-    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n-  }\n-\n-  private List<GenericKey> extractKeyValues() {\n-    inKeys = new ArrayList<>();\n-    keyContents = new Object[schema.key().size()];\n-    seenKeys = new BitSet(schema.key().size());\n-\n-    new KeyValueExtractor().process(rewrittenPredicate, null);\n-    if (!inKeys.isEmpty()) {\n-      return (inKeys);\n-    }\n-\n-    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n-  }\n-\n-  private WindowBounds extractWindowBounds() {\n-    final WindowBounds windowBounds = new WindowBounds();\n-\n-    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n-    return windowBounds;\n-  }\n-\n-  /**\n-   * Validate the WHERE clause for pull queries.\n-   * 1. There must be exactly one equality condition per key\n-   * or one IN predicate that involves a key.\n-   * 2. An IN predicate can refer to a single key.\n-   * 3. The IN predicate cannot be combined with other conditions.\n-   * 4. Only AND is allowed.\n-   * 5. If there is a multi-key, conditions on all keys must be specified.\n-   * 6. The IN predicate cannot use multi-keys.\n-   */\n-  private final class Validator extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void process(final Expression node, final Object context) {\n-      if (!(node instanceof  LogicalBinaryExpression)\n-          && !(node instanceof  ComparisonExpression)\n-          && !(node instanceof  InPredicate)) {\n-        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n-      }\n-      super.process(node, context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitLogicalBinaryExpression(\n-        final LogicalBinaryExpression node,\n-        final Object context\n-    ) {\n-      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n-        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n-      }\n-      process(node.getLeft(), context);\n-      process(node.getRight(), context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final Object context\n-    ) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-\n-      final ColumnName columnName = column.getColumnName();\n-      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n-          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n-        final Type type = node.getType();\n-        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n-          throw invalidWhereClauseException(\n-              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n-        }\n-        if (!isWindowed) {\n-          throw invalidWhereClauseException(\n-              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n-              false);\n-        }\n-        return null;\n-      } else {\n-        final Column col = schema.findColumn(columnName)\n-            .orElseThrow(() -> invalidWhereClauseException(\n-                \"Bound on non-key column \" + columnName, isWindowed));\n-\n-        if (col.namespace() == Namespace.KEY) {\n-          if (node.getType() != Type.EQUAL) {\n-            throw invalidWhereClauseException(\n-                \"Bound on key columns '\" + getSource().getSchema().key()\n-                    + \"' must currently be '='\",\n-                isWindowed);\n-          }\n-          if (containsINkeys || seenKeys.get(col.index())) {\n-            throw invalidWhereClauseException(\n-                \"An equality condition on the key column cannot be combined with other comparisons\"\n-                    + \" such as an IN predicate\",\n-                isWindowed);\n-          }\n-          seenKeys.set(col.index());\n-          isKeyedQuery = true;\n-          return null;\n-        }\n-\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on non-key column: \" + columnName.text(),\n-            false\n-        );\n-      }\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node,\n-        final Object context\n-    ) {\n-      if (schema.key().size() > 1) {\n-        throw invalidWhereClauseException(\n-            \"Schemas with multiple KEY columns are not supported for IN predicates\", false);\n-      }\n-\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        if (!seenKeys.isEmpty()) {\n-          throw invalidWhereClauseException(\n-              \"The IN predicate cannot be combined with other comparisons on the key column\",\n-              isWindowed);\n-        }\n-        containsINkeys = true;\n-        isKeyedQuery = true;\n-      } else {\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on unsupported column: \" + column.getColumnName().text(),\n-            false\n-        );\n-      }\n-      return null;\n-    }\n-  }\n-\n-  private UnqualifiedColumnReferenceExp getColumnRefSide(final ComparisonExpression comp) {\n-    return (UnqualifiedColumnReferenceExp)\n-        (comp.getRight() instanceof UnqualifiedColumnReferenceExp\n-            ? comp.getRight() : comp.getLeft());\n-  }\n-\n-  private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-    return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-        ? comparison.getLeft()\n-        : comparison.getRight();\n-  }\n-\n-  /**\n-   * Extracts the key and system columns that appear in the WHERE clause.\n-   */\n-  private final class KeyAndSystemColsExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitUnqualifiedColumnReference(\n-        final UnqualifiedColumnReferenceExp node, final Object context) {\n-      final Optional<Column> col = schema.findColumn(node.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        keyColumns.add(node);\n-      } else if (SystemColumns.isSystemColumn(node.getColumnName())) {\n-        systemColumns.add(node);\n-      }\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * Extracts the values for the keys that appear in the WHERE clause.\n-   * Necessary so that we can do key lookups when scanning the data stores.\n-   */\n-  private final class KeyValueExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-      final Expression other = getNonColumnRefSide(node);\n-      final ColumnName columnName = column.getColumnName();\n-\n-      final Optional<Column> col = schema.findColumn(columnName);\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        final Object key = resolveKey(other, col.get(), metaStore, ksqlConfig, node);\n-        keyContents[col.get().index()] = key;\n-        seenKeys.set(col.get().index());\n-      }\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        inKeys.addAll(node.getValueList()\n-            .getValues()\n-            .stream()\n-            .map(expression -> resolveKey(expression, col.get(), metaStore, ksqlConfig, node))\n-            .map(GenericKey::genericKey)\n-            .collect(Collectors.toList()));\n-      }\n-      return null;\n-    }\n-\n-    private Object resolveKey(\n-        final Expression exp,\n-        final Column keyColumn,\n-        final MetaStore metaStore,\n-        final KsqlConfig config,\n-        final Expression errorMessageHint\n-    ) {\n-      final Object obj;\n-      if (exp instanceof NullLiteral) {\n-        obj = null;\n-      } else if (exp instanceof Literal) {\n-        // skip the GenericExpressionResolver because this is\n-        // a critical code path executed once-per-query\n-        obj = ((Literal) exp).getValue();\n-      } else {\n-        obj = new GenericExpressionResolver(\n-            keyColumn.type(),\n-            keyColumn.name(),\n-            metaStore,\n-            config,\n-            \"pull query\"\n-        ).resolve(exp);\n-      }\n-\n-      if (obj == null) {\n-        throw new KsqlException(\"Primary key columns can not be NULL: \" + errorMessageHint);\n-      }\n-\n-      return DefaultSqlValueCoercer.STRICT.coerce(obj, keyColumn.type())\n-          .orElseThrow(() -> new KsqlException(\n-              \"'\" + obj + \"' can not be converted \"\n-                  + \"to the type of the key column: \"\n-                  + keyColumn.toString(\n-                  FormatOptions.noEscape())))\n-          .orElse(null);\n-    }\n-  }\n-\n-\n-  /**\n-   * Extracts the upper and lower bounds on windowstart/windowend columns.\n-   * Performs the following validations on the window bounds:\n-   * 1. An equality bound cannot be combined with other bounds.\n-   * 2. No duplicate bounds are allowed, such as multiple greater than bounds.\n-   */\n-  private final class WindowBoundsExtractor extends TraversalExpressionVisitor<WindowBounds> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final WindowBounds windowBounds\n-    ) {\n-      final UnqualifiedColumnReferenceExp column;\n-      if (node.getRight() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getRight();\n-      } else if (node.getLeft() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getLeft();\n-      } else {\n-        return null;\n-      }\n-\n-      if (!column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)\n-          && !column.getColumnName().equals(SystemColumns.WINDOWEND_NAME)) {\n-        return null;\n-      }\n-      boolean result = false;\n-      if (node.getType().equals(Type.EQUAL)) {\n-        final Range<Instant> instant = Range.singleton(asInstant(getNonColumnRefSide(node)));\n-        result = windowBounds.setEquality(column, instant);\n-      }\n-      final Type type = getSimplifiedBoundType(node);\n-\n-      if (type.equals(Type.LESS_THAN)) {\n-        final Instant upper = asInstant(getNonColumnRefSide(node));\n-        final BoundType upperType = getRangeBoundType(node);\n-        result = windowBounds.setUpper(column, Range.upTo(upper, upperType));\n-      } else if (type.equals(Type.GREATER_THAN)) {\n-        final Instant lower = asInstant(getNonColumnRefSide(node));\n-        final BoundType lowerType = getRangeBoundType(node);\n-        result = windowBounds.setLower(column, Range.downTo(lower, lowerType));\n-      }\n-      validateEqualityBound(windowBounds, node, column);\n-      if (!result) {\n-        throw invalidWhereClauseException(\n-            \"Duplicate \" + column.getColumnName() + \" bounds on: \" + type, true);\n-      }\n-      return null;\n-    }\n-\n-    private void validateEqualityBound(\n-        final WindowBounds bound,\n-        final ComparisonExpression expression,\n-        final UnqualifiedColumnReferenceExp column\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (bound.getStart().getEqual() != null\n-            && (bound.getStart().getUpper() != null || bound.getStart().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-        }\n-      } else {\n-        if (bound.getEnd().getEqual() != null\n-            && (bound.getEnd().getUpper() != null || bound.getEnd().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-\n-        }\n-      }\n-    }\n-\n-    private Type getSimplifiedBoundType(final ComparisonExpression comparison) {\n-      final Type type = comparison.getType();\n-      final boolean inverted = comparison.getRight() instanceof UnqualifiedColumnReferenceExp;\n-\n-      switch (type) {\n-        case LESS_THAN:\n-        case LESS_THAN_OR_EQUAL:\n-          return inverted ? Type.GREATER_THAN : Type.LESS_THAN;\n-        case GREATER_THAN:\n-        case GREATER_THAN_OR_EQUAL:\n-          return inverted ? Type.LESS_THAN : Type.GREATER_THAN;\n-        default:\n-          return type;\n-      }\n-    }\n-\n-    private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-      return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-          ? comparison.getLeft()\n-          : comparison.getRight();\n-    }\n-\n-    private Instant asInstant(final Expression other) {\n-      if (other instanceof IntegerLiteral) {\n-        return Instant.ofEpochMilli(((IntegerLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof LongLiteral) {\n-        return Instant.ofEpochMilli(((LongLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof StringLiteral) {\n-        final String text = ((StringLiteral) other).getValue();\n-        try {\n-          final long timestamp = new PartialStringToTimestampParser()\n-              .parse(text);\n-\n-          return Instant.ofEpochMilli(timestamp);\n-        } catch (final Exception e) {\n-          throw invalidWhereClauseException(\"Failed to parse datetime: \" + text, true);\n-        }\n-      }\n-\n-      throw invalidWhereClauseException(\n-          \"Window bounds must be an INT, BIGINT or STRING containing a datetime.\",\n-          true\n-      );\n-    }\n-\n-    private BoundType getRangeBoundType(final ComparisonExpression lowerComparison) {\n-      final boolean openBound = lowerComparison.getType() == Type.LESS_THAN\n-          || lowerComparison.getType() == Type.GREATER_THAN;\n-\n-      return openBound\n-          ? BoundType.OPEN\n-          : BoundType.CLOSED;\n-    }\n-  }\n-\n-  private KsqlException invalidWhereClauseException(\n-      final String msg,\n-      final boolean windowed\n-  ) {\n-    final String additional = !windowed\n-        ? \"\"\n-        : System.lineSeparator()\n-            + \" - (optionally) limits the time bounds of the windowed table.\"\n-            + System.lineSeparator()\n-            + \"\\t Bounds on \" + SystemColumns.windowBoundsColumnNames() + \" are supported\"\n-            + System.lineSeparator()\n-            + \"\\t Supported operators are \" + VALID_WINDOW_BOUND_COMPARISONS;\n-\n-    return new KsqlException(\n-        msg\n-            + \". \"\n-            + PullQueryValidator.PULL_QUERY_SYNTAX_HELP\n-            + System.lineSeparator()\n-            + \"Pull queries require a WHERE clause that:\"\n-            + System.lineSeparator()\n-            + \" - limits the query to keys only, e.g. `SELECT * FROM X WHERE <key-column>=Y;`.\"\n-            + System.lineSeparator()\n-            + \" - specifies an equality condition that is a conjunction of equality expressions \"\n-            + \"that cover all keys.\"\n-            + additional\n-    );\n-  }\n-\n-  public static final class WindowBounds {\n-\n-    private WindowRange start;\n-    private WindowRange end;\n-\n-    public WindowBounds(final WindowRange start, final WindowRange end) {\n-      this.start = Objects.requireNonNull(start, \"startBounds\");\n-      this.end = Objects.requireNonNull(end, \"endBounds\");\n-    }\n-\n-    public WindowBounds() {\n-      this.start = new WindowRange();\n-      this.end = new WindowRange();\n-    }\n-\n-    boolean setEquality(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.equal != null) {\n-          return false;\n-        }\n-        start.equal = range;\n-      } else {\n-        if (end.equal != null) {\n-          return false;\n-        }\n-        end.equal = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setUpper(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.upper != null) {\n-          return false;\n-        }\n-        start.upper = range;\n-      } else {\n-        if (end.upper != null) {\n-          return false;\n-        }\n-        end.upper = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setLower(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.lower != null) {\n-          return false;\n-        }\n-        start.lower = range;\n-      } else {\n-        if (end.lower != null) {\n-          return false;\n-        }\n-        end.lower = range;\n-      }\n-      return true;\n-    }\n-\n-    public WindowRange getStart() {\n-      return start;\n-    }\n-\n-    public WindowRange getEnd() {\n-      return end;\n-    }\n-\n-    public Range<Instant> getMergedStart() {\n-      return start.getMergedRange();\n-    }\n-\n-    public Range<Instant> getMergedEnd() {\n-      return end.getMergedRange();\n-    }\n-\n-\n-    @Override\n-    public boolean equals(final Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      final WindowBounds that = (WindowBounds) o;\n-      return Objects.equals(start, that.start)\n-          && Objects.equals(end, that.end);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hash(start, end);\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"WindowBounds{\"\n-          + \"start=\" + start\n-          + \", end=\" + end\n-          + '}';\n-    }\n-\n-    static final class WindowRange {\n-      private Range<Instant> equal;\n-      private Range<Instant> upper;\n-      private Range<Instant> lower;\n-\n-      WindowRange(\n-          final Range<Instant> equal,\n-          final Range<Instant> upper,\n-          final Range<Instant> lower\n-      ) {\n-        this.equal = equal;\n-        this.upper = upper;\n-        this.lower = lower;\n-      }\n-\n-      WindowRange() {\n-      }\n-\n-      public Range<Instant> getEqual() {\n-        return equal;\n-      }\n-\n-      public Range<Instant> getUpper() {\n-        return upper;\n-      }\n-\n-      public Range<Instant> getLower() {\n-        return lower;\n-      }\n-\n-      Range<Instant> getMergedRange() {\n-        if (lower == null && upper == null && equal == null) {\n-          return Range.all();\n-        }\n-        if (lower != null && upper != null) {\n-          return Range.range(\n-              lower.lowerEndpoint(), lower.lowerBoundType(),\n-              upper.upperEndpoint(), upper.upperBoundType()\n-          );\n-        }\n-        if (upper != null) {\n-          return upper;\n-        }\n-        if (lower != null) {\n-          return lower;\n-        }\n-        return equal;\n-      }\n-\n-      @Override\n-      public boolean equals(final Object o) {\n-        if (this == o) {\n-          return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-          return false;\n-        }\n-\n-        final WindowRange that = (WindowRange) o;\n-        return Objects.equals(equal, that.equal)\n-            && Objects.equals(upper, that.upper)\n-            && Objects.equals(lower, that.lower);\n-      }\n-\n-      @Override\n-      public int hashCode() {\n-        return Objects.hash(equal, upper, lower);\n-      }\n-\n-      @Override\n-      public String toString() {\n-        return \"WindowRange{\"\n-            + \"equal=\" + equal\n-            + \", upper=\" + upper\n-            + \", lower=\" + lower\n-            + '}';\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = !systemColumns.isEmpty();\n-\n-    final boolean hasKeyColumns = !keyColumns.isEmpty();\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3MTIxMQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551471211", "bodyText": "If this is only used in the validator, why not make it a field there?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:52:24Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\ndeleted file mode 100644\nindex 13d9328c3b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\n+++ /dev/null\n\n@@ -1,823 +0,0 @@\n-/*\n- * Copyright 2019 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.collect.BoundType;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Range;\n-import io.confluent.ksql.GenericKey;\n-import io.confluent.ksql.analyzer.PullQueryValidator;\n-import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n-import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n-import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n-import io.confluent.ksql.execution.expression.tree.Expression;\n-import io.confluent.ksql.execution.expression.tree.InPredicate;\n-import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n-import io.confluent.ksql.execution.expression.tree.Literal;\n-import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n-import io.confluent.ksql.execution.expression.tree.LongLiteral;\n-import io.confluent.ksql.execution.expression.tree.NullLiteral;\n-import io.confluent.ksql.execution.expression.tree.StringLiteral;\n-import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n-import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.name.ColumnName;\n-import io.confluent.ksql.schema.ksql.Column;\n-import io.confluent.ksql.schema.ksql.Column.Namespace;\n-import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.utils.FormatOptions;\n-import io.confluent.ksql.structured.SchemaKStream;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class PullFilterNode extends SingleSourcePlanNode {\n-\n-  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n-      Type.EQUAL,\n-      Type.GREATER_THAN,\n-      Type.GREATER_THAN_OR_EQUAL,\n-      Type.LESS_THAN,\n-      Type.LESS_THAN_OR_EQUAL\n-  );\n-\n-  private final boolean isWindowed;\n-  private final ExpressionMetadata compiledWhereClause;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final MetaStore metaStore;\n-  private final KsqlConfig ksqlConfig;\n-  private final LogicalSchema schema = getSource().getSchema();\n-\n-  private Expression rewrittenPredicate;\n-  private boolean isKeyedQuery = false;\n-  private Optional<WindowBounds> windowBounds;\n-  private List<GenericKey> keyValues;\n-  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n-  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n-  private List<GenericKey> inKeys;\n-  private BitSet seenKeys;\n-  private Object[] keyContents;\n-  private boolean containsINkeys;\n-\n-  public PullFilterNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final Expression predicate,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final boolean isWindowed\n-  ) {\n-    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n-\n-    Objects.requireNonNull(predicate, \"predicate\");\n-    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n-    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n-    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n-    this.isWindowed = isWindowed;\n-\n-    // Basic validation of WHERE clause\n-    validateWhereClause();\n-\n-    // Validation and extractions of window bounds\n-    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n-\n-    // Extraction of key and system columns\n-    extractKeysAndSystemCols();\n-\n-    // Extraction of key values\n-    keyValues = extractKeyValues();\n-\n-    // Compiling expression into byte code\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n-        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n-    compiledWhereClause = CodeGenRunner.compileExpression(\n-        rewrittenPredicate,\n-        \"Predicate\",\n-        intermediateSchema,\n-        ksqlConfig,\n-        metaStore\n-    );\n-\n-  }\n-\n-  public Expression getRewrittenPredicate() {\n-    return rewrittenPredicate;\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return getSource().getSchema();\n-  }\n-\n-  @Override\n-  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  public ExpressionMetadata getCompiledWhereClause() {\n-    return compiledWhereClause;\n-  }\n-\n-  public boolean isKeyedQuery() {\n-    return isKeyedQuery;\n-  }\n-\n-  public boolean isWindowed() {\n-    return isWindowed;\n-  }\n-\n-  public List<GenericKey> getKeyValues() {\n-    return keyValues;\n-  }\n-\n-  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n-    return keyColumns;\n-  }\n-\n-  public Optional<WindowBounds> getWindowBounds() {\n-    return windowBounds;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  private void validateWhereClause() {\n-    seenKeys = new BitSet(schema.key().size());\n-    final Validator validator = new Validator();\n-    validator.process(rewrittenPredicate, null);\n-    if (!isKeyedQuery) {\n-      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n-    }\n-\n-    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n-      final List<ColumnName> seenKeyNames = seenKeys\n-          .stream()\n-          .boxed()\n-          .map(i -> schema.key().get(i))\n-          .map(Column::name)\n-          .collect(Collectors.toList());\n-      throw invalidWhereClauseException(\n-          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n-              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n-    }\n-  }\n-\n-  private void extractKeysAndSystemCols() {\n-    keyColumns = new HashSet<>();\n-    systemColumns = new HashSet<>();\n-    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n-  }\n-\n-  private List<GenericKey> extractKeyValues() {\n-    inKeys = new ArrayList<>();\n-    keyContents = new Object[schema.key().size()];\n-    seenKeys = new BitSet(schema.key().size());\n-\n-    new KeyValueExtractor().process(rewrittenPredicate, null);\n-    if (!inKeys.isEmpty()) {\n-      return (inKeys);\n-    }\n-\n-    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n-  }\n-\n-  private WindowBounds extractWindowBounds() {\n-    final WindowBounds windowBounds = new WindowBounds();\n-\n-    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n-    return windowBounds;\n-  }\n-\n-  /**\n-   * Validate the WHERE clause for pull queries.\n-   * 1. There must be exactly one equality condition per key\n-   * or one IN predicate that involves a key.\n-   * 2. An IN predicate can refer to a single key.\n-   * 3. The IN predicate cannot be combined with other conditions.\n-   * 4. Only AND is allowed.\n-   * 5. If there is a multi-key, conditions on all keys must be specified.\n-   * 6. The IN predicate cannot use multi-keys.\n-   */\n-  private final class Validator extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void process(final Expression node, final Object context) {\n-      if (!(node instanceof  LogicalBinaryExpression)\n-          && !(node instanceof  ComparisonExpression)\n-          && !(node instanceof  InPredicate)) {\n-        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n-      }\n-      super.process(node, context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitLogicalBinaryExpression(\n-        final LogicalBinaryExpression node,\n-        final Object context\n-    ) {\n-      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n-        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n-      }\n-      process(node.getLeft(), context);\n-      process(node.getRight(), context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final Object context\n-    ) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-\n-      final ColumnName columnName = column.getColumnName();\n-      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n-          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n-        final Type type = node.getType();\n-        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n-          throw invalidWhereClauseException(\n-              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n-        }\n-        if (!isWindowed) {\n-          throw invalidWhereClauseException(\n-              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n-              false);\n-        }\n-        return null;\n-      } else {\n-        final Column col = schema.findColumn(columnName)\n-            .orElseThrow(() -> invalidWhereClauseException(\n-                \"Bound on non-key column \" + columnName, isWindowed));\n-\n-        if (col.namespace() == Namespace.KEY) {\n-          if (node.getType() != Type.EQUAL) {\n-            throw invalidWhereClauseException(\n-                \"Bound on key columns '\" + getSource().getSchema().key()\n-                    + \"' must currently be '='\",\n-                isWindowed);\n-          }\n-          if (containsINkeys || seenKeys.get(col.index())) {\n-            throw invalidWhereClauseException(\n-                \"An equality condition on the key column cannot be combined with other comparisons\"\n-                    + \" such as an IN predicate\",\n-                isWindowed);\n-          }\n-          seenKeys.set(col.index());\n-          isKeyedQuery = true;\n-          return null;\n-        }\n-\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on non-key column: \" + columnName.text(),\n-            false\n-        );\n-      }\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node,\n-        final Object context\n-    ) {\n-      if (schema.key().size() > 1) {\n-        throw invalidWhereClauseException(\n-            \"Schemas with multiple KEY columns are not supported for IN predicates\", false);\n-      }\n-\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        if (!seenKeys.isEmpty()) {\n-          throw invalidWhereClauseException(\n-              \"The IN predicate cannot be combined with other comparisons on the key column\",\n-              isWindowed);\n-        }\n-        containsINkeys = true;\n-        isKeyedQuery = true;\n-      } else {\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on unsupported column: \" + column.getColumnName().text(),\n-            false\n-        );\n-      }\n-      return null;\n-    }\n-  }\n-\n-  private UnqualifiedColumnReferenceExp getColumnRefSide(final ComparisonExpression comp) {\n-    return (UnqualifiedColumnReferenceExp)\n-        (comp.getRight() instanceof UnqualifiedColumnReferenceExp\n-            ? comp.getRight() : comp.getLeft());\n-  }\n-\n-  private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-    return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-        ? comparison.getLeft()\n-        : comparison.getRight();\n-  }\n-\n-  /**\n-   * Extracts the key and system columns that appear in the WHERE clause.\n-   */\n-  private final class KeyAndSystemColsExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitUnqualifiedColumnReference(\n-        final UnqualifiedColumnReferenceExp node, final Object context) {\n-      final Optional<Column> col = schema.findColumn(node.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        keyColumns.add(node);\n-      } else if (SystemColumns.isSystemColumn(node.getColumnName())) {\n-        systemColumns.add(node);\n-      }\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * Extracts the values for the keys that appear in the WHERE clause.\n-   * Necessary so that we can do key lookups when scanning the data stores.\n-   */\n-  private final class KeyValueExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-      final Expression other = getNonColumnRefSide(node);\n-      final ColumnName columnName = column.getColumnName();\n-\n-      final Optional<Column> col = schema.findColumn(columnName);\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        final Object key = resolveKey(other, col.get(), metaStore, ksqlConfig, node);\n-        keyContents[col.get().index()] = key;\n-        seenKeys.set(col.get().index());\n-      }\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        inKeys.addAll(node.getValueList()\n-            .getValues()\n-            .stream()\n-            .map(expression -> resolveKey(expression, col.get(), metaStore, ksqlConfig, node))\n-            .map(GenericKey::genericKey)\n-            .collect(Collectors.toList()));\n-      }\n-      return null;\n-    }\n-\n-    private Object resolveKey(\n-        final Expression exp,\n-        final Column keyColumn,\n-        final MetaStore metaStore,\n-        final KsqlConfig config,\n-        final Expression errorMessageHint\n-    ) {\n-      final Object obj;\n-      if (exp instanceof NullLiteral) {\n-        obj = null;\n-      } else if (exp instanceof Literal) {\n-        // skip the GenericExpressionResolver because this is\n-        // a critical code path executed once-per-query\n-        obj = ((Literal) exp).getValue();\n-      } else {\n-        obj = new GenericExpressionResolver(\n-            keyColumn.type(),\n-            keyColumn.name(),\n-            metaStore,\n-            config,\n-            \"pull query\"\n-        ).resolve(exp);\n-      }\n-\n-      if (obj == null) {\n-        throw new KsqlException(\"Primary key columns can not be NULL: \" + errorMessageHint);\n-      }\n-\n-      return DefaultSqlValueCoercer.STRICT.coerce(obj, keyColumn.type())\n-          .orElseThrow(() -> new KsqlException(\n-              \"'\" + obj + \"' can not be converted \"\n-                  + \"to the type of the key column: \"\n-                  + keyColumn.toString(\n-                  FormatOptions.noEscape())))\n-          .orElse(null);\n-    }\n-  }\n-\n-\n-  /**\n-   * Extracts the upper and lower bounds on windowstart/windowend columns.\n-   * Performs the following validations on the window bounds:\n-   * 1. An equality bound cannot be combined with other bounds.\n-   * 2. No duplicate bounds are allowed, such as multiple greater than bounds.\n-   */\n-  private final class WindowBoundsExtractor extends TraversalExpressionVisitor<WindowBounds> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final WindowBounds windowBounds\n-    ) {\n-      final UnqualifiedColumnReferenceExp column;\n-      if (node.getRight() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getRight();\n-      } else if (node.getLeft() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getLeft();\n-      } else {\n-        return null;\n-      }\n-\n-      if (!column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)\n-          && !column.getColumnName().equals(SystemColumns.WINDOWEND_NAME)) {\n-        return null;\n-      }\n-      boolean result = false;\n-      if (node.getType().equals(Type.EQUAL)) {\n-        final Range<Instant> instant = Range.singleton(asInstant(getNonColumnRefSide(node)));\n-        result = windowBounds.setEquality(column, instant);\n-      }\n-      final Type type = getSimplifiedBoundType(node);\n-\n-      if (type.equals(Type.LESS_THAN)) {\n-        final Instant upper = asInstant(getNonColumnRefSide(node));\n-        final BoundType upperType = getRangeBoundType(node);\n-        result = windowBounds.setUpper(column, Range.upTo(upper, upperType));\n-      } else if (type.equals(Type.GREATER_THAN)) {\n-        final Instant lower = asInstant(getNonColumnRefSide(node));\n-        final BoundType lowerType = getRangeBoundType(node);\n-        result = windowBounds.setLower(column, Range.downTo(lower, lowerType));\n-      }\n-      validateEqualityBound(windowBounds, node, column);\n-      if (!result) {\n-        throw invalidWhereClauseException(\n-            \"Duplicate \" + column.getColumnName() + \" bounds on: \" + type, true);\n-      }\n-      return null;\n-    }\n-\n-    private void validateEqualityBound(\n-        final WindowBounds bound,\n-        final ComparisonExpression expression,\n-        final UnqualifiedColumnReferenceExp column\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (bound.getStart().getEqual() != null\n-            && (bound.getStart().getUpper() != null || bound.getStart().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-        }\n-      } else {\n-        if (bound.getEnd().getEqual() != null\n-            && (bound.getEnd().getUpper() != null || bound.getEnd().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-\n-        }\n-      }\n-    }\n-\n-    private Type getSimplifiedBoundType(final ComparisonExpression comparison) {\n-      final Type type = comparison.getType();\n-      final boolean inverted = comparison.getRight() instanceof UnqualifiedColumnReferenceExp;\n-\n-      switch (type) {\n-        case LESS_THAN:\n-        case LESS_THAN_OR_EQUAL:\n-          return inverted ? Type.GREATER_THAN : Type.LESS_THAN;\n-        case GREATER_THAN:\n-        case GREATER_THAN_OR_EQUAL:\n-          return inverted ? Type.LESS_THAN : Type.GREATER_THAN;\n-        default:\n-          return type;\n-      }\n-    }\n-\n-    private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-      return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-          ? comparison.getLeft()\n-          : comparison.getRight();\n-    }\n-\n-    private Instant asInstant(final Expression other) {\n-      if (other instanceof IntegerLiteral) {\n-        return Instant.ofEpochMilli(((IntegerLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof LongLiteral) {\n-        return Instant.ofEpochMilli(((LongLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof StringLiteral) {\n-        final String text = ((StringLiteral) other).getValue();\n-        try {\n-          final long timestamp = new PartialStringToTimestampParser()\n-              .parse(text);\n-\n-          return Instant.ofEpochMilli(timestamp);\n-        } catch (final Exception e) {\n-          throw invalidWhereClauseException(\"Failed to parse datetime: \" + text, true);\n-        }\n-      }\n-\n-      throw invalidWhereClauseException(\n-          \"Window bounds must be an INT, BIGINT or STRING containing a datetime.\",\n-          true\n-      );\n-    }\n-\n-    private BoundType getRangeBoundType(final ComparisonExpression lowerComparison) {\n-      final boolean openBound = lowerComparison.getType() == Type.LESS_THAN\n-          || lowerComparison.getType() == Type.GREATER_THAN;\n-\n-      return openBound\n-          ? BoundType.OPEN\n-          : BoundType.CLOSED;\n-    }\n-  }\n-\n-  private KsqlException invalidWhereClauseException(\n-      final String msg,\n-      final boolean windowed\n-  ) {\n-    final String additional = !windowed\n-        ? \"\"\n-        : System.lineSeparator()\n-            + \" - (optionally) limits the time bounds of the windowed table.\"\n-            + System.lineSeparator()\n-            + \"\\t Bounds on \" + SystemColumns.windowBoundsColumnNames() + \" are supported\"\n-            + System.lineSeparator()\n-            + \"\\t Supported operators are \" + VALID_WINDOW_BOUND_COMPARISONS;\n-\n-    return new KsqlException(\n-        msg\n-            + \". \"\n-            + PullQueryValidator.PULL_QUERY_SYNTAX_HELP\n-            + System.lineSeparator()\n-            + \"Pull queries require a WHERE clause that:\"\n-            + System.lineSeparator()\n-            + \" - limits the query to keys only, e.g. `SELECT * FROM X WHERE <key-column>=Y;`.\"\n-            + System.lineSeparator()\n-            + \" - specifies an equality condition that is a conjunction of equality expressions \"\n-            + \"that cover all keys.\"\n-            + additional\n-    );\n-  }\n-\n-  public static final class WindowBounds {\n-\n-    private WindowRange start;\n-    private WindowRange end;\n-\n-    public WindowBounds(final WindowRange start, final WindowRange end) {\n-      this.start = Objects.requireNonNull(start, \"startBounds\");\n-      this.end = Objects.requireNonNull(end, \"endBounds\");\n-    }\n-\n-    public WindowBounds() {\n-      this.start = new WindowRange();\n-      this.end = new WindowRange();\n-    }\n-\n-    boolean setEquality(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.equal != null) {\n-          return false;\n-        }\n-        start.equal = range;\n-      } else {\n-        if (end.equal != null) {\n-          return false;\n-        }\n-        end.equal = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setUpper(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.upper != null) {\n-          return false;\n-        }\n-        start.upper = range;\n-      } else {\n-        if (end.upper != null) {\n-          return false;\n-        }\n-        end.upper = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setLower(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.lower != null) {\n-          return false;\n-        }\n-        start.lower = range;\n-      } else {\n-        if (end.lower != null) {\n-          return false;\n-        }\n-        end.lower = range;\n-      }\n-      return true;\n-    }\n-\n-    public WindowRange getStart() {\n-      return start;\n-    }\n-\n-    public WindowRange getEnd() {\n-      return end;\n-    }\n-\n-    public Range<Instant> getMergedStart() {\n-      return start.getMergedRange();\n-    }\n-\n-    public Range<Instant> getMergedEnd() {\n-      return end.getMergedRange();\n-    }\n-\n-\n-    @Override\n-    public boolean equals(final Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      final WindowBounds that = (WindowBounds) o;\n-      return Objects.equals(start, that.start)\n-          && Objects.equals(end, that.end);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hash(start, end);\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"WindowBounds{\"\n-          + \"start=\" + start\n-          + \", end=\" + end\n-          + '}';\n-    }\n-\n-    static final class WindowRange {\n-      private Range<Instant> equal;\n-      private Range<Instant> upper;\n-      private Range<Instant> lower;\n-\n-      WindowRange(\n-          final Range<Instant> equal,\n-          final Range<Instant> upper,\n-          final Range<Instant> lower\n-      ) {\n-        this.equal = equal;\n-        this.upper = upper;\n-        this.lower = lower;\n-      }\n-\n-      WindowRange() {\n-      }\n-\n-      public Range<Instant> getEqual() {\n-        return equal;\n-      }\n-\n-      public Range<Instant> getUpper() {\n-        return upper;\n-      }\n-\n-      public Range<Instant> getLower() {\n-        return lower;\n-      }\n-\n-      Range<Instant> getMergedRange() {\n-        if (lower == null && upper == null && equal == null) {\n-          return Range.all();\n-        }\n-        if (lower != null && upper != null) {\n-          return Range.range(\n-              lower.lowerEndpoint(), lower.lowerBoundType(),\n-              upper.upperEndpoint(), upper.upperBoundType()\n-          );\n-        }\n-        if (upper != null) {\n-          return upper;\n-        }\n-        if (lower != null) {\n-          return lower;\n-        }\n-        return equal;\n-      }\n-\n-      @Override\n-      public boolean equals(final Object o) {\n-        if (this == o) {\n-          return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-          return false;\n-        }\n-\n-        final WindowRange that = (WindowRange) o;\n-        return Objects.equals(equal, that.equal)\n-            && Objects.equals(upper, that.upper)\n-            && Objects.equals(lower, that.lower);\n-      }\n-\n-      @Override\n-      public int hashCode() {\n-        return Objects.hash(equal, upper, lower);\n-      }\n-\n-      @Override\n-      public String toString() {\n-        return \"WindowRange{\"\n-            + \"equal=\" + equal\n-            + \", upper=\" + upper\n-            + \", lower=\" + lower\n-            + '}';\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = !systemColumns.isEmpty();\n-\n-    final boolean hasKeyColumns = !keyColumns.isEmpty();\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3MTgxMg==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551471812", "bodyText": "This is primarily used in the validator.  Move to that class?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:53:33Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\ndeleted file mode 100644\nindex 13d9328c3b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\n+++ /dev/null\n\n@@ -1,823 +0,0 @@\n-/*\n- * Copyright 2019 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.collect.BoundType;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Range;\n-import io.confluent.ksql.GenericKey;\n-import io.confluent.ksql.analyzer.PullQueryValidator;\n-import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n-import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n-import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n-import io.confluent.ksql.execution.expression.tree.Expression;\n-import io.confluent.ksql.execution.expression.tree.InPredicate;\n-import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n-import io.confluent.ksql.execution.expression.tree.Literal;\n-import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n-import io.confluent.ksql.execution.expression.tree.LongLiteral;\n-import io.confluent.ksql.execution.expression.tree.NullLiteral;\n-import io.confluent.ksql.execution.expression.tree.StringLiteral;\n-import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n-import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.name.ColumnName;\n-import io.confluent.ksql.schema.ksql.Column;\n-import io.confluent.ksql.schema.ksql.Column.Namespace;\n-import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.utils.FormatOptions;\n-import io.confluent.ksql.structured.SchemaKStream;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class PullFilterNode extends SingleSourcePlanNode {\n-\n-  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n-      Type.EQUAL,\n-      Type.GREATER_THAN,\n-      Type.GREATER_THAN_OR_EQUAL,\n-      Type.LESS_THAN,\n-      Type.LESS_THAN_OR_EQUAL\n-  );\n-\n-  private final boolean isWindowed;\n-  private final ExpressionMetadata compiledWhereClause;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final MetaStore metaStore;\n-  private final KsqlConfig ksqlConfig;\n-  private final LogicalSchema schema = getSource().getSchema();\n-\n-  private Expression rewrittenPredicate;\n-  private boolean isKeyedQuery = false;\n-  private Optional<WindowBounds> windowBounds;\n-  private List<GenericKey> keyValues;\n-  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n-  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n-  private List<GenericKey> inKeys;\n-  private BitSet seenKeys;\n-  private Object[] keyContents;\n-  private boolean containsINkeys;\n-\n-  public PullFilterNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final Expression predicate,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final boolean isWindowed\n-  ) {\n-    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n-\n-    Objects.requireNonNull(predicate, \"predicate\");\n-    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n-    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n-    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n-    this.isWindowed = isWindowed;\n-\n-    // Basic validation of WHERE clause\n-    validateWhereClause();\n-\n-    // Validation and extractions of window bounds\n-    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n-\n-    // Extraction of key and system columns\n-    extractKeysAndSystemCols();\n-\n-    // Extraction of key values\n-    keyValues = extractKeyValues();\n-\n-    // Compiling expression into byte code\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n-        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n-    compiledWhereClause = CodeGenRunner.compileExpression(\n-        rewrittenPredicate,\n-        \"Predicate\",\n-        intermediateSchema,\n-        ksqlConfig,\n-        metaStore\n-    );\n-\n-  }\n-\n-  public Expression getRewrittenPredicate() {\n-    return rewrittenPredicate;\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return getSource().getSchema();\n-  }\n-\n-  @Override\n-  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  public ExpressionMetadata getCompiledWhereClause() {\n-    return compiledWhereClause;\n-  }\n-\n-  public boolean isKeyedQuery() {\n-    return isKeyedQuery;\n-  }\n-\n-  public boolean isWindowed() {\n-    return isWindowed;\n-  }\n-\n-  public List<GenericKey> getKeyValues() {\n-    return keyValues;\n-  }\n-\n-  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n-    return keyColumns;\n-  }\n-\n-  public Optional<WindowBounds> getWindowBounds() {\n-    return windowBounds;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  private void validateWhereClause() {\n-    seenKeys = new BitSet(schema.key().size());\n-    final Validator validator = new Validator();\n-    validator.process(rewrittenPredicate, null);\n-    if (!isKeyedQuery) {\n-      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n-    }\n-\n-    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n-      final List<ColumnName> seenKeyNames = seenKeys\n-          .stream()\n-          .boxed()\n-          .map(i -> schema.key().get(i))\n-          .map(Column::name)\n-          .collect(Collectors.toList());\n-      throw invalidWhereClauseException(\n-          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n-              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n-    }\n-  }\n-\n-  private void extractKeysAndSystemCols() {\n-    keyColumns = new HashSet<>();\n-    systemColumns = new HashSet<>();\n-    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n-  }\n-\n-  private List<GenericKey> extractKeyValues() {\n-    inKeys = new ArrayList<>();\n-    keyContents = new Object[schema.key().size()];\n-    seenKeys = new BitSet(schema.key().size());\n-\n-    new KeyValueExtractor().process(rewrittenPredicate, null);\n-    if (!inKeys.isEmpty()) {\n-      return (inKeys);\n-    }\n-\n-    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n-  }\n-\n-  private WindowBounds extractWindowBounds() {\n-    final WindowBounds windowBounds = new WindowBounds();\n-\n-    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n-    return windowBounds;\n-  }\n-\n-  /**\n-   * Validate the WHERE clause for pull queries.\n-   * 1. There must be exactly one equality condition per key\n-   * or one IN predicate that involves a key.\n-   * 2. An IN predicate can refer to a single key.\n-   * 3. The IN predicate cannot be combined with other conditions.\n-   * 4. Only AND is allowed.\n-   * 5. If there is a multi-key, conditions on all keys must be specified.\n-   * 6. The IN predicate cannot use multi-keys.\n-   */\n-  private final class Validator extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void process(final Expression node, final Object context) {\n-      if (!(node instanceof  LogicalBinaryExpression)\n-          && !(node instanceof  ComparisonExpression)\n-          && !(node instanceof  InPredicate)) {\n-        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n-      }\n-      super.process(node, context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitLogicalBinaryExpression(\n-        final LogicalBinaryExpression node,\n-        final Object context\n-    ) {\n-      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n-        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n-      }\n-      process(node.getLeft(), context);\n-      process(node.getRight(), context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final Object context\n-    ) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-\n-      final ColumnName columnName = column.getColumnName();\n-      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n-          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n-        final Type type = node.getType();\n-        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n-          throw invalidWhereClauseException(\n-              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n-        }\n-        if (!isWindowed) {\n-          throw invalidWhereClauseException(\n-              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n-              false);\n-        }\n-        return null;\n-      } else {\n-        final Column col = schema.findColumn(columnName)\n-            .orElseThrow(() -> invalidWhereClauseException(\n-                \"Bound on non-key column \" + columnName, isWindowed));\n-\n-        if (col.namespace() == Namespace.KEY) {\n-          if (node.getType() != Type.EQUAL) {\n-            throw invalidWhereClauseException(\n-                \"Bound on key columns '\" + getSource().getSchema().key()\n-                    + \"' must currently be '='\",\n-                isWindowed);\n-          }\n-          if (containsINkeys || seenKeys.get(col.index())) {\n-            throw invalidWhereClauseException(\n-                \"An equality condition on the key column cannot be combined with other comparisons\"\n-                    + \" such as an IN predicate\",\n-                isWindowed);\n-          }\n-          seenKeys.set(col.index());\n-          isKeyedQuery = true;\n-          return null;\n-        }\n-\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on non-key column: \" + columnName.text(),\n-            false\n-        );\n-      }\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node,\n-        final Object context\n-    ) {\n-      if (schema.key().size() > 1) {\n-        throw invalidWhereClauseException(\n-            \"Schemas with multiple KEY columns are not supported for IN predicates\", false);\n-      }\n-\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        if (!seenKeys.isEmpty()) {\n-          throw invalidWhereClauseException(\n-              \"The IN predicate cannot be combined with other comparisons on the key column\",\n-              isWindowed);\n-        }\n-        containsINkeys = true;\n-        isKeyedQuery = true;\n-      } else {\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on unsupported column: \" + column.getColumnName().text(),\n-            false\n-        );\n-      }\n-      return null;\n-    }\n-  }\n-\n-  private UnqualifiedColumnReferenceExp getColumnRefSide(final ComparisonExpression comp) {\n-    return (UnqualifiedColumnReferenceExp)\n-        (comp.getRight() instanceof UnqualifiedColumnReferenceExp\n-            ? comp.getRight() : comp.getLeft());\n-  }\n-\n-  private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-    return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-        ? comparison.getLeft()\n-        : comparison.getRight();\n-  }\n-\n-  /**\n-   * Extracts the key and system columns that appear in the WHERE clause.\n-   */\n-  private final class KeyAndSystemColsExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitUnqualifiedColumnReference(\n-        final UnqualifiedColumnReferenceExp node, final Object context) {\n-      final Optional<Column> col = schema.findColumn(node.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        keyColumns.add(node);\n-      } else if (SystemColumns.isSystemColumn(node.getColumnName())) {\n-        systemColumns.add(node);\n-      }\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * Extracts the values for the keys that appear in the WHERE clause.\n-   * Necessary so that we can do key lookups when scanning the data stores.\n-   */\n-  private final class KeyValueExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-      final Expression other = getNonColumnRefSide(node);\n-      final ColumnName columnName = column.getColumnName();\n-\n-      final Optional<Column> col = schema.findColumn(columnName);\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        final Object key = resolveKey(other, col.get(), metaStore, ksqlConfig, node);\n-        keyContents[col.get().index()] = key;\n-        seenKeys.set(col.get().index());\n-      }\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        inKeys.addAll(node.getValueList()\n-            .getValues()\n-            .stream()\n-            .map(expression -> resolveKey(expression, col.get(), metaStore, ksqlConfig, node))\n-            .map(GenericKey::genericKey)\n-            .collect(Collectors.toList()));\n-      }\n-      return null;\n-    }\n-\n-    private Object resolveKey(\n-        final Expression exp,\n-        final Column keyColumn,\n-        final MetaStore metaStore,\n-        final KsqlConfig config,\n-        final Expression errorMessageHint\n-    ) {\n-      final Object obj;\n-      if (exp instanceof NullLiteral) {\n-        obj = null;\n-      } else if (exp instanceof Literal) {\n-        // skip the GenericExpressionResolver because this is\n-        // a critical code path executed once-per-query\n-        obj = ((Literal) exp).getValue();\n-      } else {\n-        obj = new GenericExpressionResolver(\n-            keyColumn.type(),\n-            keyColumn.name(),\n-            metaStore,\n-            config,\n-            \"pull query\"\n-        ).resolve(exp);\n-      }\n-\n-      if (obj == null) {\n-        throw new KsqlException(\"Primary key columns can not be NULL: \" + errorMessageHint);\n-      }\n-\n-      return DefaultSqlValueCoercer.STRICT.coerce(obj, keyColumn.type())\n-          .orElseThrow(() -> new KsqlException(\n-              \"'\" + obj + \"' can not be converted \"\n-                  + \"to the type of the key column: \"\n-                  + keyColumn.toString(\n-                  FormatOptions.noEscape())))\n-          .orElse(null);\n-    }\n-  }\n-\n-\n-  /**\n-   * Extracts the upper and lower bounds on windowstart/windowend columns.\n-   * Performs the following validations on the window bounds:\n-   * 1. An equality bound cannot be combined with other bounds.\n-   * 2. No duplicate bounds are allowed, such as multiple greater than bounds.\n-   */\n-  private final class WindowBoundsExtractor extends TraversalExpressionVisitor<WindowBounds> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final WindowBounds windowBounds\n-    ) {\n-      final UnqualifiedColumnReferenceExp column;\n-      if (node.getRight() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getRight();\n-      } else if (node.getLeft() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getLeft();\n-      } else {\n-        return null;\n-      }\n-\n-      if (!column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)\n-          && !column.getColumnName().equals(SystemColumns.WINDOWEND_NAME)) {\n-        return null;\n-      }\n-      boolean result = false;\n-      if (node.getType().equals(Type.EQUAL)) {\n-        final Range<Instant> instant = Range.singleton(asInstant(getNonColumnRefSide(node)));\n-        result = windowBounds.setEquality(column, instant);\n-      }\n-      final Type type = getSimplifiedBoundType(node);\n-\n-      if (type.equals(Type.LESS_THAN)) {\n-        final Instant upper = asInstant(getNonColumnRefSide(node));\n-        final BoundType upperType = getRangeBoundType(node);\n-        result = windowBounds.setUpper(column, Range.upTo(upper, upperType));\n-      } else if (type.equals(Type.GREATER_THAN)) {\n-        final Instant lower = asInstant(getNonColumnRefSide(node));\n-        final BoundType lowerType = getRangeBoundType(node);\n-        result = windowBounds.setLower(column, Range.downTo(lower, lowerType));\n-      }\n-      validateEqualityBound(windowBounds, node, column);\n-      if (!result) {\n-        throw invalidWhereClauseException(\n-            \"Duplicate \" + column.getColumnName() + \" bounds on: \" + type, true);\n-      }\n-      return null;\n-    }\n-\n-    private void validateEqualityBound(\n-        final WindowBounds bound,\n-        final ComparisonExpression expression,\n-        final UnqualifiedColumnReferenceExp column\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (bound.getStart().getEqual() != null\n-            && (bound.getStart().getUpper() != null || bound.getStart().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-        }\n-      } else {\n-        if (bound.getEnd().getEqual() != null\n-            && (bound.getEnd().getUpper() != null || bound.getEnd().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-\n-        }\n-      }\n-    }\n-\n-    private Type getSimplifiedBoundType(final ComparisonExpression comparison) {\n-      final Type type = comparison.getType();\n-      final boolean inverted = comparison.getRight() instanceof UnqualifiedColumnReferenceExp;\n-\n-      switch (type) {\n-        case LESS_THAN:\n-        case LESS_THAN_OR_EQUAL:\n-          return inverted ? Type.GREATER_THAN : Type.LESS_THAN;\n-        case GREATER_THAN:\n-        case GREATER_THAN_OR_EQUAL:\n-          return inverted ? Type.LESS_THAN : Type.GREATER_THAN;\n-        default:\n-          return type;\n-      }\n-    }\n-\n-    private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-      return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-          ? comparison.getLeft()\n-          : comparison.getRight();\n-    }\n-\n-    private Instant asInstant(final Expression other) {\n-      if (other instanceof IntegerLiteral) {\n-        return Instant.ofEpochMilli(((IntegerLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof LongLiteral) {\n-        return Instant.ofEpochMilli(((LongLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof StringLiteral) {\n-        final String text = ((StringLiteral) other).getValue();\n-        try {\n-          final long timestamp = new PartialStringToTimestampParser()\n-              .parse(text);\n-\n-          return Instant.ofEpochMilli(timestamp);\n-        } catch (final Exception e) {\n-          throw invalidWhereClauseException(\"Failed to parse datetime: \" + text, true);\n-        }\n-      }\n-\n-      throw invalidWhereClauseException(\n-          \"Window bounds must be an INT, BIGINT or STRING containing a datetime.\",\n-          true\n-      );\n-    }\n-\n-    private BoundType getRangeBoundType(final ComparisonExpression lowerComparison) {\n-      final boolean openBound = lowerComparison.getType() == Type.LESS_THAN\n-          || lowerComparison.getType() == Type.GREATER_THAN;\n-\n-      return openBound\n-          ? BoundType.OPEN\n-          : BoundType.CLOSED;\n-    }\n-  }\n-\n-  private KsqlException invalidWhereClauseException(\n-      final String msg,\n-      final boolean windowed\n-  ) {\n-    final String additional = !windowed\n-        ? \"\"\n-        : System.lineSeparator()\n-            + \" - (optionally) limits the time bounds of the windowed table.\"\n-            + System.lineSeparator()\n-            + \"\\t Bounds on \" + SystemColumns.windowBoundsColumnNames() + \" are supported\"\n-            + System.lineSeparator()\n-            + \"\\t Supported operators are \" + VALID_WINDOW_BOUND_COMPARISONS;\n-\n-    return new KsqlException(\n-        msg\n-            + \". \"\n-            + PullQueryValidator.PULL_QUERY_SYNTAX_HELP\n-            + System.lineSeparator()\n-            + \"Pull queries require a WHERE clause that:\"\n-            + System.lineSeparator()\n-            + \" - limits the query to keys only, e.g. `SELECT * FROM X WHERE <key-column>=Y;`.\"\n-            + System.lineSeparator()\n-            + \" - specifies an equality condition that is a conjunction of equality expressions \"\n-            + \"that cover all keys.\"\n-            + additional\n-    );\n-  }\n-\n-  public static final class WindowBounds {\n-\n-    private WindowRange start;\n-    private WindowRange end;\n-\n-    public WindowBounds(final WindowRange start, final WindowRange end) {\n-      this.start = Objects.requireNonNull(start, \"startBounds\");\n-      this.end = Objects.requireNonNull(end, \"endBounds\");\n-    }\n-\n-    public WindowBounds() {\n-      this.start = new WindowRange();\n-      this.end = new WindowRange();\n-    }\n-\n-    boolean setEquality(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.equal != null) {\n-          return false;\n-        }\n-        start.equal = range;\n-      } else {\n-        if (end.equal != null) {\n-          return false;\n-        }\n-        end.equal = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setUpper(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.upper != null) {\n-          return false;\n-        }\n-        start.upper = range;\n-      } else {\n-        if (end.upper != null) {\n-          return false;\n-        }\n-        end.upper = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setLower(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.lower != null) {\n-          return false;\n-        }\n-        start.lower = range;\n-      } else {\n-        if (end.lower != null) {\n-          return false;\n-        }\n-        end.lower = range;\n-      }\n-      return true;\n-    }\n-\n-    public WindowRange getStart() {\n-      return start;\n-    }\n-\n-    public WindowRange getEnd() {\n-      return end;\n-    }\n-\n-    public Range<Instant> getMergedStart() {\n-      return start.getMergedRange();\n-    }\n-\n-    public Range<Instant> getMergedEnd() {\n-      return end.getMergedRange();\n-    }\n-\n-\n-    @Override\n-    public boolean equals(final Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      final WindowBounds that = (WindowBounds) o;\n-      return Objects.equals(start, that.start)\n-          && Objects.equals(end, that.end);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hash(start, end);\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"WindowBounds{\"\n-          + \"start=\" + start\n-          + \", end=\" + end\n-          + '}';\n-    }\n-\n-    static final class WindowRange {\n-      private Range<Instant> equal;\n-      private Range<Instant> upper;\n-      private Range<Instant> lower;\n-\n-      WindowRange(\n-          final Range<Instant> equal,\n-          final Range<Instant> upper,\n-          final Range<Instant> lower\n-      ) {\n-        this.equal = equal;\n-        this.upper = upper;\n-        this.lower = lower;\n-      }\n-\n-      WindowRange() {\n-      }\n-\n-      public Range<Instant> getEqual() {\n-        return equal;\n-      }\n-\n-      public Range<Instant> getUpper() {\n-        return upper;\n-      }\n-\n-      public Range<Instant> getLower() {\n-        return lower;\n-      }\n-\n-      Range<Instant> getMergedRange() {\n-        if (lower == null && upper == null && equal == null) {\n-          return Range.all();\n-        }\n-        if (lower != null && upper != null) {\n-          return Range.range(\n-              lower.lowerEndpoint(), lower.lowerBoundType(),\n-              upper.upperEndpoint(), upper.upperBoundType()\n-          );\n-        }\n-        if (upper != null) {\n-          return upper;\n-        }\n-        if (lower != null) {\n-          return lower;\n-        }\n-        return equal;\n-      }\n-\n-      @Override\n-      public boolean equals(final Object o) {\n-        if (this == o) {\n-          return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-          return false;\n-        }\n-\n-        final WindowRange that = (WindowRange) o;\n-        return Objects.equals(equal, that.equal)\n-            && Objects.equals(upper, that.upper)\n-            && Objects.equals(lower, that.lower);\n-      }\n-\n-      @Override\n-      public int hashCode() {\n-        return Objects.hash(equal, upper, lower);\n-      }\n-\n-      @Override\n-      public String toString() {\n-        return \"WindowRange{\"\n-            + \"equal=\" + equal\n-            + \", upper=\" + upper\n-            + \", lower=\" + lower\n-            + '}';\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = !systemColumns.isEmpty();\n-\n-    final boolean hasKeyColumns = !keyColumns.isEmpty();\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3MjYyMA==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551472620", "bodyText": "You can also add as getter to validator to get this field as well.", "author": "AlanConfluent", "createdAt": "2021-01-04T17:55:03Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());\n+    final Validator validator = new Validator();\n+    validator.process(rewrittenPredicate, null);\n+    if (!isKeyedQuery) {", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\ndeleted file mode 100644\nindex 13d9328c3b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\n+++ /dev/null\n\n@@ -1,823 +0,0 @@\n-/*\n- * Copyright 2019 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.collect.BoundType;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Range;\n-import io.confluent.ksql.GenericKey;\n-import io.confluent.ksql.analyzer.PullQueryValidator;\n-import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n-import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n-import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n-import io.confluent.ksql.execution.expression.tree.Expression;\n-import io.confluent.ksql.execution.expression.tree.InPredicate;\n-import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n-import io.confluent.ksql.execution.expression.tree.Literal;\n-import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n-import io.confluent.ksql.execution.expression.tree.LongLiteral;\n-import io.confluent.ksql.execution.expression.tree.NullLiteral;\n-import io.confluent.ksql.execution.expression.tree.StringLiteral;\n-import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n-import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.name.ColumnName;\n-import io.confluent.ksql.schema.ksql.Column;\n-import io.confluent.ksql.schema.ksql.Column.Namespace;\n-import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.utils.FormatOptions;\n-import io.confluent.ksql.structured.SchemaKStream;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class PullFilterNode extends SingleSourcePlanNode {\n-\n-  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n-      Type.EQUAL,\n-      Type.GREATER_THAN,\n-      Type.GREATER_THAN_OR_EQUAL,\n-      Type.LESS_THAN,\n-      Type.LESS_THAN_OR_EQUAL\n-  );\n-\n-  private final boolean isWindowed;\n-  private final ExpressionMetadata compiledWhereClause;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final MetaStore metaStore;\n-  private final KsqlConfig ksqlConfig;\n-  private final LogicalSchema schema = getSource().getSchema();\n-\n-  private Expression rewrittenPredicate;\n-  private boolean isKeyedQuery = false;\n-  private Optional<WindowBounds> windowBounds;\n-  private List<GenericKey> keyValues;\n-  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n-  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n-  private List<GenericKey> inKeys;\n-  private BitSet seenKeys;\n-  private Object[] keyContents;\n-  private boolean containsINkeys;\n-\n-  public PullFilterNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final Expression predicate,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final boolean isWindowed\n-  ) {\n-    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n-\n-    Objects.requireNonNull(predicate, \"predicate\");\n-    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n-    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n-    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n-    this.isWindowed = isWindowed;\n-\n-    // Basic validation of WHERE clause\n-    validateWhereClause();\n-\n-    // Validation and extractions of window bounds\n-    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n-\n-    // Extraction of key and system columns\n-    extractKeysAndSystemCols();\n-\n-    // Extraction of key values\n-    keyValues = extractKeyValues();\n-\n-    // Compiling expression into byte code\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n-        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n-    compiledWhereClause = CodeGenRunner.compileExpression(\n-        rewrittenPredicate,\n-        \"Predicate\",\n-        intermediateSchema,\n-        ksqlConfig,\n-        metaStore\n-    );\n-\n-  }\n-\n-  public Expression getRewrittenPredicate() {\n-    return rewrittenPredicate;\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return getSource().getSchema();\n-  }\n-\n-  @Override\n-  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  public ExpressionMetadata getCompiledWhereClause() {\n-    return compiledWhereClause;\n-  }\n-\n-  public boolean isKeyedQuery() {\n-    return isKeyedQuery;\n-  }\n-\n-  public boolean isWindowed() {\n-    return isWindowed;\n-  }\n-\n-  public List<GenericKey> getKeyValues() {\n-    return keyValues;\n-  }\n-\n-  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n-    return keyColumns;\n-  }\n-\n-  public Optional<WindowBounds> getWindowBounds() {\n-    return windowBounds;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  private void validateWhereClause() {\n-    seenKeys = new BitSet(schema.key().size());\n-    final Validator validator = new Validator();\n-    validator.process(rewrittenPredicate, null);\n-    if (!isKeyedQuery) {\n-      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n-    }\n-\n-    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n-      final List<ColumnName> seenKeyNames = seenKeys\n-          .stream()\n-          .boxed()\n-          .map(i -> schema.key().get(i))\n-          .map(Column::name)\n-          .collect(Collectors.toList());\n-      throw invalidWhereClauseException(\n-          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n-              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n-    }\n-  }\n-\n-  private void extractKeysAndSystemCols() {\n-    keyColumns = new HashSet<>();\n-    systemColumns = new HashSet<>();\n-    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n-  }\n-\n-  private List<GenericKey> extractKeyValues() {\n-    inKeys = new ArrayList<>();\n-    keyContents = new Object[schema.key().size()];\n-    seenKeys = new BitSet(schema.key().size());\n-\n-    new KeyValueExtractor().process(rewrittenPredicate, null);\n-    if (!inKeys.isEmpty()) {\n-      return (inKeys);\n-    }\n-\n-    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n-  }\n-\n-  private WindowBounds extractWindowBounds() {\n-    final WindowBounds windowBounds = new WindowBounds();\n-\n-    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n-    return windowBounds;\n-  }\n-\n-  /**\n-   * Validate the WHERE clause for pull queries.\n-   * 1. There must be exactly one equality condition per key\n-   * or one IN predicate that involves a key.\n-   * 2. An IN predicate can refer to a single key.\n-   * 3. The IN predicate cannot be combined with other conditions.\n-   * 4. Only AND is allowed.\n-   * 5. If there is a multi-key, conditions on all keys must be specified.\n-   * 6. The IN predicate cannot use multi-keys.\n-   */\n-  private final class Validator extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void process(final Expression node, final Object context) {\n-      if (!(node instanceof  LogicalBinaryExpression)\n-          && !(node instanceof  ComparisonExpression)\n-          && !(node instanceof  InPredicate)) {\n-        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n-      }\n-      super.process(node, context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitLogicalBinaryExpression(\n-        final LogicalBinaryExpression node,\n-        final Object context\n-    ) {\n-      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n-        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n-      }\n-      process(node.getLeft(), context);\n-      process(node.getRight(), context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final Object context\n-    ) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-\n-      final ColumnName columnName = column.getColumnName();\n-      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n-          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n-        final Type type = node.getType();\n-        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n-          throw invalidWhereClauseException(\n-              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n-        }\n-        if (!isWindowed) {\n-          throw invalidWhereClauseException(\n-              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n-              false);\n-        }\n-        return null;\n-      } else {\n-        final Column col = schema.findColumn(columnName)\n-            .orElseThrow(() -> invalidWhereClauseException(\n-                \"Bound on non-key column \" + columnName, isWindowed));\n-\n-        if (col.namespace() == Namespace.KEY) {\n-          if (node.getType() != Type.EQUAL) {\n-            throw invalidWhereClauseException(\n-                \"Bound on key columns '\" + getSource().getSchema().key()\n-                    + \"' must currently be '='\",\n-                isWindowed);\n-          }\n-          if (containsINkeys || seenKeys.get(col.index())) {\n-            throw invalidWhereClauseException(\n-                \"An equality condition on the key column cannot be combined with other comparisons\"\n-                    + \" such as an IN predicate\",\n-                isWindowed);\n-          }\n-          seenKeys.set(col.index());\n-          isKeyedQuery = true;\n-          return null;\n-        }\n-\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on non-key column: \" + columnName.text(),\n-            false\n-        );\n-      }\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node,\n-        final Object context\n-    ) {\n-      if (schema.key().size() > 1) {\n-        throw invalidWhereClauseException(\n-            \"Schemas with multiple KEY columns are not supported for IN predicates\", false);\n-      }\n-\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        if (!seenKeys.isEmpty()) {\n-          throw invalidWhereClauseException(\n-              \"The IN predicate cannot be combined with other comparisons on the key column\",\n-              isWindowed);\n-        }\n-        containsINkeys = true;\n-        isKeyedQuery = true;\n-      } else {\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on unsupported column: \" + column.getColumnName().text(),\n-            false\n-        );\n-      }\n-      return null;\n-    }\n-  }\n-\n-  private UnqualifiedColumnReferenceExp getColumnRefSide(final ComparisonExpression comp) {\n-    return (UnqualifiedColumnReferenceExp)\n-        (comp.getRight() instanceof UnqualifiedColumnReferenceExp\n-            ? comp.getRight() : comp.getLeft());\n-  }\n-\n-  private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-    return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-        ? comparison.getLeft()\n-        : comparison.getRight();\n-  }\n-\n-  /**\n-   * Extracts the key and system columns that appear in the WHERE clause.\n-   */\n-  private final class KeyAndSystemColsExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitUnqualifiedColumnReference(\n-        final UnqualifiedColumnReferenceExp node, final Object context) {\n-      final Optional<Column> col = schema.findColumn(node.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        keyColumns.add(node);\n-      } else if (SystemColumns.isSystemColumn(node.getColumnName())) {\n-        systemColumns.add(node);\n-      }\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * Extracts the values for the keys that appear in the WHERE clause.\n-   * Necessary so that we can do key lookups when scanning the data stores.\n-   */\n-  private final class KeyValueExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-      final Expression other = getNonColumnRefSide(node);\n-      final ColumnName columnName = column.getColumnName();\n-\n-      final Optional<Column> col = schema.findColumn(columnName);\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        final Object key = resolveKey(other, col.get(), metaStore, ksqlConfig, node);\n-        keyContents[col.get().index()] = key;\n-        seenKeys.set(col.get().index());\n-      }\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        inKeys.addAll(node.getValueList()\n-            .getValues()\n-            .stream()\n-            .map(expression -> resolveKey(expression, col.get(), metaStore, ksqlConfig, node))\n-            .map(GenericKey::genericKey)\n-            .collect(Collectors.toList()));\n-      }\n-      return null;\n-    }\n-\n-    private Object resolveKey(\n-        final Expression exp,\n-        final Column keyColumn,\n-        final MetaStore metaStore,\n-        final KsqlConfig config,\n-        final Expression errorMessageHint\n-    ) {\n-      final Object obj;\n-      if (exp instanceof NullLiteral) {\n-        obj = null;\n-      } else if (exp instanceof Literal) {\n-        // skip the GenericExpressionResolver because this is\n-        // a critical code path executed once-per-query\n-        obj = ((Literal) exp).getValue();\n-      } else {\n-        obj = new GenericExpressionResolver(\n-            keyColumn.type(),\n-            keyColumn.name(),\n-            metaStore,\n-            config,\n-            \"pull query\"\n-        ).resolve(exp);\n-      }\n-\n-      if (obj == null) {\n-        throw new KsqlException(\"Primary key columns can not be NULL: \" + errorMessageHint);\n-      }\n-\n-      return DefaultSqlValueCoercer.STRICT.coerce(obj, keyColumn.type())\n-          .orElseThrow(() -> new KsqlException(\n-              \"'\" + obj + \"' can not be converted \"\n-                  + \"to the type of the key column: \"\n-                  + keyColumn.toString(\n-                  FormatOptions.noEscape())))\n-          .orElse(null);\n-    }\n-  }\n-\n-\n-  /**\n-   * Extracts the upper and lower bounds on windowstart/windowend columns.\n-   * Performs the following validations on the window bounds:\n-   * 1. An equality bound cannot be combined with other bounds.\n-   * 2. No duplicate bounds are allowed, such as multiple greater than bounds.\n-   */\n-  private final class WindowBoundsExtractor extends TraversalExpressionVisitor<WindowBounds> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final WindowBounds windowBounds\n-    ) {\n-      final UnqualifiedColumnReferenceExp column;\n-      if (node.getRight() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getRight();\n-      } else if (node.getLeft() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getLeft();\n-      } else {\n-        return null;\n-      }\n-\n-      if (!column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)\n-          && !column.getColumnName().equals(SystemColumns.WINDOWEND_NAME)) {\n-        return null;\n-      }\n-      boolean result = false;\n-      if (node.getType().equals(Type.EQUAL)) {\n-        final Range<Instant> instant = Range.singleton(asInstant(getNonColumnRefSide(node)));\n-        result = windowBounds.setEquality(column, instant);\n-      }\n-      final Type type = getSimplifiedBoundType(node);\n-\n-      if (type.equals(Type.LESS_THAN)) {\n-        final Instant upper = asInstant(getNonColumnRefSide(node));\n-        final BoundType upperType = getRangeBoundType(node);\n-        result = windowBounds.setUpper(column, Range.upTo(upper, upperType));\n-      } else if (type.equals(Type.GREATER_THAN)) {\n-        final Instant lower = asInstant(getNonColumnRefSide(node));\n-        final BoundType lowerType = getRangeBoundType(node);\n-        result = windowBounds.setLower(column, Range.downTo(lower, lowerType));\n-      }\n-      validateEqualityBound(windowBounds, node, column);\n-      if (!result) {\n-        throw invalidWhereClauseException(\n-            \"Duplicate \" + column.getColumnName() + \" bounds on: \" + type, true);\n-      }\n-      return null;\n-    }\n-\n-    private void validateEqualityBound(\n-        final WindowBounds bound,\n-        final ComparisonExpression expression,\n-        final UnqualifiedColumnReferenceExp column\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (bound.getStart().getEqual() != null\n-            && (bound.getStart().getUpper() != null || bound.getStart().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-        }\n-      } else {\n-        if (bound.getEnd().getEqual() != null\n-            && (bound.getEnd().getUpper() != null || bound.getEnd().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-\n-        }\n-      }\n-    }\n-\n-    private Type getSimplifiedBoundType(final ComparisonExpression comparison) {\n-      final Type type = comparison.getType();\n-      final boolean inverted = comparison.getRight() instanceof UnqualifiedColumnReferenceExp;\n-\n-      switch (type) {\n-        case LESS_THAN:\n-        case LESS_THAN_OR_EQUAL:\n-          return inverted ? Type.GREATER_THAN : Type.LESS_THAN;\n-        case GREATER_THAN:\n-        case GREATER_THAN_OR_EQUAL:\n-          return inverted ? Type.LESS_THAN : Type.GREATER_THAN;\n-        default:\n-          return type;\n-      }\n-    }\n-\n-    private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-      return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-          ? comparison.getLeft()\n-          : comparison.getRight();\n-    }\n-\n-    private Instant asInstant(final Expression other) {\n-      if (other instanceof IntegerLiteral) {\n-        return Instant.ofEpochMilli(((IntegerLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof LongLiteral) {\n-        return Instant.ofEpochMilli(((LongLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof StringLiteral) {\n-        final String text = ((StringLiteral) other).getValue();\n-        try {\n-          final long timestamp = new PartialStringToTimestampParser()\n-              .parse(text);\n-\n-          return Instant.ofEpochMilli(timestamp);\n-        } catch (final Exception e) {\n-          throw invalidWhereClauseException(\"Failed to parse datetime: \" + text, true);\n-        }\n-      }\n-\n-      throw invalidWhereClauseException(\n-          \"Window bounds must be an INT, BIGINT or STRING containing a datetime.\",\n-          true\n-      );\n-    }\n-\n-    private BoundType getRangeBoundType(final ComparisonExpression lowerComparison) {\n-      final boolean openBound = lowerComparison.getType() == Type.LESS_THAN\n-          || lowerComparison.getType() == Type.GREATER_THAN;\n-\n-      return openBound\n-          ? BoundType.OPEN\n-          : BoundType.CLOSED;\n-    }\n-  }\n-\n-  private KsqlException invalidWhereClauseException(\n-      final String msg,\n-      final boolean windowed\n-  ) {\n-    final String additional = !windowed\n-        ? \"\"\n-        : System.lineSeparator()\n-            + \" - (optionally) limits the time bounds of the windowed table.\"\n-            + System.lineSeparator()\n-            + \"\\t Bounds on \" + SystemColumns.windowBoundsColumnNames() + \" are supported\"\n-            + System.lineSeparator()\n-            + \"\\t Supported operators are \" + VALID_WINDOW_BOUND_COMPARISONS;\n-\n-    return new KsqlException(\n-        msg\n-            + \". \"\n-            + PullQueryValidator.PULL_QUERY_SYNTAX_HELP\n-            + System.lineSeparator()\n-            + \"Pull queries require a WHERE clause that:\"\n-            + System.lineSeparator()\n-            + \" - limits the query to keys only, e.g. `SELECT * FROM X WHERE <key-column>=Y;`.\"\n-            + System.lineSeparator()\n-            + \" - specifies an equality condition that is a conjunction of equality expressions \"\n-            + \"that cover all keys.\"\n-            + additional\n-    );\n-  }\n-\n-  public static final class WindowBounds {\n-\n-    private WindowRange start;\n-    private WindowRange end;\n-\n-    public WindowBounds(final WindowRange start, final WindowRange end) {\n-      this.start = Objects.requireNonNull(start, \"startBounds\");\n-      this.end = Objects.requireNonNull(end, \"endBounds\");\n-    }\n-\n-    public WindowBounds() {\n-      this.start = new WindowRange();\n-      this.end = new WindowRange();\n-    }\n-\n-    boolean setEquality(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.equal != null) {\n-          return false;\n-        }\n-        start.equal = range;\n-      } else {\n-        if (end.equal != null) {\n-          return false;\n-        }\n-        end.equal = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setUpper(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.upper != null) {\n-          return false;\n-        }\n-        start.upper = range;\n-      } else {\n-        if (end.upper != null) {\n-          return false;\n-        }\n-        end.upper = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setLower(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.lower != null) {\n-          return false;\n-        }\n-        start.lower = range;\n-      } else {\n-        if (end.lower != null) {\n-          return false;\n-        }\n-        end.lower = range;\n-      }\n-      return true;\n-    }\n-\n-    public WindowRange getStart() {\n-      return start;\n-    }\n-\n-    public WindowRange getEnd() {\n-      return end;\n-    }\n-\n-    public Range<Instant> getMergedStart() {\n-      return start.getMergedRange();\n-    }\n-\n-    public Range<Instant> getMergedEnd() {\n-      return end.getMergedRange();\n-    }\n-\n-\n-    @Override\n-    public boolean equals(final Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      final WindowBounds that = (WindowBounds) o;\n-      return Objects.equals(start, that.start)\n-          && Objects.equals(end, that.end);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hash(start, end);\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"WindowBounds{\"\n-          + \"start=\" + start\n-          + \", end=\" + end\n-          + '}';\n-    }\n-\n-    static final class WindowRange {\n-      private Range<Instant> equal;\n-      private Range<Instant> upper;\n-      private Range<Instant> lower;\n-\n-      WindowRange(\n-          final Range<Instant> equal,\n-          final Range<Instant> upper,\n-          final Range<Instant> lower\n-      ) {\n-        this.equal = equal;\n-        this.upper = upper;\n-        this.lower = lower;\n-      }\n-\n-      WindowRange() {\n-      }\n-\n-      public Range<Instant> getEqual() {\n-        return equal;\n-      }\n-\n-      public Range<Instant> getUpper() {\n-        return upper;\n-      }\n-\n-      public Range<Instant> getLower() {\n-        return lower;\n-      }\n-\n-      Range<Instant> getMergedRange() {\n-        if (lower == null && upper == null && equal == null) {\n-          return Range.all();\n-        }\n-        if (lower != null && upper != null) {\n-          return Range.range(\n-              lower.lowerEndpoint(), lower.lowerBoundType(),\n-              upper.upperEndpoint(), upper.upperBoundType()\n-          );\n-        }\n-        if (upper != null) {\n-          return upper;\n-        }\n-        if (lower != null) {\n-          return lower;\n-        }\n-        return equal;\n-      }\n-\n-      @Override\n-      public boolean equals(final Object o) {\n-        if (this == o) {\n-          return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-          return false;\n-        }\n-\n-        final WindowRange that = (WindowRange) o;\n-        return Objects.equals(equal, that.equal)\n-            && Objects.equals(upper, that.upper)\n-            && Objects.equals(lower, that.lower);\n-      }\n-\n-      @Override\n-      public int hashCode() {\n-        return Objects.hash(equal, upper, lower);\n-      }\n-\n-      @Override\n-      public String toString() {\n-        return \"WindowRange{\"\n-            + \"equal=\" + equal\n-            + \", upper=\" + upper\n-            + \", lower=\" + lower\n-            + '}';\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = !systemColumns.isEmpty();\n-\n-    final boolean hasKeyColumns = !keyColumns.isEmpty();\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTM0Nw==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551475347", "bodyText": "You're effectively using this version of seenKeys to check that they're not attempting to use a key twice, right?  If you changed this to a counter rather than a bit set, you could initialize it once in ExtractKeyValues and then just do the check in a single place without traversing the expression again.", "author": "AlanConfluent", "createdAt": "2021-01-04T17:59:57Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());\n+    final Validator validator = new Validator();\n+    validator.process(rewrittenPredicate, null);\n+    if (!isKeyedQuery) {\n+      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n+    }\n+\n+    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n+      final List<ColumnName> seenKeyNames = seenKeys\n+          .stream()\n+          .boxed()\n+          .map(i -> schema.key().get(i))\n+          .map(Column::name)\n+          .collect(Collectors.toList());\n+      throw invalidWhereClauseException(\n+          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n+              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n+    }\n+  }\n+\n+  private void extractKeysAndSystemCols() {\n+    keyColumns = new HashSet<>();\n+    systemColumns = new HashSet<>();\n+    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n+  }\n+\n+  private List<GenericKey> extractKeyValues() {\n+    inKeys = new ArrayList<>();\n+    keyContents = new Object[schema.key().size()];\n+    seenKeys = new BitSet(schema.key().size());\n+\n+    new KeyValueExtractor().process(rewrittenPredicate, null);\n+    if (!inKeys.isEmpty()) {\n+      return (inKeys);\n+    }\n+\n+    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n+  }\n+\n+  private WindowBounds extractWindowBounds() {\n+    final WindowBounds windowBounds = new WindowBounds();\n+\n+    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n+    return windowBounds;\n+  }\n+\n+  /**\n+   * Validate the WHERE clause for pull queries.\n+   * 1. There must be exactly one equality condition per key\n+   * or one IN predicate that involves a key.\n+   * 2. An IN predicate can refer to a single key.\n+   * 3. The IN predicate cannot be combined with other conditions.\n+   * 4. Only AND is allowed.\n+   * 5. If there is a multi-key, conditions on all keys must be specified.\n+   * 6. The IN predicate cannot use multi-keys.\n+   */\n+  private final class Validator extends TraversalExpressionVisitor<Object> {\n+\n+    @Override\n+    public Void process(final Expression node, final Object context) {\n+      if (!(node instanceof  LogicalBinaryExpression)\n+          && !(node instanceof  ComparisonExpression)\n+          && !(node instanceof  InPredicate)) {\n+        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n+      }\n+      super.process(node, context);\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitLogicalBinaryExpression(\n+        final LogicalBinaryExpression node,\n+        final Object context\n+    ) {\n+      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n+        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n+      }\n+      process(node.getLeft(), context);\n+      process(node.getRight(), context);\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitComparisonExpression(\n+        final ComparisonExpression node,\n+        final Object context\n+    ) {\n+      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n+\n+      final ColumnName columnName = column.getColumnName();\n+      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n+          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n+        final Type type = node.getType();\n+        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n+          throw invalidWhereClauseException(\n+              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n+        }\n+        if (!isWindowed) {\n+          throw invalidWhereClauseException(\n+              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n+              false);\n+        }\n+        return null;\n+      } else {\n+        final Column col = schema.findColumn(columnName)\n+            .orElseThrow(() -> invalidWhereClauseException(\n+                \"Bound on non-key column \" + columnName, isWindowed));\n+\n+        if (col.namespace() == Namespace.KEY) {\n+          if (node.getType() != Type.EQUAL) {\n+            throw invalidWhereClauseException(\n+                \"Bound on key columns '\" + getSource().getSchema().key()\n+                    + \"' must currently be '='\",\n+                isWindowed);\n+          }\n+          if (containsINkeys || seenKeys.get(col.index())) {\n+            throw invalidWhereClauseException(\n+                \"An equality condition on the key column cannot be combined with other comparisons\"\n+                    + \" such as an IN predicate\",\n+                isWindowed);\n+          }\n+          seenKeys.set(col.index());", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA4NzQ3NQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553087475", "bodyText": "This is actually to check that every column of the key has a constraint. With the counter you lose the information of which column you have seen", "author": "vpapavas", "createdAt": "2021-01-07T03:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ3OTE2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553479162", "bodyText": "Sorry, I mean, a map of counters so you could know how many times you saw a column.  Not a huge deal.", "author": "AlanConfluent", "createdAt": "2021-01-07T17:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTM0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\ndeleted file mode 100644\nindex 13d9328c3b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\n+++ /dev/null\n\n@@ -1,823 +0,0 @@\n-/*\n- * Copyright 2019 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.collect.BoundType;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Range;\n-import io.confluent.ksql.GenericKey;\n-import io.confluent.ksql.analyzer.PullQueryValidator;\n-import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n-import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n-import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n-import io.confluent.ksql.execution.expression.tree.Expression;\n-import io.confluent.ksql.execution.expression.tree.InPredicate;\n-import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n-import io.confluent.ksql.execution.expression.tree.Literal;\n-import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n-import io.confluent.ksql.execution.expression.tree.LongLiteral;\n-import io.confluent.ksql.execution.expression.tree.NullLiteral;\n-import io.confluent.ksql.execution.expression.tree.StringLiteral;\n-import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n-import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.name.ColumnName;\n-import io.confluent.ksql.schema.ksql.Column;\n-import io.confluent.ksql.schema.ksql.Column.Namespace;\n-import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.utils.FormatOptions;\n-import io.confluent.ksql.structured.SchemaKStream;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class PullFilterNode extends SingleSourcePlanNode {\n-\n-  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n-      Type.EQUAL,\n-      Type.GREATER_THAN,\n-      Type.GREATER_THAN_OR_EQUAL,\n-      Type.LESS_THAN,\n-      Type.LESS_THAN_OR_EQUAL\n-  );\n-\n-  private final boolean isWindowed;\n-  private final ExpressionMetadata compiledWhereClause;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final MetaStore metaStore;\n-  private final KsqlConfig ksqlConfig;\n-  private final LogicalSchema schema = getSource().getSchema();\n-\n-  private Expression rewrittenPredicate;\n-  private boolean isKeyedQuery = false;\n-  private Optional<WindowBounds> windowBounds;\n-  private List<GenericKey> keyValues;\n-  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n-  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n-  private List<GenericKey> inKeys;\n-  private BitSet seenKeys;\n-  private Object[] keyContents;\n-  private boolean containsINkeys;\n-\n-  public PullFilterNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final Expression predicate,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final boolean isWindowed\n-  ) {\n-    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n-\n-    Objects.requireNonNull(predicate, \"predicate\");\n-    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n-    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n-    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n-    this.isWindowed = isWindowed;\n-\n-    // Basic validation of WHERE clause\n-    validateWhereClause();\n-\n-    // Validation and extractions of window bounds\n-    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n-\n-    // Extraction of key and system columns\n-    extractKeysAndSystemCols();\n-\n-    // Extraction of key values\n-    keyValues = extractKeyValues();\n-\n-    // Compiling expression into byte code\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n-        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n-    compiledWhereClause = CodeGenRunner.compileExpression(\n-        rewrittenPredicate,\n-        \"Predicate\",\n-        intermediateSchema,\n-        ksqlConfig,\n-        metaStore\n-    );\n-\n-  }\n-\n-  public Expression getRewrittenPredicate() {\n-    return rewrittenPredicate;\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return getSource().getSchema();\n-  }\n-\n-  @Override\n-  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  public ExpressionMetadata getCompiledWhereClause() {\n-    return compiledWhereClause;\n-  }\n-\n-  public boolean isKeyedQuery() {\n-    return isKeyedQuery;\n-  }\n-\n-  public boolean isWindowed() {\n-    return isWindowed;\n-  }\n-\n-  public List<GenericKey> getKeyValues() {\n-    return keyValues;\n-  }\n-\n-  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n-    return keyColumns;\n-  }\n-\n-  public Optional<WindowBounds> getWindowBounds() {\n-    return windowBounds;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  private void validateWhereClause() {\n-    seenKeys = new BitSet(schema.key().size());\n-    final Validator validator = new Validator();\n-    validator.process(rewrittenPredicate, null);\n-    if (!isKeyedQuery) {\n-      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n-    }\n-\n-    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n-      final List<ColumnName> seenKeyNames = seenKeys\n-          .stream()\n-          .boxed()\n-          .map(i -> schema.key().get(i))\n-          .map(Column::name)\n-          .collect(Collectors.toList());\n-      throw invalidWhereClauseException(\n-          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n-              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n-    }\n-  }\n-\n-  private void extractKeysAndSystemCols() {\n-    keyColumns = new HashSet<>();\n-    systemColumns = new HashSet<>();\n-    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n-  }\n-\n-  private List<GenericKey> extractKeyValues() {\n-    inKeys = new ArrayList<>();\n-    keyContents = new Object[schema.key().size()];\n-    seenKeys = new BitSet(schema.key().size());\n-\n-    new KeyValueExtractor().process(rewrittenPredicate, null);\n-    if (!inKeys.isEmpty()) {\n-      return (inKeys);\n-    }\n-\n-    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n-  }\n-\n-  private WindowBounds extractWindowBounds() {\n-    final WindowBounds windowBounds = new WindowBounds();\n-\n-    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n-    return windowBounds;\n-  }\n-\n-  /**\n-   * Validate the WHERE clause for pull queries.\n-   * 1. There must be exactly one equality condition per key\n-   * or one IN predicate that involves a key.\n-   * 2. An IN predicate can refer to a single key.\n-   * 3. The IN predicate cannot be combined with other conditions.\n-   * 4. Only AND is allowed.\n-   * 5. If there is a multi-key, conditions on all keys must be specified.\n-   * 6. The IN predicate cannot use multi-keys.\n-   */\n-  private final class Validator extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void process(final Expression node, final Object context) {\n-      if (!(node instanceof  LogicalBinaryExpression)\n-          && !(node instanceof  ComparisonExpression)\n-          && !(node instanceof  InPredicate)) {\n-        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n-      }\n-      super.process(node, context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitLogicalBinaryExpression(\n-        final LogicalBinaryExpression node,\n-        final Object context\n-    ) {\n-      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n-        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n-      }\n-      process(node.getLeft(), context);\n-      process(node.getRight(), context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final Object context\n-    ) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-\n-      final ColumnName columnName = column.getColumnName();\n-      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n-          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n-        final Type type = node.getType();\n-        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n-          throw invalidWhereClauseException(\n-              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n-        }\n-        if (!isWindowed) {\n-          throw invalidWhereClauseException(\n-              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n-              false);\n-        }\n-        return null;\n-      } else {\n-        final Column col = schema.findColumn(columnName)\n-            .orElseThrow(() -> invalidWhereClauseException(\n-                \"Bound on non-key column \" + columnName, isWindowed));\n-\n-        if (col.namespace() == Namespace.KEY) {\n-          if (node.getType() != Type.EQUAL) {\n-            throw invalidWhereClauseException(\n-                \"Bound on key columns '\" + getSource().getSchema().key()\n-                    + \"' must currently be '='\",\n-                isWindowed);\n-          }\n-          if (containsINkeys || seenKeys.get(col.index())) {\n-            throw invalidWhereClauseException(\n-                \"An equality condition on the key column cannot be combined with other comparisons\"\n-                    + \" such as an IN predicate\",\n-                isWindowed);\n-          }\n-          seenKeys.set(col.index());\n-          isKeyedQuery = true;\n-          return null;\n-        }\n-\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on non-key column: \" + columnName.text(),\n-            false\n-        );\n-      }\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node,\n-        final Object context\n-    ) {\n-      if (schema.key().size() > 1) {\n-        throw invalidWhereClauseException(\n-            \"Schemas with multiple KEY columns are not supported for IN predicates\", false);\n-      }\n-\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        if (!seenKeys.isEmpty()) {\n-          throw invalidWhereClauseException(\n-              \"The IN predicate cannot be combined with other comparisons on the key column\",\n-              isWindowed);\n-        }\n-        containsINkeys = true;\n-        isKeyedQuery = true;\n-      } else {\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on unsupported column: \" + column.getColumnName().text(),\n-            false\n-        );\n-      }\n-      return null;\n-    }\n-  }\n-\n-  private UnqualifiedColumnReferenceExp getColumnRefSide(final ComparisonExpression comp) {\n-    return (UnqualifiedColumnReferenceExp)\n-        (comp.getRight() instanceof UnqualifiedColumnReferenceExp\n-            ? comp.getRight() : comp.getLeft());\n-  }\n-\n-  private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-    return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-        ? comparison.getLeft()\n-        : comparison.getRight();\n-  }\n-\n-  /**\n-   * Extracts the key and system columns that appear in the WHERE clause.\n-   */\n-  private final class KeyAndSystemColsExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitUnqualifiedColumnReference(\n-        final UnqualifiedColumnReferenceExp node, final Object context) {\n-      final Optional<Column> col = schema.findColumn(node.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        keyColumns.add(node);\n-      } else if (SystemColumns.isSystemColumn(node.getColumnName())) {\n-        systemColumns.add(node);\n-      }\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * Extracts the values for the keys that appear in the WHERE clause.\n-   * Necessary so that we can do key lookups when scanning the data stores.\n-   */\n-  private final class KeyValueExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-      final Expression other = getNonColumnRefSide(node);\n-      final ColumnName columnName = column.getColumnName();\n-\n-      final Optional<Column> col = schema.findColumn(columnName);\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        final Object key = resolveKey(other, col.get(), metaStore, ksqlConfig, node);\n-        keyContents[col.get().index()] = key;\n-        seenKeys.set(col.get().index());\n-      }\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        inKeys.addAll(node.getValueList()\n-            .getValues()\n-            .stream()\n-            .map(expression -> resolveKey(expression, col.get(), metaStore, ksqlConfig, node))\n-            .map(GenericKey::genericKey)\n-            .collect(Collectors.toList()));\n-      }\n-      return null;\n-    }\n-\n-    private Object resolveKey(\n-        final Expression exp,\n-        final Column keyColumn,\n-        final MetaStore metaStore,\n-        final KsqlConfig config,\n-        final Expression errorMessageHint\n-    ) {\n-      final Object obj;\n-      if (exp instanceof NullLiteral) {\n-        obj = null;\n-      } else if (exp instanceof Literal) {\n-        // skip the GenericExpressionResolver because this is\n-        // a critical code path executed once-per-query\n-        obj = ((Literal) exp).getValue();\n-      } else {\n-        obj = new GenericExpressionResolver(\n-            keyColumn.type(),\n-            keyColumn.name(),\n-            metaStore,\n-            config,\n-            \"pull query\"\n-        ).resolve(exp);\n-      }\n-\n-      if (obj == null) {\n-        throw new KsqlException(\"Primary key columns can not be NULL: \" + errorMessageHint);\n-      }\n-\n-      return DefaultSqlValueCoercer.STRICT.coerce(obj, keyColumn.type())\n-          .orElseThrow(() -> new KsqlException(\n-              \"'\" + obj + \"' can not be converted \"\n-                  + \"to the type of the key column: \"\n-                  + keyColumn.toString(\n-                  FormatOptions.noEscape())))\n-          .orElse(null);\n-    }\n-  }\n-\n-\n-  /**\n-   * Extracts the upper and lower bounds on windowstart/windowend columns.\n-   * Performs the following validations on the window bounds:\n-   * 1. An equality bound cannot be combined with other bounds.\n-   * 2. No duplicate bounds are allowed, such as multiple greater than bounds.\n-   */\n-  private final class WindowBoundsExtractor extends TraversalExpressionVisitor<WindowBounds> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final WindowBounds windowBounds\n-    ) {\n-      final UnqualifiedColumnReferenceExp column;\n-      if (node.getRight() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getRight();\n-      } else if (node.getLeft() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getLeft();\n-      } else {\n-        return null;\n-      }\n-\n-      if (!column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)\n-          && !column.getColumnName().equals(SystemColumns.WINDOWEND_NAME)) {\n-        return null;\n-      }\n-      boolean result = false;\n-      if (node.getType().equals(Type.EQUAL)) {\n-        final Range<Instant> instant = Range.singleton(asInstant(getNonColumnRefSide(node)));\n-        result = windowBounds.setEquality(column, instant);\n-      }\n-      final Type type = getSimplifiedBoundType(node);\n-\n-      if (type.equals(Type.LESS_THAN)) {\n-        final Instant upper = asInstant(getNonColumnRefSide(node));\n-        final BoundType upperType = getRangeBoundType(node);\n-        result = windowBounds.setUpper(column, Range.upTo(upper, upperType));\n-      } else if (type.equals(Type.GREATER_THAN)) {\n-        final Instant lower = asInstant(getNonColumnRefSide(node));\n-        final BoundType lowerType = getRangeBoundType(node);\n-        result = windowBounds.setLower(column, Range.downTo(lower, lowerType));\n-      }\n-      validateEqualityBound(windowBounds, node, column);\n-      if (!result) {\n-        throw invalidWhereClauseException(\n-            \"Duplicate \" + column.getColumnName() + \" bounds on: \" + type, true);\n-      }\n-      return null;\n-    }\n-\n-    private void validateEqualityBound(\n-        final WindowBounds bound,\n-        final ComparisonExpression expression,\n-        final UnqualifiedColumnReferenceExp column\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (bound.getStart().getEqual() != null\n-            && (bound.getStart().getUpper() != null || bound.getStart().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-        }\n-      } else {\n-        if (bound.getEnd().getEqual() != null\n-            && (bound.getEnd().getUpper() != null || bound.getEnd().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-\n-        }\n-      }\n-    }\n-\n-    private Type getSimplifiedBoundType(final ComparisonExpression comparison) {\n-      final Type type = comparison.getType();\n-      final boolean inverted = comparison.getRight() instanceof UnqualifiedColumnReferenceExp;\n-\n-      switch (type) {\n-        case LESS_THAN:\n-        case LESS_THAN_OR_EQUAL:\n-          return inverted ? Type.GREATER_THAN : Type.LESS_THAN;\n-        case GREATER_THAN:\n-        case GREATER_THAN_OR_EQUAL:\n-          return inverted ? Type.LESS_THAN : Type.GREATER_THAN;\n-        default:\n-          return type;\n-      }\n-    }\n-\n-    private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-      return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-          ? comparison.getLeft()\n-          : comparison.getRight();\n-    }\n-\n-    private Instant asInstant(final Expression other) {\n-      if (other instanceof IntegerLiteral) {\n-        return Instant.ofEpochMilli(((IntegerLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof LongLiteral) {\n-        return Instant.ofEpochMilli(((LongLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof StringLiteral) {\n-        final String text = ((StringLiteral) other).getValue();\n-        try {\n-          final long timestamp = new PartialStringToTimestampParser()\n-              .parse(text);\n-\n-          return Instant.ofEpochMilli(timestamp);\n-        } catch (final Exception e) {\n-          throw invalidWhereClauseException(\"Failed to parse datetime: \" + text, true);\n-        }\n-      }\n-\n-      throw invalidWhereClauseException(\n-          \"Window bounds must be an INT, BIGINT or STRING containing a datetime.\",\n-          true\n-      );\n-    }\n-\n-    private BoundType getRangeBoundType(final ComparisonExpression lowerComparison) {\n-      final boolean openBound = lowerComparison.getType() == Type.LESS_THAN\n-          || lowerComparison.getType() == Type.GREATER_THAN;\n-\n-      return openBound\n-          ? BoundType.OPEN\n-          : BoundType.CLOSED;\n-    }\n-  }\n-\n-  private KsqlException invalidWhereClauseException(\n-      final String msg,\n-      final boolean windowed\n-  ) {\n-    final String additional = !windowed\n-        ? \"\"\n-        : System.lineSeparator()\n-            + \" - (optionally) limits the time bounds of the windowed table.\"\n-            + System.lineSeparator()\n-            + \"\\t Bounds on \" + SystemColumns.windowBoundsColumnNames() + \" are supported\"\n-            + System.lineSeparator()\n-            + \"\\t Supported operators are \" + VALID_WINDOW_BOUND_COMPARISONS;\n-\n-    return new KsqlException(\n-        msg\n-            + \". \"\n-            + PullQueryValidator.PULL_QUERY_SYNTAX_HELP\n-            + System.lineSeparator()\n-            + \"Pull queries require a WHERE clause that:\"\n-            + System.lineSeparator()\n-            + \" - limits the query to keys only, e.g. `SELECT * FROM X WHERE <key-column>=Y;`.\"\n-            + System.lineSeparator()\n-            + \" - specifies an equality condition that is a conjunction of equality expressions \"\n-            + \"that cover all keys.\"\n-            + additional\n-    );\n-  }\n-\n-  public static final class WindowBounds {\n-\n-    private WindowRange start;\n-    private WindowRange end;\n-\n-    public WindowBounds(final WindowRange start, final WindowRange end) {\n-      this.start = Objects.requireNonNull(start, \"startBounds\");\n-      this.end = Objects.requireNonNull(end, \"endBounds\");\n-    }\n-\n-    public WindowBounds() {\n-      this.start = new WindowRange();\n-      this.end = new WindowRange();\n-    }\n-\n-    boolean setEquality(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.equal != null) {\n-          return false;\n-        }\n-        start.equal = range;\n-      } else {\n-        if (end.equal != null) {\n-          return false;\n-        }\n-        end.equal = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setUpper(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.upper != null) {\n-          return false;\n-        }\n-        start.upper = range;\n-      } else {\n-        if (end.upper != null) {\n-          return false;\n-        }\n-        end.upper = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setLower(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.lower != null) {\n-          return false;\n-        }\n-        start.lower = range;\n-      } else {\n-        if (end.lower != null) {\n-          return false;\n-        }\n-        end.lower = range;\n-      }\n-      return true;\n-    }\n-\n-    public WindowRange getStart() {\n-      return start;\n-    }\n-\n-    public WindowRange getEnd() {\n-      return end;\n-    }\n-\n-    public Range<Instant> getMergedStart() {\n-      return start.getMergedRange();\n-    }\n-\n-    public Range<Instant> getMergedEnd() {\n-      return end.getMergedRange();\n-    }\n-\n-\n-    @Override\n-    public boolean equals(final Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      final WindowBounds that = (WindowBounds) o;\n-      return Objects.equals(start, that.start)\n-          && Objects.equals(end, that.end);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hash(start, end);\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"WindowBounds{\"\n-          + \"start=\" + start\n-          + \", end=\" + end\n-          + '}';\n-    }\n-\n-    static final class WindowRange {\n-      private Range<Instant> equal;\n-      private Range<Instant> upper;\n-      private Range<Instant> lower;\n-\n-      WindowRange(\n-          final Range<Instant> equal,\n-          final Range<Instant> upper,\n-          final Range<Instant> lower\n-      ) {\n-        this.equal = equal;\n-        this.upper = upper;\n-        this.lower = lower;\n-      }\n-\n-      WindowRange() {\n-      }\n-\n-      public Range<Instant> getEqual() {\n-        return equal;\n-      }\n-\n-      public Range<Instant> getUpper() {\n-        return upper;\n-      }\n-\n-      public Range<Instant> getLower() {\n-        return lower;\n-      }\n-\n-      Range<Instant> getMergedRange() {\n-        if (lower == null && upper == null && equal == null) {\n-          return Range.all();\n-        }\n-        if (lower != null && upper != null) {\n-          return Range.range(\n-              lower.lowerEndpoint(), lower.lowerBoundType(),\n-              upper.upperEndpoint(), upper.upperBoundType()\n-          );\n-        }\n-        if (upper != null) {\n-          return upper;\n-        }\n-        if (lower != null) {\n-          return lower;\n-        }\n-        return equal;\n-      }\n-\n-      @Override\n-      public boolean equals(final Object o) {\n-        if (this == o) {\n-          return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-          return false;\n-        }\n-\n-        final WindowRange that = (WindowRange) o;\n-        return Objects.equals(equal, that.equal)\n-            && Objects.equals(upper, that.upper)\n-            && Objects.equals(lower, that.lower);\n-      }\n-\n-      @Override\n-      public int hashCode() {\n-        return Objects.hash(equal, upper, lower);\n-      }\n-\n-      @Override\n-      public String toString() {\n-        return \"WindowRange{\"\n-            + \"equal=\" + equal\n-            + \", upper=\" + upper\n-            + \", lower=\" + lower\n-            + '}';\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = !systemColumns.isEmpty();\n-\n-    final boolean hasKeyColumns = !keyColumns.isEmpty();\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3Nzg5MQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551477891", "bodyText": "I find the reuse, multiple times, of the field seenKeys to be confusing.  Why not just make this a field of Validator and add a getter for it to be checked below?", "author": "AlanConfluent", "createdAt": "2021-01-04T18:05:04Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\ndeleted file mode 100644\nindex 13d9328c3b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\n+++ /dev/null\n\n@@ -1,823 +0,0 @@\n-/*\n- * Copyright 2019 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.collect.BoundType;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Range;\n-import io.confluent.ksql.GenericKey;\n-import io.confluent.ksql.analyzer.PullQueryValidator;\n-import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n-import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n-import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n-import io.confluent.ksql.execution.expression.tree.Expression;\n-import io.confluent.ksql.execution.expression.tree.InPredicate;\n-import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n-import io.confluent.ksql.execution.expression.tree.Literal;\n-import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n-import io.confluent.ksql.execution.expression.tree.LongLiteral;\n-import io.confluent.ksql.execution.expression.tree.NullLiteral;\n-import io.confluent.ksql.execution.expression.tree.StringLiteral;\n-import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n-import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.name.ColumnName;\n-import io.confluent.ksql.schema.ksql.Column;\n-import io.confluent.ksql.schema.ksql.Column.Namespace;\n-import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.utils.FormatOptions;\n-import io.confluent.ksql.structured.SchemaKStream;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class PullFilterNode extends SingleSourcePlanNode {\n-\n-  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n-      Type.EQUAL,\n-      Type.GREATER_THAN,\n-      Type.GREATER_THAN_OR_EQUAL,\n-      Type.LESS_THAN,\n-      Type.LESS_THAN_OR_EQUAL\n-  );\n-\n-  private final boolean isWindowed;\n-  private final ExpressionMetadata compiledWhereClause;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final MetaStore metaStore;\n-  private final KsqlConfig ksqlConfig;\n-  private final LogicalSchema schema = getSource().getSchema();\n-\n-  private Expression rewrittenPredicate;\n-  private boolean isKeyedQuery = false;\n-  private Optional<WindowBounds> windowBounds;\n-  private List<GenericKey> keyValues;\n-  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n-  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n-  private List<GenericKey> inKeys;\n-  private BitSet seenKeys;\n-  private Object[] keyContents;\n-  private boolean containsINkeys;\n-\n-  public PullFilterNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final Expression predicate,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final boolean isWindowed\n-  ) {\n-    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n-\n-    Objects.requireNonNull(predicate, \"predicate\");\n-    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n-    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n-    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n-    this.isWindowed = isWindowed;\n-\n-    // Basic validation of WHERE clause\n-    validateWhereClause();\n-\n-    // Validation and extractions of window bounds\n-    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n-\n-    // Extraction of key and system columns\n-    extractKeysAndSystemCols();\n-\n-    // Extraction of key values\n-    keyValues = extractKeyValues();\n-\n-    // Compiling expression into byte code\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n-        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n-    compiledWhereClause = CodeGenRunner.compileExpression(\n-        rewrittenPredicate,\n-        \"Predicate\",\n-        intermediateSchema,\n-        ksqlConfig,\n-        metaStore\n-    );\n-\n-  }\n-\n-  public Expression getRewrittenPredicate() {\n-    return rewrittenPredicate;\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return getSource().getSchema();\n-  }\n-\n-  @Override\n-  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  public ExpressionMetadata getCompiledWhereClause() {\n-    return compiledWhereClause;\n-  }\n-\n-  public boolean isKeyedQuery() {\n-    return isKeyedQuery;\n-  }\n-\n-  public boolean isWindowed() {\n-    return isWindowed;\n-  }\n-\n-  public List<GenericKey> getKeyValues() {\n-    return keyValues;\n-  }\n-\n-  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n-    return keyColumns;\n-  }\n-\n-  public Optional<WindowBounds> getWindowBounds() {\n-    return windowBounds;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  private void validateWhereClause() {\n-    seenKeys = new BitSet(schema.key().size());\n-    final Validator validator = new Validator();\n-    validator.process(rewrittenPredicate, null);\n-    if (!isKeyedQuery) {\n-      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n-    }\n-\n-    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n-      final List<ColumnName> seenKeyNames = seenKeys\n-          .stream()\n-          .boxed()\n-          .map(i -> schema.key().get(i))\n-          .map(Column::name)\n-          .collect(Collectors.toList());\n-      throw invalidWhereClauseException(\n-          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n-              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n-    }\n-  }\n-\n-  private void extractKeysAndSystemCols() {\n-    keyColumns = new HashSet<>();\n-    systemColumns = new HashSet<>();\n-    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n-  }\n-\n-  private List<GenericKey> extractKeyValues() {\n-    inKeys = new ArrayList<>();\n-    keyContents = new Object[schema.key().size()];\n-    seenKeys = new BitSet(schema.key().size());\n-\n-    new KeyValueExtractor().process(rewrittenPredicate, null);\n-    if (!inKeys.isEmpty()) {\n-      return (inKeys);\n-    }\n-\n-    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n-  }\n-\n-  private WindowBounds extractWindowBounds() {\n-    final WindowBounds windowBounds = new WindowBounds();\n-\n-    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n-    return windowBounds;\n-  }\n-\n-  /**\n-   * Validate the WHERE clause for pull queries.\n-   * 1. There must be exactly one equality condition per key\n-   * or one IN predicate that involves a key.\n-   * 2. An IN predicate can refer to a single key.\n-   * 3. The IN predicate cannot be combined with other conditions.\n-   * 4. Only AND is allowed.\n-   * 5. If there is a multi-key, conditions on all keys must be specified.\n-   * 6. The IN predicate cannot use multi-keys.\n-   */\n-  private final class Validator extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void process(final Expression node, final Object context) {\n-      if (!(node instanceof  LogicalBinaryExpression)\n-          && !(node instanceof  ComparisonExpression)\n-          && !(node instanceof  InPredicate)) {\n-        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n-      }\n-      super.process(node, context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitLogicalBinaryExpression(\n-        final LogicalBinaryExpression node,\n-        final Object context\n-    ) {\n-      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n-        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n-      }\n-      process(node.getLeft(), context);\n-      process(node.getRight(), context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final Object context\n-    ) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-\n-      final ColumnName columnName = column.getColumnName();\n-      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n-          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n-        final Type type = node.getType();\n-        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n-          throw invalidWhereClauseException(\n-              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n-        }\n-        if (!isWindowed) {\n-          throw invalidWhereClauseException(\n-              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n-              false);\n-        }\n-        return null;\n-      } else {\n-        final Column col = schema.findColumn(columnName)\n-            .orElseThrow(() -> invalidWhereClauseException(\n-                \"Bound on non-key column \" + columnName, isWindowed));\n-\n-        if (col.namespace() == Namespace.KEY) {\n-          if (node.getType() != Type.EQUAL) {\n-            throw invalidWhereClauseException(\n-                \"Bound on key columns '\" + getSource().getSchema().key()\n-                    + \"' must currently be '='\",\n-                isWindowed);\n-          }\n-          if (containsINkeys || seenKeys.get(col.index())) {\n-            throw invalidWhereClauseException(\n-                \"An equality condition on the key column cannot be combined with other comparisons\"\n-                    + \" such as an IN predicate\",\n-                isWindowed);\n-          }\n-          seenKeys.set(col.index());\n-          isKeyedQuery = true;\n-          return null;\n-        }\n-\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on non-key column: \" + columnName.text(),\n-            false\n-        );\n-      }\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node,\n-        final Object context\n-    ) {\n-      if (schema.key().size() > 1) {\n-        throw invalidWhereClauseException(\n-            \"Schemas with multiple KEY columns are not supported for IN predicates\", false);\n-      }\n-\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        if (!seenKeys.isEmpty()) {\n-          throw invalidWhereClauseException(\n-              \"The IN predicate cannot be combined with other comparisons on the key column\",\n-              isWindowed);\n-        }\n-        containsINkeys = true;\n-        isKeyedQuery = true;\n-      } else {\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on unsupported column: \" + column.getColumnName().text(),\n-            false\n-        );\n-      }\n-      return null;\n-    }\n-  }\n-\n-  private UnqualifiedColumnReferenceExp getColumnRefSide(final ComparisonExpression comp) {\n-    return (UnqualifiedColumnReferenceExp)\n-        (comp.getRight() instanceof UnqualifiedColumnReferenceExp\n-            ? comp.getRight() : comp.getLeft());\n-  }\n-\n-  private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-    return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-        ? comparison.getLeft()\n-        : comparison.getRight();\n-  }\n-\n-  /**\n-   * Extracts the key and system columns that appear in the WHERE clause.\n-   */\n-  private final class KeyAndSystemColsExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitUnqualifiedColumnReference(\n-        final UnqualifiedColumnReferenceExp node, final Object context) {\n-      final Optional<Column> col = schema.findColumn(node.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        keyColumns.add(node);\n-      } else if (SystemColumns.isSystemColumn(node.getColumnName())) {\n-        systemColumns.add(node);\n-      }\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * Extracts the values for the keys that appear in the WHERE clause.\n-   * Necessary so that we can do key lookups when scanning the data stores.\n-   */\n-  private final class KeyValueExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-      final Expression other = getNonColumnRefSide(node);\n-      final ColumnName columnName = column.getColumnName();\n-\n-      final Optional<Column> col = schema.findColumn(columnName);\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        final Object key = resolveKey(other, col.get(), metaStore, ksqlConfig, node);\n-        keyContents[col.get().index()] = key;\n-        seenKeys.set(col.get().index());\n-      }\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        inKeys.addAll(node.getValueList()\n-            .getValues()\n-            .stream()\n-            .map(expression -> resolveKey(expression, col.get(), metaStore, ksqlConfig, node))\n-            .map(GenericKey::genericKey)\n-            .collect(Collectors.toList()));\n-      }\n-      return null;\n-    }\n-\n-    private Object resolveKey(\n-        final Expression exp,\n-        final Column keyColumn,\n-        final MetaStore metaStore,\n-        final KsqlConfig config,\n-        final Expression errorMessageHint\n-    ) {\n-      final Object obj;\n-      if (exp instanceof NullLiteral) {\n-        obj = null;\n-      } else if (exp instanceof Literal) {\n-        // skip the GenericExpressionResolver because this is\n-        // a critical code path executed once-per-query\n-        obj = ((Literal) exp).getValue();\n-      } else {\n-        obj = new GenericExpressionResolver(\n-            keyColumn.type(),\n-            keyColumn.name(),\n-            metaStore,\n-            config,\n-            \"pull query\"\n-        ).resolve(exp);\n-      }\n-\n-      if (obj == null) {\n-        throw new KsqlException(\"Primary key columns can not be NULL: \" + errorMessageHint);\n-      }\n-\n-      return DefaultSqlValueCoercer.STRICT.coerce(obj, keyColumn.type())\n-          .orElseThrow(() -> new KsqlException(\n-              \"'\" + obj + \"' can not be converted \"\n-                  + \"to the type of the key column: \"\n-                  + keyColumn.toString(\n-                  FormatOptions.noEscape())))\n-          .orElse(null);\n-    }\n-  }\n-\n-\n-  /**\n-   * Extracts the upper and lower bounds on windowstart/windowend columns.\n-   * Performs the following validations on the window bounds:\n-   * 1. An equality bound cannot be combined with other bounds.\n-   * 2. No duplicate bounds are allowed, such as multiple greater than bounds.\n-   */\n-  private final class WindowBoundsExtractor extends TraversalExpressionVisitor<WindowBounds> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final WindowBounds windowBounds\n-    ) {\n-      final UnqualifiedColumnReferenceExp column;\n-      if (node.getRight() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getRight();\n-      } else if (node.getLeft() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getLeft();\n-      } else {\n-        return null;\n-      }\n-\n-      if (!column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)\n-          && !column.getColumnName().equals(SystemColumns.WINDOWEND_NAME)) {\n-        return null;\n-      }\n-      boolean result = false;\n-      if (node.getType().equals(Type.EQUAL)) {\n-        final Range<Instant> instant = Range.singleton(asInstant(getNonColumnRefSide(node)));\n-        result = windowBounds.setEquality(column, instant);\n-      }\n-      final Type type = getSimplifiedBoundType(node);\n-\n-      if (type.equals(Type.LESS_THAN)) {\n-        final Instant upper = asInstant(getNonColumnRefSide(node));\n-        final BoundType upperType = getRangeBoundType(node);\n-        result = windowBounds.setUpper(column, Range.upTo(upper, upperType));\n-      } else if (type.equals(Type.GREATER_THAN)) {\n-        final Instant lower = asInstant(getNonColumnRefSide(node));\n-        final BoundType lowerType = getRangeBoundType(node);\n-        result = windowBounds.setLower(column, Range.downTo(lower, lowerType));\n-      }\n-      validateEqualityBound(windowBounds, node, column);\n-      if (!result) {\n-        throw invalidWhereClauseException(\n-            \"Duplicate \" + column.getColumnName() + \" bounds on: \" + type, true);\n-      }\n-      return null;\n-    }\n-\n-    private void validateEqualityBound(\n-        final WindowBounds bound,\n-        final ComparisonExpression expression,\n-        final UnqualifiedColumnReferenceExp column\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (bound.getStart().getEqual() != null\n-            && (bound.getStart().getUpper() != null || bound.getStart().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-        }\n-      } else {\n-        if (bound.getEnd().getEqual() != null\n-            && (bound.getEnd().getUpper() != null || bound.getEnd().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-\n-        }\n-      }\n-    }\n-\n-    private Type getSimplifiedBoundType(final ComparisonExpression comparison) {\n-      final Type type = comparison.getType();\n-      final boolean inverted = comparison.getRight() instanceof UnqualifiedColumnReferenceExp;\n-\n-      switch (type) {\n-        case LESS_THAN:\n-        case LESS_THAN_OR_EQUAL:\n-          return inverted ? Type.GREATER_THAN : Type.LESS_THAN;\n-        case GREATER_THAN:\n-        case GREATER_THAN_OR_EQUAL:\n-          return inverted ? Type.LESS_THAN : Type.GREATER_THAN;\n-        default:\n-          return type;\n-      }\n-    }\n-\n-    private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-      return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-          ? comparison.getLeft()\n-          : comparison.getRight();\n-    }\n-\n-    private Instant asInstant(final Expression other) {\n-      if (other instanceof IntegerLiteral) {\n-        return Instant.ofEpochMilli(((IntegerLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof LongLiteral) {\n-        return Instant.ofEpochMilli(((LongLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof StringLiteral) {\n-        final String text = ((StringLiteral) other).getValue();\n-        try {\n-          final long timestamp = new PartialStringToTimestampParser()\n-              .parse(text);\n-\n-          return Instant.ofEpochMilli(timestamp);\n-        } catch (final Exception e) {\n-          throw invalidWhereClauseException(\"Failed to parse datetime: \" + text, true);\n-        }\n-      }\n-\n-      throw invalidWhereClauseException(\n-          \"Window bounds must be an INT, BIGINT or STRING containing a datetime.\",\n-          true\n-      );\n-    }\n-\n-    private BoundType getRangeBoundType(final ComparisonExpression lowerComparison) {\n-      final boolean openBound = lowerComparison.getType() == Type.LESS_THAN\n-          || lowerComparison.getType() == Type.GREATER_THAN;\n-\n-      return openBound\n-          ? BoundType.OPEN\n-          : BoundType.CLOSED;\n-    }\n-  }\n-\n-  private KsqlException invalidWhereClauseException(\n-      final String msg,\n-      final boolean windowed\n-  ) {\n-    final String additional = !windowed\n-        ? \"\"\n-        : System.lineSeparator()\n-            + \" - (optionally) limits the time bounds of the windowed table.\"\n-            + System.lineSeparator()\n-            + \"\\t Bounds on \" + SystemColumns.windowBoundsColumnNames() + \" are supported\"\n-            + System.lineSeparator()\n-            + \"\\t Supported operators are \" + VALID_WINDOW_BOUND_COMPARISONS;\n-\n-    return new KsqlException(\n-        msg\n-            + \". \"\n-            + PullQueryValidator.PULL_QUERY_SYNTAX_HELP\n-            + System.lineSeparator()\n-            + \"Pull queries require a WHERE clause that:\"\n-            + System.lineSeparator()\n-            + \" - limits the query to keys only, e.g. `SELECT * FROM X WHERE <key-column>=Y;`.\"\n-            + System.lineSeparator()\n-            + \" - specifies an equality condition that is a conjunction of equality expressions \"\n-            + \"that cover all keys.\"\n-            + additional\n-    );\n-  }\n-\n-  public static final class WindowBounds {\n-\n-    private WindowRange start;\n-    private WindowRange end;\n-\n-    public WindowBounds(final WindowRange start, final WindowRange end) {\n-      this.start = Objects.requireNonNull(start, \"startBounds\");\n-      this.end = Objects.requireNonNull(end, \"endBounds\");\n-    }\n-\n-    public WindowBounds() {\n-      this.start = new WindowRange();\n-      this.end = new WindowRange();\n-    }\n-\n-    boolean setEquality(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.equal != null) {\n-          return false;\n-        }\n-        start.equal = range;\n-      } else {\n-        if (end.equal != null) {\n-          return false;\n-        }\n-        end.equal = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setUpper(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.upper != null) {\n-          return false;\n-        }\n-        start.upper = range;\n-      } else {\n-        if (end.upper != null) {\n-          return false;\n-        }\n-        end.upper = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setLower(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.lower != null) {\n-          return false;\n-        }\n-        start.lower = range;\n-      } else {\n-        if (end.lower != null) {\n-          return false;\n-        }\n-        end.lower = range;\n-      }\n-      return true;\n-    }\n-\n-    public WindowRange getStart() {\n-      return start;\n-    }\n-\n-    public WindowRange getEnd() {\n-      return end;\n-    }\n-\n-    public Range<Instant> getMergedStart() {\n-      return start.getMergedRange();\n-    }\n-\n-    public Range<Instant> getMergedEnd() {\n-      return end.getMergedRange();\n-    }\n-\n-\n-    @Override\n-    public boolean equals(final Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      final WindowBounds that = (WindowBounds) o;\n-      return Objects.equals(start, that.start)\n-          && Objects.equals(end, that.end);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hash(start, end);\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"WindowBounds{\"\n-          + \"start=\" + start\n-          + \", end=\" + end\n-          + '}';\n-    }\n-\n-    static final class WindowRange {\n-      private Range<Instant> equal;\n-      private Range<Instant> upper;\n-      private Range<Instant> lower;\n-\n-      WindowRange(\n-          final Range<Instant> equal,\n-          final Range<Instant> upper,\n-          final Range<Instant> lower\n-      ) {\n-        this.equal = equal;\n-        this.upper = upper;\n-        this.lower = lower;\n-      }\n-\n-      WindowRange() {\n-      }\n-\n-      public Range<Instant> getEqual() {\n-        return equal;\n-      }\n-\n-      public Range<Instant> getUpper() {\n-        return upper;\n-      }\n-\n-      public Range<Instant> getLower() {\n-        return lower;\n-      }\n-\n-      Range<Instant> getMergedRange() {\n-        if (lower == null && upper == null && equal == null) {\n-          return Range.all();\n-        }\n-        if (lower != null && upper != null) {\n-          return Range.range(\n-              lower.lowerEndpoint(), lower.lowerBoundType(),\n-              upper.upperEndpoint(), upper.upperBoundType()\n-          );\n-        }\n-        if (upper != null) {\n-          return upper;\n-        }\n-        if (lower != null) {\n-          return lower;\n-        }\n-        return equal;\n-      }\n-\n-      @Override\n-      public boolean equals(final Object o) {\n-        if (this == o) {\n-          return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-          return false;\n-        }\n-\n-        final WindowRange that = (WindowRange) o;\n-        return Objects.equals(equal, that.equal)\n-            && Objects.equals(upper, that.upper)\n-            && Objects.equals(lower, that.lower);\n-      }\n-\n-      @Override\n-      public int hashCode() {\n-        return Objects.hash(equal, upper, lower);\n-      }\n-\n-      @Override\n-      public String toString() {\n-        return \"WindowRange{\"\n-            + \"equal=\" + equal\n-            + \", upper=\" + upper\n-            + \", lower=\" + lower\n-            + '}';\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = !systemColumns.isEmpty();\n-\n-    final boolean hasKeyColumns = !keyColumns.isEmpty();\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4MTE4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551481181", "bodyText": "Currently, you have to check for this case in both visitComparisonExpression and  visitInPredicate since you don't know whether you're going to hit a comparison or in predicate first.\nIf you set containsINkeys and seenKeys in ExtractKeyValues, then you can do the check just once in one spot.", "author": "AlanConfluent", "createdAt": "2021-01-04T18:12:04Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());\n+    final Validator validator = new Validator();\n+    validator.process(rewrittenPredicate, null);\n+    if (!isKeyedQuery) {\n+      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n+    }\n+\n+    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n+      final List<ColumnName> seenKeyNames = seenKeys\n+          .stream()\n+          .boxed()\n+          .map(i -> schema.key().get(i))\n+          .map(Column::name)\n+          .collect(Collectors.toList());\n+      throw invalidWhereClauseException(\n+          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n+              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n+    }\n+  }\n+\n+  private void extractKeysAndSystemCols() {\n+    keyColumns = new HashSet<>();\n+    systemColumns = new HashSet<>();\n+    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n+  }\n+\n+  private List<GenericKey> extractKeyValues() {\n+    inKeys = new ArrayList<>();\n+    keyContents = new Object[schema.key().size()];\n+    seenKeys = new BitSet(schema.key().size());\n+\n+    new KeyValueExtractor().process(rewrittenPredicate, null);\n+    if (!inKeys.isEmpty()) {\n+      return (inKeys);\n+    }\n+\n+    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n+  }\n+\n+  private WindowBounds extractWindowBounds() {\n+    final WindowBounds windowBounds = new WindowBounds();\n+\n+    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n+    return windowBounds;\n+  }\n+\n+  /**\n+   * Validate the WHERE clause for pull queries.\n+   * 1. There must be exactly one equality condition per key\n+   * or one IN predicate that involves a key.\n+   * 2. An IN predicate can refer to a single key.\n+   * 3. The IN predicate cannot be combined with other conditions.\n+   * 4. Only AND is allowed.\n+   * 5. If there is a multi-key, conditions on all keys must be specified.\n+   * 6. The IN predicate cannot use multi-keys.\n+   */\n+  private final class Validator extends TraversalExpressionVisitor<Object> {\n+\n+    @Override\n+    public Void process(final Expression node, final Object context) {\n+      if (!(node instanceof  LogicalBinaryExpression)\n+          && !(node instanceof  ComparisonExpression)\n+          && !(node instanceof  InPredicate)) {\n+        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n+      }\n+      super.process(node, context);\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitLogicalBinaryExpression(\n+        final LogicalBinaryExpression node,\n+        final Object context\n+    ) {\n+      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n+        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n+      }\n+      process(node.getLeft(), context);\n+      process(node.getRight(), context);\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitComparisonExpression(\n+        final ComparisonExpression node,\n+        final Object context\n+    ) {\n+      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n+\n+      final ColumnName columnName = column.getColumnName();\n+      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n+          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n+        final Type type = node.getType();\n+        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n+          throw invalidWhereClauseException(\n+              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n+        }\n+        if (!isWindowed) {\n+          throw invalidWhereClauseException(\n+              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n+              false);\n+        }\n+        return null;\n+      } else {\n+        final Column col = schema.findColumn(columnName)\n+            .orElseThrow(() -> invalidWhereClauseException(\n+                \"Bound on non-key column \" + columnName, isWindowed));\n+\n+        if (col.namespace() == Namespace.KEY) {\n+          if (node.getType() != Type.EQUAL) {\n+            throw invalidWhereClauseException(\n+                \"Bound on key columns '\" + getSource().getSchema().key()\n+                    + \"' must currently be '='\",\n+                isWindowed);\n+          }\n+          if (containsINkeys || seenKeys.get(col.index())) {", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA4ODI5Mg==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553088292", "bodyText": "I am not sure I follow what you mean. The validation happens first before we extract keys so how can I set it in the ExtractKeyValues ? It makes sense to validate first so that we fail fast.", "author": "vpapavas", "createdAt": "2021-01-07T03:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4MTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4MDI2MQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553480261", "bodyText": "I just meant that you don't know which expression you'll hit first. so you have to put the check twice whereas if you factored out the key use metrics, you could check for the error once.\nIf the ordering of things doesn't allow for this, then that's fine.", "author": "AlanConfluent", "createdAt": "2021-01-07T17:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4MTE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\ndeleted file mode 100644\nindex 13d9328c3b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java\n+++ /dev/null\n\n@@ -1,823 +0,0 @@\n-/*\n- * Copyright 2019 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.collect.BoundType;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Range;\n-import io.confluent.ksql.GenericKey;\n-import io.confluent.ksql.analyzer.PullQueryValidator;\n-import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n-import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n-import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n-import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n-import io.confluent.ksql.execution.expression.tree.Expression;\n-import io.confluent.ksql.execution.expression.tree.InPredicate;\n-import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n-import io.confluent.ksql.execution.expression.tree.Literal;\n-import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n-import io.confluent.ksql.execution.expression.tree.LongLiteral;\n-import io.confluent.ksql.execution.expression.tree.NullLiteral;\n-import io.confluent.ksql.execution.expression.tree.StringLiteral;\n-import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n-import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.name.ColumnName;\n-import io.confluent.ksql.schema.ksql.Column;\n-import io.confluent.ksql.schema.ksql.Column.Namespace;\n-import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.utils.FormatOptions;\n-import io.confluent.ksql.structured.SchemaKStream;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class PullFilterNode extends SingleSourcePlanNode {\n-\n-  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n-      Type.EQUAL,\n-      Type.GREATER_THAN,\n-      Type.GREATER_THAN_OR_EQUAL,\n-      Type.LESS_THAN,\n-      Type.LESS_THAN_OR_EQUAL\n-  );\n-\n-  private final boolean isWindowed;\n-  private final ExpressionMetadata compiledWhereClause;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final MetaStore metaStore;\n-  private final KsqlConfig ksqlConfig;\n-  private final LogicalSchema schema = getSource().getSchema();\n-\n-  private Expression rewrittenPredicate;\n-  private boolean isKeyedQuery = false;\n-  private Optional<WindowBounds> windowBounds;\n-  private List<GenericKey> keyValues;\n-  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n-  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n-  private List<GenericKey> inKeys;\n-  private BitSet seenKeys;\n-  private Object[] keyContents;\n-  private boolean containsINkeys;\n-\n-  public PullFilterNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final Expression predicate,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final boolean isWindowed\n-  ) {\n-    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n-\n-    Objects.requireNonNull(predicate, \"predicate\");\n-    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n-    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n-    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n-    this.isWindowed = isWindowed;\n-\n-    // Basic validation of WHERE clause\n-    validateWhereClause();\n-\n-    // Validation and extractions of window bounds\n-    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n-\n-    // Extraction of key and system columns\n-    extractKeysAndSystemCols();\n-\n-    // Extraction of key values\n-    keyValues = extractKeyValues();\n-\n-    // Compiling expression into byte code\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n-        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n-    compiledWhereClause = CodeGenRunner.compileExpression(\n-        rewrittenPredicate,\n-        \"Predicate\",\n-        intermediateSchema,\n-        ksqlConfig,\n-        metaStore\n-    );\n-\n-  }\n-\n-  public Expression getRewrittenPredicate() {\n-    return rewrittenPredicate;\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return getSource().getSchema();\n-  }\n-\n-  @Override\n-  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  public ExpressionMetadata getCompiledWhereClause() {\n-    return compiledWhereClause;\n-  }\n-\n-  public boolean isKeyedQuery() {\n-    return isKeyedQuery;\n-  }\n-\n-  public boolean isWindowed() {\n-    return isWindowed;\n-  }\n-\n-  public List<GenericKey> getKeyValues() {\n-    return keyValues;\n-  }\n-\n-  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n-    return keyColumns;\n-  }\n-\n-  public Optional<WindowBounds> getWindowBounds() {\n-    return windowBounds;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  private void validateWhereClause() {\n-    seenKeys = new BitSet(schema.key().size());\n-    final Validator validator = new Validator();\n-    validator.process(rewrittenPredicate, null);\n-    if (!isKeyedQuery) {\n-      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n-    }\n-\n-    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n-      final List<ColumnName> seenKeyNames = seenKeys\n-          .stream()\n-          .boxed()\n-          .map(i -> schema.key().get(i))\n-          .map(Column::name)\n-          .collect(Collectors.toList());\n-      throw invalidWhereClauseException(\n-          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n-              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n-    }\n-  }\n-\n-  private void extractKeysAndSystemCols() {\n-    keyColumns = new HashSet<>();\n-    systemColumns = new HashSet<>();\n-    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n-  }\n-\n-  private List<GenericKey> extractKeyValues() {\n-    inKeys = new ArrayList<>();\n-    keyContents = new Object[schema.key().size()];\n-    seenKeys = new BitSet(schema.key().size());\n-\n-    new KeyValueExtractor().process(rewrittenPredicate, null);\n-    if (!inKeys.isEmpty()) {\n-      return (inKeys);\n-    }\n-\n-    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n-  }\n-\n-  private WindowBounds extractWindowBounds() {\n-    final WindowBounds windowBounds = new WindowBounds();\n-\n-    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n-    return windowBounds;\n-  }\n-\n-  /**\n-   * Validate the WHERE clause for pull queries.\n-   * 1. There must be exactly one equality condition per key\n-   * or one IN predicate that involves a key.\n-   * 2. An IN predicate can refer to a single key.\n-   * 3. The IN predicate cannot be combined with other conditions.\n-   * 4. Only AND is allowed.\n-   * 5. If there is a multi-key, conditions on all keys must be specified.\n-   * 6. The IN predicate cannot use multi-keys.\n-   */\n-  private final class Validator extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void process(final Expression node, final Object context) {\n-      if (!(node instanceof  LogicalBinaryExpression)\n-          && !(node instanceof  ComparisonExpression)\n-          && !(node instanceof  InPredicate)) {\n-        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n-      }\n-      super.process(node, context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitLogicalBinaryExpression(\n-        final LogicalBinaryExpression node,\n-        final Object context\n-    ) {\n-      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n-        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n-      }\n-      process(node.getLeft(), context);\n-      process(node.getRight(), context);\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final Object context\n-    ) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-\n-      final ColumnName columnName = column.getColumnName();\n-      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n-          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n-        final Type type = node.getType();\n-        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n-          throw invalidWhereClauseException(\n-              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n-        }\n-        if (!isWindowed) {\n-          throw invalidWhereClauseException(\n-              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n-              false);\n-        }\n-        return null;\n-      } else {\n-        final Column col = schema.findColumn(columnName)\n-            .orElseThrow(() -> invalidWhereClauseException(\n-                \"Bound on non-key column \" + columnName, isWindowed));\n-\n-        if (col.namespace() == Namespace.KEY) {\n-          if (node.getType() != Type.EQUAL) {\n-            throw invalidWhereClauseException(\n-                \"Bound on key columns '\" + getSource().getSchema().key()\n-                    + \"' must currently be '='\",\n-                isWindowed);\n-          }\n-          if (containsINkeys || seenKeys.get(col.index())) {\n-            throw invalidWhereClauseException(\n-                \"An equality condition on the key column cannot be combined with other comparisons\"\n-                    + \" such as an IN predicate\",\n-                isWindowed);\n-          }\n-          seenKeys.set(col.index());\n-          isKeyedQuery = true;\n-          return null;\n-        }\n-\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on non-key column: \" + columnName.text(),\n-            false\n-        );\n-      }\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node,\n-        final Object context\n-    ) {\n-      if (schema.key().size() > 1) {\n-        throw invalidWhereClauseException(\n-            \"Schemas with multiple KEY columns are not supported for IN predicates\", false);\n-      }\n-\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        if (!seenKeys.isEmpty()) {\n-          throw invalidWhereClauseException(\n-              \"The IN predicate cannot be combined with other comparisons on the key column\",\n-              isWindowed);\n-        }\n-        containsINkeys = true;\n-        isKeyedQuery = true;\n-      } else {\n-        throw invalidWhereClauseException(\n-            \"WHERE clause on unsupported column: \" + column.getColumnName().text(),\n-            false\n-        );\n-      }\n-      return null;\n-    }\n-  }\n-\n-  private UnqualifiedColumnReferenceExp getColumnRefSide(final ComparisonExpression comp) {\n-    return (UnqualifiedColumnReferenceExp)\n-        (comp.getRight() instanceof UnqualifiedColumnReferenceExp\n-            ? comp.getRight() : comp.getLeft());\n-  }\n-\n-  private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-    return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-        ? comparison.getLeft()\n-        : comparison.getRight();\n-  }\n-\n-  /**\n-   * Extracts the key and system columns that appear in the WHERE clause.\n-   */\n-  private final class KeyAndSystemColsExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitUnqualifiedColumnReference(\n-        final UnqualifiedColumnReferenceExp node, final Object context) {\n-      final Optional<Column> col = schema.findColumn(node.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        keyColumns.add(node);\n-      } else if (SystemColumns.isSystemColumn(node.getColumnName())) {\n-        systemColumns.add(node);\n-      }\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * Extracts the values for the keys that appear in the WHERE clause.\n-   * Necessary so that we can do key lookups when scanning the data stores.\n-   */\n-  private final class KeyValueExtractor extends TraversalExpressionVisitor<Object> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n-      final Expression other = getNonColumnRefSide(node);\n-      final ColumnName columnName = column.getColumnName();\n-\n-      final Optional<Column> col = schema.findColumn(columnName);\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        final Object key = resolveKey(other, col.get(), metaStore, ksqlConfig, node);\n-        keyContents[col.get().index()] = key;\n-        seenKeys.set(col.get().index());\n-      }\n-      return null;\n-    }\n-\n-    @Override\n-    public Void visitInPredicate(\n-        final InPredicate node, final Object context) {\n-      final UnqualifiedColumnReferenceExp column\n-          = (UnqualifiedColumnReferenceExp) node.getValue();\n-      final Optional<Column> col = schema.findColumn(column.getColumnName());\n-      if (col.isPresent() && col.get().namespace() == Namespace.KEY) {\n-        inKeys.addAll(node.getValueList()\n-            .getValues()\n-            .stream()\n-            .map(expression -> resolveKey(expression, col.get(), metaStore, ksqlConfig, node))\n-            .map(GenericKey::genericKey)\n-            .collect(Collectors.toList()));\n-      }\n-      return null;\n-    }\n-\n-    private Object resolveKey(\n-        final Expression exp,\n-        final Column keyColumn,\n-        final MetaStore metaStore,\n-        final KsqlConfig config,\n-        final Expression errorMessageHint\n-    ) {\n-      final Object obj;\n-      if (exp instanceof NullLiteral) {\n-        obj = null;\n-      } else if (exp instanceof Literal) {\n-        // skip the GenericExpressionResolver because this is\n-        // a critical code path executed once-per-query\n-        obj = ((Literal) exp).getValue();\n-      } else {\n-        obj = new GenericExpressionResolver(\n-            keyColumn.type(),\n-            keyColumn.name(),\n-            metaStore,\n-            config,\n-            \"pull query\"\n-        ).resolve(exp);\n-      }\n-\n-      if (obj == null) {\n-        throw new KsqlException(\"Primary key columns can not be NULL: \" + errorMessageHint);\n-      }\n-\n-      return DefaultSqlValueCoercer.STRICT.coerce(obj, keyColumn.type())\n-          .orElseThrow(() -> new KsqlException(\n-              \"'\" + obj + \"' can not be converted \"\n-                  + \"to the type of the key column: \"\n-                  + keyColumn.toString(\n-                  FormatOptions.noEscape())))\n-          .orElse(null);\n-    }\n-  }\n-\n-\n-  /**\n-   * Extracts the upper and lower bounds on windowstart/windowend columns.\n-   * Performs the following validations on the window bounds:\n-   * 1. An equality bound cannot be combined with other bounds.\n-   * 2. No duplicate bounds are allowed, such as multiple greater than bounds.\n-   */\n-  private final class WindowBoundsExtractor extends TraversalExpressionVisitor<WindowBounds> {\n-\n-    @Override\n-    public Void visitComparisonExpression(\n-        final ComparisonExpression node,\n-        final WindowBounds windowBounds\n-    ) {\n-      final UnqualifiedColumnReferenceExp column;\n-      if (node.getRight() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getRight();\n-      } else if (node.getLeft() instanceof UnqualifiedColumnReferenceExp) {\n-        column = (UnqualifiedColumnReferenceExp) node.getLeft();\n-      } else {\n-        return null;\n-      }\n-\n-      if (!column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)\n-          && !column.getColumnName().equals(SystemColumns.WINDOWEND_NAME)) {\n-        return null;\n-      }\n-      boolean result = false;\n-      if (node.getType().equals(Type.EQUAL)) {\n-        final Range<Instant> instant = Range.singleton(asInstant(getNonColumnRefSide(node)));\n-        result = windowBounds.setEquality(column, instant);\n-      }\n-      final Type type = getSimplifiedBoundType(node);\n-\n-      if (type.equals(Type.LESS_THAN)) {\n-        final Instant upper = asInstant(getNonColumnRefSide(node));\n-        final BoundType upperType = getRangeBoundType(node);\n-        result = windowBounds.setUpper(column, Range.upTo(upper, upperType));\n-      } else if (type.equals(Type.GREATER_THAN)) {\n-        final Instant lower = asInstant(getNonColumnRefSide(node));\n-        final BoundType lowerType = getRangeBoundType(node);\n-        result = windowBounds.setLower(column, Range.downTo(lower, lowerType));\n-      }\n-      validateEqualityBound(windowBounds, node, column);\n-      if (!result) {\n-        throw invalidWhereClauseException(\n-            \"Duplicate \" + column.getColumnName() + \" bounds on: \" + type, true);\n-      }\n-      return null;\n-    }\n-\n-    private void validateEqualityBound(\n-        final WindowBounds bound,\n-        final ComparisonExpression expression,\n-        final UnqualifiedColumnReferenceExp column\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (bound.getStart().getEqual() != null\n-            && (bound.getStart().getUpper() != null || bound.getStart().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-        }\n-      } else {\n-        if (bound.getEnd().getEqual() != null\n-            && (bound.getEnd().getUpper() != null || bound.getEnd().getLower() != null)) {\n-          throw invalidWhereClauseException(\n-              \"`\" + expression + \"` cannot be combined with other \" + column.getColumnName()\n-                  + \" bounds\",\n-              true\n-          );\n-\n-        }\n-      }\n-    }\n-\n-    private Type getSimplifiedBoundType(final ComparisonExpression comparison) {\n-      final Type type = comparison.getType();\n-      final boolean inverted = comparison.getRight() instanceof UnqualifiedColumnReferenceExp;\n-\n-      switch (type) {\n-        case LESS_THAN:\n-        case LESS_THAN_OR_EQUAL:\n-          return inverted ? Type.GREATER_THAN : Type.LESS_THAN;\n-        case GREATER_THAN:\n-        case GREATER_THAN_OR_EQUAL:\n-          return inverted ? Type.LESS_THAN : Type.GREATER_THAN;\n-        default:\n-          return type;\n-      }\n-    }\n-\n-    private Expression getNonColumnRefSide(final ComparisonExpression comparison) {\n-      return comparison.getRight() instanceof UnqualifiedColumnReferenceExp\n-          ? comparison.getLeft()\n-          : comparison.getRight();\n-    }\n-\n-    private Instant asInstant(final Expression other) {\n-      if (other instanceof IntegerLiteral) {\n-        return Instant.ofEpochMilli(((IntegerLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof LongLiteral) {\n-        return Instant.ofEpochMilli(((LongLiteral) other).getValue());\n-      }\n-\n-      if (other instanceof StringLiteral) {\n-        final String text = ((StringLiteral) other).getValue();\n-        try {\n-          final long timestamp = new PartialStringToTimestampParser()\n-              .parse(text);\n-\n-          return Instant.ofEpochMilli(timestamp);\n-        } catch (final Exception e) {\n-          throw invalidWhereClauseException(\"Failed to parse datetime: \" + text, true);\n-        }\n-      }\n-\n-      throw invalidWhereClauseException(\n-          \"Window bounds must be an INT, BIGINT or STRING containing a datetime.\",\n-          true\n-      );\n-    }\n-\n-    private BoundType getRangeBoundType(final ComparisonExpression lowerComparison) {\n-      final boolean openBound = lowerComparison.getType() == Type.LESS_THAN\n-          || lowerComparison.getType() == Type.GREATER_THAN;\n-\n-      return openBound\n-          ? BoundType.OPEN\n-          : BoundType.CLOSED;\n-    }\n-  }\n-\n-  private KsqlException invalidWhereClauseException(\n-      final String msg,\n-      final boolean windowed\n-  ) {\n-    final String additional = !windowed\n-        ? \"\"\n-        : System.lineSeparator()\n-            + \" - (optionally) limits the time bounds of the windowed table.\"\n-            + System.lineSeparator()\n-            + \"\\t Bounds on \" + SystemColumns.windowBoundsColumnNames() + \" are supported\"\n-            + System.lineSeparator()\n-            + \"\\t Supported operators are \" + VALID_WINDOW_BOUND_COMPARISONS;\n-\n-    return new KsqlException(\n-        msg\n-            + \". \"\n-            + PullQueryValidator.PULL_QUERY_SYNTAX_HELP\n-            + System.lineSeparator()\n-            + \"Pull queries require a WHERE clause that:\"\n-            + System.lineSeparator()\n-            + \" - limits the query to keys only, e.g. `SELECT * FROM X WHERE <key-column>=Y;`.\"\n-            + System.lineSeparator()\n-            + \" - specifies an equality condition that is a conjunction of equality expressions \"\n-            + \"that cover all keys.\"\n-            + additional\n-    );\n-  }\n-\n-  public static final class WindowBounds {\n-\n-    private WindowRange start;\n-    private WindowRange end;\n-\n-    public WindowBounds(final WindowRange start, final WindowRange end) {\n-      this.start = Objects.requireNonNull(start, \"startBounds\");\n-      this.end = Objects.requireNonNull(end, \"endBounds\");\n-    }\n-\n-    public WindowBounds() {\n-      this.start = new WindowRange();\n-      this.end = new WindowRange();\n-    }\n-\n-    boolean setEquality(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.equal != null) {\n-          return false;\n-        }\n-        start.equal = range;\n-      } else {\n-        if (end.equal != null) {\n-          return false;\n-        }\n-        end.equal = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setUpper(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.upper != null) {\n-          return false;\n-        }\n-        start.upper = range;\n-      } else {\n-        if (end.upper != null) {\n-          return false;\n-        }\n-        end.upper = range;\n-      }\n-      return true;\n-    }\n-\n-    boolean setLower(\n-        final UnqualifiedColumnReferenceExp column,\n-        final Range<Instant> range\n-    ) {\n-      if (column.getColumnName().equals(SystemColumns.WINDOWSTART_NAME)) {\n-        if (start.lower != null) {\n-          return false;\n-        }\n-        start.lower = range;\n-      } else {\n-        if (end.lower != null) {\n-          return false;\n-        }\n-        end.lower = range;\n-      }\n-      return true;\n-    }\n-\n-    public WindowRange getStart() {\n-      return start;\n-    }\n-\n-    public WindowRange getEnd() {\n-      return end;\n-    }\n-\n-    public Range<Instant> getMergedStart() {\n-      return start.getMergedRange();\n-    }\n-\n-    public Range<Instant> getMergedEnd() {\n-      return end.getMergedRange();\n-    }\n-\n-\n-    @Override\n-    public boolean equals(final Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      final WindowBounds that = (WindowBounds) o;\n-      return Objects.equals(start, that.start)\n-          && Objects.equals(end, that.end);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hash(start, end);\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"WindowBounds{\"\n-          + \"start=\" + start\n-          + \", end=\" + end\n-          + '}';\n-    }\n-\n-    static final class WindowRange {\n-      private Range<Instant> equal;\n-      private Range<Instant> upper;\n-      private Range<Instant> lower;\n-\n-      WindowRange(\n-          final Range<Instant> equal,\n-          final Range<Instant> upper,\n-          final Range<Instant> lower\n-      ) {\n-        this.equal = equal;\n-        this.upper = upper;\n-        this.lower = lower;\n-      }\n-\n-      WindowRange() {\n-      }\n-\n-      public Range<Instant> getEqual() {\n-        return equal;\n-      }\n-\n-      public Range<Instant> getUpper() {\n-        return upper;\n-      }\n-\n-      public Range<Instant> getLower() {\n-        return lower;\n-      }\n-\n-      Range<Instant> getMergedRange() {\n-        if (lower == null && upper == null && equal == null) {\n-          return Range.all();\n-        }\n-        if (lower != null && upper != null) {\n-          return Range.range(\n-              lower.lowerEndpoint(), lower.lowerBoundType(),\n-              upper.upperEndpoint(), upper.upperBoundType()\n-          );\n-        }\n-        if (upper != null) {\n-          return upper;\n-        }\n-        if (lower != null) {\n-          return lower;\n-        }\n-        return equal;\n-      }\n-\n-      @Override\n-      public boolean equals(final Object o) {\n-        if (this == o) {\n-          return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-          return false;\n-        }\n-\n-        final WindowRange that = (WindowRange) o;\n-        return Objects.equals(equal, that.equal)\n-            && Objects.equals(upper, that.upper)\n-            && Objects.equals(lower, that.lower);\n-      }\n-\n-      @Override\n-      public int hashCode() {\n-        return Objects.hash(equal, upper, lower);\n-      }\n-\n-      @Override\n-      public String toString() {\n-        return \"WindowRange{\"\n-            + \"equal=\" + equal\n-            + \", upper=\" + upper\n-            + \", lower=\" + lower\n-            + '}';\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = !systemColumns.isEmpty();\n-\n-    final boolean hasKeyColumns = !keyColumns.isEmpty();\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-}\n"}}, {"oid": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "url": "https://github.com/confluentinc/ksql/commit/cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "message": "initial logical node", "committedDate": "2021-01-08T02:49:52Z", "type": "commit"}, {"oid": "99d84ce46c520aed905cc1417a2eec21f047cb23", "url": "https://github.com/confluentinc/ksql/commit/99d84ce46c520aed905cc1417a2eec21f047cb23", "message": "work in progress", "committedDate": "2021-01-08T02:49:52Z", "type": "commit"}, {"oid": "54034b4e70d677c9249b2ad441ec18e6a9964a25", "url": "https://github.com/confluentinc/ksql/commit/54034b4e70d677c9249b2ad441ec18e6a9964a25", "message": "filter node", "committedDate": "2021-01-08T02:49:52Z", "type": "commit"}, {"oid": "4c9adf3fcc40d9240014b6c028dce75c1d261d33", "url": "https://github.com/confluentinc/ksql/commit/4c9adf3fcc40d9240014b6c028dce75c1d261d33", "message": "temp", "committedDate": "2021-01-08T02:49:52Z", "type": "commit"}, {"oid": "8d7e0d92bf6c622ba6741af1ee14f6c8e66c0072", "url": "https://github.com/confluentinc/ksql/commit/8d7e0d92bf6c622ba6741af1ee14f6c8e66c0072", "message": "working on tests", "committedDate": "2021-01-08T02:49:52Z", "type": "commit"}, {"oid": "22d0c5c13e43a2e962563881f5daec46da772023", "url": "https://github.com/confluentinc/ksql/commit/22d0c5c13e43a2e962563881f5daec46da772023", "message": "added tests and fixed tests", "committedDate": "2021-01-08T02:51:30Z", "type": "commit"}, {"oid": "eb70640c85769279f71ececd550861edb312b3d6", "url": "https://github.com/confluentinc/ksql/commit/eb70640c85769279f71ececd550861edb312b3d6", "message": "rebase master", "committedDate": "2021-01-08T02:51:33Z", "type": "commit"}, {"oid": "b91e48607afb9130b68d4f052515c99c79ed0d87", "url": "https://github.com/confluentinc/ksql/commit/b91e48607afb9130b68d4f052515c99c79ed0d87", "message": "address alan's comments", "committedDate": "2021-01-08T02:51:33Z", "type": "commit"}, {"oid": "f6f623d8b1e9e5442500b1021ae194d8e7460912", "url": "https://github.com/confluentinc/ksql/commit/f6f623d8b1e9e5442500b1021ae194d8e7460912", "message": "compilation error", "committedDate": "2021-01-08T02:51:33Z", "type": "commit"}, {"oid": "acb2a3bbb10309e45ca721021836234f4976b7a9", "url": "https://github.com/confluentinc/ksql/commit/acb2a3bbb10309e45ca721021836234f4976b7a9", "message": "rebase", "committedDate": "2021-01-11T06:33:26Z", "type": "commit"}, {"oid": "acb2a3bbb10309e45ca721021836234f4976b7a9", "url": "https://github.com/confluentinc/ksql/commit/acb2a3bbb10309e45ca721021836234f4976b7a9", "message": "rebase", "committedDate": "2021-01-11T06:33:26Z", "type": "forcePushed"}, {"oid": "8382610de75d792828e1f06d46cccf4d1ac5d32c", "url": "https://github.com/confluentinc/ksql/commit/8382610de75d792828e1f06d46cccf4d1ac5d32c", "message": "fixed rqtt", "committedDate": "2021-01-12T04:12:07Z", "type": "commit"}]}