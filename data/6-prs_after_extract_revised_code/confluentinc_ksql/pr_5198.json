{"pr_number": 5198, "pr_title": "fix: use schema in annotation as schema provider if present", "pr_createdAt": "2020-04-27T22:13:57Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5198", "timeline": [{"oid": "ddf502a26a0bda52406409195a5f0df03011ec60", "url": "https://github.com/confluentinc/ksql/commit/ddf502a26a0bda52406409195a5f0df03011ec60", "message": "fix: use schema in annotation as schema provider if present", "committedDate": "2020-04-27T22:27:32Z", "type": "forcePushed"}, {"oid": "8b155ebb8c4c23a4d4cf285bc9dda9a5b9321660", "url": "https://github.com/confluentinc/ksql/commit/8b155ebb8c4c23a4d4cf285bc9dda9a5b9321660", "message": "fix: use schema in annotation as schema provider if present", "committedDate": "2020-04-27T23:16:46Z", "type": "commit"}, {"oid": "8b155ebb8c4c23a4d4cf285bc9dda9a5b9321660", "url": "https://github.com/confluentinc/ksql/commit/8b155ebb8c4c23a4d4cf285bc9dda9a5b9321660", "message": "fix: use schema in annotation as schema provider if present", "committedDate": "2020-04-27T23:16:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MDg3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5198#discussion_r416480876", "bodyText": "Is it worth parsing once, and failing early, rather than on each call?  Or is this not really an issue?", "author": "big-andy-coates", "createdAt": "2020-04-28T09:49:32Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java", "diffHunk": "@@ -180,17 +180,27 @@ static ParamType getReturnType(\n   static SchemaProvider handleUdfReturnSchema(\n       final Class theClass,\n       final ParamType javaReturnSchema,\n+      final String annotationSchema,\n+      final SqlTypeParser parser,\n       final String schemaProviderFunctionName,\n       final String functionName,\n       final boolean isVariadic\n   ) {\n     final Function<List<SqlType>, SqlType> schemaProvider;\n-    if (!schemaProviderFunctionName.equals(\"\")) {\n+    if (!Udf.NO_SCHEMA_PROVIDER.equals(schemaProviderFunctionName)) {\n       schemaProvider = handleUdfSchemaProviderAnnotation(\n           schemaProviderFunctionName, theClass, functionName);\n-    } else if (javaReturnSchema instanceof DecimalType) {\n-      throw new KsqlException(String.format(\"Cannot load UDF %s. BigDecimal return type \"\n-          + \"is not supported without a schema provider method.\", functionName));\n+    } else if (!Udf.NO_SCHEMA.equals(annotationSchema)) {\n+      schemaProvider = args -> parser.parse(annotationSchema).getSqlType();", "originalCommit": "8b155ebb8c4c23a4d4cf285bc9dda9a5b9321660", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "636e7d0aa4a9e430b50d5375691502fffeafefde", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java\nindex f143f0482e..bf6d5d56be 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java\n\n@@ -191,15 +191,13 @@ public final class FunctionLoaderUtils {\n       schemaProvider = handleUdfSchemaProviderAnnotation(\n           schemaProviderFunctionName, theClass, functionName);\n     } else if (!Udf.NO_SCHEMA.equals(annotationSchema)) {\n-      schemaProvider = args -> parser.parse(annotationSchema).getSqlType();\n+      final SqlType sqlType = parser.parse(annotationSchema).getSqlType();\n+      schemaProvider = args -> sqlType;\n     } else if (!GenericsUtil.hasGenerics(javaReturnSchema)) {\n-      final SqlType sqlType;\n-      try {\n-        sqlType = SchemaConverters.functionToSqlConverter().toSqlType(javaReturnSchema);\n-      } catch (final Exception e) {\n-        throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n-            + javaReturnSchema + \" return type is not supported without a schema annotation.\");\n-      }\n+      // it is important to do this eagerly and not in the lambda so that\n+      // we can fail early (when loading the UDF) instead of when the user\n+      // attempts to use the UDF\n+      final SqlType sqlType = fromJavaType(javaReturnSchema, functionName);\n       schemaProvider = args -> sqlType;\n     } else {\n       schemaProvider = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MTI0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5198#discussion_r416481249", "bodyText": "This method is getting large - consider moving this code into its own function?", "author": "big-andy-coates", "createdAt": "2020-04-28T09:50:13Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java", "diffHunk": "@@ -180,17 +180,27 @@ static ParamType getReturnType(\n   static SchemaProvider handleUdfReturnSchema(\n       final Class theClass,\n       final ParamType javaReturnSchema,\n+      final String annotationSchema,\n+      final SqlTypeParser parser,\n       final String schemaProviderFunctionName,\n       final String functionName,\n       final boolean isVariadic\n   ) {\n     final Function<List<SqlType>, SqlType> schemaProvider;\n-    if (!schemaProviderFunctionName.equals(\"\")) {\n+    if (!Udf.NO_SCHEMA_PROVIDER.equals(schemaProviderFunctionName)) {\n       schemaProvider = handleUdfSchemaProviderAnnotation(\n           schemaProviderFunctionName, theClass, functionName);\n-    } else if (javaReturnSchema instanceof DecimalType) {\n-      throw new KsqlException(String.format(\"Cannot load UDF %s. BigDecimal return type \"\n-          + \"is not supported without a schema provider method.\", functionName));\n+    } else if (!Udf.NO_SCHEMA.equals(annotationSchema)) {\n+      schemaProvider = args -> parser.parse(annotationSchema).getSqlType();\n+    } else if (!GenericsUtil.hasGenerics(javaReturnSchema)) {\n+      final SqlType sqlType;\n+      try {\n+        sqlType = SchemaConverters.functionToSqlConverter().toSqlType(javaReturnSchema);\n+      } catch (final Exception e) {\n+        throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n+            + javaReturnSchema + \" return type is not supported without a schema annotation.\");\n+      }\n+      schemaProvider = args -> sqlType;", "originalCommit": "8b155ebb8c4c23a4d4cf285bc9dda9a5b9321660", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "636e7d0aa4a9e430b50d5375691502fffeafefde", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java\nindex f143f0482e..bf6d5d56be 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java\n\n@@ -191,15 +191,13 @@ public final class FunctionLoaderUtils {\n       schemaProvider = handleUdfSchemaProviderAnnotation(\n           schemaProviderFunctionName, theClass, functionName);\n     } else if (!Udf.NO_SCHEMA.equals(annotationSchema)) {\n-      schemaProvider = args -> parser.parse(annotationSchema).getSqlType();\n+      final SqlType sqlType = parser.parse(annotationSchema).getSqlType();\n+      schemaProvider = args -> sqlType;\n     } else if (!GenericsUtil.hasGenerics(javaReturnSchema)) {\n-      final SqlType sqlType;\n-      try {\n-        sqlType = SchemaConverters.functionToSqlConverter().toSqlType(javaReturnSchema);\n-      } catch (final Exception e) {\n-        throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n-            + javaReturnSchema + \" return type is not supported without a schema annotation.\");\n-      }\n+      // it is important to do this eagerly and not in the lambda so that\n+      // we can fail early (when loading the UDF) instead of when the user\n+      // attempts to use the UDF\n+      final SqlType sqlType = fromJavaType(javaReturnSchema, functionName);\n       schemaProvider = args -> sqlType;\n     } else {\n       schemaProvider = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MjY4OA==", "url": "https://github.com/confluentinc/ksql/pull/5198#discussion_r416482688", "bodyText": "Either a schema or schemaProvider is required, right?\n... and users may find 'schema annotation;' confusing, given the 'schema' is the name of a property of the annotation, not the name of the annotation.\nMaybe:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n          \n          \n            \n                        + javaReturnSchema + \" return type is not supported without a schema annotation.\");\n          \n          \n            \n                    throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n          \n          \n            \n                        + javaReturnSchema + \" return type is not supported without either a schema or schemaProvider set in the annotation.\");\n          \n      \n    \n    \n  \n\nThough even better would be to pass down the type of the annotation so that the error could be explicit and say set in the @Udf annotation, or in the @Udtf annotation etc.", "author": "big-andy-coates", "createdAt": "2020-04-28T09:52:37Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java", "diffHunk": "@@ -180,17 +180,27 @@ static ParamType getReturnType(\n   static SchemaProvider handleUdfReturnSchema(\n       final Class theClass,\n       final ParamType javaReturnSchema,\n+      final String annotationSchema,\n+      final SqlTypeParser parser,\n       final String schemaProviderFunctionName,\n       final String functionName,\n       final boolean isVariadic\n   ) {\n     final Function<List<SqlType>, SqlType> schemaProvider;\n-    if (!schemaProviderFunctionName.equals(\"\")) {\n+    if (!Udf.NO_SCHEMA_PROVIDER.equals(schemaProviderFunctionName)) {\n       schemaProvider = handleUdfSchemaProviderAnnotation(\n           schemaProviderFunctionName, theClass, functionName);\n-    } else if (javaReturnSchema instanceof DecimalType) {\n-      throw new KsqlException(String.format(\"Cannot load UDF %s. BigDecimal return type \"\n-          + \"is not supported without a schema provider method.\", functionName));\n+    } else if (!Udf.NO_SCHEMA.equals(annotationSchema)) {\n+      schemaProvider = args -> parser.parse(annotationSchema).getSqlType();\n+    } else if (!GenericsUtil.hasGenerics(javaReturnSchema)) {\n+      final SqlType sqlType;\n+      try {\n+        sqlType = SchemaConverters.functionToSqlConverter().toSqlType(javaReturnSchema);\n+      } catch (final Exception e) {\n+        throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n+            + javaReturnSchema + \" return type is not supported without a schema annotation.\");", "originalCommit": "8b155ebb8c4c23a4d4cf285bc9dda9a5b9321660", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0MDExNg==", "url": "https://github.com/confluentinc/ksql/pull/5198#discussion_r416740116", "bodyText": "I changed the error to clarify, but did not pass down the annotation. I think it's clear enough without it :)", "author": "agavra", "createdAt": "2020-04-28T16:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MjY4OA=="}], "type": "inlineReview", "revised_code": {"commit": "636e7d0aa4a9e430b50d5375691502fffeafefde", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java b/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java\nindex f143f0482e..bf6d5d56be 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionLoaderUtils.java\n\n@@ -191,15 +191,13 @@ public final class FunctionLoaderUtils {\n       schemaProvider = handleUdfSchemaProviderAnnotation(\n           schemaProviderFunctionName, theClass, functionName);\n     } else if (!Udf.NO_SCHEMA.equals(annotationSchema)) {\n-      schemaProvider = args -> parser.parse(annotationSchema).getSqlType();\n+      final SqlType sqlType = parser.parse(annotationSchema).getSqlType();\n+      schemaProvider = args -> sqlType;\n     } else if (!GenericsUtil.hasGenerics(javaReturnSchema)) {\n-      final SqlType sqlType;\n-      try {\n-        sqlType = SchemaConverters.functionToSqlConverter().toSqlType(javaReturnSchema);\n-      } catch (final Exception e) {\n-        throw new KsqlException(\"Cannot load UDF \" + functionName + \". \"\n-            + javaReturnSchema + \" return type is not supported without a schema annotation.\");\n-      }\n+      // it is important to do this eagerly and not in the lambda so that\n+      // we can fail early (when loading the UDF) instead of when the user\n+      // attempts to use the UDF\n+      final SqlType sqlType = fromJavaType(javaReturnSchema, functionName);\n       schemaProvider = args -> sqlType;\n     } else {\n       schemaProvider = null;\n"}}, {"oid": "636e7d0aa4a9e430b50d5375691502fffeafefde", "url": "https://github.com/confluentinc/ksql/commit/636e7d0aa4a9e430b50d5375691502fffeafefde", "message": "chore: address andy's comments", "committedDate": "2020-04-28T16:25:29Z", "type": "commit"}]}