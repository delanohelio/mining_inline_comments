{"pr_number": 4512, "pr_title": "feat: Plug insert streams into backend", "pr_createdAt": "2020-02-11T11:23:16Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4512", "timeline": [{"oid": "2a6cbcd0c33dee9c46682f92f10b5be515e52a86", "url": "https://github.com/confluentinc/ksql/commit/2a6cbcd0c33dee9c46682f92f10b5be515e52a86", "message": "inserts stream", "committedDate": "2020-02-11T22:59:07Z", "type": "forcePushed"}, {"oid": "fa9438117be1772ca2ccf892e79d41fe01047ba7", "url": "https://github.com/confluentinc/ksql/commit/fa9438117be1772ca2ccf892e79d41fe01047ba7", "message": "inserts stream", "committedDate": "2020-02-12T11:37:11Z", "type": "forcePushed"}, {"oid": "5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "url": "https://github.com/confluentinc/ksql/commit/5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "message": "checkstyle", "committedDate": "2020-02-14T13:41:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0NjE3Mg==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379446172", "bodyText": "Why pass a field as a param?", "author": "big-andy-coates", "createdAt": "2020-02-14T14:04:47Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/plugin/KsqlServerEndpoints.java", "diffHunk": "@@ -168,10 +176,43 @@ public String getName() {\n   }\n \n   @Override\n-  public InsertsSubscriber createInsertsSubscriber(final String target,\n+  public InsertsStreamSubscriber createInsertsSubscriber(final String target,\n       final JsonObject properties,\n-      final Subscriber<JsonObject> acksSubscriber) {\n-    return null;\n+      final Subscriber<InsertResult> acksSubscriber, final Context context,\n+      final WorkerExecutor workerExecutor) {\n+    Utils.checkIsWorker();\n+    final ServiceContext serviceContext = createServiceContext(new DummyPrincipal());\n+    final DataSource dataSource = getDataSource(ksqlConfig, ksqlEngine.getMetaStore(),\n+        SourceName.of(target));\n+    if (dataSource.getDataSourceType() == DataSourceType.KTABLE) {\n+      throw new KsqlException(\"Cannot insert into a table\");\n+    }\n+    return InsertsSubscriber.createInsertsSubscriber(serviceContext, properties, dataSource,\n+        ksqlConfig, context, acksSubscriber, workerExecutor);\n+  }\n+\n+  private DataSource getDataSource(\n+      final KsqlConfig ksqlConfig,", "originalCommit": "5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyOTM2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379529363", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-14T16:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0NjE3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c63ad53ee9653ada35be93b43b2aeec4898626fb", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/plugin/KsqlServerEndpoints.java b/ksql-api/src/main/java/io/confluent/ksql/api/plugin/KsqlServerEndpoints.java\nindex 4d43e78bf7..9d18ea9ec8 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/plugin/KsqlServerEndpoints.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/plugin/KsqlServerEndpoints.java\n\n@@ -176,10 +175,9 @@ public class KsqlServerEndpoints implements Endpoints {\n   }\n \n   @Override\n-  public InsertsStreamSubscriber createInsertsSubscriber(final String target,\n+  public Subscriber<JsonObject> createInsertsSubscriber(final String target,\n       final JsonObject properties,\n-      final Subscriber<InsertResult> acksSubscriber, final Context context,\n-      final WorkerExecutor workerExecutor) {\n+      final Subscriber<InsertResult> acksSubscriber, final Context context) {\n     Utils.checkIsWorker();\n     final ServiceContext serviceContext = createServiceContext(new DummyPrincipal());\n     final DataSource dataSource = getDataSource(ksqlConfig, ksqlEngine.getMetaStore(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0NjYxOQ==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379446619", "bodyText": "internalTopics can probably be a field.  You could even inject it so that it's easier to unit test this class without coupling to ReservedInternalTopics functionality.", "author": "big-andy-coates", "createdAt": "2020-02-14T14:05:41Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/plugin/KsqlServerEndpoints.java", "diffHunk": "@@ -168,10 +176,43 @@ public String getName() {\n   }\n \n   @Override\n-  public InsertsSubscriber createInsertsSubscriber(final String target,\n+  public InsertsStreamSubscriber createInsertsSubscriber(final String target,\n       final JsonObject properties,\n-      final Subscriber<JsonObject> acksSubscriber) {\n-    return null;\n+      final Subscriber<InsertResult> acksSubscriber, final Context context,\n+      final WorkerExecutor workerExecutor) {\n+    Utils.checkIsWorker();\n+    final ServiceContext serviceContext = createServiceContext(new DummyPrincipal());\n+    final DataSource dataSource = getDataSource(ksqlConfig, ksqlEngine.getMetaStore(),\n+        SourceName.of(target));\n+    if (dataSource.getDataSourceType() == DataSourceType.KTABLE) {\n+      throw new KsqlException(\"Cannot insert into a table\");\n+    }\n+    return InsertsSubscriber.createInsertsSubscriber(serviceContext, properties, dataSource,\n+        ksqlConfig, context, acksSubscriber, workerExecutor);\n+  }\n+\n+  private DataSource getDataSource(\n+      final KsqlConfig ksqlConfig,\n+      final MetaStore metaStore,\n+      final SourceName sourceName\n+  ) {\n+    final DataSource dataSource = metaStore.getSource(sourceName);\n+    if (dataSource == null) {\n+      throw new KsqlException(\"Cannot insert values into an unknown stream: \"\n+          + sourceName);\n+    }\n+\n+    if (dataSource.getKsqlTopic().getKeyFormat().isWindowed()) {\n+      throw new KsqlException(\"Cannot insert values into windowed stream\");\n+    }\n+\n+    final ReservedInternalTopics internalTopics = new ReservedInternalTopics(ksqlConfig);", "originalCommit": "5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzMDIxMg==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379530212", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-14T16:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0NjYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU1MDcwOQ==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379550709", "bodyText": "Interactive users obviously still want to interact using SQL, so we're going to need the SQL INSERT VALUES functionality at some point. Do you see this being handled through a standard SQL processing endpoint?\n\nAIUI, currently INSERT VALUES is executed via the /ksql endpoint (although doesn't seem to be documented in the REST API docs https://docs.confluent.io/current/ksql/docs/developer-guide/api.html so I didn't have a task created for this).\nCurrent plan is to just support it in the new API as is.\n\nOne thing the UI team struggle with is how different statements need to go to different endpoints in the current API, e.g. queries and print topics to a websocket APi. The challenge is that the UI doesn't know what statement is which without some form of parsing - which couples the UI to the SQL syntax. If would be good if the new API could think of a way to solve this issue and be more UI friendly. (I'd previously though of adding an endpoint that would just parse the text a user entered in the UI but not execute it. This could then be returned to the UI to then direct the different bits at the different endpoints - while this would have helped with the old API, these feels rather convoluted for a new API).\n\nI suppose if the user just wants to execute a command and display the result as text on a UI somewhere then we can create an endpoint that allows any command to be executed and returned that way. This means they don't have to figure out what endpoint to call.\nIf they want a structured response (e.g. a list of Json arrays) so they can be easily parsed then they're going to have to have different code for parsing the response depending on what command they execute, so they're going to have to know what the command is at the client anyway, so calling a different endpoint for those is no extra pain.\nWe could create such a generic endpoint that can be accessed over http or websockets.\n\nThere are two things I'd really like to see added to this API soon:\n\nAuthentication and authorisation - we can't turn the thing on until we have it and its better to do it from the ground up rather than to bolt it on after.\n\n\nAck. @vcrfxia  is working on the basic auth integration.\n\n\nA JSON based test framework, i.e. along the lines of QueryTranslationTest.  Something that can just accept the JSON requests and assert the JSON responses.\n\n\nSeems like a good idea.", "author": "purplefox", "createdAt": "2020-02-14T17:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0NjYxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c63ad53ee9653ada35be93b43b2aeec4898626fb", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/plugin/KsqlServerEndpoints.java b/ksql-api/src/main/java/io/confluent/ksql/api/plugin/KsqlServerEndpoints.java\nindex 4d43e78bf7..9d18ea9ec8 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/plugin/KsqlServerEndpoints.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/plugin/KsqlServerEndpoints.java\n\n@@ -176,10 +175,9 @@ public class KsqlServerEndpoints implements Endpoints {\n   }\n \n   @Override\n-  public InsertsStreamSubscriber createInsertsSubscriber(final String target,\n+  public Subscriber<JsonObject> createInsertsSubscriber(final String target,\n       final JsonObject properties,\n-      final Subscriber<InsertResult> acksSubscriber, final Context context,\n-      final WorkerExecutor workerExecutor) {\n+      final Subscriber<InsertResult> acksSubscriber, final Context context) {\n     Utils.checkIsWorker();\n     final ServiceContext serviceContext = createServiceContext(new DummyPrincipal());\n     final DataSource dataSource = getDataSource(ksqlConfig, ksqlEngine.getMetaStore(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0NjcyMA==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379446720", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.\nAlso, take defensive copies of the data, i.e. ImmutableList.copyOf", "author": "big-andy-coates", "createdAt": "2020-02-14T14:05:54Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/plugin/PullQueryPublisher.java", "diffHunk": "@@ -19,24 +19,29 @@\n import io.confluent.ksql.api.server.BufferedPublisher;\n import io.confluent.ksql.api.spi.QueryPublisher;\n import io.vertx.core.Context;\n+import java.util.ArrayList;\n import java.util.List;\n \n public class PullQueryPublisher extends BufferedPublisher<GenericRow> implements QueryPublisher {\n \n   private final List<String> columnNames;\n   private final List<String> columnTypes;\n \n-  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n   public PullQueryPublisher(final Context ctx, final TableRows tableRows,\n       final List<String> columnNames, final List<String> columnTypes) {\n-    super(ctx);\n+    super(ctx, toGenericRows(tableRows));\n+    this.columnNames = columnNames;\n+    this.columnTypes = columnTypes;", "originalCommit": "5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzMDk5OA==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379530998", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-14T16:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0NjcyMA=="}], "type": "inlineReview", "revised_code": {"commit": "901392c44ac9190423e36f331c2a89ae29823982", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/plugin/PullQueryPublisher.java b/ksql-api/src/main/java/io/confluent/ksql/api/plugin/PullQueryPublisher.java\nindex fabf498ece..58b59bd49c 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/plugin/PullQueryPublisher.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/plugin/PullQueryPublisher.java\n\n@@ -21,6 +21,7 @@ import io.confluent.ksql.api.spi.QueryPublisher;\n import io.vertx.core.Context;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Objects;\n \n public class PullQueryPublisher extends BufferedPublisher<GenericRow> implements QueryPublisher {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0OTcxMw==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379449713", "bodyText": "Not a very helpful error message. Not sure what a user can do with such a message. Can we not provide more details? e.g. the exception message?  Or are we intentionally trying to avoid returning potentially embarrassing error messages? e.g. null in a NPE?", "author": "big-andy-coates", "createdAt": "2020-02-14T14:11:45Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -54,22 +55,41 @@ protected void afterSubscribe(final Subscription subscription) {\n   }\n \n   @Override\n-  public void handleValue(final JsonObject value) {\n+  public void handleValue(final InsertResult result) {\n     checkContext();\n-    insertsStreamResponseWriter.writeInsertResponse();\n-    acksSent++;\n-    if (insertsSent != null && insertsSent == acksSent) {\n-      close();\n-    } else if (response.writeQueueFull()) {\n-      if (!drainHandlerSet) {\n-        response.drainHandler(v -> {\n-          drainHandlerSet = false;\n-          checkMakeRequest();\n-        });\n-        drainHandlerSet = true;\n+    if (responseEnded) {\n+      return;\n+    }\n+    if (result.succeeded()) {\n+      insertsStreamResponseWriter.writeInsertResponse(new InsertAck(result.sequenceNumber()));\n+      acksSent++;\n+      if (insertsSent != null && insertsSent == acksSent) {\n+        close();\n+      } else if (response.writeQueueFull()) {\n+        if (!drainHandlerSet) {\n+          response.drainHandler(v -> {\n+            drainHandlerSet = false;\n+            checkMakeRequest();\n+          });\n+          drainHandlerSet = true;\n+        }\n+      } else {\n+        checkMakeRequest();\n       }\n     } else {\n-      checkMakeRequest();\n+      log.error(\"Error in processing inserts\", result.exception());\n+      final InsertError insertError;\n+      final Exception exception = result.exception();\n+      if (exception instanceof KsqlInsertsException) {\n+        insertError = new InsertError(result.sequenceNumber(),\n+            ((KsqlInsertsException) exception).getErrorCode(),\n+            exception.getMessage());\n+      } else {\n+        insertError = new InsertError(result.sequenceNumber(), ERROR_CODE_INTERNAL_ERROR,\n+            \"Error in processing inserts\");", "originalCommit": "5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzMzI4Mw==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379533283", "bodyText": "Right. Any kind of user error (e.g. missing key, wrong types etc) due to bad input should never result in this error. This should only occur if there is some kind of internal error which could be due to a programming error (e.g. NPE) or maybe some environment issue on the server (problems accessing network or filesystem), in which case the real exception will be logged and the user will be sent a simple error to avoid exposing internals on a public API.", "author": "purplefox", "createdAt": "2020-02-14T16:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0OTcxMw=="}], "type": "inlineReview", "revised_code": {"commit": "c63ad53ee9653ada35be93b43b2aeec4898626fb", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\nindex 1d82b9edc9..bfdc2da002 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\n\n@@ -81,8 +82,7 @@ public class AcksSubscriber extends BaseSubscriber<InsertResult> {\n       final InsertError insertError;\n       final Exception exception = result.exception();\n       if (exception instanceof KsqlInsertsException) {\n-        insertError = new InsertError(result.sequenceNumber(),\n-            ((KsqlInsertsException) exception).getErrorCode(),\n+        insertError = new InsertError(result.sequenceNumber(), ERROR_CODE_MISSING_KEY_FIELD,\n             exception.getMessage());\n       } else {\n         insertError = new InsertError(result.sequenceNumber(), ERROR_CODE_INTERNAL_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MjU4NA==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379452584", "bodyText": "I find such heavily nested if/else if/else code very hard to grok.\nHave you considered moving the two main chunks into handleSuccess and handleError type methods?\nTaking the success one as an example, it might look something like:\nprivate void handleSuccess(final InsertResult result) {\n      insertsStreamResponseWriter.writeInsertResponse(new InsertAck(result.sequenceNumber()));\n     acksSent++;\n\n     if (insertsSent != null && insertsSent == acksSent) {\n         close();\n         return;\n      }\n\n      if (response.writeQueueFull()) {\n            if (!drainHandlerSet) {\n                 response.drainHandler(v -> {\n                     drainHandlerSet = false;\n                     checkMakeRequest();\n                 });\n               drainHandlerSet = true;\n            }\n            return;\n      }\n\n     checkMakeRequest();\n}\nI find this much easier to follow, as each if block returns, meaning I don't need to scan down the rest of the method to see what else is going to happen.", "author": "big-andy-coates", "createdAt": "2020-02-14T14:17:20Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -54,22 +55,41 @@ protected void afterSubscribe(final Subscription subscription) {\n   }\n \n   @Override\n-  public void handleValue(final JsonObject value) {\n+  public void handleValue(final InsertResult result) {\n     checkContext();\n-    insertsStreamResponseWriter.writeInsertResponse();\n-    acksSent++;\n-    if (insertsSent != null && insertsSent == acksSent) {\n-      close();\n-    } else if (response.writeQueueFull()) {\n-      if (!drainHandlerSet) {\n-        response.drainHandler(v -> {\n-          drainHandlerSet = false;\n-          checkMakeRequest();\n-        });\n-        drainHandlerSet = true;\n+    if (responseEnded) {\n+      return;\n+    }\n+    if (result.succeeded()) {\n+      insertsStreamResponseWriter.writeInsertResponse(new InsertAck(result.sequenceNumber()));\n+      acksSent++;\n+      if (insertsSent != null && insertsSent == acksSent) {\n+        close();\n+      } else if (response.writeQueueFull()) {\n+        if (!drainHandlerSet) {\n+          response.drainHandler(v -> {\n+            drainHandlerSet = false;\n+            checkMakeRequest();\n+          });\n+          drainHandlerSet = true;\n+        }\n+      } else {\n+        checkMakeRequest();\n       }\n     } else {\n-      checkMakeRequest();\n+      log.error(\"Error in processing inserts\", result.exception());\n+      final InsertError insertError;\n+      final Exception exception = result.exception();\n+      if (exception instanceof KsqlInsertsException) {\n+        insertError = new InsertError(result.sequenceNumber(),\n+            ((KsqlInsertsException) exception).getErrorCode(),\n+            exception.getMessage());\n+      } else {\n+        insertError = new InsertError(result.sequenceNumber(), ERROR_CODE_INTERNAL_ERROR,\n+            \"Error in processing inserts\");\n+      }\n+      insertsStreamResponseWriter.writeError(insertError).end();\n+      responseEnded = true;", "originalCommit": "5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNTk5OQ==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379535999", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-14T16:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MjU4NA=="}], "type": "inlineReview", "revised_code": {"commit": "c63ad53ee9653ada35be93b43b2aeec4898626fb", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\nindex 1d82b9edc9..bfdc2da002 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\n\n@@ -81,8 +82,7 @@ public class AcksSubscriber extends BaseSubscriber<InsertResult> {\n       final InsertError insertError;\n       final Exception exception = result.exception();\n       if (exception instanceof KsqlInsertsException) {\n-        insertError = new InsertError(result.sequenceNumber(),\n-            ((KsqlInsertsException) exception).getErrorCode(),\n+        insertError = new InsertError(result.sequenceNumber(), ERROR_CODE_MISSING_KEY_FIELD,\n             exception.getMessage());\n       } else {\n         insertError = new InsertError(result.sequenceNumber(), ERROR_CODE_INTERNAL_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MzQ3NA==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379453474", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-02-14T14:19:08Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/BaseSubscriber.java", "diffHunk": "@@ -47,26 +51,26 @@\n    *                be executed on this context. This ensures the code is never executed\n    *                concurrently by more than one thread.\n    */\n-  public ReactiveSubscriber(final Context context) {\n+  public BaseSubscriber(final Context context) {", "originalCommit": "5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNjI5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379536296", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-14T16:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MzQ3NA=="}], "type": "inlineReview", "revised_code": {"commit": "901392c44ac9190423e36f331c2a89ae29823982", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/BaseSubscriber.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/BaseSubscriber.java\nindex ae4f67a065..74eb898e87 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/BaseSubscriber.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/BaseSubscriber.java\n\n@@ -52,7 +52,7 @@ public class BaseSubscriber<T> implements Subscriber<T> {\n    *                concurrently by more than one thread.\n    */\n   public BaseSubscriber(final Context context) {\n-    this.context = context;\n+    this.context = Objects.requireNonNull(context);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1NDM2OA==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379454368", "bodyText": "don't return nulls -> if this shouldn't be called, then throw an exception! e.g. UnsupportedOperationException.", "author": "big-andy-coates", "createdAt": "2020-02-14T14:20:46Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertResult.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+public interface InsertResult {\n+\n+  long sequenceNumber();\n+\n+  boolean succeeded();\n+\n+  Exception exception();\n+\n+  static InsertResult succeededInsert(final long sequenceNumber) {\n+    return new InsertResult() {\n+      @Override\n+      public long sequenceNumber() {\n+        return sequenceNumber;\n+      }\n+\n+      @Override\n+      public boolean succeeded() {\n+        return true;\n+      }\n+\n+      @Override\n+      public Exception exception() {\n+        return null;", "originalCommit": "5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzOTg1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379539851", "bodyText": "This is sort of similar to the Vert.x AsyncResult class, where in case of success it's ok for the exception to be null.\nif (result.exception != null)\n\nIs a synonym for\nif (result.succeeded())", "author": "purplefox", "createdAt": "2020-02-14T16:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1NDM2OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1NTQ2Mg==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379455462", "bodyText": "nit: Can we have all the fields declared at the top of the file, please?", "author": "big-andy-coates", "createdAt": "2020-02-14T14:22:46Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java", "diffHunk": "@@ -103,30 +122,55 @@ private void handleArgs(final Buffer buff) {\n         return;\n       }\n \n-      acksSubscriber =\n-          insertsStreamArgs.get().requiresAcks ? new AcksSubscriber(ctx, routingContext.response(),\n-              insertsStreamResponseWriter) : null;\n-      final InsertsSubscriber insertsSubscriber = endpoints\n-          .createInsertsSubscriber(insertsStreamArgs.get().target,\n-              insertsStreamArgs.get().properties,\n-              acksSubscriber);\n-      publisher = new BufferedPublisher<>(ctx);\n+      routingContext.response().endHandler(v -> handleResponseEnd());\n+\n+      acksSubscriber = new AcksSubscriber(ctx, routingContext.response(),\n+          insertsStreamResponseWriter);\n+\n+      recordParser.pause();\n+      createInsertsSubscriberAsync(insertsStreamArgs.get().target,\n+          insertsStreamArgs.get().properties,\n+          acksSubscriber, ctx)\n+          .thenAccept(insertsSubscriber -> {\n+            publisher = new BufferedPublisher<>(ctx);\n \n-      // This forces response headers to be written so we know we send a 200 OK\n-      // This is important if we subsequently find an error in the stream\n-      routingContext.response().write(\"\");\n+            // This forces response headers to be written so we know we send a 200 OK\n+            // This is important if we subsequently find an error in the stream\n+            routingContext.response().write(\"\");\n \n-      publisher.subscribe(insertsSubscriber);\n+            publisher.subscribe(insertsSubscriber);\n \n+            recordParser.resume();\n+\n+            this.insertsSubscriber = insertsSubscriber;\n+          })\n+          .exceptionally(t -> handleInsertSubscriberException(t, routingContext));\n     }\n \n-    private void handleRow(final Buffer buff) {\n+    private InsertsStreamSubscriber insertsSubscriber;", "originalCommit": "5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNzEyOA==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379537128", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-14T16:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1NTQ2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c63ad53ee9653ada35be93b43b2aeec4898626fb", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java\nindex efd9a6e4dd..f2324201b4 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsStreamHandler.java\n\n@@ -141,14 +141,10 @@ public class InsertsStreamHandler implements Handler<RoutingContext> {\n             publisher.subscribe(insertsSubscriber);\n \n             recordParser.resume();\n-\n-            this.insertsSubscriber = insertsSubscriber;\n           })\n           .exceptionally(t -> handleInsertSubscriberException(t, routingContext));\n     }\n \n-    private InsertsStreamSubscriber insertsSubscriber;\n-\n     private Void handleInsertSubscriberException(final Throwable t,\n         final RoutingContext routingContext) {\n       Throwable toLog = t;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1NjQxNw==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379456417", "bodyText": "Would it make sense to have a base KsqlApiException that held the errorCode?  I'm sure there will be other operations other than inserts that want to return a error code, right?", "author": "big-andy-coates", "createdAt": "2020-02-14T14:24:38Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/KsqlInsertsException.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.util.KsqlException;\n+\n+public class KsqlInsertsException extends KsqlException {\n+\n+  private final int errorCode;", "originalCommit": "5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNzQzNQ==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379537435", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-14T16:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1NjQxNw=="}], "type": "inlineReview", "revised_code": {"commit": "c63ad53ee9653ada35be93b43b2aeec4898626fb", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/KsqlInsertsException.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/KsqlInsertsException.java\nindex 8a7e397663..353f711d02 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/KsqlInsertsException.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/KsqlInsertsException.java\n\n@@ -19,14 +19,15 @@ import io.confluent.ksql.util.KsqlException;\n \n public class KsqlInsertsException extends KsqlException {\n \n-  private final int errorCode;\n+  public KsqlInsertsException(final Throwable cause) {\n+    super(cause);\n+  }\n \n-  public KsqlInsertsException(final String message, final int errorCode) {\n+  public KsqlInsertsException(final String message) {\n     super(message);\n-    this.errorCode = errorCode;\n   }\n \n-  public int getErrorCode() {\n-    return errorCode;\n+  public KsqlInsertsException(final String message, final Throwable cause) {\n+    super(message, cause);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ3MjY3Ng==", "url": "https://github.com/confluentinc/ksql/pull/4512#discussion_r379472676", "bodyText": "I think I've seen this snippet of code repeated quite a few times in the new API code.  Might it be worth coding this into a type?  i.e. a type that takes the response as a constructor param, and you can just call enqueue(this::checkMakeRequest) and it will internally handle checking if the queue is full, setting the drain handler and flag etc.?", "author": "big-andy-coates", "createdAt": "2020-02-14T14:54:11Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -54,22 +55,41 @@ protected void afterSubscribe(final Subscription subscription) {\n   }\n \n   @Override\n-  public void handleValue(final JsonObject value) {\n+  public void handleValue(final InsertResult result) {\n     checkContext();\n-    insertsStreamResponseWriter.writeInsertResponse();\n-    acksSent++;\n-    if (insertsSent != null && insertsSent == acksSent) {\n-      close();\n-    } else if (response.writeQueueFull()) {\n-      if (!drainHandlerSet) {\n-        response.drainHandler(v -> {\n-          drainHandlerSet = false;\n-          checkMakeRequest();\n-        });\n-        drainHandlerSet = true;\n+    if (responseEnded) {\n+      return;\n+    }\n+    if (result.succeeded()) {\n+      insertsStreamResponseWriter.writeInsertResponse(new InsertAck(result.sequenceNumber()));\n+      acksSent++;\n+      if (insertsSent != null && insertsSent == acksSent) {\n+        close();\n+      } else if (response.writeQueueFull()) {\n+        if (!drainHandlerSet) {\n+          response.drainHandler(v -> {\n+            drainHandlerSet = false;\n+            checkMakeRequest();\n+          });\n+          drainHandlerSet = true;\n+        }\n+      } else {\n+        checkMakeRequest();", "originalCommit": "5b9e0bfcc732841ad275dfe5a4bf3638e4888cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63ad53ee9653ada35be93b43b2aeec4898626fb", "chunk": "diff --git a/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java b/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\nindex 1d82b9edc9..bfdc2da002 100644\n--- a/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\n+++ b/ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java\n\n@@ -81,8 +82,7 @@ public class AcksSubscriber extends BaseSubscriber<InsertResult> {\n       final InsertError insertError;\n       final Exception exception = result.exception();\n       if (exception instanceof KsqlInsertsException) {\n-        insertError = new InsertError(result.sequenceNumber(),\n-            ((KsqlInsertsException) exception).getErrorCode(),\n+        insertError = new InsertError(result.sequenceNumber(), ERROR_CODE_MISSING_KEY_FIELD,\n             exception.getMessage());\n       } else {\n         insertError = new InsertError(result.sequenceNumber(), ERROR_CODE_INTERNAL_ERROR,\n"}}, {"oid": "c63ad53ee9653ada35be93b43b2aeec4898626fb", "url": "https://github.com/confluentinc/ksql/commit/c63ad53ee9653ada35be93b43b2aeec4898626fb", "message": "inserts stream", "committedDate": "2020-02-14T17:47:42Z", "type": "commit"}, {"oid": "e059af55dac68052ca276c49e33327f2a34262be", "url": "https://github.com/confluentinc/ksql/commit/e059af55dac68052ca276c49e33327f2a34262be", "message": "checkstyle", "committedDate": "2020-02-14T17:47:49Z", "type": "commit"}, {"oid": "573d911131b5721acd3fff9da90e20e208d98ecb", "url": "https://github.com/confluentinc/ksql/commit/573d911131b5721acd3fff9da90e20e208d98ecb", "message": "checkstyle", "committedDate": "2020-02-14T17:47:49Z", "type": "commit"}, {"oid": "33573e2a685bb9b9e4330f8ae723c0b6d8de4d54", "url": "https://github.com/confluentinc/ksql/commit/33573e2a685bb9b9e4330f8ae723c0b6d8de4d54", "message": "tweaks", "committedDate": "2020-02-14T17:47:49Z", "type": "commit"}, {"oid": "bee7700f026d9543547e52c4c7e8392d4b497e2f", "url": "https://github.com/confluentinc/ksql/commit/bee7700f026d9543547e52c4c7e8392d4b497e2f", "message": "Remove unnecessary acls from test", "committedDate": "2020-02-14T17:47:49Z", "type": "commit"}, {"oid": "76d7d9175432c92c65cd515a150243a0e35d9792", "url": "https://github.com/confluentinc/ksql/commit/76d7d9175432c92c65cd515a150243a0e35d9792", "message": "tweaks", "committedDate": "2020-02-14T17:47:49Z", "type": "commit"}, {"oid": "fff91c1e67a1c577af3310a91c12d5f6c42f8850", "url": "https://github.com/confluentinc/ksql/commit/fff91c1e67a1c577af3310a91c12d5f6c42f8850", "message": "more tweaks", "committedDate": "2020-02-14T17:47:49Z", "type": "commit"}, {"oid": "36c9ab82a27b4f7dced8f09febac7e1c928f30d7", "url": "https://github.com/confluentinc/ksql/commit/36c9ab82a27b4f7dced8f09febac7e1c928f30d7", "message": "try and trigger a jenkins build", "committedDate": "2020-02-14T17:47:49Z", "type": "commit"}, {"oid": "6b413793c75af273151251ff2585064e403c3418", "url": "https://github.com/confluentinc/ksql/commit/6b413793c75af273151251ff2585064e403c3418", "message": "force jenkins build", "committedDate": "2020-02-14T17:47:49Z", "type": "commit"}, {"oid": "94d295f2340738292f9754427c69610799b64f36", "url": "https://github.com/confluentinc/ksql/commit/94d295f2340738292f9754427c69610799b64f36", "message": "checkstyle", "committedDate": "2020-02-14T17:47:50Z", "type": "commit"}, {"oid": "ed3f86209ccce032ec752555333ae7683122112d", "url": "https://github.com/confluentinc/ksql/commit/ed3f86209ccce032ec752555333ae7683122112d", "message": "fix error message", "committedDate": "2020-02-14T17:47:50Z", "type": "commit"}, {"oid": "901392c44ac9190423e36f331c2a89ae29823982", "url": "https://github.com/confluentinc/ksql/commit/901392c44ac9190423e36f331c2a89ae29823982", "message": "review", "committedDate": "2020-02-14T17:47:50Z", "type": "commit"}, {"oid": "901392c44ac9190423e36f331c2a89ae29823982", "url": "https://github.com/confluentinc/ksql/commit/901392c44ac9190423e36f331c2a89ae29823982", "message": "review", "committedDate": "2020-02-14T17:47:50Z", "type": "forcePushed"}]}