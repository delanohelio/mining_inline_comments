{"pr_number": 6684, "pr_title": "feat: Move code from physical to logical plan for Projection", "pr_createdAt": "2020-11-26T21:35:48Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6684", "timeline": [{"oid": "92e7e17d330a2b37c4f38de9ce334f14e2763553", "url": "https://github.com/confluentinc/ksql/commit/92e7e17d330a2b37c4f38de9ce334f14e2763553", "message": "rebase", "committedDate": "2020-12-04T00:27:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNzU1NA==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r537727554", "bodyText": "What is the correspondence between DataSource and Materialization? Why do their schemas differ? If the Materialization is a table, then shouldn't the schema of the DataSource match that of the table? I.e not have the rowtime and key in the value?\nWhy do the output schemas of the pull query and FinalProjectNode differ? Basically, it seems that the output schemas of persistent queries are different than that of pull queries? Moreover, the output schema of FinalProjectNode seems to have extra columns that are not in the projection. Why?\n\nOff the top of my head (see bottom), I don't know the answers to these questions (and I'm not sure that without digging anyone on the team knows) but I think these are exactly the ones we need to answer (and document for the future! Ideally in the code...) before merging this pr. Then, we can see if we can change it to be a single code path for both persistent/pull queries.\nOtherwise (if we can't merge the code paths), I think we need to have two different logical nodes since they (logically) represent different operations and construct different schemas (they can extend a common base so that it's clear which code they share and which is different). We shouldn't make the pull and persistent code more intertwined but with a nuanced difference as it will make it harder to develop them independently without context on the other.\nFWIW, you can change the behavior of any logical node of the persistent queries so long as the QTT tests pass. Any old query will continue to work because the physical plans are persisted, not the logical ones, in the command topic.\n\n\nMoreover, the output schema of FinalProjectNode seems to have extra columns that are not in the projection.\n\nMy best guess on this one is that the rowkey-in-value/rowtime-in-value/windowstart/windowend columns are needed to handle the processing. At the moment, the way we've coded it up, most operations accept only the value and not the key (or other metadata information) - so we need to copy information from the key into the value. I've looked into changing this and I got pretty close, but the problem is that the Joiner code in streams doesn't yet have the signature that I need to fully get rid of it so I abandoned the change. I'll try to revisit it (and hopefully change that in streams if necessary) at some point.", "author": "agavra", "createdAt": "2020-12-07T18:22:58Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FinalProjectNode.java", "diffHunk": "@@ -56,23 +67,54 @@\n   private final Optional<Analysis.Into> into;\n   private final LogicalSchema schema;\n   private final ImmutableList<SelectExpression> selectExpressions;\n+  private final Optional<LogicalSchema> pullQueryOutputSchema;\n+  private final Optional<LogicalSchema> pullQueryIntermediateSchema;\n+  private final Optional<List<ExpressionMetadata>> compiledSelectExpressions;\n+  private final RewrittenAnalysis analysis;\n+  private final boolean isPullQuerySelectStar;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n \n   public FinalProjectNode(\n       final PlanNodeId id,\n       final PlanNode source,\n       final List<SelectItem> selectItems,\n       final Optional<Analysis.Into> into,\n-      final MetaStore metaStore\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final RewrittenAnalysis analysis\n   ) {\n     super(id, source);\n     this.projection = Projection.of(selectItems);\n     this.into = into;\n+    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n \n     final Pair<LogicalSchema, List<SelectExpression>> result = build(metaStore);\n     this.schema = result.left;\n     this.selectExpressions = ImmutableList.copyOf(result.right);\n+    if (analysis.isPullQuery()) {\n+      this.isPullQuerySelectStar = isPullQuerySelectStar();\n+      this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+      this.pullQueryOutputSchema = Optional.of(buildPullQueryOutputSchema(metaStore));\n+      this.pullQueryIntermediateSchema = Optional.of(buildPullQueryIntermediateSchema());\n+      this.compiledSelectExpressions = Optional.of(selectExpressions\n+          .stream()\n+          .map(selectExpression -> CodeGenRunner.compileExpression(\n+              selectExpression.getExpression(),\n+              \"Select\",\n+              pullQueryIntermediateSchema.get(),\n+              ksqlConfig,\n+              metaStore\n+          ))\n+          .collect(ImmutableList.toImmutableList()));\n+    } else {\n+      this.isPullQuerySelectStar = false;\n+      this.addAdditionalColumnsToIntermediateSchema = false;\n+      this.pullQueryOutputSchema = Optional.empty();\n+      this.pullQueryIntermediateSchema = Optional.empty();\n+      this.compiledSelectExpressions = Optional.empty();\n+      throwOnEmptyValueOrUnknownColumns();", "originalCommit": "a11156c785b42a4dd363c01e712d7b4e77b2cc9d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FinalProjectNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FinalProjectNode.java\nindex eea5c75991..e3484e6134 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FinalProjectNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FinalProjectNode.java\n\n@@ -68,11 +68,10 @@ public class FinalProjectNode extends ProjectNode implements VerifiableNode {\n   private final LogicalSchema schema;\n   private final ImmutableList<SelectExpression> selectExpressions;\n   private final Optional<LogicalSchema> pullQueryOutputSchema;\n-  private final Optional<LogicalSchema> pullQueryIntermediateSchema;\n   private final Optional<List<ExpressionMetadata>> compiledSelectExpressions;\n   private final RewrittenAnalysis analysis;\n-  private final boolean isPullQuerySelectStar;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final boolean isSelectStar;\n+  private final boolean noAdditionalColumnsInSchema;\n \n   public FinalProjectNode(\n       final PlanNodeId id,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNzQ2NA==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r537917464", "bodyText": "What exactly is the difference between FinalProjectNode and ProjectNode?", "author": "AlanConfluent", "createdAt": "2020-12-07T23:37:01Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java", "diffHunk": "@@ -137,17 +124,18 @@ public PullPhysicalPlan buildPullPhysicalPlan(final LogicalPlanNode logicalPlanN\n     while (true) {\n \n       AbstractPhysicalOperator currentPhysicalOp = null;\n-      if (currentLogicalNode instanceof ProjectNode) {\n-        currentPhysicalOp = translateProjectNode((ProjectNode)currentLogicalNode);\n+      if (currentLogicalNode instanceof FinalProjectNode) {", "originalCommit": "a11156c785b42a4dd363c01e712d7b4e77b2cc9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4MTM1Ng==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539581356", "bodyText": "I think this is outdated", "author": "AlanConfluent", "createdAt": "2020-12-09T19:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNzQ2NA=="}], "type": "inlineReview", "revised_code": {"commit": "9933eabb493594a555ba5024d0e4088afd765848", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java\nindex 3b7e31073e..d50e45c958 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java\n\n@@ -124,8 +124,8 @@ public class PullPhysicalPlanBuilder {\n     while (true) {\n \n       AbstractPhysicalOperator currentPhysicalOp = null;\n-      if (currentLogicalNode instanceof FinalProjectNode) {\n-        currentPhysicalOp = translateProjectNode((FinalProjectNode)currentLogicalNode);\n+      if (currentLogicalNode instanceof PullProjectNode) {\n+        currentPhysicalOp = translateProjectNode((PullProjectNode)currentLogicalNode);\n       } else if (currentLogicalNode instanceof FilterNode) {\n         currentPhysicalOp = translateFilterNode((FilterNode)currentLogicalNode);\n       } else if (currentLogicalNode instanceof DataSourceNode) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0NDYxMA==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539544610", "bodyText": "One nice benefit of splitting this up is that it's easier to throw errors for things that are not supported.  E.g. we could throw an error if there's a group by?  Where is this currently done at the moment?  It seems like at the very least we have the error Error in translating logical to physical plan for pull queries: unrecognized logical node. but ideally this should be caught at the logical layer.\nShould we do some of these checks here and throw errors if there are unsupported expressions?", "author": "AlanConfluent", "createdAt": "2020-12-09T18:27:22Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -170,6 +171,25 @@ public OutputNode buildPlan() {\n     return buildOutputNode(currentNode);\n   }\n \n+  public OutputNode buildPullLogicalPlan() {", "originalCommit": "f31c2df7dd36bdda2d026809c400b8646fefa94e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0NTMwNQ==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539745305", "bodyText": "Some of the checks about about for instance the group by are performed in the Analyzer and specifically, by the class PullQueryValidator. The rest of the checks about the WHERE clause will be performed when building the filter node and will be in the next PR", "author": "vpapavas", "createdAt": "2020-12-10T00:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0NDYxMA=="}], "type": "inlineReview", "revised_code": {"commit": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java\nindex 68c688c238..67dee07da7 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java\n\n@@ -171,25 +170,6 @@ public class LogicalPlanner {\n     return buildOutputNode(currentNode);\n   }\n \n-  public OutputNode buildPullLogicalPlan() {\n-    PlanNode currentNode = buildSourceNode();\n-\n-    if (analysis.getWhereExpression().isPresent()) {\n-      currentNode = buildFilterNode(currentNode, analysis.getWhereExpression().get());\n-    }\n-\n-    currentNode = new PullProjectNode(\n-        new PlanNodeId(\"Project\"),\n-        currentNode,\n-        analysis.getSelectItems(),\n-        metaStore,\n-        ksqlConfig,\n-        analysis);\n-\n-    return buildOutputNode(currentNode);\n-  }\n-\n-\n   private OutputNode buildOutputNode(final PlanNode sourcePlanNode) {\n     final LogicalSchema inputSchema = sourcePlanNode.getSchema();\n     final Optional<TimestampColumn> timestampColumn = getTimestampColumn(inputSchema, analysis);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NjI2NA==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539566264", "bodyText": "The intermediate schema is only used to evaluate these select expressions, right?\nI assume that for the where clause, you'd effectively have access to the same columns and want to build the same schema for evaluating those expressions.  Will you be able to share this or will you have to rebuild it in the SelectNode?", "author": "AlanConfluent", "createdAt": "2020-12-09T18:59:15Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node\n+ *\n+ * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n+ * is created as follows:\n+ * Check if projection contains system or key columns. If not, the intermediate schema\n+ * is the input schema. If there are any of these columns, the input schema is extended by copying\n+ * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n+ *\n+ * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n+ * columns and keep value columns the same as input. If projection is not SELECT *,\n+ * then process each select and if it is a key or windowstart and windowend add them to the key\n+ * part else add them to the value part.\n+ * </ul>\n+ */\n+public class PullProjectNode extends ProjectNode {\n+\n+  private final Projection projection;\n+  private final ImmutableList<SelectExpression> selectExpressions;\n+  private final LogicalSchema outputSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final List<ExpressionMetadata> compiledSelectExpressions;\n+  private final RewrittenAnalysis analysis;\n+  private final boolean isSelectStar;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+\n+  public PullProjectNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final List<SelectItem> selectItems,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final RewrittenAnalysis analysis\n+  ) {\n+    super(id, source);\n+    this.projection = Projection.of(selectItems);\n+    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n+    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n+        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n+    this.isSelectStar = isSelectStar();\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.outputSchema = buildOutputSchema(metaStore);\n+    this.intermediateSchema = buildIntermediateSchema();\n+    this.compiledSelectExpressions = selectExpressions\n+        .stream()\n+        .map(selectExpression -> CodeGenRunner.compileExpression(\n+            selectExpression.getExpression(),\n+            \"Select\",\n+            intermediateSchema,", "originalCommit": "f31c2df7dd36bdda2d026809c400b8646fefa94e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0NTc1OA==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539745758", "bodyText": "Yeah, for the next PR that does the WHERE clause I would have to share this schema. I will build it once in the WHERE and then the PROJECT since it sits above, will be able to get if from it. If a WHERE doesn't exist, then the PROJECT will build it", "author": "vpapavas", "createdAt": "2020-12-10T00:15:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NjI2NA=="}], "type": "inlineReview", "revised_code": {"commit": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\ndeleted file mode 100644\nindex 38437c333b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\n+++ /dev/null\n\n@@ -1,260 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.collect.ImmutableList;\n-import io.confluent.ksql.analyzer.RewrittenAnalysis;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.plan.SelectExpression;\n-import io.confluent.ksql.execution.util.ExpressionTypeManager;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.parser.tree.AllColumns;\n-import io.confluent.ksql.parser.tree.SelectItem;\n-import io.confluent.ksql.parser.tree.SingleColumn;\n-import io.confluent.ksql.planner.Projection;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.ksql.types.SqlType;\n-import io.confluent.ksql.schema.ksql.types.SqlTypes;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-/**\n- * The projection of a Pull query.\n- *\n- * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n- * for codegen and the output schema.\n- * <ul>\n- * <li>The input is the schema of the child node\n- *\n- * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n- * is created as follows:\n- * Check if projection contains system or key columns. If not, the intermediate schema\n- * is the input schema. If there are any of these columns, the input schema is extended by copying\n- * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n- *\n- * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n- * columns and keep value columns the same as input. If projection is not SELECT *,\n- * then process each select and if it is a key or windowstart and windowend add them to the key\n- * part else add them to the value part.\n- * </ul>\n- */\n-public class PullProjectNode extends ProjectNode {\n-\n-  private final Projection projection;\n-  private final ImmutableList<SelectExpression> selectExpressions;\n-  private final LogicalSchema outputSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final List<ExpressionMetadata> compiledSelectExpressions;\n-  private final RewrittenAnalysis analysis;\n-  private final boolean isSelectStar;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-\n-  public PullProjectNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final List<SelectItem> selectItems,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final RewrittenAnalysis analysis\n-  ) {\n-    super(id, source);\n-    this.projection = Projection.of(selectItems);\n-    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n-    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n-        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n-    this.isSelectStar = isSelectStar();\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.outputSchema = buildOutputSchema(metaStore);\n-    this.intermediateSchema = buildIntermediateSchema();\n-    this.compiledSelectExpressions = selectExpressions\n-        .stream()\n-        .map(selectExpression -> CodeGenRunner.compileExpression(\n-            selectExpression.getExpression(),\n-            \"Select\",\n-            intermediateSchema,\n-            ksqlConfig,\n-            metaStore\n-        ))\n-        .collect(ImmutableList.toImmutableList());\n-\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return outputSchema;\n-  }\n-\n-  @Override\n-  public List<SelectExpression> getSelectExpressions() {\n-    return selectExpressions;\n-  }\n-\n-  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n-    return compiledSelectExpressions;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  public boolean getIsSelectStar() {\n-    return isSelectStar;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  /**\n-   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n-   * need to be extended with system columns if they are part of the projection.\n-   * @return the intermediate schema\n-   */\n-  @VisibleForTesting\n-  protected LogicalSchema buildIntermediateSchema() {\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    if (!addAdditionalColumnsToIntermediateSchema) {\n-      return parentSchema;\n-    } else {\n-      // SelectValueMapper requires the rowTime & key fields in the value schema :(\n-      final boolean isWindowed = analysis\n-          .getFrom()\n-          .getDataSource()\n-          .getKsqlTopic()\n-          .getKeyFormat().isWindowed();\n-\n-      return parentSchema\n-          .withPseudoAndKeyColsInValue(isWindowed);\n-    }\n-  }\n-\n-  /**\n-   * Builds the output schema of the project node.\n-   * The output schema comprises of exactly the columns that appear in the SELECT clause of the\n-   * query.\n-   * @param metaStore the metastore\n-   * @return the project node's output schema\n-   */\n-  @VisibleForTesting\n-  protected LogicalSchema buildOutputSchema(final MetaStore metaStore) {\n-    final LogicalSchema outputSchema;\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-    final boolean isWindowed = analysis\n-        .getFrom()\n-        .getDataSource()\n-        .getKsqlTopic()\n-        .getKeyFormat().isWindowed();\n-\n-    if (isSelectStar()) {\n-      outputSchema = buildPullQuerySelectStarSchema(\n-          parentSchema.withoutPseudoAndKeyColsInValue(), isWindowed);\n-    } else {\n-      final List<SelectExpression> projects = projection.selectItems().stream()\n-          .map(SingleColumn.class::cast)\n-          .map(si -> SelectExpression\n-              .of(si.getAlias().orElseThrow(IllegalStateException::new), si.getExpression()))\n-          .collect(Collectors.toList());\n-\n-      outputSchema = selectOutputSchema(metaStore, projects, isWindowed);\n-    }\n-    return outputSchema;\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = analysis.getSelectColumnNames().stream().anyMatch(\n-        SystemColumns::isSystemColumn\n-    );\n-\n-    final boolean hasKeyColumns = analysis.getSelectColumnNames().stream().anyMatch(cn ->\n-        getSource().getSchema().isKeyColumn(cn)\n-    );\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-\n-  private boolean isSelectStar() {\n-    final boolean someStars = projection.selectItems().stream()\n-        .anyMatch(s -> s instanceof AllColumns);\n-\n-    if (someStars && projection.selectItems().size() != 1) {\n-      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n-                                  + \"if they are the only expression\");\n-    }\n-\n-    return someStars;\n-  }\n-\n-  private LogicalSchema buildPullQuerySelectStarSchema(\n-      final LogicalSchema schema,\n-      final boolean windowed\n-  ) {\n-    final Builder builder = LogicalSchema.builder()\n-        .keyColumns(schema.key());\n-\n-    if (windowed) {\n-      builder.keyColumn(SystemColumns.WINDOWSTART_NAME, SqlTypes.BIGINT);\n-      builder.keyColumn(SystemColumns.WINDOWEND_NAME, SqlTypes.BIGINT);\n-    }\n-\n-    return builder\n-        .valueColumns(schema.value())\n-        .build();\n-  }\n-\n-  private LogicalSchema selectOutputSchema(\n-      final MetaStore metaStore,\n-      final List<SelectExpression> selectExpressions,\n-      final boolean isWindowed\n-  ) {\n-    final Builder schemaBuilder = LogicalSchema.builder();\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    // Copy meta & key columns into the value schema as SelectValueMapper expects it:\n-    final LogicalSchema schema = parentSchema\n-        .withPseudoAndKeyColsInValue(isWindowed);\n-\n-    final ExpressionTypeManager expressionTypeManager =\n-        new ExpressionTypeManager(schema, metaStore);\n-\n-    for (final SelectExpression select : selectExpressions) {\n-      final SqlType type = expressionTypeManager.getExpressionSqlType(select.getExpression());\n-\n-      if (parentSchema.isKeyColumn(select.getAlias())\n-          || select.getAlias().equals(SystemColumns.WINDOWSTART_NAME)\n-          || select.getAlias().equals(SystemColumns.WINDOWEND_NAME)\n-      ) {\n-        schemaBuilder.keyColumn(select.getAlias(), type);\n-      } else {\n-        schemaBuilder.valueColumn(select.getAlias(), type);\n-      }\n-    }\n-    return schemaBuilder.build();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NjUxNA==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539566514", "bodyText": "Should this be package private and @VisibleForTesting?", "author": "AlanConfluent", "createdAt": "2020-12-09T18:59:36Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node\n+ *\n+ * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n+ * is created as follows:\n+ * Check if projection contains system or key columns. If not, the intermediate schema\n+ * is the input schema. If there are any of these columns, the input schema is extended by copying\n+ * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n+ *\n+ * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n+ * columns and keep value columns the same as input. If projection is not SELECT *,\n+ * then process each select and if it is a key or windowstart and windowend add them to the key\n+ * part else add them to the value part.\n+ * </ul>\n+ */\n+public class PullProjectNode extends ProjectNode {\n+\n+  private final Projection projection;\n+  private final ImmutableList<SelectExpression> selectExpressions;\n+  private final LogicalSchema outputSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final List<ExpressionMetadata> compiledSelectExpressions;\n+  private final RewrittenAnalysis analysis;\n+  private final boolean isSelectStar;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+\n+  public PullProjectNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final List<SelectItem> selectItems,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final RewrittenAnalysis analysis\n+  ) {\n+    super(id, source);\n+    this.projection = Projection.of(selectItems);\n+    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n+    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n+        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n+    this.isSelectStar = isSelectStar();\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.outputSchema = buildOutputSchema(metaStore);\n+    this.intermediateSchema = buildIntermediateSchema();\n+    this.compiledSelectExpressions = selectExpressions\n+        .stream()\n+        .map(selectExpression -> CodeGenRunner.compileExpression(\n+            selectExpression.getExpression(),\n+            \"Select\",\n+            intermediateSchema,\n+            ksqlConfig,\n+            metaStore\n+        ))\n+        .collect(ImmutableList.toImmutableList());\n+\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return outputSchema;\n+  }\n+\n+  @Override\n+  public List<SelectExpression> getSelectExpressions() {\n+    return selectExpressions;\n+  }\n+\n+  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n+    return compiledSelectExpressions;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {", "originalCommit": "f31c2df7dd36bdda2d026809c400b8646fefa94e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\ndeleted file mode 100644\nindex 38437c333b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\n+++ /dev/null\n\n@@ -1,260 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.collect.ImmutableList;\n-import io.confluent.ksql.analyzer.RewrittenAnalysis;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.plan.SelectExpression;\n-import io.confluent.ksql.execution.util.ExpressionTypeManager;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.parser.tree.AllColumns;\n-import io.confluent.ksql.parser.tree.SelectItem;\n-import io.confluent.ksql.parser.tree.SingleColumn;\n-import io.confluent.ksql.planner.Projection;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.ksql.types.SqlType;\n-import io.confluent.ksql.schema.ksql.types.SqlTypes;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-/**\n- * The projection of a Pull query.\n- *\n- * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n- * for codegen and the output schema.\n- * <ul>\n- * <li>The input is the schema of the child node\n- *\n- * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n- * is created as follows:\n- * Check if projection contains system or key columns. If not, the intermediate schema\n- * is the input schema. If there are any of these columns, the input schema is extended by copying\n- * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n- *\n- * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n- * columns and keep value columns the same as input. If projection is not SELECT *,\n- * then process each select and if it is a key or windowstart and windowend add them to the key\n- * part else add them to the value part.\n- * </ul>\n- */\n-public class PullProjectNode extends ProjectNode {\n-\n-  private final Projection projection;\n-  private final ImmutableList<SelectExpression> selectExpressions;\n-  private final LogicalSchema outputSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final List<ExpressionMetadata> compiledSelectExpressions;\n-  private final RewrittenAnalysis analysis;\n-  private final boolean isSelectStar;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-\n-  public PullProjectNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final List<SelectItem> selectItems,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final RewrittenAnalysis analysis\n-  ) {\n-    super(id, source);\n-    this.projection = Projection.of(selectItems);\n-    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n-    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n-        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n-    this.isSelectStar = isSelectStar();\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.outputSchema = buildOutputSchema(metaStore);\n-    this.intermediateSchema = buildIntermediateSchema();\n-    this.compiledSelectExpressions = selectExpressions\n-        .stream()\n-        .map(selectExpression -> CodeGenRunner.compileExpression(\n-            selectExpression.getExpression(),\n-            \"Select\",\n-            intermediateSchema,\n-            ksqlConfig,\n-            metaStore\n-        ))\n-        .collect(ImmutableList.toImmutableList());\n-\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return outputSchema;\n-  }\n-\n-  @Override\n-  public List<SelectExpression> getSelectExpressions() {\n-    return selectExpressions;\n-  }\n-\n-  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n-    return compiledSelectExpressions;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  public boolean getIsSelectStar() {\n-    return isSelectStar;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  /**\n-   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n-   * need to be extended with system columns if they are part of the projection.\n-   * @return the intermediate schema\n-   */\n-  @VisibleForTesting\n-  protected LogicalSchema buildIntermediateSchema() {\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    if (!addAdditionalColumnsToIntermediateSchema) {\n-      return parentSchema;\n-    } else {\n-      // SelectValueMapper requires the rowTime & key fields in the value schema :(\n-      final boolean isWindowed = analysis\n-          .getFrom()\n-          .getDataSource()\n-          .getKsqlTopic()\n-          .getKeyFormat().isWindowed();\n-\n-      return parentSchema\n-          .withPseudoAndKeyColsInValue(isWindowed);\n-    }\n-  }\n-\n-  /**\n-   * Builds the output schema of the project node.\n-   * The output schema comprises of exactly the columns that appear in the SELECT clause of the\n-   * query.\n-   * @param metaStore the metastore\n-   * @return the project node's output schema\n-   */\n-  @VisibleForTesting\n-  protected LogicalSchema buildOutputSchema(final MetaStore metaStore) {\n-    final LogicalSchema outputSchema;\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-    final boolean isWindowed = analysis\n-        .getFrom()\n-        .getDataSource()\n-        .getKsqlTopic()\n-        .getKeyFormat().isWindowed();\n-\n-    if (isSelectStar()) {\n-      outputSchema = buildPullQuerySelectStarSchema(\n-          parentSchema.withoutPseudoAndKeyColsInValue(), isWindowed);\n-    } else {\n-      final List<SelectExpression> projects = projection.selectItems().stream()\n-          .map(SingleColumn.class::cast)\n-          .map(si -> SelectExpression\n-              .of(si.getAlias().orElseThrow(IllegalStateException::new), si.getExpression()))\n-          .collect(Collectors.toList());\n-\n-      outputSchema = selectOutputSchema(metaStore, projects, isWindowed);\n-    }\n-    return outputSchema;\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = analysis.getSelectColumnNames().stream().anyMatch(\n-        SystemColumns::isSystemColumn\n-    );\n-\n-    final boolean hasKeyColumns = analysis.getSelectColumnNames().stream().anyMatch(cn ->\n-        getSource().getSchema().isKeyColumn(cn)\n-    );\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-\n-  private boolean isSelectStar() {\n-    final boolean someStars = projection.selectItems().stream()\n-        .anyMatch(s -> s instanceof AllColumns);\n-\n-    if (someStars && projection.selectItems().size() != 1) {\n-      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n-                                  + \"if they are the only expression\");\n-    }\n-\n-    return someStars;\n-  }\n-\n-  private LogicalSchema buildPullQuerySelectStarSchema(\n-      final LogicalSchema schema,\n-      final boolean windowed\n-  ) {\n-    final Builder builder = LogicalSchema.builder()\n-        .keyColumns(schema.key());\n-\n-    if (windowed) {\n-      builder.keyColumn(SystemColumns.WINDOWSTART_NAME, SqlTypes.BIGINT);\n-      builder.keyColumn(SystemColumns.WINDOWEND_NAME, SqlTypes.BIGINT);\n-    }\n-\n-    return builder\n-        .valueColumns(schema.value())\n-        .build();\n-  }\n-\n-  private LogicalSchema selectOutputSchema(\n-      final MetaStore metaStore,\n-      final List<SelectExpression> selectExpressions,\n-      final boolean isWindowed\n-  ) {\n-    final Builder schemaBuilder = LogicalSchema.builder();\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    // Copy meta & key columns into the value schema as SelectValueMapper expects it:\n-    final LogicalSchema schema = parentSchema\n-        .withPseudoAndKeyColsInValue(isWindowed);\n-\n-    final ExpressionTypeManager expressionTypeManager =\n-        new ExpressionTypeManager(schema, metaStore);\n-\n-    for (final SelectExpression select : selectExpressions) {\n-      final SqlType type = expressionTypeManager.getExpressionSqlType(select.getExpression());\n-\n-      if (parentSchema.isKeyColumn(select.getAlias())\n-          || select.getAlias().equals(SystemColumns.WINDOWSTART_NAME)\n-          || select.getAlias().equals(SystemColumns.WINDOWEND_NAME)\n-      ) {\n-        schemaBuilder.keyColumn(select.getAlias(), type);\n-      } else {\n-        schemaBuilder.valueColumn(select.getAlias(), type);\n-      }\n-    }\n-    return schemaBuilder.build();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MDEwMg==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539570102", "bodyText": "If you just apply the transform immediately, can you just call it directly rather than returning a function?", "author": "AlanConfluent", "createdAt": "2020-12-09T19:05:03Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java", "diffHunk": "@@ -163,17 +86,17 @@ public Object next() {\n     if (row == null) {\n       return null;\n     }\n-    if (isSelectStar) {\n+    if (logicalNode.getIsSelectStar()) {\n       return createRow(row);\n     }\n-    final GenericRow intermediate = preSelectTransform.apply(row);\n+    final GenericRow intermediate = getPreSelectTransform().apply(row);", "originalCommit": "f31c2df7dd36bdda2d026809c400b8646fefa94e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java\nindex 0c615c3aa0..7bbb7570c3 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java\n\n@@ -86,7 +86,7 @@ public class ProjectOperator extends AbstractPhysicalOperator implements UnaryPh\n     if (row == null) {\n       return null;\n     }\n-    if (logicalNode.getIsSelectStar()) {\n+    if (logicalNode.getIsPullQuerySelectStar()) {\n       return createRow(row);\n     }\n     final GenericRow intermediate = getPreSelectTransform().apply(row);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4MDI2Ng==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539580266", "bodyText": "Maybe this should be called getIntermediateRow to match the terminology of the logical node?", "author": "AlanConfluent", "createdAt": "2020-12-09T19:20:59Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java", "diffHunk": "@@ -207,8 +135,34 @@ public AbstractPhysicalOperator getChild(final int index) {\n     throw new UnsupportedOperationException();\n   }\n \n-  public LogicalSchema getOutputSchema() {\n-    return outputSchema;\n+  private Function<TableRow, GenericRow> getPreSelectTransform() {", "originalCommit": "f31c2df7dd36bdda2d026809c400b8646fefa94e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java\nindex 0c615c3aa0..7bbb7570c3 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/ProjectOperator.java\n\n@@ -137,15 +137,17 @@ public class ProjectOperator extends AbstractPhysicalOperator implements UnaryPh\n \n   private Function<TableRow, GenericRow> getPreSelectTransform() {\n \n-    if (!logicalNode.getAddAdditionalColumnsToIntermediateSchema()) {\n+    if (logicalNode.getNoAdditionalColumnsInSchema()) {\n       return TableRow::value;\n     }\n \n     return row -> {\n-      final GenericKey key = row.key();\n+      final Struct key = row.key();\n       final GenericRow value = row.value();\n \n-      final List<?> keyFields = key.values();\n+      final List<Object> keyFields = key.schema().fields().stream()\n+          .map(key::get)\n+          .collect(Collectors.toList());\n \n       value.ensureAdditionalCapacity(\n           1 // ROWTIME\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4OTk1MQ==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539589951", "bodyText": "But that's fine because this intermediate schema is never exposed, right?  The output schema puts these fields correctly as keys.", "author": "AlanConfluent", "createdAt": "2020-12-09T19:35:40Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node\n+ *\n+ * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n+ * is created as follows:\n+ * Check if projection contains system or key columns. If not, the intermediate schema\n+ * is the input schema. If there are any of these columns, the input schema is extended by copying\n+ * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n+ *\n+ * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n+ * columns and keep value columns the same as input. If projection is not SELECT *,\n+ * then process each select and if it is a key or windowstart and windowend add them to the key\n+ * part else add them to the value part.\n+ * </ul>\n+ */\n+public class PullProjectNode extends ProjectNode {\n+\n+  private final Projection projection;\n+  private final ImmutableList<SelectExpression> selectExpressions;\n+  private final LogicalSchema outputSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final List<ExpressionMetadata> compiledSelectExpressions;\n+  private final RewrittenAnalysis analysis;\n+  private final boolean isSelectStar;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+\n+  public PullProjectNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final List<SelectItem> selectItems,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final RewrittenAnalysis analysis\n+  ) {\n+    super(id, source);\n+    this.projection = Projection.of(selectItems);\n+    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n+    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n+        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n+    this.isSelectStar = isSelectStar();\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.outputSchema = buildOutputSchema(metaStore);\n+    this.intermediateSchema = buildIntermediateSchema();\n+    this.compiledSelectExpressions = selectExpressions\n+        .stream()\n+        .map(selectExpression -> CodeGenRunner.compileExpression(\n+            selectExpression.getExpression(),\n+            \"Select\",\n+            intermediateSchema,\n+            ksqlConfig,\n+            metaStore\n+        ))\n+        .collect(ImmutableList.toImmutableList());\n+\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return outputSchema;\n+  }\n+\n+  @Override\n+  public List<SelectExpression> getSelectExpressions() {\n+    return selectExpressions;\n+  }\n+\n+  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n+    return compiledSelectExpressions;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  public boolean getIsSelectStar() {\n+    return isSelectStar;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  /**\n+   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n+   * need to be extended with system columns if they are part of the projection.\n+   * @return the intermediate schema\n+   */\n+  @VisibleForTesting\n+  protected LogicalSchema buildIntermediateSchema() {\n+    final LogicalSchema parentSchema = getSource().getSchema();\n+\n+    if (!addAdditionalColumnsToIntermediateSchema) {\n+      return parentSchema;\n+    } else {\n+      // SelectValueMapper requires the rowTime & key fields in the value schema :(", "originalCommit": "f31c2df7dd36bdda2d026809c400b8646fefa94e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0NjAxMw==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539746013", "bodyText": "Yes, they are not exposed", "author": "vpapavas", "createdAt": "2020-12-10T00:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4OTk1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\ndeleted file mode 100644\nindex 38437c333b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\n+++ /dev/null\n\n@@ -1,260 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.collect.ImmutableList;\n-import io.confluent.ksql.analyzer.RewrittenAnalysis;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.plan.SelectExpression;\n-import io.confluent.ksql.execution.util.ExpressionTypeManager;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.parser.tree.AllColumns;\n-import io.confluent.ksql.parser.tree.SelectItem;\n-import io.confluent.ksql.parser.tree.SingleColumn;\n-import io.confluent.ksql.planner.Projection;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.ksql.types.SqlType;\n-import io.confluent.ksql.schema.ksql.types.SqlTypes;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-/**\n- * The projection of a Pull query.\n- *\n- * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n- * for codegen and the output schema.\n- * <ul>\n- * <li>The input is the schema of the child node\n- *\n- * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n- * is created as follows:\n- * Check if projection contains system or key columns. If not, the intermediate schema\n- * is the input schema. If there are any of these columns, the input schema is extended by copying\n- * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n- *\n- * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n- * columns and keep value columns the same as input. If projection is not SELECT *,\n- * then process each select and if it is a key or windowstart and windowend add them to the key\n- * part else add them to the value part.\n- * </ul>\n- */\n-public class PullProjectNode extends ProjectNode {\n-\n-  private final Projection projection;\n-  private final ImmutableList<SelectExpression> selectExpressions;\n-  private final LogicalSchema outputSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final List<ExpressionMetadata> compiledSelectExpressions;\n-  private final RewrittenAnalysis analysis;\n-  private final boolean isSelectStar;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-\n-  public PullProjectNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final List<SelectItem> selectItems,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final RewrittenAnalysis analysis\n-  ) {\n-    super(id, source);\n-    this.projection = Projection.of(selectItems);\n-    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n-    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n-        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n-    this.isSelectStar = isSelectStar();\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.outputSchema = buildOutputSchema(metaStore);\n-    this.intermediateSchema = buildIntermediateSchema();\n-    this.compiledSelectExpressions = selectExpressions\n-        .stream()\n-        .map(selectExpression -> CodeGenRunner.compileExpression(\n-            selectExpression.getExpression(),\n-            \"Select\",\n-            intermediateSchema,\n-            ksqlConfig,\n-            metaStore\n-        ))\n-        .collect(ImmutableList.toImmutableList());\n-\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return outputSchema;\n-  }\n-\n-  @Override\n-  public List<SelectExpression> getSelectExpressions() {\n-    return selectExpressions;\n-  }\n-\n-  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n-    return compiledSelectExpressions;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  public boolean getIsSelectStar() {\n-    return isSelectStar;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  /**\n-   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n-   * need to be extended with system columns if they are part of the projection.\n-   * @return the intermediate schema\n-   */\n-  @VisibleForTesting\n-  protected LogicalSchema buildIntermediateSchema() {\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    if (!addAdditionalColumnsToIntermediateSchema) {\n-      return parentSchema;\n-    } else {\n-      // SelectValueMapper requires the rowTime & key fields in the value schema :(\n-      final boolean isWindowed = analysis\n-          .getFrom()\n-          .getDataSource()\n-          .getKsqlTopic()\n-          .getKeyFormat().isWindowed();\n-\n-      return parentSchema\n-          .withPseudoAndKeyColsInValue(isWindowed);\n-    }\n-  }\n-\n-  /**\n-   * Builds the output schema of the project node.\n-   * The output schema comprises of exactly the columns that appear in the SELECT clause of the\n-   * query.\n-   * @param metaStore the metastore\n-   * @return the project node's output schema\n-   */\n-  @VisibleForTesting\n-  protected LogicalSchema buildOutputSchema(final MetaStore metaStore) {\n-    final LogicalSchema outputSchema;\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-    final boolean isWindowed = analysis\n-        .getFrom()\n-        .getDataSource()\n-        .getKsqlTopic()\n-        .getKeyFormat().isWindowed();\n-\n-    if (isSelectStar()) {\n-      outputSchema = buildPullQuerySelectStarSchema(\n-          parentSchema.withoutPseudoAndKeyColsInValue(), isWindowed);\n-    } else {\n-      final List<SelectExpression> projects = projection.selectItems().stream()\n-          .map(SingleColumn.class::cast)\n-          .map(si -> SelectExpression\n-              .of(si.getAlias().orElseThrow(IllegalStateException::new), si.getExpression()))\n-          .collect(Collectors.toList());\n-\n-      outputSchema = selectOutputSchema(metaStore, projects, isWindowed);\n-    }\n-    return outputSchema;\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = analysis.getSelectColumnNames().stream().anyMatch(\n-        SystemColumns::isSystemColumn\n-    );\n-\n-    final boolean hasKeyColumns = analysis.getSelectColumnNames().stream().anyMatch(cn ->\n-        getSource().getSchema().isKeyColumn(cn)\n-    );\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-\n-  private boolean isSelectStar() {\n-    final boolean someStars = projection.selectItems().stream()\n-        .anyMatch(s -> s instanceof AllColumns);\n-\n-    if (someStars && projection.selectItems().size() != 1) {\n-      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n-                                  + \"if they are the only expression\");\n-    }\n-\n-    return someStars;\n-  }\n-\n-  private LogicalSchema buildPullQuerySelectStarSchema(\n-      final LogicalSchema schema,\n-      final boolean windowed\n-  ) {\n-    final Builder builder = LogicalSchema.builder()\n-        .keyColumns(schema.key());\n-\n-    if (windowed) {\n-      builder.keyColumn(SystemColumns.WINDOWSTART_NAME, SqlTypes.BIGINT);\n-      builder.keyColumn(SystemColumns.WINDOWEND_NAME, SqlTypes.BIGINT);\n-    }\n-\n-    return builder\n-        .valueColumns(schema.value())\n-        .build();\n-  }\n-\n-  private LogicalSchema selectOutputSchema(\n-      final MetaStore metaStore,\n-      final List<SelectExpression> selectExpressions,\n-      final boolean isWindowed\n-  ) {\n-    final Builder schemaBuilder = LogicalSchema.builder();\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    // Copy meta & key columns into the value schema as SelectValueMapper expects it:\n-    final LogicalSchema schema = parentSchema\n-        .withPseudoAndKeyColsInValue(isWindowed);\n-\n-    final ExpressionTypeManager expressionTypeManager =\n-        new ExpressionTypeManager(schema, metaStore);\n-\n-    for (final SelectExpression select : selectExpressions) {\n-      final SqlType type = expressionTypeManager.getExpressionSqlType(select.getExpression());\n-\n-      if (parentSchema.isKeyColumn(select.getAlias())\n-          || select.getAlias().equals(SystemColumns.WINDOWSTART_NAME)\n-          || select.getAlias().equals(SystemColumns.WINDOWEND_NAME)\n-      ) {\n-        schemaBuilder.keyColumn(select.getAlias(), type);\n-      } else {\n-        schemaBuilder.valueColumn(select.getAlias(), type);\n-      }\n-    }\n-    return schemaBuilder.build();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MTUwOQ==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539591509", "bodyText": "This is just to use the SelectValueMapper, right?", "author": "AlanConfluent", "createdAt": "2020-12-09T19:38:02Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node\n+ *\n+ * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n+ * is created as follows:\n+ * Check if projection contains system or key columns. If not, the intermediate schema\n+ * is the input schema. If there are any of these columns, the input schema is extended by copying\n+ * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.", "originalCommit": "f31c2df7dd36bdda2d026809c400b8646fefa94e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0NjA5MQ==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539746091", "bodyText": "Correct", "author": "vpapavas", "createdAt": "2020-12-10T00:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MTUwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\ndeleted file mode 100644\nindex 38437c333b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\n+++ /dev/null\n\n@@ -1,260 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.collect.ImmutableList;\n-import io.confluent.ksql.analyzer.RewrittenAnalysis;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.plan.SelectExpression;\n-import io.confluent.ksql.execution.util.ExpressionTypeManager;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.parser.tree.AllColumns;\n-import io.confluent.ksql.parser.tree.SelectItem;\n-import io.confluent.ksql.parser.tree.SingleColumn;\n-import io.confluent.ksql.planner.Projection;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.ksql.types.SqlType;\n-import io.confluent.ksql.schema.ksql.types.SqlTypes;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-/**\n- * The projection of a Pull query.\n- *\n- * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n- * for codegen and the output schema.\n- * <ul>\n- * <li>The input is the schema of the child node\n- *\n- * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n- * is created as follows:\n- * Check if projection contains system or key columns. If not, the intermediate schema\n- * is the input schema. If there are any of these columns, the input schema is extended by copying\n- * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n- *\n- * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n- * columns and keep value columns the same as input. If projection is not SELECT *,\n- * then process each select and if it is a key or windowstart and windowend add them to the key\n- * part else add them to the value part.\n- * </ul>\n- */\n-public class PullProjectNode extends ProjectNode {\n-\n-  private final Projection projection;\n-  private final ImmutableList<SelectExpression> selectExpressions;\n-  private final LogicalSchema outputSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final List<ExpressionMetadata> compiledSelectExpressions;\n-  private final RewrittenAnalysis analysis;\n-  private final boolean isSelectStar;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-\n-  public PullProjectNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final List<SelectItem> selectItems,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final RewrittenAnalysis analysis\n-  ) {\n-    super(id, source);\n-    this.projection = Projection.of(selectItems);\n-    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n-    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n-        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n-    this.isSelectStar = isSelectStar();\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.outputSchema = buildOutputSchema(metaStore);\n-    this.intermediateSchema = buildIntermediateSchema();\n-    this.compiledSelectExpressions = selectExpressions\n-        .stream()\n-        .map(selectExpression -> CodeGenRunner.compileExpression(\n-            selectExpression.getExpression(),\n-            \"Select\",\n-            intermediateSchema,\n-            ksqlConfig,\n-            metaStore\n-        ))\n-        .collect(ImmutableList.toImmutableList());\n-\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return outputSchema;\n-  }\n-\n-  @Override\n-  public List<SelectExpression> getSelectExpressions() {\n-    return selectExpressions;\n-  }\n-\n-  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n-    return compiledSelectExpressions;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  public boolean getIsSelectStar() {\n-    return isSelectStar;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  /**\n-   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n-   * need to be extended with system columns if they are part of the projection.\n-   * @return the intermediate schema\n-   */\n-  @VisibleForTesting\n-  protected LogicalSchema buildIntermediateSchema() {\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    if (!addAdditionalColumnsToIntermediateSchema) {\n-      return parentSchema;\n-    } else {\n-      // SelectValueMapper requires the rowTime & key fields in the value schema :(\n-      final boolean isWindowed = analysis\n-          .getFrom()\n-          .getDataSource()\n-          .getKsqlTopic()\n-          .getKeyFormat().isWindowed();\n-\n-      return parentSchema\n-          .withPseudoAndKeyColsInValue(isWindowed);\n-    }\n-  }\n-\n-  /**\n-   * Builds the output schema of the project node.\n-   * The output schema comprises of exactly the columns that appear in the SELECT clause of the\n-   * query.\n-   * @param metaStore the metastore\n-   * @return the project node's output schema\n-   */\n-  @VisibleForTesting\n-  protected LogicalSchema buildOutputSchema(final MetaStore metaStore) {\n-    final LogicalSchema outputSchema;\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-    final boolean isWindowed = analysis\n-        .getFrom()\n-        .getDataSource()\n-        .getKsqlTopic()\n-        .getKeyFormat().isWindowed();\n-\n-    if (isSelectStar()) {\n-      outputSchema = buildPullQuerySelectStarSchema(\n-          parentSchema.withoutPseudoAndKeyColsInValue(), isWindowed);\n-    } else {\n-      final List<SelectExpression> projects = projection.selectItems().stream()\n-          .map(SingleColumn.class::cast)\n-          .map(si -> SelectExpression\n-              .of(si.getAlias().orElseThrow(IllegalStateException::new), si.getExpression()))\n-          .collect(Collectors.toList());\n-\n-      outputSchema = selectOutputSchema(metaStore, projects, isWindowed);\n-    }\n-    return outputSchema;\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = analysis.getSelectColumnNames().stream().anyMatch(\n-        SystemColumns::isSystemColumn\n-    );\n-\n-    final boolean hasKeyColumns = analysis.getSelectColumnNames().stream().anyMatch(cn ->\n-        getSource().getSchema().isKeyColumn(cn)\n-    );\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-\n-  private boolean isSelectStar() {\n-    final boolean someStars = projection.selectItems().stream()\n-        .anyMatch(s -> s instanceof AllColumns);\n-\n-    if (someStars && projection.selectItems().size() != 1) {\n-      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n-                                  + \"if they are the only expression\");\n-    }\n-\n-    return someStars;\n-  }\n-\n-  private LogicalSchema buildPullQuerySelectStarSchema(\n-      final LogicalSchema schema,\n-      final boolean windowed\n-  ) {\n-    final Builder builder = LogicalSchema.builder()\n-        .keyColumns(schema.key());\n-\n-    if (windowed) {\n-      builder.keyColumn(SystemColumns.WINDOWSTART_NAME, SqlTypes.BIGINT);\n-      builder.keyColumn(SystemColumns.WINDOWEND_NAME, SqlTypes.BIGINT);\n-    }\n-\n-    return builder\n-        .valueColumns(schema.value())\n-        .build();\n-  }\n-\n-  private LogicalSchema selectOutputSchema(\n-      final MetaStore metaStore,\n-      final List<SelectExpression> selectExpressions,\n-      final boolean isWindowed\n-  ) {\n-    final Builder schemaBuilder = LogicalSchema.builder();\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    // Copy meta & key columns into the value schema as SelectValueMapper expects it:\n-    final LogicalSchema schema = parentSchema\n-        .withPseudoAndKeyColsInValue(isWindowed);\n-\n-    final ExpressionTypeManager expressionTypeManager =\n-        new ExpressionTypeManager(schema, metaStore);\n-\n-    for (final SelectExpression select : selectExpressions) {\n-      final SqlType type = expressionTypeManager.getExpressionSqlType(select.getExpression());\n-\n-      if (parentSchema.isKeyColumn(select.getAlias())\n-          || select.getAlias().equals(SystemColumns.WINDOWSTART_NAME)\n-          || select.getAlias().equals(SystemColumns.WINDOWEND_NAME)\n-      ) {\n-        schemaBuilder.keyColumn(select.getAlias(), type);\n-      } else {\n-        schemaBuilder.valueColumn(select.getAlias(), type);\n-      }\n-    }\n-    return schemaBuilder.build();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MzEzNg==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539593136", "bodyText": "Does this mean ExpressionTypeManager expects it?  That's the main place where this schema is used is just to evaluate the type of the expression.", "author": "AlanConfluent", "createdAt": "2020-12-09T19:40:30Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node\n+ *\n+ * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n+ * is created as follows:\n+ * Check if projection contains system or key columns. If not, the intermediate schema\n+ * is the input schema. If there are any of these columns, the input schema is extended by copying\n+ * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n+ *\n+ * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n+ * columns and keep value columns the same as input. If projection is not SELECT *,\n+ * then process each select and if it is a key or windowstart and windowend add them to the key\n+ * part else add them to the value part.\n+ * </ul>\n+ */\n+public class PullProjectNode extends ProjectNode {\n+\n+  private final Projection projection;\n+  private final ImmutableList<SelectExpression> selectExpressions;\n+  private final LogicalSchema outputSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final List<ExpressionMetadata> compiledSelectExpressions;\n+  private final RewrittenAnalysis analysis;\n+  private final boolean isSelectStar;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+\n+  public PullProjectNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final List<SelectItem> selectItems,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final RewrittenAnalysis analysis\n+  ) {\n+    super(id, source);\n+    this.projection = Projection.of(selectItems);\n+    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n+    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n+        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n+    this.isSelectStar = isSelectStar();\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.outputSchema = buildOutputSchema(metaStore);\n+    this.intermediateSchema = buildIntermediateSchema();\n+    this.compiledSelectExpressions = selectExpressions\n+        .stream()\n+        .map(selectExpression -> CodeGenRunner.compileExpression(\n+            selectExpression.getExpression(),\n+            \"Select\",\n+            intermediateSchema,\n+            ksqlConfig,\n+            metaStore\n+        ))\n+        .collect(ImmutableList.toImmutableList());\n+\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return outputSchema;\n+  }\n+\n+  @Override\n+  public List<SelectExpression> getSelectExpressions() {\n+    return selectExpressions;\n+  }\n+\n+  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n+    return compiledSelectExpressions;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  public boolean getIsSelectStar() {\n+    return isSelectStar;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  /**\n+   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n+   * need to be extended with system columns if they are part of the projection.\n+   * @return the intermediate schema\n+   */\n+  @VisibleForTesting\n+  protected LogicalSchema buildIntermediateSchema() {\n+    final LogicalSchema parentSchema = getSource().getSchema();\n+\n+    if (!addAdditionalColumnsToIntermediateSchema) {\n+      return parentSchema;\n+    } else {\n+      // SelectValueMapper requires the rowTime & key fields in the value schema :(\n+      final boolean isWindowed = analysis\n+          .getFrom()\n+          .getDataSource()\n+          .getKsqlTopic()\n+          .getKeyFormat().isWindowed();\n+\n+      return parentSchema\n+          .withPseudoAndKeyColsInValue(isWindowed);\n+    }\n+  }\n+\n+  /**\n+   * Builds the output schema of the project node.\n+   * The output schema comprises of exactly the columns that appear in the SELECT clause of the\n+   * query.\n+   * @param metaStore the metastore\n+   * @return the project node's output schema\n+   */\n+  @VisibleForTesting\n+  protected LogicalSchema buildOutputSchema(final MetaStore metaStore) {\n+    final LogicalSchema outputSchema;\n+    final LogicalSchema parentSchema = getSource().getSchema();\n+    final boolean isWindowed = analysis\n+        .getFrom()\n+        .getDataSource()\n+        .getKsqlTopic()\n+        .getKeyFormat().isWindowed();\n+\n+    if (isSelectStar()) {\n+      outputSchema = buildPullQuerySelectStarSchema(\n+          parentSchema.withoutPseudoAndKeyColsInValue(), isWindowed);\n+    } else {\n+      final List<SelectExpression> projects = projection.selectItems().stream()\n+          .map(SingleColumn.class::cast)\n+          .map(si -> SelectExpression\n+              .of(si.getAlias().orElseThrow(IllegalStateException::new), si.getExpression()))\n+          .collect(Collectors.toList());\n+\n+      outputSchema = selectOutputSchema(metaStore, projects, isWindowed);\n+    }\n+    return outputSchema;\n+  }\n+\n+  /**\n+   * Checks whether the intermediate schema should be extended with system and key columns.\n+   * @return true if the intermediate schema should be extended\n+   */\n+  private boolean shouldAddAdditionalColumnsInSchema() {\n+\n+    final boolean hasSystemColumns = analysis.getSelectColumnNames().stream().anyMatch(\n+        SystemColumns::isSystemColumn\n+    );\n+\n+    final boolean hasKeyColumns = analysis.getSelectColumnNames().stream().anyMatch(cn ->\n+        getSource().getSchema().isKeyColumn(cn)\n+    );\n+\n+    return hasSystemColumns || hasKeyColumns;\n+  }\n+\n+  private boolean isSelectStar() {\n+    final boolean someStars = projection.selectItems().stream()\n+        .anyMatch(s -> s instanceof AllColumns);\n+\n+    if (someStars && projection.selectItems().size() != 1) {\n+      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n+                                  + \"if they are the only expression\");\n+    }\n+\n+    return someStars;\n+  }\n+\n+  private LogicalSchema buildPullQuerySelectStarSchema(\n+      final LogicalSchema schema,\n+      final boolean windowed\n+  ) {\n+    final Builder builder = LogicalSchema.builder()\n+        .keyColumns(schema.key());\n+\n+    if (windowed) {\n+      builder.keyColumn(SystemColumns.WINDOWSTART_NAME, SqlTypes.BIGINT);\n+      builder.keyColumn(SystemColumns.WINDOWEND_NAME, SqlTypes.BIGINT);\n+    }\n+\n+    return builder\n+        .valueColumns(schema.value())\n+        .build();\n+  }\n+\n+  private LogicalSchema selectOutputSchema(\n+      final MetaStore metaStore,\n+      final List<SelectExpression> selectExpressions,\n+      final boolean isWindowed\n+  ) {\n+    final Builder schemaBuilder = LogicalSchema.builder();\n+    final LogicalSchema parentSchema = getSource().getSchema();\n+\n+    // Copy meta & key columns into the value schema as SelectValueMapper expects it:", "originalCommit": "f31c2df7dd36bdda2d026809c400b8646fefa94e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0NzA3MA==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r539747070", "bodyText": "Also, the CodeGenRunner uses the schema", "author": "vpapavas", "createdAt": "2020-12-10T00:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MzEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE1NzYwNQ==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r541157605", "bodyText": "I guess I just meant that schema is only used with the ExpressionTypeManager and the comment is a bit misleading.", "author": "AlanConfluent", "createdAt": "2020-12-11T18:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MzEzNg=="}], "type": "inlineReview", "revised_code": {"commit": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\ndeleted file mode 100644\nindex 38437c333b..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\n+++ /dev/null\n\n@@ -1,260 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.collect.ImmutableList;\n-import io.confluent.ksql.analyzer.RewrittenAnalysis;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.plan.SelectExpression;\n-import io.confluent.ksql.execution.util.ExpressionTypeManager;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.parser.tree.AllColumns;\n-import io.confluent.ksql.parser.tree.SelectItem;\n-import io.confluent.ksql.parser.tree.SingleColumn;\n-import io.confluent.ksql.planner.Projection;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.ksql.types.SqlType;\n-import io.confluent.ksql.schema.ksql.types.SqlTypes;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-/**\n- * The projection of a Pull query.\n- *\n- * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n- * for codegen and the output schema.\n- * <ul>\n- * <li>The input is the schema of the child node\n- *\n- * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n- * is created as follows:\n- * Check if projection contains system or key columns. If not, the intermediate schema\n- * is the input schema. If there are any of these columns, the input schema is extended by copying\n- * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n- *\n- * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n- * columns and keep value columns the same as input. If projection is not SELECT *,\n- * then process each select and if it is a key or windowstart and windowend add them to the key\n- * part else add them to the value part.\n- * </ul>\n- */\n-public class PullProjectNode extends ProjectNode {\n-\n-  private final Projection projection;\n-  private final ImmutableList<SelectExpression> selectExpressions;\n-  private final LogicalSchema outputSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final List<ExpressionMetadata> compiledSelectExpressions;\n-  private final RewrittenAnalysis analysis;\n-  private final boolean isSelectStar;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-\n-  public PullProjectNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final List<SelectItem> selectItems,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final RewrittenAnalysis analysis\n-  ) {\n-    super(id, source);\n-    this.projection = Projection.of(selectItems);\n-    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n-    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n-        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n-    this.isSelectStar = isSelectStar();\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.outputSchema = buildOutputSchema(metaStore);\n-    this.intermediateSchema = buildIntermediateSchema();\n-    this.compiledSelectExpressions = selectExpressions\n-        .stream()\n-        .map(selectExpression -> CodeGenRunner.compileExpression(\n-            selectExpression.getExpression(),\n-            \"Select\",\n-            intermediateSchema,\n-            ksqlConfig,\n-            metaStore\n-        ))\n-        .collect(ImmutableList.toImmutableList());\n-\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return outputSchema;\n-  }\n-\n-  @Override\n-  public List<SelectExpression> getSelectExpressions() {\n-    return selectExpressions;\n-  }\n-\n-  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n-    return compiledSelectExpressions;\n-  }\n-\n-  public LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  public boolean getIsSelectStar() {\n-    return isSelectStar;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  /**\n-   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n-   * need to be extended with system columns if they are part of the projection.\n-   * @return the intermediate schema\n-   */\n-  @VisibleForTesting\n-  protected LogicalSchema buildIntermediateSchema() {\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    if (!addAdditionalColumnsToIntermediateSchema) {\n-      return parentSchema;\n-    } else {\n-      // SelectValueMapper requires the rowTime & key fields in the value schema :(\n-      final boolean isWindowed = analysis\n-          .getFrom()\n-          .getDataSource()\n-          .getKsqlTopic()\n-          .getKeyFormat().isWindowed();\n-\n-      return parentSchema\n-          .withPseudoAndKeyColsInValue(isWindowed);\n-    }\n-  }\n-\n-  /**\n-   * Builds the output schema of the project node.\n-   * The output schema comprises of exactly the columns that appear in the SELECT clause of the\n-   * query.\n-   * @param metaStore the metastore\n-   * @return the project node's output schema\n-   */\n-  @VisibleForTesting\n-  protected LogicalSchema buildOutputSchema(final MetaStore metaStore) {\n-    final LogicalSchema outputSchema;\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-    final boolean isWindowed = analysis\n-        .getFrom()\n-        .getDataSource()\n-        .getKsqlTopic()\n-        .getKeyFormat().isWindowed();\n-\n-    if (isSelectStar()) {\n-      outputSchema = buildPullQuerySelectStarSchema(\n-          parentSchema.withoutPseudoAndKeyColsInValue(), isWindowed);\n-    } else {\n-      final List<SelectExpression> projects = projection.selectItems().stream()\n-          .map(SingleColumn.class::cast)\n-          .map(si -> SelectExpression\n-              .of(si.getAlias().orElseThrow(IllegalStateException::new), si.getExpression()))\n-          .collect(Collectors.toList());\n-\n-      outputSchema = selectOutputSchema(metaStore, projects, isWindowed);\n-    }\n-    return outputSchema;\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = analysis.getSelectColumnNames().stream().anyMatch(\n-        SystemColumns::isSystemColumn\n-    );\n-\n-    final boolean hasKeyColumns = analysis.getSelectColumnNames().stream().anyMatch(cn ->\n-        getSource().getSchema().isKeyColumn(cn)\n-    );\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-\n-  private boolean isSelectStar() {\n-    final boolean someStars = projection.selectItems().stream()\n-        .anyMatch(s -> s instanceof AllColumns);\n-\n-    if (someStars && projection.selectItems().size() != 1) {\n-      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n-                                  + \"if they are the only expression\");\n-    }\n-\n-    return someStars;\n-  }\n-\n-  private LogicalSchema buildPullQuerySelectStarSchema(\n-      final LogicalSchema schema,\n-      final boolean windowed\n-  ) {\n-    final Builder builder = LogicalSchema.builder()\n-        .keyColumns(schema.key());\n-\n-    if (windowed) {\n-      builder.keyColumn(SystemColumns.WINDOWSTART_NAME, SqlTypes.BIGINT);\n-      builder.keyColumn(SystemColumns.WINDOWEND_NAME, SqlTypes.BIGINT);\n-    }\n-\n-    return builder\n-        .valueColumns(schema.value())\n-        .build();\n-  }\n-\n-  private LogicalSchema selectOutputSchema(\n-      final MetaStore metaStore,\n-      final List<SelectExpression> selectExpressions,\n-      final boolean isWindowed\n-  ) {\n-    final Builder schemaBuilder = LogicalSchema.builder();\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    // Copy meta & key columns into the value schema as SelectValueMapper expects it:\n-    final LogicalSchema schema = parentSchema\n-        .withPseudoAndKeyColsInValue(isWindowed);\n-\n-    final ExpressionTypeManager expressionTypeManager =\n-        new ExpressionTypeManager(schema, metaStore);\n-\n-    for (final SelectExpression select : selectExpressions) {\n-      final SqlType type = expressionTypeManager.getExpressionSqlType(select.getExpression());\n-\n-      if (parentSchema.isKeyColumn(select.getAlias())\n-          || select.getAlias().equals(SystemColumns.WINDOWSTART_NAME)\n-          || select.getAlias().equals(SystemColumns.WINDOWEND_NAME)\n-      ) {\n-        schemaBuilder.keyColumn(select.getAlias(), type);\n-      } else {\n-        schemaBuilder.valueColumn(select.getAlias(), type);\n-      }\n-    }\n-    return schemaBuilder.build();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0MjgwNQ==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r540442805", "bodyText": "thank you for the javadoc!", "author": "agavra", "createdAt": "2020-12-10T19:35:32Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.", "originalCommit": "a66694a0518fb72d9eb26a900b4983be215b77f4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\ndeleted file mode 100644\nindex 067633d35a..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\n+++ /dev/null\n\n@@ -1,257 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.collect.ImmutableList;\n-import io.confluent.ksql.analyzer.RewrittenAnalysis;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.plan.SelectExpression;\n-import io.confluent.ksql.execution.util.ExpressionTypeManager;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.parser.tree.AllColumns;\n-import io.confluent.ksql.parser.tree.SelectItem;\n-import io.confluent.ksql.parser.tree.SingleColumn;\n-import io.confluent.ksql.planner.Projection;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.ksql.types.SqlType;\n-import io.confluent.ksql.schema.ksql.types.SqlTypes;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-/**\n- * The projection of a Pull query.\n- *\n- * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n- * for codegen and the output schema.\n- * <ul>\n- * <li>The input is the schema of the child node\n- *\n- * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n- * is created as follows:\n- * Check if projection contains system or key columns. If not, the intermediate schema\n- * is the input schema. If there are any of these columns, the input schema is extended by copying\n- * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n- *\n- * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n- * columns and keep value columns the same as input. If projection is not SELECT *,\n- * then process each select and if it is a key or windowstart and windowend add them to the key\n- * part else add them to the value part.\n- * </ul>\n- */\n-public class PullProjectNode extends ProjectNode {\n-\n-  private final Projection projection;\n-  private final ImmutableList<SelectExpression> selectExpressions;\n-  private final LogicalSchema outputSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final List<ExpressionMetadata> compiledSelectExpressions;\n-  private final RewrittenAnalysis analysis;\n-  private final boolean isSelectStar;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-\n-  public PullProjectNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final List<SelectItem> selectItems,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final RewrittenAnalysis analysis\n-  ) {\n-    super(id, source);\n-    this.projection = Projection.of(selectItems);\n-    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n-    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n-        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n-    this.isSelectStar = isSelectStar();\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.outputSchema = buildOutputSchema(metaStore);\n-    this.intermediateSchema = buildIntermediateSchema();\n-    this.compiledSelectExpressions = selectExpressions\n-        .stream()\n-        .map(selectExpression -> CodeGenRunner.compileExpression(\n-            selectExpression.getExpression(),\n-            \"Select\",\n-            intermediateSchema,\n-            ksqlConfig,\n-            metaStore\n-        ))\n-        .collect(ImmutableList.toImmutableList());\n-\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return outputSchema;\n-  }\n-\n-  @Override\n-  public List<SelectExpression> getSelectExpressions() {\n-    return selectExpressions;\n-  }\n-\n-  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n-    return compiledSelectExpressions;\n-  }\n-\n-  LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  public boolean getIsSelectStar() {\n-    return isSelectStar;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  /**\n-   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n-   * need to be extended with system columns if they are part of the projection.\n-   * @return the intermediate schema\n-   */\n-  private LogicalSchema buildIntermediateSchema() {\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    if (!addAdditionalColumnsToIntermediateSchema) {\n-      return parentSchema;\n-    } else {\n-      // SelectValueMapper requires the rowTime & key fields in the value schema :(\n-      final boolean isWindowed = analysis\n-          .getFrom()\n-          .getDataSource()\n-          .getKsqlTopic()\n-          .getKeyFormat().isWindowed();\n-\n-      return parentSchema\n-          .withPseudoAndKeyColsInValue(isWindowed);\n-    }\n-  }\n-\n-  /**\n-   * Builds the output schema of the project node.\n-   * The output schema comprises of exactly the columns that appear in the SELECT clause of the\n-   * query.\n-   * @param metaStore the metastore\n-   * @return the project node's output schema\n-   */\n-  private LogicalSchema buildOutputSchema(final MetaStore metaStore) {\n-    final LogicalSchema outputSchema;\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-    final boolean isWindowed = analysis\n-        .getFrom()\n-        .getDataSource()\n-        .getKsqlTopic()\n-        .getKeyFormat().isWindowed();\n-\n-    if (isSelectStar()) {\n-      outputSchema = buildPullQuerySelectStarSchema(\n-          parentSchema.withoutPseudoAndKeyColsInValue(), isWindowed);\n-    } else {\n-      final List<SelectExpression> projects = projection.selectItems().stream()\n-          .map(SingleColumn.class::cast)\n-          .map(si -> SelectExpression\n-              .of(si.getAlias().orElseThrow(IllegalStateException::new), si.getExpression()))\n-          .collect(Collectors.toList());\n-\n-      outputSchema = selectOutputSchema(metaStore, projects, isWindowed);\n-    }\n-    return outputSchema;\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = analysis.getSelectColumnNames().stream().anyMatch(\n-        SystemColumns::isSystemColumn\n-    );\n-\n-    final boolean hasKeyColumns = analysis.getSelectColumnNames().stream().anyMatch(cn ->\n-        getSource().getSchema().isKeyColumn(cn)\n-    );\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-\n-  private boolean isSelectStar() {\n-    final boolean someStars = projection.selectItems().stream()\n-        .anyMatch(s -> s instanceof AllColumns);\n-\n-    if (someStars && projection.selectItems().size() != 1) {\n-      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n-                                  + \"if they are the only expression\");\n-    }\n-\n-    return someStars;\n-  }\n-\n-  private LogicalSchema buildPullQuerySelectStarSchema(\n-      final LogicalSchema schema,\n-      final boolean windowed\n-  ) {\n-    final Builder builder = LogicalSchema.builder()\n-        .keyColumns(schema.key());\n-\n-    if (windowed) {\n-      builder.keyColumn(SystemColumns.WINDOWSTART_NAME, SqlTypes.BIGINT);\n-      builder.keyColumn(SystemColumns.WINDOWEND_NAME, SqlTypes.BIGINT);\n-    }\n-\n-    return builder\n-        .valueColumns(schema.value())\n-        .build();\n-  }\n-\n-  private LogicalSchema selectOutputSchema(\n-      final MetaStore metaStore,\n-      final List<SelectExpression> selectExpressions,\n-      final boolean isWindowed\n-  ) {\n-    final Builder schemaBuilder = LogicalSchema.builder();\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    // Copy meta & key columns into the value schema as SelectValueMapper expects it:\n-    final LogicalSchema schema = parentSchema\n-        .withPseudoAndKeyColsInValue(isWindowed);\n-\n-    final ExpressionTypeManager expressionTypeManager =\n-        new ExpressionTypeManager(schema, metaStore);\n-\n-    for (final SelectExpression select : selectExpressions) {\n-      final SqlType type = expressionTypeManager.getExpressionSqlType(select.getExpression());\n-\n-      if (parentSchema.isKeyColumn(select.getAlias())\n-          || select.getAlias().equals(SystemColumns.WINDOWSTART_NAME)\n-          || select.getAlias().equals(SystemColumns.WINDOWEND_NAME)\n-      ) {\n-        schemaBuilder.keyColumn(select.getAlias(), type);\n-      } else {\n-        schemaBuilder.valueColumn(select.getAlias(), type);\n-      }\n-    }\n-    return schemaBuilder.build();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0NDk2MA==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r540444960", "bodyText": "excuse me while I philosophize for a bit...\njust wondering, is 'child' and 'parent' standard terminology in databases when discussing logical plans? I know we've standardized on it, but it always confuses me because the \"child\" is the \"source node\" which makes me feel like it's a \"parent\" \ud83e\udd14\nWhat do you think about upstream/downstream nodes? That way it's clear that the direction of data is flowing from the source nodes (upstream) to the sink nodes (downstream)", "author": "agavra", "createdAt": "2020-12-10T19:39:09Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.analyzer.RewrittenAnalysis;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import io.confluent.ksql.planner.Projection;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The projection of a Pull query.\n+ *\n+ * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n+ * for codegen and the output schema.\n+ * <ul>\n+ * <li>The input is the schema of the child node", "originalCommit": "a66694a0518fb72d9eb26a900b4983be215b77f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQwNjg2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r541406862", "bodyText": "The plans (logical, physical) are trees hence the terminology root, child, parent. The children are the leaves and as we move up the tree we visit from child to parent. Information and rows is flowing from the leaves towards the root.\nHonestly, sorry but I find the upstream/downstream more confusing :(", "author": "vpapavas", "createdAt": "2020-12-11T23:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0NDk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQxOTI4OQ==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r541419289", "bodyText": "\ud83d\ude02 haha i'll keep working at making it feel intuitive!", "author": "agavra", "createdAt": "2020-12-11T23:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0NDk2MA=="}], "type": "inlineReview", "revised_code": {"commit": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\ndeleted file mode 100644\nindex 067633d35a..0000000000\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullProjectNode.java\n+++ /dev/null\n\n@@ -1,257 +0,0 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.planner.plan;\n-\n-import com.google.common.collect.ImmutableList;\n-import io.confluent.ksql.analyzer.RewrittenAnalysis;\n-import io.confluent.ksql.execution.codegen.CodeGenRunner;\n-import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n-import io.confluent.ksql.execution.plan.SelectExpression;\n-import io.confluent.ksql.execution.util.ExpressionTypeManager;\n-import io.confluent.ksql.metastore.MetaStore;\n-import io.confluent.ksql.parser.tree.AllColumns;\n-import io.confluent.ksql.parser.tree.SelectItem;\n-import io.confluent.ksql.parser.tree.SingleColumn;\n-import io.confluent.ksql.planner.Projection;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n-import io.confluent.ksql.schema.ksql.SystemColumns;\n-import io.confluent.ksql.schema.ksql.types.SqlType;\n-import io.confluent.ksql.schema.ksql.types.SqlTypes;\n-import io.confluent.ksql.util.KsqlConfig;\n-import io.confluent.ksql.util.KsqlException;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-/**\n- * The projection of a Pull query.\n- *\n- * <p>There are 3 schemas the node is handling, the input schema, the intermediate schema used\n- * for codegen and the output schema.\n- * <ul>\n- * <li>The input is the schema of the child node\n- *\n- * <li>CodeGen is used only if the projection is not SELECT *. For CodeGen, an intermediate schema\n- * is created as follows:\n- * Check if projection contains system or key columns. If not, the intermediate schema\n- * is the input schema. If there are any of these columns, the input schema is extended by copying\n- * the key and system columns (rowtime, windwostart and windowend) into the value of the schema.\n- *\n- * <li>For the output schema, if the projection is SELECT *, add windowstart and windowend to key\n- * columns and keep value columns the same as input. If projection is not SELECT *,\n- * then process each select and if it is a key or windowstart and windowend add them to the key\n- * part else add them to the value part.\n- * </ul>\n- */\n-public class PullProjectNode extends ProjectNode {\n-\n-  private final Projection projection;\n-  private final ImmutableList<SelectExpression> selectExpressions;\n-  private final LogicalSchema outputSchema;\n-  private final LogicalSchema intermediateSchema;\n-  private final List<ExpressionMetadata> compiledSelectExpressions;\n-  private final RewrittenAnalysis analysis;\n-  private final boolean isSelectStar;\n-  private final boolean addAdditionalColumnsToIntermediateSchema;\n-\n-  public PullProjectNode(\n-      final PlanNodeId id,\n-      final PlanNode source,\n-      final List<SelectItem> selectItems,\n-      final MetaStore metaStore,\n-      final KsqlConfig ksqlConfig,\n-      final RewrittenAnalysis analysis\n-  ) {\n-    super(id, source);\n-    this.projection = Projection.of(selectItems);\n-    this.analysis = Objects.requireNonNull(analysis, \"analysis\");\n-    this.selectExpressions = ImmutableList.copyOf(SelectionUtil\n-        .buildSelectExpressions(getSource(), projection.selectItems(), Optional.empty()));\n-    this.isSelectStar = isSelectStar();\n-    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n-    this.outputSchema = buildOutputSchema(metaStore);\n-    this.intermediateSchema = buildIntermediateSchema();\n-    this.compiledSelectExpressions = selectExpressions\n-        .stream()\n-        .map(selectExpression -> CodeGenRunner.compileExpression(\n-            selectExpression.getExpression(),\n-            \"Select\",\n-            intermediateSchema,\n-            ksqlConfig,\n-            metaStore\n-        ))\n-        .collect(ImmutableList.toImmutableList());\n-\n-  }\n-\n-  @Override\n-  public LogicalSchema getSchema() {\n-    return outputSchema;\n-  }\n-\n-  @Override\n-  public List<SelectExpression> getSelectExpressions() {\n-    return selectExpressions;\n-  }\n-\n-  public List<ExpressionMetadata> getCompiledSelectExpressions() {\n-    return compiledSelectExpressions;\n-  }\n-\n-  LogicalSchema getIntermediateSchema() {\n-    return intermediateSchema;\n-  }\n-\n-  public boolean getIsSelectStar() {\n-    return isSelectStar;\n-  }\n-\n-  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n-    return addAdditionalColumnsToIntermediateSchema;\n-  }\n-\n-  /**\n-   * Builds the schema used for codegen to compile expressions into bytecode. The input schema may\n-   * need to be extended with system columns if they are part of the projection.\n-   * @return the intermediate schema\n-   */\n-  private LogicalSchema buildIntermediateSchema() {\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    if (!addAdditionalColumnsToIntermediateSchema) {\n-      return parentSchema;\n-    } else {\n-      // SelectValueMapper requires the rowTime & key fields in the value schema :(\n-      final boolean isWindowed = analysis\n-          .getFrom()\n-          .getDataSource()\n-          .getKsqlTopic()\n-          .getKeyFormat().isWindowed();\n-\n-      return parentSchema\n-          .withPseudoAndKeyColsInValue(isWindowed);\n-    }\n-  }\n-\n-  /**\n-   * Builds the output schema of the project node.\n-   * The output schema comprises of exactly the columns that appear in the SELECT clause of the\n-   * query.\n-   * @param metaStore the metastore\n-   * @return the project node's output schema\n-   */\n-  private LogicalSchema buildOutputSchema(final MetaStore metaStore) {\n-    final LogicalSchema outputSchema;\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-    final boolean isWindowed = analysis\n-        .getFrom()\n-        .getDataSource()\n-        .getKsqlTopic()\n-        .getKeyFormat().isWindowed();\n-\n-    if (isSelectStar()) {\n-      outputSchema = buildPullQuerySelectStarSchema(\n-          parentSchema.withoutPseudoAndKeyColsInValue(), isWindowed);\n-    } else {\n-      final List<SelectExpression> projects = projection.selectItems().stream()\n-          .map(SingleColumn.class::cast)\n-          .map(si -> SelectExpression\n-              .of(si.getAlias().orElseThrow(IllegalStateException::new), si.getExpression()))\n-          .collect(Collectors.toList());\n-\n-      outputSchema = selectOutputSchema(metaStore, projects, isWindowed);\n-    }\n-    return outputSchema;\n-  }\n-\n-  /**\n-   * Checks whether the intermediate schema should be extended with system and key columns.\n-   * @return true if the intermediate schema should be extended\n-   */\n-  private boolean shouldAddAdditionalColumnsInSchema() {\n-\n-    final boolean hasSystemColumns = analysis.getSelectColumnNames().stream().anyMatch(\n-        SystemColumns::isSystemColumn\n-    );\n-\n-    final boolean hasKeyColumns = analysis.getSelectColumnNames().stream().anyMatch(cn ->\n-        getSource().getSchema().isKeyColumn(cn)\n-    );\n-\n-    return hasSystemColumns || hasKeyColumns;\n-  }\n-\n-  private boolean isSelectStar() {\n-    final boolean someStars = projection.selectItems().stream()\n-        .anyMatch(s -> s instanceof AllColumns);\n-\n-    if (someStars && projection.selectItems().size() != 1) {\n-      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n-                                  + \"if they are the only expression\");\n-    }\n-\n-    return someStars;\n-  }\n-\n-  private LogicalSchema buildPullQuerySelectStarSchema(\n-      final LogicalSchema schema,\n-      final boolean windowed\n-  ) {\n-    final Builder builder = LogicalSchema.builder()\n-        .keyColumns(schema.key());\n-\n-    if (windowed) {\n-      builder.keyColumn(SystemColumns.WINDOWSTART_NAME, SqlTypes.BIGINT);\n-      builder.keyColumn(SystemColumns.WINDOWEND_NAME, SqlTypes.BIGINT);\n-    }\n-\n-    return builder\n-        .valueColumns(schema.value())\n-        .build();\n-  }\n-\n-  private LogicalSchema selectOutputSchema(\n-      final MetaStore metaStore,\n-      final List<SelectExpression> selectExpressions,\n-      final boolean isWindowed\n-  ) {\n-    final Builder schemaBuilder = LogicalSchema.builder();\n-    final LogicalSchema parentSchema = getSource().getSchema();\n-\n-    // Copy meta & key columns into the value schema as SelectValueMapper expects it:\n-    final LogicalSchema schema = parentSchema\n-        .withPseudoAndKeyColsInValue(isWindowed);\n-\n-    final ExpressionTypeManager expressionTypeManager =\n-        new ExpressionTypeManager(schema, metaStore);\n-\n-    for (final SelectExpression select : selectExpressions) {\n-      final SqlType type = expressionTypeManager.getExpressionSqlType(select.getExpression());\n-\n-      if (parentSchema.isKeyColumn(select.getAlias())\n-          || select.getAlias().equals(SystemColumns.WINDOWSTART_NAME)\n-          || select.getAlias().equals(SystemColumns.WINDOWEND_NAME)\n-      ) {\n-        schemaBuilder.keyColumn(select.getAlias(), type);\n-      } else {\n-        schemaBuilder.valueColumn(select.getAlias(), type);\n-      }\n-    }\n-    return schemaBuilder.build();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ1MTc3OQ==", "url": "https://github.com/confluentinc/ksql/pull/6684#discussion_r540451779", "bodyText": "any reason this is no longer final?", "author": "agavra", "createdAt": "2020-12-10T19:50:10Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/transform/select/SelectValueMapperFactory.java", "diffHunk": "@@ -32,26 +33,34 @@\n  * Factor class for {@link SelectValueMapper}.\n  */\n public final class SelectValueMapperFactory {\n-\n   private static final String EXP_TYPE = \"Select\";\n \n-  private final CodeGenRunner codeGenerator;\n+  private CodeGenRunner codeGenerator;", "originalCommit": "a66694a0518fb72d9eb26a900b4983be215b77f4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dd3233434482f73ca223c66e098236571dd29dab", "chunk": "diff --git a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/transform/select/SelectValueMapperFactory.java b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/transform/select/SelectValueMapperFactory.java\nindex 16b9961813..faa964c52c 100644\n--- a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/transform/select/SelectValueMapperFactory.java\n+++ b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/transform/select/SelectValueMapperFactory.java\n\n@@ -35,17 +35,13 @@ import java.util.stream.Collectors;\n public final class SelectValueMapperFactory {\n   private static final String EXP_TYPE = \"Select\";\n \n-  private CodeGenRunner codeGenerator;\n+  private final CodeGenRunner codeGenerator;\n \n   @VisibleForTesting\n   SelectValueMapperFactory(final CodeGenRunner codeGenerator) {\n     this.codeGenerator = requireNonNull(codeGenerator, \"codeGenerator\");\n   }\n \n-  @VisibleForTesting\n-  SelectValueMapperFactory() {\n-  }\n-\n   @VisibleForTesting\n   public interface SelectValueMapperFactorySupplier {\n     <K> SelectValueMapper<K> create(\n"}}, {"oid": "281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "url": "https://github.com/confluentinc/ksql/commit/281a5b8e13b8cf4d7cdc13f9cc4bf3952788d40c", "message": "compiling expression sin logical plan\n\nlogical refactoring\n\nfilter and project\n\nrefactoring\n\nmove project operator code into logical plan\n\nstill in progress, fixed some tests and made refactor smaller\n\nfixing", "committedDate": "2020-12-16T18:29:46Z", "type": "commit"}, {"oid": "b0c4652af706865cf7f51f905f61986260216b78", "url": "https://github.com/confluentinc/ksql/commit/b0c4652af706865cf7f51f905f61986260216b78", "message": "added tests for pull queries", "committedDate": "2020-12-16T18:29:46Z", "type": "commit"}, {"oid": "5832aa4b5f496d02c8bfe12f4b2a56528d0a73e6", "url": "https://github.com/confluentinc/ksql/commit/5832aa4b5f496d02c8bfe12f4b2a56528d0a73e6", "message": "rebase", "committedDate": "2020-12-16T18:29:46Z", "type": "commit"}, {"oid": "8bab50b37a003e2226915eb1e6a3255c89689bdd", "url": "https://github.com/confluentinc/ksql/commit/8bab50b37a003e2226915eb1e6a3255c89689bdd", "message": "remove comments", "committedDate": "2020-12-16T18:29:46Z", "type": "commit"}, {"oid": "9933eabb493594a555ba5024d0e4088afd765848", "url": "https://github.com/confluentinc/ksql/commit/9933eabb493594a555ba5024d0e4088afd765848", "message": "add separate logicl nodes for pull", "committedDate": "2020-12-16T18:29:47Z", "type": "commit"}, {"oid": "7838a4c6227856d394b2c5cc4b2204559a3952d0", "url": "https://github.com/confluentinc/ksql/commit/7838a4c6227856d394b2c5cc4b2204559a3952d0", "message": "fix comments", "committedDate": "2020-12-16T18:29:47Z", "type": "commit"}, {"oid": "94b2bf3606bc96df553f4eb8d5e0dd3d71e46473", "url": "https://github.com/confluentinc/ksql/commit/94b2bf3606bc96df553f4eb8d5e0dd3d71e46473", "message": "fix test", "committedDate": "2020-12-16T18:29:47Z", "type": "commit"}, {"oid": "9a201187586df35665aa622e0562c27d92b05f7a", "url": "https://github.com/confluentinc/ksql/commit/9a201187586df35665aa622e0562c27d92b05f7a", "message": "remove unnecessary code", "committedDate": "2020-12-16T18:29:48Z", "type": "commit"}, {"oid": "c4c6cf26d42251c95710f5d1cc9bda80c9643e83", "url": "https://github.com/confluentinc/ksql/commit/c4c6cf26d42251c95710f5d1cc9bda80c9643e83", "message": "Address alans comments", "committedDate": "2020-12-16T18:29:48Z", "type": "commit"}, {"oid": "dd3233434482f73ca223c66e098236571dd29dab", "url": "https://github.com/confluentinc/ksql/commit/dd3233434482f73ca223c66e098236571dd29dab", "message": "add back final", "committedDate": "2020-12-16T18:29:48Z", "type": "commit"}, {"oid": "dd3233434482f73ca223c66e098236571dd29dab", "url": "https://github.com/confluentinc/ksql/commit/dd3233434482f73ca223c66e098236571dd29dab", "message": "add back final", "committedDate": "2020-12-16T18:29:48Z", "type": "forcePushed"}, {"oid": "d4b9eae8307627e596d7e852fef5329672a355e6", "url": "https://github.com/confluentinc/ksql/commit/d4b9eae8307627e596d7e852fef5329672a355e6", "message": "remove unused field", "committedDate": "2020-12-16T22:55:52Z", "type": "commit"}]}