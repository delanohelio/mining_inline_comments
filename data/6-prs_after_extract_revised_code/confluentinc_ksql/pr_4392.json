{"pr_number": 4392, "pr_title": "feat: Adds lag reporting and API for use in lag aware routing as described in KLIP 12", "pr_createdAt": "2020-01-27T19:36:52Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4392", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNDU2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371914563", "bodyText": "I think I had the same comment on Vicky's PR, but I feel like we should avoid exposing the KafkaStreams object here as that's an \"implementation detail\" of the query metadata. If we want to expose specific parts of the metadata, we should do it through strongly typed methods (like the getAllMetadata method below)\nThis will also make this object much easier to mock and test.", "author": "agavra", "createdAt": "2020-01-28T16:31:14Z", "path": "ksql-engine/src/main/java/io/confluent/ksql/util/QueryMetadata.java", "diffHunk": "@@ -132,6 +132,10 @@ public Topology getTopology() {\n     return topology;\n   }\n \n+  public KafkaStreams getKafkaStreams() {\n+    return kafkaStreams;\n+  }", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUzODczNQ==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372538735", "bodyText": "I originally had this exactly as you're describing, (I returned the lag map from KafkaStreams), but I actually got a comment that this was too lag-centric and shouldn't be exposed on QueryMetadata...  lags are also implementation details of a sort.\nOn the whole, exposing just lag information is less leakage than exposing all KafkaStreams, so I'm going with your suggestion.", "author": "AlanConfluent", "createdAt": "2020-01-29T17:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNDU2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-engine/src/main/java/io/confluent/ksql/util/QueryMetadata.java b/ksql-engine/src/main/java/io/confluent/ksql/util/QueryMetadata.java\nindex 5002634d66..8d420d07bf 100644\n--- a/ksql-engine/src/main/java/io/confluent/ksql/util/QueryMetadata.java\n+++ b/ksql-engine/src/main/java/io/confluent/ksql/util/QueryMetadata.java\n\n@@ -132,10 +133,6 @@ public class QueryMetadata {\n     return topology;\n   }\n \n-  public KafkaStreams getKafkaStreams() {\n-    return kafkaStreams;\n-  }\n-\n   public Collection<StreamsMetadata> getAllMetadata() {\n     try {\n       return kafkaStreams.allMetadata();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxODUzMA==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371918530", "bodyText": "nit: I want to say that the right implementation is to leverage Map#replaceAll(BiFunction<K,V>) so that we avoid the pattern of iterating and updating keys in the map simultaneously (at least at an API level, I understand the keys aren't actually changing). Also would be nice to have a HostStatusEntity#copyWithStatus(boolean isAlive) to make this code a little crisper", "author": "agavra", "createdAt": "2020-01-28T16:37:24Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -237,19 +241,25 @@ private void processHeartbeats(final long windowStart, final long windowEnd) {\n       if (receivedHeartbeats.isEmpty()) {\n         hostsStatus.forEach((host, status) -> {\n           if (!host.equals(localHostString)) {\n-            status.setHostAlive(false);\n+            hostsStatus.put(host, new HostStatusEntity(status.getHostInfoEntity(),", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk5MzQzNQ==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371993435", "bodyText": "Given that we are updating only a boolean, which is an atomic operation, I feel like this is an overkill. Moreover, I am changing the map to be an AtomicReference of an ImmutableMap with copyOnWrite to avoid the overhead of copyOnRead since we expect more reads than writes. With the new change, there is no reason to worry about concurrency here, no?", "author": "vpapavas", "createdAt": "2020-01-28T18:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxODUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU3MjM3OQ==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372572379", "bodyText": "Vicky and I chatted about this a bit offline.  I agree that replaceAll is the way to go if we were keeping a concurrent map.  I changed it to that for now.  I think Vicky intends to make it an ImmutableMap, so that removes any iterating while updating issues.  We also chatted about the atomic operation aspect in her review.\nI'll make the HostStatusEntity#copyWithStatus(boolean isAlive) change you recommend.", "author": "AlanConfluent", "createdAt": "2020-01-29T19:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxODUzMA=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\nindex 18514a3eca..4255bfb123 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n\n@@ -241,25 +237,19 @@ public final class HeartbeatAgent {\n       if (receivedHeartbeats.isEmpty()) {\n         hostsStatus.forEach((host, status) -> {\n           if (!host.equals(localHostString)) {\n-            hostsStatus.put(host, new HostStatusEntity(status.getHostInfoEntity(),\n-                                                       false,\n-                                                       status.getLastStatusUpdateMs()));\n+            status.setHostAlive(false);\n           }\n         });\n       }\n \n-      for (Entry<String, HostStatusEntity> entry: hostsStatus.entrySet()) {\n-        final String host = entry.getKey();\n-        final HostStatusEntity status = entry.getValue();\n+      for (String host: hostsStatus.keySet()) {\n         if (host.equals(localHostString)) {\n           continue;\n         }\n         final TreeMap<Long, HeartbeatInfo> heartbeats = receivedHeartbeats.get(host);\n         //For previously discovered hosts, if they have not received any heartbeats, mark them dead\n         if (heartbeats == null || heartbeats.isEmpty()) {\n-          hostsStatus.put(host, new HostStatusEntity(status.getHostInfoEntity(),\n-                                                     false,\n-                                                     status.getLastStatusUpdateMs()));\n+          hostsStatus.get(host).setHostAlive(false);\n         } else {\n           final TreeMap<Long, HeartbeatInfo> copy;\n           synchronized (heartbeats) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkyMDU4Mw==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371920583", "bodyText": "same comment as above (and one more time below), but to make life easier we could just use computeIfPresent to make it clear that the key isn't changing", "author": "agavra", "createdAt": "2020-01-28T16:40:42Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -237,19 +241,25 @@ private void processHeartbeats(final long windowStart, final long windowEnd) {\n       if (receivedHeartbeats.isEmpty()) {\n         hostsStatus.forEach((host, status) -> {\n           if (!host.equals(localHostString)) {\n-            status.setHostAlive(false);\n+            hostsStatus.put(host, new HostStatusEntity(status.getHostInfoEntity(),\n+                                                       false,\n+                                                       status.getLastStatusUpdateMs()));\n           }\n         });\n       }\n \n-      for (String host: hostsStatus.keySet()) {\n+      for (Entry<String, HostStatusEntity> entry: hostsStatus.entrySet()) {\n+        final String host = entry.getKey();\n+        final HostStatusEntity status = entry.getValue();\n         if (host.equals(localHostString)) {\n           continue;\n         }\n         final TreeMap<Long, HeartbeatInfo> heartbeats = receivedHeartbeats.get(host);\n         //For previously discovered hosts, if they have not received any heartbeats, mark them dead\n         if (heartbeats == null || heartbeats.isEmpty()) {\n-          hostsStatus.get(host).setHostAlive(false);\n+          hostsStatus.put(host, new HostStatusEntity(status.getHostInfoEntity(),", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU4MDEzOA==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372580138", "bodyText": "Changed to computeIfPresent.", "author": "AlanConfluent", "createdAt": "2020-01-29T19:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkyMDU4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\nindex 18514a3eca..4255bfb123 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java\n\n@@ -241,25 +237,19 @@ public final class HeartbeatAgent {\n       if (receivedHeartbeats.isEmpty()) {\n         hostsStatus.forEach((host, status) -> {\n           if (!host.equals(localHostString)) {\n-            hostsStatus.put(host, new HostStatusEntity(status.getHostInfoEntity(),\n-                                                       false,\n-                                                       status.getLastStatusUpdateMs()));\n+            status.setHostAlive(false);\n           }\n         });\n       }\n \n-      for (Entry<String, HostStatusEntity> entry: hostsStatus.entrySet()) {\n-        final String host = entry.getKey();\n-        final HostStatusEntity status = entry.getValue();\n+      for (String host: hostsStatus.keySet()) {\n         if (host.equals(localHostString)) {\n           continue;\n         }\n         final TreeMap<Long, HeartbeatInfo> heartbeats = receivedHeartbeats.get(host);\n         //For previously discovered hosts, if they have not received any heartbeats, mark them dead\n         if (heartbeats == null || heartbeats.isEmpty()) {\n-          hostsStatus.put(host, new HostStatusEntity(status.getHostInfoEntity(),\n-                                                     false,\n-                                                     status.getLastStatusUpdateMs()));\n+          hostsStatus.get(host).setHostAlive(false);\n         } else {\n           final TreeMap<Long, HeartbeatInfo> copy;\n           synchronized (heartbeats) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzMTYzMg==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371931632", "bodyText": "nit: if we just have one service, I don't think we need to add a service manager - but if you are thinking of adding more in the future we can leave it as is", "author": "agavra", "createdAt": "2020-01-28T16:58:36Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.ServiceManager;\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.HostStatusEntity;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.LagReportingRequest;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.rest.server.HeartbeatAgent.HostStatusListener;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.PersistentQueryMetadata;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.Clock;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.streams.LagInfo;\n+import org.apache.kafka.streams.errors.StreamsException;\n+import org.apache.kafka.streams.state.HostInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Agent responsible for sending and receiving lag information across the cluster and providing\n+ * aggregate stats, usable during query time.\n+ */\n+public final class LagReportingAgent implements HostStatusListener {\n+  private static final int SERVICE_TIMEOUT_SEC = 2;\n+  private static final int NUM_THREADS_EXECUTOR = 1;\n+  private static final int SEND_LAG_DELAY_MS = 100;\n+  private static final HostLagInfo EMPTY_HOST_LAG_INFO = new HostLagInfo(Collections.emptyMap(), 0);\n+  private static final Logger LOG = LoggerFactory.getLogger(LagReportingAgent.class);\n+\n+  private final KsqlEngine engine;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final ServiceContext serviceContext;\n+  private final LagReportingConfig config;\n+  private final ServiceManager serviceManager;\n+  private final Clock clock;\n+\n+  private final Map<HostInfo, HostLagInfo> receivedLagInfo;\n+  private final AtomicReference<Set<HostInfo>> aliveHostsRef;\n+\n+  private URL localURL;\n+\n+  /**\n+   * Builder for creating an instance of LagReportingAgent.\n+   * @return\n+   */\n+  public static LagReportingAgent.Builder builder() {\n+    return new LagReportingAgent.Builder();\n+  }\n+\n+  /**\n+   * Lag related agent for both sending out lag for localhost as well as receiving lag reports for\n+   * other nodes in the cluster.\n+   * @param engine The ksql engine to access streams for inferring the cluster and getting local\n+   *               lags metrics\n+   * @param serviceContext Service context for issuing ksql requests\n+   * @param config The LagReportingConfig for configuring this agent\n+   * @param clock Clock for reporting lag\n+   */\n+  private LagReportingAgent(\n+      final KsqlEngine engine,\n+      final ScheduledExecutorService scheduledExecutorService,\n+      final ServiceContext serviceContext,\n+      final LagReportingConfig config,\n+      final Clock clock) {\n+    this.engine = requireNonNull(engine, \"engine\");\n+    this.scheduledExecutorService = scheduledExecutorService;\n+    this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n+    this.config = requireNonNull(config, \"configuration parameters\");\n+    this.clock = clock;\n+    this.serviceManager = new ServiceManager(Arrays.asList(new SendLagService()));", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5MjY0Mw==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372592643", "bodyText": "It's possible we may combine some of these agents or add additional background processes.  I'd like to keep it for now.", "author": "AlanConfluent", "createdAt": "2020-01-29T19:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzMTYzMg=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\nindex cffb401633..6119119457 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020 Confluent Inc.\n+ * Copyright 2019 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"; you may not use\n  * this file except in compliance with the License. You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzNDIyNg==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371934226", "bodyText": "I feel like we should rename LagReportingRequest to LagReportingMessage or LagReportingEvent. In my mind, a LagReportingRequest would get a response that contains the lag info. Please correct my if I'm not understanding some terminology (or what's going on \ud83d\ude04)", "author": "agavra", "createdAt": "2020-01-28T17:03:03Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.ServiceManager;\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.HostStatusEntity;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.LagReportingRequest;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.rest.server.HeartbeatAgent.HostStatusListener;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.PersistentQueryMetadata;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.Clock;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.streams.LagInfo;\n+import org.apache.kafka.streams.errors.StreamsException;\n+import org.apache.kafka.streams.state.HostInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Agent responsible for sending and receiving lag information across the cluster and providing\n+ * aggregate stats, usable during query time.\n+ */\n+public final class LagReportingAgent implements HostStatusListener {\n+  private static final int SERVICE_TIMEOUT_SEC = 2;\n+  private static final int NUM_THREADS_EXECUTOR = 1;\n+  private static final int SEND_LAG_DELAY_MS = 100;\n+  private static final HostLagInfo EMPTY_HOST_LAG_INFO = new HostLagInfo(Collections.emptyMap(), 0);\n+  private static final Logger LOG = LoggerFactory.getLogger(LagReportingAgent.class);\n+\n+  private final KsqlEngine engine;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final ServiceContext serviceContext;\n+  private final LagReportingConfig config;\n+  private final ServiceManager serviceManager;\n+  private final Clock clock;\n+\n+  private final Map<HostInfo, HostLagInfo> receivedLagInfo;\n+  private final AtomicReference<Set<HostInfo>> aliveHostsRef;\n+\n+  private URL localURL;\n+\n+  /**\n+   * Builder for creating an instance of LagReportingAgent.\n+   * @return\n+   */\n+  public static LagReportingAgent.Builder builder() {\n+    return new LagReportingAgent.Builder();\n+  }\n+\n+  /**\n+   * Lag related agent for both sending out lag for localhost as well as receiving lag reports for\n+   * other nodes in the cluster.\n+   * @param engine The ksql engine to access streams for inferring the cluster and getting local\n+   *               lags metrics\n+   * @param serviceContext Service context for issuing ksql requests\n+   * @param config The LagReportingConfig for configuring this agent\n+   * @param clock Clock for reporting lag\n+   */\n+  private LagReportingAgent(\n+      final KsqlEngine engine,\n+      final ScheduledExecutorService scheduledExecutorService,\n+      final ServiceContext serviceContext,\n+      final LagReportingConfig config,\n+      final Clock clock) {\n+    this.engine = requireNonNull(engine, \"engine\");\n+    this.scheduledExecutorService = scheduledExecutorService;\n+    this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n+    this.config = requireNonNull(config, \"configuration parameters\");\n+    this.clock = clock;\n+    this.serviceManager = new ServiceManager(Arrays.asList(new SendLagService()));\n+    this.receivedLagInfo = new ConcurrentHashMap<>();\n+    this.aliveHostsRef = new AtomicReference<>(Collections.emptySet());\n+  }\n+\n+  void setLocalAddress(final String applicationServer) {\n+    try {\n+      this.localURL = new URL(applicationServer);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Failed to convert remote host info to URL.\"\n+          + \" remoteInfo: \" + applicationServer);\n+    }\n+  }\n+\n+  void startAgent() {\n+    try {\n+      serviceManager.startAsync().awaitHealthy(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to start heartbeat services with exception \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  void stopAgent() {\n+    try {\n+      serviceManager.stopAsync().awaitStopped(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to stop heartbeat services with exception \" + e.getMessage(), e);\n+    } finally {\n+      scheduledExecutorService.shutdownNow();\n+    }\n+  }\n+\n+  /**\n+   * Stores the host lag received from a remote Ksql server.\n+   * @param lagReportingRequest The host lag information sent directly from the other node.\n+   */\n+  public void receiveHostLag(final LagReportingRequest lagReportingRequest) {", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU4NDMxOQ==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372584319", "bodyText": "Historically, for most projects I've worked on, I've adopted a pattern of having any incoming message suffixed with \"Request\" and any outgoing replies suffixed with \"Response\".  That's where I was coming from there.\nThat said, I understand the confusion you're describing, if you interpret Request to be the intent of the object rather than a synonym for system request/reply. I don't feel strongly about this, and there doesn't seem to be an existing pattern.  I'll go with LagReportingMessage.", "author": "AlanConfluent", "createdAt": "2020-01-29T19:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzNDIyNg=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\nindex cffb401633..6119119457 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020 Confluent Inc.\n+ * Copyright 2019 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"; you may not use\n  * this file except in compliance with the License. You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0MDMxMQ==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371940311", "bodyText": "does this loop just turn the lagReportingRequest.getStoreToPartitionToLagMap into an immutable map? if so, could we just:\nlagReportingRequest\n    .getStoreToPartitionToLagMap\n    .forEach((id, partitions) -> hostMapBuilder.put(id, ImmutableMap.copyOf(partitions));", "author": "agavra", "createdAt": "2020-01-28T17:13:26Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.ServiceManager;\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.HostStatusEntity;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.LagReportingRequest;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.rest.server.HeartbeatAgent.HostStatusListener;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.PersistentQueryMetadata;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.Clock;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.streams.LagInfo;\n+import org.apache.kafka.streams.errors.StreamsException;\n+import org.apache.kafka.streams.state.HostInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Agent responsible for sending and receiving lag information across the cluster and providing\n+ * aggregate stats, usable during query time.\n+ */\n+public final class LagReportingAgent implements HostStatusListener {\n+  private static final int SERVICE_TIMEOUT_SEC = 2;\n+  private static final int NUM_THREADS_EXECUTOR = 1;\n+  private static final int SEND_LAG_DELAY_MS = 100;\n+  private static final HostLagInfo EMPTY_HOST_LAG_INFO = new HostLagInfo(Collections.emptyMap(), 0);\n+  private static final Logger LOG = LoggerFactory.getLogger(LagReportingAgent.class);\n+\n+  private final KsqlEngine engine;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final ServiceContext serviceContext;\n+  private final LagReportingConfig config;\n+  private final ServiceManager serviceManager;\n+  private final Clock clock;\n+\n+  private final Map<HostInfo, HostLagInfo> receivedLagInfo;\n+  private final AtomicReference<Set<HostInfo>> aliveHostsRef;\n+\n+  private URL localURL;\n+\n+  /**\n+   * Builder for creating an instance of LagReportingAgent.\n+   * @return\n+   */\n+  public static LagReportingAgent.Builder builder() {\n+    return new LagReportingAgent.Builder();\n+  }\n+\n+  /**\n+   * Lag related agent for both sending out lag for localhost as well as receiving lag reports for\n+   * other nodes in the cluster.\n+   * @param engine The ksql engine to access streams for inferring the cluster and getting local\n+   *               lags metrics\n+   * @param serviceContext Service context for issuing ksql requests\n+   * @param config The LagReportingConfig for configuring this agent\n+   * @param clock Clock for reporting lag\n+   */\n+  private LagReportingAgent(\n+      final KsqlEngine engine,\n+      final ScheduledExecutorService scheduledExecutorService,\n+      final ServiceContext serviceContext,\n+      final LagReportingConfig config,\n+      final Clock clock) {\n+    this.engine = requireNonNull(engine, \"engine\");\n+    this.scheduledExecutorService = scheduledExecutorService;\n+    this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n+    this.config = requireNonNull(config, \"configuration parameters\");\n+    this.clock = clock;\n+    this.serviceManager = new ServiceManager(Arrays.asList(new SendLagService()));\n+    this.receivedLagInfo = new ConcurrentHashMap<>();\n+    this.aliveHostsRef = new AtomicReference<>(Collections.emptySet());\n+  }\n+\n+  void setLocalAddress(final String applicationServer) {\n+    try {\n+      this.localURL = new URL(applicationServer);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Failed to convert remote host info to URL.\"\n+          + \" remoteInfo: \" + applicationServer);\n+    }\n+  }\n+\n+  void startAgent() {\n+    try {\n+      serviceManager.startAsync().awaitHealthy(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to start heartbeat services with exception \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  void stopAgent() {\n+    try {\n+      serviceManager.stopAsync().awaitStopped(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to stop heartbeat services with exception \" + e.getMessage(), e);\n+    } finally {\n+      scheduledExecutorService.shutdownNow();\n+    }\n+  }\n+\n+  /**\n+   * Stores the host lag received from a remote Ksql server.\n+   * @param lagReportingRequest The host lag information sent directly from the other node.\n+   */\n+  public void receiveHostLag(final LagReportingRequest lagReportingRequest) {\n+    final long updateTimeMs = lagReportingRequest.getLastLagUpdateMs();\n+    final HostInfoEntity hostInfoEntity = lagReportingRequest.getHostInfo();\n+    final HostInfo hostInfo = new HostInfo(hostInfoEntity.getHost(), hostInfoEntity.getPort());\n+\n+    ImmutableMap.Builder<QueryStateStoreId, Map<Integer, LagInfoEntity>> hostMapBuilder\n+        = ImmutableMap.builder();\n+    for (Map.Entry<QueryStateStoreId, Map<Integer, LagInfoEntity>> storeEntry", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU4ODgxMA==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372588810", "bodyText": "Yep, it does.  Changed.", "author": "AlanConfluent", "createdAt": "2020-01-29T19:35:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0MDMxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\nindex cffb401633..6119119457 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020 Confluent Inc.\n+ * Copyright 2019 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"; you may not use\n  * this file except in compliance with the License. You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0NjkxMg==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371946912", "bodyText": "thoughts on adding some logging here to indicate current lags? might be helpful for debugging", "author": "agavra", "createdAt": "2020-01-28T17:25:21Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.ServiceManager;\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.HostStatusEntity;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.LagReportingRequest;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.rest.server.HeartbeatAgent.HostStatusListener;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.PersistentQueryMetadata;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.Clock;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.streams.LagInfo;\n+import org.apache.kafka.streams.errors.StreamsException;\n+import org.apache.kafka.streams.state.HostInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Agent responsible for sending and receiving lag information across the cluster and providing\n+ * aggregate stats, usable during query time.\n+ */\n+public final class LagReportingAgent implements HostStatusListener {\n+  private static final int SERVICE_TIMEOUT_SEC = 2;\n+  private static final int NUM_THREADS_EXECUTOR = 1;\n+  private static final int SEND_LAG_DELAY_MS = 100;\n+  private static final HostLagInfo EMPTY_HOST_LAG_INFO = new HostLagInfo(Collections.emptyMap(), 0);\n+  private static final Logger LOG = LoggerFactory.getLogger(LagReportingAgent.class);\n+\n+  private final KsqlEngine engine;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final ServiceContext serviceContext;\n+  private final LagReportingConfig config;\n+  private final ServiceManager serviceManager;\n+  private final Clock clock;\n+\n+  private final Map<HostInfo, HostLagInfo> receivedLagInfo;\n+  private final AtomicReference<Set<HostInfo>> aliveHostsRef;\n+\n+  private URL localURL;\n+\n+  /**\n+   * Builder for creating an instance of LagReportingAgent.\n+   * @return\n+   */\n+  public static LagReportingAgent.Builder builder() {\n+    return new LagReportingAgent.Builder();\n+  }\n+\n+  /**\n+   * Lag related agent for both sending out lag for localhost as well as receiving lag reports for\n+   * other nodes in the cluster.\n+   * @param engine The ksql engine to access streams for inferring the cluster and getting local\n+   *               lags metrics\n+   * @param serviceContext Service context for issuing ksql requests\n+   * @param config The LagReportingConfig for configuring this agent\n+   * @param clock Clock for reporting lag\n+   */\n+  private LagReportingAgent(\n+      final KsqlEngine engine,\n+      final ScheduledExecutorService scheduledExecutorService,\n+      final ServiceContext serviceContext,\n+      final LagReportingConfig config,\n+      final Clock clock) {\n+    this.engine = requireNonNull(engine, \"engine\");\n+    this.scheduledExecutorService = scheduledExecutorService;\n+    this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n+    this.config = requireNonNull(config, \"configuration parameters\");\n+    this.clock = clock;\n+    this.serviceManager = new ServiceManager(Arrays.asList(new SendLagService()));\n+    this.receivedLagInfo = new ConcurrentHashMap<>();\n+    this.aliveHostsRef = new AtomicReference<>(Collections.emptySet());\n+  }\n+\n+  void setLocalAddress(final String applicationServer) {\n+    try {\n+      this.localURL = new URL(applicationServer);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Failed to convert remote host info to URL.\"\n+          + \" remoteInfo: \" + applicationServer);\n+    }\n+  }\n+\n+  void startAgent() {\n+    try {\n+      serviceManager.startAsync().awaitHealthy(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to start heartbeat services with exception \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  void stopAgent() {\n+    try {\n+      serviceManager.stopAsync().awaitStopped(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to stop heartbeat services with exception \" + e.getMessage(), e);\n+    } finally {\n+      scheduledExecutorService.shutdownNow();\n+    }\n+  }\n+\n+  /**\n+   * Stores the host lag received from a remote Ksql server.\n+   * @param lagReportingRequest The host lag information sent directly from the other node.\n+   */\n+  public void receiveHostLag(final LagReportingRequest lagReportingRequest) {\n+    final long updateTimeMs = lagReportingRequest.getLastLagUpdateMs();\n+    final HostInfoEntity hostInfoEntity = lagReportingRequest.getHostInfo();\n+    final HostInfo hostInfo = new HostInfo(hostInfoEntity.getHost(), hostInfoEntity.getPort());\n+\n+    ImmutableMap.Builder<QueryStateStoreId, Map<Integer, LagInfoEntity>> hostMapBuilder\n+        = ImmutableMap.builder();\n+    for (Map.Entry<QueryStateStoreId, Map<Integer, LagInfoEntity>> storeEntry\n+        : lagReportingRequest.getStoreToPartitionToLagMap().entrySet()) {\n+      final QueryStateStoreId queryStateStoreId = storeEntry.getKey();\n+      final Map<Integer, LagInfoEntity> partitionMap = storeEntry.getValue();\n+\n+      ImmutableMap.Builder<Integer, LagInfoEntity> partitionsBuilder = ImmutableMap.builder();\n+\n+      // Go through each new partition and add lag info\n+      for (final Map.Entry<Integer, LagInfoEntity> partitionEntry : partitionMap.entrySet()) {\n+        final Integer partition = partitionEntry.getKey();\n+        final LagInfoEntity lagInfo = partitionEntry.getValue();\n+        partitionsBuilder.put(partition, lagInfo);\n+      }\n+\n+      hostMapBuilder.put(queryStateStoreId, partitionsBuilder.build());\n+    }\n+\n+    Map<QueryStateStoreId, Map<Integer, LagInfoEntity>> hostMap = hostMapBuilder.build();", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5MTg4Nw==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372591887", "bodyText": "Done.  Added debug logging since this will happen often.", "author": "AlanConfluent", "createdAt": "2020-01-29T19:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0NjkxMg=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\nindex cffb401633..6119119457 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020 Confluent Inc.\n+ * Copyright 2019 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"; you may not use\n  * this file except in compliance with the License. You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1MDY5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371950696", "bodyText": "nit: seems like a common pattern. maybe we should have a HostStatuSentity#toHostInfo method", "author": "agavra", "createdAt": "2020-01-28T17:32:26Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.ServiceManager;\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.HostStatusEntity;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.LagReportingRequest;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.rest.server.HeartbeatAgent.HostStatusListener;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.PersistentQueryMetadata;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.Clock;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.streams.LagInfo;\n+import org.apache.kafka.streams.errors.StreamsException;\n+import org.apache.kafka.streams.state.HostInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Agent responsible for sending and receiving lag information across the cluster and providing\n+ * aggregate stats, usable during query time.\n+ */\n+public final class LagReportingAgent implements HostStatusListener {\n+  private static final int SERVICE_TIMEOUT_SEC = 2;\n+  private static final int NUM_THREADS_EXECUTOR = 1;\n+  private static final int SEND_LAG_DELAY_MS = 100;\n+  private static final HostLagInfo EMPTY_HOST_LAG_INFO = new HostLagInfo(Collections.emptyMap(), 0);\n+  private static final Logger LOG = LoggerFactory.getLogger(LagReportingAgent.class);\n+\n+  private final KsqlEngine engine;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final ServiceContext serviceContext;\n+  private final LagReportingConfig config;\n+  private final ServiceManager serviceManager;\n+  private final Clock clock;\n+\n+  private final Map<HostInfo, HostLagInfo> receivedLagInfo;\n+  private final AtomicReference<Set<HostInfo>> aliveHostsRef;\n+\n+  private URL localURL;\n+\n+  /**\n+   * Builder for creating an instance of LagReportingAgent.\n+   * @return\n+   */\n+  public static LagReportingAgent.Builder builder() {\n+    return new LagReportingAgent.Builder();\n+  }\n+\n+  /**\n+   * Lag related agent for both sending out lag for localhost as well as receiving lag reports for\n+   * other nodes in the cluster.\n+   * @param engine The ksql engine to access streams for inferring the cluster and getting local\n+   *               lags metrics\n+   * @param serviceContext Service context for issuing ksql requests\n+   * @param config The LagReportingConfig for configuring this agent\n+   * @param clock Clock for reporting lag\n+   */\n+  private LagReportingAgent(\n+      final KsqlEngine engine,\n+      final ScheduledExecutorService scheduledExecutorService,\n+      final ServiceContext serviceContext,\n+      final LagReportingConfig config,\n+      final Clock clock) {\n+    this.engine = requireNonNull(engine, \"engine\");\n+    this.scheduledExecutorService = scheduledExecutorService;\n+    this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n+    this.config = requireNonNull(config, \"configuration parameters\");\n+    this.clock = clock;\n+    this.serviceManager = new ServiceManager(Arrays.asList(new SendLagService()));\n+    this.receivedLagInfo = new ConcurrentHashMap<>();\n+    this.aliveHostsRef = new AtomicReference<>(Collections.emptySet());\n+  }\n+\n+  void setLocalAddress(final String applicationServer) {\n+    try {\n+      this.localURL = new URL(applicationServer);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Failed to convert remote host info to URL.\"\n+          + \" remoteInfo: \" + applicationServer);\n+    }\n+  }\n+\n+  void startAgent() {\n+    try {\n+      serviceManager.startAsync().awaitHealthy(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to start heartbeat services with exception \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  void stopAgent() {\n+    try {\n+      serviceManager.stopAsync().awaitStopped(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to stop heartbeat services with exception \" + e.getMessage(), e);\n+    } finally {\n+      scheduledExecutorService.shutdownNow();\n+    }\n+  }\n+\n+  /**\n+   * Stores the host lag received from a remote Ksql server.\n+   * @param lagReportingRequest The host lag information sent directly from the other node.\n+   */\n+  public void receiveHostLag(final LagReportingRequest lagReportingRequest) {\n+    final long updateTimeMs = lagReportingRequest.getLastLagUpdateMs();\n+    final HostInfoEntity hostInfoEntity = lagReportingRequest.getHostInfo();\n+    final HostInfo hostInfo = new HostInfo(hostInfoEntity.getHost(), hostInfoEntity.getPort());\n+\n+    ImmutableMap.Builder<QueryStateStoreId, Map<Integer, LagInfoEntity>> hostMapBuilder\n+        = ImmutableMap.builder();\n+    for (Map.Entry<QueryStateStoreId, Map<Integer, LagInfoEntity>> storeEntry\n+        : lagReportingRequest.getStoreToPartitionToLagMap().entrySet()) {\n+      final QueryStateStoreId queryStateStoreId = storeEntry.getKey();\n+      final Map<Integer, LagInfoEntity> partitionMap = storeEntry.getValue();\n+\n+      ImmutableMap.Builder<Integer, LagInfoEntity> partitionsBuilder = ImmutableMap.builder();\n+\n+      // Go through each new partition and add lag info\n+      for (final Map.Entry<Integer, LagInfoEntity> partitionEntry : partitionMap.entrySet()) {\n+        final Integer partition = partitionEntry.getKey();\n+        final LagInfoEntity lagInfo = partitionEntry.getValue();\n+        partitionsBuilder.put(partition, lagInfo);\n+      }\n+\n+      hostMapBuilder.put(queryStateStoreId, partitionsBuilder.build());\n+    }\n+\n+    Map<QueryStateStoreId, Map<Integer, LagInfoEntity>> hostMap = hostMapBuilder.build();\n+    HostLagInfo hostLagInfo = new HostLagInfo(hostMap, updateTimeMs);\n+    receivedLagInfo.compute(hostInfo, (hi, previousHostLagInfo) ->\n+        previousHostLagInfo != null && previousHostLagInfo.getUpdateTimeMs() > updateTimeMs ?\n+            previousHostLagInfo : hostLagInfo);\n+  }\n+\n+  /**\n+   * Returns lag information for all of the \"alive\" hosts for a given state store and partition.\n+   * @param queryStateStoreId The lag info key\n+   * @param partition The partition of that state\n+   * @return A map which is keyed by host and contains lag information\n+   */\n+  public Map<HostInfo, LagInfoEntity> getHostsPartitionLagInfo(\n+      final Set<HostInfo> hosts, final QueryStateStoreId queryStateStoreId, final int partition) {\n+    ImmutableMap.Builder<HostInfo, LagInfoEntity> builder = ImmutableMap.builder();\n+    Set<HostInfo> aliveHosts = aliveHostsRef.get();\n+    for (HostInfo host : hosts) {\n+      LagInfoEntity lagInfo = receivedLagInfo.getOrDefault(host, EMPTY_HOST_LAG_INFO).getLagInfo()\n+          .getOrDefault(queryStateStoreId, Collections.emptyMap())\n+          .getOrDefault(partition, null);\n+      if (aliveHosts.contains(host) && lagInfo != null) {\n+        builder.put(host, lagInfo);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Returns a map of storeName -> partition -> LagInfoEntity.  Meant for being exposed in testing\n+   * and debug resources.\n+   */\n+  public Map<HostInfoEntity, Map<QueryStateStoreId, Map<Integer, LagInfoEntity>>> listAllLags() {\n+    ImmutableMap.Builder<HostInfoEntity, Map<QueryStateStoreId, Map<Integer, LagInfoEntity>>>\n+        builder = ImmutableMap.builder();\n+    for (Entry<HostInfo, HostLagInfo> e : receivedLagInfo.entrySet()) {\n+      final HostInfo hostInfo = e.getKey();\n+      builder.put(new HostInfoEntity(hostInfo.host(), hostInfo.port()),\n+          e.getValue().getLagInfo());\n+    }\n+    return builder.build();\n+  }\n+\n+  @Override\n+  public void onHostStatusUpdated(final Map<String, HostStatusEntity> hostsStatusMap) {\n+    aliveHostsRef.set(hostsStatusMap.values().stream()\n+        .filter(HostStatusEntity::getHostAlive)\n+        .map(HostStatusEntity::getHostInfoEntity)\n+        .map(hostInfoEntity -> new HostInfo(hostInfoEntity.getHost(), hostInfoEntity.getPort()))", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwMzMyOQ==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372603329", "bodyText": "Sure, added toHostInfo.", "author": "AlanConfluent", "createdAt": "2020-01-29T20:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1MDY5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\nindex cffb401633..6119119457 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020 Confluent Inc.\n+ * Copyright 2019 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"; you may not use\n  * this file except in compliance with the License. You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1MTk0MA==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371951940", "bodyText": "a fun simplification:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (HostInfo host : hosts) {\n          \n          \n            \n                for (HostInfo host : Sets.intersection(hosts, aliveHosts)) {", "author": "agavra", "createdAt": "2020-01-28T17:34:45Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.ServiceManager;\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.HostStatusEntity;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.LagReportingRequest;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.rest.server.HeartbeatAgent.HostStatusListener;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.PersistentQueryMetadata;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.Clock;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.streams.LagInfo;\n+import org.apache.kafka.streams.errors.StreamsException;\n+import org.apache.kafka.streams.state.HostInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Agent responsible for sending and receiving lag information across the cluster and providing\n+ * aggregate stats, usable during query time.\n+ */\n+public final class LagReportingAgent implements HostStatusListener {\n+  private static final int SERVICE_TIMEOUT_SEC = 2;\n+  private static final int NUM_THREADS_EXECUTOR = 1;\n+  private static final int SEND_LAG_DELAY_MS = 100;\n+  private static final HostLagInfo EMPTY_HOST_LAG_INFO = new HostLagInfo(Collections.emptyMap(), 0);\n+  private static final Logger LOG = LoggerFactory.getLogger(LagReportingAgent.class);\n+\n+  private final KsqlEngine engine;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final ServiceContext serviceContext;\n+  private final LagReportingConfig config;\n+  private final ServiceManager serviceManager;\n+  private final Clock clock;\n+\n+  private final Map<HostInfo, HostLagInfo> receivedLagInfo;\n+  private final AtomicReference<Set<HostInfo>> aliveHostsRef;\n+\n+  private URL localURL;\n+\n+  /**\n+   * Builder for creating an instance of LagReportingAgent.\n+   * @return\n+   */\n+  public static LagReportingAgent.Builder builder() {\n+    return new LagReportingAgent.Builder();\n+  }\n+\n+  /**\n+   * Lag related agent for both sending out lag for localhost as well as receiving lag reports for\n+   * other nodes in the cluster.\n+   * @param engine The ksql engine to access streams for inferring the cluster and getting local\n+   *               lags metrics\n+   * @param serviceContext Service context for issuing ksql requests\n+   * @param config The LagReportingConfig for configuring this agent\n+   * @param clock Clock for reporting lag\n+   */\n+  private LagReportingAgent(\n+      final KsqlEngine engine,\n+      final ScheduledExecutorService scheduledExecutorService,\n+      final ServiceContext serviceContext,\n+      final LagReportingConfig config,\n+      final Clock clock) {\n+    this.engine = requireNonNull(engine, \"engine\");\n+    this.scheduledExecutorService = scheduledExecutorService;\n+    this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n+    this.config = requireNonNull(config, \"configuration parameters\");\n+    this.clock = clock;\n+    this.serviceManager = new ServiceManager(Arrays.asList(new SendLagService()));\n+    this.receivedLagInfo = new ConcurrentHashMap<>();\n+    this.aliveHostsRef = new AtomicReference<>(Collections.emptySet());\n+  }\n+\n+  void setLocalAddress(final String applicationServer) {\n+    try {\n+      this.localURL = new URL(applicationServer);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Failed to convert remote host info to URL.\"\n+          + \" remoteInfo: \" + applicationServer);\n+    }\n+  }\n+\n+  void startAgent() {\n+    try {\n+      serviceManager.startAsync().awaitHealthy(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to start heartbeat services with exception \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  void stopAgent() {\n+    try {\n+      serviceManager.stopAsync().awaitStopped(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to stop heartbeat services with exception \" + e.getMessage(), e);\n+    } finally {\n+      scheduledExecutorService.shutdownNow();\n+    }\n+  }\n+\n+  /**\n+   * Stores the host lag received from a remote Ksql server.\n+   * @param lagReportingRequest The host lag information sent directly from the other node.\n+   */\n+  public void receiveHostLag(final LagReportingRequest lagReportingRequest) {\n+    final long updateTimeMs = lagReportingRequest.getLastLagUpdateMs();\n+    final HostInfoEntity hostInfoEntity = lagReportingRequest.getHostInfo();\n+    final HostInfo hostInfo = new HostInfo(hostInfoEntity.getHost(), hostInfoEntity.getPort());\n+\n+    ImmutableMap.Builder<QueryStateStoreId, Map<Integer, LagInfoEntity>> hostMapBuilder\n+        = ImmutableMap.builder();\n+    for (Map.Entry<QueryStateStoreId, Map<Integer, LagInfoEntity>> storeEntry\n+        : lagReportingRequest.getStoreToPartitionToLagMap().entrySet()) {\n+      final QueryStateStoreId queryStateStoreId = storeEntry.getKey();\n+      final Map<Integer, LagInfoEntity> partitionMap = storeEntry.getValue();\n+\n+      ImmutableMap.Builder<Integer, LagInfoEntity> partitionsBuilder = ImmutableMap.builder();\n+\n+      // Go through each new partition and add lag info\n+      for (final Map.Entry<Integer, LagInfoEntity> partitionEntry : partitionMap.entrySet()) {\n+        final Integer partition = partitionEntry.getKey();\n+        final LagInfoEntity lagInfo = partitionEntry.getValue();\n+        partitionsBuilder.put(partition, lagInfo);\n+      }\n+\n+      hostMapBuilder.put(queryStateStoreId, partitionsBuilder.build());\n+    }\n+\n+    Map<QueryStateStoreId, Map<Integer, LagInfoEntity>> hostMap = hostMapBuilder.build();\n+    HostLagInfo hostLagInfo = new HostLagInfo(hostMap, updateTimeMs);\n+    receivedLagInfo.compute(hostInfo, (hi, previousHostLagInfo) ->\n+        previousHostLagInfo != null && previousHostLagInfo.getUpdateTimeMs() > updateTimeMs ?\n+            previousHostLagInfo : hostLagInfo);\n+  }\n+\n+  /**\n+   * Returns lag information for all of the \"alive\" hosts for a given state store and partition.\n+   * @param queryStateStoreId The lag info key\n+   * @param partition The partition of that state\n+   * @return A map which is keyed by host and contains lag information\n+   */\n+  public Map<HostInfo, LagInfoEntity> getHostsPartitionLagInfo(\n+      final Set<HostInfo> hosts, final QueryStateStoreId queryStateStoreId, final int partition) {\n+    ImmutableMap.Builder<HostInfo, LagInfoEntity> builder = ImmutableMap.builder();\n+    Set<HostInfo> aliveHosts = aliveHostsRef.get();\n+    for (HostInfo host : hosts) {", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5MzA5NA==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372593094", "bodyText": "I'm going to change the API to take a single host at a time, so that simplifies things and makes this not required.", "author": "AlanConfluent", "createdAt": "2020-01-29T19:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1MTk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\nindex cffb401633..6119119457 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020 Confluent Inc.\n+ * Copyright 2019 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"; you may not use\n  * this file except in compliance with the License. You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1NDAzNw==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371954037", "bodyText": "nit: can be simplified (same below):\n.collect(Collectors.toMap(\n   e -> QueryStateStoreId.of(getQueryApplicationId(), e.getKey()), \n   e -> e.getValue()\n))", "author": "agavra", "createdAt": "2020-01-28T17:39:01Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.ServiceManager;\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.HostStatusEntity;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.LagReportingRequest;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.rest.server.HeartbeatAgent.HostStatusListener;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.PersistentQueryMetadata;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.Clock;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.streams.LagInfo;\n+import org.apache.kafka.streams.errors.StreamsException;\n+import org.apache.kafka.streams.state.HostInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Agent responsible for sending and receiving lag information across the cluster and providing\n+ * aggregate stats, usable during query time.\n+ */\n+public final class LagReportingAgent implements HostStatusListener {\n+  private static final int SERVICE_TIMEOUT_SEC = 2;\n+  private static final int NUM_THREADS_EXECUTOR = 1;\n+  private static final int SEND_LAG_DELAY_MS = 100;\n+  private static final HostLagInfo EMPTY_HOST_LAG_INFO = new HostLagInfo(Collections.emptyMap(), 0);\n+  private static final Logger LOG = LoggerFactory.getLogger(LagReportingAgent.class);\n+\n+  private final KsqlEngine engine;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final ServiceContext serviceContext;\n+  private final LagReportingConfig config;\n+  private final ServiceManager serviceManager;\n+  private final Clock clock;\n+\n+  private final Map<HostInfo, HostLagInfo> receivedLagInfo;\n+  private final AtomicReference<Set<HostInfo>> aliveHostsRef;\n+\n+  private URL localURL;\n+\n+  /**\n+   * Builder for creating an instance of LagReportingAgent.\n+   * @return\n+   */\n+  public static LagReportingAgent.Builder builder() {\n+    return new LagReportingAgent.Builder();\n+  }\n+\n+  /**\n+   * Lag related agent for both sending out lag for localhost as well as receiving lag reports for\n+   * other nodes in the cluster.\n+   * @param engine The ksql engine to access streams for inferring the cluster and getting local\n+   *               lags metrics\n+   * @param serviceContext Service context for issuing ksql requests\n+   * @param config The LagReportingConfig for configuring this agent\n+   * @param clock Clock for reporting lag\n+   */\n+  private LagReportingAgent(\n+      final KsqlEngine engine,\n+      final ScheduledExecutorService scheduledExecutorService,\n+      final ServiceContext serviceContext,\n+      final LagReportingConfig config,\n+      final Clock clock) {\n+    this.engine = requireNonNull(engine, \"engine\");\n+    this.scheduledExecutorService = scheduledExecutorService;\n+    this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n+    this.config = requireNonNull(config, \"configuration parameters\");\n+    this.clock = clock;\n+    this.serviceManager = new ServiceManager(Arrays.asList(new SendLagService()));\n+    this.receivedLagInfo = new ConcurrentHashMap<>();\n+    this.aliveHostsRef = new AtomicReference<>(Collections.emptySet());\n+  }\n+\n+  void setLocalAddress(final String applicationServer) {\n+    try {\n+      this.localURL = new URL(applicationServer);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Failed to convert remote host info to URL.\"\n+          + \" remoteInfo: \" + applicationServer);\n+    }\n+  }\n+\n+  void startAgent() {\n+    try {\n+      serviceManager.startAsync().awaitHealthy(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to start heartbeat services with exception \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  void stopAgent() {\n+    try {\n+      serviceManager.stopAsync().awaitStopped(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to stop heartbeat services with exception \" + e.getMessage(), e);\n+    } finally {\n+      scheduledExecutorService.shutdownNow();\n+    }\n+  }\n+\n+  /**\n+   * Stores the host lag received from a remote Ksql server.\n+   * @param lagReportingRequest The host lag information sent directly from the other node.\n+   */\n+  public void receiveHostLag(final LagReportingRequest lagReportingRequest) {\n+    final long updateTimeMs = lagReportingRequest.getLastLagUpdateMs();\n+    final HostInfoEntity hostInfoEntity = lagReportingRequest.getHostInfo();\n+    final HostInfo hostInfo = new HostInfo(hostInfoEntity.getHost(), hostInfoEntity.getPort());\n+\n+    ImmutableMap.Builder<QueryStateStoreId, Map<Integer, LagInfoEntity>> hostMapBuilder\n+        = ImmutableMap.builder();\n+    for (Map.Entry<QueryStateStoreId, Map<Integer, LagInfoEntity>> storeEntry\n+        : lagReportingRequest.getStoreToPartitionToLagMap().entrySet()) {\n+      final QueryStateStoreId queryStateStoreId = storeEntry.getKey();\n+      final Map<Integer, LagInfoEntity> partitionMap = storeEntry.getValue();\n+\n+      ImmutableMap.Builder<Integer, LagInfoEntity> partitionsBuilder = ImmutableMap.builder();\n+\n+      // Go through each new partition and add lag info\n+      for (final Map.Entry<Integer, LagInfoEntity> partitionEntry : partitionMap.entrySet()) {\n+        final Integer partition = partitionEntry.getKey();\n+        final LagInfoEntity lagInfo = partitionEntry.getValue();\n+        partitionsBuilder.put(partition, lagInfo);\n+      }\n+\n+      hostMapBuilder.put(queryStateStoreId, partitionsBuilder.build());\n+    }\n+\n+    Map<QueryStateStoreId, Map<Integer, LagInfoEntity>> hostMap = hostMapBuilder.build();\n+    HostLagInfo hostLagInfo = new HostLagInfo(hostMap, updateTimeMs);\n+    receivedLagInfo.compute(hostInfo, (hi, previousHostLagInfo) ->\n+        previousHostLagInfo != null && previousHostLagInfo.getUpdateTimeMs() > updateTimeMs ?\n+            previousHostLagInfo : hostLagInfo);\n+  }\n+\n+  /**\n+   * Returns lag information for all of the \"alive\" hosts for a given state store and partition.\n+   * @param queryStateStoreId The lag info key\n+   * @param partition The partition of that state\n+   * @return A map which is keyed by host and contains lag information\n+   */\n+  public Map<HostInfo, LagInfoEntity> getHostsPartitionLagInfo(\n+      final Set<HostInfo> hosts, final QueryStateStoreId queryStateStoreId, final int partition) {\n+    ImmutableMap.Builder<HostInfo, LagInfoEntity> builder = ImmutableMap.builder();\n+    Set<HostInfo> aliveHosts = aliveHostsRef.get();\n+    for (HostInfo host : hosts) {\n+      LagInfoEntity lagInfo = receivedLagInfo.getOrDefault(host, EMPTY_HOST_LAG_INFO).getLagInfo()\n+          .getOrDefault(queryStateStoreId, Collections.emptyMap())\n+          .getOrDefault(partition, null);\n+      if (aliveHosts.contains(host) && lagInfo != null) {\n+        builder.put(host, lagInfo);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Returns a map of storeName -> partition -> LagInfoEntity.  Meant for being exposed in testing\n+   * and debug resources.\n+   */\n+  public Map<HostInfoEntity, Map<QueryStateStoreId, Map<Integer, LagInfoEntity>>> listAllLags() {\n+    ImmutableMap.Builder<HostInfoEntity, Map<QueryStateStoreId, Map<Integer, LagInfoEntity>>>\n+        builder = ImmutableMap.builder();\n+    for (Entry<HostInfo, HostLagInfo> e : receivedLagInfo.entrySet()) {\n+      final HostInfo hostInfo = e.getKey();\n+      builder.put(new HostInfoEntity(hostInfo.host(), hostInfo.port()),\n+          e.getValue().getLagInfo());\n+    }\n+    return builder.build();\n+  }\n+\n+  @Override\n+  public void onHostStatusUpdated(final Map<String, HostStatusEntity> hostsStatusMap) {\n+    aliveHostsRef.set(hostsStatusMap.values().stream()\n+        .filter(HostStatusEntity::getHostAlive)\n+        .map(HostStatusEntity::getHostInfoEntity)\n+        .map(hostInfoEntity -> new HostInfo(hostInfoEntity.getHost(), hostInfoEntity.getPort()))\n+        .collect(ImmutableSet.toImmutableSet()));\n+  }\n+\n+  /**\n+   * Broadcast lags to remote hosts.\n+   *\n+   * <p>This is an asynchronous RPC and we do not handle the response returned from the remote\n+   * server.</p>\n+   */\n+  class SendLagService extends AbstractScheduledService {\n+\n+    @Override\n+    protected void runOneIteration() {\n+      final List<PersistentQueryMetadata> currentQueries = engine.getPersistentQueries();\n+      if (currentQueries.isEmpty()) {\n+        return;\n+      }\n+\n+      final Map<QueryStateStoreId, Map<Integer, LagInfo>> localLagMap\n+          = currentQueries.stream()\n+          .map(this::getLocalLagMap)\n+          .filter(Objects::nonNull)\n+          .flatMap(map -> map.entrySet().stream())\n+          .collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n+\n+      final LagReportingRequest request = createLagReportingRequest(localLagMap);\n+\n+      Set<HostInfo> aliveHosts = aliveHostsRef.get();\n+      for (HostInfo hostInfo: aliveHosts) {\n+        try {\n+          final URI remoteUri = buildRemoteUri(localURL, hostInfo.host(), hostInfo.port());\n+          LOG.debug(\"Sending lag to host {} at {}\", hostInfo.host(), clock.millis());\n+          serviceContext.getKsqlClient().makeAsyncLagReportRequest(remoteUri, request);\n+        } catch (Throwable t) {\n+          LOG.error(\"Request to server: \" + hostInfo.host() + \":\" + hostInfo.port()\n+              + \" failed with exception: \" + t.getMessage(), t);\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Fetches the lag map from PersistentQueryMetadata, getting it from the underlying\n+     * KafkaStreams.\n+     */\n+    private Map<QueryStateStoreId, Map<Integer, LagInfo>> getLocalLagMap(\n+        PersistentQueryMetadata persistentQueryMetadata) {\n+      Map<QueryStateStoreId, Map<Integer, LagInfo>> getLagMap = null;\n+      try {\n+        getLagMap = persistentQueryMetadata.getKafkaStreams()\n+            .allLocalStorePartitionLags().entrySet().stream()\n+            .map(e -> Pair.of(QueryStateStoreId.of(persistentQueryMetadata.getQueryApplicationId(),\n+                                                   e.getKey()),\n+                              e.getValue()))\n+            .collect(Collectors.toMap(Pair::getLeft, Pair::getRight));", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwNDM2OA==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372604368", "bodyText": "Done.  Reworked per your previous comment, but now I do this in the collector.", "author": "AlanConfluent", "createdAt": "2020-01-29T20:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1NDAzNw=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\nindex cffb401633..6119119457 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020 Confluent Inc.\n+ * Copyright 2019 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"; you may not use\n  * this file except in compliance with the License. You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1NjE3NA==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371956174", "bodyText": "did you intended to collapse the top layer (i.e. not include the hostInfoEntity as a key?)", "author": "agavra", "createdAt": "2020-01-28T17:43:11Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.ServiceManager;\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.HostStatusEntity;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.LagReportingRequest;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.rest.server.HeartbeatAgent.HostStatusListener;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.PersistentQueryMetadata;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.Clock;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.streams.LagInfo;\n+import org.apache.kafka.streams.errors.StreamsException;\n+import org.apache.kafka.streams.state.HostInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Agent responsible for sending and receiving lag information across the cluster and providing\n+ * aggregate stats, usable during query time.\n+ */\n+public final class LagReportingAgent implements HostStatusListener {\n+  private static final int SERVICE_TIMEOUT_SEC = 2;\n+  private static final int NUM_THREADS_EXECUTOR = 1;\n+  private static final int SEND_LAG_DELAY_MS = 100;\n+  private static final HostLagInfo EMPTY_HOST_LAG_INFO = new HostLagInfo(Collections.emptyMap(), 0);\n+  private static final Logger LOG = LoggerFactory.getLogger(LagReportingAgent.class);\n+\n+  private final KsqlEngine engine;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final ServiceContext serviceContext;\n+  private final LagReportingConfig config;\n+  private final ServiceManager serviceManager;\n+  private final Clock clock;\n+\n+  private final Map<HostInfo, HostLagInfo> receivedLagInfo;\n+  private final AtomicReference<Set<HostInfo>> aliveHostsRef;\n+\n+  private URL localURL;\n+\n+  /**\n+   * Builder for creating an instance of LagReportingAgent.\n+   * @return\n+   */\n+  public static LagReportingAgent.Builder builder() {\n+    return new LagReportingAgent.Builder();\n+  }\n+\n+  /**\n+   * Lag related agent for both sending out lag for localhost as well as receiving lag reports for\n+   * other nodes in the cluster.\n+   * @param engine The ksql engine to access streams for inferring the cluster and getting local\n+   *               lags metrics\n+   * @param serviceContext Service context for issuing ksql requests\n+   * @param config The LagReportingConfig for configuring this agent\n+   * @param clock Clock for reporting lag\n+   */\n+  private LagReportingAgent(\n+      final KsqlEngine engine,\n+      final ScheduledExecutorService scheduledExecutorService,\n+      final ServiceContext serviceContext,\n+      final LagReportingConfig config,\n+      final Clock clock) {\n+    this.engine = requireNonNull(engine, \"engine\");\n+    this.scheduledExecutorService = scheduledExecutorService;\n+    this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n+    this.config = requireNonNull(config, \"configuration parameters\");\n+    this.clock = clock;\n+    this.serviceManager = new ServiceManager(Arrays.asList(new SendLagService()));\n+    this.receivedLagInfo = new ConcurrentHashMap<>();\n+    this.aliveHostsRef = new AtomicReference<>(Collections.emptySet());\n+  }\n+\n+  void setLocalAddress(final String applicationServer) {\n+    try {\n+      this.localURL = new URL(applicationServer);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Failed to convert remote host info to URL.\"\n+          + \" remoteInfo: \" + applicationServer);\n+    }\n+  }\n+\n+  void startAgent() {\n+    try {\n+      serviceManager.startAsync().awaitHealthy(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to start heartbeat services with exception \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  void stopAgent() {\n+    try {\n+      serviceManager.stopAsync().awaitStopped(SERVICE_TIMEOUT_SEC, TimeUnit.SECONDS);\n+    } catch (TimeoutException | IllegalStateException e) {\n+      LOG.error(\"Failed to stop heartbeat services with exception \" + e.getMessage(), e);\n+    } finally {\n+      scheduledExecutorService.shutdownNow();\n+    }\n+  }\n+\n+  /**\n+   * Stores the host lag received from a remote Ksql server.\n+   * @param lagReportingRequest The host lag information sent directly from the other node.\n+   */\n+  public void receiveHostLag(final LagReportingRequest lagReportingRequest) {\n+    final long updateTimeMs = lagReportingRequest.getLastLagUpdateMs();\n+    final HostInfoEntity hostInfoEntity = lagReportingRequest.getHostInfo();\n+    final HostInfo hostInfo = new HostInfo(hostInfoEntity.getHost(), hostInfoEntity.getPort());\n+\n+    ImmutableMap.Builder<QueryStateStoreId, Map<Integer, LagInfoEntity>> hostMapBuilder\n+        = ImmutableMap.builder();\n+    for (Map.Entry<QueryStateStoreId, Map<Integer, LagInfoEntity>> storeEntry\n+        : lagReportingRequest.getStoreToPartitionToLagMap().entrySet()) {\n+      final QueryStateStoreId queryStateStoreId = storeEntry.getKey();\n+      final Map<Integer, LagInfoEntity> partitionMap = storeEntry.getValue();\n+\n+      ImmutableMap.Builder<Integer, LagInfoEntity> partitionsBuilder = ImmutableMap.builder();\n+\n+      // Go through each new partition and add lag info\n+      for (final Map.Entry<Integer, LagInfoEntity> partitionEntry : partitionMap.entrySet()) {\n+        final Integer partition = partitionEntry.getKey();\n+        final LagInfoEntity lagInfo = partitionEntry.getValue();\n+        partitionsBuilder.put(partition, lagInfo);\n+      }\n+\n+      hostMapBuilder.put(queryStateStoreId, partitionsBuilder.build());\n+    }\n+\n+    Map<QueryStateStoreId, Map<Integer, LagInfoEntity>> hostMap = hostMapBuilder.build();\n+    HostLagInfo hostLagInfo = new HostLagInfo(hostMap, updateTimeMs);\n+    receivedLagInfo.compute(hostInfo, (hi, previousHostLagInfo) ->\n+        previousHostLagInfo != null && previousHostLagInfo.getUpdateTimeMs() > updateTimeMs ?\n+            previousHostLagInfo : hostLagInfo);\n+  }\n+\n+  /**\n+   * Returns lag information for all of the \"alive\" hosts for a given state store and partition.\n+   * @param queryStateStoreId The lag info key\n+   * @param partition The partition of that state\n+   * @return A map which is keyed by host and contains lag information\n+   */\n+  public Map<HostInfo, LagInfoEntity> getHostsPartitionLagInfo(\n+      final Set<HostInfo> hosts, final QueryStateStoreId queryStateStoreId, final int partition) {\n+    ImmutableMap.Builder<HostInfo, LagInfoEntity> builder = ImmutableMap.builder();\n+    Set<HostInfo> aliveHosts = aliveHostsRef.get();\n+    for (HostInfo host : hosts) {\n+      LagInfoEntity lagInfo = receivedLagInfo.getOrDefault(host, EMPTY_HOST_LAG_INFO).getLagInfo()\n+          .getOrDefault(queryStateStoreId, Collections.emptyMap())\n+          .getOrDefault(partition, null);\n+      if (aliveHosts.contains(host) && lagInfo != null) {\n+        builder.put(host, lagInfo);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Returns a map of storeName -> partition -> LagInfoEntity.  Meant for being exposed in testing", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwMzcyMw==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372603723", "bodyText": "No, I think this comment is a bit stale.  Updated.", "author": "AlanConfluent", "createdAt": "2020-01-29T20:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1NjE3NA=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\nindex cffb401633..6119119457 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LagReportingAgent.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020 Confluent Inc.\n+ * Copyright 2019 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"; you may not use\n  * this file except in compliance with the License. You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2MDM0NA==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371960344", "bodyText": "I think it might make sense to follow the same pattern we have for the heartbeat API and not add a verb to the /lag endpoint (i.e. we just POST /lag) to keep it RESTFUL", "author": "agavra", "createdAt": "2020-01-28T17:51:21Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/LagReportingResource.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server.resources;\n+\n+import io.confluent.ksql.rest.entity.LagReportingRequest;\n+import io.confluent.ksql.rest.entity.LagReportingResponse;\n+import io.confluent.ksql.rest.entity.Versions;\n+import io.confluent.ksql.rest.server.LagReportingAgent;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+@Path(\"/lag\")\n+@Consumes({Versions.KSQL_V1_JSON, MediaType.APPLICATION_JSON})\n+@Produces({Versions.KSQL_V1_JSON, MediaType.APPLICATION_JSON})\n+public class LagReportingResource {\n+\n+  private LagReportingAgent lagReportingAgent;\n+\n+  public LagReportingResource(final LagReportingAgent lagReportingAgent) {\n+    this.lagReportingAgent = lagReportingAgent;\n+  }\n+\n+  @Path(\"/report\")", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwNDk1Mw==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372604953", "bodyText": "That's a good point.  I had previously exposed list lags here as well with a different sub path, but I agree it makes little sense now.", "author": "AlanConfluent", "createdAt": "2020-01-29T20:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2MDM0NA=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/LagReportingResource.java b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/LagReportingResource.java\nsimilarity index 54%\nrename from ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/LagReportingResource.java\nrename to ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/LagReportingResource.java\nindex 39926bb35c..2ff12625b7 100644\n--- a/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/LagReportingResource.java\n+++ b/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/LagReportingResource.java\n\n@@ -1,25 +1,11 @@\n-/*\n- * Copyright 2020 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.rest.server.resources;\n+package io.confluent.ksql.rest.server.services;\n \n import io.confluent.ksql.rest.entity.LagReportingRequest;\n import io.confluent.ksql.rest.entity.LagReportingResponse;\n+import io.confluent.ksql.rest.entity.LagListResponse;\n import io.confluent.ksql.rest.entity.Versions;\n import io.confluent.ksql.rest.server.LagReportingAgent;\n-import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n import javax.ws.rs.POST;\n import javax.ws.rs.Path;\n import javax.ws.rs.Produces;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2NTczNg==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r371965736", "bodyText": "nit: this might be a pain, but I think these tests would be easier to read and maintain if we had properly named constants for all of these ints", "author": "agavra", "createdAt": "2020-01-28T18:01:41Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/LagReportingAgentTest.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package io.confluent.ksql.rest.server;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.HostStatusEntity;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.LagReportingRequest;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.rest.server.LagReportingAgent.Builder;\n+import io.confluent.ksql.rest.server.LagReportingAgent.SendLagService;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.services.SimpleKsqlClient;\n+import io.confluent.ksql.util.PersistentQueryMetadata;\n+import java.net.URI;\n+import java.time.Clock;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.LagInfo;\n+import org.apache.kafka.streams.state.HostInfo;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class LagReportingAgentTest {\n+  private static long TIME_NOW_MS = 100;\n+  private static final String LOCALHOST_URL = \"http://localhost:8088\";\n+  private static HostInfoEntity LOCALHOST_INFO = new HostInfoEntity(\"localhost\", 8088);\n+\n+  private static HostInfoEntity HOST1 = new HostInfoEntity(\"host1\", 1234);\n+  private static HostInfoEntity HOST2 = new HostInfoEntity(\"host2\", 1234);\n+  private static HostInfo HI1 = new HostInfo(\"host1\", 1234);\n+  private static HostInfo HI2 = new HostInfo(\"host2\", 1234);\n+  private static Set<HostInfo> HOSTS = ImmutableSet.of(HI1, HI2);\n+  private static HostStatusEntity HOST1_STATUS_ALIVE = new HostStatusEntity(HOST1, true, 0L);\n+  private static HostStatusEntity HOST2_STATUS_ALIVE = new HostStatusEntity(HOST2, true, 0L);\n+  private static HostStatusEntity HOST1_STATUS_DEAD = new HostStatusEntity(HOST1, false, 0L);\n+  private static HostStatusEntity HOST2_STATUS_DEAD = new HostStatusEntity(HOST2, false, 0L);\n+\n+  private static Map<String, HostStatusEntity> HOSTS_ALIVE\n+      = ImmutableMap.<String, HostStatusEntity>builder()\n+      .put(HOST1.toString(), HOST1_STATUS_ALIVE)\n+      .put(HOST2.toString(), HOST2_STATUS_ALIVE)\n+      .build();\n+\n+  private static Map<String, HostStatusEntity> HOSTS_HOST1_DEAD\n+      = ImmutableMap.<String, HostStatusEntity>builder()\n+      .put(HOST1.toString(), HOST1_STATUS_DEAD)\n+      .put(HOST2.toString(), HOST2_STATUS_ALIVE)\n+      .build();\n+\n+  private static Map<String, HostStatusEntity> HOSTS_HOST2_DEAD\n+      = ImmutableMap.<String, HostStatusEntity>builder()\n+      .put(HOST1.toString(), HOST1_STATUS_ALIVE)\n+      .put(HOST2.toString(), HOST2_STATUS_DEAD)\n+      .build();\n+\n+  private static final String QUERY_ID0 = \"query0\";\n+  private static final String QUERY_ID1 = \"query1\";\n+  private static final String STATE_STORE0 = \"a\";\n+  private static final String STATE_STORE1 = \"b\";\n+  private static final QueryStateStoreId QUERY_STORE_A =\n+      QueryStateStoreId.of(QUERY_ID0, STATE_STORE0);\n+  private static final QueryStateStoreId QUERY_STORE_B =\n+      QueryStateStoreId.of(QUERY_ID1, STATE_STORE1);\n+\n+  private static final Map<QueryStateStoreId, Map<Integer, LagInfoEntity>> LAG_MAP1\n+      = ImmutableMap.<QueryStateStoreId, Map<Integer, LagInfoEntity>>builder()\n+      .put(QUERY_STORE_A, ImmutableMap.<Integer, LagInfoEntity>builder()\n+          .put(1, new LagInfoEntity(1, 10, 9))\n+          .put(3, new LagInfoEntity(3, 10, 7))\n+          .build())\n+      .put(QUERY_STORE_B, ImmutableMap.<Integer, LagInfoEntity>builder()\n+          .put(4, new LagInfoEntity(6, 10, 4))\n+          .build())\n+      .build();\n+\n+  private static final Map<QueryStateStoreId, Map<Integer, LagInfoEntity>> LAG_MAP2\n+      = ImmutableMap.<QueryStateStoreId, Map<Integer, LagInfoEntity>>builder()\n+      .put(QUERY_STORE_A, ImmutableMap.<Integer, LagInfoEntity>builder()\n+          .put(1, new LagInfoEntity(4, 10, 6))\n+          .build())\n+      .put(QUERY_STORE_B, ImmutableMap.<Integer, LagInfoEntity>builder()\n+          .put(4, new LagInfoEntity(7, 10, 3))\n+          .build())\n+      .build();\n+\n+  @Mock\n+  private PersistentQueryMetadata query0;\n+  @Mock\n+  private PersistentQueryMetadata query1;\n+  @Mock\n+  private KafkaStreams kafkaStreams0;\n+  @Mock\n+  private KafkaStreams kafkaStreams1;\n+  @Mock\n+  private ServiceContext serviceContext;\n+  @Mock\n+  private KsqlEngine ksqlEngine;\n+  @Mock\n+  private SimpleKsqlClient ksqlClient;\n+  @Mock\n+  private LagInfo lagInfo0;\n+  @Mock\n+  private LagInfo lagInfo1;\n+  @Mock\n+  private Clock clock;\n+\n+  private LagReportingAgent lagReportingAgent;\n+\n+\n+  @Before\n+  public void setUp() {\n+    when(serviceContext.getKsqlClient()).thenReturn(ksqlClient);\n+\n+    Builder builder = LagReportingAgent.builder();\n+    lagReportingAgent = builder\n+        .clock(clock)\n+        .build(ksqlEngine, serviceContext);\n+    lagReportingAgent.setLocalAddress(LOCALHOST_URL);\n+  }\n+\n+  @Test\n+  public void shouldReceiveLags() {\n+    // When:\n+    lagReportingAgent.receiveHostLag(hostLag(HOST1, LAG_MAP1, 100));\n+    lagReportingAgent.receiveHostLag(hostLag(HOST2, LAG_MAP2, 200));\n+    lagReportingAgent.onHostStatusUpdated(HOSTS_ALIVE);\n+\n+    // Then:\n+    Map<HostInfo, LagInfoEntity> hostPartitionLagList\n+        = lagReportingAgent.getHostsPartitionLagInfo(HOSTS, QueryStateStoreId.of(\"query0\", \"a\"), 1);\n+    assertEquals(2, hostPartitionLagList.size());\n+    assertEquals(1, hostPartitionLagList.get(HI1).getCurrentOffsetPosition());\n+    assertEquals(10, hostPartitionLagList.get(HI1).getEndOffsetPosition());\n+    assertEquals(9, hostPartitionLagList.get(HI1).getOffsetLag());\n+    assertEquals(4, hostPartitionLagList.get(HI2).getCurrentOffsetPosition());\n+    assertEquals(10, hostPartitionLagList.get(HI2).getEndOffsetPosition());\n+    assertEquals(6, hostPartitionLagList.get(HI2).getOffsetLag());", "originalCommit": "d3e4f951c670028b925593aa13f654440e50ae3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0MTYwOA==", "url": "https://github.com/confluentinc/ksql/pull/4392#discussion_r372641608", "bodyText": "Ok, did that for all of the offsets.", "author": "AlanConfluent", "createdAt": "2020-01-29T21:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2NTczNg=="}], "type": "inlineReview", "revised_code": {"commit": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "chunk": "diff --git a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/LagReportingAgentTest.java b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/LagReportingAgentTest.java\nindex c4c7da2754..cf5da66b49 100644\n--- a/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/LagReportingAgentTest.java\n+++ b/ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/LagReportingAgentTest.java\n\n@@ -5,25 +5,26 @@ import static org.mockito.Mockito.eq;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n+import com.google.common.base.Ticker;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSortedMap;\n import io.confluent.ksql.engine.KsqlEngine;\n import io.confluent.ksql.rest.entity.HostInfoEntity;\n-import io.confluent.ksql.rest.entity.HostStatusEntity;\n-import io.confluent.ksql.rest.entity.LagInfoEntity;\n import io.confluent.ksql.rest.entity.LagReportingRequest;\n-import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n import io.confluent.ksql.rest.server.LagReportingAgent.Builder;\n+import io.confluent.ksql.rest.server.LagReportingAgent.HostPartitionLagInfo;\n import io.confluent.ksql.rest.server.LagReportingAgent.SendLagService;\n import io.confluent.ksql.services.ServiceContext;\n import io.confluent.ksql.services.SimpleKsqlClient;\n import io.confluent.ksql.util.PersistentQueryMetadata;\n import java.net.URI;\n import java.time.Clock;\n+import java.time.Duration;\n import java.util.Map;\n import java.util.Set;\n-import org.apache.kafka.streams.KafkaStreams;\n import org.apache.kafka.streams.LagInfo;\n import org.apache.kafka.streams.state.HostInfo;\n import org.junit.Before;\n"}}, {"oid": "93276a4e8a1874e1520be8d4c2620addd8d7df14", "url": "https://github.com/confluentinc/ksql/commit/93276a4e8a1874e1520be8d4c2620addd8d7df14", "message": "feat: Adds lag reporting and API for use in lag aware routing as described in KLIP-12", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "a3a29a0aa0f455a5ab3a09f9b8c6357755171bb4", "url": "https://github.com/confluentinc/ksql/commit/a3a29a0aa0f455a5ab3a09f9b8c6357755171bb4", "message": "Uses new heartbeat listener", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "ec5453909a6f9767e1f4a9a801e6302e40ca1667", "url": "https://github.com/confluentinc/ksql/commit/ec5453909a6f9767e1f4a9a801e6302e40ca1667", "message": "Fixes style issues", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "a6cb9870f2793cd4437a195318d4a9df381ed012", "url": "https://github.com/confluentinc/ksql/commit/a6cb9870f2793cd4437a195318d4a9df381ed012", "message": "Remove prev warning removals", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "e93ac04a82162493357e2566f738410c39e2e4c0", "url": "https://github.com/confluentinc/ksql/commit/e93ac04a82162493357e2566f738410c39e2e4c0", "message": "Adds lagagent as a listener", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "82090fec74b2f3fbbf24e24064227a47c80f256f", "url": "https://github.com/confluentinc/ksql/commit/82090fec74b2f3fbbf24e24064227a47c80f256f", "message": "Introduces simple LagCache", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "356ad508850ac96278a6509f09f44d8337a4bf66", "url": "https://github.com/confluentinc/ksql/commit/356ad508850ac96278a6509f09f44d8337a4bf66", "message": "Some comments and simple changes", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "1e836b4aeaddbe057e849ad799851851c02467cf", "url": "https://github.com/confluentinc/ksql/commit/1e836b4aeaddbe057e849ad799851851c02467cf", "message": "Only allows LagReportingAgent if HeartbeatAgent is enabled", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "ccb70a97548e32cfbcfdfbbaca02fc5199bea606", "url": "https://github.com/confluentinc/ksql/commit/ccb70a97548e32cfbcfdfbbaca02fc5199bea606", "message": "Adds Lag Reporting Functional test", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "81f22e1475c2b96d25fdcd08ce68ebb01b5ffd11", "url": "https://github.com/confluentinc/ksql/commit/81f22e1475c2b96d25fdcd08ce68ebb01b5ffd11", "message": "Style fixes", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "2ea201e0b2c4dad01784fdf61cf2da27cc85a7ca", "url": "https://github.com/confluentinc/ksql/commit/2ea201e0b2c4dad01784fdf61cf2da27cc85a7ca", "message": "Adds LagInfoKey to keep track of lags", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "459360e4c8c2a898db9a8fae0edf58abd04df13c", "url": "https://github.com/confluentinc/ksql/commit/459360e4c8c2a898db9a8fae0edf58abd04df13c", "message": "Style again", "committedDate": "2020-01-29T22:00:32Z", "type": "commit"}, {"oid": "4a4626ca708923973b7db8c5ad57a2bfd4a3b426", "url": "https://github.com/confluentinc/ksql/commit/4a4626ca708923973b7db8c5ad57a2bfd4a3b426", "message": "Refactors to key by host", "committedDate": "2020-01-29T22:00:33Z", "type": "commit"}, {"oid": "e1b7d24c12993d66df884d8877161c68fb6ebd06", "url": "https://github.com/confluentinc/ksql/commit/e1b7d24c12993d66df884d8877161c68fb6ebd06", "message": "Feedback", "committedDate": "2020-01-29T22:00:33Z", "type": "commit"}, {"oid": "77d94fe6b0f3dd39ae46615318c47a94075098f8", "url": "https://github.com/confluentinc/ksql/commit/77d94fe6b0f3dd39ae46615318c47a94075098f8", "message": "Feedback round 1", "committedDate": "2020-01-29T22:00:33Z", "type": "commit"}, {"oid": "12603548682243e38577770e0badfd6bd6a9163d", "url": "https://github.com/confluentinc/ksql/commit/12603548682243e38577770e0badfd6bd6a9163d", "message": "More feedback about consolidating cluster status", "committedDate": "2020-01-29T22:00:33Z", "type": "commit"}, {"oid": "1781831e03e3c047f1e3f61877debe08df05cbf9", "url": "https://github.com/confluentinc/ksql/commit/1781831e03e3c047f1e3f61877debe08df05cbf9", "message": "Renamed HeartbeatListener to HostStatusListener", "committedDate": "2020-01-29T22:00:33Z", "type": "commit"}, {"oid": "65b21a88c82c548bdf552baf36706af8515f5449", "url": "https://github.com/confluentinc/ksql/commit/65b21a88c82c548bdf552baf36706af8515f5449", "message": "Adds empty set of live hosts to begin with", "committedDate": "2020-01-29T22:00:33Z", "type": "commit"}, {"oid": "e9e7d3ce0425d30560d7500e5c6f030b22a86928", "url": "https://github.com/confluentinc/ksql/commit/e9e7d3ce0425d30560d7500e5c6f030b22a86928", "message": "Moves the null check so it's after getLocalLagMap", "committedDate": "2020-01-29T22:00:33Z", "type": "commit"}, {"oid": "f35a7bc1b66a327dbff1a52c0d775dce32d77fcd", "url": "https://github.com/confluentinc/ksql/commit/f35a7bc1b66a327dbff1a52c0d775dce32d77fcd", "message": "Feedback from Almog", "committedDate": "2020-01-29T22:00:33Z", "type": "commit"}, {"oid": "f35a7bc1b66a327dbff1a52c0d775dce32d77fcd", "url": "https://github.com/confluentinc/ksql/commit/f35a7bc1b66a327dbff1a52c0d775dce32d77fcd", "message": "Feedback from Almog", "committedDate": "2020-01-29T22:00:33Z", "type": "forcePushed"}, {"oid": "ee30b2a4415b6e5fa20e33f7d61c8da9f5771b8a", "url": "https://github.com/confluentinc/ksql/commit/ee30b2a4415b6e5fa20e33f7d61c8da9f5771b8a", "message": "Adds lags to ClusterStatusResponse.equals", "committedDate": "2020-01-30T01:00:14Z", "type": "commit"}, {"oid": "6201d14d273b11527c6a8b089738fa785e52a752", "url": "https://github.com/confluentinc/ksql/commit/6201d14d273b11527c6a8b089738fa785e52a752", "message": "Changes separator to # rather than $", "committedDate": "2020-01-30T01:10:46Z", "type": "commit"}]}