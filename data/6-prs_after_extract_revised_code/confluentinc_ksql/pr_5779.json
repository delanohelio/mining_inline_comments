{"pr_number": 5779, "pr_title": "feat: add suppress node", "pr_createdAt": "2020-07-07T23:52:54Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5779", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1OTA3MQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451659071", "bodyText": "let's make sure the date and license are right!", "author": "agavra", "createdAt": "2020-07-08T16:06:37Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2018 Confluent Inc.", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\nindex c5c2c0e95d..5b8a2a880e 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018 Confluent Inc.\n+ * Copyright 2020 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"); you may not use\n  * this file except in compliance with the License.  You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1OTc5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451659793", "bodyText": "I think we should add a detailed description of the design for the implementation in the PR description, and get at least one person other than me to +1 this PR to \"approve\" the design as well", "author": "agavra", "createdAt": "2020-07-08T16:07:43Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -138,6 +140,10 @@ public OutputNode buildPlan() {\n       currentNode = buildUserProjectNode(currentNode);\n     }\n \n+    if (analysis.getResultMaterialization().get() == ResultMaterialization.FINAL) {\n+      currentNode = buildSuppressNode(currentNode, analysis.getResultMaterialization().get());", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java\nindex 5984381937..e12aa1dc33 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java\n\n@@ -140,7 +140,8 @@ public class LogicalPlanner {\n       currentNode = buildUserProjectNode(currentNode);\n     }\n \n-    if (analysis.getResultMaterialization().get() == ResultMaterialization.FINAL) {\n+    if (analysis.getResultMaterialization().isPresent()\n+        && analysis.getResultMaterialization().get() == ResultMaterialization.FINAL) {\n       currentNode = buildSuppressNode(currentNode, analysis.getResultMaterialization().get());\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY2NDAxOA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451664018", "bodyText": "It would be helpful for people who read this code in the future if we included a detailed javadoc description of what the suppress node is, how it works and where/why it is used.\nHistorically, our code base isn't really good about this but for anything new we should strive to keep good documentation! For some examples (choosing my own stuff because I know of them) you can take a look at https://github.com/confluentinc/ksql/blob/master/ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java and https://github.com/confluentinc/ksql/blob/master/ksqldb-common/src/main/java/io/confluent/ksql/function/UdfIndex.java", "author": "agavra", "createdAt": "2020-07-08T16:14:06Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2018 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Collections;\n+import java.util.Objects;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+\n+\n+\n+public class SuppressNode extends SingleSourcePlanNode {", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\nindex c5c2c0e95d..5b8a2a880e 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018 Confluent Inc.\n+ * Copyright 2020 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"); you may not use\n  * this file except in compliance with the License.  You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY2Njk0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451666949", "bodyText": "this should be a KsqlException, and we should have a more detailed error message that includes (1) what is happening (i.e. building a suppress node) and (2) any context that might help debug it (e.g. the stream name)", "author": "agavra", "createdAt": "2020-07-08T16:18:39Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2018 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Collections;\n+import java.util.Objects;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+\n+\n+\n+public class SuppressNode extends SingleSourcePlanNode {\n+\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final ResultMaterialization resultMaterialization\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.resultMaterialization = Objects.requireNonNull(\n+        resultMaterialization, \"resultMaterialization\");\n+  }\n+\n+  public ResultMaterialization getResultMaterialization() {\n+    return resultMaterialization;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(\n+        builder.withKsqlConfig(builder.getKsqlConfig()\n+            .cloneWithPropertyOverwrite(Collections.singletonMap(\n+                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\")))\n+    );\n+\n+    if (!(schemaKStream instanceof SchemaKTable)) {\n+      throw new RuntimeException(\"Expected to find a Table, found a stream instead.\");", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\nindex c5c2c0e95d..5b8a2a880e 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018 Confluent Inc.\n+ * Copyright 2020 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"); you may not use\n  * this file except in compliance with the License.  You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY2NzcxMg==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451667712", "bodyText": "since we haven't implemented anything here yet, we should make sure that we throw a meaningful exception (e.g. throw new KsqlException(\"EMIT FINAL is not yet supported\")", "author": "agavra", "createdAt": "2020-07-08T16:19:49Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.execution.plan.KTableHolder;\n+\n+public final class TableSuppressBuilder {\n+\n+  private TableSuppressBuilder() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static <K> KTableHolder<K> build(\n+      final KTableHolder<K> table\n+  ) {\n+    return table;", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "chunk": "diff --git a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java\nindex 8f9041e7ac..3df0554dca 100644\n--- a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java\n+++ b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2019 Confluent Inc.\n+ * Copyright 2020 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"); you may not use\n  * this file except in compliance with the License.  You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY2ODIyMA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451668220", "bodyText": "why are we adding this config to the suppress node?", "author": "agavra", "createdAt": "2020-07-08T16:20:36Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2018 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Collections;\n+import java.util.Objects;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+\n+\n+\n+public class SuppressNode extends SingleSourcePlanNode {\n+\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final ResultMaterialization resultMaterialization\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.resultMaterialization = Objects.requireNonNull(\n+        resultMaterialization, \"resultMaterialization\");\n+  }\n+\n+  public ResultMaterialization getResultMaterialization() {\n+    return resultMaterialization;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(\n+        builder.withKsqlConfig(builder.getKsqlConfig()\n+            .cloneWithPropertyOverwrite(Collections.singletonMap(\n+                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\")))\n+    );", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\nindex c5c2c0e95d..5b8a2a880e 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018 Confluent Inc.\n+ * Copyright 2020 Confluent Inc.\n  *\n  * Licensed under the Confluent Community License (the \"License\"); you may not use\n  * this file except in compliance with the License.  You may obtain a copy of the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY5NDg3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451694876", "bodyText": "any reason to have another method to call out to instead of inlining return schema here?", "author": "agavra", "createdAt": "2020-07-08T17:02:40Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/StepSchemaResolver.java", "diffHunk": "@@ -293,6 +295,13 @@ private LogicalSchema handleTableSelect(\n     return buildSelectSchema(schema, step.getKeyColumnNames(), step.getSelectExpressions());\n   }\n \n+  private LogicalSchema handleTableSuppress(\n+      final LogicalSchema schema,\n+      final TableSuppress<?> step\n+  ) {\n+    return buildSuppressSchema(schema);", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcwNzcwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451707705", "bodyText": "No we can simply just use the existing method sameSchema  instead of creating handleTableSuppress and buildSuppressSchema methods, since Suppress does not alter the schema", "author": "nae701", "createdAt": "2020-07-08T17:24:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY5NDg3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "chunk": "diff --git a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/StepSchemaResolver.java b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/StepSchemaResolver.java\nindex cd0078fc27..dd7dc71359 100644\n--- a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/StepSchemaResolver.java\n+++ b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/StepSchemaResolver.java\n\n@@ -295,13 +295,6 @@ public final class StepSchemaResolver {\n     return buildSelectSchema(schema, step.getKeyColumnNames(), step.getSelectExpressions());\n   }\n \n-  private LogicalSchema handleTableSuppress(\n-      final LogicalSchema schema,\n-      final TableSuppress<?> step\n-  ) {\n-    return buildSuppressSchema(schema);\n-  }\n-\n   private LogicalSchema sameSchema(final LogicalSchema schema, final ExecutionStep<?> step) {\n     return schema;\n   }\n"}}, {"oid": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "url": "https://github.com/confluentinc/ksql/commit/b2b80285b58a97f1a299c38889cb4dea6a974eb7", "message": "test: add unit tests for suppress node", "committedDate": "2020-07-10T21:20:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5NDc3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453094772", "bodyText": "This is an unneccesary import", "author": "nae701", "createdAt": "2020-07-10T21:56:37Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java", "diffHunk": "@@ -32,10 +32,12 @@\n import io.confluent.ksql.name.SourceName;\n import io.confluent.ksql.planner.plan.DataSourceNode;\n import io.confluent.ksql.planner.plan.FilterNode;\n+import io.confluent.ksql.planner.plan.FinalProjectNode;", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java\nindex 6ceaea0100..517b97514e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java\n\n@@ -30,9 +32,9 @@ import io.confluent.ksql.metastore.MetaStore;\n import io.confluent.ksql.metastore.model.DataSource;\n import io.confluent.ksql.name.ColumnName;\n import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.planner.plan.AggregateNode;\n import io.confluent.ksql.planner.plan.DataSourceNode;\n import io.confluent.ksql.planner.plan.FilterNode;\n-import io.confluent.ksql.planner.plan.FinalProjectNode;\n import io.confluent.ksql.planner.plan.JoinNode;\n import io.confluent.ksql.planner.plan.PlanNode;\n import io.confluent.ksql.planner.plan.ProjectNode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5NDE4OA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453094188", "bodyText": "can this just be buildStream(builder) do we need to reset the ksqlConfig?", "author": "agavra", "createdAt": "2020-07-10T21:55:03Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Objects;\n+\n+import io.confluent.ksql.util.KsqlException;\n+\n+\n+/**\n+ The suppress node is a plan node that is added to the logical plan if the user specifies in their\n+ ksqlDB query that the result materialization should be EMIT FINAL. The physical plan is then built\n+ and executed using the logical plan, and executes all of the plan nodes that were added from the\n+ logical plan including the suppress node if it was added. Currently the suppress node needs to be\n+ added at the end of the logical plan right before we build the output node, this is so that we can\n+ suppress results that may need to be aggregated or altered somehow. Using a suppress node also\n+ allows for more flexibility in the future in terms of enhancements or different types of\n+ suppression being supported.\n+ */\n+public class SuppressNode extends SingleSourcePlanNode implements VerifiableNode {\n+\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final ResultMaterialization resultMaterialization\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.resultMaterialization = Objects.requireNonNull(\n+        resultMaterialization, \"resultMaterialization\");\n+  }\n+\n+  public ResultMaterialization getResultMaterialization() {\n+    return resultMaterialization;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(\n+        builder.withKsqlConfig(builder.getKsqlConfig())", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\nindex 5b8a2a880e..af9dbe16a0 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n\n@@ -18,13 +18,13 @@ package io.confluent.ksql.planner.plan;\n import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n import io.confluent.ksql.execution.context.QueryContext;\n import io.confluent.ksql.name.SourceName;\n-import io.confluent.ksql.parser.ResultMaterialization;\n import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.serde.RefinementInfo;\n import io.confluent.ksql.structured.SchemaKStream;\n import io.confluent.ksql.structured.SchemaKTable;\n+import io.confluent.ksql.util.KsqlException;\n import java.util.Objects;\n \n-import io.confluent.ksql.util.KsqlException;\n \n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5NTIyNQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453095225", "bodyText": "schemaKStream.toString() doesn't seem to be very helpful - it'll probably give us something like SchemaKStream@[b1234. I know I originally asked you to put this in, but I'm not actually sure what name we could put here that would be meaningful - we can change it back to just Expected to find a Table but found a stream", "author": "agavra", "createdAt": "2020-07-10T21:57:58Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Objects;\n+\n+import io.confluent.ksql.util.KsqlException;\n+\n+\n+/**\n+ The suppress node is a plan node that is added to the logical plan if the user specifies in their\n+ ksqlDB query that the result materialization should be EMIT FINAL. The physical plan is then built\n+ and executed using the logical plan, and executes all of the plan nodes that were added from the\n+ logical plan including the suppress node if it was added. Currently the suppress node needs to be\n+ added at the end of the logical plan right before we build the output node, this is so that we can\n+ suppress results that may need to be aggregated or altered somehow. Using a suppress node also\n+ allows for more flexibility in the future in terms of enhancements or different types of\n+ suppression being supported.\n+ */\n+public class SuppressNode extends SingleSourcePlanNode implements VerifiableNode {\n+\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final ResultMaterialization resultMaterialization\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.resultMaterialization = Objects.requireNonNull(\n+        resultMaterialization, \"resultMaterialization\");\n+  }\n+\n+  public ResultMaterialization getResultMaterialization() {\n+    return resultMaterialization;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(\n+        builder.withKsqlConfig(builder.getKsqlConfig())\n+    );\n+\n+    if (!(schemaKStream instanceof SchemaKTable)) {\n+      throw new KsqlException(\"Failed to build suppress node. Expected to find a Table, but \"\n+          + \"found a stream named \" + schemaKStream.toString() + \" instead.\");", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\nindex 5b8a2a880e..af9dbe16a0 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n\n@@ -18,13 +18,13 @@ package io.confluent.ksql.planner.plan;\n import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n import io.confluent.ksql.execution.context.QueryContext;\n import io.confluent.ksql.name.SourceName;\n-import io.confluent.ksql.parser.ResultMaterialization;\n import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.serde.RefinementInfo;\n import io.confluent.ksql.structured.SchemaKStream;\n import io.confluent.ksql.structured.SchemaKTable;\n+import io.confluent.ksql.util.KsqlException;\n import java.util.Objects;\n \n-import io.confluent.ksql.util.KsqlException;\n \n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5NzY2OQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453097669", "bodyText": "we should delegate the the source node and call source.validateKeyPresent(sinkName) (we'll have to assert that source is instance of VerifiableNode and then cast it)", "author": "agavra", "createdAt": "2020-07-10T22:03:18Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Objects;\n+\n+import io.confluent.ksql.util.KsqlException;\n+\n+\n+/**\n+ The suppress node is a plan node that is added to the logical plan if the user specifies in their\n+ ksqlDB query that the result materialization should be EMIT FINAL. The physical plan is then built\n+ and executed using the logical plan, and executes all of the plan nodes that were added from the\n+ logical plan including the suppress node if it was added. Currently the suppress node needs to be\n+ added at the end of the logical plan right before we build the output node, this is so that we can\n+ suppress results that may need to be aggregated or altered somehow. Using a suppress node also\n+ allows for more flexibility in the future in terms of enhancements or different types of\n+ suppression being supported.\n+ */\n+public class SuppressNode extends SingleSourcePlanNode implements VerifiableNode {\n+\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final ResultMaterialization resultMaterialization\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.resultMaterialization = Objects.requireNonNull(\n+        resultMaterialization, \"resultMaterialization\");\n+  }\n+\n+  public ResultMaterialization getResultMaterialization() {\n+    return resultMaterialization;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(\n+        builder.withKsqlConfig(builder.getKsqlConfig())\n+    );\n+\n+    if (!(schemaKStream instanceof SchemaKTable)) {\n+      throw new KsqlException(\"Failed to build suppress node. Expected to find a Table, but \"\n+          + \"found a stream named \" + schemaKStream.toString() + \" instead.\");\n+    }\n+\n+    return (((SchemaKTable<?>) schemaKStream)\n+        .suppress(\n+            resultMaterialization,\n+            contextStacker\n+        ));\n+  }\n+\n+  @Override\n+  public void validateKeyPresent(final SourceName sinkName) {", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\nindex 5b8a2a880e..af9dbe16a0 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n\n@@ -18,13 +18,13 @@ package io.confluent.ksql.planner.plan;\n import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n import io.confluent.ksql.execution.context.QueryContext;\n import io.confluent.ksql.name.SourceName;\n-import io.confluent.ksql.parser.ResultMaterialization;\n import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.serde.RefinementInfo;\n import io.confluent.ksql.structured.SchemaKStream;\n import io.confluent.ksql.structured.SchemaKTable;\n+import io.confluent.ksql.util.KsqlException;\n import java.util.Objects;\n \n-import io.confluent.ksql.util.KsqlException;\n \n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwMDg2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453100865", "bodyText": "we might want to make this test a window aggregation, we probably actually want to fail in this scenario in the logical planner and throw \"EMIT FINAL is only supported for windowed aggregations\" until (if) we support non-windowed suppressed", "author": "agavra", "createdAt": "2020-07-10T22:13:51Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java", "diffHunk": "@@ -132,6 +134,17 @@ public void testSimpleLeftJoinFilterLogicalPlan() {\n     assertThat(rightSource.getSources().get(0), instanceOf(RepartitionNode.class));\n   }\n \n+  @Test\n+  public void testSimpleSuppressLogicalPlan() {\n+    final String simpleQuery = \"SELECT * FROM test2 EMIT FINAL;\";", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java\nindex 6ceaea0100..517b97514e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java\n\n@@ -135,16 +138,17 @@ public class LogicalPlannerTest {\n   }\n \n   @Test\n-  public void testSimpleSuppressLogicalPlan() {\n-    final String simpleQuery = \"SELECT * FROM test2 EMIT FINAL;\";\n+  public void testSuppressLogicalPlan() {\n+    final String simpleQuery = \"SELECT col1,COUNT(*) as COUNT FROM test2 WINDOW TUMBLING (SIZE 2 MILLISECONDS, GRACE PERIOD 1 MILLISECONDS) GROUP BY col1 EMIT FINAL;\";\n     final PlanNode logicalPlan = buildLogicalPlan(simpleQuery);\n \n     assertThat(logicalPlan.getSources().get(0), instanceOf(SuppressNode.class));\n-    assertThat(logicalPlan.getSources().get(0).getSources().get(0), instanceOf(ProjectNode.class));\n+    assertThat(logicalPlan.getSources().get(0).getSources().get(0), instanceOf(AggregateNode.class));\n     assertThat(logicalPlan.getSources().get(0).getSources().get(0).getSources().get(0), instanceOf(DataSourceNode.class));\n-    assertThat(logicalPlan.getSchema().value().size(), equalTo( 5));\n-    Assert.assertNotNull(((SuppressNode) logicalPlan.getSources().get(0)).getResultMaterialization());\n+    assertThat(logicalPlan.getSchema().value().size(), equalTo( 2));\n+    Assert.assertNotNull(((SuppressNode) logicalPlan.getSources().get(0)).getRefinementInfo());\n   }\n+\n   private static SelectExpression selectCol(final String column, final String alias) {\n     return SelectExpression.of(\n         ColumnName.of(alias),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyNDk3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453124976", "bodyText": "these should be in the //Given section. I know it says \"when\" but for the Given/When/Then pattern, the \"When\" should be the functionality that we are testing, the \"Given\" should be the setup required to test that, and the \"Then\" should be assertions", "author": "agavra", "createdAt": "2020-07-10T23:53:47Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import static io.confluent.ksql.metastore.model.DataSource.DataSourceType;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+\n+import static org.mockito.Mockito.when;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext.Stacker;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+public class SuppressNodeTest {\n+\n+  private static final PlanNodeId NODE_ID = new PlanNodeId(\"nodeid\");\n+\n+  @Mock\n+  private ResultMaterialization resultMaterialization;\n+  @Mock\n+  private PlanNode sourceNode;\n+  @Mock\n+  private SchemaKStream schemaKStream;\n+  @Mock\n+  private SchemaKTable schemaKTable;\n+  @Mock\n+  private KsqlQueryBuilder ksqlStreamBuilder;\n+  @Mock\n+  private Stacker stacker;\n+\n+  private SuppressNode node;\n+\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void shouldThrowOnSuppressOnStream() {\n+\n+    // When:\n+    when(sourceNode.getSchema()).thenReturn(LogicalSchema.builder().build());\n+    when(sourceNode.buildStream(any()))\n+        .thenReturn(schemaKStream);\n+    when(sourceNode.getNodeOutputType()).thenReturn(DataSourceType.KSTREAM);\n+    when(schemaKTable.suppress(any(), any()))\n+        .thenReturn(schemaKTable);", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java\nindex cd4c40d0ce..7bcb32c522 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java\n\n@@ -21,16 +21,15 @@ import static org.hamcrest.Matchers.containsString;\n import static org.junit.Assert.assertThrows;\n import static org.mockito.ArgumentMatchers.any;\n \n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n import io.confluent.ksql.execution.context.QueryContext.Stacker;\n-import io.confluent.ksql.parser.ResultMaterialization;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.parser.OutputRefinement;\n+import io.confluent.ksql.serde.RefinementInfo;\n import io.confluent.ksql.structured.SchemaKTable;\n import io.confluent.ksql.util.KsqlException;\n-import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n import org.mockito.Mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyNTA1Nw==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453125057", "bodyText": "we should have a test that ensures SchemaKStream#suppress is called when buildStream is called on a SuppressNode (you can use Mockito#verify for that)", "author": "agavra", "createdAt": "2020-07-10T23:54:22Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import static io.confluent.ksql.metastore.model.DataSource.DataSourceType;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+\n+import static org.mockito.Mockito.when;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext.Stacker;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+public class SuppressNodeTest {\n+\n+  private static final PlanNodeId NODE_ID = new PlanNodeId(\"nodeid\");\n+\n+  @Mock\n+  private ResultMaterialization resultMaterialization;\n+  @Mock\n+  private PlanNode sourceNode;\n+  @Mock\n+  private SchemaKStream schemaKStream;\n+  @Mock\n+  private SchemaKTable schemaKTable;\n+  @Mock\n+  private KsqlQueryBuilder ksqlStreamBuilder;\n+  @Mock\n+  private Stacker stacker;\n+\n+  private SuppressNode node;\n+\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void shouldThrowOnSuppressOnStream() {", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java\nindex cd4c40d0ce..7bcb32c522 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java\n\n@@ -21,16 +21,15 @@ import static org.hamcrest.Matchers.containsString;\n import static org.junit.Assert.assertThrows;\n import static org.mockito.ArgumentMatchers.any;\n \n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n import io.confluent.ksql.execution.context.QueryContext.Stacker;\n-import io.confluent.ksql.parser.ResultMaterialization;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n-import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.parser.OutputRefinement;\n+import io.confluent.ksql.serde.RefinementInfo;\n import io.confluent.ksql.structured.SchemaKTable;\n import io.confluent.ksql.util.KsqlException;\n-import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n import org.mockito.Mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyNTUyNg==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453125526", "bodyText": "for extensibility, we might want to wrap this in a Refinement class that we introduce. Imagine in the future we want to add a EMIT EVERY N SECONDS, the result materialization would be parameterized so an enum wouldn't fly. We could have the ResultMaterialization be TIMED and then have the refinement specify the time interval.\nin general, having enums in model classes is a little bit of an anti-pattern because they're tough to evolve in a backwards compatible way\nalso not your fault, but materialization is a super overloaded word \ud83d\ude22 it might be nice to change this to outputRefinement sooner rather than later (especially in the physical plan, where this stuff gets persisted into our API and can't change easily) so that the terminology is easier to understand", "author": "agavra", "createdAt": "2020-07-10T23:56:47Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/TableSuppress.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License; you may not use this file\n+ * except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.errorprone.annotations.Immutable;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+@Immutable\n+public class TableSuppress<K> implements ExecutionStep<KTableHolder<K>> {\n+\n+  private final ExecutionStepPropertiesV1 properties;\n+  private final ExecutionStep<KTableHolder<K>> source;\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public TableSuppress(\n+      @JsonProperty(value = \"properties\", required = true) final ExecutionStepPropertiesV1 props,\n+      @JsonProperty(value = \"source\", required = true) final ExecutionStep<KTableHolder<K>> source,\n+      @JsonProperty(value = \"resultMaterialization\",\n+          required = true) final ResultMaterialization resultMaterialization", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "chunk": "diff --git a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/TableSuppress.java b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/TableSuppress.java\nindex 872dcfc069..aa50a1a67c 100644\n--- a/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/TableSuppress.java\n+++ b/ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/TableSuppress.java\n\n@@ -17,7 +17,7 @@ package io.confluent.ksql.execution.plan;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.google.errorprone.annotations.Immutable;\n-import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.serde.RefinementInfo;\n \n import java.util.Collections;\n import java.util.List;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyNjQyMA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453126420", "bodyText": "why is there a suppress here?", "author": "agavra", "createdAt": "2020-07-11T00:01:19Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.execution.plan.KTableHolder;\n+import io.confluent.ksql.util.KsqlException;\n+\n+public final class TableSuppressBuilder {\n+\n+  private TableSuppressBuilder() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "chunk": "diff --git a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java\nindex 3df0554dca..37f6351a52 100644\n--- a/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java\n+++ b/ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java\n\n@@ -23,7 +23,6 @@ public final class TableSuppressBuilder {\n   private TableSuppressBuilder() {\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   public static <K> KTableHolder<K> build(\n       final KTableHolder<K> table\n   ) {\n"}}, {"oid": "9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "url": "https://github.com/confluentinc/ksql/commit/9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "message": "test: add RefinementInfo tests", "committedDate": "2020-07-16T23:35:47Z", "type": "forcePushed"}, {"oid": "23c674efbeef3235565b403424c90a58245eb3ee", "url": "https://github.com/confluentinc/ksql/commit/23c674efbeef3235565b403424c90a58245eb3ee", "message": "feat: add suppress node", "committedDate": "2020-07-17T00:19:24Z", "type": "commit"}, {"oid": "647d4e62363caa4f40a2ca9461c19303a2ae1060", "url": "https://github.com/confluentinc/ksql/commit/647d4e62363caa4f40a2ca9461c19303a2ae1060", "message": "chore: trim redundant condition", "committedDate": "2020-07-17T00:19:24Z", "type": "commit"}, {"oid": "6303bc5c157a4637a1f6f5f5ee08af2444ec6bed", "url": "https://github.com/confluentinc/ksql/commit/6303bc5c157a4637a1f6f5f5ee08af2444ec6bed", "message": "fix: correct license year, remove redundancy in schema resolver", "committedDate": "2020-07-17T00:19:24Z", "type": "commit"}, {"oid": "f858f8700bf32429fa139fb162b9fa74604a5cdb", "url": "https://github.com/confluentinc/ksql/commit/f858f8700bf32429fa139fb162b9fa74604a5cdb", "message": "test: add unit tests for suppress node", "committedDate": "2020-07-17T00:21:34Z", "type": "commit"}, {"oid": "b55a19eb3ea906100a6fb762d2c702d5e4fa7083", "url": "https://github.com/confluentinc/ksql/commit/b55a19eb3ea906100a6fb762d2c702d5e4fa7083", "message": "feat: add refinementInfo wrapper", "committedDate": "2020-07-17T00:21:34Z", "type": "commit"}, {"oid": "1e0f2baf0cbfb03eac911a2685d31ada6b773e9e", "url": "https://github.com/confluentinc/ksql/commit/1e0f2baf0cbfb03eac911a2685d31ada6b773e9e", "message": "test: fix tests for refinement", "committedDate": "2020-07-17T00:21:34Z", "type": "commit"}, {"oid": "7237084ecd2766b7b64883f99e3601bd1e5c290f", "url": "https://github.com/confluentinc/ksql/commit/7237084ecd2766b7b64883f99e3601bd1e5c290f", "message": "test: add RefinementInfo tests", "committedDate": "2020-07-17T00:21:34Z", "type": "commit"}, {"oid": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "url": "https://github.com/confluentinc/ksql/commit/67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "message": "chore: remove comments and fix nits", "committedDate": "2020-07-17T00:21:34Z", "type": "commit"}, {"oid": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "url": "https://github.com/confluentinc/ksql/commit/67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "message": "chore: remove comments and fix nits", "committedDate": "2020-07-17T00:21:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE2Mzc2NA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456163764", "bodyText": "I'm confused, why is the OutputRefinement an optional? I feel like if you have a RefinementInfo it should have an OutputRefinement", "author": "agavra", "createdAt": "2020-07-17T01:14:14Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/serde/RefinementInfo.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.errorprone.annotations.Immutable;\n+import io.confluent.ksql.parser.OutputRefinement;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * Immutable pojo for storing info about a refinement.\n+ */\n+@Immutable\n+public final class RefinementInfo {\n+\n+  private final Optional<OutputRefinement> outputRefinement;\n+\n+  @JsonCreator\n+  public static RefinementInfo of(\n+      @JsonProperty(value = \"outputRefinement\", required = true)\n+      final Optional<OutputRefinement> outputRefinement", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "494261eb5b39052e8056115526d513d108c7a1d3", "chunk": "diff --git a/ksqldb-common/src/main/java/io/confluent/ksql/serde/RefinementInfo.java b/ksqldb-common/src/main/java/io/confluent/ksql/serde/RefinementInfo.java\nindex 669eda7a7c..e65fa12e0e 100644\n--- a/ksqldb-common/src/main/java/io/confluent/ksql/serde/RefinementInfo.java\n+++ b/ksqldb-common/src/main/java/io/confluent/ksql/serde/RefinementInfo.java\n\n@@ -21,7 +21,6 @@ import com.google.errorprone.annotations.Immutable;\n import io.confluent.ksql.parser.OutputRefinement;\n \n import java.util.Objects;\n-import java.util.Optional;\n \n /**\n  * Immutable pojo for storing info about a refinement.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE2NDI2NA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456164264", "bodyText": "this is an awesome tool to use for testing! you probably don't need each equality group to have the same thing twice though. If the first equality group has something twice it's testing \"if the same object is .equals with itself, does it return true?\" - you only need to test that once.", "author": "agavra", "createdAt": "2020-07-17T01:15:49Z", "path": "ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde;\n+\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+\n+import com.google.common.testing.EqualsTester;\n+import com.google.common.testing.NullPointerTester;\n+import java.util.Optional;\n+\n+import io.confluent.ksql.parser.OutputRefinement;\n+import org.junit.Test;\n+\n+public class RefinementInfoTest {\n+  @Test\n+  public void shouldThrowNPEs() {\n+    new NullPointerTester()\n+        .testAllPublicStaticMethods(RefinementInfo.class);\n+  }\n+\n+  @Test\n+  public void shouldImplementEquals() {\n+    new EqualsTester()", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "494261eb5b39052e8056115526d513d108c7a1d3", "chunk": "diff --git a/ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java b/ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java\nindex 3a7cad374a..0d4c815333 100644\n--- a/ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java\n+++ b/ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java\n\n@@ -38,16 +38,11 @@ public class RefinementInfoTest {\n   public void shouldImplementEquals() {\n     new EqualsTester()\n         .addEqualityGroup(\n-            RefinementInfo.of(Optional.of(OutputRefinement.FINAL)),\n-            RefinementInfo.of(Optional.of(OutputRefinement.FINAL))\n+            RefinementInfo.of(OutputRefinement.FINAL),\n+            RefinementInfo.of(OutputRefinement.FINAL)\n         )\n         .addEqualityGroup(\n-            RefinementInfo.of(Optional.of(OutputRefinement.CHANGES)),\n-            RefinementInfo.of(Optional.of(OutputRefinement.CHANGES))\n-        )\n-        .addEqualityGroup(\n-            RefinementInfo.of(Optional.empty()),\n-            RefinementInfo.of(Optional.empty())\n+            RefinementInfo.of(OutputRefinement.CHANGES)\n         )\n         .testEquals();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE2NDQ2MQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456164461", "bodyText": "in my opinion, this test doesn't really add much - testing getters/setters is usually too much testing (which I think is a real thing!)", "author": "agavra", "createdAt": "2020-07-17T01:16:24Z", "path": "ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde;\n+\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+\n+import com.google.common.testing.EqualsTester;\n+import com.google.common.testing.NullPointerTester;\n+import java.util.Optional;\n+\n+import io.confluent.ksql.parser.OutputRefinement;\n+import org.junit.Test;\n+\n+public class RefinementInfoTest {\n+  @Test\n+  public void shouldThrowNPEs() {\n+    new NullPointerTester()\n+        .testAllPublicStaticMethods(RefinementInfo.class);\n+  }\n+\n+  @Test\n+  public void shouldImplementEquals() {\n+    new EqualsTester()\n+        .addEqualityGroup(\n+            RefinementInfo.of(Optional.of(OutputRefinement.FINAL)),\n+            RefinementInfo.of(Optional.of(OutputRefinement.FINAL))\n+        )\n+        .addEqualityGroup(\n+            RefinementInfo.of(Optional.of(OutputRefinement.CHANGES)),\n+            RefinementInfo.of(Optional.of(OutputRefinement.CHANGES))\n+        )\n+        .addEqualityGroup(\n+            RefinementInfo.of(Optional.empty()),\n+            RefinementInfo.of(Optional.empty())\n+        )\n+        .testEquals();\n+  }\n+\n+  @Test\n+  public void shouldImplementToString() {\n+    // Given:\n+    final RefinementInfo refinementInfo = RefinementInfo.of(Optional.of(OutputRefinement.FINAL));\n+\n+    // When:\n+    final String result = refinementInfo.toString();\n+\n+    // Then:\n+    assertThat(result, containsString(\"FINAL\"));\n+  }\n+\n+  @Test\n+  public void shouldGetOutputRefinement() {", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "494261eb5b39052e8056115526d513d108c7a1d3", "chunk": "diff --git a/ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java b/ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java\nindex 3a7cad374a..0d4c815333 100644\n--- a/ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java\n+++ b/ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java\n\n@@ -38,16 +38,11 @@ public class RefinementInfoTest {\n   public void shouldImplementEquals() {\n     new EqualsTester()\n         .addEqualityGroup(\n-            RefinementInfo.of(Optional.of(OutputRefinement.FINAL)),\n-            RefinementInfo.of(Optional.of(OutputRefinement.FINAL))\n+            RefinementInfo.of(OutputRefinement.FINAL),\n+            RefinementInfo.of(OutputRefinement.FINAL)\n         )\n         .addEqualityGroup(\n-            RefinementInfo.of(Optional.of(OutputRefinement.CHANGES)),\n-            RefinementInfo.of(Optional.of(OutputRefinement.CHANGES))\n-        )\n-        .addEqualityGroup(\n-            RefinementInfo.of(Optional.empty()),\n-            RefinementInfo.of(Optional.empty())\n+            RefinementInfo.of(OutputRefinement.CHANGES)\n         )\n         .testEquals();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE2OTk1Nw==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456169957", "bodyText": "super-nit: this should be IllegalStateException - meaning something happened that is the server's fault but shouldn't happen. IllegalArgumentException is usually reserved for the user passing in a bad argument. I do realize this is what KsqlStructuredOutputNode does, but I think it's wrong \ud83d\ude02", "author": "agavra", "createdAt": "2020-07-17T01:36:36Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.serde.RefinementInfo;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.Objects;\n+\n+\n+\n+/**\n+ The suppress node is a plan node that is added to the logical plan if the user specifies in their\n+ ksqlDB query that the result materialization should be EMIT FINAL. The physical plan is then built\n+ and executed using the logical plan, and executes all of the plan nodes that were added from the\n+ logical plan including the suppress node if it was added. Currently the suppress node needs to be\n+ added at the end of the logical plan right before we build the output node, this is so that we can\n+ suppress results that may need to be aggregated or altered somehow. Using a suppress node also\n+ allows for more flexibility in the future in terms of enhancements or different types of\n+ suppression being supported.\n+ */\n+public class SuppressNode extends SingleSourcePlanNode implements VerifiableNode {\n+\n+  private final RefinementInfo refinementInfo;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final RefinementInfo refinementInfo\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.refinementInfo = Objects.requireNonNull(\n+        refinementInfo, \"refinementInfo\");\n+  }\n+\n+  public RefinementInfo getRefinementInfo() {\n+    return refinementInfo;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(builder);\n+\n+    if (!(schemaKStream instanceof SchemaKTable)) {\n+      throw new KsqlException(\"Failed in suppress node. Expected to find a Table, but \"\n+          + \"found a stream instead.\");\n+    }\n+\n+\n+    return (((SchemaKTable<?>) schemaKStream)\n+        .suppress(\n+            refinementInfo,\n+            contextStacker\n+        ));\n+  }\n+\n+  @Override\n+  public void validateKeyPresent(final SourceName sinkName) {\n+    if (!(this.getSource() instanceof VerifiableNode)) {\n+      throw new IllegalArgumentException(\"VerifiableNode required\");", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "494261eb5b39052e8056115526d513d108c7a1d3", "chunk": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\nindex af9dbe16a0..4ab8e27970 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java\n\n@@ -82,7 +82,7 @@ public class SuppressNode extends SingleSourcePlanNode implements VerifiableNode\n   @Override\n   public void validateKeyPresent(final SourceName sinkName) {\n     if (!(this.getSource() instanceof VerifiableNode)) {\n-      throw new IllegalArgumentException(\"VerifiableNode required\");\n+      throw new IllegalStateException(\"VerifiableNode required\");\n     }\n \n     ((VerifiableNode) this.getSource())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyOTY1MQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456529651", "bodyText": "nit: this method call can be in an @Before method", "author": "agavra", "createdAt": "2020-07-17T15:54:52Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import static io.confluent.ksql.metastore.model.DataSource.DataSourceType;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext.Stacker;\n+import io.confluent.ksql.parser.OutputRefinement;\n+import io.confluent.ksql.serde.RefinementInfo;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+public class SuppressNodeTest {\n+\n+  private static final PlanNodeId NODE_ID = new PlanNodeId(\"nodeid\");\n+\n+  @Mock\n+  private RefinementInfo refinementInfo;\n+  @Mock\n+  private PlanNode sourceNode;\n+  @Mock\n+  private SchemaKTable schemaKTable;\n+  @Mock\n+  private KsqlQueryBuilder ksqlStreamBuilder;\n+  @Mock\n+  private Stacker stacker;\n+\n+  private SuppressNode node;\n+\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void shouldThrowOnSuppressOnStream() {\n+\n+    // Given:\n+    when(sourceNode.getNodeOutputType()).thenReturn(DataSourceType.KSTREAM);\n+    when(ksqlStreamBuilder.buildNodeContext(NODE_ID.toString())).thenReturn(stacker);", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4NzU0NQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456687545", "bodyText": "I don't think I can in this case because the first test requires a stream so that it fails and the second test requires a table so it can succeed, and thus I can't use the @Before to set both up.", "author": "nae701", "createdAt": "2020-07-17T21:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyOTY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5MTI4OA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456691288", "bodyText": "I meant just the second of the two (about the stacker)", "author": "agavra", "createdAt": "2020-07-17T21:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyOTY1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "494261eb5b39052e8056115526d513d108c7a1d3", "chunk": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java\nindex 7bcb32c522..061a0387b6 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java\n\n@@ -24,18 +24,22 @@ import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n+import io.confluent.ksql.analyzer.PullQueryValidator;\n import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n import io.confluent.ksql.execution.context.QueryContext.Stacker;\n import io.confluent.ksql.parser.OutputRefinement;\n import io.confluent.ksql.serde.RefinementInfo;\n import io.confluent.ksql.structured.SchemaKTable;\n import io.confluent.ksql.util.KsqlException;\n+import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.junit.MockitoJUnit;\n import org.mockito.junit.MockitoRule;\n \n+import java.util.Optional;\n+\n public class SuppressNodeTest {\n \n   private static final PlanNodeId NODE_ID = new PlanNodeId(\"nodeid\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1NTYwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456655605", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final Optional<RefinementInfo> refinementInfo;\n          \n          \n            \n                  if (!pullQuery) {\n          \n          \n            \n                    refinementInfo = Optional.of(RefinementInfo.of(outputRefinement));\n          \n          \n            \n                  } else {\n          \n          \n            \n                    refinementInfo = Optional.empty();\n          \n          \n            \n            \n          \n          \n            \n                  }\n          \n          \n            \n                  final Optional<RefinementInfo> refinementInfo = outputRefinement.map(RefinementInfo::of);\n          \n      \n    \n    \n  \n\nThis way we don't duplicate the if (!pullQuery) logic from above and just rely on knowing that if it's a pull query the outputRefinement will already be Optional.empy()", "author": "agavra", "createdAt": "2020-07-17T20:19:06Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/AstBuilder.java", "diffHunk": "@@ -398,34 +399,40 @@ public Query visitQuery(final SqlBaseParser.QueryContext context) {\n \n       final boolean pullQuery = context.EMIT() == null && !buildingPersistentQuery;\n \n-      final Optional<ResultMaterialization> resultMaterialization;\n+      final Optional<OutputRefinement> outputRefinement;\n \n       if (pullQuery) {\n-        resultMaterialization = Optional.empty();\n+        outputRefinement = Optional.empty();\n       } else if (buildingPersistentQuery) {\n-        resultMaterialization = Optional.of(Optional\n+        outputRefinement = Optional.of(Optional\n             .ofNullable(context.resultMaterialization())\n             .map(rm -> rm.FINAL() == null\n-                ? ResultMaterialization.CHANGES\n-                : ResultMaterialization.FINAL\n+                ? OutputRefinement.CHANGES\n+                : OutputRefinement.FINAL\n             )\n-            .orElse(ResultMaterialization.CHANGES));\n+            .orElse(OutputRefinement.CHANGES));\n         // Else must be a push query, which must specify a materialization\n       } else {\n-        resultMaterialization = Optional\n+        outputRefinement = Optional\n             .of(context.resultMaterialization().CHANGES() == null\n-                ? ResultMaterialization.FINAL\n-                : ResultMaterialization.CHANGES\n+                ? OutputRefinement.FINAL\n+                : OutputRefinement.CHANGES\n             );\n       }\n+      final Optional<RefinementInfo> refinementInfo;\n+      if (!pullQuery) {\n+        refinementInfo = Optional.of(RefinementInfo.of(outputRefinement));\n+      } else {\n+        refinementInfo = Optional.empty();\n+\n+      }", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "494261eb5b39052e8056115526d513d108c7a1d3", "chunk": "diff --git a/ksqldb-parser/src/main/java/io/confluent/ksql/parser/AstBuilder.java b/ksqldb-parser/src/main/java/io/confluent/ksql/parser/AstBuilder.java\nindex d872629416..6794572627 100644\n--- a/ksqldb-parser/src/main/java/io/confluent/ksql/parser/AstBuilder.java\n+++ b/ksqldb-parser/src/main/java/io/confluent/ksql/parser/AstBuilder.java\n\n@@ -419,13 +419,7 @@ public class AstBuilder {\n                 : OutputRefinement.CHANGES\n             );\n       }\n-      final Optional<RefinementInfo> refinementInfo;\n-      if (!pullQuery) {\n-        refinementInfo = Optional.of(RefinementInfo.of(outputRefinement));\n-      } else {\n-        refinementInfo = Optional.empty();\n-\n-      }\n+      final Optional<RefinementInfo> refinementInfo = outputRefinement.map(RefinementInfo::of);\n \n \n       final OptionalInt limit = getLimit(context.limitClause());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1NzAzMA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456657030", "bodyText": "this goes back to my comment above that the OutputRefinement inside the RefinementInfo shouldn't be optional - we expect it to be present. If it's possible that it's not present, then we need to check isPresent (which I'm not sure what we'd do if its not)", "author": "agavra", "createdAt": "2020-07-17T20:22:52Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/SqlFormatter.java", "diffHunk": "@@ -127,9 +127,12 @@ protected Void visitQuery(final Query node, final Integer indent) {\n       }\n \n       if (!node.isPullQuery()) {\n-        if (node.getResultMaterialization().isPresent()) {\n+        if (node.getRefinement().isPresent()\n+            && node.getRefinement().get().getOutputRefinement().isPresent()) {\n           append(indent, \"EMIT \");\n-          append(indent, node.getResultMaterialization()\n+          append(indent, node.getRefinement()\n+              .get()\n+              .getOutputRefinement()", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "494261eb5b39052e8056115526d513d108c7a1d3", "chunk": "diff --git a/ksqldb-parser/src/main/java/io/confluent/ksql/parser/SqlFormatter.java b/ksqldb-parser/src/main/java/io/confluent/ksql/parser/SqlFormatter.java\nindex 1b9358848d..6816112a59 100644\n--- a/ksqldb-parser/src/main/java/io/confluent/ksql/parser/SqlFormatter.java\n+++ b/ksqldb-parser/src/main/java/io/confluent/ksql/parser/SqlFormatter.java\n\n@@ -127,13 +127,11 @@ public final class SqlFormatter {\n       }\n \n       if (!node.isPullQuery()) {\n-        if (node.getRefinement().isPresent()\n-            && node.getRefinement().get().getOutputRefinement().isPresent()) {\n+        if (node.getRefinement().isPresent()) {\n           append(indent, \"EMIT \");\n           append(indent, node.getRefinement()\n               .get()\n               .getOutputRefinement()\n-              .get()\n               .toString())\n               .append('\\n');\n         }\n"}}, {"oid": "494261eb5b39052e8056115526d513d108c7a1d3", "url": "https://github.com/confluentinc/ksql/commit/494261eb5b39052e8056115526d513d108c7a1d3", "message": "chore: fix style issues and nits", "committedDate": "2020-07-17T22:32:12Z", "type": "commit"}, {"oid": "dd49ddb7a5bdd24122bfb281713129d0d0d68b16", "url": "https://github.com/confluentinc/ksql/commit/dd49ddb7a5bdd24122bfb281713129d0d0d68b16", "message": "chore: remove unused imports", "committedDate": "2020-07-17T22:35:17Z", "type": "commit"}]}