{"pr_number": 197, "pr_title": "[Port Manager] Add Bulk operation & Integrate with Route/SGM", "pr_createdAt": "2020-05-15T03:59:38Z", "pr_url": "https://github.com/futurewei-cloud/alcor/pull/197", "timeline": [{"oid": "d4cd8321e75a1e55b464c7fb7b63b734f545dd01", "url": "https://github.com/futurewei-cloud/alcor/commit/d4cd8321e75a1e55b464c7fb7b63b734f545dd01", "message": "turn on all UTs of port-manager", "committedDate": "2020-05-15T08:39:50Z", "type": "forcePushed"}, {"oid": "7def1d013cefd389ba278747eaf6b1e7e9ddc748", "url": "https://github.com/futurewei-cloud/alcor/commit/7def1d013cefd389ba278747eaf6b1e7e9ddc748", "message": "batch operations are supported for the creation and update of port", "committedDate": "2020-05-18T11:06:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r427776658", "bodyText": "By sharing the same rollbacks stack, will one port creation failure cause rollback of other ports in the same request?", "author": "xieus", "createdAt": "2020-05-20T06:46:34Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java", "diffHunk": "@@ -115,57 +162,53 @@ public PortStateJson createPortState(String projectId, PortStateJson portStateJs\n         portState.setProjectId(projectId);\n \n         try {\n-            //Verify VPC ID\n-            VpcManagerProxy vpcManagerProxy = new VpcManagerProxy(rollbacks);\n-            executor.runAsync(vpcManagerProxy::verifyVpc, portState);\n+            createPortStateAsync(portState, executor, rollbacks);\n \n-            IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, portState.getProjectId());\n-            if (portState.getFixedIps() == null) {\n-                executor.runAsync(ipManagerProxy::allocateRandomIpAddress, portState);\n-            } else {\n-                executor.runAsync(ipManagerProxy::allocateFixedIpAddress, portState.getFixedIps());\n-            }\n+            //Wait for all async functions to finish\n+            executor.joinAll();\n \n-            //Generate uuid for port\n-            if (portState.getId() == null) {\n-                portState.setId(UUID.randomUUID().toString());\n-            }\n+            //Persist portState\n+            portRepository.addItem(portState);\n+        } catch (Exception e) {\n+            exceptionHandle(executor, rollbacks, e);\n+        }\n \n-            MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n-            if (portState.getMacAddress() == null) {\n-                executor.runAsync(macManagerProxy::allocateRandomMacAddress, portState);\n-            } else {\n-                executor.runAsync(macManagerProxy::allocateFixedMacAddress, portState);\n-            }\n+        LOG.info(\"Create port state success, projectId: {}, PortStateJson: {}\", projectId, portStateJson);\n \n-            //Verify security group\n+        return portStateJson;\n+    }\n+\n+    /**\n+     * Create multiple ports, and call the interfaces of each micro-service according to the\n+     * configuration of the port to create various required resources for all ports.\n+     * If an exception occurs during the creation of multiple ports, we need to roll back\n+     * the resource allocated from each micro-service.\n+     * @param projectId Project the port belongs to\n+     * @param portStateBulkJson Multiple ports configuration\n+     * @return PortStateBulkJson\n+     * @throws Exception Various exceptions that may occur during the create process\n+     */\n+    @Override\n+    public PortStateBulkJson createPortStateBulk(String projectId, PortStateBulkJson portStateBulkJson) throws Exception {\n+        Stack<PortStateRollback> rollbacks = new Stack<>();\n+        AsyncExecutor executor = new AsyncExecutor();\n \n-            //Verify Binding Host ID\n-            if (portState.getBindingHostId() != null) {\n-                NodeManagerProxy nodeManagerProxy = new NodeManagerProxy(rollbacks);\n-                nodeManagerProxy.verifyHost(portState.getBindingHostId());\n+        try {\n+            for (PortState portState: portStateBulkJson.getPortStates()) {\n+                portState.setProjectId(projectId);\n+                createPortStateAsync(portState, executor, rollbacks);", "originalCommit": "7def1d013cefd389ba278747eaf6b1e7e9ddc748", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3ODU2Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r427778566", "bodyText": "Yes, I think for batch creation, if a port creation fails, all operations should be rolled back.", "author": "chenpiaoping", "createdAt": "2020-05-20T06:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc4NDM3Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r427784373", "bodyText": "This is right from customer behavior perspective. On the API reliability side, it may be fragile.\nCan we add one optional parameter for the API, e.g. allow_partial with default value false. Then the default value is what we are right now. When it is set to true, we will return something all port states, including created/updated port states and failed port with exception.", "author": "xieus", "createdAt": "2020-05-20T07:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc4NzM4NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r427787385", "bodyText": "okay, I know what you mean.", "author": "chenpiaoping", "createdAt": "2020-05-20T07:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3ODA0Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430178047", "bodyText": "What does the responsed data look like when we support allow_partial?", "author": "chenpiaoping", "createdAt": "2020-05-26T06:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3OTUwMg==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430179502", "bodyText": "Supporting allow_partial under the current rollback framework may be a bit troublesome, because we don't know which operations need to be rolled back when an exception occurs.", "author": "chenpiaoping", "createdAt": "2020-05-26T06:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIwNTI5OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430205298", "bodyText": "@xieus Regardless of this question, I think this PR is ready to be reviewed.", "author": "chenpiaoping", "createdAt": "2020-05-26T07:21:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgxMzc2OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430813768", "bodyText": "okay then. I will resume the review.", "author": "xieus", "createdAt": "2020-05-27T01:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgxNTk5Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430815996", "bodyText": "What does the responsed data look like when we support allow_partial?\n\nFor the successful ports, we could return its detailed port info.\nFor unsuccessful ones, we could return port_id: error code + detailed exception, something like that.", "author": "xieus", "createdAt": "2020-05-27T01:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1NzY3Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430857676", "bodyText": "Piaoping ~ Have you completed the implementation of port update? When I tested it before, it seemed that the port update API function was not fully completed.", "author": "kevin-zhonghao", "createdAt": "2020-05-27T05:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMDIzNA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430910234", "bodyText": "@kevin-zhonghao only ip addresses can be updated currently.", "author": "chenpiaoping", "createdAt": "2020-05-27T07:26:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg0NDAwMA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434844000", "bodyText": "Use Issue #228 for tracking purpose.", "author": "xieus", "createdAt": "2020-06-03T20:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NjY1OA=="}], "type": "inlineReview", "revised_code": {"commit": "91932144cbb23bb6f1854a0f5d15ea5e06827d84", "chunk": "diff --git a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\nindex dfd7634e8..caedbe461 100644\n--- a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n+++ b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n\n@@ -147,35 +174,43 @@ public class PortServiceImpl implements PortService {\n      * If any exception occurs in the added process, we need to roll back\n      * the resource allocated from each micro-service.\n      * @param projectId Project the port belongs to\n-     * @param portStateJson Port configuration\n-     * @return PortStateJson\n+     * @param portWebJson Port configuration\n+     * @return PortWebJson\n      * @throws Exception Various exceptions that may occur during the create process\n      */\n     @Override\n-    public PortStateJson createPortState(String projectId, PortStateJson portStateJson) throws Exception {\n-        LOG.debug(\"Create port state, projectId: {}, PortStateJson: {}\", projectId, portStateJson);\n+    public PortWebJson createPort(String projectId, PortWebJson portWebJson) throws Exception {\n+        LOG.debug(\"Create port state, projectId: {}, PortWebJson: {}\", projectId, portWebJson);\n \n-        Stack<PortStateRollback> rollbacks = new Stack<>();\n+        Stack<Rollback> rollbacks = new Stack<>();\n         AsyncExecutor executor = new AsyncExecutor();\n \n-        PortState portState = portStateJson.getPortState();\n-        portState.setProjectId(projectId);\n+        PortEntity portEntity = portWebJson.getPortEntity();\n+        portEntity.setProjectId(projectId);\n \n         try {\n-            createPortStateAsync(portState, executor, rollbacks);\n+            createPortAsync(portEntity, executor, rollbacks);\n \n             //Wait for all async functions to finish\n-            executor.joinAll();\n+            List<Object> entities = executor.joinAll();\n+            entities.add(portEntity);\n+\n+            //Build GoalState and Send it to DPM\n+            if (portEntity.getBindingHostId() != null) {\n+                Goalstate.GoalState goalState = GoalStateUtil.buildGoalState(entities, Common.OperationType.CREATE);\n+                DataPlaneManagerProxy dataPlaneManagerProxy = new DataPlaneManagerProxy(rollbacks);\n+                dataPlaneManagerProxy.createGoalState(goalState);\n+            }\n \n             //Persist portState\n-            portRepository.addItem(portState);\n+            portRepository.addItem(portEntity);\n         } catch (Exception e) {\n             exceptionHandle(executor, rollbacks, e);\n         }\n \n-        LOG.info(\"Create port state success, projectId: {}, PortStateJson: {}\", projectId, portStateJson);\n+        LOG.info(\"Create port state success, projectId: {}, portWebJson: {}\", projectId, portWebJson);\n \n-        return portStateJson;\n+        return portWebJson;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NzE5NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r427777195", "bodyText": "Bulk APIs are very fancy. Let us add some UTs to cover them :-)", "author": "xieus", "createdAt": "2020-05-20T06:47:48Z", "path": "services/port_manager/src/test/java/com/futurewei/alcor/portmanager/config/UnitTestConfig.java", "diffHunk": "@@ -82,4 +85,42 @@\n             \"        \\\"allowed_address_pairs\\\":[{\\\"ip_address\\\":\\\"\" + ip2 + \"\\\", \\\"mac_address\\\":\\\"\" + mac1 + \"\\\"}]\\n\" +\n             \"    }\\n\" +\n             \"}\";\n+    public static String createPortBulk = \"{\\n\" +", "originalCommit": "7def1d013cefd389ba278747eaf6b1e7e9ddc748", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc4MzMyNw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r427783327", "bodyText": "There are two: createPortBulkTest and updateMacAddressAndFixedIpsBulkTest", "author": "chenpiaoping", "createdAt": "2020-05-20T07:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NzE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc4NTc3Mg==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r427785772", "bodyText": "Oh I see. I didn't find it in this PR. Are they checked in previously?", "author": "xieus", "createdAt": "2020-05-20T07:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NzE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc4NjAxMA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r427786010", "bodyText": "Never mind. Find it now.", "author": "xieus", "createdAt": "2020-05-20T07:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NzE5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "91932144cbb23bb6f1854a0f5d15ea5e06827d84", "chunk": "diff --git a/services/port_manager/src/test/java/com/futurewei/alcor/portmanager/config/UnitTestConfig.java b/services/port_manager/src/test/java/com/futurewei/alcor/portmanager/config/UnitTestConfig.java\nindex 29d84f908..f9bb2824c 100644\n--- a/services/port_manager/src/test/java/com/futurewei/alcor/portmanager/config/UnitTestConfig.java\n+++ b/services/port_manager/src/test/java/com/futurewei/alcor/portmanager/config/UnitTestConfig.java\n\n@@ -78,48 +97,53 @@ public class UnitTestConfig {\n     public static String updateFixedIps = \"{\\n\" +\n             \"    \\\"port\\\": {\\n\" +\n             \"        \\\"id\\\":\\\"\" + portId + \"\\\",\\n\" +\n-            \"        \\\"vpc_id\\\":\\\"\" + vpcId + \"\\\",\\n\" +\n+            \"        \\\"network_id\\\":\\\"\" + vpcId + \"\\\",\\n\" +\n             \"        \\\"tenant_id\\\":\\\"\" + tenantId + \"\\\",\\n\" +\n+            \"        \\\"binding:host_id\\\":\\\"\" + nodeId + \"\\\",\\n\" +\n             \"        \\\"fixed_ips\\\":[{\\\"subnet_id\\\":\\\"\" + subnetId + \"\\\", \\\"ip_address\\\":\\\"\" + ip2 + \"\\\"}],\\n\" +\n-            \"        \\\"security_groups\\\": [\\\"\"+ securityGroup +\"\\\"],\\n\" +\n+            \"        \\\"security_groups\\\": [\\\"\"+ securityGroupId +\"\\\"],\\n\" +\n             \"        \\\"allowed_address_pairs\\\":[{\\\"ip_address\\\":\\\"\" + ip2 + \"\\\", \\\"mac_address\\\":\\\"\" + mac1 + \"\\\"}]\\n\" +\n             \"    }\\n\" +\n             \"}\";\n     public static String createPortBulk = \"{\\n\" +\n             \"    \\\"ports\\\": [{\\n\" +\n             \"        \\\"id\\\":\\\"\" + portId + \"\\\",\\n\" +\n-            \"        \\\"vpc_id\\\":\\\"\" + vpcId + \"\\\",\\n\" +\n+            \"        \\\"network_id\\\":\\\"\" + vpcId + \"\\\",\\n\" +\n             \"        \\\"tenant_id\\\":\\\"\" + tenantId + \"\\\",\\n\" +\n+            \"        \\\"binding:host_id\\\":\\\"\" + nodeId + \"\\\",\\n\" +\n             \"        \\\"fixed_ips\\\":[{\\\"subnet_id\\\":\\\"\" + subnetId + \"\\\", \\\"ip_address\\\":\\\"\" + ip1 + \"\\\"}],\\n\" +\n-            \"        \\\"security_groups\\\": [\\\"\"+ securityGroup +\"\\\"],\\n\" +\n+            \"        \\\"security_groups\\\": [\\\"\"+ securityGroupId +\"\\\"],\\n\" +\n             \"        \\\"allowed_address_pairs\\\":[{\\\"ip_address\\\":\\\"\" + ip2 + \"\\\", \\\"mac_address\\\":\\\"\" + mac1 + \"\\\"}]\\n\" +\n             \"    },{\\n\" +\n             \"        \\\"id\\\":\\\"\" + portId2 + \"\\\",\\n\" +\n-            \"        \\\"vpc_id\\\":\\\"\" + vpcId + \"\\\",\\n\" +\n+            \"        \\\"network_id\\\":\\\"\" + vpcId + \"\\\",\\n\" +\n             \"        \\\"tenant_id\\\":\\\"\" + tenantId + \"\\\",\\n\" +\n+            \"        \\\"binding:host_id\\\":\\\"\" + nodeId + \"\\\",\\n\" +\n             \"        \\\"fixed_ips\\\":[{\\\"subnet_id\\\":\\\"\" + subnetId + \"\\\", \\\"ip_address\\\":\\\"\" + ip2 + \"\\\"}],\\n\" +\n-            \"        \\\"security_groups\\\": [\\\"\"+ securityGroup +\"\\\"],\\n\" +\n+            \"        \\\"security_groups\\\": [\\\"\"+ securityGroupId +\"\\\"],\\n\" +\n             \"        \\\"allowed_address_pairs\\\":[{\\\"ip_address\\\":\\\"\" + ip2 + \"\\\", \\\"mac_address\\\":\\\"\" + mac2 + \"\\\"}]\\n\" +\n             \"    }]\\n\" +\n             \"}\";\n     public static String updatePortBulk = \"{\\n\" +\n             \"    \\\"ports\\\": [{\\n\" +\n             \"        \\\"id\\\":\\\"\" + portId + \"\\\",\\n\" +\n-            \"        \\\"vpc_id\\\":\\\"\" + vpcId + \"\\\",\\n\" +\n+            \"        \\\"network_id\\\":\\\"\" + vpcId + \"\\\",\\n\" +\n             \"        \\\"tenant_id\\\":\\\"\" + tenantId + \"\\\",\\n\" +\n+            \"        \\\"binding:host_id\\\":\\\"\" + nodeId + \"\\\",\\n\" +\n             \"        \\\"mac_address\\\":\\\"\" + mac2 + \"\\\",\\n\" +\n             \"        \\\"binding:host_id\\\":\\\"\" + nodeId2 + \"\\\",\\n\" +\n             \"        \\\"fixed_ips\\\":[{\\\"subnet_id\\\":\\\"\" + subnetId + \"\\\", \\\"ip_address\\\":\\\"\" + ip2 + \"\\\"}],\\n\" +\n-            \"        \\\"security_groups\\\": [\\\"\"+ securityGroup +\"\\\"],\\n\" +\n+            \"        \\\"security_groups\\\": [\\\"\"+ securityGroupId +\"\\\"],\\n\" +\n             \"        \\\"allowed_address_pairs\\\":[{\\\"ip_address\\\":\\\"\" + ip2 + \"\\\", \\\"mac_address\\\":\\\"\" + mac1 + \"\\\"}]\\n\" +\n             \"    },{\\n\" +\n             \"        \\\"id\\\":\\\"\" + portId2 + \"\\\",\\n\" +\n-            \"        \\\"vpc_id\\\":\\\"\" + vpcId + \"\\\",\\n\" +\n+            \"        \\\"network_id\\\":\\\"\" + vpcId + \"\\\",\\n\" +\n             \"        \\\"tenant_id\\\":\\\"\" + tenantId + \"\\\",\\n\" +\n+            \"        \\\"binding:host_id\\\":\\\"\" + nodeId + \"\\\",\\n\" +\n             \"        \\\"mac_address\\\":\\\"\" + mac2 + \"\\\",\\n\" +\n             \"        \\\"binding:host_id\\\":\\\"\" + nodeId2 + \"\\\",\\n\" +\n             \"        \\\"fixed_ips\\\":[{\\\"subnet_id\\\":\\\"\" + subnetId + \"\\\", \\\"ip_address\\\":\\\"\" + ip2 + \"\\\"}],\\n\" +\n-            \"        \\\"security_groups\\\": [\\\"\"+ securityGroup +\"\\\"],\\n\" +\n+            \"        \\\"security_groups\\\": [\\\"\"+ securityGroupId +\"\\\"],\\n\" +\n             \"        \\\"allowed_address_pairs\\\":[{\\\"ip_address\\\":\\\"\" + ip2 + \"\\\", \\\"mac_address\\\":\\\"\" + mac2 + \"\\\"}]\\n\" +\n             \"    }]\\n\" +\n             \"}\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTcyMA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r428459720", "bodyText": "Btw, so Ignite doesn't support a bulk insertion?", "author": "xieus", "createdAt": "2020-05-21T05:56:15Z", "path": "lib/src/main/java/com/futurewei/alcor/common/db/repo/ICacheRepository.java", "diffHunk": "@@ -28,5 +29,7 @@\n \n     void addItem(T newItem) throws CacheException;\n \n+    //void addItems(List<T> items) throws CacheException;", "originalCommit": "7def1d013cefd389ba278747eaf6b1e7e9ddc748", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyNTkzMQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430125931", "bodyText": "Ignite support a bulk insertion,  but if I add this line, all the classes that implement ICacheRepository fail to compile.", "author": "chenpiaoping", "createdAt": "2020-05-26T02:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgxNDYyMg==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430814622", "bodyText": "In that case, we could in a project-wide search for ICacheRepository. Once we turn on the line, we add one missing method for each occurrence and mark them \"Not Implemented\".\nThis is not a urgent matter, but we will need bulk insertion eventually.", "author": "xieus", "createdAt": "2020-05-27T01:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MjA1OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434652058", "bodyText": "@chenpiaoping This will be tracked by Issue #226.", "author": "xieus", "createdAt": "2020-06-03T15:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTcyMA=="}], "type": "inlineReview", "revised_code": {"commit": "93a59b92e1780501be96c5c7511f1fafd6e76a23", "chunk": "diff --git a/lib/src/main/java/com/futurewei/alcor/common/db/repo/ICacheRepository.java b/lib/src/main/java/com/futurewei/alcor/common/db/repo/ICacheRepository.java\nindex 00ce50bf1..f9fa0b0bd 100644\n--- a/lib/src/main/java/com/futurewei/alcor/common/db/repo/ICacheRepository.java\n+++ b/lib/src/main/java/com/futurewei/alcor/common/db/repo/ICacheRepository.java\n\n@@ -29,7 +28,5 @@ public interface ICacheRepository<T> {\n \n     void addItem(T newItem) throws CacheException;\n \n-    //void addItems(List<T> items) throws CacheException;\n-\n     void deleteItem(String id) throws CacheException;\n }\n"}}, {"oid": "5959954f536183668ebc1092a408d295a651e394", "url": "https://github.com/futurewei-cloud/alcor/commit/5959954f536183668ebc1092a408d295a651e394", "message": "rebase from master", "committedDate": "2020-05-26T03:25:10Z", "type": "forcePushed"}, {"oid": "3a171b70ef745b6aa95d7ddc32bcaf2eab34134e", "url": "https://github.com/futurewei-cloud/alcor/commit/3a171b70ef745b6aa95d7ddc32bcaf2eab34134e", "message": "rebase from master", "committedDate": "2020-05-26T04:35:09Z", "type": "forcePushed"}, {"oid": "fe4e219dbe3c5fee2b93f928a7320bb2d2885da9", "url": "https://github.com/futurewei-cloud/alcor/commit/fe4e219dbe3c5fee2b93f928a7320bb2d2885da9", "message": "rebase from master", "committedDate": "2020-05-26T06:37:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTQ1OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430841459", "bodyText": "As the requested RouteManager API is ready (ref:#203), we should be able to add integration with Route Manager now.", "author": "xieus", "createdAt": "2020-05-27T03:47:42Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java", "diffHunk": "@@ -94,6 +96,51 @@ private void addPortToHost(String hostId) {\n         //FIXME: Add port to Host\n     }\n \n+    private void createPortStateAsync(PortState portState, AsyncExecutor executor, Stack<PortStateRollback> rollbacks) throws Exception {", "originalCommit": "fe4e219dbe3c5fee2b93f928a7320bb2d2885da9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwNzQ3NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r432807475", "bodyText": "@RequestMapping(\n        method = GET,\n        value = {\"/subnets/{subnetId}/routes/{routeId}\"})\npublic RouteWebJson getRuleBySubnetId(@PathVariable String subnetId, @PathVariable String routeId) throws Exception {\n\n    RouteEntity routeEntity = null;\n\n    try {\n        RestPreconditionsUtil.verifyParameterNotNullorEmpty(subnetId);\n        RestPreconditionsUtil.verifyParameterNotNullorEmpty(routeId);\n\n        routeEntity = this.routeDatabaseService.getByRouteId(routeId);\n    } catch (ParameterNullOrEmptyException e) {\n        //TODO: REST error code\n        throw new Exception(e);\n    }\n\n    if (routeEntity == null) {\n        //TODO: REST error code\n        return new RouteWebJson();\n    }\n\n    return new RouteWebJson(routeEntity);\n\n}\n\nDoes port manager get the route through this interface? But it requires subnetId and routeId. I thought it just subnetId. Is that right?", "author": "chenpiaoping", "createdAt": "2020-05-30T03:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwOTM2OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r432809369", "bodyText": "@chenpiaoping\nHere is the link to API: \n  \n    \n      alcor/services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouteController.java\n    \n    \n         Line 127\n      in\n      26033d0\n    \n    \n    \n    \n\n        \n          \n           @RequestMapping(", "author": "xieus", "createdAt": "2020-05-30T04:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNTI0NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r432815244", "bodyText": "@chenpiaoping\nHere is the link to API:\n\n  \n    \n      alcor/services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouteController.java\n    \n    \n         Line 127\n      in\n      26033d0\n    \n    \n    \n    \n\n        \n          \n           @RequestMapping( \n        \n    \n  \n\n\n\nYes, this is the same API as the one I posted above. I mean, this API needs to provide two parameters, subnetId and routeId, but port manager can't get the routeId, dose port manager need to provide routeId?", "author": "chenpiaoping", "createdAt": "2020-05-30T06:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxOTY3NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r432819674", "bodyText": "You are right, Piaoping. Reopen issue #203 as unresolved, and add @kevin-zhonghao to take a further look.\nLet us do this quickly. @chenpiaoping, can you add the API in RouteController.java without the implementation, just to unblock yourself to write necessary codes in Port Manager. @kevin-zhonghao or I will implement the API early next week.", "author": "xieus", "createdAt": "2020-05-30T07:37:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwOTY1MA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r433009650", "bodyText": "Don't worry, this won't block me. Just raised it up here.", "author": "chenpiaoping", "createdAt": "2020-06-01T01:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTQ1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "91932144cbb23bb6f1854a0f5d15ea5e06827d84", "chunk": "diff --git a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\nindex 86f7161d5..caedbe461 100644\n--- a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n+++ b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n\n@@ -96,40 +95,68 @@ public class PortServiceImpl implements PortService {\n         //FIXME: Add port to Host\n     }\n \n-    private void createPortStateAsync(PortState portState, AsyncExecutor executor, Stack<PortStateRollback> rollbacks) throws Exception {\n+    private void createPortAsync(PortEntity portEntity, AsyncExecutor executor, Stack<Rollback> rollbacks) throws Exception {\n         //Verify VPC ID\n         VpcManagerProxy vpcManagerProxy = new VpcManagerProxy(rollbacks);\n-        executor.runAsync(vpcManagerProxy::verifyVpc, portState);\n-\n-        IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, portState.getProjectId());\n-        if (portState.getFixedIps() == null) {\n-            executor.runAsync(ipManagerProxy::allocateRandomIpAddress, portState);\n+        executor.runAsync(vpcManagerProxy::getVpcEntity, portEntity);\n+\n+        //Allocate IP address\n+        IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, portEntity.getProjectId());\n+        SubnetManagerProxy subnetManagerProxy = new SubnetManagerProxy(portEntity.getProjectId());\n+        if (portEntity.getFixedIps() != null) {\n+            for (PortEntity.FixedIp fixedIp: portEntity.getFixedIps()) {\n+                executor.runAsyncThenAccept(subnetManagerProxy::getSubnetEntity,\n+                        ipManagerProxy::allocateFixedIpAddress,\n+                        fixedIp, fixedIp);\n+            }\n         } else {\n-            executor.runAsync(ipManagerProxy::allocateFixedIpAddress, portState.getFixedIps());\n+            executor.runAsyncThenApply(ipManagerProxy::allocateRandomIpAddress,\n+                    subnetManagerProxy::getSubnetEntity,\n+                    portEntity);\n         }\n \n         //Generate uuid for port\n-        if (portState.getId() == null) {\n-            portState.setId(UUID.randomUUID().toString());\n+        if (portEntity.getId() == null) {\n+            portEntity.setId(UUID.randomUUID().toString());\n         }\n \n+        //Allocate MAC address\n         MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n-        if (portState.getMacAddress() == null) {\n-            executor.runAsync(macManagerProxy::allocateRandomMacAddress, portState);\n+        if (portEntity.getMacAddress() == null) {\n+            executor.runAsync(macManagerProxy::allocateRandomMacAddress, portEntity);\n+        } else {\n+            executor.runAsync(macManagerProxy::allocateFixedMacAddress, portEntity);\n+        }\n+\n+        //Verify and bind security group\n+        SecurityGroupManagerProxy securityGroupManagerProxy = new SecurityGroupManagerProxy(portEntity.getProjectId());\n+        if (portEntity.getSecurityGroups() != null) {\n+            for (String securityGroupId: portEntity.getSecurityGroups()) {\n+                executor.runAsync(securityGroupManagerProxy::getSecurityGroupEntity, securityGroupId);\n+                executor.runAsync(securityGroupManagerProxy::bindSecurityGroup, portEntity);\n+            }\n         } else {\n-            executor.runAsync(macManagerProxy::allocateFixedMacAddress, portState);\n+            //Do we need to bind default security group? No, we don't\n+            executor.runAsync(securityGroupManagerProxy::getDefaultSecurityGroupEntity, portEntity);\n         }\n \n-        //Verify security group\n+        //Get subnet route\n+        if (portEntity.getFixedIps() != null) {\n+            RouteManagerProxy routeManagerProxy = new RouteManagerProxy(rollbacks);\n+\n+            for (PortEntity.FixedIp fixedIp: portEntity.getFixedIps()) {\n+                executor.runAsync(routeManagerProxy::getRouteBySubnetId, fixedIp.getSubnetId());\n+            }\n+        }\n \n         //Verify Binding Host ID\n-        if (portState.getBindingHostId() != null) {\n+        if (portEntity.getBindingHostId() != null) {\n             NodeManagerProxy nodeManagerProxy = new NodeManagerProxy(rollbacks);\n-            executor.runAsync(nodeManagerProxy::verifyHost, portState.getBindingHostId());\n+            executor.runAsync(nodeManagerProxy::getNodeInfo, portEntity.getBindingHostId());\n         }\n     }\n \n-    private void exceptionHandle(AsyncExecutor executor, Stack<PortStateRollback> rollbacks, Exception e) throws Exception {\n+    private void exceptionHandle(AsyncExecutor executor, Stack<Rollback> rollbacks, Exception e) throws Exception {\n         /**\n          When an exception occurs, we need to roll back all asynchronous operations,\n          and some asynchronous may not be finished yet.if we roll back at this time,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTk2Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430841967", "bodyText": "Is update port implementation completed?", "author": "xieus", "createdAt": "2020-05-27T03:49:59Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java", "diffHunk": "@@ -247,6 +290,68 @@ private void updatePortToHost(PortState portState) {\n \n     }\n \n+    private void updatePortStateAsync(PortState portState, PortState oldPortState, AsyncExecutor executor,", "originalCommit": "fe4e219dbe3c5fee2b93f928a7320bb2d2885da9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "91932144cbb23bb6f1854a0f5d15ea5e06827d84", "chunk": "diff --git a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\nindex 86f7161d5..caedbe461 100644\n--- a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n+++ b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n\n@@ -262,94 +289,202 @@ public class PortServiceImpl implements PortService {\n         return addFixedIps;\n     }\n \n-    private void updateSecurityGroup(PortState portState, PortState oldPortState) throws Exception {\n-        String deviceOwner = portState.getDeviceOwner();\n-\n-        //Network device interface does not need security groups\n-        if (deviceOwner != null && deviceOwner.indexOf(\"network\") > 0) {\n-            throw new UpdateSecurityGroupException();\n+    private boolean updatePortAsync(PortEntity newPortEntity, PortEntity oldPortEntity, AsyncExecutor executor,\n+                                 Stack<Rollback> rollbacks) throws Exception {\n+        boolean needNotifyDpm = false;\n+        //Update name\n+        String newName = newPortEntity.getName();\n+        String oldName = oldPortEntity.getName();\n+        if (newName != null && !newName.equals(oldName)) {\n+            oldPortEntity.setName(newName);\n         }\n \n-        //Verify request security groups valid\n-        verifySecurityGroup(portState);\n-\n-        //Delete old security groups binding\n-        unbindSecurityGroups(oldPortState);\n+        //Update admin_state\n+        boolean newAdminState = newPortEntity.isAdminStateUp();\n+        boolean oldAdminState = oldPortEntity.isAdminStateUp();\n+        if (newAdminState != oldAdminState) {\n+            oldPortEntity.setAdminStateUp(newAdminState);\n+            needNotifyDpm = true;\n+        }\n \n-        //Create security groups binding for port\n-        bindSecurityGroups(portState);\n+        //Update binding:host_id\n+        String newBindingHostId = newPortEntity.getBindingHostId();\n+        String oldBindingHostId = oldPortEntity.getBindingHostId();\n+        if (newBindingHostId != null && !newBindingHostId.equals(oldBindingHostId)) {\n+            oldPortEntity.setBindingHostId(newBindingHostId);\n+            needNotifyDpm = true;\n+        }\n \n-        oldPortState.setSecurityGroups(portState.getSecurityGroups());\n-    }\n+        //Update binding:profile\n+        String newBindingProfile = newPortEntity.getBindingProfile();\n+        String oldBindingProfile = oldPortEntity.getBindingProfile();\n+        if (newBindingProfile != null && !newBindingProfile.equals(oldBindingProfile)) {\n+            oldPortEntity.setBindingProfile(newBindingProfile);\n+            needNotifyDpm = true;\n+        }\n \n-    private void UpdateExtraDhcpOpts(PortState portState, PortState portStateOld) {\n+        //Update binding:vnic_type\n+        String newBindingVnicType = newPortEntity.getBindingVnicType();\n+        String oldBindingVnicType = oldPortEntity.getBindingVnicType();\n+        if (newBindingVnicType != null && !newBindingVnicType.equals(oldBindingVnicType)) {\n+            oldPortEntity.setBindingVnicType(newBindingVnicType);\n+            needNotifyDpm = true;\n+        }\n \n-    }\n+        //Update description\n+        String newDescription = newPortEntity.getDescription();\n+        String oldDescription = oldPortEntity.getDescription();\n+        if (newDescription != null && !newDescription.equals(oldDescription)) {\n+            oldPortEntity.setDescription(newDescription);\n+        }\n \n-    private void updatePortToHost(PortState portState) {\n+        //Update device_id\n+        String newDeviceId = newPortEntity.getDeviceId();\n+        String oldDeviceId = oldPortEntity.getDeviceId();\n+        if (newDeviceId != null && !newDeviceId.equals(oldDeviceId)) {\n+            oldPortEntity.setDeviceId(newDeviceId);\n+            needNotifyDpm = true;\n+        }\n \n-    }\n+        //Update device_owner\n+        String newDeviceOwner = newPortEntity.getDeviceOwner();\n+        String oldDeviceOwner = oldPortEntity.getDeviceOwner();\n+        if (newDeviceOwner != null && !newDeviceOwner.equals(oldDeviceOwner)) {\n+            oldPortEntity.setDeviceOwner(newDeviceOwner);\n+        }\n \n-    private void updatePortStateAsync(PortState portState, PortState oldPortState, AsyncExecutor executor,\n-                                      Stack<PortStateRollback> rollbacks) throws Exception {\n-        //Update mac_address\n-        String macAddress = portState.getMacAddress();\n-        String oldMacAddress = oldPortState.getMacAddress();\n-        if (macAddress != null && !oldMacAddress.equals(macAddress)) {\n-            MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n-            executor.runAsync(macManagerProxy::releaseMacAddress, oldPortState);\n-            executor.runAsync(macManagerProxy::allocateFixedMacAddress, portState);\n-            oldPortState.setMacAddress(macAddress);\n+        //Update dns_domain\n+        String newDnsDomain = newPortEntity.getDnsDomain();\n+        String oldDnsDomain = oldPortEntity.getDnsDomain();\n+        if (newDnsDomain != null && !newDnsDomain.equals(oldDnsDomain)) {\n+            oldPortEntity.setDnsDomain(newDnsDomain);\n+            needNotifyDpm = true;\n         }\n \n-        //Update device_owner and device_id\n-        String deviceOwnerNew = portState.getDeviceOwner();\n-        String deviceIdNew = portState.getDeviceId();\n-        String deviceIdOld = oldPortState.getDeviceId();\n-        String tenantId = oldPortState.getTenantId();\n+        //Update dns_name\n+        String newDnsName = newPortEntity.getDnsName();\n+        String oldDnsName = oldPortEntity.getDnsName();\n+        if (newDnsName != null && !newDnsName.equals(oldDnsName)) {\n+            oldPortEntity.setDnsName(newDnsName);\n+            needNotifyDpm = true;\n+        }\n \n-        if (deviceOwnerNew != null && deviceIdNew != null && !deviceIdNew.equals(deviceIdOld)) {\n-            if (DeviceOwner.ROUTER.getOwner().equals(deviceOwnerNew)) {\n-                verifyRouter(deviceIdNew, tenantId);\n-            }\n+        //Update dns_name\n+        List<PortEntity.ExtraDhcpOpt> newExtraDhcpOpts = newPortEntity.getExtraDhcpOpts();\n+        List<PortEntity.ExtraDhcpOpt> oldExtraDhcpOpts = oldPortEntity.getExtraDhcpOpts();\n+        if (newExtraDhcpOpts != null && !newExtraDhcpOpts.equals(oldExtraDhcpOpts)) {\n+            oldPortEntity.setExtraDhcpOpts(newExtraDhcpOpts);\n+            needNotifyDpm = true;\n         }\n \n         //Update fixed_ips\n-        List<PortState.FixedIp> fixedIps = portState.getFixedIps();\n-        IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, portState.getProjectId());\n-\n-        if (fixedIps != null) {\n-            List<PortState.FixedIp> oldFixedIps = oldPortState.getFixedIps();\n-\n-            List<PortState.FixedIp> addFixedIps = fixedIpsCompare(fixedIps, oldFixedIps);\n-            List<PortState.FixedIp> delFixedIps = fixedIpsCompare(oldFixedIps, fixedIps);\n+        List<PortEntity.FixedIp> newFixedIps = newPortEntity.getFixedIps();\n+        List<PortEntity.FixedIp> oldFixedIps = oldPortEntity.getFixedIps();\n+        if (newFixedIps != null && !newFixedIps.equals(oldFixedIps)) {\n+            List<PortEntity.FixedIp> addFixedIps = fixedIpsCompare(newFixedIps, oldFixedIps);\n+            List<PortEntity.FixedIp> delFixedIps = fixedIpsCompare(oldFixedIps, newFixedIps);\n+            IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, newPortEntity.getProjectId());\n \n             if (delFixedIps.size() > 0) {\n+                needNotifyDpm = true;\n                 executor.runAsync(ipManagerProxy::releaseIpAddressBulk, delFixedIps);\n             }\n \n             if (addFixedIps.size() > 0) {\n-                executor.runAsync(ipManagerProxy::allocateFixedIpAddress, addFixedIps);\n+                needNotifyDpm = true;\n+                executor.runAsync(ipManagerProxy::allocateFixedIpAddresses, addFixedIps);\n             }\n \n-            oldPortState.setFixedIps(fixedIps);\n+            oldPortEntity.setFixedIps(newFixedIps);\n         }\n \n-        //Update security_groups\n-        updateSecurityGroup(oldPortState, portState);\n+        //Update mac_address\n+        String macAddress = newPortEntity.getMacAddress();\n+        String oldMacAddress = oldPortEntity.getMacAddress();\n+        if (macAddress != null && !oldMacAddress.equals(macAddress)) {\n+            MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n+            executor.runAsync(macManagerProxy::updateMacAddress, oldPortEntity, newPortEntity);\n+            oldPortEntity.setMacAddress(macAddress);\n+            needNotifyDpm = true;\n+        }\n \n         //Update allow_address_pairs\n-        //UpdateAllowAddressPairs();\n+        List<PortEntity.AllowAddressPair> newAllowedAddressPairs = newPortEntity.getAllowedAddressPairs();\n+        List<PortEntity.AllowAddressPair> oldAllowedAddressPairs = oldPortEntity.getAllowedAddressPairs();\n+        if (newAllowedAddressPairs != null && !newAllowedAddressPairs.equals(oldAllowedAddressPairs)) {\n+            oldPortEntity.setAllowedAddressPairs(newAllowedAddressPairs);\n+            needNotifyDpm = true;\n+        }\n \n-        //Update extra_dhcp_opts\n-        UpdateExtraDhcpOpts(portState, oldPortState);\n+        //Update port_security_enabled\n+        boolean newPortSecurityEnabled = newPortEntity.isPortSecurityEnabled();\n+        boolean oldPortSecurityEnabled = oldPortEntity.isPortSecurityEnabled();\n+        if (newPortSecurityEnabled != oldPortSecurityEnabled) {\n+            oldPortEntity.setPortSecurityEnabled(newPortSecurityEnabled);\n+            needNotifyDpm = true;\n+        }\n \n-        //Update binding:host_id\n-        if (portState.getBindingHostId() != null) {\n-            NodeManagerProxy nodeManagerProxy = new NodeManagerProxy(rollbacks);\n-            executor.runAsync(nodeManagerProxy::verifyHost, portState.getBindingHostId());\n-            oldPortState.setBindingHostId(portState.getBindingHostId());\n+        //Update qos_policy_id\n+        String newQosPolicyId = newPortEntity.getQosPolicyId();\n+        String oldQosPolicyId = oldPortEntity.getQosPolicyId();\n+        if (newQosPolicyId!= null && !newQosPolicyId.equals(oldQosPolicyId)) {\n+            oldPortEntity.setQosPolicyId(newQosPolicyId);\n+            needNotifyDpm = true;\n+        }\n+\n+        //Update qos_policy_id\n+        List<String> newSecurityGroups = newPortEntity.getSecurityGroups();\n+        List<String> oldSecurityGroups = oldPortEntity.getSecurityGroups();\n+        if (newSecurityGroups != null && !newSecurityGroups.equals(oldSecurityGroups)) {\n+            //FIXME: update security group\n+            SecurityGroupManagerProxy securityGroupManagerProxy = new SecurityGroupManagerProxy(newPortEntity.getProjectId());\n+            executor.runAsync(securityGroupManagerProxy::unbindSecurityGroup, oldPortEntity);\n+            executor.runAsync(securityGroupManagerProxy::bindSecurityGroup, newPortEntity);\n+            oldPortEntity.setSecurityGroups(newSecurityGroups);\n+            needNotifyDpm = true;\n+        }\n+\n+        //Update mac_learning_enabled\n+        boolean newMacLearningEnabled = newPortEntity.isMacLearningEnabled();\n+        boolean oldMacLearningEnabled = oldPortEntity.isMacLearningEnabled();\n+        if (newMacLearningEnabled != oldMacLearningEnabled) {\n+            oldPortEntity.setMacLearningEnabled(newMacLearningEnabled);\n+            needNotifyDpm = true;\n+        }\n+\n+        return needNotifyDpm;\n+    }\n+\n+    private void getPortDependentResources(PortEntity portEntity, AsyncExecutor executor) {\n+        //Get VpcEntity\n+        VpcManagerProxy vpcManagerProxy = new VpcManagerProxy(null);\n+        executor.runAsync(vpcManagerProxy::getVpcEntity, portEntity);\n+\n+        //Get SubnetEntity and subnet route\n+        SubnetManagerProxy subnetManagerProxy = new SubnetManagerProxy(portEntity.getProjectId());\n+        RouteManagerProxy routeManagerProxy = new RouteManagerProxy(null);\n+        for (PortEntity.FixedIp fixedIp: portEntity.getFixedIps()) {\n+            executor.runAsync(subnetManagerProxy::getSubnetEntity, fixedIp);\n+            executor.runAsync(routeManagerProxy::getRouteBySubnetId, fixedIp.getSubnetId());\n         }\n+\n+        //Get SecurityGroupEntity\n+        SecurityGroupManagerProxy securityGroupManagerProxy = new SecurityGroupManagerProxy(portEntity.getProjectId());\n+        if (portEntity.getSecurityGroups() != null) {\n+            for (String securityGroupId: portEntity.getSecurityGroups()) {\n+                executor.runAsync(securityGroupManagerProxy::getSecurityGroupEntity, securityGroupId);\n+            }\n+        } else {\n+            executor.runAsync(securityGroupManagerProxy::getDefaultSecurityGroupEntity, null);\n+        }\n+\n+        //Get NodeInfo\n+        NodeManagerProxy nodeManagerProxy = new NodeManagerProxy(null);\n+        if (portEntity.getBindingHostId() != null) {\n+            executor.runAsync(nodeManagerProxy::getNodeInfo, portEntity.getBindingHostId());\n+        }\n+\n+        //Get Neighbors\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjU2OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430842568", "bodyText": "We should allocate mac address before releasing the old one. Otherwise, it is possible that after releasing the old mac, Port Manager instance crashes which causes loss of old mac but no new mac is allocated. In the worse case, the old mac address is allocated by some other tenant.", "author": "xieus", "createdAt": "2020-05-27T03:52:47Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java", "diffHunk": "@@ -247,6 +290,68 @@ private void updatePortToHost(PortState portState) {\n \n     }\n \n+    private void updatePortStateAsync(PortState portState, PortState oldPortState, AsyncExecutor executor,\n+                                      Stack<PortStateRollback> rollbacks) throws Exception {\n+        //Update mac_address\n+        String macAddress = portState.getMacAddress();\n+        String oldMacAddress = oldPortState.getMacAddress();\n+        if (macAddress != null && !oldMacAddress.equals(macAddress)) {\n+            MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n+            executor.runAsync(macManagerProxy::releaseMacAddress, oldPortState);", "originalCommit": "fe4e219dbe3c5fee2b93f928a7320bb2d2885da9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NTQ5Mg==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430885492", "bodyText": "Since both allocate and release are asynchronous, the order of allocate and release cannot be guaranteed.", "author": "chenpiaoping", "createdAt": "2020-05-27T06:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5Mjk0NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430892944", "bodyText": "Good point. But we still needs to address this issue. Two options:\n\nBased on the different exceptions, Port Manager handles it differently. For example, if allocate fails and release succeeds, we need to retry allocation heavily; if allocate succeeds and release fails, we need to verify that the mac is still own by existing port then return new mac.\nMacManager provides one API to \"replace\" mac for a port in one \"transaction\". This appears to be cleaner and easier for clients such as PortManager.\n\nWhat do you think of?", "author": "xieus", "createdAt": "2020-05-27T06:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwNzQ2OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430907468", "bodyText": "Mac Manager to provide an update interface would be nice, at least reducing the number of interactions with it. But this exceptions will still exist(for example, allocate  mac address succeeded, but allocate ip address failed), if we handle this exception in the main flow of CRUD processing, it may be a bit complicated, and there is no 100% guarantee that the exception will be handled correctly (for example, what should we do if we try again but fails?). The simple handling is that once an exception occurs, the whole operation is considered to have failed, and the rollback mechanism is used to undo all operations before the failure.", "author": "chenpiaoping", "createdAt": "2020-05-27T07:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxOTM5NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430919395", "bodyText": "Mac Manager to provide an update interface would be nice, at least reducing the number of interactions with it. But this exceptions will still exist(for example, allocate mac address succeeded, but allocate ip address failed),\n\nDoes this comment apply to the replacement API? The replacement API offers atomic operation, either success together or failure together, no mix of the two.\n\nif we handle this exception in the main flow of CRUD processing, it may be a bit complicated, and there is no 100% guarantee that the exception will be handled correctly (for example, what should we do if we try again but fails?). The simple handling is that once an exception occurs, the whole operation is considered to have failed, and the rollback mechanism is used to undo all operations before the failure.\n\nCorrect. The rollback mechanism is intact to protect resources across microservices as described, but not within the same microservices therefore we need the upstream service to provide \"replacement\" API so that client don't need to worry about those complicated rollback mechanism.", "author": "xieus", "createdAt": "2020-05-27T07:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkyMDU0Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430920546", "bodyText": "If no objection, let us proceed to provide two \"replacement\" APIs, one in Mac Manager, and one in IP Manager then. Thoughts?", "author": "xieus", "createdAt": "2020-05-27T07:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTQyMw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430981423", "bodyText": "Agreed. No problem.", "author": "chenpiaoping", "createdAt": "2020-05-27T09:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg0NjkwMw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434846903", "bodyText": "Tracked by Issue #229.", "author": "xieus", "createdAt": "2020-06-03T20:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjU2OA=="}], "type": "inlineReview", "revised_code": {"commit": "91932144cbb23bb6f1854a0f5d15ea5e06827d84", "chunk": "diff --git a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\nindex 86f7161d5..caedbe461 100644\n--- a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n+++ b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n\n@@ -262,94 +289,202 @@ public class PortServiceImpl implements PortService {\n         return addFixedIps;\n     }\n \n-    private void updateSecurityGroup(PortState portState, PortState oldPortState) throws Exception {\n-        String deviceOwner = portState.getDeviceOwner();\n-\n-        //Network device interface does not need security groups\n-        if (deviceOwner != null && deviceOwner.indexOf(\"network\") > 0) {\n-            throw new UpdateSecurityGroupException();\n+    private boolean updatePortAsync(PortEntity newPortEntity, PortEntity oldPortEntity, AsyncExecutor executor,\n+                                 Stack<Rollback> rollbacks) throws Exception {\n+        boolean needNotifyDpm = false;\n+        //Update name\n+        String newName = newPortEntity.getName();\n+        String oldName = oldPortEntity.getName();\n+        if (newName != null && !newName.equals(oldName)) {\n+            oldPortEntity.setName(newName);\n         }\n \n-        //Verify request security groups valid\n-        verifySecurityGroup(portState);\n-\n-        //Delete old security groups binding\n-        unbindSecurityGroups(oldPortState);\n+        //Update admin_state\n+        boolean newAdminState = newPortEntity.isAdminStateUp();\n+        boolean oldAdminState = oldPortEntity.isAdminStateUp();\n+        if (newAdminState != oldAdminState) {\n+            oldPortEntity.setAdminStateUp(newAdminState);\n+            needNotifyDpm = true;\n+        }\n \n-        //Create security groups binding for port\n-        bindSecurityGroups(portState);\n+        //Update binding:host_id\n+        String newBindingHostId = newPortEntity.getBindingHostId();\n+        String oldBindingHostId = oldPortEntity.getBindingHostId();\n+        if (newBindingHostId != null && !newBindingHostId.equals(oldBindingHostId)) {\n+            oldPortEntity.setBindingHostId(newBindingHostId);\n+            needNotifyDpm = true;\n+        }\n \n-        oldPortState.setSecurityGroups(portState.getSecurityGroups());\n-    }\n+        //Update binding:profile\n+        String newBindingProfile = newPortEntity.getBindingProfile();\n+        String oldBindingProfile = oldPortEntity.getBindingProfile();\n+        if (newBindingProfile != null && !newBindingProfile.equals(oldBindingProfile)) {\n+            oldPortEntity.setBindingProfile(newBindingProfile);\n+            needNotifyDpm = true;\n+        }\n \n-    private void UpdateExtraDhcpOpts(PortState portState, PortState portStateOld) {\n+        //Update binding:vnic_type\n+        String newBindingVnicType = newPortEntity.getBindingVnicType();\n+        String oldBindingVnicType = oldPortEntity.getBindingVnicType();\n+        if (newBindingVnicType != null && !newBindingVnicType.equals(oldBindingVnicType)) {\n+            oldPortEntity.setBindingVnicType(newBindingVnicType);\n+            needNotifyDpm = true;\n+        }\n \n-    }\n+        //Update description\n+        String newDescription = newPortEntity.getDescription();\n+        String oldDescription = oldPortEntity.getDescription();\n+        if (newDescription != null && !newDescription.equals(oldDescription)) {\n+            oldPortEntity.setDescription(newDescription);\n+        }\n \n-    private void updatePortToHost(PortState portState) {\n+        //Update device_id\n+        String newDeviceId = newPortEntity.getDeviceId();\n+        String oldDeviceId = oldPortEntity.getDeviceId();\n+        if (newDeviceId != null && !newDeviceId.equals(oldDeviceId)) {\n+            oldPortEntity.setDeviceId(newDeviceId);\n+            needNotifyDpm = true;\n+        }\n \n-    }\n+        //Update device_owner\n+        String newDeviceOwner = newPortEntity.getDeviceOwner();\n+        String oldDeviceOwner = oldPortEntity.getDeviceOwner();\n+        if (newDeviceOwner != null && !newDeviceOwner.equals(oldDeviceOwner)) {\n+            oldPortEntity.setDeviceOwner(newDeviceOwner);\n+        }\n \n-    private void updatePortStateAsync(PortState portState, PortState oldPortState, AsyncExecutor executor,\n-                                      Stack<PortStateRollback> rollbacks) throws Exception {\n-        //Update mac_address\n-        String macAddress = portState.getMacAddress();\n-        String oldMacAddress = oldPortState.getMacAddress();\n-        if (macAddress != null && !oldMacAddress.equals(macAddress)) {\n-            MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n-            executor.runAsync(macManagerProxy::releaseMacAddress, oldPortState);\n-            executor.runAsync(macManagerProxy::allocateFixedMacAddress, portState);\n-            oldPortState.setMacAddress(macAddress);\n+        //Update dns_domain\n+        String newDnsDomain = newPortEntity.getDnsDomain();\n+        String oldDnsDomain = oldPortEntity.getDnsDomain();\n+        if (newDnsDomain != null && !newDnsDomain.equals(oldDnsDomain)) {\n+            oldPortEntity.setDnsDomain(newDnsDomain);\n+            needNotifyDpm = true;\n         }\n \n-        //Update device_owner and device_id\n-        String deviceOwnerNew = portState.getDeviceOwner();\n-        String deviceIdNew = portState.getDeviceId();\n-        String deviceIdOld = oldPortState.getDeviceId();\n-        String tenantId = oldPortState.getTenantId();\n+        //Update dns_name\n+        String newDnsName = newPortEntity.getDnsName();\n+        String oldDnsName = oldPortEntity.getDnsName();\n+        if (newDnsName != null && !newDnsName.equals(oldDnsName)) {\n+            oldPortEntity.setDnsName(newDnsName);\n+            needNotifyDpm = true;\n+        }\n \n-        if (deviceOwnerNew != null && deviceIdNew != null && !deviceIdNew.equals(deviceIdOld)) {\n-            if (DeviceOwner.ROUTER.getOwner().equals(deviceOwnerNew)) {\n-                verifyRouter(deviceIdNew, tenantId);\n-            }\n+        //Update dns_name\n+        List<PortEntity.ExtraDhcpOpt> newExtraDhcpOpts = newPortEntity.getExtraDhcpOpts();\n+        List<PortEntity.ExtraDhcpOpt> oldExtraDhcpOpts = oldPortEntity.getExtraDhcpOpts();\n+        if (newExtraDhcpOpts != null && !newExtraDhcpOpts.equals(oldExtraDhcpOpts)) {\n+            oldPortEntity.setExtraDhcpOpts(newExtraDhcpOpts);\n+            needNotifyDpm = true;\n         }\n \n         //Update fixed_ips\n-        List<PortState.FixedIp> fixedIps = portState.getFixedIps();\n-        IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, portState.getProjectId());\n-\n-        if (fixedIps != null) {\n-            List<PortState.FixedIp> oldFixedIps = oldPortState.getFixedIps();\n-\n-            List<PortState.FixedIp> addFixedIps = fixedIpsCompare(fixedIps, oldFixedIps);\n-            List<PortState.FixedIp> delFixedIps = fixedIpsCompare(oldFixedIps, fixedIps);\n+        List<PortEntity.FixedIp> newFixedIps = newPortEntity.getFixedIps();\n+        List<PortEntity.FixedIp> oldFixedIps = oldPortEntity.getFixedIps();\n+        if (newFixedIps != null && !newFixedIps.equals(oldFixedIps)) {\n+            List<PortEntity.FixedIp> addFixedIps = fixedIpsCompare(newFixedIps, oldFixedIps);\n+            List<PortEntity.FixedIp> delFixedIps = fixedIpsCompare(oldFixedIps, newFixedIps);\n+            IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, newPortEntity.getProjectId());\n \n             if (delFixedIps.size() > 0) {\n+                needNotifyDpm = true;\n                 executor.runAsync(ipManagerProxy::releaseIpAddressBulk, delFixedIps);\n             }\n \n             if (addFixedIps.size() > 0) {\n-                executor.runAsync(ipManagerProxy::allocateFixedIpAddress, addFixedIps);\n+                needNotifyDpm = true;\n+                executor.runAsync(ipManagerProxy::allocateFixedIpAddresses, addFixedIps);\n             }\n \n-            oldPortState.setFixedIps(fixedIps);\n+            oldPortEntity.setFixedIps(newFixedIps);\n         }\n \n-        //Update security_groups\n-        updateSecurityGroup(oldPortState, portState);\n+        //Update mac_address\n+        String macAddress = newPortEntity.getMacAddress();\n+        String oldMacAddress = oldPortEntity.getMacAddress();\n+        if (macAddress != null && !oldMacAddress.equals(macAddress)) {\n+            MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n+            executor.runAsync(macManagerProxy::updateMacAddress, oldPortEntity, newPortEntity);\n+            oldPortEntity.setMacAddress(macAddress);\n+            needNotifyDpm = true;\n+        }\n \n         //Update allow_address_pairs\n-        //UpdateAllowAddressPairs();\n+        List<PortEntity.AllowAddressPair> newAllowedAddressPairs = newPortEntity.getAllowedAddressPairs();\n+        List<PortEntity.AllowAddressPair> oldAllowedAddressPairs = oldPortEntity.getAllowedAddressPairs();\n+        if (newAllowedAddressPairs != null && !newAllowedAddressPairs.equals(oldAllowedAddressPairs)) {\n+            oldPortEntity.setAllowedAddressPairs(newAllowedAddressPairs);\n+            needNotifyDpm = true;\n+        }\n \n-        //Update extra_dhcp_opts\n-        UpdateExtraDhcpOpts(portState, oldPortState);\n+        //Update port_security_enabled\n+        boolean newPortSecurityEnabled = newPortEntity.isPortSecurityEnabled();\n+        boolean oldPortSecurityEnabled = oldPortEntity.isPortSecurityEnabled();\n+        if (newPortSecurityEnabled != oldPortSecurityEnabled) {\n+            oldPortEntity.setPortSecurityEnabled(newPortSecurityEnabled);\n+            needNotifyDpm = true;\n+        }\n \n-        //Update binding:host_id\n-        if (portState.getBindingHostId() != null) {\n-            NodeManagerProxy nodeManagerProxy = new NodeManagerProxy(rollbacks);\n-            executor.runAsync(nodeManagerProxy::verifyHost, portState.getBindingHostId());\n-            oldPortState.setBindingHostId(portState.getBindingHostId());\n+        //Update qos_policy_id\n+        String newQosPolicyId = newPortEntity.getQosPolicyId();\n+        String oldQosPolicyId = oldPortEntity.getQosPolicyId();\n+        if (newQosPolicyId!= null && !newQosPolicyId.equals(oldQosPolicyId)) {\n+            oldPortEntity.setQosPolicyId(newQosPolicyId);\n+            needNotifyDpm = true;\n+        }\n+\n+        //Update qos_policy_id\n+        List<String> newSecurityGroups = newPortEntity.getSecurityGroups();\n+        List<String> oldSecurityGroups = oldPortEntity.getSecurityGroups();\n+        if (newSecurityGroups != null && !newSecurityGroups.equals(oldSecurityGroups)) {\n+            //FIXME: update security group\n+            SecurityGroupManagerProxy securityGroupManagerProxy = new SecurityGroupManagerProxy(newPortEntity.getProjectId());\n+            executor.runAsync(securityGroupManagerProxy::unbindSecurityGroup, oldPortEntity);\n+            executor.runAsync(securityGroupManagerProxy::bindSecurityGroup, newPortEntity);\n+            oldPortEntity.setSecurityGroups(newSecurityGroups);\n+            needNotifyDpm = true;\n+        }\n+\n+        //Update mac_learning_enabled\n+        boolean newMacLearningEnabled = newPortEntity.isMacLearningEnabled();\n+        boolean oldMacLearningEnabled = oldPortEntity.isMacLearningEnabled();\n+        if (newMacLearningEnabled != oldMacLearningEnabled) {\n+            oldPortEntity.setMacLearningEnabled(newMacLearningEnabled);\n+            needNotifyDpm = true;\n+        }\n+\n+        return needNotifyDpm;\n+    }\n+\n+    private void getPortDependentResources(PortEntity portEntity, AsyncExecutor executor) {\n+        //Get VpcEntity\n+        VpcManagerProxy vpcManagerProxy = new VpcManagerProxy(null);\n+        executor.runAsync(vpcManagerProxy::getVpcEntity, portEntity);\n+\n+        //Get SubnetEntity and subnet route\n+        SubnetManagerProxy subnetManagerProxy = new SubnetManagerProxy(portEntity.getProjectId());\n+        RouteManagerProxy routeManagerProxy = new RouteManagerProxy(null);\n+        for (PortEntity.FixedIp fixedIp: portEntity.getFixedIps()) {\n+            executor.runAsync(subnetManagerProxy::getSubnetEntity, fixedIp);\n+            executor.runAsync(routeManagerProxy::getRouteBySubnetId, fixedIp.getSubnetId());\n         }\n+\n+        //Get SecurityGroupEntity\n+        SecurityGroupManagerProxy securityGroupManagerProxy = new SecurityGroupManagerProxy(portEntity.getProjectId());\n+        if (portEntity.getSecurityGroups() != null) {\n+            for (String securityGroupId: portEntity.getSecurityGroups()) {\n+                executor.runAsync(securityGroupManagerProxy::getSecurityGroupEntity, securityGroupId);\n+            }\n+        } else {\n+            executor.runAsync(securityGroupManagerProxy::getDefaultSecurityGroupEntity, null);\n+        }\n+\n+        //Get NodeInfo\n+        NodeManagerProxy nodeManagerProxy = new NodeManagerProxy(null);\n+        if (portEntity.getBindingHostId() != null) {\n+            executor.runAsync(nodeManagerProxy::getNodeInfo, portEntity.getBindingHostId());\n+        }\n+\n+        //Get Neighbors\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MzE0NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430843145", "bodyText": "Same there. Allocate before release.\nAlso, could you give a simple comment or example to explain addFixedIps and delFixedIps to increase code readability?", "author": "xieus", "createdAt": "2020-05-27T03:55:28Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java", "diffHunk": "@@ -247,6 +290,68 @@ private void updatePortToHost(PortState portState) {\n \n     }\n \n+    private void updatePortStateAsync(PortState portState, PortState oldPortState, AsyncExecutor executor,\n+                                      Stack<PortStateRollback> rollbacks) throws Exception {\n+        //Update mac_address\n+        String macAddress = portState.getMacAddress();\n+        String oldMacAddress = oldPortState.getMacAddress();\n+        if (macAddress != null && !oldMacAddress.equals(macAddress)) {\n+            MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n+            executor.runAsync(macManagerProxy::releaseMacAddress, oldPortState);\n+            executor.runAsync(macManagerProxy::allocateFixedMacAddress, portState);\n+            oldPortState.setMacAddress(macAddress);\n+        }\n+\n+        //Update device_owner and device_id\n+        String deviceOwnerNew = portState.getDeviceOwner();\n+        String deviceIdNew = portState.getDeviceId();\n+        String deviceIdOld = oldPortState.getDeviceId();\n+        String tenantId = oldPortState.getTenantId();\n+\n+        if (deviceOwnerNew != null && deviceIdNew != null && !deviceIdNew.equals(deviceIdOld)) {\n+            if (DeviceOwner.ROUTER.getOwner().equals(deviceOwnerNew)) {\n+                verifyRouter(deviceIdNew, tenantId);\n+            }\n+        }\n+\n+        //Update fixed_ips\n+        List<PortState.FixedIp> fixedIps = portState.getFixedIps();\n+        IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, portState.getProjectId());\n+\n+        if (fixedIps != null) {\n+            List<PortState.FixedIp> oldFixedIps = oldPortState.getFixedIps();\n+\n+            List<PortState.FixedIp> addFixedIps = fixedIpsCompare(fixedIps, oldFixedIps);\n+            List<PortState.FixedIp> delFixedIps = fixedIpsCompare(oldFixedIps, fixedIps);\n+\n+            if (delFixedIps.size() > 0) {\n+                executor.runAsync(ipManagerProxy::releaseIpAddressBulk, delFixedIps);\n+            }\n+\n+            if (addFixedIps.size() > 0) {\n+                executor.runAsync(ipManagerProxy::allocateFixedIpAddress, addFixedIps);\n+            }", "originalCommit": "fe4e219dbe3c5fee2b93f928a7320bb2d2885da9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzM0Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430893347", "bodyText": "Same replacement API might be needed for PIP manager as well.", "author": "xieus", "createdAt": "2020-05-27T06:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MzE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg0NzA4MA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434847080", "bodyText": "Tracked by Issue #229.", "author": "xieus", "createdAt": "2020-06-03T20:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MzE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "91932144cbb23bb6f1854a0f5d15ea5e06827d84", "chunk": "diff --git a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\nindex 86f7161d5..caedbe461 100644\n--- a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n+++ b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n\n@@ -262,94 +289,202 @@ public class PortServiceImpl implements PortService {\n         return addFixedIps;\n     }\n \n-    private void updateSecurityGroup(PortState portState, PortState oldPortState) throws Exception {\n-        String deviceOwner = portState.getDeviceOwner();\n-\n-        //Network device interface does not need security groups\n-        if (deviceOwner != null && deviceOwner.indexOf(\"network\") > 0) {\n-            throw new UpdateSecurityGroupException();\n+    private boolean updatePortAsync(PortEntity newPortEntity, PortEntity oldPortEntity, AsyncExecutor executor,\n+                                 Stack<Rollback> rollbacks) throws Exception {\n+        boolean needNotifyDpm = false;\n+        //Update name\n+        String newName = newPortEntity.getName();\n+        String oldName = oldPortEntity.getName();\n+        if (newName != null && !newName.equals(oldName)) {\n+            oldPortEntity.setName(newName);\n         }\n \n-        //Verify request security groups valid\n-        verifySecurityGroup(portState);\n-\n-        //Delete old security groups binding\n-        unbindSecurityGroups(oldPortState);\n+        //Update admin_state\n+        boolean newAdminState = newPortEntity.isAdminStateUp();\n+        boolean oldAdminState = oldPortEntity.isAdminStateUp();\n+        if (newAdminState != oldAdminState) {\n+            oldPortEntity.setAdminStateUp(newAdminState);\n+            needNotifyDpm = true;\n+        }\n \n-        //Create security groups binding for port\n-        bindSecurityGroups(portState);\n+        //Update binding:host_id\n+        String newBindingHostId = newPortEntity.getBindingHostId();\n+        String oldBindingHostId = oldPortEntity.getBindingHostId();\n+        if (newBindingHostId != null && !newBindingHostId.equals(oldBindingHostId)) {\n+            oldPortEntity.setBindingHostId(newBindingHostId);\n+            needNotifyDpm = true;\n+        }\n \n-        oldPortState.setSecurityGroups(portState.getSecurityGroups());\n-    }\n+        //Update binding:profile\n+        String newBindingProfile = newPortEntity.getBindingProfile();\n+        String oldBindingProfile = oldPortEntity.getBindingProfile();\n+        if (newBindingProfile != null && !newBindingProfile.equals(oldBindingProfile)) {\n+            oldPortEntity.setBindingProfile(newBindingProfile);\n+            needNotifyDpm = true;\n+        }\n \n-    private void UpdateExtraDhcpOpts(PortState portState, PortState portStateOld) {\n+        //Update binding:vnic_type\n+        String newBindingVnicType = newPortEntity.getBindingVnicType();\n+        String oldBindingVnicType = oldPortEntity.getBindingVnicType();\n+        if (newBindingVnicType != null && !newBindingVnicType.equals(oldBindingVnicType)) {\n+            oldPortEntity.setBindingVnicType(newBindingVnicType);\n+            needNotifyDpm = true;\n+        }\n \n-    }\n+        //Update description\n+        String newDescription = newPortEntity.getDescription();\n+        String oldDescription = oldPortEntity.getDescription();\n+        if (newDescription != null && !newDescription.equals(oldDescription)) {\n+            oldPortEntity.setDescription(newDescription);\n+        }\n \n-    private void updatePortToHost(PortState portState) {\n+        //Update device_id\n+        String newDeviceId = newPortEntity.getDeviceId();\n+        String oldDeviceId = oldPortEntity.getDeviceId();\n+        if (newDeviceId != null && !newDeviceId.equals(oldDeviceId)) {\n+            oldPortEntity.setDeviceId(newDeviceId);\n+            needNotifyDpm = true;\n+        }\n \n-    }\n+        //Update device_owner\n+        String newDeviceOwner = newPortEntity.getDeviceOwner();\n+        String oldDeviceOwner = oldPortEntity.getDeviceOwner();\n+        if (newDeviceOwner != null && !newDeviceOwner.equals(oldDeviceOwner)) {\n+            oldPortEntity.setDeviceOwner(newDeviceOwner);\n+        }\n \n-    private void updatePortStateAsync(PortState portState, PortState oldPortState, AsyncExecutor executor,\n-                                      Stack<PortStateRollback> rollbacks) throws Exception {\n-        //Update mac_address\n-        String macAddress = portState.getMacAddress();\n-        String oldMacAddress = oldPortState.getMacAddress();\n-        if (macAddress != null && !oldMacAddress.equals(macAddress)) {\n-            MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n-            executor.runAsync(macManagerProxy::releaseMacAddress, oldPortState);\n-            executor.runAsync(macManagerProxy::allocateFixedMacAddress, portState);\n-            oldPortState.setMacAddress(macAddress);\n+        //Update dns_domain\n+        String newDnsDomain = newPortEntity.getDnsDomain();\n+        String oldDnsDomain = oldPortEntity.getDnsDomain();\n+        if (newDnsDomain != null && !newDnsDomain.equals(oldDnsDomain)) {\n+            oldPortEntity.setDnsDomain(newDnsDomain);\n+            needNotifyDpm = true;\n         }\n \n-        //Update device_owner and device_id\n-        String deviceOwnerNew = portState.getDeviceOwner();\n-        String deviceIdNew = portState.getDeviceId();\n-        String deviceIdOld = oldPortState.getDeviceId();\n-        String tenantId = oldPortState.getTenantId();\n+        //Update dns_name\n+        String newDnsName = newPortEntity.getDnsName();\n+        String oldDnsName = oldPortEntity.getDnsName();\n+        if (newDnsName != null && !newDnsName.equals(oldDnsName)) {\n+            oldPortEntity.setDnsName(newDnsName);\n+            needNotifyDpm = true;\n+        }\n \n-        if (deviceOwnerNew != null && deviceIdNew != null && !deviceIdNew.equals(deviceIdOld)) {\n-            if (DeviceOwner.ROUTER.getOwner().equals(deviceOwnerNew)) {\n-                verifyRouter(deviceIdNew, tenantId);\n-            }\n+        //Update dns_name\n+        List<PortEntity.ExtraDhcpOpt> newExtraDhcpOpts = newPortEntity.getExtraDhcpOpts();\n+        List<PortEntity.ExtraDhcpOpt> oldExtraDhcpOpts = oldPortEntity.getExtraDhcpOpts();\n+        if (newExtraDhcpOpts != null && !newExtraDhcpOpts.equals(oldExtraDhcpOpts)) {\n+            oldPortEntity.setExtraDhcpOpts(newExtraDhcpOpts);\n+            needNotifyDpm = true;\n         }\n \n         //Update fixed_ips\n-        List<PortState.FixedIp> fixedIps = portState.getFixedIps();\n-        IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, portState.getProjectId());\n-\n-        if (fixedIps != null) {\n-            List<PortState.FixedIp> oldFixedIps = oldPortState.getFixedIps();\n-\n-            List<PortState.FixedIp> addFixedIps = fixedIpsCompare(fixedIps, oldFixedIps);\n-            List<PortState.FixedIp> delFixedIps = fixedIpsCompare(oldFixedIps, fixedIps);\n+        List<PortEntity.FixedIp> newFixedIps = newPortEntity.getFixedIps();\n+        List<PortEntity.FixedIp> oldFixedIps = oldPortEntity.getFixedIps();\n+        if (newFixedIps != null && !newFixedIps.equals(oldFixedIps)) {\n+            List<PortEntity.FixedIp> addFixedIps = fixedIpsCompare(newFixedIps, oldFixedIps);\n+            List<PortEntity.FixedIp> delFixedIps = fixedIpsCompare(oldFixedIps, newFixedIps);\n+            IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, newPortEntity.getProjectId());\n \n             if (delFixedIps.size() > 0) {\n+                needNotifyDpm = true;\n                 executor.runAsync(ipManagerProxy::releaseIpAddressBulk, delFixedIps);\n             }\n \n             if (addFixedIps.size() > 0) {\n-                executor.runAsync(ipManagerProxy::allocateFixedIpAddress, addFixedIps);\n+                needNotifyDpm = true;\n+                executor.runAsync(ipManagerProxy::allocateFixedIpAddresses, addFixedIps);\n             }\n \n-            oldPortState.setFixedIps(fixedIps);\n+            oldPortEntity.setFixedIps(newFixedIps);\n         }\n \n-        //Update security_groups\n-        updateSecurityGroup(oldPortState, portState);\n+        //Update mac_address\n+        String macAddress = newPortEntity.getMacAddress();\n+        String oldMacAddress = oldPortEntity.getMacAddress();\n+        if (macAddress != null && !oldMacAddress.equals(macAddress)) {\n+            MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n+            executor.runAsync(macManagerProxy::updateMacAddress, oldPortEntity, newPortEntity);\n+            oldPortEntity.setMacAddress(macAddress);\n+            needNotifyDpm = true;\n+        }\n \n         //Update allow_address_pairs\n-        //UpdateAllowAddressPairs();\n+        List<PortEntity.AllowAddressPair> newAllowedAddressPairs = newPortEntity.getAllowedAddressPairs();\n+        List<PortEntity.AllowAddressPair> oldAllowedAddressPairs = oldPortEntity.getAllowedAddressPairs();\n+        if (newAllowedAddressPairs != null && !newAllowedAddressPairs.equals(oldAllowedAddressPairs)) {\n+            oldPortEntity.setAllowedAddressPairs(newAllowedAddressPairs);\n+            needNotifyDpm = true;\n+        }\n \n-        //Update extra_dhcp_opts\n-        UpdateExtraDhcpOpts(portState, oldPortState);\n+        //Update port_security_enabled\n+        boolean newPortSecurityEnabled = newPortEntity.isPortSecurityEnabled();\n+        boolean oldPortSecurityEnabled = oldPortEntity.isPortSecurityEnabled();\n+        if (newPortSecurityEnabled != oldPortSecurityEnabled) {\n+            oldPortEntity.setPortSecurityEnabled(newPortSecurityEnabled);\n+            needNotifyDpm = true;\n+        }\n \n-        //Update binding:host_id\n-        if (portState.getBindingHostId() != null) {\n-            NodeManagerProxy nodeManagerProxy = new NodeManagerProxy(rollbacks);\n-            executor.runAsync(nodeManagerProxy::verifyHost, portState.getBindingHostId());\n-            oldPortState.setBindingHostId(portState.getBindingHostId());\n+        //Update qos_policy_id\n+        String newQosPolicyId = newPortEntity.getQosPolicyId();\n+        String oldQosPolicyId = oldPortEntity.getQosPolicyId();\n+        if (newQosPolicyId!= null && !newQosPolicyId.equals(oldQosPolicyId)) {\n+            oldPortEntity.setQosPolicyId(newQosPolicyId);\n+            needNotifyDpm = true;\n+        }\n+\n+        //Update qos_policy_id\n+        List<String> newSecurityGroups = newPortEntity.getSecurityGroups();\n+        List<String> oldSecurityGroups = oldPortEntity.getSecurityGroups();\n+        if (newSecurityGroups != null && !newSecurityGroups.equals(oldSecurityGroups)) {\n+            //FIXME: update security group\n+            SecurityGroupManagerProxy securityGroupManagerProxy = new SecurityGroupManagerProxy(newPortEntity.getProjectId());\n+            executor.runAsync(securityGroupManagerProxy::unbindSecurityGroup, oldPortEntity);\n+            executor.runAsync(securityGroupManagerProxy::bindSecurityGroup, newPortEntity);\n+            oldPortEntity.setSecurityGroups(newSecurityGroups);\n+            needNotifyDpm = true;\n+        }\n+\n+        //Update mac_learning_enabled\n+        boolean newMacLearningEnabled = newPortEntity.isMacLearningEnabled();\n+        boolean oldMacLearningEnabled = oldPortEntity.isMacLearningEnabled();\n+        if (newMacLearningEnabled != oldMacLearningEnabled) {\n+            oldPortEntity.setMacLearningEnabled(newMacLearningEnabled);\n+            needNotifyDpm = true;\n+        }\n+\n+        return needNotifyDpm;\n+    }\n+\n+    private void getPortDependentResources(PortEntity portEntity, AsyncExecutor executor) {\n+        //Get VpcEntity\n+        VpcManagerProxy vpcManagerProxy = new VpcManagerProxy(null);\n+        executor.runAsync(vpcManagerProxy::getVpcEntity, portEntity);\n+\n+        //Get SubnetEntity and subnet route\n+        SubnetManagerProxy subnetManagerProxy = new SubnetManagerProxy(portEntity.getProjectId());\n+        RouteManagerProxy routeManagerProxy = new RouteManagerProxy(null);\n+        for (PortEntity.FixedIp fixedIp: portEntity.getFixedIps()) {\n+            executor.runAsync(subnetManagerProxy::getSubnetEntity, fixedIp);\n+            executor.runAsync(routeManagerProxy::getRouteBySubnetId, fixedIp.getSubnetId());\n         }\n+\n+        //Get SecurityGroupEntity\n+        SecurityGroupManagerProxy securityGroupManagerProxy = new SecurityGroupManagerProxy(portEntity.getProjectId());\n+        if (portEntity.getSecurityGroups() != null) {\n+            for (String securityGroupId: portEntity.getSecurityGroups()) {\n+                executor.runAsync(securityGroupManagerProxy::getSecurityGroupEntity, securityGroupId);\n+            }\n+        } else {\n+            executor.runAsync(securityGroupManagerProxy::getDefaultSecurityGroupEntity, null);\n+        }\n+\n+        //Get NodeInfo\n+        NodeManagerProxy nodeManagerProxy = new NodeManagerProxy(null);\n+        if (portEntity.getBindingHostId() != null) {\n+            executor.runAsync(nodeManagerProxy::getNodeInfo, portEntity.getBindingHostId());\n+        }\n+\n+        //Get Neighbors\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MzQxMA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430843410", "bodyText": "newPortState?", "author": "xieus", "createdAt": "2020-05-27T03:56:41Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java", "diffHunk": "@@ -267,84 +372,70 @@ public PortStateJson updatePortState(String projectId, String portId, PortStateJ\n         AsyncExecutor executor = new AsyncExecutor();\n \n         PortState portState = portStateJson.getPortState();\n-        PortState oldPortState = portRepository.findItem(portId);\n+        portState.setProjectId(projectId);\n \n         try {\n-            if (portRepository.findItem(portId) == null) {\n+            PortState oldPortState = portRepository.findItem(portId);\n+            if (oldPortState == null) {\n                 throw new PortStateNotFoundException();\n             }\n \n-            portState.setProjectId(projectId);\n-\n-            //Update mac_address\n+            updatePortStateAsync(portState, oldPortState, executor, rollbacks);\n \n-            //Update device_owner and device_id\n-            String deviceOwnerNew = portState.getDeviceOwner();\n-            String deviceIdNew = portState.getDeviceId();\n-            String deviceIdOld = oldPortState.getDeviceId();\n-            String tenantId = oldPortState.getTenantId();\n-\n-            if (deviceOwnerNew != null && deviceIdNew != null && !deviceIdNew.equals(deviceIdOld)) {\n-                if (DeviceOwner.ROUTER.getOwner().equals(deviceOwnerNew)) {\n-                    verifyRouter(deviceIdNew, tenantId);\n-                }\n-            }\n+            //Wait for all async functions to finish\n+            executor.joinAll();\n \n-            //Update fixed_ips\n-            List<PortState.FixedIp> fixedIps = portState.getFixedIps();\n-            IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, projectId);\n+            //Persist the new configuration of port to the db\n+            portRepository.addItem(oldPortState);", "originalCommit": "fe4e219dbe3c5fee2b93f928a7320bb2d2885da9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NzExMQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430887111", "bodyText": "no, newPortState not have complete fields.", "author": "chenpiaoping", "createdAt": "2020-05-27T06:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MzQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5NDU3Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430894573", "bodyText": "Sorry I don't quite follow this. Why do we want to persist the \"oldPortState\" in an update call? Can you please elaborate?", "author": "xieus", "createdAt": "2020-05-27T06:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MzQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwMDAzNA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430900034", "bodyText": "Because some fields in PortState are generated dynamically during create, in addition, only part of the fields are allowed to be updated during update, so the fields in portState may be incomplete.", "author": "chenpiaoping", "createdAt": "2020-05-27T07:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MzQxMA=="}], "type": "inlineReview", "revised_code": {"commit": "91932144cbb23bb6f1854a0f5d15ea5e06827d84", "chunk": "diff --git a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\nindex 86f7161d5..caedbe461 100644\n--- a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n+++ b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n\n@@ -359,42 +494,53 @@ public class PortServiceImpl implements PortService {\n      * the resource added or deleted operation of each micro-service.\n      * @param projectId Project the port belongs to\n      * @param portId Id of port\n-     * @param portStateJson The new configuration of port\n+     * @param portWebJson The new configuration of port\n      * @return The new configuration of port\n      * @throws Exception Various exceptions that may occur during the update process\n      */\n     @Override\n-    public PortStateJson updatePortState(String projectId, String portId, PortStateJson portStateJson) throws Exception {\n-        LOG.debug(\"Update port state, projectId: {}, portId: {}, PortStateJson: {}\",\n-                projectId, portId, portStateJson);\n+    public PortWebJson updatePort(String projectId, String portId, PortWebJson portWebJson) throws Exception {\n+        LOG.debug(\"Update port state, projectId: {}, portId: {}, PortWebJson: {}\",\n+                projectId, portId, portWebJson);\n \n-        Stack<PortStateRollback> rollbacks = new Stack<>();\n+        Stack<Rollback> rollbacks = new Stack<>();\n         AsyncExecutor executor = new AsyncExecutor();\n \n-        PortState portState = portStateJson.getPortState();\n-        portState.setProjectId(projectId);\n+        PortEntity portEntity = portWebJson.getPortEntity();\n+        portEntity.setProjectId(projectId);\n \n         try {\n-            PortState oldPortState = portRepository.findItem(portId);\n-            if (oldPortState == null) {\n-                throw new PortStateNotFoundException();\n+            PortEntity oldPortEntity = portRepository.findItem(portId);\n+            if (oldPortEntity == null) {\n+                throw new PortEntityNotFound();\n             }\n \n-            updatePortStateAsync(portState, oldPortState, executor, rollbacks);\n+            boolean needNotifyDpm = updatePortAsync(portEntity, oldPortEntity, executor, rollbacks);\n+            if (needNotifyDpm) {\n+                getPortDependentResources(oldPortEntity, executor);\n+            }\n \n             //Wait for all async functions to finish\n-            executor.joinAll();\n+            List<Object> entities = executor.joinAll();\n+\n+            //Build GoalState and send it to DPM\n+            if (needNotifyDpm) {\n+                entities.add(oldPortEntity);\n+                DataPlaneManagerProxy dataPlaneManagerProxy = new DataPlaneManagerProxy(rollbacks);\n+                Goalstate.GoalState goalState = GoalStateUtil.buildGoalState(entities, Common.OperationType.UPDATE);\n+                dataPlaneManagerProxy.updateGoalState(goalState);\n+            }\n \n             //Persist the new configuration of port to the db\n-            portRepository.addItem(oldPortState);\n-            portStateJson.setPortState(oldPortState);\n+            portRepository.addItem(oldPortEntity);\n+            portWebJson.setPortEntity(oldPortEntity);\n         } catch (Exception e) {\n             exceptionHandle(executor, rollbacks, e);\n         }\n \n-        LOG.debug(\"Update port state success, portStateJson: {}\", portStateJson);\n+        LOG.debug(\"Update port state success, portWebJson: {}\", portWebJson);\n \n-        return portStateJson;\n+        return portWebJson;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MzY1NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r430843654", "bodyText": "The update logic is quite tricky. Do we have sufficient UTs to cover those corner cases?", "author": "xieus", "createdAt": "2020-05-27T03:57:46Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java", "diffHunk": "@@ -267,84 +372,70 @@ public PortStateJson updatePortState(String projectId, String portId, PortStateJ\n         AsyncExecutor executor = new AsyncExecutor();\n \n         PortState portState = portStateJson.getPortState();\n-        PortState oldPortState = portRepository.findItem(portId);\n+        portState.setProjectId(projectId);\n \n         try {\n-            if (portRepository.findItem(portId) == null) {\n+            PortState oldPortState = portRepository.findItem(portId);\n+            if (oldPortState == null) {\n                 throw new PortStateNotFoundException();\n             }\n \n-            portState.setProjectId(projectId);\n-\n-            //Update mac_address\n+            updatePortStateAsync(portState, oldPortState, executor, rollbacks);", "originalCommit": "fe4e219dbe3c5fee2b93f928a7320bb2d2885da9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "91932144cbb23bb6f1854a0f5d15ea5e06827d84", "chunk": "diff --git a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\nindex 86f7161d5..caedbe461 100644\n--- a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n+++ b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n\n@@ -359,42 +494,53 @@ public class PortServiceImpl implements PortService {\n      * the resource added or deleted operation of each micro-service.\n      * @param projectId Project the port belongs to\n      * @param portId Id of port\n-     * @param portStateJson The new configuration of port\n+     * @param portWebJson The new configuration of port\n      * @return The new configuration of port\n      * @throws Exception Various exceptions that may occur during the update process\n      */\n     @Override\n-    public PortStateJson updatePortState(String projectId, String portId, PortStateJson portStateJson) throws Exception {\n-        LOG.debug(\"Update port state, projectId: {}, portId: {}, PortStateJson: {}\",\n-                projectId, portId, portStateJson);\n+    public PortWebJson updatePort(String projectId, String portId, PortWebJson portWebJson) throws Exception {\n+        LOG.debug(\"Update port state, projectId: {}, portId: {}, PortWebJson: {}\",\n+                projectId, portId, portWebJson);\n \n-        Stack<PortStateRollback> rollbacks = new Stack<>();\n+        Stack<Rollback> rollbacks = new Stack<>();\n         AsyncExecutor executor = new AsyncExecutor();\n \n-        PortState portState = portStateJson.getPortState();\n-        portState.setProjectId(projectId);\n+        PortEntity portEntity = portWebJson.getPortEntity();\n+        portEntity.setProjectId(projectId);\n \n         try {\n-            PortState oldPortState = portRepository.findItem(portId);\n-            if (oldPortState == null) {\n-                throw new PortStateNotFoundException();\n+            PortEntity oldPortEntity = portRepository.findItem(portId);\n+            if (oldPortEntity == null) {\n+                throw new PortEntityNotFound();\n             }\n \n-            updatePortStateAsync(portState, oldPortState, executor, rollbacks);\n+            boolean needNotifyDpm = updatePortAsync(portEntity, oldPortEntity, executor, rollbacks);\n+            if (needNotifyDpm) {\n+                getPortDependentResources(oldPortEntity, executor);\n+            }\n \n             //Wait for all async functions to finish\n-            executor.joinAll();\n+            List<Object> entities = executor.joinAll();\n+\n+            //Build GoalState and send it to DPM\n+            if (needNotifyDpm) {\n+                entities.add(oldPortEntity);\n+                DataPlaneManagerProxy dataPlaneManagerProxy = new DataPlaneManagerProxy(rollbacks);\n+                Goalstate.GoalState goalState = GoalStateUtil.buildGoalState(entities, Common.OperationType.UPDATE);\n+                dataPlaneManagerProxy.updateGoalState(goalState);\n+            }\n \n             //Persist the new configuration of port to the db\n-            portRepository.addItem(oldPortState);\n-            portStateJson.setPortState(oldPortState);\n+            portRepository.addItem(oldPortEntity);\n+            portWebJson.setPortEntity(oldPortEntity);\n         } catch (Exception e) {\n             exceptionHandle(executor, rollbacks, e);\n         }\n \n-        LOG.debug(\"Update port state success, portStateJson: {}\", portStateJson);\n+        LOG.debug(\"Update port state success, portWebJson: {}\", portWebJson);\n \n-        return portStateJson;\n+        return portWebJson;\n     }\n \n     /**\n"}}, {"oid": "91932144cbb23bb6f1854a0f5d15ea5e06827d84", "url": "https://github.com/futurewei-cloud/alcor/commit/91932144cbb23bb6f1854a0f5d15ea5e06827d84", "message": "port manager interact with dataplane manager", "committedDate": "2020-06-02T12:30:48Z", "type": "forcePushed"}, {"oid": "93a59b92e1780501be96c5c7511f1fafd6e76a23", "url": "https://github.com/futurewei-cloud/alcor/commit/93a59b92e1780501be96c5c7511f1fafd6e76a23", "message": "turn on all UTs of port-manager", "committedDate": "2020-06-03T01:51:22Z", "type": "commit"}, {"oid": "737196623b1829d36a78ec24712b6daef1f8b639", "url": "https://github.com/futurewei-cloud/alcor/commit/737196623b1829d36a78ec24712b6daef1f8b639", "message": "batch operations are supported for the creation and update of port", "committedDate": "2020-06-03T01:51:24Z", "type": "commit"}, {"oid": "c68200cd01d7da17f76ea9e3cde673b89900e0c7", "url": "https://github.com/futurewei-cloud/alcor/commit/c68200cd01d7da17f76ea9e3cde673b89900e0c7", "message": "rebase from master", "committedDate": "2020-06-03T01:51:27Z", "type": "commit"}, {"oid": "a20ff164d9b9089670b10e4453075c7ae9964b2d", "url": "https://github.com/futurewei-cloud/alcor/commit/a20ff164d9b9089670b10e4453075c7ae9964b2d", "message": "add API specs and basic design for Port Manager", "committedDate": "2020-06-03T01:51:27Z", "type": "commit"}, {"oid": "5db1d48ca913008d235046eb6a1d0e0d6eb17098", "url": "https://github.com/futurewei-cloud/alcor/commit/5db1d48ca913008d235046eb6a1d0e0d6eb17098", "message": "add some missing fileds to PortState", "committedDate": "2020-06-03T01:51:30Z", "type": "commit"}, {"oid": "80730b0ee2e310f2eb591ba8aaf1360cf04a4e8a", "url": "https://github.com/futurewei-cloud/alcor/commit/80730b0ee2e310f2eb591ba8aaf1360cf04a4e8a", "message": "rebase from master", "committedDate": "2020-06-03T01:51:32Z", "type": "commit"}, {"oid": "d406a27e6c3c092154f8726100a75ed42b48d711", "url": "https://github.com/futurewei-cloud/alcor/commit/d406a27e6c3c092154f8726100a75ed42b48d711", "message": "port manager interact with dataplane manager", "committedDate": "2020-06-03T01:51:37Z", "type": "commit"}, {"oid": "d8f1bbe0f7a33a1183e3da7c047d23a25a93350f", "url": "https://github.com/futurewei-cloud/alcor/commit/d8f1bbe0f7a33a1183e3da7c047d23a25a93350f", "message": "add security group test cases", "committedDate": "2020-06-03T03:37:33Z", "type": "forcePushed"}, {"oid": "80608d29d4f49608b260f636f74f05074cb717c9", "url": "https://github.com/futurewei-cloud/alcor/commit/80608d29d4f49608b260f636f74f05074cb717c9", "message": "add security group test cases", "committedDate": "2020-06-03T03:56:49Z", "type": "forcePushed"}, {"oid": "80608d29d4f49608b260f636f74f05074cb717c9", "url": "https://github.com/futurewei-cloud/alcor/commit/80608d29d4f49608b260f636f74f05074cb717c9", "message": "add security group test cases", "committedDate": "2020-06-03T03:56:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMjY1OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434322658", "bodyText": "\".which\" => \", which\"", "author": "xieus", "createdAt": "2020-06-03T05:51:34Z", "path": "lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java", "diffHunk": "@@ -44,6 +44,15 @@ public AsyncExecutor() {\n         return CompletableFuture.supplyAsync(supplier);\n     }\n \n+    /**\n+     * Execute the function(first parameter) asynchronously.which has one input parameter", "originalCommit": "80608d29d4f49608b260f636f74f05074cb717c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1857c1695fd45fb12f0f3ea2ee6a846e10d777e2", "chunk": "diff --git a/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java b/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java\nindex c76e42840..a0a2b149f 100644\n--- a/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java\n+++ b/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java\n\n@@ -45,7 +45,7 @@ public class AsyncExecutor {\n     }\n \n     /**\n-     * Execute the function(first parameter) asynchronously.which has one input parameter\n+     * Execute the function(first parameter) asynchronously which has one input parameter\n      * and one return value. The type of input parameter is Object, and the return value is R.\n      * @param fun The function to be executed\n      * @param args The parameter of the function being executed\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNDg0NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434324844", "bodyText": "\".which\" => \", which\"", "author": "xieus", "createdAt": "2020-06-03T05:58:24Z", "path": "lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java", "diffHunk": "@@ -58,13 +67,146 @@ public AsyncExecutor() {\n         return future;\n     }\n \n-    public void joinAll() throws CompletionException {\n+    /**\n+     * Execute the function(first parameter) asynchronously.which has one input parameter", "originalCommit": "80608d29d4f49608b260f636f74f05074cb717c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNTA0NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434325045", "bodyText": "Is this comment supposed to be the same as \"runAsync\"?", "author": "xieus", "createdAt": "2020-06-03T05:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMzMzc5MA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434333790", "bodyText": "Oh, Let me add some comments for these methods.", "author": "chenpiaoping", "createdAt": "2020-06-03T06:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg0ODE2OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434848169", "bodyText": "Like those new comments \ud83d\udc4d", "author": "xieus", "createdAt": "2020-06-03T20:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNDg0NA=="}], "type": "inlineReview", "revised_code": {"commit": "1857c1695fd45fb12f0f3ea2ee6a846e10d777e2", "chunk": "diff --git a/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java b/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java\nindex c76e42840..a0a2b149f 100644\n--- a/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java\n+++ b/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java\n\n@@ -68,13 +68,39 @@ public class AsyncExecutor {\n     }\n \n     /**\n-     * Execute the function(first parameter) asynchronously.which has one input parameter\n-     * and one return value. The type of input parameter is Object, and the return value is R.\n-     * @param fun1 The function to be executed\n-     * @param fun2 The function to be executed\n+     * Execute the function asynchronously which has two input parameters and one return value.\n+     * The two input parameters of the function are Object, and the return value is R.\n+     * @param fun The function to be executed\n      * @param arg1 The parameter of the function being executed\n-     * @param <R> The parameter of the function being executed\n-     * @param <U> The type of return value of the function being executed\n+     * @param arg2 The parameter of the function being executed\n+     * @param <R> The type of return value of the function being executed\n+     * @return CompletableFuture\n+     * @throws CompletionException\n+     */\n+    public <R>CompletableFuture runAsync(AsyncFunctionWithTwoArgs<Object,Object, R> fun, Object arg1, Object arg2) throws CompletionException {\n+        CompletableFuture<R> future = CompletableFuture.supplyAsync(() -> {\n+            try {\n+                return fun.apply(arg1, arg2);\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            }\n+        }, executor);\n+\n+        futures.add(future);\n+\n+        return future;\n+    }\n+\n+    /**\n+     * Execute fun1 asynchronously, after the execution of fun1 is finished, the output of fun1\n+     * is used as the input parameter of fun2 to continue to execute fun2. arg1 is the input\n+     * parameter of fun1, the output of fun1 is used as the input parameter of fun2. And the output\n+     * of fun2 as the final return value.\n+     * @param fun1 The function to be executed\n+     * @param fun2 The function to be executed after the execution of fun1 is finished\n+     * @param arg1 Input parameters of fun1\n+     * @param <R> Return Type of fun1\n+     * @param <U> Return Type of fun2\n      * @return CompletableFuture\n      * @throws CompletionException\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzIyMQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434327221", "bodyText": "Okay. We definitely need comments on each of these methods.", "author": "xieus", "createdAt": "2020-06-03T06:05:54Z", "path": "lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java", "diffHunk": "@@ -58,13 +67,146 @@ public AsyncExecutor() {\n         return future;\n     }\n \n-    public void joinAll() throws CompletionException {\n+    /**\n+     * Execute the function(first parameter) asynchronously.which has one input parameter\n+     * and one return value. The type of input parameter is Object, and the return value is R.\n+     * @param fun1 The function to be executed\n+     * @param fun2 The function to be executed\n+     * @param arg1 The parameter of the function being executed\n+     * @param <R> The parameter of the function being executed\n+     * @param <U> The type of return value of the function being executed\n+     * @return CompletableFuture\n+     * @throws CompletionException\n+     */\n+    public <R, U>CompletableFuture runAsyncThenApply(AsyncFunction<Object, R> fun1, AsyncFunction<Object, U> fun2, Object arg1) throws CompletionException {\n+        CompletableFuture<U> future = CompletableFuture.supplyAsync(() -> {\n+            try {\n+                return fun1.apply(arg1);\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            }\n+        }, executor).thenApply((ret) -> {\n+            try {\n+                return fun2.apply(ret);\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            }\n+        });\n+\n+        futures.add(future);\n+\n+        return future;\n+    }\n+\n+    public <R, U>CompletableFuture runAsyncThenApply(AsyncFunction<Object, R> fun1, AsyncFunction<Object, U> fun2, Object arg1, Object arg2) throws CompletionException {\n+        CompletableFuture<U> future = CompletableFuture.supplyAsync(() -> {\n+            try {\n+                return fun1.apply(arg1);\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            }\n+        }, executor).thenApply((ret) -> {\n+            try {\n+                return fun2.apply(arg2);\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            }\n+        });\n+\n+        futures.add(future);\n+\n+        return future;\n+    }\n+\n+    public <R, U>CompletableFuture runAsyncThenAccept(AsyncFunction<Object, R> fun1, AsyncFunction<Object, U> fun2, Object arg1) throws CompletionException {", "originalCommit": "80608d29d4f49608b260f636f74f05074cb717c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1857c1695fd45fb12f0f3ea2ee6a846e10d777e2", "chunk": "diff --git a/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java b/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java\nindex c76e42840..a0a2b149f 100644\n--- a/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java\n+++ b/lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java\n\n@@ -68,13 +68,39 @@ public class AsyncExecutor {\n     }\n \n     /**\n-     * Execute the function(first parameter) asynchronously.which has one input parameter\n-     * and one return value. The type of input parameter is Object, and the return value is R.\n-     * @param fun1 The function to be executed\n-     * @param fun2 The function to be executed\n+     * Execute the function asynchronously which has two input parameters and one return value.\n+     * The two input parameters of the function are Object, and the return value is R.\n+     * @param fun The function to be executed\n      * @param arg1 The parameter of the function being executed\n-     * @param <R> The parameter of the function being executed\n-     * @param <U> The type of return value of the function being executed\n+     * @param arg2 The parameter of the function being executed\n+     * @param <R> The type of return value of the function being executed\n+     * @return CompletableFuture\n+     * @throws CompletionException\n+     */\n+    public <R>CompletableFuture runAsync(AsyncFunctionWithTwoArgs<Object,Object, R> fun, Object arg1, Object arg2) throws CompletionException {\n+        CompletableFuture<R> future = CompletableFuture.supplyAsync(() -> {\n+            try {\n+                return fun.apply(arg1, arg2);\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            }\n+        }, executor);\n+\n+        futures.add(future);\n+\n+        return future;\n+    }\n+\n+    /**\n+     * Execute fun1 asynchronously, after the execution of fun1 is finished, the output of fun1\n+     * is used as the input parameter of fun2 to continue to execute fun2. arg1 is the input\n+     * parameter of fun1, the output of fun1 is used as the input parameter of fun2. And the output\n+     * of fun2 as the final return value.\n+     * @param fun1 The function to be executed\n+     * @param fun2 The function to be executed after the execution of fun1 is finished\n+     * @param arg1 Input parameters of fun1\n+     * @param <R> Return Type of fun1\n+     * @param <U> Return Type of fun2\n      * @return CompletableFuture\n      * @throws CompletionException\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzg5MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434327891", "bodyText": "Move util class from port manager to common is great. I remember previous attempt of moving this caused some UT failure or so.", "author": "xieus", "createdAt": "2020-06-03T06:08:02Z", "path": "lib/src/main/java/com/futurewei/alcor/common/utils/SpringContextUtil.java", "diffHunk": "@@ -13,7 +13,7 @@\n         See the License for the specific language governing permissions and\n         limitations under the License.\n */\n-package com.futurewei.alcor.portmanager.util;\n+package com.futurewei.alcor.common.utils;", "originalCommit": "80608d29d4f49608b260f636f74f05074cb717c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "1857c1695fd45fb12f0f3ea2ee6a846e10d777e2", "url": "https://github.com/futurewei-cloud/alcor/commit/1857c1695fd45fb12f0f3ea2ee6a846e10d777e2", "message": "add some comments for methods of AsyncExecutor", "committedDate": "2020-06-03T07:00:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMzOTM0NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434339345", "bodyText": "Just checked SGM PR #208. Didn't find these entity classes there.", "author": "xieus", "createdAt": "2020-06-03T06:38:50Z", "path": "web/src/main/java/com/futurewei/alcor/web/entity/securitygroup/SecurityGroupEntity.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+        http://www.apache.org/licenses/LICENSE-2.0\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.web.entity.securitygroup;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.futurewei.alcor.common.entity.CustomerResource;\n+\n+import java.util.List;\n+\n+public class SecurityGroupEntity extends CustomerResource {", "originalCommit": "80608d29d4f49608b260f636f74f05074cb717c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NzAyOQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434347029", "bodyText": "If this PR checked in first, I will assume that SGM will use the same set of entity classes from alcor/web/securitygroup/", "author": "xieus", "createdAt": "2020-06-03T06:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMzOTM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2ODkxNA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434368914", "bodyText": "yes, I use the new name SecurityGroupEntity instead of SecurityGroup like PortEntity. I will rename it in the SGM PR.", "author": "chenpiaoping", "createdAt": "2020-06-03T07:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMzOTM0NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MDUxNQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434340515", "bodyText": "Like it!", "author": "xieus", "createdAt": "2020-06-03T06:41:38Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/repo/PortRepository.java", "diffHunk": "@@ -61,6 +63,15 @@ public void addItem(PortEntity portEntity) throws CacheException {\n         cache.put(portEntity.getId(), portEntity);\n     }\n \n+    //@Override\n+    public void addItems(List<PortEntity> portEntities) throws CacheException {\n+        Map<String, PortEntity> portEntityMap = portEntities\n+                .stream()\n+                .collect(Collectors.toMap(PortEntity::getId, Function.identity()));\n+\n+        cache.putAll(portEntityMap);", "originalCommit": "80608d29d4f49608b260f636f74f05074cb717c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MzI4OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434343288", "bodyText": "Issue\nThe buildGoalState method will be used for constructing the message sent from DPM to ACA. I think port manager needs to call REST API of DPM.", "author": "xieus", "createdAt": "2020-06-03T06:48:13Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java", "diffHunk": "@@ -94,94 +95,167 @@ private void addPortToHost(String hostId) {\n         //FIXME: Add port to Host\n     }\n \n+    private void createPortAsync(PortEntity portEntity, AsyncExecutor executor, Stack<Rollback> rollbacks) throws Exception {\n+        //Verify VPC ID\n+        VpcManagerProxy vpcManagerProxy = new VpcManagerProxy(rollbacks);\n+        executor.runAsync(vpcManagerProxy::getVpcEntity, portEntity);\n+\n+        //Allocate IP address\n+        IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, portEntity.getProjectId());\n+        SubnetManagerProxy subnetManagerProxy = new SubnetManagerProxy(portEntity.getProjectId());\n+        if (portEntity.getFixedIps() != null) {\n+            for (PortEntity.FixedIp fixedIp: portEntity.getFixedIps()) {\n+                executor.runAsyncThenAccept(subnetManagerProxy::getSubnetEntity,\n+                        ipManagerProxy::allocateFixedIpAddress,\n+                        fixedIp, fixedIp);\n+            }\n+        } else {\n+            executor.runAsyncThenApply(ipManagerProxy::allocateRandomIpAddress,\n+                    subnetManagerProxy::getSubnetEntity,\n+                    portEntity);\n+        }\n+\n+        //Generate uuid for port\n+        if (portEntity.getId() == null) {\n+            portEntity.setId(UUID.randomUUID().toString());\n+        }\n+\n+        //Allocate MAC address\n+        MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n+        if (portEntity.getMacAddress() == null) {\n+            executor.runAsync(macManagerProxy::allocateRandomMacAddress, portEntity);\n+        } else {\n+            executor.runAsync(macManagerProxy::allocateFixedMacAddress, portEntity);\n+        }\n+\n+        //Verify and bind security group\n+        SecurityGroupManagerProxy securityGroupManagerProxy = new SecurityGroupManagerProxy(portEntity.getProjectId());\n+        if (portEntity.getSecurityGroups() != null) {\n+            for (String securityGroupId: portEntity.getSecurityGroups()) {\n+                executor.runAsync(securityGroupManagerProxy::getSecurityGroupEntity, securityGroupId);\n+                executor.runAsync(securityGroupManagerProxy::bindSecurityGroup, portEntity);\n+            }\n+        } else {\n+            //Do we need to bind default security group? No, we don't\n+            executor.runAsync(securityGroupManagerProxy::getDefaultSecurityGroupEntity, null);\n+        }\n+\n+        //Get subnet route\n+        if (portEntity.getFixedIps() != null) {\n+            RouteManagerProxy routeManagerProxy = new RouteManagerProxy(rollbacks);\n+\n+            for (PortEntity.FixedIp fixedIp: portEntity.getFixedIps()) {\n+                executor.runAsync(routeManagerProxy::getRouteBySubnetId, fixedIp.getSubnetId());\n+            }\n+        }\n+\n+        //Verify Binding Host ID\n+        if (portEntity.getBindingHostId() != null) {\n+            NodeManagerProxy nodeManagerProxy = new NodeManagerProxy(rollbacks);\n+            executor.runAsync(nodeManagerProxy::getNodeInfo, portEntity.getBindingHostId());\n+        }\n+    }\n+\n+    private void exceptionHandle(AsyncExecutor executor, Stack<Rollback> rollbacks, Exception e) throws Exception {\n+        /**\n+         When an exception occurs, we need to roll back all asynchronous operations,\n+         and some asynchronous may not be finished yet.if we roll back at this time,\n+         they may not be completed until the rollback operation is completed.\n+         as a result, they cannot be rolled back.\n+         */\n+        executor.waitAll();\n+        rollBackAllOperations(rollbacks);\n+        throw e;\n+    }\n+\n     /**\n      * Create a port, and call the interfaces of each micro-service according to the\n      * configuration of the port to create various required resources for the port.\n      * If any exception occurs in the added process, we need to roll back\n      * the resource allocated from each micro-service.\n      * @param projectId Project the port belongs to\n      * @param portWebJson Port configuration\n-     * @return PortStateJson\n+     * @return PortWebJson\n      * @throws Exception Various exceptions that may occur during the create process\n      */\n     @Override\n-    public PortWebJson createPortState(String projectId, PortWebJson portWebJson) throws Exception {\n-        LOG.debug(\"Create port state, projectId: {}, PortStateJson: {}\", projectId, portWebJson);\n+    public PortWebJson createPort(String projectId, PortWebJson portWebJson) throws Exception {\n+        LOG.debug(\"Create port state, projectId: {}, PortWebJson: {}\", projectId, portWebJson);\n \n-        Stack<PortStateRollback> rollbacks = new Stack<>();\n+        Stack<Rollback> rollbacks = new Stack<>();\n         AsyncExecutor executor = new AsyncExecutor();\n \n         PortEntity portEntity = portWebJson.getPortEntity();\n         portEntity.setProjectId(projectId);\n \n         try {\n-            //Verify VPC ID\n-            VpcManagerProxy vpcManagerProxy = new VpcManagerProxy(rollbacks);\n-            executor.runAsync(vpcManagerProxy::verifyVpc, portEntity);\n-\n-            IpManagerProxy ipManagerProxy = new IpManagerProxy(rollbacks, portEntity.getProjectId());\n-            if (portEntity.getFixedIps() == null) {\n-                executor.runAsync(ipManagerProxy::allocateRandomIpAddress, portEntity);\n-            } else {\n-                executor.runAsync(ipManagerProxy::allocateFixedIpAddress, portEntity.getFixedIps());\n-            }\n+            createPortAsync(portEntity, executor, rollbacks);\n \n-            //Generate uuid for port\n-            if (portEntity.getId() == null) {\n-                portEntity.setId(UUID.randomUUID().toString());\n-            }\n-\n-            MacManagerProxy macManagerProxy = new MacManagerProxy(rollbacks);\n-            if (portEntity.getMacAddress() == null) {\n-                executor.runAsync(macManagerProxy::allocateRandomMacAddress, portEntity);\n-            } else {\n-                executor.runAsync(macManagerProxy::allocateFixedMacAddress, portEntity);\n-            }\n-\n-            //Verify security group\n+            //Wait for all async functions to finish\n+            List<Object> entities = executor.joinAll();\n+            entities.add(portEntity);\n \n-            //Verify Binding Host ID\n+            //Build GoalState and Send it to DPM\n             if (portEntity.getBindingHostId() != null) {\n-                NodeManagerProxy nodeManagerProxy = new NodeManagerProxy(rollbacks);\n-                nodeManagerProxy.verifyHost(portEntity.getBindingHostId());\n+                Goalstate.GoalState goalState = GoalStateUtil.buildGoalState(entities, Common.OperationType.CREATE);", "originalCommit": "80608d29d4f49608b260f636f74f05074cb717c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2OTc2NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434369764", "bodyText": "Oh, I see. Can I fix it after DPM is merged?", "author": "chenpiaoping", "createdAt": "2020-06-03T07:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MzI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MjI1Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434642257", "bodyText": "Definitely.", "author": "xieus", "createdAt": "2020-06-03T15:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MzI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg1MDYxNA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434850614", "bodyText": "Use Issue #230 for tracking purpose.", "author": "xieus", "createdAt": "2020-06-03T20:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MzI4OA=="}], "type": "inlineReview", "revised_code": {"commit": "3d6fe808558f4bbcd207612939cf31e6c9dbdb66", "chunk": "diff --git a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\nindex 5f5edb405..b39927e17 100644\n--- a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n+++ b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/service/implement/PortServiceImpl.java\n\n@@ -85,16 +52,6 @@ public class PortServiceImpl implements PortService {\n         }\n     }\n \n-    private HostState getHostState(String hostId) {\n-        return null;\n-    }\n-\n-    private void addPortToHost(String hostId) {\n-        HostState hostState = getHostState(hostId);\n-\n-        //FIXME: Add port to Host\n-    }\n-\n     private void createPortAsync(PortEntity portEntity, AsyncExecutor executor, Stack<Rollback> rollbacks) throws Exception {\n         //Verify VPC ID\n         VpcManagerProxy vpcManagerProxy = new VpcManagerProxy(rollbacks);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NDM2MA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434344360", "bodyText": "As mentioned previously, Port Manager shouldn't use any class under alcor.schema.*", "author": "xieus", "createdAt": "2020-06-03T06:50:45Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/util/GoalStateUtil.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.portmanager.util;\n+\n+import com.futurewei.alcor.portmanager.exception.*;\n+import com.futurewei.alcor.schema.*;", "originalCommit": "80608d29d4f49608b260f636f74f05074cb717c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2OTkxNQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434369915", "bodyText": "Got it.", "author": "chenpiaoping", "createdAt": "2020-06-03T07:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NDM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg1MTE4Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434851187", "bodyText": "Use Issue #230 for tracking purpose.", "author": "xieus", "createdAt": "2020-06-03T21:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NDM2MA=="}], "type": "inlineReview", "revised_code": {"commit": "52dca37ba2fe03e883212eb2843d853412c48743", "chunk": "diff --git a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/util/GoalStateUtil.java b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/util/GoalStateUtil.java\nindex 843e39699..a245956de 100644\n--- a/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/util/GoalStateUtil.java\n+++ b/services/port_manager/src/main/java/com/futurewei/alcor/portmanager/util/GoalStateUtil.java\n\n@@ -212,7 +212,7 @@ public class GoalStateUtil {\n \n         //Required fields\n         portConfigBuilder.setId(portEntity.getId());\n-        portConfigBuilder.setVpcId(portEntity.getNetworkId());\n+        portConfigBuilder.setVpcId(portEntity.getVpcId());\n         portConfigBuilder.setMacAddress(portEntity.getMacAddress());\n \n         for (PortEntity.FixedIp fixedIp: portEntity.getFixedIps()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NjUzNA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434346534", "bodyText": "I would recommend to use the following way: Externally we call it network_id, but internally we call it vpcId. This is the way how VPC/Subnet Manager handles the inconsistency.\n@JsonProperty(\"network_id\")\nprivate String vpcId;", "author": "xieus", "createdAt": "2020-06-03T06:55:40Z", "path": "web/src/main/java/com/futurewei/alcor/web/entity/port/PortEntity.java", "diffHunk": "@@ -24,8 +24,8 @@\n \n @Data\n public class PortEntity extends CustomerResource {\n-    @JsonProperty(\"vpc_id\")\n-    private String vpcId;\n+    @JsonProperty(\"network_id\")\n+    private String networkId;", "originalCommit": "80608d29d4f49608b260f636f74f05074cb717c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM3MTQ3NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434371474", "bodyText": "ok", "author": "chenpiaoping", "createdAt": "2020-06-03T07:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NjUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcwOTIxMA==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434709210", "bodyText": "The change looks good!", "author": "xieus", "createdAt": "2020-06-03T16:43:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NjUzNA=="}], "type": "inlineReview", "revised_code": {"commit": "52dca37ba2fe03e883212eb2843d853412c48743", "chunk": "diff --git a/web/src/main/java/com/futurewei/alcor/web/entity/port/PortEntity.java b/web/src/main/java/com/futurewei/alcor/web/entity/port/PortEntity.java\nindex 25a4f7f3d..ca5eec3b4 100644\n--- a/web/src/main/java/com/futurewei/alcor/web/entity/port/PortEntity.java\n+++ b/web/src/main/java/com/futurewei/alcor/web/entity/port/PortEntity.java\n\n@@ -25,7 +25,7 @@ import java.util.List;\n @Data\n public class PortEntity extends CustomerResource {\n     @JsonProperty(\"network_id\")\n-    private String networkId;\n+    private String vpcId;\n \n     @JsonProperty(\"tenant_id\")\n     private String tenantId;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0ODE1Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434348157", "bodyText": "Like you moved restclient to the AlcorCommon. This is awesome!", "author": "xieus", "createdAt": "2020-06-03T06:59:06Z", "path": "web/src/main/java/com/futurewei/alcor/web/restclient/IpManagerRestClient.java", "diffHunk": "@@ -13,7 +13,7 @@\n         See the License for the specific language governing permissions and\n         limitations under the License.\n */\n-package com.futurewei.alcor.portmanager.restclient;\n+package com.futurewei.alcor.web.restclient;", "originalCommit": "80608d29d4f49608b260f636f74f05074cb717c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM1MDQxMg==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434350412", "bodyText": "Nice comments!", "author": "xieus", "createdAt": "2020-06-03T07:04:02Z", "path": "lib/src/main/java/com/futurewei/alcor/common/executor/AsyncExecutor.java", "diffHunk": "@@ -45,7 +45,7 @@ public AsyncExecutor() {\n     }\n \n     /**\n-     * Execute the function(first parameter) asynchronously.which has one input parameter\n+     * Execute the function(first parameter) asynchronously which has one input parameter", "originalCommit": "1857c1695fd45fb12f0f3ea2ee6a846e10d777e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "3d6fe808558f4bbcd207612939cf31e6c9dbdb66", "url": "https://github.com/futurewei-cloud/alcor/commit/3d6fe808558f4bbcd207612939cf31e6c9dbdb66", "message": "modify some comments", "committedDate": "2020-06-03T07:23:26Z", "type": "commit"}, {"oid": "52dca37ba2fe03e883212eb2843d853412c48743", "url": "https://github.com/futurewei-cloud/alcor/commit/52dca37ba2fe03e883212eb2843d853412c48743", "message": "rename networkId to vpcId", "committedDate": "2020-06-03T08:01:10Z", "type": "commit"}, {"oid": "6ce0658abac0925e94c1c3369a1c5d7e5bdba82a", "url": "https://github.com/futurewei-cloud/alcor/commit/6ce0658abac0925e94c1c3369a1c5d7e5bdba82a", "message": "rename fastPath to fast_path", "committedDate": "2020-06-03T08:16:08Z", "type": "commit"}, {"oid": "da743c06ee0ae6dd23cbcb5faa197c6fb5cdc806", "url": "https://github.com/futurewei-cloud/alcor/commit/da743c06ee0ae6dd23cbcb5faa197c6fb5cdc806", "message": "add some update port UTs for port-manager", "committedDate": "2020-06-03T10:36:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxNTUzNw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434715537", "bodyText": "Good call to comment out IPv6 allocation for now. Let us revisit IPv6 allocation when other components are more ready. Created a tracking issue in case we forget.\nIssue #227", "author": "xieus", "createdAt": "2020-06-03T16:53:55Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/proxy/IpManagerProxy.java", "diffHunk": "@@ -104,19 +118,37 @@ private void addIpAddrRollback(AbstractIpAddrRollback rollback, IpAddrRequest ip\n         addIpAddrRollback(new AllocateIpAddrRollback(ipManagerRestClient), ipv4Addr);\n \n         //Allocate a random ipv6 address", "originalCommit": "da743c06ee0ae6dd23cbcb5faa197c6fb5cdc806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxNjMzMw==", "url": "https://github.com/futurewei-cloud/alcor/pull/197#discussion_r434716333", "bodyText": "Minor comment: rename it to genereateMacState.", "author": "xieus", "createdAt": "2020-06-03T16:55:14Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/proxy/MacManagerProxy.java", "diffHunk": "@@ -42,6 +43,16 @@ private void addMacAddrRollback(AbstractMacAddrRollback rollback, MacState macSt\n         rollbacks.push(rollback);\n     }\n \n+    private MacState newMacState(String projectId, String vpcId, String portId, String macAddress) {", "originalCommit": "da743c06ee0ae6dd23cbcb5faa197c6fb5cdc806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}