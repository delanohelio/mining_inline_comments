{"pr_number": 594, "pr_title": "CLDR-14016 fix alias rules", "pr_createdAt": "2020-07-30T01:15:23Z", "pr_url": "https://github.com/unicode-org/cldr/pull/594", "timeline": [{"oid": "88c7325f4e22788f9d1a0bffb5a811f1faf0d440", "url": "https://github.com/unicode-org/cldr/commit/88c7325f4e22788f9d1a0bffb5a811f1faf0d440", "message": "CLDR-14016 fix alias rules", "committedDate": "2020-08-21T23:32:39Z", "type": "forcePushed"}, {"oid": "46cd038d971c2bef8549c73952e558b71e2b35e0", "url": "https://github.com/unicode-org/cldr/commit/46cd038d971c2bef8549c73952e558b71e2b35e0", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-24T19:19:07Z", "type": "forcePushed"}, {"oid": "d81604b90d199ff6219139c291cf212ff0732bf7", "url": "https://github.com/unicode-org/cldr/commit/d81604b90d199ff6219139c291cf212ff0732bf7", "message": "CLDR-14016 Clean up tests", "committedDate": "2020-08-25T00:25:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NzU1Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475877556", "bodyText": "This is a new class that uses the canonicalization of the LSRV part of a locale identifier to verify correctness of the algorithm and test data.", "author": "macchiati", "createdAt": "2020-08-24T20:34:10Z", "path": "tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.unicode.cldr.unittest;", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNTE3Mg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476415172", "bodyText": "JavaDoc or link to a design doc?", "author": "hagbard", "createdAt": "2020-08-25T12:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NzU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU5MzIwOA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476593208", "bodyText": "Added to javadoc", "author": "macchiati", "createdAt": "2020-08-25T16:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NzU1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "chunk": "diff --git a/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java b/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\nindex 9fdf6e79d2..8bd48dbb39 100644\n--- a/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\n+++ b/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\n\n@@ -1,20 +1,35 @@\n package org.unicode.cldr.unittest;\n \n import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Set;\n \n+import org.unicode.cldr.util.CLDRConfig;\n+import org.unicode.cldr.util.CLDRFile;\n import org.unicode.cldr.util.LsrvCanonicalizer;\n import org.unicode.cldr.util.LsrvCanonicalizer.ReplacementRule;\n import org.unicode.cldr.util.LsrvCanonicalizer.TestDataTypes;\n import org.unicode.cldr.util.LsrvCanonicalizer.XLanguageTag;\n+import org.unicode.cldr.util.StandardCodes;\n+import org.unicode.cldr.util.StandardCodes.LstrField;\n import org.unicode.cldr.util.StandardCodes.LstrType;\n+import org.unicode.cldr.util.SupplementalDataInfo;\n \n import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n import com.ibm.icu.dev.test.TestFmwk;\n+import com.ibm.icu.impl.Row.R2;\n \n+/**\n+ * TestLsrvCanonicalizer is used to verify the correctness of the specification algorithm,\n+ * sanity-check the supplementalMetadata.xml alias data,\n+ * and generate test files for use by implementations.\n+ */\n public class TestLsrvCanonicalizer extends TestFmwk {\n \n     static final LsrvCanonicalizer rrs = LsrvCanonicalizer.getInstance();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3ODIyMw==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475878223", "bodyText": "A new class that generates the test data above.", "author": "macchiati", "createdAt": "2020-08-24T20:35:25Z", "path": "tools/java/org/unicode/cldr/tool/GenerateLocaleTestData.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.unicode.cldr.tool;", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d81604b90d199ff6219139c291cf212ff0732bf7", "chunk": "diff --git a/tools/java/org/unicode/cldr/tool/GenerateLocaleTestData.java b/tools/java/org/unicode/cldr/tool/GenerateLocaleTestData.java\nindex 83cc913b16..33da58f859 100644\n--- a/tools/java/org/unicode/cldr/tool/GenerateLocaleTestData.java\n+++ b/tools/java/org/unicode/cldr/tool/GenerateLocaleTestData.java\n\n@@ -23,11 +23,11 @@ public class GenerateLocaleTestData {\n                 + \"# <source locale identifier>\\t;\\t<expected canonicalized locale identifier>\\n\"\n                 + \"#\\n\"\n                 + \"# The data lines are divided into 4 sets:\\n\"\n-                + \"#   \" + LsrvCanonicalizer.TestDataTypes.explicit + \": a short list of explicit test cases.\\n\"\n+                + \"#   \" + LsrvCanonicalizer.TestDataTypes.explicit + \":    a short list of explicit test cases.\\n\"\n                 + \"#   \" + LsrvCanonicalizer.TestDataTypes.fromAliases + \": test cases generated from the alias data.\\n\"\n                 + \"#   \" + LsrvCanonicalizer.TestDataTypes.decanonicalized + \": test cases generated by reversing the normalization process.\\n\"\n                 + \"#   \" + LsrvCanonicalizer.TestDataTypes.withIrrelevants + \": test cases generated from the others by adding irrelevant fields where possible,\\n\"\n-                + \"# to ensure that the canonicalization implementation is not sensitive to irrelevant fields. These include:\\n\"\n+                + \"#                           to ensure that the canonicalization implementation is not sensitive to irrelevant fields. These include:\\n\"\n                 + \"#     Language: \" + rrs.getIrrelevantField(LstrType.language) + \"\\n\"\n                 + \"#     Script:   \" + rrs.getIrrelevantField(LstrType.script) + \"\\n\"\n                 + \"#     Region:   \" + rrs.getIrrelevantField(LstrType.region) + \"\\n\"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3ODc5Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475878796", "bodyText": "Some small tweaks to add enum values for other elements used in validity (really for other tickets).", "author": "macchiati", "createdAt": "2020-08-24T20:36:25Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1036,7 +1036,9 @@ private void add(CodeType type, String code, List<String> otherData) {\n         /** specialized codes for validity; TODO: rename LstrType **/\n         currency(false, true, \"XXX\"),\n         subdivision(false, true),\n-        unit(false, true);\n+        unit(false, true),", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3OTIzNg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475879236", "bodyText": "Utility to account for some older code and data structures using 'territory' instead of 'region'.", "author": "macchiati", "createdAt": "2020-08-24T20:37:14Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1073,6 +1075,17 @@ boolean isWellFormed(String candidate) {\n         public String toCompatString() {\n             return this == region ? \"territory\" : toString();\n         }\n+\n+        public static LstrType fromString(String rawType) {", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMTk2Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476411966", "bodyText": "Please comment this to say how it conflates \"territory\" as an alternate identifier for region.", "author": "hagbard", "createdAt": "2020-08-25T12:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3OTIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU5NDg4Mg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476594882", "bodyText": "done", "author": "macchiati", "createdAt": "2020-08-25T16:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3OTIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "chunk": "diff --git a/tools/java/org/unicode/cldr/util/StandardCodes.java b/tools/java/org/unicode/cldr/util/StandardCodes.java\nindex 9726b5691c..b8245c82fc 100644\n--- a/tools/java/org/unicode/cldr/util/StandardCodes.java\n+++ b/tools/java/org/unicode/cldr/util/StandardCodes.java\n\n@@ -1072,14 +1072,25 @@ public class StandardCodes {\n             }\n         }\n \n+        /**\n+         * Generate compatibility string, returning 'territory' instead of 'region', etc.\n+         */\n         public String toCompatString() {\n-            return this == region ? \"territory\" : toString();\n+            switch (this) {\n+            case region: return \"territory\";\n+            case grandfathered: return \"language\";\n+            case redundant: return \"language\";\n+            default: return toString();\n+            }\n         }\n \n+        /**\n+         * Create LstrType from string, allowing the compat string 'territory'.\n+         */\n         public static LstrType fromString(String rawType) {\n             try {\n                 return valueOf(rawType);\n-            } catch (Exception e) {\n+            } catch (IllegalArgumentException e) {\n                 if (\"territory\".equals(rawType)) {\n                     return region;\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg4MDExMA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475880110", "bodyText": "This is used in matching a ReplacementRule. It is here instead of on ReplacementRule so we can use in the denormalization utility used in testing.", "author": "macchiati", "createdAt": "2020-08-24T20:38:57Z", "path": "tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.unicode.cldr.util;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ComparisonChain;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.TreeMultimap;\n+import com.ibm.icu.impl.Row.R2;\n+\n+/**\n+ * Provides Unicode Language Identifier canonicalization for use in testing.\n+ * The implementation is designed to be simple, and is not at all optimized for production use.\n+ */\n+public class LsrvCanonicalizer {\n+\n+    public static final Set<LstrType> LSRV = ImmutableSet.of(LstrType.language, LstrType.script, LstrType.region, LstrType.variant);\n+    public static final Joiner UNDERBAR_JOINER = Joiner.on('_');\n+\n+    /**\n+     * A representation of a Unicode Language Identifier in a format that makes it simple to process.\n+     * The LSRV fields are represented as multimaps, though the LSR fields restricted to have only have 0 or 1 element.\n+     */\n+    public static class XLanguageTag {\n+        final Multimap<LstrType, String> data;\n+\n+        private XLanguageTag(Multimap<LstrType, String> result) {\n+            data = ImmutableMultimap.copyOf(result);\n+        }\n+        public Set<LstrType> keys() {\n+            return data.keySet();\n+        }\n+        public Collection<String> get(LstrType lstrType) {\n+            return data.get(lstrType);\n+        }\n+        public String toLocaleString() {\n+            StringBuilder buffer = new StringBuilder();\n+            final Collection<String> region = data.get(LstrType.language);\n+            if (!region.isEmpty()) {\n+                buffer.append(UNDERBAR_JOINER.join(region));\n+            } else {\n+                buffer.append(\"und\");\n+            }\n+            addItem(buffer, LstrType.script, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \"\", \"_\", UNDERBAR_JOINER);\n+\n+            return buffer.toString();\n+        }\n+        @Override\n+        public String toString() {\n+            StringBuilder buffer = new StringBuilder();\n+            addItem(buffer, LstrType.language, \"\", \"L:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.script, \";\", \"S:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \";\", \"R:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \";\", \"V:\", UNDERBAR_JOINER);\n+            return buffer.toString();\n+        }\n+\n+        public void addItem(StringBuilder buffer, LstrType lstrType, String separator, String prefix, final Joiner dashJoiner) {\n+            final Collection<String> region = data.get(lstrType);\n+            if (!region.isEmpty()) {\n+                if (buffer.length() > 0) {\n+                    buffer.append(separator);\n+                }\n+                buffer.append(prefix).append(dashJoiner.join(region));\n+            }\n+        }\n+\n+        public static XLanguageTag fromTag(LstrType lstrType, String tag) {\n+            Multimap<LstrType,String> result = TreeMultimap.create();\n+            LanguageTagParser source = new LanguageTagParser();\n+            final boolean isLanguage = lstrType == LstrType.language;\n+            String prefix = isLanguage ? \"\" : \"und_\";\n+            try {\n+                source.set(prefix + tag);\n+            } catch (Exception e) {\n+                return null;  // skip ill-formed for now\n+//                if (lstrType == LstrType.region && tag.length() == 3) {\n+//                    //result.put(LstrType.language, \"und\");\n+//                    result.put(LstrType.region, tag);\n+//                } else {\n+//                    result.put(LstrType.language, tag);\n+//                }\n+//                //System.out.println(\"ILLEGAL SOURCE\\t\" + lstrType + \":\\t\" + tag + \" \u21d2 \" + result); // for debugging\n+//                return new XLanguageTag(result);\n+            }\n+            if (!source.getLanguage().isEmpty()\n+                && !source.getLanguage().contains(\"und\")) {\n+                result.put(LstrType.language, source.getLanguage());\n+            }\n+            if (!source.getScript().isEmpty()) {\n+                result.put(LstrType.script, source.getScript());\n+            }\n+            if (!source.getRegion().isEmpty()) {\n+                result.put(LstrType.region, source.getRegion());\n+            }\n+            if (!source.getVariants().isEmpty()) {\n+                result.putAll(LstrType.variant, source.getVariants());\n+            }\n+            return new XLanguageTag(result);\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            return data.equals(((XLanguageTag)obj).data);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return data.hashCode();\n+        }\n+        public XLanguageTag set(LstrType lstrType, String string) {\n+            Multimap<LstrType,String> result = TreeMultimap.create(data);\n+            if (lstrType != LstrType.variant) {\n+                result.removeAll(lstrType);\n+            }\n+            result.put(lstrType, string);\n+            return new XLanguageTag(result);\n+        }\n+\n+        public boolean containsAll(XLanguageTag type) {", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "chunk": "diff --git a/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java b/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\nindex d75727ea55..aa97c15f85 100644\n--- a/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\n+++ b/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\n\n@@ -27,6 +27,9 @@ import com.ibm.icu.impl.Row.R2;\n /**\n  * Provides Unicode Language Identifier canonicalization for use in testing.\n  * The implementation is designed to be simple, and is not at all optimized for production use.\n+ * It is used to verify the correctness of the specification algorithm,\n+ * sanity-check the supplementalMetadata.xml alias data,\n+ * and generate test files for use by implementations.\n  */\n public class LsrvCanonicalizer {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg4MTI3Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475881276", "bodyText": "This actually does the replacement. Also here instead of on ReplacementRule so we can use in the denormalization utility used in testing.", "author": "macchiati", "createdAt": "2020-08-24T20:41:22Z", "path": "tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.unicode.cldr.util;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ComparisonChain;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.TreeMultimap;\n+import com.ibm.icu.impl.Row.R2;\n+\n+/**\n+ * Provides Unicode Language Identifier canonicalization for use in testing.\n+ * The implementation is designed to be simple, and is not at all optimized for production use.\n+ */\n+public class LsrvCanonicalizer {\n+\n+    public static final Set<LstrType> LSRV = ImmutableSet.of(LstrType.language, LstrType.script, LstrType.region, LstrType.variant);\n+    public static final Joiner UNDERBAR_JOINER = Joiner.on('_');\n+\n+    /**\n+     * A representation of a Unicode Language Identifier in a format that makes it simple to process.\n+     * The LSRV fields are represented as multimaps, though the LSR fields restricted to have only have 0 or 1 element.\n+     */\n+    public static class XLanguageTag {\n+        final Multimap<LstrType, String> data;\n+\n+        private XLanguageTag(Multimap<LstrType, String> result) {\n+            data = ImmutableMultimap.copyOf(result);\n+        }\n+        public Set<LstrType> keys() {\n+            return data.keySet();\n+        }\n+        public Collection<String> get(LstrType lstrType) {\n+            return data.get(lstrType);\n+        }\n+        public String toLocaleString() {\n+            StringBuilder buffer = new StringBuilder();\n+            final Collection<String> region = data.get(LstrType.language);\n+            if (!region.isEmpty()) {\n+                buffer.append(UNDERBAR_JOINER.join(region));\n+            } else {\n+                buffer.append(\"und\");\n+            }\n+            addItem(buffer, LstrType.script, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \"\", \"_\", UNDERBAR_JOINER);\n+\n+            return buffer.toString();\n+        }\n+        @Override\n+        public String toString() {\n+            StringBuilder buffer = new StringBuilder();\n+            addItem(buffer, LstrType.language, \"\", \"L:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.script, \";\", \"S:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \";\", \"R:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \";\", \"V:\", UNDERBAR_JOINER);\n+            return buffer.toString();\n+        }\n+\n+        public void addItem(StringBuilder buffer, LstrType lstrType, String separator, String prefix, final Joiner dashJoiner) {\n+            final Collection<String> region = data.get(lstrType);\n+            if (!region.isEmpty()) {\n+                if (buffer.length() > 0) {\n+                    buffer.append(separator);\n+                }\n+                buffer.append(prefix).append(dashJoiner.join(region));\n+            }\n+        }\n+\n+        public static XLanguageTag fromTag(LstrType lstrType, String tag) {\n+            Multimap<LstrType,String> result = TreeMultimap.create();\n+            LanguageTagParser source = new LanguageTagParser();\n+            final boolean isLanguage = lstrType == LstrType.language;\n+            String prefix = isLanguage ? \"\" : \"und_\";\n+            try {\n+                source.set(prefix + tag);\n+            } catch (Exception e) {\n+                return null;  // skip ill-formed for now\n+//                if (lstrType == LstrType.region && tag.length() == 3) {\n+//                    //result.put(LstrType.language, \"und\");\n+//                    result.put(LstrType.region, tag);\n+//                } else {\n+//                    result.put(LstrType.language, tag);\n+//                }\n+//                //System.out.println(\"ILLEGAL SOURCE\\t\" + lstrType + \":\\t\" + tag + \" \u21d2 \" + result); // for debugging\n+//                return new XLanguageTag(result);\n+            }\n+            if (!source.getLanguage().isEmpty()\n+                && !source.getLanguage().contains(\"und\")) {\n+                result.put(LstrType.language, source.getLanguage());\n+            }\n+            if (!source.getScript().isEmpty()) {\n+                result.put(LstrType.script, source.getScript());\n+            }\n+            if (!source.getRegion().isEmpty()) {\n+                result.put(LstrType.region, source.getRegion());\n+            }\n+            if (!source.getVariants().isEmpty()) {\n+                result.putAll(LstrType.variant, source.getVariants());\n+            }\n+            return new XLanguageTag(result);\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            return data.equals(((XLanguageTag)obj).data);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return data.hashCode();\n+        }\n+        public XLanguageTag set(LstrType lstrType, String string) {\n+            Multimap<LstrType,String> result = TreeMultimap.create(data);\n+            if (lstrType != LstrType.variant) {\n+                result.removeAll(lstrType);\n+            }\n+            result.put(lstrType, string);\n+            return new XLanguageTag(result);\n+        }\n+\n+        public boolean containsAll(XLanguageTag type) {\n+            for (LstrType lstrType : LSRV) {\n+                final Collection<String> sources = get(lstrType);\n+                final Collection<String> types = type.get(lstrType);\n+                if (!sources.containsAll(types)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        public XLanguageTag replacePartsFrom(XLanguageTag typeParts, XLanguageTag replacementParts) {", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "chunk": "diff --git a/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java b/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\nindex d75727ea55..aa97c15f85 100644\n--- a/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\n+++ b/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\n\n@@ -27,6 +27,9 @@ import com.ibm.icu.impl.Row.R2;\n /**\n  * Provides Unicode Language Identifier canonicalization for use in testing.\n  * The implementation is designed to be simple, and is not at all optimized for production use.\n+ * It is used to verify the correctness of the specification algorithm,\n+ * sanity-check the supplementalMetadata.xml alias data,\n+ * and generate test files for use by implementations.\n  */\n public class LsrvCanonicalizer {\n \n"}}, {"oid": "b73c6b164b9e8c2c73a377c4bdc4eff7be9c238d", "url": "https://github.com/unicode-org/cldr/commit/b73c6b164b9e8c2c73a377c4bdc4eff7be9c238d", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-25T00:44:04Z", "type": "forcePushed"}, {"oid": "414fff6e0ec586b0e09e08d394e6daa578f4476b", "url": "https://github.com/unicode-org/cldr/commit/414fff6e0ec586b0e09e08d394e6daa578f4476b", "message": "CLDR-14016 fix attribute test", "committedDate": "2020-08-25T01:08:59Z", "type": "forcePushed"}, {"oid": "60b3b0972d4b939cc8501d0fab44059b4b76af7e", "url": "https://github.com/unicode-org/cldr/commit/60b3b0972d4b939cc8501d0fab44059b4b76af7e", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-25T01:11:32Z", "type": "forcePushed"}, {"oid": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "url": "https://github.com/unicode-org/cldr/commit/d3c89c38d85fea2f76b4685371dba74230a9c0f1", "message": "CLDR-14016 fix cel_gaulish", "committedDate": "2020-08-25T01:37:02Z", "type": "forcePushed"}, {"oid": "b4c35c12e85464a5024e08cc6a280504a521e3d1", "url": "https://github.com/unicode-org/cldr/commit/b4c35c12e85464a5024e08cc6a280504a521e3d1", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-25T03:39:46Z", "type": "forcePushed"}, {"oid": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "url": "https://github.com/unicode-org/cldr/commit/d3c89c38d85fea2f76b4685371dba74230a9c0f1", "message": "CLDR-14016 fix cel_gaulish", "committedDate": "2020-08-25T01:37:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwODQ5MA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476408490", "bodyText": "Adding immediately commented out code without any comments declaring its intent is weird.\nI mean yes it's sort of clear it's a debug thing, but there's a DEBUG flag above and this is test code anyway, so why not leave it in guarded by the debug flag? At least that way it won't rot over time with successive refactorings of the code around it.", "author": "hagbard", "createdAt": "2020-08-25T12:27:07Z", "path": "tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.unicode.cldr.unittest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.unicode.cldr.util.LsrvCanonicalizer;\n+import org.unicode.cldr.util.LsrvCanonicalizer.ReplacementRule;\n+import org.unicode.cldr.util.LsrvCanonicalizer.TestDataTypes;\n+import org.unicode.cldr.util.LsrvCanonicalizer.XLanguageTag;\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Objects;\n+import com.ibm.icu.dev.test.TestFmwk;\n+\n+public class TestLsrvCanonicalizer extends TestFmwk {\n+\n+    static final LsrvCanonicalizer rrs = LsrvCanonicalizer.getInstance();\n+    private static final boolean DEBUG = false;\n+\n+    public static void main(String[] args) {\n+        final TestLsrvCanonicalizer testLocaleCanonicalizer = new TestLsrvCanonicalizer();\n+        testLocaleCanonicalizer.run(args);\n+    }\n+\n+    public void TestCases() {\n+        if (DEBUG) {\n+//          System.out.println(Joiner.on('\\n').join(rrs.filter(LstrType.variant, null)));\n+            System.out.println(Joiner.on('\\n').join(rrs.filter(LstrType.language, \"no\")));\n+        }\n+\n+        List<ReplacementRule> rules = new ArrayList<>();\n+        for (Entry<TestDataTypes, Map<String, String>> mainEntry : rrs.getTestData(null).entrySet()) {\n+            TestDataTypes type = mainEntry.getKey();\n+            for (Entry<String, String> entry : mainEntry.getValue().entrySet()) {\n+                String toTest = entry.getKey();\n+                String expected = entry.getValue();\n+                final XLanguageTag source2 = XLanguageTag.fromTag(LstrType.language, toTest);\n+                XLanguageTag newTag = rrs.canonicalizeToX(source2, rules);\n+                String actual = newTag.toLocaleString();\n+                if (DEBUG && rules.size() > 1) {\n+                    System.out.println(\n+                        \"source: \" + toTest\n+                        + \", expected: \" + expected\n+                        + \", actual: \" + actual\n+                        + \", rules: \" + rules\n+                        );\n+                }\n+                if (!Objects.equal(expected, actual)) {\n+                    errln(\"Error: \"\n+                        + \"source: \" + toTest\n+                        + \", expected: \" + expected\n+                        + \", actual: \" + actual\n+                        + \", rules: \" + rules\n+                        );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+//            if (!rule.regular) {\n+//                System.out.println(\n+//                    rule.lstrType + \"\\t\u2795\\t\" + rule.typeParts + \"\\t\u21d2\\t\"+rule.replacementParts + \"\\t\u2795\\t\" + rule.reason + \"\\t\" + diff(rule.typeParts, rule.replacementParts));\n+//            }\n+//        }\n+//    }\n+\n+\n+\n+//    private static String diff(XLanguageTag tagParts, XLanguageTag replacementParts) {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MDc3MA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476850770", "bodyText": "It's gone.", "author": "macchiati", "createdAt": "2020-08-25T23:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwODQ5MA=="}], "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "chunk": "diff --git a/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java b/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\nindex 9fdf6e79d2..8bd48dbb39 100644\n--- a/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\n+++ b/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\n\n@@ -1,20 +1,35 @@\n package org.unicode.cldr.unittest;\n \n import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Set;\n \n+import org.unicode.cldr.util.CLDRConfig;\n+import org.unicode.cldr.util.CLDRFile;\n import org.unicode.cldr.util.LsrvCanonicalizer;\n import org.unicode.cldr.util.LsrvCanonicalizer.ReplacementRule;\n import org.unicode.cldr.util.LsrvCanonicalizer.TestDataTypes;\n import org.unicode.cldr.util.LsrvCanonicalizer.XLanguageTag;\n+import org.unicode.cldr.util.StandardCodes;\n+import org.unicode.cldr.util.StandardCodes.LstrField;\n import org.unicode.cldr.util.StandardCodes.LstrType;\n+import org.unicode.cldr.util.SupplementalDataInfo;\n \n import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n import com.ibm.icu.dev.test.TestFmwk;\n+import com.ibm.icu.impl.Row.R2;\n \n+/**\n+ * TestLsrvCanonicalizer is used to verify the correctness of the specification algorithm,\n+ * sanity-check the supplementalMetadata.xml alias data,\n+ * and generate test files for use by implementations.\n+ */\n public class TestLsrvCanonicalizer extends TestFmwk {\n \n     static final LsrvCanonicalizer rrs = LsrvCanonicalizer.getInstance();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwOTMyMw==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476409323", "bodyText": "\"oo\" doesn't seem like a particularly clear variable name to me. Maybe \"outputOpts\" ?", "author": "hagbard", "createdAt": "2020-08-25T12:28:37Z", "path": "tools/java/org/unicode/cldr/util/LanguageTagCanonicalizer.java", "diffHunk": "@@ -52,6 +52,9 @@ public LanguageTagCanonicalizer(LstrType lstrType) {\n     // TODO, handle variants\n     @Override\n     public synchronized String transform(String locale) {\n+        return transform (locale, OutputOption.ICU_LCVARIANT);\n+    }\n+    public synchronized String transform(String locale, OutputOption oo) {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MTk3MQ==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476851971", "bodyText": "I'd like to clean this up later. To much to do right now, and I don't want another cycle.", "author": "macchiati", "createdAt": "2020-08-25T23:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwOTMyMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMTY1Mg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476411652", "bodyText": "Do the if check first and just don't have a try-catch block.\nvalueOf() is defined to only throw IllegalArgumentException or NullPointerException and I think you want to complain if you're given null anyway (it's a very different type of failure mode).", "author": "hagbard", "createdAt": "2020-08-25T12:32:39Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1073,6 +1075,17 @@ boolean isWellFormed(String candidate) {\n         public String toCompatString() {\n             return this == region ? \"territory\" : toString();\n         }\n+\n+        public static LstrType fromString(String rawType) {\n+            try {\n+                return valueOf(rawType);\n+            } catch (Exception e) {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "chunk": "diff --git a/tools/java/org/unicode/cldr/util/StandardCodes.java b/tools/java/org/unicode/cldr/util/StandardCodes.java\nindex 9726b5691c..b8245c82fc 100644\n--- a/tools/java/org/unicode/cldr/util/StandardCodes.java\n+++ b/tools/java/org/unicode/cldr/util/StandardCodes.java\n\n@@ -1072,14 +1072,25 @@ public class StandardCodes {\n             }\n         }\n \n+        /**\n+         * Generate compatibility string, returning 'territory' instead of 'region', etc.\n+         */\n         public String toCompatString() {\n-            return this == region ? \"territory\" : toString();\n+            switch (this) {\n+            case region: return \"territory\";\n+            case grandfathered: return \"language\";\n+            case redundant: return \"language\";\n+            default: return toString();\n+            }\n         }\n \n+        /**\n+         * Create LstrType from string, allowing the compat string 'territory'.\n+         */\n         public static LstrType fromString(String rawType) {\n             try {\n                 return valueOf(rawType);\n-            } catch (Exception e) {\n+            } catch (IllegalArgumentException e) {\n                 if (\"territory\".equals(rawType)) {\n                     return region;\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMjc1Nw==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476412757", "bodyText": "Another way to do this is to store the compat string as a field, but either way it would be nice to see a comment on this public method explaining its not the enum name.", "author": "hagbard", "createdAt": "2020-08-25T12:34:36Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1073,6 +1075,17 @@ boolean isWellFormed(String candidate) {\n         public String toCompatString() {\n             return this == region ? \"territory\" : toString();", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MjU1OA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476852558", "bodyText": "done (the doc, and some other changes)", "author": "macchiati", "createdAt": "2020-08-25T23:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMjc1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "chunk": "diff --git a/tools/java/org/unicode/cldr/util/StandardCodes.java b/tools/java/org/unicode/cldr/util/StandardCodes.java\nindex 9726b5691c..b8245c82fc 100644\n--- a/tools/java/org/unicode/cldr/util/StandardCodes.java\n+++ b/tools/java/org/unicode/cldr/util/StandardCodes.java\n\n@@ -1072,14 +1072,25 @@ public class StandardCodes {\n             }\n         }\n \n+        /**\n+         * Generate compatibility string, returning 'territory' instead of 'region', etc.\n+         */\n         public String toCompatString() {\n-            return this == region ? \"territory\" : toString();\n+            switch (this) {\n+            case region: return \"territory\";\n+            case grandfathered: return \"language\";\n+            case redundant: return \"language\";\n+            default: return toString();\n+            }\n         }\n \n+        /**\n+         * Create LstrType from string, allowing the compat string 'territory'.\n+         */\n         public static LstrType fromString(String rawType) {\n             try {\n                 return valueOf(rawType);\n-            } catch (Exception e) {\n+            } catch (IllegalArgumentException e) {\n                 if (\"territory\".equals(rawType)) {\n                     return region;\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNDI5NA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476414294", "bodyText": "JavaDoc?", "author": "hagbard", "createdAt": "2020-08-25T12:37:10Z", "path": "tools/java/org/unicode/cldr/tool/GenerateLocaleIDTestData.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.unicode.cldr.tool;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.unicode.cldr.util.CLDRPaths;\n+import org.unicode.cldr.util.CldrUtility;\n+import org.unicode.cldr.util.LsrvCanonicalizer;\n+import org.unicode.cldr.util.LsrvCanonicalizer.TestDataTypes;\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+import org.unicode.cldr.util.TempPrintWriter;\n+\n+public class GenerateLocaleIDTestData {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MTI5MQ==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476851291", "bodyText": "done", "author": "macchiati", "createdAt": "2020-08-25T23:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNDI5NA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "9191edd4650528b9c03f63719ae27a61326046a2", "url": "https://github.com/unicode-org/cldr/commit/9191edd4650528b9c03f63719ae27a61326046a2", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-26T00:14:20Z", "type": "commit"}, {"oid": "9191edd4650528b9c03f63719ae27a61326046a2", "url": "https://github.com/unicode-org/cldr/commit/9191edd4650528b9c03f63719ae27a61326046a2", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-26T00:14:20Z", "type": "forcePushed"}]}