{"pr_number": 354, "pr_title": "CLDR-13331 Make ExampleGenerator faster, clear cache less", "pr_createdAt": "2020-02-25T20:28:36Z", "pr_url": "https://github.com/unicode-org/cldr/pull/354", "timeline": [{"oid": "dd7f611f256231ab661a25993cf00e4c3b5938f9", "url": "https://github.com/unicode-org/cldr/commit/dd7f611f256231ab661a25993cf00e4c3b5938f9", "message": "CLDR-13331 Make ExampleGenerator faster, clear cache less\n\n-New file TestExampleDependencies.json\n\n-Revise TestExampleGeneratorDependencies and related code\n\n-Skip non-type-A paths in updateCache, new function pathMightBeTypeA\n\n-Enable Transliterator cache for loadTransliterator even if not xml, for speed\n\n-New option USE_STARRED_PATHS\n\n-For valueB, use originalValues.get(pathB), not cldrFile.getStringValue(pathB)\n\n-Fix deprecation warning in ExampleGenerator.formatCountValue, explicit PluralType.cardinal", "committedDate": "2020-02-25T20:26:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyMDcxMw==", "url": "https://github.com/unicode-org/cldr/pull/354#discussion_r384220713", "bodyText": "should it be an env var?", "author": "srl295", "createdAt": "2020-02-26T01:03:41Z", "path": "tools/java/org/unicode/cldr/test/ExampleGenerator.java", "diffHunk": "@@ -167,44 +178,157 @@ public CLDRFile getCldrFile() {\n     private CLDRFile englishFile;\n     Matcher URLMatcher = URL_PATTERN.matcher(\"\");\n \n-    /*\n+    /**\n      * The cache is accessed only by getExampleHtml and updateCache.\n-     * Its key is built from an xpath, a value for that xpath, and a letter to indicate the ExampleType (ENGLISH or NATIVE).\n+     * Its key is built from an xpath, and a value for that xpath.\n      * Its value is an HTML string showing example(s) using that value for that path, for the locale of this ExampleGenerator.\n      *\n      * Note that this cache is internal to each ExampleGenerator. Compare TestCache.exampleGeneratorCache,\n      * which is at a higher level, caching entire ExampleGenerator objects, one for each locale.\n-     *\n-     * TODO: simplify/clarify the ENGLISH/NATIVE distinction, to facilitate performance improvements.\n-     * The general-purpose mechanism that currently appears to support both ENGLISH and NATIVE for each\n-     * ExampleGenerator doesn't currently appear to be used or needed. If the two types are not really mixed\n-     * in the same cache (or even in same ExampleGenerator), then E/N needn't be part of cache key (or\n-     * require separate caches). Also, at least within Survey Tool, englishFile == cldrFile if (and only\n-     * if) the ExampleGenerator is used for ExampleType.ENGLISH. In Survey Tool, ExampleType.ENGLISH is\n-     * only actually used for a single ExampleGenerator, namely sm.getTranslationHintsExample().\n-     *\n-     * Reference: https://unicode-org.atlassian.net/browse/CLDR-12020\n      */\n     private Map<String, String> cache = new ConcurrentHashMap<String, String>();\n \n     /**\n-     * For this (locale-specific) ExampleGenerator, clear the cached value for the given xpath,\n-     * and for any xpaths whose examples might also depend on this xpath.\n+     * AVOID_CLEARING_CACHE: work in progress, keep false until it becomes beneficial and reliable.\n+     * Reference: https://unicode-org.atlassian.net/browse/CLDR-13331\n+     */\n+    private static final boolean AVOID_CLEARING_CACHE = false;", "originalCommit": "dd7f611f256231ab661a25993cf00e4c3b5938f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzNDEyMA==", "url": "https://github.com/unicode-org/cldr/pull/354#discussion_r384534120", "bodyText": "Once it's working reliably and demonstrated to improve performance, we might not need the boolean anymore, we might just make it effectively true permanently. Though, I suppose we could keep it in case later on we want to double-check whether it's still improving performance, and/or still working correctly by producing the same examples as it would if false. I don't really see a use case for making it an environment variable.", "author": "btangmu", "createdAt": "2020-02-26T14:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyMDcxMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyMTA3Mg==", "url": "https://github.com/unicode-org/cldr/pull/354#discussion_r384221072", "bodyText": "should use a hash", "author": "srl295", "createdAt": "2020-02-26T01:05:00Z", "path": "tools/java/org/unicode/cldr/test/ExampleGenerator.java", "diffHunk": "@@ -167,44 +178,157 @@ public CLDRFile getCldrFile() {\n     private CLDRFile englishFile;\n     Matcher URLMatcher = URL_PATTERN.matcher(\"\");\n \n-    /*\n+    /**\n      * The cache is accessed only by getExampleHtml and updateCache.\n-     * Its key is built from an xpath, a value for that xpath, and a letter to indicate the ExampleType (ENGLISH or NATIVE).\n+     * Its key is built from an xpath, and a value for that xpath.\n      * Its value is an HTML string showing example(s) using that value for that path, for the locale of this ExampleGenerator.\n      *\n      * Note that this cache is internal to each ExampleGenerator. Compare TestCache.exampleGeneratorCache,\n      * which is at a higher level, caching entire ExampleGenerator objects, one for each locale.\n-     *\n-     * TODO: simplify/clarify the ENGLISH/NATIVE distinction, to facilitate performance improvements.\n-     * The general-purpose mechanism that currently appears to support both ENGLISH and NATIVE for each\n-     * ExampleGenerator doesn't currently appear to be used or needed. If the two types are not really mixed\n-     * in the same cache (or even in same ExampleGenerator), then E/N needn't be part of cache key (or\n-     * require separate caches). Also, at least within Survey Tool, englishFile == cldrFile if (and only\n-     * if) the ExampleGenerator is used for ExampleType.ENGLISH. In Survey Tool, ExampleType.ENGLISH is\n-     * only actually used for a single ExampleGenerator, namely sm.getTranslationHintsExample().\n-     *\n-     * Reference: https://unicode-org.atlassian.net/browse/CLDR-12020\n      */\n     private Map<String, String> cache = new ConcurrentHashMap<String, String>();\n \n     /**\n-     * For this (locale-specific) ExampleGenerator, clear the cached value for the given xpath,\n-     * and for any xpaths whose examples might also depend on this xpath.\n+     * AVOID_CLEARING_CACHE: work in progress, keep false until it becomes beneficial and reliable.\n+     * Reference: https://unicode-org.atlassian.net/browse/CLDR-13331\n+     */\n+    private static final boolean AVOID_CLEARING_CACHE = false;\n+\n+    /**\n+     * For this (locale-specific) ExampleGenerator, clear the cached examples for\n+     * any paths whose examples might depend on the winning value of the given path,\n+     * since the winning value of the given path has (or may have?) changed.\n      *\n-     * Is cache-clearing ever needed for ExampleType.ENGLISH?\n+     * There is no need to update the example(s) for the given path itself, since\n+     * the cache key includes path+value and therefore each path+value has its own\n+     * example, regardless of which value is winning. There is a need to update\n+     * the examples for OTHER paths whose examples depend on the winning value\n+     * of the given path.\n      *\n-     * @param xpath the path\n+     * For example, let pathA = \"//ldml/localeDisplayNames/languages/language[@type=\\\"aa\\\"]\"\n+     * and pathB = \"//ldml/localeDisplayNames/territories/territory[@type=\\\"DJ\\\"]\". The values,\n+     * in locale fr, might be \"afar\" for pathA and \"Djibouti\" for pathB. The example for pathB\n+     * might include \"afar (Djibouti)\", which depends on the values of both pathA and pathB.\n+     *\n+     * @param xpath the path whose winning value has (may have?) changed\n+     *\n+     * TODO: make sure we're only called if the winning value really HAS changed.\n+     * Looking at the callers, it's not obvious if that's the case, or if this\n+     * function may sometimes be called when a vote has been made without actually\n+     * changing the winning value.\n+     *\n+     * Called by TestCache.updateExampleGeneratorCache\n      */\n     public void updateCache(@SuppressWarnings(\"unused\") String xpath) {\n         /*\n-         * TODO: instead of removing ALL keys, only remove the paths that may be affected\n-         * by this change.\n+         * TODO: instead of removing ALL keys, only remove keys for which the examples\n+         * may be affected by this change.\n+         *\n+         * It appears (based on incomplete evidence), that all paths of type \u201cA\u201d\n+         * (i.e., all that have dependencies) start with one of these seven strings:\n+         * //ldml/characterLabels\n+         * //ldml/dates\n+         * //ldml/delimiters\n+         * //ldml/listPatterns\n+         * //ldml/localeDisplayNames\n+         * //ldml/numbers\n+         * //ldml/units\n          *\n-         * Reference: https://unicode-org.atlassian.net/browse/CLDR-12020\n+         * Problem: that's something like 98% of all paths! Need to narrow it down much further.\n+         *\n+         * For any other path given as the argument to this function, there should be no need to clear the cache.\n+         * Also, when there are dependencies, ideally only the keys for paths that are dependent on this path\n+         * should be removed. It might be slow to loop through the cache testing each path to see if it's affected.\n+         * Ideally we might maintain a complete mapping of dependencies, so given pathA we could quickly loop\n+         * through the pre-existing set of paths B that depend on pathA.\n+         *\n+         * Reference: https://unicode-org.atlassian.net/browse/CLDR-13331\n          */\n+        if (AVOID_CLEARING_CACHE) {\n+            if (!pathMightBeTypeA(xpath)) {\n+                return;\n+            }\n+        }\n         cache.clear();\n     }\n \n+    static long typeACount = 0, notTypeACount = 0;\n+\n+    /**\n+     * Does changing the winning value for the given path potentially have side-effect of changing the example\n+     * html for other paths? In other words, might this be a path of type \"A\"?\n+     *\n+     * We say \"might be\", since this function is meant to be fast rather than exact. It should never return\n+     * false for a path that really is type \"A\", but it may return true for some paths that aren't really type \"A\".\n+     *\n+     * @param xpath\n+     * @return true or false\n+     *\n+     * Called locally (only if AVOID_CLEARING_CACHE is true), and also by TestExampleGeneratorDependencies.\n+     */\n+    static public boolean pathMightBeTypeA(String xpath) {\n+        final String pathAStarts[] = {\n+            \"//ldml/characterLabels/characterLabelPattern\",\n+            \"//ldml/characterLabels/characterLabel\",\n+            \"//ldml/dates/calendars\",\n+            \"//ldml/dates/fields\",\n+            \"//ldml/dates/timeZoneNames\",\n+            \"//ldml/delimiters/alternateQuotationEnd\",\n+            \"//ldml/delimiters/alternateQuotationStart\",\n+            \"//ldml/delimiters/quotationEnd\",\n+            \"//ldml/delimiters/quotationStart\",\n+            \"//ldml/listPatterns/listPattern\",\n+            \"//ldml/localeDisplayNames/codePatterns\",\n+            \"//ldml/localeDisplayNames/keys\",\n+            \"//ldml/localeDisplayNames/languages\",\n+            \"//ldml/localeDisplayNames/localeDisplayPattern\",\n+            \"//ldml/localeDisplayNames/scripts\",\n+            \"//ldml/localeDisplayNames/territories\",\n+            \"//ldml/localeDisplayNames/types\",\n+            \"//ldml/numbers/currencies\",\n+            \"//ldml/numbers/currencyFormats\",\n+            \"//ldml/numbers/decimalFormats\",\n+            \"//ldml/numbers/defaultNumberingSystem\",\n+            \"//ldml/numbers/minimalPairs\",\n+            \"//ldml/numbers/minimumGroupingDigits\",\n+            \"//ldml/numbers/miscPatterns\",\n+            \"//ldml/numbers/otherNumberingSystems\",\n+            \"//ldml/numbers/percentFormats\",\n+            \"//ldml/numbers/scientificFormats\",\n+            \"//ldml/numbers/symbols\",\n+            \"//ldml/posix/messages\",\n+            \"//ldml/typographicNames\",\n+            \"//ldml/units/durationUnit\",\n+            \"//ldml/units/unitLength\",\n+        };\n+        /***\n+        final String pathAStartsShorter[] = {\n+            \"//ldml/characterLabels\",\n+            \"//ldml/dates\",\n+            \"//ldml/delimiters\",\n+            \"//ldml/listPatterns\",\n+            \"//ldml/localeDisplayNames\",\n+            \"//ldml/numbers\",\n+            \"//ldml/units\"\n+        };\n+        ***/\n+        boolean maybeTypeA = false;\n+        for (String s : pathAStarts) {\n+            if (xpath.startsWith(s)) {", "originalCommit": "dd7f611f256231ab661a25993cf00e4c3b5938f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzOTgzMw==", "url": "https://github.com/unicode-org/cldr/pull/354#discussion_r384539833", "bodyText": "Good idea, if the function continues to exist. I was hoping to find simple patterns for quick separation between most paths that have dependencies and most paths that don't. Disappointingly, there don't seem to be any such patterns. Instead, Mark and I are planning to build the complete mappings based on starred paths, definitely using a fast lookup (e.g., a hash or multimap), not looping through an array.", "author": "btangmu", "createdAt": "2020-02-26T14:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyMTA3Mg=="}], "type": "inlineReview", "revised_code": null}]}