{"pr_number": 825, "pr_title": "KOGITO-3073 Kafka persistence addon", "pr_createdAt": "2020-10-14T06:32:00Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/825", "timeline": [{"oid": "9a2fc4aedbe8ca5a65d1c1f76e10c675ac9aa167", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9a2fc4aedbe8ca5a65d1c1f76e10c675ac9aa167", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2020-10-14T06:42:31Z", "type": "forcePushed"}, {"oid": "6d9939fc38d86843a5f4b78d3ad3926766b36c99", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6d9939fc38d86843a5f4b78d3ad3926766b36c99", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2020-11-26T14:43:39Z", "type": "forcePushed"}, {"oid": "8affe25c07610759435303d251cfb993f73c0483", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8affe25c07610759435303d251cfb993f73c0483", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-21T02:48:25Z", "type": "forcePushed"}, {"oid": "9e90fbc5bac886986406040e8b072a83c808e486", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9e90fbc5bac886986406040e8b072a83c808e486", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-21T05:33:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE3MzY3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562173672", "bodyText": "This method returns all the protos (+ list JSON) used by the operator to export them to data index so I think we should move this code outside single persistence types and bind it to the add-on that produce data index events.\nWdyt?\nSide note this change is in conflict with #967\n/cc @r00ta", "author": "danielezonca", "createdAt": "2021-01-21T20:23:51Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -147,6 +144,46 @@ public String persistenceType() {\n             persistenceProviderClazz.addMember(templateNameField);\n             persistenceProviderClazz.addMember(templateNameMethod);\n         }\n+        \n+        return protobufBasedPersistence(persistenceProviderClazz);\n+    }\n+\n+    protected Collection<GeneratedFile> kafkaBasedPersistence() {\n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(KOGITO_PROCESS_INSTANCE_FACTORY_IMPL)\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(KOGITO_PROCESS_INSTANCE_FACTORY_PACKAGE);\n+\n+        if (context().hasDI()) {\n+            context().getDependencyInjectionAnnotator().withApplicationComponent(persistenceProviderClazz);\n+        }\n+\n+        Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n+\n+        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerTemplate.java\"));\n+\n+        ClassOrInterfaceDeclaration producer = parsedClazzFile.getClassByName(\"KafkaStreamsTopologyProducer\").get();\n+        \n+        MethodCallExpr asListOfProcesses = new MethodCallExpr(new NameExpr(\"java.util.Arrays\"), \"asList\");\n+\n+        protoGenerator.getProcessIds().forEach(p -> asListOfProcesses.addArgument(new StringLiteralExpr(p)));\n+        producer.getFieldByName(\"processes\").get().getVariable(0).setInitializer(asListOfProcesses);\n+\n+        String clazzName = KOGITO_PROCESS_INSTANCE_PACKAGE + \".\" + producer.getName().asString();\n+        generatedFiles.add(new GeneratedFile(GeneratedFileType.SOURCE,\n+                                             clazzName.replace('.', '/') + \".java\",\n+                                             parsedClazzFile.toString()));\n+        return generatedFiles;\n+    }\n+    \n+    private Collection<GeneratedFile> protobufBasedPersistence(ClassOrInterfaceDeclaration persistenceProviderClazz){\n+        CompilationUnit compilationUnit = new CompilationUnit(KOGITO_PROCESS_INSTANCE_PACKAGE);\n+        compilationUnit.getTypes().add(persistenceProviderClazz);\n+\n+        Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());", "originalCommit": "9e90fbc5bac886986406040e8b072a83c808e486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzNjU2MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562436560", "bodyText": "@danielezonca agree I did a minor tweak now to have the proto always generated, and we review and further enhance later.", "author": "cristianonicolai", "createdAt": "2021-01-22T07:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE3MzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDQxNDAwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r564414004", "bodyText": "Hi, I was about to start working on #967 for the proto files. But since the changes are already in this PR I'll close it fyi", "author": "r00ta", "createdAt": "2021-01-26T10:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE3MzY3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "970d8591278df327a508211eea0fcdd42b826144", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 4d4d46b982..b951d9813d 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n\n@@ -160,7 +162,7 @@ public class PersistenceGenerator extends AbstractGenerator {\n \n         Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n \n-        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerTemplate.java\"));\n+        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));\n \n         ClassOrInterfaceDeclaration producer = parsedClazzFile.getClassByName(\"KafkaStreamsTopologyProducer\").get();\n         \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4MzMzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562183336", "bodyText": "I think you can use existing generatedAnnotation field", "author": "danielezonca", "createdAt": "2021-01-21T20:41:10Z", "path": "kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java", "diffHunk": "@@ -102,6 +106,18 @@ public Proto generate(String messageComment, String fieldComment, String package\n         return parameters;\n     }\n \n+    @Override\n+    public Set<String> getProcessIds() {\n+        return modelClasses.stream().map(c -> {\n+            AnnotationInstance instance = c.classAnnotation(DotName.createSimple(Generated.class.getCanonicalName()));", "originalCommit": "9e90fbc5bac886986406040e8b072a83c808e486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzNjEwNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562436105", "bodyText": "+1", "author": "cristianonicolai", "createdAt": "2021-01-22T07:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4MzMzNg=="}], "type": "inlineReview", "revised_code": {"commit": "c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "chunk": "diff --git a/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java b/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java\nindex 0c0d0d257c..4530a2f9ec 100644\n--- a/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java\n+++ b/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java\n\n@@ -109,7 +109,7 @@ public class JandexProtoGenerator extends AbstractProtoGenerator<ClassInfo> {\n     @Override\n     public Set<String> getProcessIds() {\n         return modelClasses.stream().map(c -> {\n-            AnnotationInstance instance = c.classAnnotation(DotName.createSimple(Generated.class.getCanonicalName()));\n+            AnnotationInstance instance = c.classAnnotation(generatedAnnotation);\n             if(instance == null){\n                 return null;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4NDIzNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562184235", "bodyText": "Can you please describe in the ticket what a kafka topology is and the relation with ktable?", "author": "danielezonca", "createdAt": "2021-01-21T20:42:56Z", "path": "kogito-codegen/src/main/resources/class-templates/persistence/KafkaStreamsTopologyProducerTemplate.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import org.apache.kafka.streams.Topology;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+\n+@ApplicationScoped\n+public class KafkaStreamsTopologyProducer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsTopologyProducer.class);\n+\n+    private List<String> processes = Arrays.asList();\n+\n+    @Produces\n+    public Topology buildTopology() {", "originalCommit": "9e90fbc5bac886986406040e8b072a83c808e486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzNjA5NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562436094", "bodyText": "working on a doc for that", "author": "cristianonicolai", "createdAt": "2021-01-22T07:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4NDIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYwODQ4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562608483", "bodyText": "Great thanks \ud83d\udc4d", "author": "danielezonca", "createdAt": "2021-01-22T12:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4NDIzNQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "970d8591278df327a508211eea0fcdd42b826144", "url": "https://github.com/kiegroup/kogito-runtimes/commit/970d8591278df327a508211eea0fcdd42b826144", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T02:16:12Z", "type": "forcePushed"}, {"oid": "c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T08:40:27Z", "type": "forcePushed"}, {"oid": "cfa5bdc0f3e20e0ce2334b5a9100652ffabda740", "url": "https://github.com/kiegroup/kogito-runtimes/commit/cfa5bdc0f3e20e0ce2334b5a9100652ffabda740", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T10:47:49Z", "type": "forcePushed"}, {"oid": "68c1854e5ed94fa96ad8296153f08f8f08da011e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/68c1854e5ed94fa96ad8296153f08f8f08da011e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T11:58:59Z", "type": "forcePushed"}, {"oid": "7cb3890af384c1abbb28fafa5622c7c794af5765", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7cb3890af384c1abbb28fafa5622c7c794af5765", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-01T06:07:44Z", "type": "forcePushed"}, {"oid": "1f3cb4a037745998c7d3e05c24500971e812526a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1f3cb4a037745998c7d3e05c24500971e812526a", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T02:05:02Z", "type": "forcePushed"}, {"oid": "0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T04:30:44Z", "type": "forcePushed"}, {"oid": "72c4b39fec40aa5d1882ee3c89c59a613e434474", "url": "https://github.com/kiegroup/kogito-runtimes/commit/72c4b39fec40aa5d1882ee3c89c59a613e434474", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T11:34:12Z", "type": "forcePushed"}, {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T11:39:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDAzMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r566844033", "bodyText": "If new KafkaProcessInstancesFactory() fails this could be null", "author": "danielezonca", "createdAt": "2021-01-29T14:05:59Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.jbpm.process.instance.impl.Action;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Node;\n+import org.kie.api.definition.process.WorkflowProcess;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        factory.stop();", "originalCommit": "68c1854e5ed94fa96ad8296153f08f8f08da011e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjc0OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816748", "bodyText": "fixed", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 0a8051e6dc..2193ec1f2b 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n\n@@ -159,6 +159,8 @@ public class KafkaProcessInstancesIT {\n         processInstance.start();\n         assertEquals(STATE_ACTIVE, processInstance.status());\n \n+        System.out.println(\"values().size() = \" + processInstance.process().instances().values().size());\n+        System.out.println(\"instances().size() = \" + processInstance.process().instances().size());\n         assertThat(process.instances().size()).isOne();\n \n         SecurityPolicy asJohn = SecurityPolicy.of(IdentityProviders.of(\"john\"));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDg2MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r566844861", "bodyText": "Can you please clarify why this workaround? What about (in another PR of course) convert scripts to lambdas?", "author": "danielezonca", "createdAt": "2021-01-29T14:07:18Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.jbpm.process.instance.impl.Action;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Node;\n+import org.kie.api.definition.process.WorkflowProcess;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        factory.stop();\n+        if (factory.getKafkaStreams() != null) {\n+            factory.getKafkaStreams().close();\n+        }\n+    }\n+\n+    @Test\n+    void testFindByIdReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n+        // workaround as BpmnProcess does not compile the scripts but just reads the xml\n+        for (Node node : ((WorkflowProcess) process.process()).getNodes()) {\n+            if (node instanceof ActionNode) {\n+                DroolsAction a = ((ActionNode) node).getAction();\n+                a.setMetaData(\"Action\", (Action) kcontext -> {\n+                    System.out.println(\"The variable value is \" + kcontext.getVariable(\"s\") + \" about to call toString on it\");\n+                    kcontext.getVariable(\"s\").toString();\n+                });\n+            }\n+        }", "originalCommit": "68c1854e5ed94fa96ad8296153f08f8f08da011e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjc2OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816768", "bodyText": "its not needed anymore", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDg2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 0a8051e6dc..2193ec1f2b 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n\n@@ -159,6 +159,8 @@ public class KafkaProcessInstancesIT {\n         processInstance.start();\n         assertEquals(STATE_ACTIVE, processInstance.status());\n \n+        System.out.println(\"values().size() = \" + processInstance.process().instances().values().size());\n+        System.out.println(\"instances().size() = \" + processInstance.process().instances().size());\n         assertThat(process.instances().size()).isOne();\n \n         SecurityPolicy asJohn = SecurityPolicy.of(IdentityProviders.of(\"john\"));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4Njg2NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568586865", "bodyText": "Please use TemplatedGenerator\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));\n          \n          \n            \n                    TemplatedGenerator generator = TemplatedGenerator.builder()\n          \n          \n            \n                                .withTemplateBasePath(\"/class-templates/persistence/\")\n          \n          \n            \n                                .withFallbackContext(JavaKogitoBuildContext.CONTEXT_NAME)\n          \n          \n            \n                                .build(context(), \"KafkaStreamsTopologyProducer\");\n          \n          \n            \n                    CompilationUnit parsedClazzFile = generator.compilationUnitOrThrow();", "author": "danielezonca", "createdAt": "2021-02-02T13:07:44Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -147,6 +155,44 @@ public String persistenceType() {\n             persistenceProviderClazz.addMember(templateNameField);\n             persistenceProviderClazz.addMember(templateNameMethod);\n         }\n+        \n+        return protobufBasedPersistence(persistenceProviderClazz);\n+    }\n+\n+    protected Collection<GeneratedFile> kafkaBasedPersistence() {\n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(KOGITO_PROCESS_INSTANCE_FACTORY_IMPL)\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(KOGITO_PROCESS_INSTANCE_FACTORY_PACKAGE);\n+\n+        if (context().hasDI()) {\n+            context().getDependencyInjectionAnnotator().withApplicationComponent(persistenceProviderClazz);\n+        }\n+\n+        Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n+\n+        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjgwOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816809", "bodyText": "done", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4Njg2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex a501d4b9a3..7998985fbe 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n\n@@ -171,9 +172,13 @@ public class PersistenceGenerator extends AbstractGenerator {\n \n         Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n \n-        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));\n-\n-        ClassOrInterfaceDeclaration producer = parsedClazzFile.getClassByName(\"KafkaStreamsTopologyProducer\").get();\n+        TemplatedGenerator generator = TemplatedGenerator.builder().withTemplateBasePath(\"/class-templates/persistence/\")\n+                .withFallbackContext(JavaKogitoBuildContext.CONTEXT_NAME)\n+                .build(context(), \"KafkaStreamsTopologyProducer\");\n+        CompilationUnit parsedClazzFile = generator.compilationUnitOrThrow();\n+        ClassOrInterfaceDeclaration producer = parsedClazzFile.findFirst(ClassOrInterfaceDeclaration.class).orElseThrow(() -> new InvalidTemplateException(\n+                generator,\n+                \"Failed to find template for KafkaStreamsTopologyProducer\"));\n         \n         MethodCallExpr asListOfProcesses = new MethodCallExpr(new NameExpr(\"java.util.Arrays\"), \"asList\");\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4OTk2OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568589969", "bodyText": "This class is a *JavaTemplate but it seems to be a Quarkus one (it uses CDI). I think we need also a *SpringTemplate", "author": "danielezonca", "createdAt": "2021-02-02T13:12:48Z", "path": "kogito-codegen/src/main/resources/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import org.apache.kafka.streams.Topology;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+\n+@ApplicationScoped\n+public class KafkaStreamsTopologyProducer {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5NTMyMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568895320", "bodyText": "and do we really need a template? or this could be a static class? I mean what is injected during codegen?", "author": "tiagodolphine", "createdAt": "2021-02-02T20:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4OTk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjg2Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816867", "bodyText": "@danielezonca there is no support for spring at this stage, will need to be done later one if we think there is need to\n@tiagodolphine I needed to inject ( statically ) the process ids in order to create the topics needed for kafka. I cant inject @Process as it would cause a circle dependency, so decided to do a build time generation.", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4OTk2OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU5MTE5Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568591196", "bodyText": "What about add checks on proto in this test too (like this)?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(generatedFiles).hasSize(3);\n          \n          \n            \n                    assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE)).count()).isEqualTo(2);\n          \n          \n            \n                    assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE) && gf.relativePath().endsWith(\".json\")).count()).isEqualTo(1);\n          \n          \n            \n            \n          \n          \n            \n                    assertThat(generatedFiles).hasSize(3);", "author": "danielezonca", "createdAt": "2021-02-02T13:14:52Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java", "diffHunk": "@@ -57,7 +57,7 @@ void test() {\n                 protoGenerator);\n         Collection<GeneratedFile> generatedFiles = persistenceGenerator.generate();\n \n-        assertThat(generatedFiles).hasSize(1);\n+        assertThat(generatedFiles).hasSize(3);", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjkzNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816935", "bodyText": "done, thanks", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU5MTE5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "chunk": "diff --git a/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java b/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java\nindex 78cff8c227..2cd1d77102 100644\n--- a/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java\n+++ b/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java\n\n@@ -57,6 +58,8 @@ class FileSystemPersistenceGeneratorTest {\n                 protoGenerator);\n         Collection<GeneratedFile> generatedFiles = persistenceGenerator.generate();\n \n+        assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE)).count()).isEqualTo(2);\n+        assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE) && gf.relativePath().endsWith(\".json\")).count()).isEqualTo(1);\n         assertThat(generatedFiles).hasSize(3);\n \n         Optional<GeneratedFile> persistenceFactoryImpl = generatedFiles.stream()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg3ODE3Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568878173", "bodyText": "remove commented code?", "author": "tiagodolphine", "createdAt": "2021-02-02T19:38:02Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    //Store can only be accessed after the Kafka Streams has started \n+    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n+//        ReadOnlyKeyValueStore<String, byte[]> store = null;", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjk2Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816962", "bodyText": "done", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg3ODE3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "633430c163438bed2b8989df88c4fcbc93e82871", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex b399b61599..f301330981 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n\n@@ -20,7 +20,6 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import java.util.function.Supplier;\n \n import javax.annotation.PreDestroy;\n import javax.inject.Inject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDU0MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568880541", "bodyText": "what about using a listerner for the state? for example streams.setStateListener(....) in this way we can get rid of the Thread.sleep", "author": "tiagodolphine", "createdAt": "2021-02-02T19:42:00Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    //Store can only be accessed after the Kafka Streams has started \n+    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n+//        ReadOnlyKeyValueStore<String, byte[]> store = null;\n+        return () -> {\n+//            if (store != null) {\n+//                return store;\n+//            }\n+            while (streams.state() == KafkaStreams.State.CREATED || streams.state() == KafkaStreams.State.REBALANCING) {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjk5NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816994", "bodyText": "+1", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDU0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "633430c163438bed2b8989df88c4fcbc93e82871", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex b399b61599..f301330981 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n\n@@ -20,7 +20,6 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import java.util.function.Supplier;\n \n import javax.annotation.PreDestroy;\n import javax.inject.Inject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDk1NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568880955", "bodyText": "log instead of printStackTrace would be bettter", "author": "tiagodolphine", "createdAt": "2021-02-02T19:42:43Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNzAxMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571817011", "bodyText": "done", "author": "cristianonicolai", "createdAt": "2021-02-08T07:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDk1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "633430c163438bed2b8989df88c4fcbc93e82871", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex b399b61599..f301330981 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n\n@@ -20,7 +20,6 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import java.util.function.Supplier;\n \n import javax.annotation.PreDestroy;\n import javax.inject.Inject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4OTgzNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568889834", "bodyText": "maybe using store.approximateNumEntries() would be better in this way it is not necessary to fetch all entries to sum, wdyt?", "author": "tiagodolphine", "createdAt": "2021-02-02T19:57:43Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public KafkaProcessInstances(Process<?> process, String topic, Supplier<ReadOnlyKeyValueStore<String, byte[]>> storeSupplier, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topic;\n+        this.producer = producer;\n+        this.marshaller = new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers));\n+        this.store = storeSupplier.get();\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return store.get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (store.get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = store.get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {\n+            while (iterator.hasNext()) {\n+                instances.add(mode == MUTABLE ?\n+                                      marshaller.unmarshallProcessInstance(iterator.next().value, process) :\n+                                      marshaller.unmarshallReadOnlyProcessInstance(iterator.next().value, process)\n+                );\n+            }\n+            return instances;\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public Integer size() {\n+        int size = 0;\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNzQxNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571817417", "bodyText": "I changed to use that, but isnt reliable, or it does get updated from time to time, so in order to use this way, I removed it from the tests.", "author": "cristianonicolai", "createdAt": "2021-02-08T07:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4OTgzNA=="}], "type": "inlineReview", "revised_code": {"commit": "633430c163438bed2b8989df88c4fcbc93e82871", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 2fe3ff6391..6e7d29e7c6 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n\n@@ -20,11 +20,15 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n import java.util.function.Supplier;\n \n import org.apache.kafka.clients.producer.KafkaProducer;\n import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n import org.infinispan.protostream.BaseMarshaller;\n import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5MjQzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568892436", "bodyText": "I already said that but every time I see all() it hurts me :P  at some point we need to revisit this values() method in runtimes, anyway just saying.", "author": "tiagodolphine", "createdAt": "2021-02-02T20:02:00Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public KafkaProcessInstances(Process<?> process, String topic, Supplier<ReadOnlyKeyValueStore<String, byte[]>> storeSupplier, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topic;\n+        this.producer = producer;\n+        this.marshaller = new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers));\n+        this.store = storeSupplier.get();\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return store.get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (store.get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = store.get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNzY3Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571817677", "bodyText": "+1, not happy about this either :) but its the same for all persistence types, should really be used for tests only", "author": "cristianonicolai", "createdAt": "2021-02-08T07:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5MjQzNg=="}], "type": "inlineReview", "revised_code": {"commit": "633430c163438bed2b8989df88c4fcbc93e82871", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 2fe3ff6391..6e7d29e7c6 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n\n@@ -20,11 +20,15 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n import java.util.function.Supplier;\n \n import org.apache.kafka.clients.producer.KafkaProducer;\n import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n import org.infinispan.protostream.BaseMarshaller;\n import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n"}}, {"oid": "633430c163438bed2b8989df88c4fcbc93e82871", "url": "https://github.com/kiegroup/kogito-runtimes/commit/633430c163438bed2b8989df88c4fcbc93e82871", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-03T03:58:22Z", "type": "forcePushed"}, {"oid": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-04T01:01:28Z", "type": "forcePushed"}, {"oid": "ede1cb4064c89d1b2f4fc8577b0602d3e81348af", "url": "https://github.com/kiegroup/kogito-runtimes/commit/ede1cb4064c89d1b2f4fc8577b0602d3e81348af", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-04T08:33:25Z", "type": "forcePushed"}, {"oid": "9cecb263d0ebb610ae1d54509cb9561437d3e33e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9cecb263d0ebb610ae1d54509cb9561437d3e33e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-04T09:18:08Z", "type": "forcePushed"}, {"oid": "27327e054b73b72e065a160fe42059ba4776df71", "url": "https://github.com/kiegroup/kogito-runtimes/commit/27327e054b73b72e065a160fe42059ba4776df71", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-05T06:09:56Z", "type": "forcePushed"}, {"oid": "eba1a010fed2d94fef88bef28ce3c3d498eb2d02", "url": "https://github.com/kiegroup/kogito-runtimes/commit/eba1a010fed2d94fef88bef28ce3c3d498eb2d02", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-05T07:35:25Z", "type": "forcePushed"}, {"oid": "494bee99defc436f1c88fb00356bb81095ac1865", "url": "https://github.com/kiegroup/kogito-runtimes/commit/494bee99defc436f1c88fb00356bb81095ac1865", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T03:47:19Z", "type": "forcePushed"}, {"oid": "29159a9f025be375f7d1dde948732c6b8951f6ff", "url": "https://github.com/kiegroup/kogito-runtimes/commit/29159a9f025be375f7d1dde948732c6b8951f6ff", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T07:40:32Z", "type": "forcePushed"}, {"oid": "8291208a7fdbc2b9e2c5c89702060eccd1181a82", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8291208a7fdbc2b9e2c5c89702060eccd1181a82", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T11:55:10Z", "type": "forcePushed"}, {"oid": "95ffd75ab52b23dcfd4fc83df24f356547c3b9cf", "url": "https://github.com/kiegroup/kogito-runtimes/commit/95ffd75ab52b23dcfd4fc83df24f356547c3b9cf", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T11:56:08Z", "type": "forcePushed"}, {"oid": "c1b58ae3e223447875d6dde4127472a981e15fb0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c1b58ae3e223447875d6dde4127472a981e15fb0", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T15:17:25Z", "type": "forcePushed"}, {"oid": "04f611739e7cf099fd05e3b4aa3ecfd485e93318", "url": "https://github.com/kiegroup/kogito-runtimes/commit/04f611739e7cf099fd05e3b4aa3ecfd485e93318", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T15:24:58Z", "type": "forcePushed"}, {"oid": "0190a1a1283fb5ca6da0625d00ce0ed868dc1bf9", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0190a1a1283fb5ca6da0625d00ce0ed868dc1bf9", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-09T05:37:29Z", "type": "forcePushed"}, {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-09T06:40:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc4MDA0Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572780046", "bodyText": "Can't this be called in parallel during injection and initialization of the process endpoints?", "author": "MarianMacik", "createdAt": "2021-02-09T10:46:56Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(KafkaProducer::close);\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = getProducer();\n+            producers.add(producer);", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NDQ0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573484445", "bodyText": "true, but I changed the logic now, the producer is not created here anymore.", "author": "cristianonicolai", "createdAt": "2021-02-10T06:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc4MDA0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "730a8254ba0855f4a904091a1306a0599df22613", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex a7ab4e52fc..0109771c8b 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n\n@@ -16,7 +16,6 @@\n \n package org.kie.kogito.persistence;\n \n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc5NDI4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572794286", "bodyText": "This means that KafkaStreams can already be injected, but not started? So we have to wait in all store manipulation methods until it is running?", "author": "MarianMacik", "createdAt": "2021-02-09T11:06:25Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private KafkaStreams streams;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        this.streams = streams;\n+        this.streams.setStateListener((newState, oldState) -> {\n+            if (store == null && newState == KafkaStreams.State.RUNNING) {\n+                setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore())));\n+                latch.countDown();\n+            }\n+        });", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NDY4Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573484687", "bodyText": "yep, KafkaStream get injected but is in CREATED state, a store can only be retrieved once it is on RUNNING state.", "author": "cristianonicolai", "createdAt": "2021-02-10T06:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc5NDI4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "730a8254ba0855f4a904091a1306a0599df22613", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex e6144573a8..30318b42c9 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n\n@@ -25,10 +25,7 @@ import java.util.concurrent.TimeUnit;\n \n import org.apache.kafka.clients.producer.KafkaProducer;\n import org.apache.kafka.clients.producer.ProducerRecord;\n-import org.apache.kafka.streams.KafkaStreams;\n-import org.apache.kafka.streams.StoreQueryParameters;\n import org.apache.kafka.streams.state.KeyValueIterator;\n-import org.apache.kafka.streams.state.QueryableStoreTypes;\n import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n import org.infinispan.protostream.BaseMarshaller;\n import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwOTY1Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572809653", "bodyText": "Daniele said that this can happen, but I don't see how would new KafkaProcessInstancesFactory(); fail. Maybe in older code it could happen?", "author": "MarianMacik", "createdAt": "2021-02-09T11:30:33Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (factory != null) {", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzIyOTcyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573229727", "bodyText": "My comment was mainly for general stability and avoid problem in the future :)", "author": "danielezonca", "createdAt": "2021-02-09T20:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwOTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NDgyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573484827", "bodyText": "yep, just more defensive style, just in case :)", "author": "cristianonicolai", "createdAt": "2021-02-10T06:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwOTY1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "730a8254ba0855f4a904091a1306a0599df22613", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 8ed95049b4..ee607d63e1 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n\n@@ -65,20 +65,23 @@ public class KafkaProcessInstancesIT {\n \n     KafkaProcessInstancesFactory factory;\n \n+    KafkaStreamsStateListener listener = new KafkaStreamsStateListener();\n+\n     @BeforeEach\n     void start() {\n         factory = new KafkaProcessInstancesFactory();\n         factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+        factory.setStateListener(listener);\n     }\n \n     @AfterEach\n     void stop() {\n         if (factory != null) {\n             factory.stop();\n-            if (factory.getKafkaStreams() != null) {\n-                factory.getKafkaStreams().close();\n-                factory.getKafkaStreams().cleanUp();\n-            }\n+        }\n+        if (listener.getKafkaStreams() != null) {\n+            listener.getKafkaStreams().close();\n+            listener.getKafkaStreams().cleanUp();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxMjkwMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572812900", "bodyText": "Just curious, I have always thought that Kafka Streams also support producers and consumers, meaning it is the \"superset\" of the traditional Consumer/Producer API. Or this is just in case we receive something from Kafka and then want to push it again to Kafka (\"streams\")? Not sure about the clear distinction between Kafka Streams and Kafka here.", "author": "MarianMacik", "createdAt": "2021-02-09T11:35:57Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private KafkaStreams streams;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        this.streams = streams;", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NjE1NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573486154", "bodyText": "KafkaStreams is building a table ( key value store ) representation of the data ( process state ). The way it does it is key storing the latest value of certain message key as the current state. That means, I can read the current state of process from KafkaStreams table abstraction, but if I want to manipulate it ( delete/create/update ) the process, I need to send a message to a Kafka topic.\nSee https://docs.confluent.io/platform/current/streams/concepts.html#duality-of-streams-and-tables", "author": "cristianonicolai", "createdAt": "2021-02-10T06:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxMjkwMA=="}], "type": "inlineReview", "revised_code": {"commit": "730a8254ba0855f4a904091a1306a0599df22613", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex e6144573a8..30318b42c9 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n\n@@ -25,10 +25,7 @@ import java.util.concurrent.TimeUnit;\n \n import org.apache.kafka.clients.producer.KafkaProducer;\n import org.apache.kafka.clients.producer.ProducerRecord;\n-import org.apache.kafka.streams.KafkaStreams;\n-import org.apache.kafka.streams.StoreQueryParameters;\n import org.apache.kafka.streams.state.KeyValueIterator;\n-import org.apache.kafka.streams.state.QueryableStoreTypes;\n import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n import org.infinispan.protostream.BaseMarshaller;\n import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxNTgyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572815823", "bodyText": "Do all of these methods have to be package-private?", "author": "MarianMacik", "createdAt": "2021-02-09T11:40:46Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (factory != null) {\n+            factory.stop();\n+            if (factory.getKafkaStreams() != null) {\n+                factory.getKafkaStreams().close();\n+                factory.getKafkaStreams().cleanUp();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testFindByIdReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n+\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+\n+        ProcessInstance<BpmnVariables> mutablePi = process.createInstance(BpmnVariables.create(singletonMap(\"var\", \"value\")));\n+\n+        mutablePi.start();\n+        assertThat(mutablePi.status()).isEqualTo(STATE_ERROR);\n+        assertThat(mutablePi.error()).hasValueSatisfying(error -> {\n+            assertThat(error.errorMessage()).endsWith(\"java.lang.NullPointerException - null\");\n+            assertThat(error.failedNodeId()).isEqualTo(\"ScriptTask_1\");\n+        });\n+        assertThat(mutablePi.variables().toMap()).containsExactly(entry(\"var\", \"value\"));\n+\n+        await().until(() -> instances.values().size() == 1);\n+        \n+        ProcessInstance<BpmnVariables> pi = instances.findById(mutablePi.id(), ProcessInstanceReadMode.READ_ONLY).get();\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> pi.abort());\n+\n+        ProcessInstance<BpmnVariables> readOnlyPi = instances.findById(mutablePi.id(), ProcessInstanceReadMode.READ_ONLY).get();\n+        assertThat(readOnlyPi.status()).isEqualTo(STATE_ERROR);\n+        assertThat(readOnlyPi.error()).hasValueSatisfying(error -> {\n+            assertThat(error.errorMessage()).endsWith(\"java.lang.NullPointerException - null\");\n+            assertThat(error.failedNodeId()).isEqualTo(\"ScriptTask_1\");\n+        });\n+        assertThat(readOnlyPi.variables().toMap()).containsExactly(entry(\"var\", \"value\"));\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> readOnlyPi.abort());\n+\n+        instances.findById(mutablePi.id()).get().abort();\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    @Test\n+    void testValuesReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask.bpmn2\")).get(0);\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+\n+        ProcessInstance<BpmnVariables> processInstance = process.createInstance(BpmnVariables.create(singletonMap(\"test\", \"test\")));\n+\n+        processInstance.start();\n+\n+        await().until(() -> instances.values().size() == 1);\n+\n+        ProcessInstance<BpmnVariables> pi = instances.values().stream().findFirst().get();\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> pi.abort());\n+        instances.values(ProcessInstanceReadMode.MUTABLE).stream().findFirst().get().abort();\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    @Test\n+    void testBasicFlow() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask.bpmn2\")).get(0);\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+        \n+        ProcessInstance<BpmnVariables> processInstance = process.createInstance(BpmnVariables.create(singletonMap(\"test\", \"test\")));\n+\n+        processInstance.start();\n+        assertEquals(STATE_ACTIVE, processInstance.status());\n+\n+        await().until(() -> instances.values().size() == 1);\n+\n+        SecurityPolicy asJohn = SecurityPolicy.of(IdentityProviders.of(\"john\"));\n+\n+        assertThat(instances.values().iterator().next().workItems(asJohn)).hasSize(1);\n+\n+        List<WorkItem> workItems = processInstance.workItems(asJohn);\n+        assertThat(workItems).hasSize(1);\n+        WorkItem workItem = workItems.get(0);\n+        assertEquals(\"john\", workItem.getParameters().get(\"ActorId\"));\n+        processInstance.completeWorkItem(workItem.getId(), null, asJohn);\n+        assertEquals(STATE_COMPLETED, processInstance.status());\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    KafkaStreams createStreams(Process process) {\n+        Topology topology = createTopologyForProcesses(Arrays.asList(process.id()));\n+        KafkaStreams streams = new KafkaStreams(topology, getStreamsConfig());\n+        streams.setUncaughtExceptionHandler((Thread thread, Throwable throwable) ->\n+                                                    LOGGER.error(\"Kafka persistence error: \" + throwable.getMessage(), throwable)\n+        );\n+        streams.cleanUp();\n+        return streams;\n+    }\n+\n+    Properties getStreamsConfig() {", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NjMzMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573486330", "bodyText": "not really, but this is just an IT test anyway, didn't see much of a need to do it differently", "author": "cristianonicolai", "createdAt": "2021-02-10T06:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxNTgyMw=="}], "type": "inlineReview", "revised_code": {"commit": "730a8254ba0855f4a904091a1306a0599df22613", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 8ed95049b4..ee607d63e1 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n\n@@ -65,20 +65,23 @@ public class KafkaProcessInstancesIT {\n \n     KafkaProcessInstancesFactory factory;\n \n+    KafkaStreamsStateListener listener = new KafkaStreamsStateListener();\n+\n     @BeforeEach\n     void start() {\n         factory = new KafkaProcessInstancesFactory();\n         factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+        factory.setStateListener(listener);\n     }\n \n     @AfterEach\n     void stop() {\n         if (factory != null) {\n             factory.stop();\n-            if (factory.getKafkaStreams() != null) {\n-                factory.getKafkaStreams().close();\n-                factory.getKafkaStreams().cleanUp();\n-            }\n+        }\n+        if (listener.getKafkaStreams() != null) {\n+            listener.getKafkaStreams().close();\n+            listener.getKafkaStreams().cleanUp();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg3NzY4MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572877680", "bodyText": "Isn't this already true because of the check at the beginning of the method?", "author": "MarianMacik", "createdAt": "2021-02-09T13:21:07Z", "path": "kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -94,34 +99,39 @@ public PersistenceGenerator(KogitoBuildContext context, ProtoGenerator protoGene\n             return Collections.emptyList();\n         }\n \n-        switch (persistenceType()) {\n-            case INFINISPAN_PERSISTENCE_TYPE:\n-                return infinispanBasedPersistence();\n-            case FILESYSTEM_PERSISTENCE_TYPE:\n-                return fileSystemBasedPersistence();\n-            case MONGODB_PERSISTENCE_TYPE:\n-                return mongodbBasedPersistence();\n-            default:\n-                throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n+        Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());\n+        \n+        if (context().getAddonsConfig().usePersistence()) {", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NzIzNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573487237", "bodyText": "true, that was a bad merge, fixed now", "author": "cristianonicolai", "createdAt": "2021-02-10T06:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg3NzY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "chunk": "diff --git a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 3a68a47a4a..cc6bf851ea 100644\n--- a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n\n@@ -101,23 +101,21 @@ public class PersistenceGenerator extends AbstractGenerator {\n \n         Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());\n         \n-        if (context().getAddonsConfig().usePersistence()) {\n-            switch (persistenceType()) {\n-                case INFINISPAN_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(infinispanBasedPersistence());\n-                    break;\n-                case FILESYSTEM_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(fileSystemBasedPersistence());\n-                    break;\n-                case MONGODB_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(mongodbBasedPersistence());\n-                    break;\n-                case KAFKA_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(kafkaBasedPersistence());\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n-            }\n+        switch (persistenceType()) {\n+            case INFINISPAN_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(infinispanBasedPersistence());\n+                break;\n+            case FILESYSTEM_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(fileSystemBasedPersistence());\n+                break;\n+            case MONGODB_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(mongodbBasedPersistence());\n+                break;\n+            case KAFKA_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(kafkaBasedPersistence());\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n         }\n \n         return generatedFiles;\n"}}, {"oid": "730a8254ba0855f4a904091a1306a0599df22613", "url": "https://github.com/kiegroup/kogito-runtimes/commit/730a8254ba0855f4a904091a1306a0599df22613", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-10T06:34:15Z", "type": "forcePushed"}, {"oid": "c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-10T07:02:46Z", "type": "forcePushed"}, {"oid": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-10T10:20:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzcyODc4OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573728789", "bodyText": "As I asked before, cannot this be called by multiple threads at the same time? Imagine having more processes and injecting them when the app starts. This calls this method then:\n\n  \n    \n      kogito-runtimes/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcess.java\n    \n    \n        Lines 131 to 139\n      in\n      17154e1\n    \n    \n    \n    \n\n        \n          \n           public Process<T> configure() { \n        \n\n        \n          \n            \n        \n\n        \n          \n               registerListeners(); \n        \n\n        \n          \n               if (isProcessFactorySet()) { \n        \n\n        \n          \n                   this.instances = (MutableProcessInstances<T>) processInstancesFactory.createProcessInstances(this); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               return this; \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nwhen the process is activated.\nNot sure if injection can happen in more threads, but if it can then we need to use concurrent collection here I think. Otherwise in case more than one process is activated at the same time, it won't work properly.", "author": "MarianMacik", "createdAt": "2021-02-10T13:33:32Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+\n+@ApplicationScoped\n+public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n+\n+    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+\n+    private KafkaStreams streams;\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+        this.streams.setStateListener(this);\n+    }\n+\n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        instances.clear();\n+    }\n+\n+    protected List<KafkaProcessInstances> getInstances() {\n+        return instances;\n+    }\n+\n+    @Override\n+    public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n+        LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n+        if (newState == KafkaStreams.State.RUNNING) {\n+            instances.forEach(pi -> {\n+                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n+                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            });\n+        }\n+    }\n+\n+    public void addProcessInstances(KafkaProcessInstances pi) {\n+        LOGGER.debug(\"Adding process instance into listener for process: {}\", pi.getProcess().id());\n+        instances.add(pi);", "originalCommit": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI1MTQ3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574251472", "bodyText": "yep, makes sense. I changed the backing collection to support concurrent access now, thanks", "author": "cristianonicolai", "createdAt": "2021-02-11T04:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzcyODc4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c3aae5132acc313a6460afbfa28a8bb09057cc62", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\nindex 8f214a8028..d090f2b3eb 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n\n@@ -16,8 +16,9 @@\n \n package org.kie.kogito.persistence.kafka;\n \n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import javax.annotation.PreDestroy;\n import javax.enterprise.context.ApplicationScoped;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzczNTM5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573735392", "bodyText": "What if KafkaStreams component is started earlier then all the KafkaProcessInstances are set up? Will it react also then? If not, we may permanently set state to running in the listener when we get that information and then set stores directly if the state is already running. That would mean, however, to sync it properly.", "author": "MarianMacik", "createdAt": "2021-02-10T13:43:03Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+\n+@ApplicationScoped\n+public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n+\n+    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+\n+    private KafkaStreams streams;\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+        this.streams.setStateListener(this);\n+    }\n+\n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        instances.clear();\n+    }\n+\n+    protected List<KafkaProcessInstances> getInstances() {\n+        return instances;\n+    }\n+\n+    @Override\n+    public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n+        LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n+        if (newState == KafkaStreams.State.RUNNING) {\n+            instances.forEach(pi -> {\n+                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n+                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            });", "originalCommit": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI1MTI2Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574251266", "bodyText": "from what I seen that shouldnt happen, but I added a check anyway so we should be covered now.", "author": "cristianonicolai", "createdAt": "2021-02-11T04:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzczNTM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDQwMTgxNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574401814", "bodyText": "In theory it can still happen if the addProcessInstances passes the check and the streams are not running, but then the listener is triggered before a hash map is updated. But I agree, that this probably should be sorted out on the Kafka Streams/Quarkus side that they should wait until dependency injection is established so any listeners can be triggered only after that. I think it is fine for now.", "author": "MarianMacik", "createdAt": "2021-02-11T10:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzczNTM5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c3aae5132acc313a6460afbfa28a8bb09057cc62", "chunk": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\nindex 8f214a8028..d090f2b3eb 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n\n@@ -16,8 +16,9 @@\n \n package org.kie.kogito.persistence.kafka;\n \n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import javax.annotation.PreDestroy;\n import javax.enterprise.context.ApplicationScoped;\n"}}, {"oid": "c3aae5132acc313a6460afbfa28a8bb09057cc62", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c3aae5132acc313a6460afbfa28a8bb09057cc62", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-11T04:54:42Z", "type": "forcePushed"}, {"oid": "1cb72ee9575ad444bba155bc7610f9eaf168bce7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1cb72ee9575ad444bba155bc7610f9eaf168bce7", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-11T04:59:49Z", "type": "forcePushed"}, {"oid": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-11T05:43:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDgzMTY1MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574831651", "bodyText": "This is just an approximation, do we use this value anywhere? We should make sure an approximation works", "author": "danielezonca", "createdAt": "2021-02-11T21:15:50Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        setMarshaller(new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers)));\n+    }\n+\n+    protected Process<?> getProcess() {\n+        return process;\n+    }\n+\n+    protected ReadOnlyKeyValueStore<String, byte[]> getStore() {\n+        if (store != null) {\n+            return store;\n+        }\n+\n+        return getStoreAwait();\n+    }\n+\n+    protected void setStore(ReadOnlyKeyValueStore<String, byte[]> store) {\n+        this.store = store;\n+        this.latch.countDown();\n+    }\n+\n+    private ReadOnlyKeyValueStore<String, byte[]> getStoreAwait() {\n+        try {\n+            if (latch.await(1, TimeUnit.MINUTES)) {\n+                if (store == null) {\n+                    throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n+                } else {\n+                    return store;\n+                }\n+            } else {\n+                throw new RuntimeException(\"Timeout waiting to obtain Kafka Store for process: \" + process.id());\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n+        }\n+    }\n+\n+    protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n+        this.marshaller = marshaller;\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return getStore().get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (getStore().get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = getStore().get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = getStore().all()) {\n+            while (iterator.hasNext()) {\n+                instances.add(mode == MUTABLE ?\n+                                      marshaller.unmarshallProcessInstance(iterator.next().value, process) :\n+                                      marshaller.unmarshallReadOnlyProcessInstance(iterator.next().value, process)\n+                );\n+            }\n+            return instances;\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public Integer size() {\n+        return (int) getStore().approximateNumEntries();", "originalCommit": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTE0MTgzMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r575141832", "bodyText": "I added just to keep it somehow compatible with the other persistence impl. During my tests this is not reliable at all, or it doesn't update as frequently as it would need for a simple IT test. We will probably have to review this in the future, but size, values are methods used manly for tests.", "author": "cristianonicolai", "createdAt": "2021-02-12T10:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDgzMTY1MQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "b9353cbdb6843b3584630fd4e77028e6c819a4bf", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b9353cbdb6843b3584630fd4e77028e6c819a4bf", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-12T13:03:01Z", "type": "forcePushed"}, {"oid": "d5a0ac73bf080723dfd265f9b0862f1d0509e7a0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/d5a0ac73bf080723dfd265f9b0862f1d0509e7a0", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-12T13:50:00Z", "type": "forcePushed"}, {"oid": "03463ae050215ce3761dae5e78eb8150c216d72e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/03463ae050215ce3761dae5e78eb8150c216d72e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-15T02:33:44Z", "type": "commit"}, {"oid": "03463ae050215ce3761dae5e78eb8150c216d72e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/03463ae050215ce3761dae5e78eb8150c216d72e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-15T02:33:44Z", "type": "forcePushed"}]}