{"pr_number": 778, "pr_title": "[KOGITO-3158] Adding RestTaskHandler", "pr_createdAt": "2020-09-18T19:26:38Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/778", "timeline": [{"oid": "149cb9bd6dc6ae44e43785de5284c6dc9d9ae91f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/149cb9bd6dc6ae44e43785de5284c6dc9d9ae91f", "message": "[KOGITO-3158] Adding RestTaskHandler\n\nAlso generating work item for workflow functions", "committedDate": "2020-09-18T20:00:39Z", "type": "forcePushed"}, {"oid": "1ab33a6991ce2880eda5b5613c77e29cad2ddbae", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1ab33a6991ce2880eda5b5613c77e29cad2ddbae", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-21T13:46:03Z", "type": "forcePushed"}, {"oid": "86a4004b13f89f293db3ca10f73607b975b3ffc0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/86a4004b13f89f293db3ca10f73607b975b3ffc0", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-21T13:47:13Z", "type": "forcePushed"}, {"oid": "7f6cfc225ff86c812e5316e000727d7722f9fffb", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7f6cfc225ff86c812e5316e000727d7722f9fffb", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-21T13:54:09Z", "type": "forcePushed"}, {"oid": "1ef92b3975994d6f9442b04f4687108290701f57", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1ef92b3975994d6f9442b04f4687108290701f57", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-21T14:00:47Z", "type": "forcePushed"}, {"oid": "3846904687e60620047b5022d5b8c3f0e794ae82", "url": "https://github.com/kiegroup/kogito-runtimes/commit/3846904687e60620047b5022d5b8c3f0e794ae82", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-21T15:11:54Z", "type": "forcePushed"}, {"oid": "760ba4fc71c661fab3bb6e9852e06812d6135282", "url": "https://github.com/kiegroup/kogito-runtimes/commit/760ba4fc71c661fab3bb6e9852e06812d6135282", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-21T15:19:18Z", "type": "forcePushed"}, {"oid": "9f75213e9bc31aeb35b5dfca49ab10d314f05739", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9f75213e9bc31aeb35b5dfca49ab10d314f05739", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-21T15:38:53Z", "type": "forcePushed"}, {"oid": "a51b032f08b28c48f814d865c673d1f174aef608", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a51b032f08b28c48f814d865c673d1f174aef608", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-21T15:39:50Z", "type": "forcePushed"}, {"oid": "ccec804cd4dad036294f0d22d14420c3ff2bbc86", "url": "https://github.com/kiegroup/kogito-runtimes/commit/ccec804cd4dad036294f0d22d14420c3ff2bbc86", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-21T15:42:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0NjkyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492246927", "bodyText": "If you are addressing results of a JsonPath query, it will/should always be an array.\nI don't fully understand the copying of values much, just return the json as-is that comes back from the rest service call.", "author": "tsurdilo", "createdAt": "2020-09-21T17:59:42Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.util.function.BiFunction;\n+\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JSonPathResultHandler implements BiFunction<Object, JsonObject, Object> {", "originalCommit": "ccec804cd4dad036294f0d22d14420c3ff2bbc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NDcwMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492264701", "bodyText": "The resulf of the rest invocation needs to be merged into the json tree, in order json queries to be performed over it.\nThe point is that details of the conversion are hidden into this object, so neither serverless no handler needs to be changed if the model structure change, just this object (or a new object that implements bifunction can be defined and invoked by the generator)", "author": "fjtirado", "createdAt": "2020-09-21T18:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0NjkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM1NTUzNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492355537", "bodyText": "Ok, what I'm thinking is that it would be better for SW to deal with this via a script task that does this, than having this code in /jbpm/process/instance. Reason being is that SW should be able to do this independently of the bpmn2 processes for example. Or allow for SW to overwrite this class if possible, so it can evolve this independently", "author": "tsurdilo", "createdAt": "2020-09-21T21:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0NjkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUzNTkwNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492535907", "bodyText": "SW is specifying that this class should be used when populating the workitem with parameters\nI think this is cleaner that forcing the sw writer to introduce a script task", "author": "fjtirado", "createdAt": "2020-09-22T07:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0NjkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcxODc1OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493718759", "bodyText": "Please read #778 (comment)", "author": "fjtirado", "createdAt": "2020-09-23T16:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0NjkyNw=="}], "type": "inlineReview", "revised_code": {"commit": "1960b6ff25ca54dfa8350c88f9cf2deedf808416", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\nindex ddeefede25..4d725d4aea 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\n\n@@ -23,89 +23,69 @@ import io.vertx.core.json.JsonObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-\n public class JSonPathResultHandler implements BiFunction<Object, JsonObject, Object> {\n-    \n+\n     private static final Logger logger = LoggerFactory.getLogger(JSonPathResultHandler.class);\n-    \n+\n     @Override\n     public Object apply(Object inputParameter, JsonObject node) {\n-        return transform(node,(ObjectNode) inputParameter);\n+        return transform(node, (ObjectNode) inputParameter);\n     }\n-    \n-    private ObjectNode transform (JsonObject src, ObjectNode target) {\n-        src.forEach(e -> setValue(target,e.getKey(),e.getValue()));\n+\n+    private ObjectNode transform(JsonObject src, ObjectNode target) {\n+        src.forEach(e -> setValue(target, e.getKey(), e.getValue()));\n         return target;\n     }\n \n     private void setValue(ObjectNode result, String key, Object value) {\n         if (value instanceof Double) {\n-            result.put(key, (Double)value);\n-        }\n-        else if (value instanceof Float) {\n-            result.put(key, (Float)value);\n-        }\n-        else if (value instanceof Long) {\n+            result.put(key, (Double) value);\n+        } else if (value instanceof Float) {\n+            result.put(key, (Float) value);\n+        } else if (value instanceof Long) {\n             result.put(key, (Long) value);\n-        }\n-        else if (value instanceof Integer) {\n+        } else if (value instanceof Integer) {\n             result.put(key, (Integer) value);\n-        }\n-        else if (value instanceof Short) {\n+        } else if (value instanceof Short) {\n             result.put(key, (Short) value);\n-        }\n-        else if (value instanceof Boolean) {\n+        } else if (value instanceof Boolean) {\n             result.put(key, (Boolean) value);\n-        }\n-        else if (value instanceof String) {\n+        } else if (value instanceof String) {\n             result.put(key, (String) value);\n-        }\n-        else if (value instanceof JsonObject) {\n-            result.set(key, transform((JsonObject)value, result.objectNode()));\n-        }\n-        else if (value instanceof JsonArray) {\n+        } else if (value instanceof JsonObject) {\n+            result.set(key, transform((JsonObject) value, result.objectNode()));\n+        } else if (value instanceof JsonArray) {\n             ArrayNode array = result.arrayNode();\n-            ((JsonArray)value).forEach(v -> addValue(array,v));\n-            result.set(key,array);\n-        }\n-        else {\n-            logger.warn(\"Unrecognized data type for object {} class {}\",value,value.getClass());\n+            ((JsonArray) value).forEach(v -> addValue(array, v));\n+            result.set(key, array);\n+        } else {\n+            logger.warn(\"Unrecognized data type for object {} class {}\", value, value.getClass());\n         }\n     }\n-    \n-    \n-    private void addValue (ArrayNode result, Object value) {\n+\n+    private void addValue(ArrayNode result, Object value) {\n         if (value instanceof Double) {\n-            result.add((Double)value);\n-        }\n-        else if (value instanceof Float) {\n-            result.add( (Float)value);\n-        }\n-        else if (value instanceof Long) {\n-            result.add( (Long) value);\n-        }\n-        else if (value instanceof Integer) {\n-            result.add( (Integer) value);\n-        }\n-        else if (value instanceof Short) {\n-            result.add( (Short) value);\n-        }\n-        else if (value instanceof Boolean) {\n-            result.add( (Boolean) value);\n-        }\n-        else if (value instanceof String) {\n-            result.add( (String) value);\n-        }\n-        else if (value instanceof JsonObject) {\n-            result.add(transform((JsonObject)value, result.objectNode()));\n-        }\n-        else if (value instanceof JsonArray) {\n+            result.add((Double) value);\n+        } else if (value instanceof Float) {\n+            result.add((Float) value);\n+        } else if (value instanceof Long) {\n+            result.add((Long) value);\n+        } else if (value instanceof Integer) {\n+            result.add((Integer) value);\n+        } else if (value instanceof Short) {\n+            result.add((Short) value);\n+        } else if (value instanceof Boolean) {\n+            result.add((Boolean) value);\n+        } else if (value instanceof String) {\n+            result.add((String) value);\n+        } else if (value instanceof JsonObject) {\n+            result.add(transform((JsonObject) value, result.objectNode()));\n+        } else if (value instanceof JsonArray) {\n             ArrayNode array = result.arrayNode();\n-            ((JsonArray)value).forEach(v -> addValue(array,v));\n+            ((JsonArray) value).forEach(v -> addValue(array, v));\n             result.add(array);\n-        }\n-        else {\n-            logger.warn(\"Unrecognized data type for object {} class {}\",value,value.getClass());\n+        } else {\n+            logger.warn(\"Unrecognized data type for object {} class {}\", value, value.getClass());\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MDEyNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492250124", "bodyText": "Are we exposing this to users in public api? If so it could also be used insides script expressions which is nice.\nI would change it tho so it can be used easier, for example JsonPathResolver.resolve(....). much easier to deal w/ in expressions as such", "author": "tsurdilo", "createdAt": "2020-09-21T18:05:23Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JsonPathResolver.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.function.UnaryOperator;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.jayway.jsonpath.Configuration;\n+import com.jayway.jsonpath.JsonPath;\n+import com.jayway.jsonpath.spi.json.JacksonJsonNodeJsonProvider;\n+import com.jayway.jsonpath.spi.mapper.JacksonMappingProvider;\n+\n+public class JsonPathResolver implements UnaryOperator<Object> {", "originalCommit": "ccec804cd4dad036294f0d22d14420c3ff2bbc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NTQ1Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492265457", "bodyText": "This is not a public API. And even if it was, it is implementing a well known interface defined in jdk8, users familiar with utils.function package will probably expect an apply as public method in this case(but it does not matter since it is not public)", "author": "fjtirado", "createdAt": "2020-09-21T18:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MDEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NjkwOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492276908", "bodyText": "Please note that this class is for now specific to SW, since it is dealing with json path resolution", "author": "fjtirado", "createdAt": "2020-09-21T18:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MDEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM1NjM2Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492356366", "bodyText": "If its specific to SW then it should be in the jbpm/jbpm-serverless-workflow package and not in /jbpm/process/instance impl IMO. Again since IMO this can be set as a expression or in script task it would be nice to do that as SW can evolve independently.", "author": "tsurdilo", "createdAt": "2020-09-21T21:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MDEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM1OTg5OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492359899", "bodyText": "I really do not care if it uses a well or not well known interface or not :) My concern is about usability.", "author": "tsurdilo", "createdAt": "2020-09-21T21:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MDEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUzNjcyOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492536728", "bodyText": "I first put this class in sw project, but it turns out that classes there are not used at runtime, thats the only reason this class was add to flow, but I agree is not the better place. The goal of doing so is that this class should be in classpath at runtime", "author": "fjtirado", "createdAt": "2020-09-22T07:50:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MDEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcxODIyOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493718229", "bodyText": "Class has been moved to serverless-workflow-runtime project (so can be edited by SW developers). It now implementes a well defined interface rather than the generic one", "author": "fjtirado", "createdAt": "2020-09-23T16:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MDEyNA=="}], "type": "inlineReview", "revised_code": {"commit": "a02f120e8c651c1b750eed28fa306c3ff949d98d", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JsonPathResolver.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JsonPathResolver.java\nindex 05b74e5447..b2ea317f0d 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JsonPathResolver.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JsonPathResolver.java\n\n@@ -17,7 +17,6 @@ package org.jbpm.process.instance.impl.rest;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Iterator;\n-import java.util.function.UnaryOperator;\n \n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.node.ArrayNode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MjU2OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492252569", "bodyText": "Don't get this:\n\nIt seems very workflow specific , but then again in new version the queries are enclosed in '{{' and '}}'.\nData passed to functions even in SW are not always expressions. It can be custom JSON objects as well.\nThis seems not useful for BPMN2 scenarios no?\n'", "author": "tsurdilo", "createdAt": "2020-09-21T18:09:52Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.kie.api.runtime.process.WorkItemHandler;\n+import org.kie.api.runtime.process.WorkItemManager;\n+\n+public class RestTaskHandler implements WorkItemHandler {\n+\n+    public static final String REST_TASK_TYPE = \"Rest Task\";\n+    public static final String ENDPOINT = \"endpoint\";\n+    public static final String METHOD = \"method\";\n+    public static final String PARAMETER = \"Parameter\";\n+    public static final String RESULT = \"Result\";\n+    public static final String RESULT_HANDLER = \"ResultHandler\";\n+    public static final String USER = \"User\";\n+    public static final String PASSWORD = \"Password\";\n+\n+    // package scoped to allow unit test\n+    static class RestUnaryOperator implements UnaryOperator<Object> {\n+\n+        private Object inputModel;\n+\n+        public RestUnaryOperator(Object inputModel) {\n+            this.inputModel = inputModel;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public Object apply(Object value) {\n+            return value instanceof Function\n+                    ? ((Function<Object, Object>) value).apply(inputModel) : value;\n+        }\n+    }\n+\n+    private WebClient client;\n+\n+    public RestTaskHandler(WebClient client) {\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public void executeWorkItem(WorkItem workItem, WorkItemManager manager) {\n+        // retrieving parameters\n+        Map<String, Object> parameters = new HashMap<>(workItem.getParameters());\n+        String endPoint = (String) getParam(parameters, ENDPOINT);\n+        String method = (String) getParam(parameters, METHOD);\n+        Object inputModel = getParam(parameters, PARAMETER);\n+        String user = (String) parameters.remove(USER);\n+        String password = (String) parameters.remove(PASSWORD);\n+        @SuppressWarnings(\"unchecked\")\n+        BiFunction<Object, JsonObject, Object> resultHandler =\n+                (BiFunction<Object, JsonObject, Object>) getParam(parameters, RESULT_HANDLER);\n+        // executing request\n+        UnaryOperator<Object> resolver = new RestUnaryOperator(inputModel);\n+        endPoint = resolvePathParams(endPoint, parameters, resolver);\n+        URI uri = URI.create(endPoint);\n+        HttpRequest<Buffer> request = client\n+            .request(HttpMethod.valueOf(method.toUpperCase()), uri.getPort(), uri.getHost(), uri.getPath());\n+\n+        if (user != null && !user.trim().isEmpty() && password != null && !password.trim().isEmpty()) {\n+            request.basicAuthentication(user, password);\n+        }\n+        HttpResponse<Buffer> response = method.equalsIgnoreCase(\"POST\") || method.equalsIgnoreCase(\"PUT\")\n+                ? request\n+                    .sendJsonAndAwait(\n+                                      parameters\n+                                          .entrySet()\n+                                          .stream()\n+                                          .collect(\n+                                                   Collectors\n+                                                       .toMap(Entry::getKey, e -> resolver.apply(e.getValue()))))\n+                : request.sendAndAwait();\n+\n+        manager\n+            .completeWorkItem(\n+                              workItem.getId(),\n+                              Collections\n+                                  .singletonMap(RESULT, resultHandler.apply(inputModel, response.bodyAsJsonObject())));\n+    }\n+\n+    @Override\n+    public void abortWorkItem(WorkItem workItem, WorkItemManager manager) {\n+        // rest item handler does not support abort\n+    }\n+\n+    //  package scoped to allow unit test\n+    static String resolvePathParams(String endPoint, Map<String, Object> parameters, UnaryOperator<Object> resolver) {\n+        Set<String> toRemove = new HashSet<>();\n+        int start = endPoint.indexOf('{');", "originalCommit": "ccec804cd4dad036294f0d22d14420c3ff2bbc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NzczMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492267731", "bodyText": "This is code is not SW specific. This code is replacing parameters in the endpoint. JAX-RS convention is to include the path parameters to be replaced between {} (this is not related at all with json path, json path details are  handled by json specific class JsonPathResolver)\nThis behaviour applies both for POJO/Json parameters, both for BPMN/SW.\nThe code is not assuming POJO/Json, but it is relying in whatever is passed in the parameters of the workitem (concrete value, field name resolver, json path resolver). The point is that the handler delegates the resolution of the paramter value in the objects that are generated by the parser.", "author": "fjtirado", "createdAt": "2020-09-21T18:37:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MjU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM1OTE4MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492359181", "bodyText": "Ok. There are things missing here like accept headers, read timeouts, content type etc etc. Also expecting a hard-coded password in the workflow markup is something noone is going to really use as its pretty much only for demos I assume.\nI hardly think that even for a demo anyone out there that still uses hard-coded passwords in their apps is even thinking about moving to a serverless architectures. wdyt?", "author": "tsurdilo", "createdAt": "2020-09-21T21:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MjU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUzODc5MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492538791", "bodyText": "RestTaskHadled needs evolution (as the SW flow ;)). I think at this stage we should care about the contract (aka how the serverles parser fills the work node item)\nContent type is assumed to be json (is going to be different in any case?)\nHeaders can be specified as a parameter of the workitem (as method, user and password)\nI agree that password for basic authentication needs to be at least encrypted (which encryption?)", "author": "fjtirado", "createdAt": "2020-09-22T07:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MjU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY4NDgwMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492684802", "bodyText": "Security constraints should be handled by injected configuration properties, please see: https://docs.google.com/document/d/1GgAEAAoiBWsQ3zDKsW_w_Uml4cg5C5dnG6tlGQZlY0g/edit#heading=h.9qnfgrgjxwzl", "author": "ricardozanini", "createdAt": "2020-09-22T12:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MjU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY4NTY1NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492685654", "bodyText": "There's a JIRA for that: https://issues.redhat.com/browse/KOGITO-3160", "author": "ricardozanini", "createdAt": "2020-09-22T12:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MjU2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "1960b6ff25ca54dfa8350c88f9cf2deedf808416", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\nindex 654d5259b1..bab81025ad 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\n\n@@ -74,34 +74,35 @@ public class RestTaskHandler implements WorkItemHandler {\n     public void executeWorkItem(WorkItem workItem, WorkItemManager manager) {\n         // retrieving parameters\n         Map<String, Object> parameters = new HashMap<>(workItem.getParameters());\n-        String endPoint = (String) getParam(parameters, ENDPOINT);\n-        String method = (String) getParam(parameters, METHOD);\n-        Object inputModel = getParam(parameters, PARAMETER);\n+        String endPoint = getParam(parameters, ENDPOINT, String.class);\n+        HttpMethod method = HttpMethod.valueOf(getParam(parameters, METHOD, String.class).toUpperCase());\n+        Object inputModel = getParam(parameters, PARAMETER, Object.class);\n         String user = (String) parameters.remove(USER);\n         String password = (String) parameters.remove(PASSWORD);\n-        @SuppressWarnings(\"unchecked\")\n-        BiFunction<Object, JsonObject, Object> resultHandler =\n-                (BiFunction<Object, JsonObject, Object>) getParam(parameters, RESULT_HANDLER);\n-        // executing request\n+        BiFunction<Object, JsonObject, Object> resultHandler = getParam(parameters, RESULT_HANDLER, BiFunction.class);\n+        // create request\n         UnaryOperator<Object> resolver = new RestUnaryOperator(inputModel);\n         endPoint = resolvePathParams(endPoint, parameters, resolver);\n         URI uri = URI.create(endPoint);\n-        HttpRequest<Buffer> request = client\n-            .request(HttpMethod.valueOf(method.toUpperCase()), uri.getPort(), uri.getHost(), uri.getPath());\n-\n+        HttpRequest<Buffer> request = client.request(method, uri.getPort(), uri.getHost(), uri.getPath());\n         if (user != null && !user.trim().isEmpty() && password != null && !password.trim().isEmpty()) {\n             request.basicAuthentication(user, password);\n         }\n-        HttpResponse<Buffer> response = method.equalsIgnoreCase(\"POST\") || method.equalsIgnoreCase(\"PUT\")\n-                ? request\n-                    .sendJsonAndAwait(\n-                                      parameters\n-                                          .entrySet()\n-                                          .stream()\n-                                          .collect(\n-                                                   Collectors\n-                                                       .toMap(Entry::getKey, e -> resolver.apply(e.getValue()))))\n-                : request.sendAndAwait();\n+        // execute request\n+        HttpResponse<Buffer> response;\n+        if (method == HttpMethod.POST || method == HttpMethod.PUT) {\n+            // if parameters is empty at this stage, assume post content is the whole input model\n+            // if not, build a map from parameters remaining\n+            Object body = parameters.isEmpty() ? inputModel : parameters\n+                .entrySet()\n+                .stream()\n+                .collect(\n+                         Collectors\n+                             .toMap(Entry::getKey, e -> resolver.apply(e.getValue())));\n+            response = request.sendJsonAndAwait(body);\n+        } else {\n+            response = request.sendAndAwait();\n+        }\n \n         manager\n             .completeWorkItem(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1NDAzMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492254031", "bodyText": "Wonder since this defines workitem we can have a generic getWorkitemNode(....) method that can handle any future workitems that we might expose in kogito like this one.", "author": "tsurdilo", "createdAt": "2020-09-21T18:12:32Z", "path": "jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/ServerlessWorkflowFactory.java", "diffHunk": "@@ -322,6 +340,37 @@ public WorkItemNode camelRouteServiceNode(long id, String name, Function functio\n \n         return workItemNode;\n     }\n+    \n+    public Node restServiceNode(long id,", "originalCommit": "ccec804cd4dad036294f0d22d14420c3ff2bbc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2Nzk5MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492267990", "bodyText": "I think parameters will be different depending on the work item type, probably some of this code can be moved to a common method, but most parameters names will differ.", "author": "fjtirado", "createdAt": "2020-09-21T18:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1NDAzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4ca0d221e4446e24338ffbd70114290cb9fee2b0", "chunk": "diff --git a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/ServerlessWorkflowFactory.java b/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/ServerlessWorkflowFactory.java\nindex e41e26a13d..14f9b5f169 100644\n--- a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/ServerlessWorkflowFactory.java\n+++ b/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/ServerlessWorkflowFactory.java\n\n@@ -348,15 +348,15 @@ public class ServerlessWorkflowFactory {\n         WorkItemNode workItemNode = new WorkItemNode();\n         workItemNode.setId(id);\n         workItemNode.setName(function.getName());\n-        workItemNode.setMetaData(\"Type\", RestTaskHandler.REST_TASK_TYPE);\n+        workItemNode.setMetaData(\"Type\", RestWorkItemHandler.REST_TASK_TYPE);\n \n         Work work = new WorkImpl();\n         workItemNode.setWork(work);\n-        work.setName(RestTaskHandler.REST_TASK_TYPE);\n-        work.setParameter(RestTaskHandler.ENDPOINT, function.getResource());\n-        work.setParameter(RestTaskHandler.METHOD, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestTaskHandler.METHOD, workflowAppContext));\n-        work.setParameter(RestTaskHandler.USER, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestTaskHandler.USER, workflowAppContext));\n-        work.setParameter(RestTaskHandler.PASSWORD, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestTaskHandler.PASSWORD, workflowAppContext));\n+        work.setName(RestWorkItemHandler.REST_TASK_TYPE);\n+        work.setParameter(RestWorkItemHandler.ENDPOINT, function.getResource());\n+        work.setParameter(RestWorkItemHandler.METHOD, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestWorkItemHandler.METHOD, workflowAppContext));\n+        work.setParameter(RestWorkItemHandler.USER, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestWorkItemHandler.USER, workflowAppContext));\n+        work.setParameter(RestWorkItemHandler.PASSWORD, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestWorkItemHandler.PASSWORD, workflowAppContext));\n         \n         if (functionRef.getParameters() != null) {\n             for (Entry<String, String> param : functionRef.getParameters().entrySet()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1NDIzNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492254235", "bodyText": "Yeah, it can also be custom JSON data.", "author": "tsurdilo", "createdAt": "2020-09-21T18:12:53Z", "path": "jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/ServerlessWorkflowFactory.java", "diffHunk": "@@ -322,6 +340,37 @@ public WorkItemNode camelRouteServiceNode(long id, String name, Function functio\n \n         return workItemNode;\n     }\n+    \n+    public Node restServiceNode(long id,\n+                                FunctionRef functionRef,\n+                                Function function,\n+                                NodeContainer nodeContainer) {\n+        WorkItemNode workItemNode = new WorkItemNode();\n+        workItemNode.setId(id);\n+        workItemNode.setName(function.getName());\n+        workItemNode.setMetaData(\"Type\", RestTaskHandler.REST_TASK_TYPE);\n+\n+        Work work = new WorkImpl();\n+        workItemNode.setWork(work);\n+        work.setName(RestTaskHandler.REST_TASK_TYPE);\n+        work.setParameter(RestTaskHandler.ENDPOINT, function.getResource());\n+        work.setParameter(RestTaskHandler.METHOD, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestTaskHandler.METHOD, workflowAppContext));\n+        work.setParameter(RestTaskHandler.USER, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestTaskHandler.USER, workflowAppContext));\n+        work.setParameter(RestTaskHandler.PASSWORD, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestTaskHandler.PASSWORD, workflowAppContext));\n+        \n+        if (functionRef.getParameters() != null) {\n+            for (Entry<String, String> param : functionRef.getParameters().entrySet()) {\n+                // assuming param value is json string path", "originalCommit": "ccec804cd4dad036294f0d22d14420c3ff2bbc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3MDA3Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492270076", "bodyText": "Yes, I added that comment to indicate that, when JSON pojo support is added to SW, a new Supplier that deals with POJO can be added here.\nThats the point of this parameter, through the Supplier (that generates a piece of code) the SW indirectly told the handler (wihtout having to change the handler code) how to resolve parameters (POJO or Json)", "author": "fjtirado", "createdAt": "2020-09-21T18:41:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1NDIzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "4ca0d221e4446e24338ffbd70114290cb9fee2b0", "chunk": "diff --git a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/ServerlessWorkflowFactory.java b/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/ServerlessWorkflowFactory.java\nindex e41e26a13d..14f9b5f169 100644\n--- a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/ServerlessWorkflowFactory.java\n+++ b/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/ServerlessWorkflowFactory.java\n\n@@ -348,15 +348,15 @@ public class ServerlessWorkflowFactory {\n         WorkItemNode workItemNode = new WorkItemNode();\n         workItemNode.setId(id);\n         workItemNode.setName(function.getName());\n-        workItemNode.setMetaData(\"Type\", RestTaskHandler.REST_TASK_TYPE);\n+        workItemNode.setMetaData(\"Type\", RestWorkItemHandler.REST_TASK_TYPE);\n \n         Work work = new WorkImpl();\n         workItemNode.setWork(work);\n-        work.setName(RestTaskHandler.REST_TASK_TYPE);\n-        work.setParameter(RestTaskHandler.ENDPOINT, function.getResource());\n-        work.setParameter(RestTaskHandler.METHOD, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestTaskHandler.METHOD, workflowAppContext));\n-        work.setParameter(RestTaskHandler.USER, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestTaskHandler.USER, workflowAppContext));\n-        work.setParameter(RestTaskHandler.PASSWORD, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestTaskHandler.PASSWORD, workflowAppContext));\n+        work.setName(RestWorkItemHandler.REST_TASK_TYPE);\n+        work.setParameter(RestWorkItemHandler.ENDPOINT, function.getResource());\n+        work.setParameter(RestWorkItemHandler.METHOD, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestWorkItemHandler.METHOD, workflowAppContext));\n+        work.setParameter(RestWorkItemHandler.USER, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestWorkItemHandler.USER, workflowAppContext));\n+        work.setParameter(RestWorkItemHandler.PASSWORD, ServerlessWorkflowUtils.resolveFunctionMetadata(function, RestWorkItemHandler.PASSWORD, workflowAppContext));\n         \n         if (functionRef.getParameters() != null) {\n             for (Entry<String, String> param : functionRef.getParameters().entrySet()) {\n"}}, {"oid": "f48b76065b32ace27450c79a4238f025861484bc", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f48b76065b32ace27450c79a4238f025861484bc", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-21T19:02:07Z", "type": "forcePushed"}, {"oid": "a6762f59a6f7b11c70416c2d4ee93351e21f39be", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a6762f59a6f7b11c70416c2d4ee93351e21f39be", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-21T19:19:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1MTU5NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492051594", "bodyText": "Can't the inputParameter be of type ObjectNode?\nMaybe add some nullchecks too?", "author": "ruromero", "createdAt": "2020-09-21T13:38:41Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.function.BiFunction;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+\n+public class JSonPathResultHandler implements BiFunction<Object, JsonNode, Object> {\n+    @Override\n+    public Object apply(Object inputParameter, JsonNode node) {\n+        ObjectNode result = (ObjectNode) inputParameter;", "originalCommit": "149cb9bd6dc6ae44e43785de5284c6dc9d9ae91f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0MDc1OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492540759", "bodyText": "Null check is already performed in the Handler (inputModel is taking from parameter, which a mandatory attribute)\nIf this class in being invoked is because SW fill ResultHander parameter and it did that because the Parameter object is an ObjectNode.", "author": "fjtirado", "createdAt": "2020-09-22T07:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1MTU5NA=="}], "type": "inlineReview", "revised_code": {"commit": "1ab33a6991ce2880eda5b5613c77e29cad2ddbae", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\nindex 078ad22dc7..ddeefede25 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\n\n@@ -14,24 +14,98 @@\n  */\n package org.jbpm.process.instance.impl.rest;\n \n-import java.util.Iterator;\n-import java.util.Map.Entry;\n import java.util.function.BiFunction;\n \n-import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n-public class JSonPathResultHandler implements BiFunction<Object, JsonNode, Object> {\n+public class JSonPathResultHandler implements BiFunction<Object, JsonObject, Object> {\n+    \n+    private static final Logger logger = LoggerFactory.getLogger(JSonPathResultHandler.class);\n+    \n     @Override\n-    public Object apply(Object inputParameter, JsonNode node) {\n-        ObjectNode result = (ObjectNode) inputParameter;\n-        Iterator<Entry<String, JsonNode>> fields = node.fields();\n-        while (fields.hasNext()) {\n-            Entry<String, JsonNode> field = fields.next();\n-            result.set(field.getKey(), field.getValue());\n-        }\n-        return result;\n+    public Object apply(Object inputParameter, JsonObject node) {\n+        return transform(node,(ObjectNode) inputParameter);\n+    }\n+    \n+    private ObjectNode transform (JsonObject src, ObjectNode target) {\n+        src.forEach(e -> setValue(target,e.getKey(),e.getValue()));\n+        return target;\n     }\n \n+    private void setValue(ObjectNode result, String key, Object value) {\n+        if (value instanceof Double) {\n+            result.put(key, (Double)value);\n+        }\n+        else if (value instanceof Float) {\n+            result.put(key, (Float)value);\n+        }\n+        else if (value instanceof Long) {\n+            result.put(key, (Long) value);\n+        }\n+        else if (value instanceof Integer) {\n+            result.put(key, (Integer) value);\n+        }\n+        else if (value instanceof Short) {\n+            result.put(key, (Short) value);\n+        }\n+        else if (value instanceof Boolean) {\n+            result.put(key, (Boolean) value);\n+        }\n+        else if (value instanceof String) {\n+            result.put(key, (String) value);\n+        }\n+        else if (value instanceof JsonObject) {\n+            result.set(key, transform((JsonObject)value, result.objectNode()));\n+        }\n+        else if (value instanceof JsonArray) {\n+            ArrayNode array = result.arrayNode();\n+            ((JsonArray)value).forEach(v -> addValue(array,v));\n+            result.set(key,array);\n+        }\n+        else {\n+            logger.warn(\"Unrecognized data type for object {} class {}\",value,value.getClass());\n+        }\n+    }\n+    \n+    \n+    private void addValue (ArrayNode result, Object value) {\n+        if (value instanceof Double) {\n+            result.add((Double)value);\n+        }\n+        else if (value instanceof Float) {\n+            result.add( (Float)value);\n+        }\n+        else if (value instanceof Long) {\n+            result.add( (Long) value);\n+        }\n+        else if (value instanceof Integer) {\n+            result.add( (Integer) value);\n+        }\n+        else if (value instanceof Short) {\n+            result.add( (Short) value);\n+        }\n+        else if (value instanceof Boolean) {\n+            result.add( (Boolean) value);\n+        }\n+        else if (value instanceof String) {\n+            result.add( (String) value);\n+        }\n+        else if (value instanceof JsonObject) {\n+            result.add(transform((JsonObject)value, result.objectNode()));\n+        }\n+        else if (value instanceof JsonArray) {\n+            ArrayNode array = result.arrayNode();\n+            ((JsonArray)value).forEach(v -> addValue(array,v));\n+            result.add(array);\n+        }\n+        else {\n+            logger.warn(\"Unrecognized data type for object {} class {}\",value,value.getClass());\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyODM1MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492228351", "bodyText": "Formatting looks odd, check the whole class.", "author": "ruromero", "createdAt": "2020-09-21T17:28:23Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.util.function.BiFunction;\n+\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JSonPathResultHandler implements BiFunction<Object, JsonObject, Object> {\n+    \n+    private static final Logger logger = LoggerFactory.getLogger(JSonPathResultHandler.class);\n+    \n+    @Override\n+    public Object apply(Object inputParameter, JsonObject node) {\n+        return transform(node,(ObjectNode) inputParameter);\n+    }\n+    \n+    private ObjectNode transform (JsonObject src, ObjectNode target) {\n+        src.forEach(e -> setValue(target,e.getKey(),e.getValue()));\n+        return target;\n+    }\n+\n+    private void setValue(ObjectNode result, String key, Object value) {\n+        if (value instanceof Double) {\n+            result.put(key, (Double)value);\n+        }\n+        else if (value instanceof Float) {\n+            result.put(key, (Float)value);\n+        }\n+        else if (value instanceof Long) {\n+            result.put(key, (Long) value);\n+        }\n+        else if (value instanceof Integer) {\n+            result.put(key, (Integer) value);\n+        }\n+        else if (value instanceof Short) {\n+            result.put(key, (Short) value);\n+        }\n+        else if (value instanceof Boolean) {\n+            result.put(key, (Boolean) value);\n+        }\n+        else if (value instanceof String) {\n+            result.put(key, (String) value);\n+        }\n+        else if (value instanceof JsonObject) {\n+            result.set(key, transform((JsonObject)value, result.objectNode()));\n+        }\n+        else if (value instanceof JsonArray) {\n+            ArrayNode array = result.arrayNode();\n+            ((JsonArray)value).forEach(v -> addValue(array,v));\n+            result.set(key,array);\n+        }\n+        else {\n+            logger.warn(\"Unrecognized data type for object {} class {}\",value,value.getClass());\n+        }\n+    }\n+    \n+    \n+    private void addValue (ArrayNode result, Object value) {", "originalCommit": "ccec804cd4dad036294f0d22d14420c3ff2bbc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0MTIxMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492541213", "bodyText": "Thanks, I have the formatter disable by default", "author": "fjtirado", "createdAt": "2020-09-22T07:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyODM1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "1960b6ff25ca54dfa8350c88f9cf2deedf808416", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\nindex ddeefede25..4d725d4aea 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\n\n@@ -23,89 +23,69 @@ import io.vertx.core.json.JsonObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-\n public class JSonPathResultHandler implements BiFunction<Object, JsonObject, Object> {\n-    \n+\n     private static final Logger logger = LoggerFactory.getLogger(JSonPathResultHandler.class);\n-    \n+\n     @Override\n     public Object apply(Object inputParameter, JsonObject node) {\n-        return transform(node,(ObjectNode) inputParameter);\n+        return transform(node, (ObjectNode) inputParameter);\n     }\n-    \n-    private ObjectNode transform (JsonObject src, ObjectNode target) {\n-        src.forEach(e -> setValue(target,e.getKey(),e.getValue()));\n+\n+    private ObjectNode transform(JsonObject src, ObjectNode target) {\n+        src.forEach(e -> setValue(target, e.getKey(), e.getValue()));\n         return target;\n     }\n \n     private void setValue(ObjectNode result, String key, Object value) {\n         if (value instanceof Double) {\n-            result.put(key, (Double)value);\n-        }\n-        else if (value instanceof Float) {\n-            result.put(key, (Float)value);\n-        }\n-        else if (value instanceof Long) {\n+            result.put(key, (Double) value);\n+        } else if (value instanceof Float) {\n+            result.put(key, (Float) value);\n+        } else if (value instanceof Long) {\n             result.put(key, (Long) value);\n-        }\n-        else if (value instanceof Integer) {\n+        } else if (value instanceof Integer) {\n             result.put(key, (Integer) value);\n-        }\n-        else if (value instanceof Short) {\n+        } else if (value instanceof Short) {\n             result.put(key, (Short) value);\n-        }\n-        else if (value instanceof Boolean) {\n+        } else if (value instanceof Boolean) {\n             result.put(key, (Boolean) value);\n-        }\n-        else if (value instanceof String) {\n+        } else if (value instanceof String) {\n             result.put(key, (String) value);\n-        }\n-        else if (value instanceof JsonObject) {\n-            result.set(key, transform((JsonObject)value, result.objectNode()));\n-        }\n-        else if (value instanceof JsonArray) {\n+        } else if (value instanceof JsonObject) {\n+            result.set(key, transform((JsonObject) value, result.objectNode()));\n+        } else if (value instanceof JsonArray) {\n             ArrayNode array = result.arrayNode();\n-            ((JsonArray)value).forEach(v -> addValue(array,v));\n-            result.set(key,array);\n-        }\n-        else {\n-            logger.warn(\"Unrecognized data type for object {} class {}\",value,value.getClass());\n+            ((JsonArray) value).forEach(v -> addValue(array, v));\n+            result.set(key, array);\n+        } else {\n+            logger.warn(\"Unrecognized data type for object {} class {}\", value, value.getClass());\n         }\n     }\n-    \n-    \n-    private void addValue (ArrayNode result, Object value) {\n+\n+    private void addValue(ArrayNode result, Object value) {\n         if (value instanceof Double) {\n-            result.add((Double)value);\n-        }\n-        else if (value instanceof Float) {\n-            result.add( (Float)value);\n-        }\n-        else if (value instanceof Long) {\n-            result.add( (Long) value);\n-        }\n-        else if (value instanceof Integer) {\n-            result.add( (Integer) value);\n-        }\n-        else if (value instanceof Short) {\n-            result.add( (Short) value);\n-        }\n-        else if (value instanceof Boolean) {\n-            result.add( (Boolean) value);\n-        }\n-        else if (value instanceof String) {\n-            result.add( (String) value);\n-        }\n-        else if (value instanceof JsonObject) {\n-            result.add(transform((JsonObject)value, result.objectNode()));\n-        }\n-        else if (value instanceof JsonArray) {\n+            result.add((Double) value);\n+        } else if (value instanceof Float) {\n+            result.add((Float) value);\n+        } else if (value instanceof Long) {\n+            result.add((Long) value);\n+        } else if (value instanceof Integer) {\n+            result.add((Integer) value);\n+        } else if (value instanceof Short) {\n+            result.add((Short) value);\n+        } else if (value instanceof Boolean) {\n+            result.add((Boolean) value);\n+        } else if (value instanceof String) {\n+            result.add((String) value);\n+        } else if (value instanceof JsonObject) {\n+            result.add(transform((JsonObject) value, result.objectNode()));\n+        } else if (value instanceof JsonArray) {\n             ArrayNode array = result.arrayNode();\n-            ((JsonArray)value).forEach(v -> addValue(array,v));\n+            ((JsonArray) value).forEach(v -> addValue(array, v));\n             result.add(array);\n-        }\n-        else {\n-            logger.warn(\"Unrecognized data type for object {} class {}\",value,value.getClass());\n+        } else {\n+            logger.warn(\"Unrecognized data type for object {} class {}\", value, value.getClass());\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIzOTAzNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492239035", "bodyText": "Maybe I missed something but why don't you just use the ObjectMapper to go from a String to an ObjectNode? Something like this:\nObjectNode node = (ObjectNode) objectMapper.readTree(json.encode());\n\nAlthough the readTree value returns a JsonNode it is always an ObjectNode instance (subclass)", "author": "ruromero", "createdAt": "2020-09-21T17:46:12Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.util.function.BiFunction;\n+\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class JSonPathResultHandler implements BiFunction<Object, JsonObject, Object> {\n+    \n+    private static final Logger logger = LoggerFactory.getLogger(JSonPathResultHandler.class);\n+    \n+    @Override\n+    public Object apply(Object inputParameter, JsonObject node) {\n+        return transform(node,(ObjectNode) inputParameter);\n+    }\n+    \n+    private ObjectNode transform (JsonObject src, ObjectNode target) {", "originalCommit": "ccec804cd4dad036294f0d22d14420c3ff2bbc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0MjA5Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492542093", "bodyText": "Since I have to merge the input with the response, I prefer to avoid encode/decode step and perform the merge programatically", "author": "fjtirado", "createdAt": "2020-09-22T07:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIzOTAzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "1960b6ff25ca54dfa8350c88f9cf2deedf808416", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\nindex ddeefede25..4d725d4aea 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JSonPathResultHandler.java\n\n@@ -23,89 +23,69 @@ import io.vertx.core.json.JsonObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-\n public class JSonPathResultHandler implements BiFunction<Object, JsonObject, Object> {\n-    \n+\n     private static final Logger logger = LoggerFactory.getLogger(JSonPathResultHandler.class);\n-    \n+\n     @Override\n     public Object apply(Object inputParameter, JsonObject node) {\n-        return transform(node,(ObjectNode) inputParameter);\n+        return transform(node, (ObjectNode) inputParameter);\n     }\n-    \n-    private ObjectNode transform (JsonObject src, ObjectNode target) {\n-        src.forEach(e -> setValue(target,e.getKey(),e.getValue()));\n+\n+    private ObjectNode transform(JsonObject src, ObjectNode target) {\n+        src.forEach(e -> setValue(target, e.getKey(), e.getValue()));\n         return target;\n     }\n \n     private void setValue(ObjectNode result, String key, Object value) {\n         if (value instanceof Double) {\n-            result.put(key, (Double)value);\n-        }\n-        else if (value instanceof Float) {\n-            result.put(key, (Float)value);\n-        }\n-        else if (value instanceof Long) {\n+            result.put(key, (Double) value);\n+        } else if (value instanceof Float) {\n+            result.put(key, (Float) value);\n+        } else if (value instanceof Long) {\n             result.put(key, (Long) value);\n-        }\n-        else if (value instanceof Integer) {\n+        } else if (value instanceof Integer) {\n             result.put(key, (Integer) value);\n-        }\n-        else if (value instanceof Short) {\n+        } else if (value instanceof Short) {\n             result.put(key, (Short) value);\n-        }\n-        else if (value instanceof Boolean) {\n+        } else if (value instanceof Boolean) {\n             result.put(key, (Boolean) value);\n-        }\n-        else if (value instanceof String) {\n+        } else if (value instanceof String) {\n             result.put(key, (String) value);\n-        }\n-        else if (value instanceof JsonObject) {\n-            result.set(key, transform((JsonObject)value, result.objectNode()));\n-        }\n-        else if (value instanceof JsonArray) {\n+        } else if (value instanceof JsonObject) {\n+            result.set(key, transform((JsonObject) value, result.objectNode()));\n+        } else if (value instanceof JsonArray) {\n             ArrayNode array = result.arrayNode();\n-            ((JsonArray)value).forEach(v -> addValue(array,v));\n-            result.set(key,array);\n-        }\n-        else {\n-            logger.warn(\"Unrecognized data type for object {} class {}\",value,value.getClass());\n+            ((JsonArray) value).forEach(v -> addValue(array, v));\n+            result.set(key, array);\n+        } else {\n+            logger.warn(\"Unrecognized data type for object {} class {}\", value, value.getClass());\n         }\n     }\n-    \n-    \n-    private void addValue (ArrayNode result, Object value) {\n+\n+    private void addValue(ArrayNode result, Object value) {\n         if (value instanceof Double) {\n-            result.add((Double)value);\n-        }\n-        else if (value instanceof Float) {\n-            result.add( (Float)value);\n-        }\n-        else if (value instanceof Long) {\n-            result.add( (Long) value);\n-        }\n-        else if (value instanceof Integer) {\n-            result.add( (Integer) value);\n-        }\n-        else if (value instanceof Short) {\n-            result.add( (Short) value);\n-        }\n-        else if (value instanceof Boolean) {\n-            result.add( (Boolean) value);\n-        }\n-        else if (value instanceof String) {\n-            result.add( (String) value);\n-        }\n-        else if (value instanceof JsonObject) {\n-            result.add(transform((JsonObject)value, result.objectNode()));\n-        }\n-        else if (value instanceof JsonArray) {\n+            result.add((Double) value);\n+        } else if (value instanceof Float) {\n+            result.add((Float) value);\n+        } else if (value instanceof Long) {\n+            result.add((Long) value);\n+        } else if (value instanceof Integer) {\n+            result.add((Integer) value);\n+        } else if (value instanceof Short) {\n+            result.add((Short) value);\n+        } else if (value instanceof Boolean) {\n+            result.add((Boolean) value);\n+        } else if (value instanceof String) {\n+            result.add((String) value);\n+        } else if (value instanceof JsonObject) {\n+            result.add(transform((JsonObject) value, result.objectNode()));\n+        } else if (value instanceof JsonArray) {\n             ArrayNode array = result.arrayNode();\n-            ((JsonArray)value).forEach(v -> addValue(array,v));\n+            ((JsonArray) value).forEach(v -> addValue(array, v));\n             result.add(array);\n-        }\n-        else {\n-            logger.warn(\"Unrecognized data type for object {} class {}\",value,value.getClass());\n+        } else {\n+            logger.warn(\"Unrecognized data type for object {} class {}\", value, value.getClass());\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0MDAxMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492240012", "bodyText": "I prefer to have such annotations outside of the method, to favour readability.", "author": "ruromero", "createdAt": "2020-09-21T17:47:48Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.kie.api.runtime.process.WorkItemHandler;\n+import org.kie.api.runtime.process.WorkItemManager;\n+\n+public class RestTaskHandler implements WorkItemHandler {\n+\n+    public static final String REST_TASK_TYPE = \"Rest Task\";\n+    public static final String ENDPOINT = \"endpoint\";\n+    public static final String METHOD = \"method\";\n+    public static final String PARAMETER = \"Parameter\";\n+    public static final String RESULT = \"Result\";\n+    public static final String RESULT_HANDLER = \"ResultHandler\";\n+    public static final String USER = \"User\";\n+    public static final String PASSWORD = \"Password\";\n+\n+    // package scoped to allow unit test\n+    static class RestUnaryOperator implements UnaryOperator<Object> {\n+\n+        private Object inputModel;\n+\n+        public RestUnaryOperator(Object inputModel) {\n+            this.inputModel = inputModel;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public Object apply(Object value) {\n+            return value instanceof Function\n+                    ? ((Function<Object, Object>) value).apply(inputModel) : value;\n+        }\n+    }\n+\n+    private WebClient client;\n+\n+    public RestTaskHandler(WebClient client) {\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public void executeWorkItem(WorkItem workItem, WorkItemManager manager) {\n+        // retrieving parameters\n+        Map<String, Object> parameters = new HashMap<>(workItem.getParameters());\n+        String endPoint = (String) getParam(parameters, ENDPOINT);\n+        String method = (String) getParam(parameters, METHOD);\n+        Object inputModel = getParam(parameters, PARAMETER);\n+        String user = (String) parameters.remove(USER);\n+        String password = (String) parameters.remove(PASSWORD);\n+        @SuppressWarnings(\"unchecked\")", "originalCommit": "ccec804cd4dad036294f0d22d14420c3ff2bbc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0MjUxOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492542519", "bodyText": "yes, but as a generic rule the annotation should in lowest possible scope to prevent other unchecked casting to be unnoticed, in any case, I think that here an instance of will be desirable, so editing it", "author": "fjtirado", "createdAt": "2020-09-22T08:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0MDAxMg=="}], "type": "inlineReview", "revised_code": {"commit": "1960b6ff25ca54dfa8350c88f9cf2deedf808416", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\nindex 654d5259b1..bab81025ad 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\n\n@@ -74,34 +74,35 @@ public class RestTaskHandler implements WorkItemHandler {\n     public void executeWorkItem(WorkItem workItem, WorkItemManager manager) {\n         // retrieving parameters\n         Map<String, Object> parameters = new HashMap<>(workItem.getParameters());\n-        String endPoint = (String) getParam(parameters, ENDPOINT);\n-        String method = (String) getParam(parameters, METHOD);\n-        Object inputModel = getParam(parameters, PARAMETER);\n+        String endPoint = getParam(parameters, ENDPOINT, String.class);\n+        HttpMethod method = HttpMethod.valueOf(getParam(parameters, METHOD, String.class).toUpperCase());\n+        Object inputModel = getParam(parameters, PARAMETER, Object.class);\n         String user = (String) parameters.remove(USER);\n         String password = (String) parameters.remove(PASSWORD);\n-        @SuppressWarnings(\"unchecked\")\n-        BiFunction<Object, JsonObject, Object> resultHandler =\n-                (BiFunction<Object, JsonObject, Object>) getParam(parameters, RESULT_HANDLER);\n-        // executing request\n+        BiFunction<Object, JsonObject, Object> resultHandler = getParam(parameters, RESULT_HANDLER, BiFunction.class);\n+        // create request\n         UnaryOperator<Object> resolver = new RestUnaryOperator(inputModel);\n         endPoint = resolvePathParams(endPoint, parameters, resolver);\n         URI uri = URI.create(endPoint);\n-        HttpRequest<Buffer> request = client\n-            .request(HttpMethod.valueOf(method.toUpperCase()), uri.getPort(), uri.getHost(), uri.getPath());\n-\n+        HttpRequest<Buffer> request = client.request(method, uri.getPort(), uri.getHost(), uri.getPath());\n         if (user != null && !user.trim().isEmpty() && password != null && !password.trim().isEmpty()) {\n             request.basicAuthentication(user, password);\n         }\n-        HttpResponse<Buffer> response = method.equalsIgnoreCase(\"POST\") || method.equalsIgnoreCase(\"PUT\")\n-                ? request\n-                    .sendJsonAndAwait(\n-                                      parameters\n-                                          .entrySet()\n-                                          .stream()\n-                                          .collect(\n-                                                   Collectors\n-                                                       .toMap(Entry::getKey, e -> resolver.apply(e.getValue()))))\n-                : request.sendAndAwait();\n+        // execute request\n+        HttpResponse<Buffer> response;\n+        if (method == HttpMethod.POST || method == HttpMethod.PUT) {\n+            // if parameters is empty at this stage, assume post content is the whole input model\n+            // if not, build a map from parameters remaining\n+            Object body = parameters.isEmpty() ? inputModel : parameters\n+                .entrySet()\n+                .stream()\n+                .collect(\n+                         Collectors\n+                             .toMap(Entry::getKey, e -> resolver.apply(e.getValue())));\n+            response = request.sendJsonAndAwait(body);\n+        } else {\n+            response = request.sendAndAwait();\n+        }\n \n         manager\n             .completeWorkItem(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0MDM2NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492240364", "bodyText": "Use constants", "author": "ruromero", "createdAt": "2020-09-21T17:48:33Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.kie.api.runtime.process.WorkItemHandler;\n+import org.kie.api.runtime.process.WorkItemManager;\n+\n+public class RestTaskHandler implements WorkItemHandler {\n+\n+    public static final String REST_TASK_TYPE = \"Rest Task\";\n+    public static final String ENDPOINT = \"endpoint\";\n+    public static final String METHOD = \"method\";\n+    public static final String PARAMETER = \"Parameter\";\n+    public static final String RESULT = \"Result\";\n+    public static final String RESULT_HANDLER = \"ResultHandler\";\n+    public static final String USER = \"User\";\n+    public static final String PASSWORD = \"Password\";\n+\n+    // package scoped to allow unit test\n+    static class RestUnaryOperator implements UnaryOperator<Object> {\n+\n+        private Object inputModel;\n+\n+        public RestUnaryOperator(Object inputModel) {\n+            this.inputModel = inputModel;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public Object apply(Object value) {\n+            return value instanceof Function\n+                    ? ((Function<Object, Object>) value).apply(inputModel) : value;\n+        }\n+    }\n+\n+    private WebClient client;\n+\n+    public RestTaskHandler(WebClient client) {\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public void executeWorkItem(WorkItem workItem, WorkItemManager manager) {\n+        // retrieving parameters\n+        Map<String, Object> parameters = new HashMap<>(workItem.getParameters());\n+        String endPoint = (String) getParam(parameters, ENDPOINT);\n+        String method = (String) getParam(parameters, METHOD);\n+        Object inputModel = getParam(parameters, PARAMETER);\n+        String user = (String) parameters.remove(USER);\n+        String password = (String) parameters.remove(PASSWORD);\n+        @SuppressWarnings(\"unchecked\")\n+        BiFunction<Object, JsonObject, Object> resultHandler =\n+                (BiFunction<Object, JsonObject, Object>) getParam(parameters, RESULT_HANDLER);\n+        // executing request\n+        UnaryOperator<Object> resolver = new RestUnaryOperator(inputModel);\n+        endPoint = resolvePathParams(endPoint, parameters, resolver);\n+        URI uri = URI.create(endPoint);\n+        HttpRequest<Buffer> request = client\n+            .request(HttpMethod.valueOf(method.toUpperCase()), uri.getPort(), uri.getHost(), uri.getPath());\n+\n+        if (user != null && !user.trim().isEmpty() && password != null && !password.trim().isEmpty()) {\n+            request.basicAuthentication(user, password);\n+        }\n+        HttpResponse<Buffer> response = method.equalsIgnoreCase(\"POST\") || method.equalsIgnoreCase(\"PUT\")", "originalCommit": "ccec804cd4dad036294f0d22d14420c3ff2bbc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0MjgwOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492542808", "bodyText": "sure, thanks", "author": "fjtirado", "createdAt": "2020-09-22T08:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0MDM2NA=="}], "type": "inlineReview", "revised_code": {"commit": "1960b6ff25ca54dfa8350c88f9cf2deedf808416", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\nindex 654d5259b1..bab81025ad 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\n\n@@ -74,34 +74,35 @@ public class RestTaskHandler implements WorkItemHandler {\n     public void executeWorkItem(WorkItem workItem, WorkItemManager manager) {\n         // retrieving parameters\n         Map<String, Object> parameters = new HashMap<>(workItem.getParameters());\n-        String endPoint = (String) getParam(parameters, ENDPOINT);\n-        String method = (String) getParam(parameters, METHOD);\n-        Object inputModel = getParam(parameters, PARAMETER);\n+        String endPoint = getParam(parameters, ENDPOINT, String.class);\n+        HttpMethod method = HttpMethod.valueOf(getParam(parameters, METHOD, String.class).toUpperCase());\n+        Object inputModel = getParam(parameters, PARAMETER, Object.class);\n         String user = (String) parameters.remove(USER);\n         String password = (String) parameters.remove(PASSWORD);\n-        @SuppressWarnings(\"unchecked\")\n-        BiFunction<Object, JsonObject, Object> resultHandler =\n-                (BiFunction<Object, JsonObject, Object>) getParam(parameters, RESULT_HANDLER);\n-        // executing request\n+        BiFunction<Object, JsonObject, Object> resultHandler = getParam(parameters, RESULT_HANDLER, BiFunction.class);\n+        // create request\n         UnaryOperator<Object> resolver = new RestUnaryOperator(inputModel);\n         endPoint = resolvePathParams(endPoint, parameters, resolver);\n         URI uri = URI.create(endPoint);\n-        HttpRequest<Buffer> request = client\n-            .request(HttpMethod.valueOf(method.toUpperCase()), uri.getPort(), uri.getHost(), uri.getPath());\n-\n+        HttpRequest<Buffer> request = client.request(method, uri.getPort(), uri.getHost(), uri.getPath());\n         if (user != null && !user.trim().isEmpty() && password != null && !password.trim().isEmpty()) {\n             request.basicAuthentication(user, password);\n         }\n-        HttpResponse<Buffer> response = method.equalsIgnoreCase(\"POST\") || method.equalsIgnoreCase(\"PUT\")\n-                ? request\n-                    .sendJsonAndAwait(\n-                                      parameters\n-                                          .entrySet()\n-                                          .stream()\n-                                          .collect(\n-                                                   Collectors\n-                                                       .toMap(Entry::getKey, e -> resolver.apply(e.getValue()))))\n-                : request.sendAndAwait();\n+        // execute request\n+        HttpResponse<Buffer> response;\n+        if (method == HttpMethod.POST || method == HttpMethod.PUT) {\n+            // if parameters is empty at this stage, assume post content is the whole input model\n+            // if not, build a map from parameters remaining\n+            Object body = parameters.isEmpty() ? inputModel : parameters\n+                .entrySet()\n+                .stream()\n+                .collect(\n+                         Collectors\n+                             .toMap(Entry::getKey, e -> resolver.apply(e.getValue())));\n+            response = request.sendJsonAndAwait(body);\n+        } else {\n+            response = request.sendAndAwait();\n+        }\n \n         manager\n             .completeWorkItem(\n"}}, {"oid": "1960b6ff25ca54dfa8350c88f9cf2deedf808416", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1960b6ff25ca54dfa8350c88f9cf2deedf808416", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-22T08:11:41Z", "type": "forcePushed"}, {"oid": "1f26da55b84060eda620e229901b8ccb16b467e4", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1f26da55b84060eda620e229901b8ccb16b467e4", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-22T10:10:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY3NTQ1OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492675458", "bodyText": "Why is this generated programmatically instead of being a template?", "author": "evacchi", "createdAt": "2020-09-22T11:58:17Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.jbpm.compiler.canonical;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.Modifier;\n+import com.github.javaparser.ast.Modifier.Keyword;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.jbpm.process.instance.impl.rest.RestTaskHandler;\n+\n+public class RestTaskDescriptor {\n+\n+    private RestTaskDescriptor() {}\n+\n+    public static String getClassName(ProcessMetaData processMetadata) {", "originalCommit": "1f26da55b84060eda620e229901b8ccb16b467e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY4ODQ0Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492688443", "bodyText": "I asked myself the same thing.", "author": "ricardozanini", "createdAt": "2020-09-22T12:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY3NTQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc0NTQyNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492745425", "bodyText": "because ServiceTaskDescriptor is not using template either. I can use template, but the generated code is going to be the same", "author": "fjtirado", "createdAt": "2020-09-22T13:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY3NTQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc3OTAyOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492779028", "bodyText": "I'd prefer to move as much code as possible to templates, especially new code :)", "author": "evacchi", "createdAt": "2020-09-22T14:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY3NTQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNzk3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492827972", "bodyText": "yes, Ill move to template", "author": "fjtirado", "createdAt": "2020-09-22T15:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY3NTQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MzM2NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r492843365", "bodyText": "done", "author": "fjtirado", "createdAt": "2020-09-22T15:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY3NTQ1OA=="}], "type": "inlineReview", "revised_code": {"commit": "6847a950d09ab8de00ae875b955db12bb0ad513b", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java\nindex b279bbd557..641f115126 100644\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java\n\n@@ -16,18 +16,11 @@\n \n package org.jbpm.compiler.canonical;\n \n-import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n-import com.github.javaparser.ast.Modifier;\n-import com.github.javaparser.ast.Modifier.Keyword;\n import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n-import com.github.javaparser.ast.expr.MethodCallExpr;\n-import com.github.javaparser.ast.expr.NameExpr;\n-import com.github.javaparser.ast.expr.SimpleName;\n-import com.github.javaparser.ast.stmt.BlockStmt;\n-import io.vertx.mutiny.core.Vertx;\n-import io.vertx.mutiny.ext.web.client.WebClient;\n-import org.jbpm.process.instance.impl.rest.RestTaskHandler;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+\n+import static com.github.javaparser.StaticJavaParser.parse;\n \n public class RestTaskDescriptor {\n \n"}}, {"oid": "6847a950d09ab8de00ae875b955db12bb0ad513b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6847a950d09ab8de00ae875b955db12bb0ad513b", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-22T15:44:45Z", "type": "forcePushed"}, {"oid": "a02f120e8c651c1b750eed28fa306c3ff949d98d", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a02f120e8c651c1b750eed28fa306c3ff949d98d", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-22T16:15:33Z", "type": "forcePushed"}, {"oid": "5103d97a9fa239a3103e1e358da02cfb43ccd47a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/5103d97a9fa239a3103e1e358da02cfb43ccd47a", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-22T20:08:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEzNzI5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493137292", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Boolean asBoolean (Object value) {\n          \n          \n            \n                private Boolean asBoolean(Object value) {", "author": "cristianonicolai", "createdAt": "2020-09-23T01:48:14Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java", "diffHunk": "@@ -110,30 +117,43 @@ protected void addWorkItemParameters(Work work, BlockStmt body, String variableN\n             if(work.getParameterDefinition(entry.getKey()) != null) {\n                 paramType = work.getParameterDefinition(entry.getKey()).getType().getStringType();\n             }\n-            body.addStatement(getFactoryMethod(variableName, METHOD_WORK_PARAMETER, new StringLiteralExpr(entry.getKey()), getParameterExpr(paramType, entry.getValue().toString())));\n+            body.addStatement(getFactoryMethod(variableName, METHOD_WORK_PARAMETER, new StringLiteralExpr(entry.getKey()), getParameterExpr(paramType, entry.getValue())));\n         }\n     }\n+    \n+  \n \n-    private Expression getParameterExpr(String type, String value) {\n+    private Expression getParameterExpr(String type, Object value) {\n         ParamType pType = ParamType.fromString(type);\n         if (pType == null) {\n-            return new StringLiteralExpr(value);\n+            if (value instanceof Supplier) {\n+                return ((Supplier<Expression>)value).get();\n+            }\n+            else {\n+                return new StringLiteralExpr(value.toString());\n+            }\n+            \n         }\n         switch (pType) {\n             case BOOLEAN:\n-                return new BooleanLiteralExpr(Boolean.parseBoolean(value));\n+                return new BooleanLiteralExpr(asBoolean(value));\n             case FLOAT:\n                 return new MethodCallExpr()\n                         .setScope(new NameExpr(Float.class.getName()))\n                         .setName(\"parseFloat\")\n-                        .addArgument(new StringLiteralExpr(value));\n+                        .addArgument(new StringLiteralExpr(value.toString()));\n             case INTEGER:\n-                return new IntegerLiteralExpr(Integer.parseInt(value));\n+                return new IntegerLiteralExpr(asInteger(value));\n             default:\n-                return new StringLiteralExpr(value);\n+                return new StringLiteralExpr(value.toString());\n         }\n     }\n-\n-\n-\n+    \n+    private Boolean asBoolean (Object value) {", "originalCommit": "5103d97a9fa239a3103e1e358da02cfb43ccd47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzMyMTMyNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493321324", "bodyText": "WorkItemNodeVisitor changes has been formatted now", "author": "fjtirado", "createdAt": "2020-09-23T08:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEzNzI5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "07ceec69b278edac4db9caf5252849520db6a312", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\nindex 28ee2cbc6c..c5b968990a 100644\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\n\n@@ -127,33 +127,32 @@ public class WorkItemNodeVisitor<T extends WorkItemNode> extends AbstractNodeVis\n         ParamType pType = ParamType.fromString(type);\n         if (pType == null) {\n             if (value instanceof Supplier) {\n-                return ((Supplier<Expression>)value).get();\n-            }\n-            else {\n+                return ((Supplier<Expression>) value).get();\n+            } else {\n                 return new StringLiteralExpr(value.toString());\n             }\n-            \n+\n         }\n         switch (pType) {\n             case BOOLEAN:\n                 return new BooleanLiteralExpr(asBoolean(value));\n             case FLOAT:\n                 return new MethodCallExpr()\n-                        .setScope(new NameExpr(Float.class.getName()))\n-                        .setName(\"parseFloat\")\n-                        .addArgument(new StringLiteralExpr(value.toString()));\n+                    .setScope(new NameExpr(Float.class.getName()))\n+                    .setName(\"parseFloat\")\n+                    .addArgument(new StringLiteralExpr(value.toString()));\n             case INTEGER:\n                 return new IntegerLiteralExpr(asInteger(value));\n             default:\n                 return new StringLiteralExpr(value.toString());\n         }\n     }\n-    \n-    private Boolean asBoolean (Object value) {\n+\n+    private Boolean asBoolean(Object value) {\n         return value instanceof Boolean ? (Boolean) value : Boolean.parseBoolean(value.toString());\n     }\n-    \n-    private Integer asInteger (Object value) {\n+\n+    private Integer asInteger(Object value) {\n         return value instanceof Number ? ((Number) value).intValue() : Integer.parseInt(value.toString());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEzNzM4NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493137385", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Integer asInteger (Object value) {\n          \n          \n            \n                private Integer asInteger(Object value) {", "author": "cristianonicolai", "createdAt": "2020-09-23T01:48:23Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java", "diffHunk": "@@ -110,30 +117,43 @@ protected void addWorkItemParameters(Work work, BlockStmt body, String variableN\n             if(work.getParameterDefinition(entry.getKey()) != null) {\n                 paramType = work.getParameterDefinition(entry.getKey()).getType().getStringType();\n             }\n-            body.addStatement(getFactoryMethod(variableName, METHOD_WORK_PARAMETER, new StringLiteralExpr(entry.getKey()), getParameterExpr(paramType, entry.getValue().toString())));\n+            body.addStatement(getFactoryMethod(variableName, METHOD_WORK_PARAMETER, new StringLiteralExpr(entry.getKey()), getParameterExpr(paramType, entry.getValue())));\n         }\n     }\n+    \n+  \n \n-    private Expression getParameterExpr(String type, String value) {\n+    private Expression getParameterExpr(String type, Object value) {\n         ParamType pType = ParamType.fromString(type);\n         if (pType == null) {\n-            return new StringLiteralExpr(value);\n+            if (value instanceof Supplier) {\n+                return ((Supplier<Expression>)value).get();\n+            }\n+            else {\n+                return new StringLiteralExpr(value.toString());\n+            }\n+            \n         }\n         switch (pType) {\n             case BOOLEAN:\n-                return new BooleanLiteralExpr(Boolean.parseBoolean(value));\n+                return new BooleanLiteralExpr(asBoolean(value));\n             case FLOAT:\n                 return new MethodCallExpr()\n                         .setScope(new NameExpr(Float.class.getName()))\n                         .setName(\"parseFloat\")\n-                        .addArgument(new StringLiteralExpr(value));\n+                        .addArgument(new StringLiteralExpr(value.toString()));\n             case INTEGER:\n-                return new IntegerLiteralExpr(Integer.parseInt(value));\n+                return new IntegerLiteralExpr(asInteger(value));\n             default:\n-                return new StringLiteralExpr(value);\n+                return new StringLiteralExpr(value.toString());\n         }\n     }\n-\n-\n-\n+    \n+    private Boolean asBoolean (Object value) {\n+        return value instanceof Boolean ? (Boolean) value : Boolean.parseBoolean(value.toString());\n+    }\n+    \n+    private Integer asInteger (Object value) {", "originalCommit": "5103d97a9fa239a3103e1e358da02cfb43ccd47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzMyMTU0OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493321548", "bodyText": "formatted", "author": "fjtirado", "createdAt": "2020-09-23T08:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEzNzM4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "07ceec69b278edac4db9caf5252849520db6a312", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\nindex 28ee2cbc6c..c5b968990a 100644\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\n\n@@ -127,33 +127,32 @@ public class WorkItemNodeVisitor<T extends WorkItemNode> extends AbstractNodeVis\n         ParamType pType = ParamType.fromString(type);\n         if (pType == null) {\n             if (value instanceof Supplier) {\n-                return ((Supplier<Expression>)value).get();\n-            }\n-            else {\n+                return ((Supplier<Expression>) value).get();\n+            } else {\n                 return new StringLiteralExpr(value.toString());\n             }\n-            \n+\n         }\n         switch (pType) {\n             case BOOLEAN:\n                 return new BooleanLiteralExpr(asBoolean(value));\n             case FLOAT:\n                 return new MethodCallExpr()\n-                        .setScope(new NameExpr(Float.class.getName()))\n-                        .setName(\"parseFloat\")\n-                        .addArgument(new StringLiteralExpr(value.toString()));\n+                    .setScope(new NameExpr(Float.class.getName()))\n+                    .setName(\"parseFloat\")\n+                    .addArgument(new StringLiteralExpr(value.toString()));\n             case INTEGER:\n                 return new IntegerLiteralExpr(asInteger(value));\n             default:\n                 return new StringLiteralExpr(value.toString());\n         }\n     }\n-    \n-    private Boolean asBoolean (Object value) {\n+\n+    private Boolean asBoolean(Object value) {\n         return value instanceof Boolean ? (Boolean) value : Boolean.parseBoolean(value.toString());\n     }\n-    \n-    private Integer asInteger (Object value) {\n+\n+    private Integer asInteger(Object value) {\n         return value instanceof Number ? ((Number) value).intValue() : Integer.parseInt(value.toString());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MjA5OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493142098", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Object readValue (JsonNode node) {\n          \n          \n            \n                private Object readValue(JsonNode node) {", "author": "cristianonicolai", "createdAt": "2020-09-23T01:55:34Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JsonPathResolver.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.jayway.jsonpath.Configuration;\n+import com.jayway.jsonpath.JsonPath;\n+import com.jayway.jsonpath.spi.json.JacksonJsonNodeJsonProvider;\n+import com.jayway.jsonpath.spi.mapper.JacksonMappingProvider;\n+\n+/*TODO this class should be moved to a different module when available \n+ * together with jsonpath dependency*/\n+public class JsonPathResolver implements RestTaskParamResolver {\n+\n+    private static final Configuration jsonPathConfig = Configuration\n+        .builder()\n+        .mappingProvider(new JacksonMappingProvider())\n+        .jsonProvider(new JacksonJsonNodeJsonProvider())\n+        .build();\n+\n+    private String jsonPathExpr;\n+\n+    public JsonPathResolver(String jsonPathExpr) {\n+        this.jsonPathExpr = jsonPathExpr;\n+    }\n+\n+    @Override\n+    public Object apply(Object context) {\n+        JsonNode node = JsonPath\n+            .using(jsonPathConfig)\n+            .parse(context)\n+            .read(jsonPathExpr, JsonNode.class);\n+        return readValue(node);\n+    }\n+    \n+    private Object readValue (JsonNode node) {", "originalCommit": "5103d97a9fa239a3103e1e358da02cfb43ccd47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzMyMDQ4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493320486", "bodyText": "formatted", "author": "fjtirado", "createdAt": "2020-09-23T08:41:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MjA5OA=="}], "type": "inlineReview", "revised_code": {"commit": "07ceec69b278edac4db9caf5252849520db6a312", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JsonPathResolver.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JsonPathResolver.java\nindex b2ea317f0d..1df70e203f 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JsonPathResolver.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/JsonPathResolver.java\n\n@@ -49,8 +49,8 @@ public class JsonPathResolver implements RestTaskParamResolver {\n             .read(jsonPathExpr, JsonNode.class);\n         return readValue(node);\n     }\n-    \n-    private Object readValue (JsonNode node) {\n+\n+    private Object readValue(JsonNode node) {\n         switch (node.getNodeType()) {\n             case NUMBER:\n                 if (node.isInt()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDE0Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493144146", "bodyText": "to be honest, I dont think it is realistic to expect that a user name and password would be stored as the workitem paramenter, AKA bpmn model.", "author": "cristianonicolai", "createdAt": "2020-09-23T01:58:51Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.kie.api.runtime.process.WorkItemHandler;\n+import org.kie.api.runtime.process.WorkItemManager;\n+\n+public class RestTaskHandler implements WorkItemHandler {\n+\n+    public static final String REST_TASK_TYPE = \"Rest Task\";\n+    public static final String ENDPOINT = \"endpoint\";\n+    public static final String METHOD = \"method\";\n+    public static final String PARAMETER = \"Parameter\";\n+    public static final String RESULT = \"Result\";\n+    public static final String RESULT_HANDLER = \"ResultHandler\";\n+    public static final String USER = \"User\";\n+    public static final String PASSWORD = \"Password\";\n+\n+    // package scoped to allow unit test\n+    static class RestUnaryOperator implements UnaryOperator<Object> {\n+\n+        private Object inputModel;\n+\n+        public RestUnaryOperator(Object inputModel) {\n+            this.inputModel = inputModel;\n+        }\n+\n+        @Override\n+        public Object apply(Object value) {\n+            return value instanceof RestTaskParamResolver\n+                    ? ((RestTaskParamResolver) value).apply(inputModel) : value;\n+        }\n+    }\n+\n+    private WebClient client;\n+\n+    public RestTaskHandler(WebClient client) {\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public void executeWorkItem(WorkItem workItem, WorkItemManager manager) {\n+        // retrieving parameters\n+        Map<String, Object> parameters = new HashMap<>(workItem.getParameters());\n+        String endPoint = getParam(parameters, ENDPOINT, String.class);\n+        HttpMethod method = HttpMethod.valueOf(getParam(parameters, METHOD, String.class).toUpperCase());\n+        Object inputModel = getParam(parameters, PARAMETER, Object.class);\n+        String user = (String) parameters.remove(USER);", "originalCommit": "5103d97a9fa239a3103e1e358da02cfb43ccd47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzMxNDExOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493314118", "bodyText": "me neither, but this is what is already happening in v7 version of the rest handler. We need to discuss which is the best approach for passing password to handler, but it can be perfectly part of another JIRA, this one is already too big.", "author": "fjtirado", "createdAt": "2020-09-23T08:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDE0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "07ceec69b278edac4db9caf5252849520db6a312", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\nindex a87986cf40..1842576ab1 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\n\n@@ -138,13 +138,14 @@ public class RestTaskHandler implements WorkItemHandler {\n         return sb.toString();\n     }\n \n-    private <T> T getParam(Map<String, Object> parameters, String paramName,Class<T> type) {\n+    private <T> T getParam(Map<String, Object> parameters, String paramName, Class<T> type) {\n         Object value = parameters.remove(paramName);\n         if (value == null) {\n             throw new IllegalArgumentException(\"Missing required parameter \" + paramName);\n         }\n         if (!type.isAssignableFrom(value.getClass())) {\n-            throw new IllegalArgumentException(\"Parameter paramName should be of type \"+type+\" but it is of type \"+value.getClass()); \n+            throw new IllegalArgumentException(\n+                \"Parameter paramName should be of type \" + type + \" but it is of type \" + value.getClass());\n         }\n         return type.cast(value);\n     }\n"}}, {"oid": "07ceec69b278edac4db9caf5252849520db6a312", "url": "https://github.com/kiegroup/kogito-runtimes/commit/07ceec69b278edac4db9caf5252849520db6a312", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-23T08:41:34Z", "type": "forcePushed"}, {"oid": "1fa8dd5ffc271d16ca5556eccc4fb67cfe739b4a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1fa8dd5ffc271d16ca5556eccc4fb67cfe739b4a", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-23T10:47:03Z", "type": "forcePushed"}, {"oid": "9e14173c54c8e8122cb5be40574d496912e8896b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9e14173c54c8e8122cb5be40574d496912e8896b", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-23T14:35:04Z", "type": "forcePushed"}, {"oid": "ceee371594df3957dd924a00c80def5ff39adb21", "url": "https://github.com/kiegroup/kogito-runtimes/commit/ceee371594df3957dd924a00c80def5ff39adb21", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-23T15:09:04Z", "type": "forcePushed"}, {"oid": "d148ac8ea6d449d6790fa85a9fd7e211fbd3d11f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/d148ac8ea6d449d6790fa85a9fd7e211fbd3d11f", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-23T15:13:11Z", "type": "forcePushed"}, {"oid": "35ab3b99fce919ebf32c495732a8b0fc61369b99", "url": "https://github.com/kiegroup/kogito-runtimes/commit/35ab3b99fce919ebf32c495732a8b0fc61369b99", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-23T15:47:52Z", "type": "forcePushed"}, {"oid": "8ac700788713b695a6bb6ca309267a7195eee48e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8ac700788713b695a6bb6ca309267a7195eee48e", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-23T15:59:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyNzExNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493727116", "bodyText": "Any reason we are not sending json here as well? For SW at least the content type should always be application/json.", "author": "tsurdilo", "createdAt": "2020-09-23T16:25:51Z", "path": "jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.client.HttpRequest;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.kie.api.runtime.process.WorkItemHandler;\n+import org.kie.api.runtime.process.WorkItemManager;\n+\n+public class RestTaskHandler implements WorkItemHandler {\n+\n+    public static final String REST_TASK_TYPE = \"Rest Task\";\n+    public static final String ENDPOINT = \"endpoint\";\n+    public static final String METHOD = \"method\";\n+    public static final String PARAMETER = \"Parameter\";\n+    public static final String RESULT = \"Result\";\n+    public static final String RESULT_HANDLER = \"ResultHandler\";\n+    public static final String USER = \"User\";\n+    public static final String PASSWORD = \"Password\";\n+\n+    // package scoped to allow unit test\n+    static class RestUnaryOperator implements UnaryOperator<Object> {\n+\n+        private Object inputModel;\n+\n+        public RestUnaryOperator(Object inputModel) {\n+            this.inputModel = inputModel;\n+        }\n+\n+        @Override\n+        public Object apply(Object value) {\n+            return value instanceof RestTaskParamResolver\n+                    ? ((RestTaskParamResolver) value).apply(inputModel) : value;\n+        }\n+    }\n+\n+    private WebClient client;\n+\n+    public RestTaskHandler(WebClient client) {\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public void executeWorkItem(WorkItem workItem, WorkItemManager manager) {\n+        // retrieving parameters\n+        Map<String, Object> parameters = new HashMap<>(workItem.getParameters());\n+        String endPoint = getParam(parameters, ENDPOINT, String.class);\n+        HttpMethod method = HttpMethod.valueOf(getParam(parameters, METHOD, String.class).toUpperCase());\n+        Object inputModel = getParam(parameters, PARAMETER, Object.class);\n+        String user = (String) parameters.remove(USER);\n+        String password = (String) parameters.remove(PASSWORD);\n+        RestTaskResultHandler resultHandler = getParam(parameters, RESULT_HANDLER, RestTaskResultHandler.class);\n+        // create request\n+        UnaryOperator<Object> resolver = new RestUnaryOperator(inputModel);\n+        endPoint = resolvePathParams(endPoint, parameters, resolver);\n+        URI uri = URI.create(endPoint);\n+        HttpRequest<Buffer> request = client.request(method, uri.getPort(), uri.getHost(), uri.getPath());\n+        if (user != null && !user.trim().isEmpty() && password != null && !password.trim().isEmpty()) {\n+            request.basicAuthentication(user, password);\n+        }\n+        // execute request\n+         Handler<AsyncResult<HttpResponse<Buffer>>> handler = event -> \n+                manager\n+                .completeWorkItem(\n+                                  workItem.getId(),\n+                                  Collections\n+                                      .singletonMap(RESULT, resultHandler.apply(inputModel, event.result().bodyAsJsonObject())));\n+        if (method == HttpMethod.POST || method == HttpMethod.PUT) {\n+            // if parameters is empty at this stage, assume post content is the whole input model\n+            // if not, build a map from parameters remaining\n+            Object body = parameters.isEmpty() ? inputModel : parameters\n+                .entrySet()\n+                .stream()\n+                .collect(\n+                         Collectors\n+                             .toMap(Entry::getKey, e -> resolver.apply(e.getValue())));\n+           \n+            request.sendJson(body, handler);\n+        } else {\n+            request.send(handler);", "originalCommit": "8ac700788713b695a6bb6ca309267a7195eee48e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwMjM0OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493802349", "bodyText": "Line 108 is a GET or DELETE call, so there is no body, unlike POST or PUT call.\nJson output is handled by ResultTaskResultHandler implementation provided as ResultHandler parameter. In the case of the example JsonPathResultHandler, now located in serverless-worflow-runtime project", "author": "fjtirado", "createdAt": "2020-09-23T18:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyNzExNg=="}], "type": "inlineReview", "revised_code": {"commit": "4ca0d221e4446e24338ffbd70114290cb9fee2b0", "chunk": "diff --git a/jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java b/jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestWorkItemHandler.java\nsimilarity index 93%\nrename from jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\nrename to jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestWorkItemHandler.java\nindex 981f7113af..3fbc6fd543 100644\n--- a/jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\n+++ b/jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestWorkItemHandler.java\n\n@@ -35,7 +35,7 @@ import org.kie.api.runtime.process.WorkItem;\n import org.kie.api.runtime.process.WorkItemHandler;\n import org.kie.api.runtime.process.WorkItemManager;\n \n-public class RestTaskHandler implements WorkItemHandler {\n+public class RestWorkItemHandler implements WorkItemHandler {\n \n     public static final String REST_TASK_TYPE = \"Rest Task\";\n     public static final String ENDPOINT = \"endpoint\";\n"}}, {"oid": "ed593e9b9b0ec43bdb968ac1454af0a2c898a139", "url": "https://github.com/kiegroup/kogito-runtimes/commit/ed593e9b9b0ec43bdb968ac1454af0a2c898a139", "message": "[KOGITO-3158] Switching to vert.x", "committedDate": "2020-09-23T18:39:55Z", "type": "forcePushed"}, {"oid": "c85efd99f0f99a3704ebf8174dbed464c5766edd", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c85efd99f0f99a3704ebf8174dbed464c5766edd", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-23T19:41:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY0NzI2MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r493647260", "bodyText": "I think you might want to check value != null or it will throw NPE", "author": "evacchi", "createdAt": "2020-09-23T14:38:40Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java", "diffHunk": "@@ -110,30 +117,42 @@ protected void addWorkItemParameters(Work work, BlockStmt body, String variableN\n             if(work.getParameterDefinition(entry.getKey()) != null) {\n                 paramType = work.getParameterDefinition(entry.getKey()).getType().getStringType();\n             }\n-            body.addStatement(getFactoryMethod(variableName, METHOD_WORK_PARAMETER, new StringLiteralExpr(entry.getKey()), getParameterExpr(paramType, entry.getValue().toString())));\n+            body.addStatement(getFactoryMethod(variableName, METHOD_WORK_PARAMETER, new StringLiteralExpr(entry.getKey()), getParameterExpr(paramType, entry.getValue())));\n         }\n     }\n+    \n+  \n \n-    private Expression getParameterExpr(String type, String value) {\n+    private Expression getParameterExpr(String type, Object value) {", "originalCommit": "1fa8dd5ffc271d16ca5556eccc4fb67cfe739b4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMDkwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494200904", "bodyText": "Checked, returning null literal expr in that case", "author": "fjtirado", "createdAt": "2020-09-24T10:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY0NzI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "c0879d334c6c285de952a8691104a023808641a2", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\nindex c5b968990a..ad9f1ddf72 100644\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\n\n@@ -124,6 +124,9 @@ public class WorkItemNodeVisitor<T extends WorkItemNode> extends AbstractNodeVis\n   \n \n     private Expression getParameterExpr(String type, Object value) {\n+        if (value == null) {\n+            return new NullLiteralExpr();\n+        }\n         ParamType pType = ParamType.fromString(type);\n         if (pType == null) {\n             if (value instanceof Supplier) {\n"}}, {"oid": "c0879d334c6c285de952a8691104a023808641a2", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c0879d334c6c285de952a8691104a023808641a2", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-24T10:17:26Z", "type": "forcePushed"}, {"oid": "5383f4ede8e9e3cde9e16eaf5cc67720e57b3769", "url": "https://github.com/kiegroup/kogito-runtimes/commit/5383f4ede8e9e3cde9e16eaf5cc67720e57b3769", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-24T12:41:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEzODI4Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494138287", "bodyText": "What is the purpose of creating a separate work item handler for each process? A separate vertX client for each of them?", "author": "MarianMacik", "createdAt": "2020-09-24T08:37:14Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.jbpm.compiler.canonical;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+\n+import static com.github.javaparser.StaticJavaParser.parse;\n+\n+public class RestTaskDescriptor {\n+\n+    private RestTaskDescriptor() {}\n+\n+    public static String getClassName(ProcessMetaData processMetadata) {\n+        return processMetadata.getProcessId() + \"RestTaskHandler\";\n+    }\n+\n+    public static CompilationUnit generateHandlerClassForService(String className) {\n+        CompilationUnit compilationUnit =\n+                parse(RestTaskDescriptor.class.getResourceAsStream(\"/class-templates/RestTaskTemplate.java\"));\n+        compilationUnit.setPackageDeclaration(\"org.kie.kogito.handlers\");\n+        compilationUnit.findFirst(ClassOrInterfaceDeclaration.class).ifPresent(c -> c.setName(className));\n+        compilationUnit.findAll(ConstructorDeclaration.class).forEach(c -> c.setName(className));\n+        return compilationUnit;", "originalCommit": "c85efd99f0f99a3704ebf8174dbed464c5766edd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3MTQzMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494371430", "bodyText": "Yes, and also to reuse the same vertx instance (which is injected)", "author": "fjtirado", "createdAt": "2020-09-24T14:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEzODI4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4ca0d221e4446e24338ffbd70114290cb9fee2b0", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java\nindex 641f115126..ec69b4d904 100644\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java\n\n@@ -27,12 +27,12 @@ public class RestTaskDescriptor {\n     private RestTaskDescriptor() {}\n \n     public static String getClassName(ProcessMetaData processMetadata) {\n-        return processMetadata.getProcessId() + \"RestTaskHandler\";\n+        return processMetadata.getProcessId() + \"RestWorkItemHandler\";\n     }\n \n     public static CompilationUnit generateHandlerClassForService(String className) {\n         CompilationUnit compilationUnit =\n-                parse(RestTaskDescriptor.class.getResourceAsStream(\"/class-templates/RestTaskTemplate.java\"));\n+                parse(RestTaskDescriptor.class.getResourceAsStream(\"/class-templates/RestWorkItemHandlerTemplate.java\"));\n         compilationUnit.setPackageDeclaration(\"org.kie.kogito.handlers\");\n         compilationUnit.findFirst(ClassOrInterfaceDeclaration.class).ifPresent(c -> c.setName(className));\n         compilationUnit.findAll(ConstructorDeclaration.class).forEach(c -> c.setName(className));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE0OTYzMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494149630", "bodyText": "I think in jbpm it is a good convention to end all Work Item handlers with *WorkItemHandler suffix, i.e. RestWorkItemHandler. This way it is easier to distinguish them from SAX Parser handlers for example.", "author": "MarianMacik", "createdAt": "2020-09-24T08:54:04Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.jbpm.compiler.canonical;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+\n+import static com.github.javaparser.StaticJavaParser.parse;\n+\n+public class RestTaskDescriptor {\n+\n+    private RestTaskDescriptor() {}\n+\n+    public static String getClassName(ProcessMetaData processMetadata) {\n+        return processMetadata.getProcessId() + \"RestTaskHandler\";", "originalCommit": "c85efd99f0f99a3704ebf8174dbed464c5766edd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0OTIwNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494349205", "bodyText": "you are right, I'll rename it", "author": "fjtirado", "createdAt": "2020-09-24T14:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE0OTYzMA=="}], "type": "inlineReview", "revised_code": {"commit": "4ca0d221e4446e24338ffbd70114290cb9fee2b0", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java\nindex 641f115126..ec69b4d904 100644\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/RestTaskDescriptor.java\n\n@@ -27,12 +27,12 @@ public class RestTaskDescriptor {\n     private RestTaskDescriptor() {}\n \n     public static String getClassName(ProcessMetaData processMetadata) {\n-        return processMetadata.getProcessId() + \"RestTaskHandler\";\n+        return processMetadata.getProcessId() + \"RestWorkItemHandler\";\n     }\n \n     public static CompilationUnit generateHandlerClassForService(String className) {\n         CompilationUnit compilationUnit =\n-                parse(RestTaskDescriptor.class.getResourceAsStream(\"/class-templates/RestTaskTemplate.java\"));\n+                parse(RestTaskDescriptor.class.getResourceAsStream(\"/class-templates/RestWorkItemHandlerTemplate.java\"));\n         compilationUnit.setPackageDeclaration(\"org.kie.kogito.handlers\");\n         compilationUnit.findFirst(ClassOrInterfaceDeclaration.class).ifPresent(c -> c.setName(className));\n         compilationUnit.findAll(ConstructorDeclaration.class).forEach(c -> c.setName(className));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1MTEyMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494151121", "bodyText": "I know it is just a template but still would be good to name it xxxRestWorkItemHandler, both the constructors and the name of the class.", "author": "MarianMacik", "createdAt": "2020-09-24T08:56:16Z", "path": "jbpm/jbpm-flow-builder/src/main/resources/class-templates/RestTaskTemplate.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package org.jbpm.process.codegen;\n+\n+import io.vertx.ext.web.client.WebClient;\n+import io.vertx.core.Vertx;\n+import org.jbpm.process.instance.impl.rest.RestTaskHandler;\n+\n+public class xxxTaskHandler extends RestTaskHandler {\n+\n+    public xxxRestTaskHandler() {\n+        this(Vertx.vertx());\n+    }\n+\n+    public xxxRestTaskHandler(Vertx vertx) {\n+        super(WebClient.create(vertx));", "originalCommit": "c85efd99f0f99a3704ebf8174dbed464c5766edd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0OTYwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494349604", "bodyText": "yep", "author": "fjtirado", "createdAt": "2020-09-24T14:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1MTEyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4ca0d221e4446e24338ffbd70114290cb9fee2b0", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/resources/class-templates/RestTaskTemplate.java b/jbpm/jbpm-flow-builder/src/main/resources/class-templates/RestTaskTemplate.java\ndeleted file mode 100644\nindex 05bb93fe88..0000000000\n--- a/jbpm/jbpm-flow-builder/src/main/resources/class-templates/RestTaskTemplate.java\n+++ /dev/null\n\n@@ -1,16 +0,0 @@\n-package org.jbpm.process.codegen;\n-\n-import io.vertx.ext.web.client.WebClient;\n-import io.vertx.core.Vertx;\n-import org.jbpm.process.instance.impl.rest.RestTaskHandler;\n-\n-public class xxxTaskHandler extends RestTaskHandler {\n-\n-    public xxxRestTaskHandler() {\n-        this(Vertx.vertx());\n-    }\n-\n-    public xxxRestTaskHandler(Vertx vertx) {\n-        super(WebClient.create(vertx));\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1OTA4Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494159082", "bodyText": "RestWorkItemHandler would be better.", "author": "MarianMacik", "createdAt": "2020-09-24T09:09:02Z", "path": "jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.client.HttpRequest;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.kie.api.runtime.process.WorkItemHandler;\n+import org.kie.api.runtime.process.WorkItemManager;\n+\n+public class RestTaskHandler implements WorkItemHandler {", "originalCommit": "c85efd99f0f99a3704ebf8174dbed464c5766edd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM1MDc2Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494350762", "bodyText": "yes", "author": "fjtirado", "createdAt": "2020-09-24T14:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1OTA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4ca0d221e4446e24338ffbd70114290cb9fee2b0", "chunk": "diff --git a/jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java b/jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestWorkItemHandler.java\nsimilarity index 93%\nrename from jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\nrename to jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestWorkItemHandler.java\nindex 981f7113af..3fbc6fd543 100644\n--- a/jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestTaskHandler.java\n+++ b/jbpm/jbpm-rest-handler/src/main/java/org/jbpm/process/instance/impl/rest/RestWorkItemHandler.java\n\n@@ -35,7 +35,7 @@ import org.kie.api.runtime.process.WorkItem;\n import org.kie.api.runtime.process.WorkItemHandler;\n import org.kie.api.runtime.process.WorkItemManager;\n \n-public class RestTaskHandler implements WorkItemHandler {\n+public class RestWorkItemHandler implements WorkItemHandler {\n \n     public static final String REST_TASK_TYPE = \"Rest Task\";\n     public static final String ENDPOINT = \"endpoint\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNDA2MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494314061", "bodyText": "Isn't it better to call it RestTaskHandlerTest? I know junit 5 doesn't need it, but it is still a good convention.", "author": "MarianMacik", "createdAt": "2020-09-24T13:25:22Z", "path": "jbpm/jbpm-rest-handler/src/test/java/org/jbpm/process/instance/impl/rest/TestRestTaskHandler.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.process.instance.impl.rest;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class TestRestTaskHandler {", "originalCommit": "5383f4ede8e9e3cde9e16eaf5cc67720e57b3769", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM2NTY4MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494365680", "bodyText": "ok, moving test to the end", "author": "fjtirado", "createdAt": "2020-09-24T14:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNDA2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "4ca0d221e4446e24338ffbd70114290cb9fee2b0", "chunk": "diff --git a/jbpm/jbpm-rest-handler/src/test/java/org/jbpm/process/instance/impl/rest/TestRestTaskHandler.java b/jbpm/jbpm-rest-handler/src/test/java/org/jbpm/process/instance/impl/rest/RestTaskHandlerTest.java\nsimilarity index 85%\nrename from jbpm/jbpm-rest-handler/src/test/java/org/jbpm/process/instance/impl/rest/TestRestTaskHandler.java\nrename to jbpm/jbpm-rest-handler/src/test/java/org/jbpm/process/instance/impl/rest/RestTaskHandlerTest.java\nindex 3e64185c22..e7d3796683 100644\n--- a/jbpm/jbpm-rest-handler/src/test/java/org/jbpm/process/instance/impl/rest/TestRestTaskHandler.java\n+++ b/jbpm/jbpm-rest-handler/src/test/java/org/jbpm/process/instance/impl/rest/RestTaskHandlerTest.java\n\n@@ -24,7 +24,7 @@ import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-class TestRestTaskHandler {\n+class RestTaskHandlerTest {\n \n     @Test\n     void testReplaceTemplateTrivial() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMDQ4NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494320485", "bodyText": "Same here.", "author": "MarianMacik", "createdAt": "2020-09-24T13:33:56Z", "path": "jbpm/jbpm-serverless-workflow-runtime/src/test/java/TestRestTaskHandler.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.HttpRequest;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import org.jbpm.process.instance.impl.rest.RestTaskHandler;\n+import org.jbpm.serverless.workflow.JSonPathResultHandler;\n+import org.jbpm.serverless.workflow.JsonPathResolver;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.kie.api.runtime.process.WorkItemManager;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.mockito.stubbing.Answer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestRestTaskHandler {", "originalCommit": "5383f4ede8e9e3cde9e16eaf5cc67720e57b3769", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4ca0d221e4446e24338ffbd70114290cb9fee2b0", "chunk": "diff --git a/jbpm/jbpm-serverless-workflow-runtime/src/test/java/TestRestTaskHandler.java b/jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java\nsimilarity index 84%\nrename from jbpm/jbpm-serverless-workflow-runtime/src/test/java/TestRestTaskHandler.java\nrename to jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java\nindex 1746d070d6..8517b1a674 100644\n--- a/jbpm/jbpm-serverless-workflow-runtime/src/test/java/TestRestTaskHandler.java\n+++ b/jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java\n\n@@ -26,7 +26,7 @@ import io.vertx.core.json.JsonObject;\n import io.vertx.ext.web.client.HttpRequest;\n import io.vertx.ext.web.client.HttpResponse;\n import io.vertx.ext.web.client.WebClient;\n-import org.jbpm.process.instance.impl.rest.RestTaskHandler;\n+import org.jbpm.process.instance.impl.rest.RestWorkItemHandler;\n import org.jbpm.serverless.workflow.JSonPathResultHandler;\n import org.jbpm.serverless.workflow.JsonPathResolver;\n import org.junit.jupiter.api.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzOTc4Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494339787", "bodyText": "Just a typo: Cannot a find a...", "author": "MarianMacik", "createdAt": "2020-09-24T13:55:34Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -388,38 +388,19 @@ public ClassOrInterfaceDeclaration classDeclaration() {\n                 Parameter parameter = new Parameter(clazzNameType, varName);\n                 if (useInjection()) {\n                     annotator.withApplicationComponent(handlerClazz);\n+                    annotator\n+                        .withInjection(\n+                                       handlerClazz\n+                                           .getConstructors()\n+                                           .stream()\n+                                           .filter(c -> !c.getParameters().isEmpty())\n+                                           .findFirst()\n+                                           .orElseThrow(\n+                                                        () -> new IllegalStateException(\n+                                                            \"Cannot a find a non empty constructor to annotate in handler class \" +", "originalCommit": "5383f4ede8e9e3cde9e16eaf5cc67720e57b3769", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM2NTg5NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494365895", "bodyText": "good catch! thanks", "author": "fjtirado", "createdAt": "2020-09-24T14:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzOTc4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4ca0d221e4446e24338ffbd70114290cb9fee2b0", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\nindex deb1d2fea8..5387ca8ef1 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n\n@@ -397,7 +397,7 @@ public class ProcessGenerator {\n                                            .findFirst()\n                                            .orElseThrow(\n                                                         () -> new IllegalStateException(\n-                                                            \"Cannot a find a non empty constructor to annotate in handler class \" +\n+                                                            \"Cannot find a non empty constructor to annotate in handler class \" +\n                                                                                         handlerClazz)),true);\n                 }\n              \n"}}, {"oid": "4ca0d221e4446e24338ffbd70114290cb9fee2b0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/4ca0d221e4446e24338ffbd70114290cb9fee2b0", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-24T15:01:01Z", "type": "forcePushed"}, {"oid": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6d143a0cc598832b7a6bd017cc2adca371754fa4", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-24T15:11:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5MTE2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494891163", "bodyText": "Suggested change", "author": "cristianonicolai", "createdAt": "2020-09-25T10:16:33Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java", "diffHunk": "@@ -85,8 +87,13 @@ public void visitNode(String factoryField, T node, BlockStmt body, VariableScope\n             CompilationUnit generatedHandler = d.generateHandlerClassForService();\n             metadata.getGeneratedHandlers().put(mangledName, generatedHandler);\n             workName = mangledName;\n+        } else if (workName.equals(\"Rest Task\")) {\n+            workName = RestTaskDescriptor.getClassName(metadata);\n+            metadata\n+                .getGeneratedHandlers()\n+                .computeIfAbsent(workName,RestTaskDescriptor::generateHandlerClassForService);\n         }\n-\n+        ", "originalCommit": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67f4c3f42a0b1fe7af7956c189c8f504827107c6", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\nindex ad9f1ddf72..b00b7d0f62 100644\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\n\n@@ -91,7 +91,7 @@ public class WorkItemNodeVisitor<T extends WorkItemNode> extends AbstractNodeVis\n             workName = RestTaskDescriptor.getClassName(metadata);\n             metadata\n                 .getGeneratedHandlers()\n-                .computeIfAbsent(workName,RestTaskDescriptor::generateHandlerClassForService);\n+                .computeIfAbsent(workName, RestTaskDescriptor::generateHandlerClassForService);\n         }\n         \n         body.addStatement(getAssignedFactoryMethod(factoryField, WorkItemNodeFactory.class, getNodeId(node), getNodeKey(), new LongLiteralExpr(node.getId())))\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5MjU4OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494892588", "bodyText": "in most tests, we end up using import static to most Mockito API calls,", "author": "cristianonicolai", "createdAt": "2020-09-25T10:19:35Z", "path": "jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.HttpRequest;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import org.jbpm.process.instance.impl.rest.RestWorkItemHandler;\n+import org.jbpm.serverless.workflow.JSonPathResultHandler;\n+import org.jbpm.serverless.workflow.JsonPathResolver;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.kie.api.runtime.process.WorkItemManager;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.mockito.stubbing.Answer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class RestTaskHandlerTest {\n+    \n+    @Test\n+    void testGetRestTaskHandler() {\n+        WebClient webClient = Mockito.mock(WebClient.class);", "originalCommit": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "588172c2ca3c0433510e5bb6152ada230e69387b", "chunk": "diff --git a/jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java b/jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java\ndeleted file mode 100644\nindex 8517b1a674..0000000000\n--- a/jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java\n+++ /dev/null\n\n@@ -1,94 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-import io.vertx.core.AsyncResult;\n-import io.vertx.core.Handler;\n-import io.vertx.core.buffer.Buffer;\n-import io.vertx.core.http.HttpMethod;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpRequest;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import org.jbpm.process.instance.impl.rest.RestWorkItemHandler;\n-import org.jbpm.serverless.workflow.JSonPathResultHandler;\n-import org.jbpm.serverless.workflow.JsonPathResolver;\n-import org.junit.jupiter.api.Test;\n-import org.kie.api.runtime.process.WorkItem;\n-import org.kie.api.runtime.process.WorkItemManager;\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Mockito;\n-import org.mockito.stubbing.Answer;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class RestTaskHandlerTest {\n-    \n-    @Test\n-    void testGetRestTaskHandler() {\n-        WebClient webClient = Mockito.mock(WebClient.class);\n-        ObjectMapper mapper = new ObjectMapper();\n-        HttpRequest<Buffer> request = Mockito.mock(HttpRequest.class);\n-        HttpResponse<Buffer> response = Mockito.mock(HttpResponse.class);\n-        AsyncResult<HttpResponse<Buffer>> event = Mockito.mock(AsyncResult.class);\n-        Mockito.when(event.result()).thenReturn(response);\n-        Mockito\n-            .when(webClient.request(HttpMethod.GET, 8080, \"localhost\", \"/results/26/names/pepe\"))\n-            .thenReturn(request);\n-        Mockito.doAnswer((Answer<Void>) invocation -> {\n-            Handler<AsyncResult<HttpResponse<Buffer>>> handler =\n-                    (Handler<AsyncResult<HttpResponse<Buffer>>>) invocation.getArgument(0);\n-            handler.handle(event);\n-            return null;\n-        }).when(request).send(Mockito.any(Handler.class));\n-        Mockito.when(response.bodyAsJsonObject()).thenReturn(JsonObject.mapFrom(Collections.singletonMap(\"num\", 1)));\n-\n-        Map<String, Object> parameters =\n-                new HashMap<>();\n-        parameters.put(\"id\", new JsonPathResolver(\"$.id\"));\n-        parameters.put(\"name\", new JsonPathResolver(\"$.name\"));\n-        parameters.put(RestWorkItemHandler.ENDPOINT, \"http://localhost:8080/results/{id}/names/{name}\");\n-        parameters.put(RestWorkItemHandler.METHOD, \"GET\");\n-        parameters.put(RestWorkItemHandler.RESULT_HANDLER, new JSonPathResultHandler());\n-        parameters.put(RestWorkItemHandler.PARAMETER, mapper.createObjectNode().put(\"id\", 26).put(\"name\", \"pepe\"));\n-\n-        WorkItem workItem = Mockito\n-            .mock(\n-                  WorkItem.class);\n-        Mockito.when(workItem.getId()).thenReturn(\"2\");\n-        Mockito.when(workItem.getParameters()).thenReturn(parameters);\n-        WorkItemManager manager = Mockito.mock(WorkItemManager.class);\n-\n-        ArgumentCaptor<Map<String, Object>> argCaptor = ArgumentCaptor.forClass(Map.class);\n-\n-        RestWorkItemHandler handler = new RestWorkItemHandler(\n-            webClient);\n-        handler.executeWorkItem(workItem, manager);\n-        Mockito.verify(manager).completeWorkItem(Mockito.anyString(), argCaptor.capture());\n-        Map<String, Object> results = argCaptor.getValue();\n-\n-        assertEquals(1, results.size());\n-        assertTrue(results.containsKey(RestWorkItemHandler.RESULT));\n-        Object result = results.get(RestWorkItemHandler.RESULT);\n-        assertTrue(result instanceof ObjectNode);\n-        assertEquals(1, ((ObjectNode) result).get(\"num\").asInt());\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5MjcxOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494892718", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<String, Object> parameters =\n          \n          \n            \n                            new HashMap<>();\n          \n          \n            \n                    Map<String, Object> parameters = new HashMap<>();", "author": "cristianonicolai", "createdAt": "2020-09-25T10:19:50Z", "path": "jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.HttpRequest;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import org.jbpm.process.instance.impl.rest.RestWorkItemHandler;\n+import org.jbpm.serverless.workflow.JSonPathResultHandler;\n+import org.jbpm.serverless.workflow.JsonPathResolver;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.kie.api.runtime.process.WorkItemManager;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.mockito.stubbing.Answer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class RestTaskHandlerTest {\n+    \n+    @Test\n+    void testGetRestTaskHandler() {\n+        WebClient webClient = Mockito.mock(WebClient.class);\n+        ObjectMapper mapper = new ObjectMapper();\n+        HttpRequest<Buffer> request = Mockito.mock(HttpRequest.class);\n+        HttpResponse<Buffer> response = Mockito.mock(HttpResponse.class);\n+        AsyncResult<HttpResponse<Buffer>> event = Mockito.mock(AsyncResult.class);\n+        Mockito.when(event.result()).thenReturn(response);\n+        Mockito\n+            .when(webClient.request(HttpMethod.GET, 8080, \"localhost\", \"/results/26/names/pepe\"))\n+            .thenReturn(request);\n+        Mockito.doAnswer((Answer<Void>) invocation -> {\n+            Handler<AsyncResult<HttpResponse<Buffer>>> handler =\n+                    (Handler<AsyncResult<HttpResponse<Buffer>>>) invocation.getArgument(0);\n+            handler.handle(event);\n+            return null;\n+        }).when(request).send(Mockito.any(Handler.class));\n+        Mockito.when(response.bodyAsJsonObject()).thenReturn(JsonObject.mapFrom(Collections.singletonMap(\"num\", 1)));\n+\n+        Map<String, Object> parameters =\n+                new HashMap<>();", "originalCommit": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "588172c2ca3c0433510e5bb6152ada230e69387b", "chunk": "diff --git a/jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java b/jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java\ndeleted file mode 100644\nindex 8517b1a674..0000000000\n--- a/jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java\n+++ /dev/null\n\n@@ -1,94 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-import io.vertx.core.AsyncResult;\n-import io.vertx.core.Handler;\n-import io.vertx.core.buffer.Buffer;\n-import io.vertx.core.http.HttpMethod;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpRequest;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import org.jbpm.process.instance.impl.rest.RestWorkItemHandler;\n-import org.jbpm.serverless.workflow.JSonPathResultHandler;\n-import org.jbpm.serverless.workflow.JsonPathResolver;\n-import org.junit.jupiter.api.Test;\n-import org.kie.api.runtime.process.WorkItem;\n-import org.kie.api.runtime.process.WorkItemManager;\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Mockito;\n-import org.mockito.stubbing.Answer;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class RestTaskHandlerTest {\n-    \n-    @Test\n-    void testGetRestTaskHandler() {\n-        WebClient webClient = Mockito.mock(WebClient.class);\n-        ObjectMapper mapper = new ObjectMapper();\n-        HttpRequest<Buffer> request = Mockito.mock(HttpRequest.class);\n-        HttpResponse<Buffer> response = Mockito.mock(HttpResponse.class);\n-        AsyncResult<HttpResponse<Buffer>> event = Mockito.mock(AsyncResult.class);\n-        Mockito.when(event.result()).thenReturn(response);\n-        Mockito\n-            .when(webClient.request(HttpMethod.GET, 8080, \"localhost\", \"/results/26/names/pepe\"))\n-            .thenReturn(request);\n-        Mockito.doAnswer((Answer<Void>) invocation -> {\n-            Handler<AsyncResult<HttpResponse<Buffer>>> handler =\n-                    (Handler<AsyncResult<HttpResponse<Buffer>>>) invocation.getArgument(0);\n-            handler.handle(event);\n-            return null;\n-        }).when(request).send(Mockito.any(Handler.class));\n-        Mockito.when(response.bodyAsJsonObject()).thenReturn(JsonObject.mapFrom(Collections.singletonMap(\"num\", 1)));\n-\n-        Map<String, Object> parameters =\n-                new HashMap<>();\n-        parameters.put(\"id\", new JsonPathResolver(\"$.id\"));\n-        parameters.put(\"name\", new JsonPathResolver(\"$.name\"));\n-        parameters.put(RestWorkItemHandler.ENDPOINT, \"http://localhost:8080/results/{id}/names/{name}\");\n-        parameters.put(RestWorkItemHandler.METHOD, \"GET\");\n-        parameters.put(RestWorkItemHandler.RESULT_HANDLER, new JSonPathResultHandler());\n-        parameters.put(RestWorkItemHandler.PARAMETER, mapper.createObjectNode().put(\"id\", 26).put(\"name\", \"pepe\"));\n-\n-        WorkItem workItem = Mockito\n-            .mock(\n-                  WorkItem.class);\n-        Mockito.when(workItem.getId()).thenReturn(\"2\");\n-        Mockito.when(workItem.getParameters()).thenReturn(parameters);\n-        WorkItemManager manager = Mockito.mock(WorkItemManager.class);\n-\n-        ArgumentCaptor<Map<String, Object>> argCaptor = ArgumentCaptor.forClass(Map.class);\n-\n-        RestWorkItemHandler handler = new RestWorkItemHandler(\n-            webClient);\n-        handler.executeWorkItem(workItem, manager);\n-        Mockito.verify(manager).completeWorkItem(Mockito.anyString(), argCaptor.capture());\n-        Map<String, Object> results = argCaptor.getValue();\n-\n-        assertEquals(1, results.size());\n-        assertTrue(results.containsKey(RestWorkItemHandler.RESULT));\n-        Object result = results.get(RestWorkItemHandler.RESULT);\n-        assertTrue(result instanceof ObjectNode);\n-        assertEquals(1, ((ObjectNode) result).get(\"num\").asInt());\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5Mjg2OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494892868", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    WorkItem workItem = Mockito\n          \n          \n            \n                        .mock(\n          \n          \n            \n                              WorkItem.class);\n          \n          \n            \n                    WorkItem workItem = mock(WorkItem.class);", "author": "cristianonicolai", "createdAt": "2020-09-25T10:20:07Z", "path": "jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.HttpRequest;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import org.jbpm.process.instance.impl.rest.RestWorkItemHandler;\n+import org.jbpm.serverless.workflow.JSonPathResultHandler;\n+import org.jbpm.serverless.workflow.JsonPathResolver;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.kie.api.runtime.process.WorkItemManager;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.mockito.stubbing.Answer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class RestTaskHandlerTest {\n+    \n+    @Test\n+    void testGetRestTaskHandler() {\n+        WebClient webClient = Mockito.mock(WebClient.class);\n+        ObjectMapper mapper = new ObjectMapper();\n+        HttpRequest<Buffer> request = Mockito.mock(HttpRequest.class);\n+        HttpResponse<Buffer> response = Mockito.mock(HttpResponse.class);\n+        AsyncResult<HttpResponse<Buffer>> event = Mockito.mock(AsyncResult.class);\n+        Mockito.when(event.result()).thenReturn(response);\n+        Mockito\n+            .when(webClient.request(HttpMethod.GET, 8080, \"localhost\", \"/results/26/names/pepe\"))\n+            .thenReturn(request);\n+        Mockito.doAnswer((Answer<Void>) invocation -> {\n+            Handler<AsyncResult<HttpResponse<Buffer>>> handler =\n+                    (Handler<AsyncResult<HttpResponse<Buffer>>>) invocation.getArgument(0);\n+            handler.handle(event);\n+            return null;\n+        }).when(request).send(Mockito.any(Handler.class));\n+        Mockito.when(response.bodyAsJsonObject()).thenReturn(JsonObject.mapFrom(Collections.singletonMap(\"num\", 1)));\n+\n+        Map<String, Object> parameters =\n+                new HashMap<>();\n+        parameters.put(\"id\", new JsonPathResolver(\"$.id\"));\n+        parameters.put(\"name\", new JsonPathResolver(\"$.name\"));\n+        parameters.put(RestWorkItemHandler.ENDPOINT, \"http://localhost:8080/results/{id}/names/{name}\");\n+        parameters.put(RestWorkItemHandler.METHOD, \"GET\");\n+        parameters.put(RestWorkItemHandler.RESULT_HANDLER, new JSonPathResultHandler());\n+        parameters.put(RestWorkItemHandler.PARAMETER, mapper.createObjectNode().put(\"id\", 26).put(\"name\", \"pepe\"));\n+\n+        WorkItem workItem = Mockito\n+            .mock(\n+                  WorkItem.class);", "originalCommit": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "588172c2ca3c0433510e5bb6152ada230e69387b", "chunk": "diff --git a/jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java b/jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java\ndeleted file mode 100644\nindex 8517b1a674..0000000000\n--- a/jbpm/jbpm-serverless-workflow-runtime/src/test/java/RestTaskHandlerTest.java\n+++ /dev/null\n\n@@ -1,94 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-import io.vertx.core.AsyncResult;\n-import io.vertx.core.Handler;\n-import io.vertx.core.buffer.Buffer;\n-import io.vertx.core.http.HttpMethod;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpRequest;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import org.jbpm.process.instance.impl.rest.RestWorkItemHandler;\n-import org.jbpm.serverless.workflow.JSonPathResultHandler;\n-import org.jbpm.serverless.workflow.JsonPathResolver;\n-import org.junit.jupiter.api.Test;\n-import org.kie.api.runtime.process.WorkItem;\n-import org.kie.api.runtime.process.WorkItemManager;\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Mockito;\n-import org.mockito.stubbing.Answer;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class RestTaskHandlerTest {\n-    \n-    @Test\n-    void testGetRestTaskHandler() {\n-        WebClient webClient = Mockito.mock(WebClient.class);\n-        ObjectMapper mapper = new ObjectMapper();\n-        HttpRequest<Buffer> request = Mockito.mock(HttpRequest.class);\n-        HttpResponse<Buffer> response = Mockito.mock(HttpResponse.class);\n-        AsyncResult<HttpResponse<Buffer>> event = Mockito.mock(AsyncResult.class);\n-        Mockito.when(event.result()).thenReturn(response);\n-        Mockito\n-            .when(webClient.request(HttpMethod.GET, 8080, \"localhost\", \"/results/26/names/pepe\"))\n-            .thenReturn(request);\n-        Mockito.doAnswer((Answer<Void>) invocation -> {\n-            Handler<AsyncResult<HttpResponse<Buffer>>> handler =\n-                    (Handler<AsyncResult<HttpResponse<Buffer>>>) invocation.getArgument(0);\n-            handler.handle(event);\n-            return null;\n-        }).when(request).send(Mockito.any(Handler.class));\n-        Mockito.when(response.bodyAsJsonObject()).thenReturn(JsonObject.mapFrom(Collections.singletonMap(\"num\", 1)));\n-\n-        Map<String, Object> parameters =\n-                new HashMap<>();\n-        parameters.put(\"id\", new JsonPathResolver(\"$.id\"));\n-        parameters.put(\"name\", new JsonPathResolver(\"$.name\"));\n-        parameters.put(RestWorkItemHandler.ENDPOINT, \"http://localhost:8080/results/{id}/names/{name}\");\n-        parameters.put(RestWorkItemHandler.METHOD, \"GET\");\n-        parameters.put(RestWorkItemHandler.RESULT_HANDLER, new JSonPathResultHandler());\n-        parameters.put(RestWorkItemHandler.PARAMETER, mapper.createObjectNode().put(\"id\", 26).put(\"name\", \"pepe\"));\n-\n-        WorkItem workItem = Mockito\n-            .mock(\n-                  WorkItem.class);\n-        Mockito.when(workItem.getId()).thenReturn(\"2\");\n-        Mockito.when(workItem.getParameters()).thenReturn(parameters);\n-        WorkItemManager manager = Mockito.mock(WorkItemManager.class);\n-\n-        ArgumentCaptor<Map<String, Object>> argCaptor = ArgumentCaptor.forClass(Map.class);\n-\n-        RestWorkItemHandler handler = new RestWorkItemHandler(\n-            webClient);\n-        handler.executeWorkItem(workItem, manager);\n-        Mockito.verify(manager).completeWorkItem(Mockito.anyString(), argCaptor.capture());\n-        Map<String, Object> results = argCaptor.getValue();\n-\n-        assertEquals(1, results.size());\n-        assertTrue(results.containsKey(RestWorkItemHandler.RESULT));\n-        Object result = results.get(RestWorkItemHandler.RESULT);\n-        assertTrue(result instanceof ObjectNode);\n-        assertEquals(1, ((ObjectNode) result).get(\"num\").asInt());\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5MzA4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494893086", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        current = factory.restServiceNode (idCounter.getAndIncrement(), action.getFunctionRef(), actionFunction,embeddedSubProcess);\n          \n          \n            \n                                        current = factory.restServiceNode(idCounter.getAndIncrement(), action.getFunctionRef(), actionFunction, embeddedSubProcess);", "author": "cristianonicolai", "createdAt": "2020-09-25T10:20:36Z", "path": "jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java", "diffHunk": "@@ -403,55 +418,41 @@ protected void handleActions(List<Function> workflowFunctions, List<Action> acti\n                 Function actionFunction = workflowFunctions.stream()\n                         .filter(wf -> wf.getName().equals(action.getFunctionRef().getRefName()))\n                         .findFirst()\n-                        .get();\n-\n-                if (actionFunction.getType() != null) {\n-                    if (SCRIPT_TYPE.equalsIgnoreCase(actionFunction.getType())) {\n-                        String script = ServerlessWorkflowUtils.scriptFunctionScript(action.getFunctionRef().getParameters().get(SCRIPT_TYPE_PARAM));\n-                        current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), script, embeddedSubProcess);\n-\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else if (SYSOUT_TYPE.equalsIgnoreCase(actionFunction.getType())) {\n-                        String script = ServerlessWorkflowUtils.sysOutFunctionScript(action.getFunctionRef().getParameters().get(SYSOUT_TYPE_PARAM));\n-                        current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), script, embeddedSubProcess);\n-\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else if (SERVICE_TYPE.equalsIgnoreCase(actionFunction.getType())) {\n-                        current = factory.serviceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else if (DECISION_TYPE.equals(actionFunction.getType())) {\n-                        current = factory.humanTaskNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, process, embeddedSubProcess);\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else if (RULE_TYPE.equals(actionFunction.getType())) {\n-                        current = factory.ruleSetNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else if (INTEGRATION_TYPE.equals(actionFunction.getType())) {\n-                        current = factory.camelRouteServiceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else {\n-                        LOGGER.warn(\"currently unsupported function type, supported types are 'script', 'sysout', 'service', 'decision', 'rule', 'integration'\");\n-                        LOGGER.warn(\"defaulting to script type\");\n-                        String script = ServerlessWorkflowUtils.scriptFunctionScript(\"\");\n-                        current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), script, embeddedSubProcess);\n-\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n+                        .orElseThrow(()-> new IllegalArgumentException(\"cannot find function \"+action.getFunctionRef().getRefName()));\n+                if (actionFunction.getType() != null) {                    \n+                    switch (actionFunction.getType().toLowerCase())\n+                    {\n+                        case SCRIPT_TYPE: \n+                            current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), \n+                                                         ServerlessWorkflowUtils.scriptFunctionScript(action.getFunctionRef().getParameters().get(SCRIPT_TYPE_PARAM)), embeddedSubProcess);\n+                            break;\n+                        case  SYSOUT_TYPE:\n+                            current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), \n+                                                         ServerlessWorkflowUtils.sysOutFunctionScript(action.getFunctionRef().getParameters().get(SYSOUT_TYPE_PARAM)), embeddedSubProcess);\n+                            break;\n+                        case SERVICE_TYPE:\n+                            current = factory.serviceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            break;\n+                        case DECISION_TYPE:\n+                            current = factory.humanTaskNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, process, embeddedSubProcess);\n+                            break;\n+                        case RULE_TYPE: \n+                            current = factory.ruleSetNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            break;\n+                        case INTEGRATION_TYPE:\n+                            current = factory.camelRouteServiceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            break;\n+                        case REST_TYPE: \n+                            current = factory.restServiceNode (idCounter.getAndIncrement(), action.getFunctionRef(), actionFunction,embeddedSubProcess);", "originalCommit": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "941b55c7ac57e22a4d42add813a798ff23a5a556", "chunk": "diff --git a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java b/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java\nindex d4e4a5ccec..a21ae09785 100644\n--- a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java\n+++ b/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java\n\n@@ -408,65 +408,128 @@ public class ServerlessWorkflowParser {\n         }\n     }\n \n-    protected void handleActions(List<Function> workflowFunctions, List<Action> actions, RuleFlowProcess process, CompositeContextNode embeddedSubProcess) {\n+    protected void handleActions(List<Function> workflowFunctions,\n+                                 List<Action> actions,\n+                                 RuleFlowProcess process,\n+                                 CompositeContextNode embeddedSubProcess) {\n         if (actions != null && !actions.isEmpty()) {\n-            StartNode embeddedStartNode = factory.startNode(idCounter.getAndIncrement(), \"EmbeddedStart\", embeddedSubProcess);\n+            StartNode embeddedStartNode =\n+                    factory.startNode(idCounter.getAndIncrement(), \"EmbeddedStart\", embeddedSubProcess);\n             Node start = embeddedStartNode;\n             Node current = null;\n \n             for (Action action : actions) {\n-                Function actionFunction = workflowFunctions.stream()\n-                        .filter(wf -> wf.getName().equals(action.getFunctionRef().getRefName()))\n-                        .findFirst()\n-                        .orElseThrow(()-> new IllegalArgumentException(\"cannot find function \"+action.getFunctionRef().getRefName()));\n-                if (actionFunction.getType() != null) {                    \n-                    switch (actionFunction.getType().toLowerCase())\n-                    {\n-                        case SCRIPT_TYPE: \n-                            current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), \n-                                                         ServerlessWorkflowUtils.scriptFunctionScript(action.getFunctionRef().getParameters().get(SCRIPT_TYPE_PARAM)), embeddedSubProcess);\n+                Function actionFunction = workflowFunctions\n+                    .stream()\n+                    .filter(wf -> wf.getName().equals(action.getFunctionRef().getRefName()))\n+                    .findFirst()\n+                    .orElseThrow(\n+                                 () -> new IllegalArgumentException(\n+                                     \"cannot find function \" + action.getFunctionRef().getRefName()));\n+                if (actionFunction.getType() != null) {\n+                    switch (actionFunction.getType().toLowerCase()) {\n+                        case SCRIPT_TYPE:\n+                            current = factory\n+                                .scriptNode(\n+                                            idCounter.getAndIncrement(),\n+                                            action.getFunctionRef().getRefName(),\n+                                            ServerlessWorkflowUtils\n+                                                .scriptFunctionScript(\n+                                                                      action\n+                                                                          .getFunctionRef()\n+                                                                          .getParameters()\n+                                                                          .get(SCRIPT_TYPE_PARAM)),\n+                                            embeddedSubProcess);\n                             break;\n-                        case  SYSOUT_TYPE:\n-                            current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), \n-                                                         ServerlessWorkflowUtils.sysOutFunctionScript(action.getFunctionRef().getParameters().get(SYSOUT_TYPE_PARAM)), embeddedSubProcess);\n+                        case SYSOUT_TYPE:\n+                            current = factory\n+                                .scriptNode(\n+                                            idCounter.getAndIncrement(),\n+                                            action.getFunctionRef().getRefName(),\n+                                            ServerlessWorkflowUtils\n+                                                .sysOutFunctionScript(\n+                                                                      action\n+                                                                          .getFunctionRef()\n+                                                                          .getParameters()\n+                                                                          .get(SYSOUT_TYPE_PARAM)),\n+                                            embeddedSubProcess);\n                             break;\n                         case SERVICE_TYPE:\n-                            current = factory.serviceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            current = factory\n+                                .serviceNode(\n+                                             idCounter.getAndIncrement(),\n+                                             action.getFunctionRef().getRefName(),\n+                                             actionFunction,\n+                                             embeddedSubProcess);\n                             break;\n                         case DECISION_TYPE:\n-                            current = factory.humanTaskNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, process, embeddedSubProcess);\n+                            current = factory\n+                                .humanTaskNode(\n+                                               idCounter.getAndIncrement(),\n+                                               action.getFunctionRef().getRefName(),\n+                                               actionFunction,\n+                                               process,\n+                                               embeddedSubProcess);\n                             break;\n-                        case RULE_TYPE: \n-                            current = factory.ruleSetNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                        case RULE_TYPE:\n+                            current = factory\n+                                .ruleSetNode(\n+                                             idCounter.getAndIncrement(),\n+                                             action.getFunctionRef().getRefName(),\n+                                             actionFunction,\n+                                             embeddedSubProcess);\n                             break;\n                         case INTEGRATION_TYPE:\n-                            current = factory.camelRouteServiceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            current = factory\n+                                .camelRouteServiceNode(\n+                                                       idCounter.getAndIncrement(),\n+                                                       action.getFunctionRef().getRefName(),\n+                                                       actionFunction,\n+                                                       embeddedSubProcess);\n                             break;\n-                        case REST_TYPE: \n-                            current = factory.restServiceNode (idCounter.getAndIncrement(), action.getFunctionRef(), actionFunction,embeddedSubProcess);\n+                        case REST_TYPE:\n+                            current = factory\n+                                .restServiceNode(\n+                                                 idCounter.getAndIncrement(),\n+                                                 action.getFunctionRef(),\n+                                                 actionFunction,\n+                                                 embeddedSubProcess);\n                             break;\n                         default:\n-                            current = unsupportedNode(action,embeddedSubProcess);\n+                            current = unsupportedNode(action, embeddedSubProcess);\n                     }\n                 } else {\n-                   current = unsupportedNode(action,embeddedSubProcess);\n+                    current = unsupportedNode(action, embeddedSubProcess);\n                 }\n-                factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n+                factory\n+                    .connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n                 start = current;\n             }\n-            EndNode embeddedEndNode = factory.endNode(idCounter.getAndIncrement(), \"EmbeddedEnd\", true, embeddedSubProcess);\n+            EndNode embeddedEndNode =\n+                    factory.endNode(idCounter.getAndIncrement(), \"EmbeddedEnd\", true, embeddedSubProcess);\n             try {\n-                factory.connect(current.getId(), embeddedEndNode.getId(), current.getId() + \"_\" + embeddedEndNode.getId(), embeddedSubProcess);\n+                factory\n+                    .connect(\n+                             current.getId(),\n+                             embeddedEndNode.getId(),\n+                             current.getId() + \"_\" + embeddedEndNode.getId(),\n+                             embeddedSubProcess);\n             } catch (NullPointerException e) {\n                 LOGGER.warn(\"unable to connect current node to embedded end node\");\n             }\n         }\n     }\n-    \n-    private Node unsupportedNode (Action action, CompositeContextNode embeddedSubProcess) {\n-        LOGGER.warn(\"currently unsupported function type, supported types are 'script', 'sysout', 'service', 'decision', 'rule', 'integration', 'rest'\");\n+\n+    private Node unsupportedNode(Action action, CompositeContextNode embeddedSubProcess) {\n+        LOGGER\n+            .warn(\n+                  \"currently unsupported function type, supported types are 'script', 'sysout', 'service', 'decision', 'rule', 'integration', 'rest'\");\n         LOGGER.warn(\"defaulting to script type\");\n-        return factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), ServerlessWorkflowUtils.scriptFunctionScript(\"\"), embeddedSubProcess);\n+        return factory.scriptNode(\n+                        idCounter.getAndIncrement(),\n+                        action.getFunctionRef().getRefName(),\n+                        ServerlessWorkflowUtils.scriptFunctionScript(\"\"),\n+                        embeddedSubProcess);\n     }\n \n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5MzE2NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494893164", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                               current = unsupportedNode(action,embeddedSubProcess);\n          \n          \n            \n                               current = unsupportedNode(action, embeddedSubProcess);", "author": "cristianonicolai", "createdAt": "2020-09-25T10:20:47Z", "path": "jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java", "diffHunk": "@@ -403,55 +418,41 @@ protected void handleActions(List<Function> workflowFunctions, List<Action> acti\n                 Function actionFunction = workflowFunctions.stream()\n                         .filter(wf -> wf.getName().equals(action.getFunctionRef().getRefName()))\n                         .findFirst()\n-                        .get();\n-\n-                if (actionFunction.getType() != null) {\n-                    if (SCRIPT_TYPE.equalsIgnoreCase(actionFunction.getType())) {\n-                        String script = ServerlessWorkflowUtils.scriptFunctionScript(action.getFunctionRef().getParameters().get(SCRIPT_TYPE_PARAM));\n-                        current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), script, embeddedSubProcess);\n-\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else if (SYSOUT_TYPE.equalsIgnoreCase(actionFunction.getType())) {\n-                        String script = ServerlessWorkflowUtils.sysOutFunctionScript(action.getFunctionRef().getParameters().get(SYSOUT_TYPE_PARAM));\n-                        current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), script, embeddedSubProcess);\n-\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else if (SERVICE_TYPE.equalsIgnoreCase(actionFunction.getType())) {\n-                        current = factory.serviceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else if (DECISION_TYPE.equals(actionFunction.getType())) {\n-                        current = factory.humanTaskNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, process, embeddedSubProcess);\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else if (RULE_TYPE.equals(actionFunction.getType())) {\n-                        current = factory.ruleSetNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else if (INTEGRATION_TYPE.equals(actionFunction.getType())) {\n-                        current = factory.camelRouteServiceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n-                    } else {\n-                        LOGGER.warn(\"currently unsupported function type, supported types are 'script', 'sysout', 'service', 'decision', 'rule', 'integration'\");\n-                        LOGGER.warn(\"defaulting to script type\");\n-                        String script = ServerlessWorkflowUtils.scriptFunctionScript(\"\");\n-                        current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), script, embeddedSubProcess);\n-\n-                        factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                        start = current;\n+                        .orElseThrow(()-> new IllegalArgumentException(\"cannot find function \"+action.getFunctionRef().getRefName()));\n+                if (actionFunction.getType() != null) {                    \n+                    switch (actionFunction.getType().toLowerCase())\n+                    {\n+                        case SCRIPT_TYPE: \n+                            current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), \n+                                                         ServerlessWorkflowUtils.scriptFunctionScript(action.getFunctionRef().getParameters().get(SCRIPT_TYPE_PARAM)), embeddedSubProcess);\n+                            break;\n+                        case  SYSOUT_TYPE:\n+                            current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), \n+                                                         ServerlessWorkflowUtils.sysOutFunctionScript(action.getFunctionRef().getParameters().get(SYSOUT_TYPE_PARAM)), embeddedSubProcess);\n+                            break;\n+                        case SERVICE_TYPE:\n+                            current = factory.serviceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            break;\n+                        case DECISION_TYPE:\n+                            current = factory.humanTaskNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, process, embeddedSubProcess);\n+                            break;\n+                        case RULE_TYPE: \n+                            current = factory.ruleSetNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            break;\n+                        case INTEGRATION_TYPE:\n+                            current = factory.camelRouteServiceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            break;\n+                        case REST_TYPE: \n+                            current = factory.restServiceNode (idCounter.getAndIncrement(), action.getFunctionRef(), actionFunction,embeddedSubProcess);\n+                            break;\n+                        default:\n+                            current = unsupportedNode(action,embeddedSubProcess);\n                     }\n                 } else {\n-                    LOGGER.warn(\"invalid function type. supported types are 'script', 'sysout', 'service', 'decision', 'ruleunit'\");\n-                    LOGGER.warn(\"defaulting to script type\");\n-                    String script = ServerlessWorkflowUtils.scriptFunctionScript(\"\");\n-                    current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), script, embeddedSubProcess);\n-\n-                    factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n-                    start = current;\n+                   current = unsupportedNode(action,embeddedSubProcess);", "originalCommit": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "941b55c7ac57e22a4d42add813a798ff23a5a556", "chunk": "diff --git a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java b/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java\nindex d4e4a5ccec..a21ae09785 100644\n--- a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java\n+++ b/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java\n\n@@ -408,65 +408,128 @@ public class ServerlessWorkflowParser {\n         }\n     }\n \n-    protected void handleActions(List<Function> workflowFunctions, List<Action> actions, RuleFlowProcess process, CompositeContextNode embeddedSubProcess) {\n+    protected void handleActions(List<Function> workflowFunctions,\n+                                 List<Action> actions,\n+                                 RuleFlowProcess process,\n+                                 CompositeContextNode embeddedSubProcess) {\n         if (actions != null && !actions.isEmpty()) {\n-            StartNode embeddedStartNode = factory.startNode(idCounter.getAndIncrement(), \"EmbeddedStart\", embeddedSubProcess);\n+            StartNode embeddedStartNode =\n+                    factory.startNode(idCounter.getAndIncrement(), \"EmbeddedStart\", embeddedSubProcess);\n             Node start = embeddedStartNode;\n             Node current = null;\n \n             for (Action action : actions) {\n-                Function actionFunction = workflowFunctions.stream()\n-                        .filter(wf -> wf.getName().equals(action.getFunctionRef().getRefName()))\n-                        .findFirst()\n-                        .orElseThrow(()-> new IllegalArgumentException(\"cannot find function \"+action.getFunctionRef().getRefName()));\n-                if (actionFunction.getType() != null) {                    \n-                    switch (actionFunction.getType().toLowerCase())\n-                    {\n-                        case SCRIPT_TYPE: \n-                            current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), \n-                                                         ServerlessWorkflowUtils.scriptFunctionScript(action.getFunctionRef().getParameters().get(SCRIPT_TYPE_PARAM)), embeddedSubProcess);\n+                Function actionFunction = workflowFunctions\n+                    .stream()\n+                    .filter(wf -> wf.getName().equals(action.getFunctionRef().getRefName()))\n+                    .findFirst()\n+                    .orElseThrow(\n+                                 () -> new IllegalArgumentException(\n+                                     \"cannot find function \" + action.getFunctionRef().getRefName()));\n+                if (actionFunction.getType() != null) {\n+                    switch (actionFunction.getType().toLowerCase()) {\n+                        case SCRIPT_TYPE:\n+                            current = factory\n+                                .scriptNode(\n+                                            idCounter.getAndIncrement(),\n+                                            action.getFunctionRef().getRefName(),\n+                                            ServerlessWorkflowUtils\n+                                                .scriptFunctionScript(\n+                                                                      action\n+                                                                          .getFunctionRef()\n+                                                                          .getParameters()\n+                                                                          .get(SCRIPT_TYPE_PARAM)),\n+                                            embeddedSubProcess);\n                             break;\n-                        case  SYSOUT_TYPE:\n-                            current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), \n-                                                         ServerlessWorkflowUtils.sysOutFunctionScript(action.getFunctionRef().getParameters().get(SYSOUT_TYPE_PARAM)), embeddedSubProcess);\n+                        case SYSOUT_TYPE:\n+                            current = factory\n+                                .scriptNode(\n+                                            idCounter.getAndIncrement(),\n+                                            action.getFunctionRef().getRefName(),\n+                                            ServerlessWorkflowUtils\n+                                                .sysOutFunctionScript(\n+                                                                      action\n+                                                                          .getFunctionRef()\n+                                                                          .getParameters()\n+                                                                          .get(SYSOUT_TYPE_PARAM)),\n+                                            embeddedSubProcess);\n                             break;\n                         case SERVICE_TYPE:\n-                            current = factory.serviceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            current = factory\n+                                .serviceNode(\n+                                             idCounter.getAndIncrement(),\n+                                             action.getFunctionRef().getRefName(),\n+                                             actionFunction,\n+                                             embeddedSubProcess);\n                             break;\n                         case DECISION_TYPE:\n-                            current = factory.humanTaskNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, process, embeddedSubProcess);\n+                            current = factory\n+                                .humanTaskNode(\n+                                               idCounter.getAndIncrement(),\n+                                               action.getFunctionRef().getRefName(),\n+                                               actionFunction,\n+                                               process,\n+                                               embeddedSubProcess);\n                             break;\n-                        case RULE_TYPE: \n-                            current = factory.ruleSetNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                        case RULE_TYPE:\n+                            current = factory\n+                                .ruleSetNode(\n+                                             idCounter.getAndIncrement(),\n+                                             action.getFunctionRef().getRefName(),\n+                                             actionFunction,\n+                                             embeddedSubProcess);\n                             break;\n                         case INTEGRATION_TYPE:\n-                            current = factory.camelRouteServiceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            current = factory\n+                                .camelRouteServiceNode(\n+                                                       idCounter.getAndIncrement(),\n+                                                       action.getFunctionRef().getRefName(),\n+                                                       actionFunction,\n+                                                       embeddedSubProcess);\n                             break;\n-                        case REST_TYPE: \n-                            current = factory.restServiceNode (idCounter.getAndIncrement(), action.getFunctionRef(), actionFunction,embeddedSubProcess);\n+                        case REST_TYPE:\n+                            current = factory\n+                                .restServiceNode(\n+                                                 idCounter.getAndIncrement(),\n+                                                 action.getFunctionRef(),\n+                                                 actionFunction,\n+                                                 embeddedSubProcess);\n                             break;\n                         default:\n-                            current = unsupportedNode(action,embeddedSubProcess);\n+                            current = unsupportedNode(action, embeddedSubProcess);\n                     }\n                 } else {\n-                   current = unsupportedNode(action,embeddedSubProcess);\n+                    current = unsupportedNode(action, embeddedSubProcess);\n                 }\n-                factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n+                factory\n+                    .connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n                 start = current;\n             }\n-            EndNode embeddedEndNode = factory.endNode(idCounter.getAndIncrement(), \"EmbeddedEnd\", true, embeddedSubProcess);\n+            EndNode embeddedEndNode =\n+                    factory.endNode(idCounter.getAndIncrement(), \"EmbeddedEnd\", true, embeddedSubProcess);\n             try {\n-                factory.connect(current.getId(), embeddedEndNode.getId(), current.getId() + \"_\" + embeddedEndNode.getId(), embeddedSubProcess);\n+                factory\n+                    .connect(\n+                             current.getId(),\n+                             embeddedEndNode.getId(),\n+                             current.getId() + \"_\" + embeddedEndNode.getId(),\n+                             embeddedSubProcess);\n             } catch (NullPointerException e) {\n                 LOGGER.warn(\"unable to connect current node to embedded end node\");\n             }\n         }\n     }\n-    \n-    private Node unsupportedNode (Action action, CompositeContextNode embeddedSubProcess) {\n-        LOGGER.warn(\"currently unsupported function type, supported types are 'script', 'sysout', 'service', 'decision', 'rule', 'integration', 'rest'\");\n+\n+    private Node unsupportedNode(Action action, CompositeContextNode embeddedSubProcess) {\n+        LOGGER\n+            .warn(\n+                  \"currently unsupported function type, supported types are 'script', 'sysout', 'service', 'decision', 'rule', 'integration', 'rest'\");\n         LOGGER.warn(\"defaulting to script type\");\n-        return factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), ServerlessWorkflowUtils.scriptFunctionScript(\"\"), embeddedSubProcess);\n+        return factory.scriptNode(\n+                        idCounter.getAndIncrement(),\n+                        action.getFunctionRef().getRefName(),\n+                        ServerlessWorkflowUtils.scriptFunctionScript(\"\"),\n+                        embeddedSubProcess);\n     }\n \n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5MzM0MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494893340", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Node unsupportedNode (Action action, CompositeContextNode embeddedSubProcess) {\n          \n          \n            \n                private Node unsupportedNode(Action action, CompositeContextNode embeddedSubProcess) {", "author": "cristianonicolai", "createdAt": "2020-09-25T10:21:10Z", "path": "jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java", "diffHunk": "@@ -461,5 +462,11 @@ protected void handleActions(List<Function> workflowFunctions, List<Action> acti\n             }\n         }\n     }\n+    \n+    private Node unsupportedNode (Action action, CompositeContextNode embeddedSubProcess) {", "originalCommit": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "941b55c7ac57e22a4d42add813a798ff23a5a556", "chunk": "diff --git a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java b/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java\nindex d4e4a5ccec..a21ae09785 100644\n--- a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java\n+++ b/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/ServerlessWorkflowParser.java\n\n@@ -408,65 +408,128 @@ public class ServerlessWorkflowParser {\n         }\n     }\n \n-    protected void handleActions(List<Function> workflowFunctions, List<Action> actions, RuleFlowProcess process, CompositeContextNode embeddedSubProcess) {\n+    protected void handleActions(List<Function> workflowFunctions,\n+                                 List<Action> actions,\n+                                 RuleFlowProcess process,\n+                                 CompositeContextNode embeddedSubProcess) {\n         if (actions != null && !actions.isEmpty()) {\n-            StartNode embeddedStartNode = factory.startNode(idCounter.getAndIncrement(), \"EmbeddedStart\", embeddedSubProcess);\n+            StartNode embeddedStartNode =\n+                    factory.startNode(idCounter.getAndIncrement(), \"EmbeddedStart\", embeddedSubProcess);\n             Node start = embeddedStartNode;\n             Node current = null;\n \n             for (Action action : actions) {\n-                Function actionFunction = workflowFunctions.stream()\n-                        .filter(wf -> wf.getName().equals(action.getFunctionRef().getRefName()))\n-                        .findFirst()\n-                        .orElseThrow(()-> new IllegalArgumentException(\"cannot find function \"+action.getFunctionRef().getRefName()));\n-                if (actionFunction.getType() != null) {                    \n-                    switch (actionFunction.getType().toLowerCase())\n-                    {\n-                        case SCRIPT_TYPE: \n-                            current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), \n-                                                         ServerlessWorkflowUtils.scriptFunctionScript(action.getFunctionRef().getParameters().get(SCRIPT_TYPE_PARAM)), embeddedSubProcess);\n+                Function actionFunction = workflowFunctions\n+                    .stream()\n+                    .filter(wf -> wf.getName().equals(action.getFunctionRef().getRefName()))\n+                    .findFirst()\n+                    .orElseThrow(\n+                                 () -> new IllegalArgumentException(\n+                                     \"cannot find function \" + action.getFunctionRef().getRefName()));\n+                if (actionFunction.getType() != null) {\n+                    switch (actionFunction.getType().toLowerCase()) {\n+                        case SCRIPT_TYPE:\n+                            current = factory\n+                                .scriptNode(\n+                                            idCounter.getAndIncrement(),\n+                                            action.getFunctionRef().getRefName(),\n+                                            ServerlessWorkflowUtils\n+                                                .scriptFunctionScript(\n+                                                                      action\n+                                                                          .getFunctionRef()\n+                                                                          .getParameters()\n+                                                                          .get(SCRIPT_TYPE_PARAM)),\n+                                            embeddedSubProcess);\n                             break;\n-                        case  SYSOUT_TYPE:\n-                            current = factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), \n-                                                         ServerlessWorkflowUtils.sysOutFunctionScript(action.getFunctionRef().getParameters().get(SYSOUT_TYPE_PARAM)), embeddedSubProcess);\n+                        case SYSOUT_TYPE:\n+                            current = factory\n+                                .scriptNode(\n+                                            idCounter.getAndIncrement(),\n+                                            action.getFunctionRef().getRefName(),\n+                                            ServerlessWorkflowUtils\n+                                                .sysOutFunctionScript(\n+                                                                      action\n+                                                                          .getFunctionRef()\n+                                                                          .getParameters()\n+                                                                          .get(SYSOUT_TYPE_PARAM)),\n+                                            embeddedSubProcess);\n                             break;\n                         case SERVICE_TYPE:\n-                            current = factory.serviceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            current = factory\n+                                .serviceNode(\n+                                             idCounter.getAndIncrement(),\n+                                             action.getFunctionRef().getRefName(),\n+                                             actionFunction,\n+                                             embeddedSubProcess);\n                             break;\n                         case DECISION_TYPE:\n-                            current = factory.humanTaskNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, process, embeddedSubProcess);\n+                            current = factory\n+                                .humanTaskNode(\n+                                               idCounter.getAndIncrement(),\n+                                               action.getFunctionRef().getRefName(),\n+                                               actionFunction,\n+                                               process,\n+                                               embeddedSubProcess);\n                             break;\n-                        case RULE_TYPE: \n-                            current = factory.ruleSetNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                        case RULE_TYPE:\n+                            current = factory\n+                                .ruleSetNode(\n+                                             idCounter.getAndIncrement(),\n+                                             action.getFunctionRef().getRefName(),\n+                                             actionFunction,\n+                                             embeddedSubProcess);\n                             break;\n                         case INTEGRATION_TYPE:\n-                            current = factory.camelRouteServiceNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), actionFunction, embeddedSubProcess);\n+                            current = factory\n+                                .camelRouteServiceNode(\n+                                                       idCounter.getAndIncrement(),\n+                                                       action.getFunctionRef().getRefName(),\n+                                                       actionFunction,\n+                                                       embeddedSubProcess);\n                             break;\n-                        case REST_TYPE: \n-                            current = factory.restServiceNode (idCounter.getAndIncrement(), action.getFunctionRef(), actionFunction,embeddedSubProcess);\n+                        case REST_TYPE:\n+                            current = factory\n+                                .restServiceNode(\n+                                                 idCounter.getAndIncrement(),\n+                                                 action.getFunctionRef(),\n+                                                 actionFunction,\n+                                                 embeddedSubProcess);\n                             break;\n                         default:\n-                            current = unsupportedNode(action,embeddedSubProcess);\n+                            current = unsupportedNode(action, embeddedSubProcess);\n                     }\n                 } else {\n-                   current = unsupportedNode(action,embeddedSubProcess);\n+                    current = unsupportedNode(action, embeddedSubProcess);\n                 }\n-                factory.connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n+                factory\n+                    .connect(start.getId(), current.getId(), start.getId() + \"_\" + current.getId(), embeddedSubProcess);\n                 start = current;\n             }\n-            EndNode embeddedEndNode = factory.endNode(idCounter.getAndIncrement(), \"EmbeddedEnd\", true, embeddedSubProcess);\n+            EndNode embeddedEndNode =\n+                    factory.endNode(idCounter.getAndIncrement(), \"EmbeddedEnd\", true, embeddedSubProcess);\n             try {\n-                factory.connect(current.getId(), embeddedEndNode.getId(), current.getId() + \"_\" + embeddedEndNode.getId(), embeddedSubProcess);\n+                factory\n+                    .connect(\n+                             current.getId(),\n+                             embeddedEndNode.getId(),\n+                             current.getId() + \"_\" + embeddedEndNode.getId(),\n+                             embeddedSubProcess);\n             } catch (NullPointerException e) {\n                 LOGGER.warn(\"unable to connect current node to embedded end node\");\n             }\n         }\n     }\n-    \n-    private Node unsupportedNode (Action action, CompositeContextNode embeddedSubProcess) {\n-        LOGGER.warn(\"currently unsupported function type, supported types are 'script', 'sysout', 'service', 'decision', 'rule', 'integration', 'rest'\");\n+\n+    private Node unsupportedNode(Action action, CompositeContextNode embeddedSubProcess) {\n+        LOGGER\n+            .warn(\n+                  \"currently unsupported function type, supported types are 'script', 'sysout', 'service', 'decision', 'rule', 'integration', 'rest'\");\n         LOGGER.warn(\"defaulting to script type\");\n-        return factory.scriptNode(idCounter.getAndIncrement(), action.getFunctionRef().getRefName(), ServerlessWorkflowUtils.scriptFunctionScript(\"\"), embeddedSubProcess);\n+        return factory.scriptNode(\n+                        idCounter.getAndIncrement(),\n+                        action.getFunctionRef().getRefName(),\n+                        ServerlessWorkflowUtils.scriptFunctionScript(\"\"),\n+                        embeddedSubProcess);\n     }\n \n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5MzQ2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494893463", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public JsonPathExprSupplier (String jsonPathExpr) {\n          \n          \n            \n                public JsonPathExprSupplier(String jsonPathExpr) {", "author": "cristianonicolai", "createdAt": "2020-09-25T10:21:26Z", "path": "jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/JsonPathExprSupplier.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.jbpm.serverless.workflow.parser.core;\n+\n+import java.util.function.Supplier;\n+\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import org.jbpm.serverless.workflow.JsonPathResolver;\n+\n+public class JsonPathExprSupplier implements Supplier<Expression> {\n+    \n+    private String jsonPathExpr;\n+    \n+    public JsonPathExprSupplier (String jsonPathExpr) {", "originalCommit": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "941b55c7ac57e22a4d42add813a798ff23a5a556", "chunk": "diff --git a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/JsonPathExprSupplier.java b/kogito-workitems/kogito-rest-workitem/src/main/java/org/kogito/workitem/rest/jsonpath/suppliers/JsonPathExprSupplier.java\nsimilarity index 73%\nrename from jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/JsonPathExprSupplier.java\nrename to kogito-workitems/kogito-rest-workitem/src/main/java/org/kogito/workitem/rest/jsonpath/suppliers/JsonPathExprSupplier.java\nindex 210ec99efd..a140a74082 100644\n--- a/jbpm/jbpm-serverless-workflow/src/main/java/org/jbpm/serverless/workflow/parser/core/JsonPathExprSupplier.java\n+++ b/kogito-workitems/kogito-rest-workitem/src/main/java/org/kogito/workitem/rest/jsonpath/suppliers/JsonPathExprSupplier.java\n\n@@ -12,26 +12,28 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.jbpm.serverless.workflow.parser.core;\n+package org.kogito.workitem.rest.jsonpath.suppliers;\n \n import java.util.function.Supplier;\n \n import com.github.javaparser.ast.expr.Expression;\n import com.github.javaparser.ast.expr.ObjectCreationExpr;\n import com.github.javaparser.ast.expr.StringLiteralExpr;\n-import org.jbpm.serverless.workflow.JsonPathResolver;\n+import org.kogito.workitem.rest.jsonpath.functions.JsonPathResolver;\n \n public class JsonPathExprSupplier implements Supplier<Expression> {\n-    \n+\n     private String jsonPathExpr;\n-    \n-    public JsonPathExprSupplier (String jsonPathExpr) {\n+\n+    public JsonPathExprSupplier(String jsonPathExpr) {\n         this.jsonPathExpr = jsonPathExpr;\n     }\n \n     @Override\n     public Expression get() {\n-        return new ObjectCreationExpr().setType(JsonPathResolver.class.getCanonicalName()).addArgument(new StringLiteralExpr(jsonPathExpr));\n+        return new ObjectCreationExpr()\n+            .setType(JsonPathResolver.class.getCanonicalName())\n+            .addArgument(new StringLiteralExpr(jsonPathExpr));\n     }\n-    \n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5OTU1MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494899550", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .setBody(new BlockStmt().addStatement(new MethodCallExpr(\"this\",new ObjectCreationExpr().setType(serviceType))));\n          \n          \n            \n                        .setBody(new BlockStmt().addStatement(new MethodCallExpr(\"this\", new ObjectCreationExpr().setType(serviceType))));", "author": "cristianonicolai", "createdAt": "2020-09-25T10:34:07Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ServiceTaskDescriptor.java", "diffHunk": "@@ -170,9 +173,25 @@ public ClassOrInterfaceDeclaration classDeclaration() {\n                 .addImplementedType(WorkItemHandler.class.getCanonicalName());\n         ClassOrInterfaceType serviceType = new ClassOrInterfaceType(null, interfaceName);\n \n+        final String serviceName = \"service\";\n         FieldDeclaration serviceField = new FieldDeclaration()\n-                .addVariable(new VariableDeclarator(serviceType, \"service\"));\n+                .addVariable(new VariableDeclarator(serviceType, serviceName));\n         cls.addMember(serviceField);\n+        cls\n+            .addConstructor(Keyword.PUBLIC)\n+            .setBody(new BlockStmt().addStatement(new MethodCallExpr(\"this\",new ObjectCreationExpr().setType(serviceType))));", "originalCommit": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67f4c3f42a0b1fe7af7956c189c8f504827107c6", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ServiceTaskDescriptor.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ServiceTaskDescriptor.java\nindex 53fac9c226..a8f0b00ea6 100644\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ServiceTaskDescriptor.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ServiceTaskDescriptor.java\n\n@@ -179,7 +179,9 @@ public class ServiceTaskDescriptor {\n         cls.addMember(serviceField);\n         cls\n             .addConstructor(Keyword.PUBLIC)\n-            .setBody(new BlockStmt().addStatement(new MethodCallExpr(\"this\",new ObjectCreationExpr().setType(serviceType))));\n+            .setBody(\n+                     new BlockStmt()\n+                         .addStatement(new MethodCallExpr(\"this\", new ObjectCreationExpr().setType(serviceType))));\n         cls\n             .addConstructor(Keyword.PUBLIC)\n             .addParameter(serviceType, serviceName)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5OTY5NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494899694", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .computeIfAbsent(workName,RestTaskDescriptor::generateHandlerClassForService);\n          \n          \n            \n                            .computeIfAbsent(workName, RestTaskDescriptor::generateHandlerClassForService);", "author": "cristianonicolai", "createdAt": "2020-09-25T10:34:23Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java", "diffHunk": "@@ -85,8 +87,13 @@ public void visitNode(String factoryField, T node, BlockStmt body, VariableScope\n             CompilationUnit generatedHandler = d.generateHandlerClassForService();\n             metadata.getGeneratedHandlers().put(mangledName, generatedHandler);\n             workName = mangledName;\n+        } else if (workName.equals(\"Rest Task\")) {\n+            workName = RestTaskDescriptor.getClassName(metadata);\n+            metadata\n+                .getGeneratedHandlers()\n+                .computeIfAbsent(workName,RestTaskDescriptor::generateHandlerClassForService);", "originalCommit": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67f4c3f42a0b1fe7af7956c189c8f504827107c6", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\nindex ad9f1ddf72..b00b7d0f62 100644\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java\n\n@@ -91,7 +91,7 @@ public class WorkItemNodeVisitor<T extends WorkItemNode> extends AbstractNodeVis\n             workName = RestTaskDescriptor.getClassName(metadata);\n             metadata\n                 .getGeneratedHandlers()\n-                .computeIfAbsent(workName,RestTaskDescriptor::generateHandlerClassForService);\n+                .computeIfAbsent(workName, RestTaskDescriptor::generateHandlerClassForService);\n         }\n         \n         body.addStatement(getAssignedFactoryMethod(factoryField, WorkItemNodeFactory.class, getNodeId(node), getNodeKey(), new LongLiteralExpr(node.getId())))\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkzODgzMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r494938833", "bodyText": "I know it is just a template but class and constructor names should be the same :)", "author": "MarianMacik", "createdAt": "2020-09-25T11:59:06Z", "path": "jbpm/jbpm-flow-builder/src/main/resources/class-templates/RestWorkItemHandlerTemplate.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package org.jbpm.process.codegen;\n+\n+import io.vertx.ext.web.client.WebClient;\n+import io.vertx.core.Vertx;\n+import org.jbpm.process.instance.impl.rest.RestWorkItemHandler;\n+\n+public class xxxWorkItemHandler extends RestWorkItemHandler {\n+\n+    public xxxRestWorkItemHandler() {", "originalCommit": "6d143a0cc598832b7a6bd017cc2adca371754fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8faf0019038130240ca92857c4dce0c751899468", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/resources/class-templates/RestWorkItemHandlerTemplate.java b/jbpm/jbpm-flow-builder/src/main/resources/class-templates/RestWorkItemHandlerTemplate.java\nindex 440461d2e3..9310fed0dd 100644\n--- a/jbpm/jbpm-flow-builder/src/main/resources/class-templates/RestWorkItemHandlerTemplate.java\n+++ b/jbpm/jbpm-flow-builder/src/main/resources/class-templates/RestWorkItemHandlerTemplate.java\n\n@@ -2,9 +2,9 @@ package org.jbpm.process.codegen;\n \n import io.vertx.ext.web.client.WebClient;\n import io.vertx.core.Vertx;\n-import org.jbpm.process.instance.impl.rest.RestWorkItemHandler;\n+import org.kogito.workitem.rest.RestWorkItemHandler;\n \n-public class xxxWorkItemHandler extends RestWorkItemHandler {\n+public class xxxRestWorkItemHandler extends RestWorkItemHandler {\n \n     public xxxRestWorkItemHandler() {\n         this(Vertx.vertx());\n"}}, {"oid": "d186eae3d0b802f6d774a53017f5b22604bda77a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/d186eae3d0b802f6d774a53017f5b22604bda77a", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-25T16:21:46Z", "type": "forcePushed"}, {"oid": "588172c2ca3c0433510e5bb6152ada230e69387b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/588172c2ca3c0433510e5bb6152ada230e69387b", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-25T18:00:01Z", "type": "forcePushed"}, {"oid": "0f7df4fe13a9d2d83db230ee8387a42c8f3345ca", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0f7df4fe13a9d2d83db230ee8387a42c8f3345ca", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-25T18:06:20Z", "type": "forcePushed"}, {"oid": "941b55c7ac57e22a4d42add813a798ff23a5a556", "url": "https://github.com/kiegroup/kogito-runtimes/commit/941b55c7ac57e22a4d42add813a798ff23a5a556", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-25T18:23:00Z", "type": "forcePushed"}, {"oid": "8faf0019038130240ca92857c4dce0c751899468", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8faf0019038130240ca92857c4dce0c751899468", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-25T18:33:25Z", "type": "forcePushed"}, {"oid": "67f4c3f42a0b1fe7af7956c189c8f504827107c6", "url": "https://github.com/kiegroup/kogito-runtimes/commit/67f4c3f42a0b1fe7af7956c189c8f504827107c6", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-25T18:40:42Z", "type": "forcePushed"}, {"oid": "01f089c1e549ba8059dc76688f44eecfb27d15c7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/01f089c1e549ba8059dc76688f44eecfb27d15c7", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-25T18:45:13Z", "type": "forcePushed"}, {"oid": "dbc6e7f739b8a8f0eac4d92ff69feac899183259", "url": "https://github.com/kiegroup/kogito-runtimes/commit/dbc6e7f739b8a8f0eac4d92ff69feac899183259", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-25T18:50:20Z", "type": "forcePushed"}, {"oid": "bacece102d5e2c0cfd17d8a68bd476b4db62e305", "url": "https://github.com/kiegroup/kogito-runtimes/commit/bacece102d5e2c0cfd17d8a68bd476b4db62e305", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-25T18:53:24Z", "type": "forcePushed"}, {"oid": "32d8ccf86252f71b3f1bf5508b4b38a6fc4f6452", "url": "https://github.com/kiegroup/kogito-runtimes/commit/32d8ccf86252f71b3f1bf5508b4b38a6fc4f6452", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-25T20:01:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIyNTA3Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/778#discussion_r495225076", "bodyText": "I think it's better to use constants instead.", "author": "ricardozanini", "createdAt": "2020-09-25T20:52:18Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/WorkItemNodeVisitor.java", "diffHunk": "@@ -85,6 +87,11 @@ public void visitNode(String factoryField, T node, BlockStmt body, VariableScope\n             CompilationUnit generatedHandler = d.generateHandlerClassForService();\n             metadata.getGeneratedHandlers().put(mangledName, generatedHandler);\n             workName = mangledName;\n+        } else if (workName.equals(\"Rest Task\")) {", "originalCommit": "32d8ccf86252f71b3f1bf5508b4b38a6fc4f6452", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "86c7afa664ea7cd211dc57933361119fc3301d9c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/86c7afa664ea7cd211dc57933361119fc3301d9c", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-28T08:24:34Z", "type": "commit"}, {"oid": "86c7afa664ea7cd211dc57933361119fc3301d9c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/86c7afa664ea7cd211dc57933361119fc3301d9c", "message": "[KOGITO-3158] Adding RestTaskHandler", "committedDate": "2020-09-28T08:24:34Z", "type": "forcePushed"}]}