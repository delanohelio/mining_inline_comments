{"pr_number": 502, "pr_title": "[KOGITO-1968] Allow milestones to trigger completion and tests", "pr_createdAt": "2020-05-12T11:48:15Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/502", "timeline": [{"oid": "0a9fe26c9b0d0f6452f7e20027a02ffdbb9af6bd", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0a9fe26c9b0d0f6452f7e20027a02ffdbb9af6bd", "message": "[KOGITO-1968] Allow milestones to trigger completion and tests\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-12T14:33:14Z", "type": "forcePushed"}, {"oid": "49af4e0b7b7a207b0a97eb658b3d4dc8334e9f3f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/49af4e0b7b7a207b0a97eb658b3d4dc8334e9f3f", "message": "[KOGITO-1968] Allow milestones to trigger completion and tests\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-12T16:46:25Z", "type": "forcePushed"}, {"oid": "8f227e60c65322cfcf371fe3ee9ff81f8397252c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8f227e60c65322cfcf371fe3ee9ff81f8397252c", "message": "[KOGITO-1968] Allow milestones to trigger completion and tests\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-13T10:35:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3NjY1Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424376657", "bodyText": "why is this needed? if we make getAgenda() return null in the dummy implementation then you can just null check getAgenda(). Remember we want to get rid of the dummy implementation.", "author": "evacchi", "createdAt": "2020-05-13T11:51:40Z", "path": "api/kogito-api/src/main/java/org/kie/api/runtime/rule/RuleRuntime.java", "diffHunk": "@@ -45,6 +45,13 @@\n      */\n     Agenda getAgenda();\n \n+    /**\n+     * @return true if the Runtime supports the Agenda\n+     */\n+    default boolean hasAgenda() {", "originalCommit": "8f227e60c65322cfcf371fe3ee9ff81f8397252c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ3MzYwNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424473605", "bodyText": "good point, +1", "author": "tiagodolphine", "createdAt": "2020-05-13T14:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3NjY1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "298d0f68776e23a7c1bfd8bb0a9793760eacafc4", "chunk": "diff --git a/api/kogito-api/src/main/java/org/kie/api/runtime/rule/RuleRuntime.java b/api/kogito-api/src/main/java/org/kie/api/runtime/rule/RuleRuntime.java\nindex a024f6dacd..92fc5a521f 100755\n--- a/api/kogito-api/src/main/java/org/kie/api/runtime/rule/RuleRuntime.java\n+++ b/api/kogito-api/src/main/java/org/kie/api/runtime/rule/RuleRuntime.java\n\n@@ -45,13 +45,6 @@ public interface RuleRuntime\n      */\n     Agenda getAgenda();\n \n-    /**\n-     * @return true if the Runtime supports the Agenda\n-     */\n-    default boolean hasAgenda() {\n-        return true;\n-    }\n-\n     /**\n      * @return the WorkingMemoryEntryPoint instance associated with the given name.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3NzgyNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424377826", "bodyText": "memo: I wonder if we should keep these overrides in Kogito", "author": "evacchi", "createdAt": "2020-05-13T11:53:55Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "diffHunk": "@@ -142,7 +144,7 @@ public void addNodeInstance(final NodeInstance nodeInstance) {\n \n     @Override\n     public int getLevelForNode(String uniqueID) {\n-        if (\"true\".equalsIgnoreCase(System.getProperty(\"jbpm.loop.level.disabled\"))) {\n+        if (Boolean.parseBoolean(System.getProperty(\"jbpm.loop.level.disabled\"))) {", "originalCommit": "8f227e60c65322cfcf371fe3ee9ff81f8397252c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3OTI0Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424379246", "bodyText": "I can see now where rules are used, and we should probably write a short spec for this and see how we can reproduce it in the best way. Rule flow groups should be considered deprecated for Drools. Maybe we can write a \"System RuleUnit\" in the libary if these rules are static, or we could synthesize a rule unit to be used internally.", "author": "evacchi", "createdAt": "2020-05-13T11:56:36Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java", "diffHunk": "@@ -53,10 +53,13 @@ public void internalTrigger(final NodeInstance from, String type) {\n             throw new IllegalArgumentException(\n                     \"A MilestoneNode only accepts default incoming connections!\");\n         }\n-        String rule = \"RuleFlow-Milestone-\" + getProcessInstance().getProcessId()\n-                + \"-\" + getMilestoneNode().getUniqueId();\n-        boolean isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                .isRuleActiveInRuleFlowGroup(\"DROOLS_SYSTEM\", rule, getProcessInstance().getId());\n+        boolean isActive = true;\n+        if(getProcessInstance().getKnowledgeRuntime().hasAgenda()) {\n+            String rule = \"RuleFlow-Milestone-\" + getProcessInstance().getProcessId()\n+                    + \"-\" + getMilestoneNode().getUniqueId();\n+            isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n+                    .isRuleActiveInRuleFlowGroup(\"DROOLS_SYSTEM\", rule, getProcessInstance().getId());\n+        }", "originalCommit": "8f227e60c65322cfcf371fe3ee9ff81f8397252c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxMDg5NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424510895", "bodyText": "I have filed the following JIRA https://issues.redhat.com/browse/KOGITO-2168", "author": "ruromero", "createdAt": "2020-05-13T15:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3OTI0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "298d0f68776e23a7c1bfd8bb0a9793760eacafc4", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\nindex 323e837091..03f4f6696f 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\n\n@@ -54,7 +54,8 @@ public class MilestoneNodeInstance extends StateBasedNodeInstance implements Age\n                     \"A MilestoneNode only accepts default incoming connections!\");\n         }\n         boolean isActive = true;\n-        if(getProcessInstance().getKnowledgeRuntime().hasAgenda()) {\n+        // KOGITO-2168 Conditions not supported\n+        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n             String rule = \"RuleFlow-Milestone-\" + getProcessInstance().getProcessId()\n                     + \"-\" + getMilestoneNode().getUniqueId();\n             isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ4MTI5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424481292", "bodyText": "suggestion\n.filter(nodeInstance -> Objects.equals(nodeInstance.getId(), nodeInstanceId))", "author": "tiagodolphine", "createdAt": "2020-05-13T14:27:03Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "diffHunk": "@@ -193,22 +195,15 @@ public void removeNodeInstance(final NodeInstance nodeInstance) {\n \n     @Override\n     public NodeInstance getNodeInstance(String nodeInstanceId) {\n-        for (NodeInstance nodeInstance : nodeInstances) {\n-            if (nodeInstance.getId().equals(nodeInstanceId)) {\n-                return nodeInstance;\n-            }\n-        }\n-        return null;\n+        return getNodeInstance(nodeInstanceId, false);\n     }\n \n     @Override\n     public NodeInstance getNodeInstance(String nodeInstanceId, boolean recursive) {\n-        for (NodeInstance nodeInstance : getNodeInstances(recursive)) {\n-            if (nodeInstance.getId().equals(nodeInstanceId)) {\n-                return nodeInstance;\n-            }\n-        }\n-        return null;\n+        return getNodeInstances(recursive).stream()\n+                .filter(nodeInstance -> nodeInstance.getId().equals(nodeInstanceId))", "originalCommit": "8f227e60c65322cfcf371fe3ee9ff81f8397252c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc3e7ab996d726089ed6b3f50c8837c679dd8e7c", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java\nindex cc1cd08eee..2b9e302537 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java\n\n@@ -201,7 +206,7 @@ public abstract class WorkflowProcessInstanceImpl extends ProcessInstanceImpl\n     @Override\n     public NodeInstance getNodeInstance(String nodeInstanceId, boolean recursive) {\n         return getNodeInstances(recursive).stream()\n-                .filter(nodeInstance -> nodeInstance.getId().equals(nodeInstanceId))\n+                .filter(nodeInstance -> Objects.equals(nodeInstance.getId(), nodeInstanceId))\n                 .findFirst()\n                 .orElse(null);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5OTc4Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424499787", "bodyText": "trying to simplify this block... just sugestion:\nOptional.ofNullable(getProcessInstance())\n                .map(WorkflowProcessInstance::getKnowledgeRuntime)\n                .map(InternalKnowledgeRuntime::getAgenda)                \n                .filter(InternalAgenda.class::isInstance)\n                .map(InternalAgenda.class::cast)\n                .map(agenda -> {\n                    String rule =\n                            \"RuleFlow-Milestone-\" + getProcessInstance().getProcessId() + \"-\" + getMilestoneNode().getUniqueId();\n                    return agenda.isRuleActiveInRuleFlowGroup(\"DROOLS_SYSTEM\", rule, getProcessInstance().getId());\n                })\n                .orElse(true);", "author": "tiagodolphine", "createdAt": "2020-05-13T14:50:35Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java", "diffHunk": "@@ -53,10 +53,13 @@ public void internalTrigger(final NodeInstance from, String type) {\n             throw new IllegalArgumentException(\n                     \"A MilestoneNode only accepts default incoming connections!\");\n         }\n-        String rule = \"RuleFlow-Milestone-\" + getProcessInstance().getProcessId()\n-                + \"-\" + getMilestoneNode().getUniqueId();\n-        boolean isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                .isRuleActiveInRuleFlowGroup(\"DROOLS_SYSTEM\", rule, getProcessInstance().getId());\n+        boolean isActive = true;", "originalCommit": "8f227e60c65322cfcf371fe3ee9ff81f8397252c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNDI5MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424704291", "bodyText": "Although your suggestion is fancier I believe the existing code is easier to understand and maintain.", "author": "ruromero", "createdAt": "2020-05-13T20:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5OTc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNzM5NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424717394", "bodyText": "Sure, no problem, go with it, as I said just a suggestion a matter of taste, I really like and think a more functional approach is cleaner :)", "author": "tiagodolphine", "createdAt": "2020-05-13T20:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5OTc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2MjQ2OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424962469", "bodyText": "either way, this is just a refactoring of the existing code (@ruromero only added the null check around it and reformatted a bit); it doesn't really matter because I am pretty sure all this will have to be nuked in favor of rule units \ud83e\udd14", "author": "evacchi", "createdAt": "2020-05-14T08:32:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5OTc4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "298d0f68776e23a7c1bfd8bb0a9793760eacafc4", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\nindex 323e837091..03f4f6696f 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\n\n@@ -54,7 +54,8 @@ public class MilestoneNodeInstance extends StateBasedNodeInstance implements Age\n                     \"A MilestoneNode only accepts default incoming connections!\");\n         }\n         boolean isActive = true;\n-        if(getProcessInstance().getKnowledgeRuntime().hasAgenda()) {\n+        // KOGITO-2168 Conditions not supported\n+        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n             String rule = \"RuleFlow-Milestone-\" + getProcessInstance().getProcessId()\n                     + \"-\" + getMilestoneNode().getUniqueId();\n             isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNDA1Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424504052", "bodyText": "Are the castings safe? WorkflowProcess, WorkflowProcessInstance, Is it worth checking instanceof before casting?", "author": "tiagodolphine", "createdAt": "2020-05-13T14:55:50Z", "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -163,14 +164,20 @@ public void start(String trigger, String referenceId) {\n             this.status = legacyProcessInstance.getState();\n         }\n     }\n+\n+    public void complete() {\n+        if(((WorkflowProcess)legacyProcessInstance.getProcess()).isDynamic() && this.status.equals(ProcessInstance.STATE_ACTIVE)) {", "originalCommit": "8f227e60c65322cfcf371fe3ee9ff81f8397252c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNjU5OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424706599", "bodyText": "If the legacyProcessInstance.getProcess() is always returning what is generated by the legacyProcess() method coming from the codegen I'd say the only possibility is that it is a RuleFlowProcess which extends WorkflowProcessImpl", "author": "ruromero", "createdAt": "2020-05-13T20:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNDA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNzQ5MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r424717491", "bodyText": "\ud83d\udc4d", "author": "tiagodolphine", "createdAt": "2020-05-13T20:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNDA1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "0cda3ed4c1ae6d9bd2eaebaed05a8e6ba6a14a9b", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java b/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java\nindex e82e0893c7..b28015e0ce 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java\n\n@@ -167,7 +167,7 @@ public abstract class AbstractProcessInstance<T extends Model> implements Proces\n \n     public void complete() {\n         if(((WorkflowProcess)legacyProcessInstance.getProcess()).isDynamic() && this.status.equals(ProcessInstance.STATE_ACTIVE)) {\n-            ((WorkflowProcessInstance)legacyProcessInstance).setState(STATE_ACTIVE);\n+            ((WorkflowProcessInstance)legacyProcessInstance).setState(STATE_COMPLETED);\n             this.status = ProcessInstance.STATE_COMPLETED;\n         }\n     }\n"}}, {"oid": "298d0f68776e23a7c1bfd8bb0a9793760eacafc4", "url": "https://github.com/kiegroup/kogito-runtimes/commit/298d0f68776e23a7c1bfd8bb0a9793760eacafc4", "message": "[KOGITO-1968] DummyKnowledgeRuntime#getAgenda return null\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-13T15:04:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzODgwNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r426838807", "bodyText": "So Kogito process instance is completed, but legacy process instance is still active? Is that right? If so, why is it like that? I understand that cases are basically never complete as we discussed it on Zulip, but this can be considered as an inconsistency - one status is completed, the second one is active.", "author": "MarianMacik", "createdAt": "2020-05-18T19:11:33Z", "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -163,14 +164,20 @@ public void start(String trigger, String referenceId) {\n             this.status = legacyProcessInstance.getState();\n         }\n     }\n+\n+    public void complete() {\n+        if(((WorkflowProcess)legacyProcessInstance.getProcess()).isDynamic() && this.status.equals(ProcessInstance.STATE_ACTIVE)) {\n+            ((WorkflowProcessInstance)legacyProcessInstance).setState(STATE_ACTIVE);\n+            this.status = ProcessInstance.STATE_COMPLETED;", "originalCommit": "298d0f68776e23a7c1bfd8bb0a9793760eacafc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg0MTcyNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r426841724", "bodyText": "Also btw - this feature is already present in 7.x? I think that we can there only close or destroy a case instance, right? We cannot explicitly complete it...", "author": "MarianMacik", "createdAt": "2020-05-18T19:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzODgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MzkyMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r426863920", "bodyText": "Ad-hoc processes, i.e. cases, can't autocomplete unless there is a terminate end node but this is not common in cases where knowledge workers might want to add/update information in the case or trigger discretionary tasks. That means there wasn't a mechanism to close a case.\nRegarding the naming. In 7.x you could close a case but here we are not explicitly using a Case model naming. We're still talking about processes and processes from the ACTIVE state move to the COMPLETED state, thus this action. Do you agree?", "author": "ruromero", "createdAt": "2020-05-18T20:03:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzODgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE1MTQ2Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r427151462", "bodyText": "I agree, but somewhat I missed the explanation why the legacy process is still being kept ACTIVE :)", "author": "MarianMacik", "createdAt": "2020-05-19T09:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzODgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI4MzU4MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r427283581", "bodyText": "I get your point and that had to be aligned indeed. Thanks for your thorough review.", "author": "ruromero", "createdAt": "2020-05-19T13:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzODgwNw=="}], "type": "inlineReview", "revised_code": {"commit": "0cda3ed4c1ae6d9bd2eaebaed05a8e6ba6a14a9b", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java b/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java\nindex e82e0893c7..b28015e0ce 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java\n\n@@ -167,7 +167,7 @@ public abstract class AbstractProcessInstance<T extends Model> implements Proces\n \n     public void complete() {\n         if(((WorkflowProcess)legacyProcessInstance.getProcess()).isDynamic() && this.status.equals(ProcessInstance.STATE_ACTIVE)) {\n-            ((WorkflowProcessInstance)legacyProcessInstance).setState(STATE_ACTIVE);\n+            ((WorkflowProcessInstance)legacyProcessInstance).setState(STATE_COMPLETED);\n             this.status = ProcessInstance.STATE_COMPLETED;\n         }\n     }\n"}}, {"oid": "0cda3ed4c1ae6d9bd2eaebaed05a8e6ba6a14a9b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0cda3ed4c1ae6d9bd2eaebaed05a8e6ba6a14a9b", "message": "[KOGITO-1968] Validate both states\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-19T15:34:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ5NTQzMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428495432", "bodyText": "from a perspective that processes will have at least some degree of structure, would it still make sense to allow it to be completed at any time? Thinking if we should first try to go for having a minial path that demonstrates how the process will be completed, not so much like a case close action. @ruromero @krisv wdyt?", "author": "cristianonicolai", "createdAt": "2020-05-21T07:39:37Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "diffHunk": "@@ -65,7 +65,12 @@\n      * @param referenceId optional reference id that points to a another  component triggering this instance\n      */\n     void startFrom(String nodeId, String referenceId);\n-    \n+\n+    /**\n+     * Completes a dynamic process that is in the ACTIVE state.\n+     */\n+    void complete();", "originalCommit": "9186456f1fefeb02b3349b7ba2013894aa9ed3d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUxNjEzMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428516131", "bodyText": "I think this is something we need at this point and we can adapt later on. Dynamic processes need a way to be completed.", "author": "ruromero", "createdAt": "2020-05-21T08:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ5NTQzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYxODQ1Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428618456", "bodyText": "@ruromero sure, in the example you created the test can be completed once the milestone is achieved, we dont necessarly want to manually have to call complete in a process. We're trying to give some flexibility but not complete freedom, to me the process needs to to handle a expected path to end, otherwise people can still abort the process instance.", "author": "cristianonicolai", "createdAt": "2020-05-21T12:22:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ5NTQzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYzNTE1MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428635151", "bodyText": "Complete only affects dynamic processes that are active. How do you want to limit it's usage? By only allow processes without any active node to be completed for example?", "author": "ruromero", "createdAt": "2020-05-21T12:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ5NTQzMg=="}], "type": "inlineReview", "revised_code": {"commit": "79cd7a1ad0de3a91eea6046e7da195704265c0bc", "chunk": "diff --git a/api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java b/api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java\nindex d60abbad6a..04c7635f56 100644\n--- a/api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java\n+++ b/api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java\n\n@@ -24,41 +25,39 @@ import org.kie.api.runtime.process.WorkItemNotFoundException;\n import org.kie.kogito.process.workitem.Policy;\n import org.kie.kogito.process.workitem.Transition;\n \n-\n-\n public interface ProcessInstance<T> {\n-    \n+\n     int STATE_PENDING   = 0;\n     int STATE_ACTIVE    = 1;\n     int STATE_COMPLETED = 2;\n     int STATE_ABORTED   = 3;\n     int STATE_SUSPENDED = 4;\n     int STATE_ERROR = 5;\n-    \n+\n     /**\n      * Returns process definition associated with this process instance\n      * @return process definition of this process instance\n      */\n     Process<T> process();\n-    \n+\n     /**\n      * Starts process instance\n      */\n     void start();\n-    \n+\n     /**\n      * Starts process instance with trigger\n      * @param trigger name of the trigger that will indicate what start node to trigger\n      * @param referenceId optional reference id that points to a another  component triggering this instance\n      */\n     void start(String trigger, String referenceId);\n-    \n+\n     /**\n      * Starts process instance from given node\n      * @param nodeId node id that should be used as the first node\n      */\n     void startFrom(String nodeId);\n-    \n+\n     /**\n      * Starts process instance from given node\n      * @param nodeId node id that should be used as the first node\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ5NzQxNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428497415", "bodyText": "@ruromero is there any point for us to add this if we wont actually use this approach with the internal agenda? I guess we should simply set active to true.", "author": "cristianonicolai", "createdAt": "2020-05-21T07:44:13Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java", "diffHunk": "@@ -53,10 +53,14 @@ public void internalTrigger(final NodeInstance from, String type) {\n             throw new IllegalArgumentException(\n                     \"A MilestoneNode only accepts default incoming connections!\");\n         }\n-        String rule = \"RuleFlow-Milestone-\" + getProcessInstance().getProcessId()\n-                + \"-\" + getMilestoneNode().getUniqueId();\n-        boolean isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                .isRuleActiveInRuleFlowGroup(\"DROOLS_SYSTEM\", rule, getProcessInstance().getId());\n+        boolean isActive = true;\n+        // KOGITO-2168 Conditions not supported\n+        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {", "originalCommit": "9186456f1fefeb02b3349b7ba2013894aa9ed3d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUwNTk1NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428505954", "bodyText": "I didn't want to remove the old functionality because other tests still rely on the agenda. Until we don't provide a replacement for conditions I prefer to keep it this way.", "author": "ruromero", "createdAt": "2020-05-21T08:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ5NzQxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYxOTI2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428619263", "bodyText": "so maybe we should remove the old tests as well :) My concern is to bring things that we wont/dont need, removing later is way more complicated to assess.", "author": "cristianonicolai", "createdAt": "2020-05-21T12:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ5NzQxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYzNjYzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428636636", "bodyText": "I'm always up for removing stuff. I just didn't dare to do it without a second opinion.", "author": "ruromero", "createdAt": "2020-05-21T13:01:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ5NzQxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NjE4NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428666185", "bodyText": "sorry, wrong gitlog :P looks fine as is", "author": "cristianonicolai", "createdAt": "2020-05-21T13:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ5NzQxNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ5ODMwMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428498303", "bodyText": "@ruromero should the actual milestone state be checked here?", "author": "cristianonicolai", "createdAt": "2020-05-21T07:46:24Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.impl;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class MilestoneTest extends AbstractCodegenTest {\n+\n+    @Test\n+    void testSimpleMilestone() throws Exception {", "originalCommit": "9186456f1fefeb02b3349b7ba2013894aa9ed3d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYzMzkyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428633927", "bodyText": "Check my latest changes", "author": "ruromero", "createdAt": "2020-05-21T12:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ5ODMwMw=="}], "type": "inlineReview", "revised_code": {"commit": "79cd7a1ad0de3a91eea6046e7da195704265c0bc", "chunk": "diff --git a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\nindex e196f4b614..29b3766c5c 100644\n--- a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n+++ b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n\n@@ -15,42 +15,59 @@\n \n package org.kie.kogito.process.impl;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n \n+import org.jbpm.ruleflow.core.Metadata;\n+import org.jbpm.ruleflow.instance.RuleFlowProcessInstance;\n import org.junit.jupiter.api.Test;\n import org.kie.kogito.Application;\n import org.kie.kogito.Model;\n import org.kie.kogito.codegen.AbstractCodegenTest;\n import org.kie.kogito.process.Process;\n import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.CaseNodeInstance;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n class MilestoneTest extends AbstractCodegenTest {\n \n     @Test\n     void testSimpleMilestone() throws Exception {\n-\n         Application app = generateCodeProcessesOnly(\"cases/SimpleMilestone.bpmn\");\n         assertThat(app).isNotNull();\n \n         Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleMilestone\");\n-\n-        Model m = p.createModel();\n-        Map<String, Object> parameters = new HashMap<>();\n-        m.fromMap(parameters);\n-        ProcessInstance<?> processInstance = p.createInstance(m);\n-\n-        assertState(processInstance, ProcessInstance.STATE_PENDING);\n-        processInstance.complete();\n+        ProcessInstance<?> processInstance = p.createInstance(p.createModel());\n         assertState(processInstance, ProcessInstance.STATE_PENDING);\n \n-        processInstance.start();\n-        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n+        Collection<CaseNodeInstance> milestones = processInstance.milestones();\n+        assertThat(milestones.size()).isEqualTo(1);\n+        CaseNodeInstance milestone = milestones.iterator().next();\n+        assertThat(milestone).isNotNull();\n+        assertThat(milestone.getName()).isEqualTo(\"Milestone1\");\n+        assertThat(milestone.getStatus()).isEqualByComparingTo(CaseNodeInstance.Status.Available);\n \n-        processInstance.complete();\n+        processInstance.start();\n         assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+\n+        milestones = processInstance.milestones();\n+        assertThat(milestones.size()).isEqualTo(1);\n+        milestone = milestones.iterator().next();\n+        assertThat(milestone).isNotNull();\n+        assertThat(milestone.getName()).isEqualTo(\"Milestone1\");\n+        assertThat(milestone.getStatus()).isEqualByComparingTo(CaseNodeInstance.Status.Completed);\n+\n+        RuleFlowProcessInstance legacyProcessInstance = (RuleFlowProcessInstance) ((AbstractProcessInstance<?>) processInstance).legacyProcessInstance;\n+        assertThat(legacyProcessInstance.getNodeInstances()).isEmpty();\n+        assertThat(legacyProcessInstance.getNodeIdInError()).isNullOrEmpty();\n+        Optional<String> milestoneId = Stream.of(legacyProcessInstance.getNodeContainer().getNodes()).filter(node -> node.getName().equals(\"Milestone1\")).map(n -> (String) n.getMetaData().get(Metadata.UNIQUE_ID)).findFirst();\n+        assertTrue(milestoneId.isPresent());\n+        assertThat(legacyProcessInstance.getCompletedNodeIds()).contains(milestoneId.get());\n     }\n \n     private void assertState(ProcessInstance<?> processInstance, int state) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMDEzNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428620137", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ProcessInstance<?> processInstance = p.createInstance(m);\n          \n          \n            \n                    ProcessInstance<?> processInstance = p.createInstance(p.createInstance(p.createModel()));", "author": "cristianonicolai", "createdAt": "2020-05-21T12:25:59Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.impl;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.jbpm.ruleflow.core.Metadata;\n+import org.jbpm.ruleflow.instance.RuleFlowProcessInstance;\n+import org.jbpm.workflow.core.Node;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class MilestoneTest extends AbstractCodegenTest {\n+\n+    @Test\n+    void testSimpleMilestone() throws Exception {\n+\n+        Application app = generateCodeProcessesOnly(\"cases/SimpleMilestone.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleMilestone\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        m.fromMap(parameters);\n+        ProcessInstance<?> processInstance = p.createInstance(m);", "originalCommit": "7c0d50cf64a0fe1f340e8b18eee53676627d5379", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY0Mzk1MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428643950", "bodyText": "Not exactly this but I see your point", "author": "ruromero", "createdAt": "2020-05-21T13:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMDEzNw=="}], "type": "inlineReview", "revised_code": {"commit": "79cd7a1ad0de3a91eea6046e7da195704265c0bc", "chunk": "diff --git a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\nindex a05bd37231..29b3766c5c 100644\n--- a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n+++ b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n\n@@ -15,55 +15,59 @@\n \n package org.kie.kogito.process.impl;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Collection;\n+import java.util.Date;\n import java.util.Optional;\n import java.util.stream.Stream;\n \n import org.jbpm.ruleflow.core.Metadata;\n import org.jbpm.ruleflow.instance.RuleFlowProcessInstance;\n-import org.jbpm.workflow.core.Node;\n import org.junit.jupiter.api.Test;\n import org.kie.kogito.Application;\n import org.kie.kogito.Model;\n import org.kie.kogito.codegen.AbstractCodegenTest;\n import org.kie.kogito.process.Process;\n import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.CaseNodeInstance;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n class MilestoneTest extends AbstractCodegenTest {\n \n     @Test\n     void testSimpleMilestone() throws Exception {\n-\n         Application app = generateCodeProcessesOnly(\"cases/SimpleMilestone.bpmn\");\n         assertThat(app).isNotNull();\n \n         Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleMilestone\");\n-\n-        Model m = p.createModel();\n-        Map<String, Object> parameters = new HashMap<>();\n-        m.fromMap(parameters);\n-        ProcessInstance<?> processInstance = p.createInstance(m);\n-\n-        assertState(processInstance, ProcessInstance.STATE_PENDING);\n-        processInstance.complete();\n+        ProcessInstance<?> processInstance = p.createInstance(p.createModel());\n         assertState(processInstance, ProcessInstance.STATE_PENDING);\n \n+        Collection<CaseNodeInstance> milestones = processInstance.milestones();\n+        assertThat(milestones.size()).isEqualTo(1);\n+        CaseNodeInstance milestone = milestones.iterator().next();\n+        assertThat(milestone).isNotNull();\n+        assertThat(milestone.getName()).isEqualTo(\"Milestone1\");\n+        assertThat(milestone.getStatus()).isEqualByComparingTo(CaseNodeInstance.Status.Available);\n+\n         processInstance.start();\n-        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n-        \n-        RuleFlowProcessInstance legacyProcessInstance = (RuleFlowProcessInstance)((AbstractProcessInstance<?>) processInstance).legacyProcessInstance;\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+\n+        milestones = processInstance.milestones();\n+        assertThat(milestones.size()).isEqualTo(1);\n+        milestone = milestones.iterator().next();\n+        assertThat(milestone).isNotNull();\n+        assertThat(milestone.getName()).isEqualTo(\"Milestone1\");\n+        assertThat(milestone.getStatus()).isEqualByComparingTo(CaseNodeInstance.Status.Completed);\n+\n+        RuleFlowProcessInstance legacyProcessInstance = (RuleFlowProcessInstance) ((AbstractProcessInstance<?>) processInstance).legacyProcessInstance;\n         assertThat(legacyProcessInstance.getNodeInstances()).isEmpty();\n         assertThat(legacyProcessInstance.getNodeIdInError()).isNullOrEmpty();\n-        Optional<String> milestoneId = Stream.of(legacyProcessInstance.getNodeContainer().getNodes()).filter(node -> node.getName().equals(\"Milestone1\")).map(n -> (String)n.getMetaData().get(Metadata.UNIQUE_ID)).findFirst();\n+        Optional<String> milestoneId = Stream.of(legacyProcessInstance.getNodeContainer().getNodes()).filter(node -> node.getName().equals(\"Milestone1\")).map(n -> (String) n.getMetaData().get(Metadata.UNIQUE_ID)).findFirst();\n         assertTrue(milestoneId.isPresent());\n         assertThat(legacyProcessInstance.getCompletedNodeIds()).contains(milestoneId.get());\n-\n-        processInstance.complete();\n-        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n     }\n \n     private void assertState(ProcessInstance<?> processInstance, int state) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMjE4MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428622180", "bodyText": "I think you can simplify the status check by doing:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertState(processInstance, ProcessInstance.STATE_PENDING);\n          \n          \n            \n            assertThat(processInstance.status()).isEqualTo(ProcessInstance.STATE_PENDING);", "author": "cristianonicolai", "createdAt": "2020-05-21T12:30:34Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.impl;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.jbpm.ruleflow.core.Metadata;\n+import org.jbpm.ruleflow.instance.RuleFlowProcessInstance;\n+import org.jbpm.workflow.core.Node;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class MilestoneTest extends AbstractCodegenTest {\n+\n+    @Test\n+    void testSimpleMilestone() throws Exception {\n+\n+        Application app = generateCodeProcessesOnly(\"cases/SimpleMilestone.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleMilestone\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        m.fromMap(parameters);\n+        ProcessInstance<?> processInstance = p.createInstance(m);\n+\n+        assertState(processInstance, ProcessInstance.STATE_PENDING);", "originalCommit": "7c0d50cf64a0fe1f340e8b18eee53676627d5379", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY0MTYxOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428641619", "bodyText": "I want to make sure the state in the processInstance and in the legacyProcessInstance are in sync", "author": "ruromero", "createdAt": "2020-05-21T13:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMjE4MA=="}], "type": "inlineReview", "revised_code": {"commit": "79cd7a1ad0de3a91eea6046e7da195704265c0bc", "chunk": "diff --git a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\nindex a05bd37231..29b3766c5c 100644\n--- a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n+++ b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n\n@@ -15,55 +15,59 @@\n \n package org.kie.kogito.process.impl;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Collection;\n+import java.util.Date;\n import java.util.Optional;\n import java.util.stream.Stream;\n \n import org.jbpm.ruleflow.core.Metadata;\n import org.jbpm.ruleflow.instance.RuleFlowProcessInstance;\n-import org.jbpm.workflow.core.Node;\n import org.junit.jupiter.api.Test;\n import org.kie.kogito.Application;\n import org.kie.kogito.Model;\n import org.kie.kogito.codegen.AbstractCodegenTest;\n import org.kie.kogito.process.Process;\n import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.CaseNodeInstance;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n class MilestoneTest extends AbstractCodegenTest {\n \n     @Test\n     void testSimpleMilestone() throws Exception {\n-\n         Application app = generateCodeProcessesOnly(\"cases/SimpleMilestone.bpmn\");\n         assertThat(app).isNotNull();\n \n         Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleMilestone\");\n-\n-        Model m = p.createModel();\n-        Map<String, Object> parameters = new HashMap<>();\n-        m.fromMap(parameters);\n-        ProcessInstance<?> processInstance = p.createInstance(m);\n-\n-        assertState(processInstance, ProcessInstance.STATE_PENDING);\n-        processInstance.complete();\n+        ProcessInstance<?> processInstance = p.createInstance(p.createModel());\n         assertState(processInstance, ProcessInstance.STATE_PENDING);\n \n+        Collection<CaseNodeInstance> milestones = processInstance.milestones();\n+        assertThat(milestones.size()).isEqualTo(1);\n+        CaseNodeInstance milestone = milestones.iterator().next();\n+        assertThat(milestone).isNotNull();\n+        assertThat(milestone.getName()).isEqualTo(\"Milestone1\");\n+        assertThat(milestone.getStatus()).isEqualByComparingTo(CaseNodeInstance.Status.Available);\n+\n         processInstance.start();\n-        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n-        \n-        RuleFlowProcessInstance legacyProcessInstance = (RuleFlowProcessInstance)((AbstractProcessInstance<?>) processInstance).legacyProcessInstance;\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+\n+        milestones = processInstance.milestones();\n+        assertThat(milestones.size()).isEqualTo(1);\n+        milestone = milestones.iterator().next();\n+        assertThat(milestone).isNotNull();\n+        assertThat(milestone.getName()).isEqualTo(\"Milestone1\");\n+        assertThat(milestone.getStatus()).isEqualByComparingTo(CaseNodeInstance.Status.Completed);\n+\n+        RuleFlowProcessInstance legacyProcessInstance = (RuleFlowProcessInstance) ((AbstractProcessInstance<?>) processInstance).legacyProcessInstance;\n         assertThat(legacyProcessInstance.getNodeInstances()).isEmpty();\n         assertThat(legacyProcessInstance.getNodeIdInError()).isNullOrEmpty();\n-        Optional<String> milestoneId = Stream.of(legacyProcessInstance.getNodeContainer().getNodes()).filter(node -> node.getName().equals(\"Milestone1\")).map(n -> (String)n.getMetaData().get(Metadata.UNIQUE_ID)).findFirst();\n+        Optional<String> milestoneId = Stream.of(legacyProcessInstance.getNodeContainer().getNodes()).filter(node -> node.getName().equals(\"Milestone1\")).map(n -> (String) n.getMetaData().get(Metadata.UNIQUE_ID)).findFirst();\n         assertTrue(milestoneId.isPresent());\n         assertThat(legacyProcessInstance.getCompletedNodeIds()).contains(milestoneId.get());\n-\n-        processInstance.complete();\n-        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n     }\n \n     private void assertState(ProcessInstance<?> processInstance, int state) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMjkxOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428622918", "bodyText": "Im not sure what's the point in regards to testing milestones to call complete here, I would recommend removing it.", "author": "cristianonicolai", "createdAt": "2020-05-21T12:32:13Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.impl;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.jbpm.ruleflow.core.Metadata;\n+import org.jbpm.ruleflow.instance.RuleFlowProcessInstance;\n+import org.jbpm.workflow.core.Node;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class MilestoneTest extends AbstractCodegenTest {\n+\n+    @Test\n+    void testSimpleMilestone() throws Exception {\n+\n+        Application app = generateCodeProcessesOnly(\"cases/SimpleMilestone.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleMilestone\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        m.fromMap(parameters);\n+        ProcessInstance<?> processInstance = p.createInstance(m);\n+\n+        assertState(processInstance, ProcessInstance.STATE_PENDING);\n+        processInstance.complete();", "originalCommit": "7c0d50cf64a0fe1f340e8b18eee53676627d5379", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc4MDMwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428780304", "bodyText": "As discussed I have removed the complete method. A terminate end node must be present in order for the dynamic process to complete", "author": "ruromero", "createdAt": "2020-05-21T16:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMjkxOA=="}], "type": "inlineReview", "revised_code": {"commit": "79cd7a1ad0de3a91eea6046e7da195704265c0bc", "chunk": "diff --git a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\nindex a05bd37231..29b3766c5c 100644\n--- a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n+++ b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n\n@@ -15,55 +15,59 @@\n \n package org.kie.kogito.process.impl;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Collection;\n+import java.util.Date;\n import java.util.Optional;\n import java.util.stream.Stream;\n \n import org.jbpm.ruleflow.core.Metadata;\n import org.jbpm.ruleflow.instance.RuleFlowProcessInstance;\n-import org.jbpm.workflow.core.Node;\n import org.junit.jupiter.api.Test;\n import org.kie.kogito.Application;\n import org.kie.kogito.Model;\n import org.kie.kogito.codegen.AbstractCodegenTest;\n import org.kie.kogito.process.Process;\n import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.CaseNodeInstance;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n class MilestoneTest extends AbstractCodegenTest {\n \n     @Test\n     void testSimpleMilestone() throws Exception {\n-\n         Application app = generateCodeProcessesOnly(\"cases/SimpleMilestone.bpmn\");\n         assertThat(app).isNotNull();\n \n         Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleMilestone\");\n-\n-        Model m = p.createModel();\n-        Map<String, Object> parameters = new HashMap<>();\n-        m.fromMap(parameters);\n-        ProcessInstance<?> processInstance = p.createInstance(m);\n-\n-        assertState(processInstance, ProcessInstance.STATE_PENDING);\n-        processInstance.complete();\n+        ProcessInstance<?> processInstance = p.createInstance(p.createModel());\n         assertState(processInstance, ProcessInstance.STATE_PENDING);\n \n+        Collection<CaseNodeInstance> milestones = processInstance.milestones();\n+        assertThat(milestones.size()).isEqualTo(1);\n+        CaseNodeInstance milestone = milestones.iterator().next();\n+        assertThat(milestone).isNotNull();\n+        assertThat(milestone.getName()).isEqualTo(\"Milestone1\");\n+        assertThat(milestone.getStatus()).isEqualByComparingTo(CaseNodeInstance.Status.Available);\n+\n         processInstance.start();\n-        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n-        \n-        RuleFlowProcessInstance legacyProcessInstance = (RuleFlowProcessInstance)((AbstractProcessInstance<?>) processInstance).legacyProcessInstance;\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+\n+        milestones = processInstance.milestones();\n+        assertThat(milestones.size()).isEqualTo(1);\n+        milestone = milestones.iterator().next();\n+        assertThat(milestone).isNotNull();\n+        assertThat(milestone.getName()).isEqualTo(\"Milestone1\");\n+        assertThat(milestone.getStatus()).isEqualByComparingTo(CaseNodeInstance.Status.Completed);\n+\n+        RuleFlowProcessInstance legacyProcessInstance = (RuleFlowProcessInstance) ((AbstractProcessInstance<?>) processInstance).legacyProcessInstance;\n         assertThat(legacyProcessInstance.getNodeInstances()).isEmpty();\n         assertThat(legacyProcessInstance.getNodeIdInError()).isNullOrEmpty();\n-        Optional<String> milestoneId = Stream.of(legacyProcessInstance.getNodeContainer().getNodes()).filter(node -> node.getName().equals(\"Milestone1\")).map(n -> (String)n.getMetaData().get(Metadata.UNIQUE_ID)).findFirst();\n+        Optional<String> milestoneId = Stream.of(legacyProcessInstance.getNodeContainer().getNodes()).filter(node -> node.getName().equals(\"Milestone1\")).map(n -> (String) n.getMetaData().get(Metadata.UNIQUE_ID)).findFirst();\n         assertTrue(milestoneId.isPresent());\n         assertThat(legacyProcessInstance.getCompletedNodeIds()).contains(milestoneId.get());\n-\n-        processInstance.complete();\n-        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n     }\n \n     private void assertState(ProcessInstance<?> processInstance, int state) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYzOTYxMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428639611", "bodyText": "@ruromero I guess the idea would be to add a method into RuleFlowProcessInstance with a list of miliestones, that then we could check using a status like MilestoneStatus from v7. No need to publish it in the ProcessInstance object for now.", "author": "cristianonicolai", "createdAt": "2020-05-21T13:07:44Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.impl;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.jbpm.ruleflow.core.Metadata;\n+import org.jbpm.ruleflow.instance.RuleFlowProcessInstance;\n+import org.jbpm.workflow.core.Node;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class MilestoneTest extends AbstractCodegenTest {\n+\n+    @Test\n+    void testSimpleMilestone() throws Exception {\n+\n+        Application app = generateCodeProcessesOnly(\"cases/SimpleMilestone.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleMilestone\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        m.fromMap(parameters);\n+        ProcessInstance<?> processInstance = p.createInstance(m);\n+\n+        assertState(processInstance, ProcessInstance.STATE_PENDING);\n+        processInstance.complete();\n+        assertState(processInstance, ProcessInstance.STATE_PENDING);\n+\n+        processInstance.start();\n+        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n+        \n+        RuleFlowProcessInstance legacyProcessInstance = (RuleFlowProcessInstance)((AbstractProcessInstance<?>) processInstance).legacyProcessInstance;\n+        assertThat(legacyProcessInstance.getNodeInstances()).isEmpty();\n+        assertThat(legacyProcessInstance.getNodeIdInError()).isNullOrEmpty();\n+        Optional<String> milestoneId = Stream.of(legacyProcessInstance.getNodeContainer().getNodes()).filter(node -> node.getName().equals(\"Milestone1\")).map(n -> (String)n.getMetaData().get(Metadata.UNIQUE_ID)).findFirst();", "originalCommit": "7c0d50cf64a0fe1f340e8b18eee53676627d5379", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc3OTkwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r428779904", "bodyText": "I have added the milestones method as suggested", "author": "ruromero", "createdAt": "2020-05-21T16:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYzOTYxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "79cd7a1ad0de3a91eea6046e7da195704265c0bc", "chunk": "diff --git a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\nindex a05bd37231..29b3766c5c 100644\n--- a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n+++ b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n\n@@ -15,55 +15,59 @@\n \n package org.kie.kogito.process.impl;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Collection;\n+import java.util.Date;\n import java.util.Optional;\n import java.util.stream.Stream;\n \n import org.jbpm.ruleflow.core.Metadata;\n import org.jbpm.ruleflow.instance.RuleFlowProcessInstance;\n-import org.jbpm.workflow.core.Node;\n import org.junit.jupiter.api.Test;\n import org.kie.kogito.Application;\n import org.kie.kogito.Model;\n import org.kie.kogito.codegen.AbstractCodegenTest;\n import org.kie.kogito.process.Process;\n import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.CaseNodeInstance;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n class MilestoneTest extends AbstractCodegenTest {\n \n     @Test\n     void testSimpleMilestone() throws Exception {\n-\n         Application app = generateCodeProcessesOnly(\"cases/SimpleMilestone.bpmn\");\n         assertThat(app).isNotNull();\n \n         Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleMilestone\");\n-\n-        Model m = p.createModel();\n-        Map<String, Object> parameters = new HashMap<>();\n-        m.fromMap(parameters);\n-        ProcessInstance<?> processInstance = p.createInstance(m);\n-\n-        assertState(processInstance, ProcessInstance.STATE_PENDING);\n-        processInstance.complete();\n+        ProcessInstance<?> processInstance = p.createInstance(p.createModel());\n         assertState(processInstance, ProcessInstance.STATE_PENDING);\n \n+        Collection<CaseNodeInstance> milestones = processInstance.milestones();\n+        assertThat(milestones.size()).isEqualTo(1);\n+        CaseNodeInstance milestone = milestones.iterator().next();\n+        assertThat(milestone).isNotNull();\n+        assertThat(milestone.getName()).isEqualTo(\"Milestone1\");\n+        assertThat(milestone.getStatus()).isEqualByComparingTo(CaseNodeInstance.Status.Available);\n+\n         processInstance.start();\n-        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n-        \n-        RuleFlowProcessInstance legacyProcessInstance = (RuleFlowProcessInstance)((AbstractProcessInstance<?>) processInstance).legacyProcessInstance;\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+\n+        milestones = processInstance.milestones();\n+        assertThat(milestones.size()).isEqualTo(1);\n+        milestone = milestones.iterator().next();\n+        assertThat(milestone).isNotNull();\n+        assertThat(milestone.getName()).isEqualTo(\"Milestone1\");\n+        assertThat(milestone.getStatus()).isEqualByComparingTo(CaseNodeInstance.Status.Completed);\n+\n+        RuleFlowProcessInstance legacyProcessInstance = (RuleFlowProcessInstance) ((AbstractProcessInstance<?>) processInstance).legacyProcessInstance;\n         assertThat(legacyProcessInstance.getNodeInstances()).isEmpty();\n         assertThat(legacyProcessInstance.getNodeIdInError()).isNullOrEmpty();\n-        Optional<String> milestoneId = Stream.of(legacyProcessInstance.getNodeContainer().getNodes()).filter(node -> node.getName().equals(\"Milestone1\")).map(n -> (String)n.getMetaData().get(Metadata.UNIQUE_ID)).findFirst();\n+        Optional<String> milestoneId = Stream.of(legacyProcessInstance.getNodeContainer().getNodes()).filter(node -> node.getName().equals(\"Milestone1\")).map(n -> (String) n.getMetaData().get(Metadata.UNIQUE_ID)).findFirst();\n         assertTrue(milestoneId.isPresent());\n         assertThat(legacyProcessInstance.getCompletedNodeIds()).contains(milestoneId.get());\n-\n-        processInstance.complete();\n-        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n     }\n \n     private void assertState(ProcessInstance<?> processInstance, int state) {\n"}}, {"oid": "79cd7a1ad0de3a91eea6046e7da195704265c0bc", "url": "https://github.com/kiegroup/kogito-runtimes/commit/79cd7a1ad0de3a91eea6046e7da195704265c0bc", "message": "[KOGITO-1968] Remove complete and add milestones method\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-21T16:45:39Z", "type": "forcePushed"}, {"oid": "66965cb8d73e701164e3e801dc3c9d5f0caded20", "url": "https://github.com/kiegroup/kogito-runtimes/commit/66965cb8d73e701164e3e801dc3c9d5f0caded20", "message": "[KOGITO-1968] Remove complete and add milestones method\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-21T16:51:59Z", "type": "forcePushed"}, {"oid": "666317c55fa31fd6b26ecb0d2f69a9d076227644", "url": "https://github.com/kiegroup/kogito-runtimes/commit/666317c55fa31fd6b26ecb0d2f69a9d076227644", "message": "[KOGITO-1968] Remove complete and add milestones method\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-21T16:54:22Z", "type": "forcePushed"}, {"oid": "7de57ff745101d539cdbf532c2832ae41ca63738", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7de57ff745101d539cdbf532c2832ae41ca63738", "message": "[KOGITO-1968] Remove complete and add milestones method\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-21T16:59:35Z", "type": "forcePushed"}, {"oid": "b79a543fd0a66827cda74afcd9c547ee3f347306", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b79a543fd0a66827cda74afcd9c547ee3f347306", "message": "[KOGITO-1968] Allow milestones to trigger completion\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-22T08:30:56Z", "type": "forcePushed"}, {"oid": "bc3e7ab996d726089ed6b3f50c8837c679dd8e7c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/bc3e7ab996d726089ed6b3f50c8837c679dd8e7c", "message": "[KOGITO-1968] Allow milestones to trigger completion\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-22T08:39:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEzNTcxNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r429135717", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class CaseNodeInstance implements Serializable {\n          \n          \n            \n            public class MilestoneInstance implements Serializable {", "author": "cristianonicolai", "createdAt": "2020-05-22T09:15:59Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/CaseNodeInstance.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process;\n+\n+import java.io.Serializable;\n+\n+public class CaseNodeInstance implements Serializable {", "originalCommit": "bc3e7ab996d726089ed6b3f50c8837c679dd8e7c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "acf9afe2dbce7478051e1124a3c3b794673f96fb", "chunk": "diff --git a/api/kogito-api/src/main/java/org/kie/kogito/process/CaseNodeInstance.java b/api/kogito-api/src/main/java/org/kie/kogito/process/casemgmt/ItemDescription.java\nsimilarity index 86%\nrename from api/kogito-api/src/main/java/org/kie/kogito/process/CaseNodeInstance.java\nrename to api/kogito-api/src/main/java/org/kie/kogito/process/casemgmt/ItemDescription.java\nindex 0ed247e9f8..c9fcc68984 100644\n--- a/api/kogito-api/src/main/java/org/kie/kogito/process/CaseNodeInstance.java\n+++ b/api/kogito-api/src/main/java/org/kie/kogito/process/casemgmt/ItemDescription.java\n\n@@ -14,11 +14,11 @@\n  * limitations under the License.\n  */\n \n-package org.kie.kogito.process;\n+package org.kie.kogito.process.casemgmt;\n \n import java.io.Serializable;\n \n-public class CaseNodeInstance implements Serializable {\n+public class ItemDescription implements Serializable {\n \n     public enum Status {\n         AVAILABLE,\n"}}, {"oid": "acf9afe2dbce7478051e1124a3c3b794673f96fb", "url": "https://github.com/kiegroup/kogito-runtimes/commit/acf9afe2dbce7478051e1124a3c3b794673f96fb", "message": "[KOGITO-1968] Allow milestones to trigger completion\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-22T12:53:14Z", "type": "forcePushed"}, {"oid": "155315725d533ad1dbfbc9251d6822aee9ff1c43", "url": "https://github.com/kiegroup/kogito-runtimes/commit/155315725d533ad1dbfbc9251d6822aee9ff1c43", "message": "[KOGITO-1968] Allow milestones to trigger completion\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-22T13:12:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxODcxMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r429318713", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Stream<Node> getCaseNodeInstances(Class<? extends Node> nodeClass) {\n          \n          \n            \n                private Stream<Node> getNodeInstances(Class<? extends Node> nodeClass) {", "author": "cristianonicolai", "createdAt": "2020-05-22T15:37:38Z", "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -368,6 +378,35 @@ public void transitionWorkItem(String id, Transition<?> transition) {\n         return legacyProcessInstance().getEventDescriptions();\n     }\n \n+    @Override\n+    public Collection<Milestone> milestones() {\n+        return getCaseNodeInstances(MilestoneNode.class)\n+                .map(n -> {\n+                    String uid = (String) n.getMetaData().get(UNIQUE_ID);\n+                    return new Milestone(uid, n.getName(), getStatus(uid));\n+                })\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Stream<Node> getCaseNodeInstances(Class<? extends Node> nodeClass) {", "originalCommit": "155315725d533ad1dbfbc9251d6822aee9ff1c43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxMjI0Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/502#discussion_r429412242", "bodyText": "They're just nodes so I renamed it to getNodes", "author": "ruromero", "createdAt": "2020-05-22T19:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxODcxMw=="}], "type": "inlineReview", "revised_code": {"commit": "26c3b845d30a9b9bada50fd59ede11907c1d3db2", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java b/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java\nindex 7d233abeb7..302132ac70 100644\n--- a/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java\n\n@@ -380,7 +380,7 @@ public abstract class AbstractProcessInstance<T extends Model> implements Proces\n \n     @Override\n     public Collection<Milestone> milestones() {\n-        return getCaseNodeInstances(MilestoneNode.class)\n+        return getNodes(MilestoneNode.class)\n                 .map(n -> {\n                     String uid = (String) n.getMetaData().get(UNIQUE_ID);\n                     return new Milestone(uid, n.getName(), getStatus(uid));\n"}}, {"oid": "26c3b845d30a9b9bada50fd59ede11907c1d3db2", "url": "https://github.com/kiegroup/kogito-runtimes/commit/26c3b845d30a9b9bada50fd59ede11907c1d3db2", "message": "[KOGITO-1968] Allow milestones to trigger completion\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-25T07:05:16Z", "type": "forcePushed"}, {"oid": "0fcba877fbd158558ac37295ac441196c7509052", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0fcba877fbd158558ac37295ac441196c7509052", "message": "[KOGITO-1968] Allow milestones to trigger completion\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-25T08:31:03Z", "type": "commit"}, {"oid": "0fcba877fbd158558ac37295ac441196c7509052", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0fcba877fbd158558ac37295ac441196c7509052", "message": "[KOGITO-1968] Allow milestones to trigger completion\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-05-25T08:31:03Z", "type": "forcePushed"}]}