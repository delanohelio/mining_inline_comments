{"pr_number": 763, "pr_title": "[KOGITO-2766] Refactoring Process<T> initialization code", "pr_createdAt": "2020-09-14T11:06:16Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/763", "timeline": [{"oid": "fb808a607fbc780dfa4679a0a250717851dc64c3", "url": "https://github.com/kiegroup/kogito-runtimes/commit/fb808a607fbc780dfa4679a0a250717851dc64c3", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T11:15:34Z", "type": "forcePushed"}, {"oid": "1f8b3bf542941adaf3de966dca1d752eaf5dce45", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1f8b3bf542941adaf3de966dca1d752eaf5dce45", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T11:17:32Z", "type": "forcePushed"}, {"oid": "a5175befccf7a33673c5baab196ebe2aa2a6e696", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a5175befccf7a33673c5baab196ebe2aa2a6e696", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T11:47:57Z", "type": "forcePushed"}, {"oid": "866ee4e20c474e0cdb55be74683f54b358c773f8", "url": "https://github.com/kiegroup/kogito-runtimes/commit/866ee4e20c474e0cdb55be74683f54b358c773f8", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T12:22:40Z", "type": "forcePushed"}, {"oid": "bcb30db9395f271aa667680e9b5df1eb9447a771", "url": "https://github.com/kiegroup/kogito-runtimes/commit/bcb30db9395f271aa667680e9b5df1eb9447a771", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T12:41:13Z", "type": "forcePushed"}, {"oid": "9fc818079c0bda913f7a4857a5550b6b24534b85", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9fc818079c0bda913f7a4857a5550b6b24534b85", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T13:15:55Z", "type": "forcePushed"}, {"oid": "60f97f1087be8cd205adf4fe3844d9513b527970", "url": "https://github.com/kiegroup/kogito-runtimes/commit/60f97f1087be8cd205adf4fe3844d9513b527970", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T13:17:43Z", "type": "forcePushed"}, {"oid": "2b60b5f00a45533cc66d981dec1308ad127b6340", "url": "https://github.com/kiegroup/kogito-runtimes/commit/2b60b5f00a45533cc66d981dec1308ad127b6340", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T13:31:40Z", "type": "forcePushed"}, {"oid": "7596887205c0e994f43243f4a9ef566b0c8d62b4", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7596887205c0e994f43243f4a9ef566b0c8d62b4", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T14:25:29Z", "type": "forcePushed"}, {"oid": "72050ad08dc80df641630c701fb5178284cbd229", "url": "https://github.com/kiegroup/kogito-runtimes/commit/72050ad08dc80df641630c701fb5178284cbd229", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T15:39:12Z", "type": "forcePushed"}, {"oid": "b2a0b0a28d433d5674613902a5643dc128b19736", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b2a0b0a28d433d5674613902a5643dc128b19736", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T15:51:21Z", "type": "forcePushed"}, {"oid": "2c3c3bcf32d56e01b2ba9a9cfa75966284e6f279", "url": "https://github.com/kiegroup/kogito-runtimes/commit/2c3c3bcf32d56e01b2ba9a9cfa75966284e6f279", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T15:57:45Z", "type": "forcePushed"}, {"oid": "f4efd316adbc5b7014c42644490e4a424a9e2f78", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f4efd316adbc5b7014c42644490e4a424a9e2f78", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-14T15:59:33Z", "type": "forcePushed"}, {"oid": "7c0a5aad9aad51fd046e1058758d9144896bb74e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7c0a5aad9aad51fd046e1058758d9144896bb74e", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-15T09:26:42Z", "type": "forcePushed"}, {"oid": "39008da486570df4eac7e69291072f20b730b843", "url": "https://github.com/kiegroup/kogito-runtimes/commit/39008da486570df4eac7e69291072f20b730b843", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-15T12:07:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY1MzQwNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488653406", "bodyText": "with", "author": "evacchi", "createdAt": "2020-09-15T13:10:22Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java", "diffHunk": "@@ -137,6 +137,8 @@\n      * @param defaultValue value to be used in case there is no config parameter defined\n      */\n     <T extends NodeWithAnnotations<?>> T withConfigInjection(T node, String configKey, String defaultValue);\n+ \n+    default <T extends NodeWithAnnotations<?>> T witLazyInit(T node) { return node; }", "originalCommit": "39008da486570df4eac7e69291072f20b730b843", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3MjAzNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488672034", "bodyText": "Thanks", "author": "fjtirado", "createdAt": "2020-09-15T13:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY1MzQwNg=="}], "type": "inlineReview", "revised_code": {"commit": "d8e66648b60819464920316cf674e10a667a8d1d", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java\nindex a51677994b..fc40d21c53 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java\n\n@@ -138,7 +138,7 @@ public interface DependencyInjectionAnnotator {\n      */\n     <T extends NodeWithAnnotations<?>> T withConfigInjection(T node, String configKey, String defaultValue);\n  \n-    default <T extends NodeWithAnnotations<?>> T witLazyInit(T node) { return node; }\n+    default <T extends NodeWithAnnotations<?>> T withLazyInit(T node) { return node; }\n \n     /**\n      * Annotates and enhances method used to produce messages\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY1NDY0Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488654642", "bodyText": "remove comment", "author": "evacchi", "createdAt": "2020-09-15T13:12:04Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -382,76 +343,118 @@ public ClassOrInterfaceDeclaration classDeclaration() {\n         ClassOrInterfaceDeclaration cls = new ClassOrInterfaceDeclaration()\n                 .setName(targetTypeName)\n                 .setModifiers(Modifier.Keyword.PUBLIC);\n-\n-        if (useInjection()) {\n-            annotator.withNamedApplicationComponent(cls, process.getId());\n-            \n-            FieldDeclaration handlersInjectFieldDeclaration = new FieldDeclaration()\n-                    .addVariable(new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(annotator.multiInstanceInjectionType()), NodeList.nodeList(new ClassOrInterfaceType(null, WorkItemHandler.class.getCanonicalName()))), \"handlers\"));\n-            annotator.withOptionalInjection(handlersInjectFieldDeclaration);\n-            \n-            cls.addMember(handlersInjectFieldDeclaration);\n-        }\n-\n+        ProcessMetaData processMetaData = processGenerator.generate();\n         String processInstanceFQCN = ProcessInstanceGenerator.qualifiedName(packageName, typeName);\n-\n-        FieldDeclaration fieldDeclaration = new FieldDeclaration()\n-                .addVariable(new VariableDeclarator(new ClassOrInterfaceType(null, appCanonicalName), \"app\"));\n-\n-        ConstructorDeclaration constructorDeclaration = new ConstructorDeclaration()\n-                .setName(targetTypeName)\n-                .addModifier(Modifier.Keyword.PUBLIC)\n-                .addParameter(appCanonicalName, \"app\")\n-                .setBody(new BlockStmt()\n-                                 // super(module.config().process())\n-                                 .addStatement(new MethodCallExpr(null, \"super\")\n-                                              .addArgument(\n-                                                      new MethodCallExpr(\n-                                                              new MethodCallExpr(new NameExpr(\"app\"), \"config\"),\n-                                                              \"process\")))\n-                                 .addStatement(\n-                                         new AssignExpr(new FieldAccessExpr(new ThisExpr(), \"app\"), new NameExpr(\"app\"), AssignExpr.Operator.ASSIGN)));\n-        \n-        ConstructorDeclaration emptyConstructorDeclaration = new ConstructorDeclaration()\n-                .setName(targetTypeName)\n-                .addModifier(Modifier.Keyword.PUBLIC);\n-        \n+        ConstructorDeclaration constructorDeclaration = getConstructorDeclaration().addParameter(appCanonicalName, APPLICATION);\n+        BlockStmt constructorBody = new BlockStmt()\n+                // super(module.config().process())", "originalCommit": "39008da486570df4eac7e69291072f20b730b843", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3MjQzMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488672430", "bodyText": "This comment is not actually code, but displaying what the code below is generating, are we sure we want to remove it?", "author": "fjtirado", "createdAt": "2020-09-15T13:35:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY1NDY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5ODQ0OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489298449", "bodyText": "oh ok it looked like older code", "author": "evacchi", "createdAt": "2020-09-16T09:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY1NDY0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d8e66648b60819464920316cf674e10a667a8d1d", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\nindex 631776b186..56568add04 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n\n@@ -398,7 +398,7 @@ public class ProcessGenerator {\n                 Parameter parameter = new Parameter(parseClassOrInterfaceType(clazzName), varName);\n                 if (useInjection()) {\n                     annotator.withApplicationComponent(clazz);\n-                    annotator.witLazyInit(parameter);\n+                    annotator.withLazyInit(parameter);\n                 } else {\n                     initMethodCall\n                         .addArgument(\n"}}, {"oid": "d8e66648b60819464920316cf674e10a667a8d1d", "url": "https://github.com/kiegroup/kogito-runtimes/commit/d8e66648b60819464920316cf674e10a667a8d1d", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-15T13:33:42Z", "type": "forcePushed"}, {"oid": "7323bdc7aaef7dd21c27920047572a6d02c4437b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7323bdc7aaef7dd21c27920047572a6d02c4437b", "message": "[KOGITO-2766] Calling activate from constructor", "committedDate": "2020-09-15T14:19:25Z", "type": "forcePushed"}, {"oid": "f4a7419d6f6c290514b84794ebb10760db8f4f2c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f4a7419d6f6c290514b84794ebb10760db8f4f2c", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod", "committedDate": "2020-09-15T14:26:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488747361", "bodyText": "As far as I can see this concept only exists in Spring and not in CDI (even if quarkus impl should be lazy by default).\nWhy do you need it?\nMinor note, can you add a javadoc?", "author": "danielezonca", "createdAt": "2020-09-15T15:11:49Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java", "diffHunk": "@@ -137,6 +136,8 @@\n      * @param defaultValue value to be used in case there is no config parameter defined\n      */\n     <T extends NodeWithAnnotations<?>> T withConfigInjection(T node, String configKey, String defaultValue);\n+ \n+    default <T extends NodeWithAnnotations<?>> T withLazyInit(T node) { return node; }", "originalCommit": "f4a7419d6f6c290514b84794ebb10760db8f4f2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NjkyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488776927", "bodyText": "As you correctly detect, for SpringBoot we need to add lazy annotation to handlers passed as parameters in the constructor.\nSpringBoot has issues with circular dependencies when using construction injection. If, as happens in one of the examples, one of the beans injected into the handler, depends on the Process, SpringBoot wont start unless we include lazy annotation (this issue does not appear in Quarkus)\nI use a descriptive name, but we can use a more abstract one for the new method something as constructorParam. wdyt?", "author": "fjtirado", "createdAt": "2020-09-15T15:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4MzA0MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488783040", "bodyText": "After thinking a while, I think for consistency with the existing interface, the word lazy needs to be there", "author": "fjtirado", "createdAt": "2020-09-15T16:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc5OTU0Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488799547", "bodyText": "\ud83e\udd14 I'm fine with the name, I have more concern with the need of this annotation: I'm worried that sooner or later this problem (circular dependencies) will appear again if we continue to use construction injection.\nWhat if we generate the constructor with all the parameters (to allow manual instantiation) but then we inject on fields? Does it solve the need to have lazy init?\n@evacchi wdyt? If this works I would prefer to do this change instead of have the risk to add Lazy annotation \"everywhere\"", "author": "danielezonca", "createdAt": "2020-09-15T16:24:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgwOTY2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488809663", "bodyText": "I think constructor injection is what this JIRA was all about (this allow us to remove fields and remove separate initialization). I do not see a big trouble with lazy if used where it should be (just the constructor parameters). Also, please notice this is a workaround for SpringBoot, Quakus resolve circular dependencies without any issue.", "author": "fjtirado", "createdAt": "2020-09-15T16:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgxNzUwMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488817503", "bodyText": "What Im trying to say is that annotating something with Lazy is not an issue at all (a proxy is created and intialized the first time is used, pretty similar what field injection actually does). Which is an issue is to use construction injection on springboot without the lazy. If we use construction injection somewhere else, we need to have this into account (and the annotator will be ready).\nDoes it make sense to use constructor injection in this particular scenario? I think the answer is yes, so I vote going for it", "author": "fjtirado", "createdAt": "2020-09-15T16:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxMzE1OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489313158", "bodyText": "ok, here's what I think\n\nI don't love the \"Annotator\" at all really :P I believe that we should actually move to templates everywhere.\nWe don't necessarily have to introduce templates with this PR but then I would at least wish for a follow-up JIRA where we try; I am trying to do it for Rules -- the code there is arguably less, though\nHowever, the following code could be substituted for the injection of Instance/Collection\n(and in fact IIRC we were injecting a collection, before)\n\n    @javax.inject.Inject()\n    public TravellersProcess(org.kie.kogito.app.Application app, org.kie.kogito.handlers.GreetingTravellerService_greetTraveller_3_Handler greetingTravellerService_greetTraveller_3_Handler, org.kie.kogito.handlers.TravellerAuditService_auditTraveller_7_Handler travellerAuditService_auditTraveller_7_Handler, org.kie.kogito.handlers.StoreTravellerService_storeTraveller_2_Handler storeTravellerService_storeTraveller_2_Handler) {\n        super(app.config().process());\n        this.app = app;\n        org.kie.api.runtime.process.WorkItemManager workItemManager = services.getWorkItemManager();\n        workItemManager.registerWorkItemHandler(\"org.acme.travels.services.GreetingTravellerService_greetTraveller_3_Handler\", greetingTravellerService_greetTraveller_3_Handler);\n        workItemManager.registerWorkItemHandler(\"org.acme.travels.services.TravellerAuditService_auditTraveller_7_Handler\", travellerAuditService_auditTraveller_7_Handler);\n        workItemManager.registerWorkItemHandler(\"org.acme.travels.services.StoreTravellerService_storeTraveller_2_Handler\", storeTravellerService_storeTraveller_2_Handler);\n        this.activate();\n    }\nin other words:\n    @javax.inject.Inject()\n    public TravellersProcess(\n        org.kie.kogito.app.Application app, \n        // java.util.Collection in the case of Spring\n        javax.enterprise.inject.Instance<org.kie.api.runtime.process.WorkItemHandler> handlers) {\n        super(app.config().process());\n        this.app = app;\n        org.kie.api.runtime.process.WorkItemManager workItemManager = services.getWorkItemManager();\n        for (WorkItemHandler wih : handlers) {\n            workItemManager.registerWorkItemHandler(wih.getClass().getCanonicalName(), wih);\n        }\n        this.activate();\n    }\nto the point where we can actually move the logic to a super constructor:\nprotected AbstractProcess(\n    org.kie.kogito.app.Application app, \n    // iterable is a common superclass between Instance (CDI) and Collection (Spring)\n    Iterable<org.kie.api.runtime.process.WorkItemHandler> handlers) {\n        this(app.config().process());\n        this.app = app;\n        org.kie.api.runtime.process.WorkItemManager workItemManager = services.getWorkItemManager();\n        for (WorkItemHandler wih : handlers) {\n            workItemManager.registerWorkItemHandler(wih.getClass().getCanonicalName(), wih);\n        }\n        this.activate();\n}\nthus transforming the code as such:\n    @javax.inject.Inject()\n    public TravellersProcess(\n        org.kie.kogito.app.Application app, \n        // java.util.Collection in the case of Spring\n        javax.enterprise.inject.Instance<org.kie.api.runtime.process.WorkItemHandler> handlers) {\n        super(app.config().process(), handlers);\n    }\nas you can see, this way we trim down the generated code considerably, we get a much more meaningful and simpler template\n\n\nNow, for the @Lazy annotation, first of all I would like to know what's causing the issue, and rather try to solve the issue at its root if possible; IIRC Application gets injected ApplicationProcesses, which contains all of the available processes; this in a CDI/Spring context is not a dependency of this class; however, this could be still cyclic; to resolve the cycle, it may be just enough to annotate the class kogito-codegen/src/main/resources/class-templates/SpringProcessContainerTemplate.javawith @Lazy\n\n\nif there is not way to break the cycle, then I'd rather annotate the constructor rather than the single parameters\n\n\nhope this answers all of your questions", "author": "evacchi", "createdAt": "2020-09-16T09:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM0OTg0OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489349849", "bodyText": "Let me try to reply\n\nPlace where the annotator is used are now minimized (grouped as far as possible) in codegen\nAs you said, this point should be a different JIRA which change the approach we are using to insert annotations and use two different templates rather than annotator (I confess Im not a fan of the template approach and do not see the advantage of having 2 templated compared with having 2 annotator implementation. I feel  we are going to duplicate a lot of code in the templates as already happen with resources, but this is part of that another JIRA discussion ;))\nSince we are using a generator, I think is better to restrict the handler to the ones that really makes sense for a particular process, thats why Im using concrete handlers rather than a generic list, so it is guaranteed that only those handlers that are part of the process definition are registered. This was my humble aportation to the JIRA description and I think is an improvement that Im really reluctant to remove.\nAlso please note that first parameter of registerhandler method  is not really equal to class cannonical name\nName is org.acme.travels.services.GreetingTravellerService_greetTraveller_3_Handler\nClass name is org.kie.kogito.handlers.GreetingTravellerService_greetTraveller_3_Handler\n\nThe code I would generate (following your proposal)  is (using handler.getName(), not canonical name, to register the handler in AbstractProcess)\n    @javax.inject.Inject()\n    public TravellersProcess(org.kie.kogito.app.Application app, org.kie.kogito.handlers.GreetingTravellerService_greetTraveller_3_Handler greetingTravellerService_greetTraveller_3_Handler, org.kie.kogito.handlers.TravellerAuditService_auditTraveller_7_Handler travellerAuditService_auditTraveller_7_Handler, org.kie.kogito.handlers.StoreTravellerService_storeTraveller_2_Handler storeTravellerService_storeTraveller_2_Handler) {\n        super(app.config().process(), Arrays.asList(greetingTravellerService_greetTraveller_3_Handler,travellerAuditService_auditTraveller_7_Handler,storeTravellerService_storeTraveller_2_Handler));\n}\n\n3a) BTW, do we need app to be a field at all?\n4) Circular dependency happens here https://github.com/kiegroup/kogito-examples/blob/stable/process-optaplanner-quarkus/src/main/java/org/kie/kogito/examples/service/FlightSeatingSolveService.java. This is a service injected by the handler that is injecting the process. Since there is not way to prevent that circular depedency, lazy is the solution for spring boot.\n5) I applied a fine grane approach, only annotate with lazy what really needs to be annotated (please note that currently Application bean is not annotated with lazy because we know for sure that there is not circular dependency here), but of course we can switch to coarse approach and lazy initialize all constructor parameters", "author": "fjtirado", "createdAt": "2020-09-16T10:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2OTY0Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489369646", "bodyText": "@evacchi I updated code according to your point 3) proposal, please review", "author": "fjtirado", "createdAt": "2020-09-16T11:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3MDIxOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489370218", "bodyText": "ok let's file a jira for that\nwe are using the Collection approach for ApplicationConfig and ProcessConfig. I think this is a simpler approach, and although I agree we could be more specific in the way we generate code, I have also come to the conclusion it is better to lean on the side of simplicity to reduce the complexity and amount of code we generate. In this case, I'd rather uniform the codebase with that approach; otherwise we would have to modify ProcessConfig et al. for consistency.\n\n\nAlso please note that first parameter of registerhandler method is not really equal to class cannonical name\nName is org.acme.travels.services.GreetingTravellerService_greetTraveller_3_Handler\n\nweird why is that so? How was that solved before? I am pretty sure we were injecting a collection\n3a) the app is used inside process definition, that's why it's passed on (Strictly speaking we may not necessarily always need it, it depends on how the process is defined)\n\nI'd argue we should make lazy the Process field of that service in the example instead, wdyt ? :)", "author": "evacchi", "createdAt": "2020-09-16T11:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3MzEzNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489373137", "bodyText": "regarding 3). I think this is simple enough\n  public TravellersProcess(org.kie.kogito.app.Application app) {\n        this(app, new org.kie.kogito.handlers.GreetingTravellerService_greetTraveller_3_Handler(), new org.kie.kogito.handlers.TravellerAuditService_auditTraveller_7_Handler(), new org.kie.kogito.handlers.StoreTravellerService_storeTraveller_2_Handler());\n    }\n\n    @javax.inject.Inject()\n    public TravellersProcess(org.kie.kogito.app.Application app, org.kie.kogito.handlers.GreetingTravellerService_greetTraveller_3_Handler greetingTravellerService_greetTraveller_3_Handler, org.kie.kogito.handlers.TravellerAuditService_auditTraveller_7_Handler travellerAuditService_auditTraveller_7_Handler, org.kie.kogito.handlers.StoreTravellerService_storeTraveller_2_Handler storeTravellerService_storeTraveller_2_Handler) {\n        super(app, java.util.Arrays.asList(greetingTravellerService_greetTraveller_3_Handler, travellerAuditService_auditTraveller_7_Handler, storeTravellerService_storeTraveller_2_Handler));\n    }\n\n    public TravellersProcess() {\n    }", "author": "fjtirado", "createdAt": "2020-09-16T11:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3MzczMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489373731", "bodyText": "I think we cannot guarantee what the user code will do. I think is better to prevent this issue on runtime side", "author": "fjtirado", "createdAt": "2020-09-16T11:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3Njk0OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489376949", "bodyText": "weird why is that so? How was that solved before? I am pretty sure we were injecting a collection\n\nhandler.getName", "author": "fjtirado", "createdAt": "2020-09-16T11:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNDE1NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489414155", "bodyText": "Regarding lazy, I removed from process constructor parameters and add to handler constructor.\n\n    public GreetingTravellerService_greetTraveller_3_Handler() {\n        this.service = new org.acme.travels.services.GreetingTravellerService();\n    }\n\n    @org.springframework.beans.factory.annotation.Autowired()\n    @org.springframework.context.annotation.Lazy()\n    public GreetingTravellerService_greetTraveller_3_Handler(org.acme.travels.services.GreetingTravellerService service) {\n        this.service = service;\n    }", "author": "fjtirado", "createdAt": "2020-09-16T12:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQzMDAwMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489430002", "bodyText": "Please note that activate needs to be invoked from child class constructor, since it relies on abtract method process and this is only avaiable when super() has finished", "author": "fjtirado", "createdAt": "2020-09-16T13:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQzMDg2Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489430867", "bodyText": "Rather than new mthod withLazy, a new parameter lazy has been added to withInjection method, default value being false (so, it can be applied when needed, in our case, just in the handler constructor)", "author": "fjtirado", "createdAt": "2020-09-16T13:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3679780366a503252dd72447f32d79ccecd0a91", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java\nindex 4c80c769c1..23aa64fb42 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java\n\n@@ -136,7 +136,13 @@ public interface DependencyInjectionAnnotator {\n      * @param defaultValue value to be used in case there is no config parameter defined\n      */\n     <T extends NodeWithAnnotations<?>> T withConfigInjection(T node, String configKey, String defaultValue);\n- \n+\n+    /**\n+     * Annotates with lazy annotation to avoid circular dependency \n+     * @param <T> node type\n+     * @param node node to be annotated\n+     * @return annotated node\n+     */\n     default <T extends NodeWithAnnotations<?>> T withLazyInit(T node) { return node; }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MzQxMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488753413", "bodyText": "What about return Optional<MethodDeclaration>?", "author": "danielezonca", "createdAt": "2020-09-15T15:19:42Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -268,105 +276,58 @@ private MethodCallExpr createProcessRuntime() {\n     }\n     \n     private MethodDeclaration internalConfigure(ProcessMetaData processMetaData) {\n-        BlockStmt body = new BlockStmt();\n-        MethodDeclaration internalConfigure = new MethodDeclaration()\n-                .setModifiers(Modifier.Keyword.PUBLIC)\n-                .setType(targetTypeName)\n-                .setName(\"configure\")\n-                .setBody(body);   \n-        \n-        // always call super.configure\n-        body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n-\n-        if (!processMetaData.getGeneratedHandlers().isEmpty()) {\n-            \n-            processMetaData.getGeneratedHandlers().forEach((name, handler) -> {\n-                ClassOrInterfaceDeclaration clazz = handler.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                if (useInjection()) {\n-                                       \n-                    annotator.withApplicationComponent(clazz);\n-                    BlockStmt actionBody = new BlockStmt();\n-                    LambdaExpr forachBody = new LambdaExpr(new Parameter(new UnknownType(), \"h\"), actionBody);\n-                    MethodCallExpr forachHandler = new MethodCallExpr(new NameExpr(\"handlers\"), \"forEach\");                    \n-                    forachHandler.addArgument(forachBody);\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new MethodCallExpr(new NameExpr(\"h\"), \"getName\")).addArgument(new NameExpr(\"h\"));\n-                    \n-                    actionBody.addStatement(registerHandler);\n-                    \n-                    body.addStatement(forachHandler);\n-                } else {\n-                \n-                    String packageName = handler.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                    String clazzName = clazz.getName().toString();\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new StringLiteralExpr(name)).addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n-                    \n-                    body.addStatement(registerHandler);\n-                }\n-                // annotate for injection or add constructor for initialization\n-                handler.findAll(FieldDeclaration.class).forEach(fd -> {\n-                    if (useInjection()) {\n-                        annotator.withInjection(fd);\n-                    } else {\n-                        BlockStmt constructorBody = new BlockStmt();\n-                        AssignExpr assignExpr = new AssignExpr(\n-                                                               new FieldAccessExpr(new ThisExpr(), fd.getVariable(0).getNameAsString()),\n-                                                               new ObjectCreationExpr().setType(fd.getVariable(0).getType().toString()),\n-                                                               AssignExpr.Operator.ASSIGN);\n-                        \n-                        constructorBody.addStatement(assignExpr);\n-                        clazz.addConstructor(Keyword.PUBLIC).setBody(constructorBody);\n-                    }\n-                });\n-                \n-                \n-                additionalClasses.add(handler);\n-            });\n-        }\n+       \n         if (!processMetaData.getGeneratedListeners().isEmpty()) {\n+            BlockStmt body = new BlockStmt();\n+            MethodDeclaration internalConfigure = new MethodDeclaration()\n+                    .setModifiers(Modifier.Keyword.PUBLIC)\n+                    .setType(targetTypeName)\n+                    .setName(\"configure\")\n+                    .setBody(body);   \n             \n+            // always call super.configure\n+            body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n             processMetaData.getGeneratedListeners().forEach(listener -> {\n-                \n                 ClassOrInterfaceDeclaration clazz = listener.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                String packageName = listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                String clazzName = clazz.getName().toString();\n-                \n-                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");            \n-                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n+                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");\n+                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\")\n+                    .addArgument(\n+                        new ObjectCreationExpr(\n+                            null,\n+                            new ClassOrInterfaceType(\n+                                null,\n+                                listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\") + \".\" +clazz.getName()),\n+                            NodeList.nodeList()));\n                 \n                 body.addStatement(registerListener);\n                 \n                 additionalClasses.add(listener);\n             });\n+            body.addStatement(new ReturnStmt(new ThisExpr()));\n+            return internalConfigure;\n         }\n+        return null;\n         \n-        body.addStatement(new ReturnStmt(new ThisExpr()));\n-        \n-        return internalConfigure;\n+       \n     }\n     \n     private MethodDeclaration internalRegisterListeners(ProcessMetaData processMetaData) {\n-        BlockStmt body = new BlockStmt();\n-        MethodDeclaration internalRegisterListeners = new MethodDeclaration()\n-                .setModifiers(Modifier.Keyword.PROTECTED)\n-                .setType(void.class)\n-                .setName(\"registerListeners\")\n-                .setBody(body);   \n-                \n         if (!processMetaData.getSubProcesses().isEmpty()) {\n+            BlockStmt body = new BlockStmt();\n+            MethodDeclaration internalRegisterListeners = new MethodDeclaration()\n+                    .setModifiers(Modifier.Keyword.PROTECTED)\n+                    .setType(void.class)\n+                    .setName(\"registerListeners\")\n+                    .setBody(body);   \n             \n             for (Entry<String, String> subProcess : processMetaData.getSubProcesses().entrySet()) {\n                 MethodCallExpr signalManager = new MethodCallExpr(new NameExpr(\"services\"), \"getSignalManager\");\n                 MethodCallExpr registerListener = new MethodCallExpr(signalManager, \"addEventListener\").addArgument(new StringLiteralExpr(subProcess.getValue())).addArgument(new NameExpr(\"completionEventListener\"));\n-                \n                 body.addStatement(registerListener);\n             }\n+            return internalRegisterListeners;\n         }\n-        \n-        return internalRegisterListeners;\n+        return null;", "originalCommit": "f4a7419d6f6c290514b84794ebb10760db8f4f2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4NDA5NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488784095", "bodyText": "Ill do it", "author": "fjtirado", "createdAt": "2020-09-15T16:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MzQxMw=="}], "type": "inlineReview", "revised_code": {"commit": "b3679780366a503252dd72447f32d79ccecd0a91", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\nindex bf56f8891c..da3c048df4 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n\n@@ -275,7 +276,7 @@ public class ProcessGenerator {\n                 \"createProcessRuntime\");\n     }\n     \n-    private MethodDeclaration internalConfigure(ProcessMetaData processMetaData) {\n+    private Optional<MethodDeclaration> internalConfigure(ProcessMetaData processMetaData) {\n        \n         if (!processMetaData.getGeneratedListeners().isEmpty()) {\n             BlockStmt body = new BlockStmt();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1NTI5OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488755299", "bodyText": "What about return Optional<MethodDeclaration>?", "author": "danielezonca", "createdAt": "2020-09-15T15:22:17Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -268,105 +276,58 @@ private MethodCallExpr createProcessRuntime() {\n     }\n     \n     private MethodDeclaration internalConfigure(ProcessMetaData processMetaData) {\n-        BlockStmt body = new BlockStmt();\n-        MethodDeclaration internalConfigure = new MethodDeclaration()\n-                .setModifiers(Modifier.Keyword.PUBLIC)\n-                .setType(targetTypeName)\n-                .setName(\"configure\")\n-                .setBody(body);   \n-        \n-        // always call super.configure\n-        body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n-\n-        if (!processMetaData.getGeneratedHandlers().isEmpty()) {\n-            \n-            processMetaData.getGeneratedHandlers().forEach((name, handler) -> {\n-                ClassOrInterfaceDeclaration clazz = handler.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                if (useInjection()) {\n-                                       \n-                    annotator.withApplicationComponent(clazz);\n-                    BlockStmt actionBody = new BlockStmt();\n-                    LambdaExpr forachBody = new LambdaExpr(new Parameter(new UnknownType(), \"h\"), actionBody);\n-                    MethodCallExpr forachHandler = new MethodCallExpr(new NameExpr(\"handlers\"), \"forEach\");                    \n-                    forachHandler.addArgument(forachBody);\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new MethodCallExpr(new NameExpr(\"h\"), \"getName\")).addArgument(new NameExpr(\"h\"));\n-                    \n-                    actionBody.addStatement(registerHandler);\n-                    \n-                    body.addStatement(forachHandler);\n-                } else {\n-                \n-                    String packageName = handler.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                    String clazzName = clazz.getName().toString();\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new StringLiteralExpr(name)).addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n-                    \n-                    body.addStatement(registerHandler);\n-                }\n-                // annotate for injection or add constructor for initialization\n-                handler.findAll(FieldDeclaration.class).forEach(fd -> {\n-                    if (useInjection()) {\n-                        annotator.withInjection(fd);\n-                    } else {\n-                        BlockStmt constructorBody = new BlockStmt();\n-                        AssignExpr assignExpr = new AssignExpr(\n-                                                               new FieldAccessExpr(new ThisExpr(), fd.getVariable(0).getNameAsString()),\n-                                                               new ObjectCreationExpr().setType(fd.getVariable(0).getType().toString()),\n-                                                               AssignExpr.Operator.ASSIGN);\n-                        \n-                        constructorBody.addStatement(assignExpr);\n-                        clazz.addConstructor(Keyword.PUBLIC).setBody(constructorBody);\n-                    }\n-                });\n-                \n-                \n-                additionalClasses.add(handler);\n-            });\n-        }\n+       \n         if (!processMetaData.getGeneratedListeners().isEmpty()) {\n+            BlockStmt body = new BlockStmt();\n+            MethodDeclaration internalConfigure = new MethodDeclaration()\n+                    .setModifiers(Modifier.Keyword.PUBLIC)\n+                    .setType(targetTypeName)\n+                    .setName(\"configure\")\n+                    .setBody(body);   \n             \n+            // always call super.configure\n+            body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n             processMetaData.getGeneratedListeners().forEach(listener -> {\n-                \n                 ClassOrInterfaceDeclaration clazz = listener.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                String packageName = listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                String clazzName = clazz.getName().toString();\n-                \n-                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");            \n-                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n+                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");\n+                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\")\n+                    .addArgument(\n+                        new ObjectCreationExpr(\n+                            null,\n+                            new ClassOrInterfaceType(\n+                                null,\n+                                listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\") + \".\" +clazz.getName()),\n+                            NodeList.nodeList()));\n                 \n                 body.addStatement(registerListener);\n                 \n                 additionalClasses.add(listener);\n             });\n+            body.addStatement(new ReturnStmt(new ThisExpr()));\n+            return internalConfigure;\n         }\n+        return null;", "originalCommit": "f4a7419d6f6c290514b84794ebb10760db8f4f2c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3679780366a503252dd72447f32d79ccecd0a91", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\nindex bf56f8891c..da3c048df4 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n\n@@ -275,7 +276,7 @@ public class ProcessGenerator {\n                 \"createProcessRuntime\");\n     }\n     \n-    private MethodDeclaration internalConfigure(ProcessMetaData processMetaData) {\n+    private Optional<MethodDeclaration> internalConfigure(ProcessMetaData processMetaData) {\n        \n         if (!processMetaData.getGeneratedListeners().isEmpty()) {\n             BlockStmt body = new BlockStmt();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1Nzk5Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488757997", "bodyText": "Can you please rename the method to better explain its scope? Something like initializeField or similar", "author": "danielezonca", "createdAt": "2020-09-15T15:25:54Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -548,6 +535,30 @@ public ClassOrInterfaceDeclaration classDeclaration() {\n         return cls;\n     }\n \n+    \n+    private ConstructorDeclaration getConstructorDeclaration() {\n+        return new ConstructorDeclaration()\n+            .setName(targetTypeName)\n+            .addModifier(Modifier.Keyword.PUBLIC);\n+    }\n+\n+    \n+    private void forEachField (ClassOrInterfaceDeclaration clazz, FieldDeclaration fd) {", "originalCommit": "f4a7419d6f6c290514b84794ebb10760db8f4f2c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3679780366a503252dd72447f32d79ccecd0a91", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\nindex bf56f8891c..da3c048df4 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n\n@@ -543,7 +537,7 @@ public class ProcessGenerator {\n     }\n \n     \n-    private void forEachField (ClassOrInterfaceDeclaration clazz, FieldDeclaration fd) {\n+    private void initHandler (ClassOrInterfaceDeclaration clazz, FieldDeclaration fd) {\n         // annotate for injection or add constructor for initialization\n         if (useInjection()) {\n             annotator.withInjection(fd);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2MjMyMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488762322", "bodyText": "If you make them return Optional<MethodDeclaration> you can replace with something like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    MethodDeclaration configure = internalConfigure(processMetaData);\n          \n          \n            \n                    if (configure != null) {\n          \n          \n            \n                        cls.addMember(configure);\n          \n          \n            \n                    }\n          \n          \n            \n                    MethodDeclaration registerListener = internalRegisterListeners(processMetaData);\n          \n          \n            \n                    if (registerListener != null) {\n          \n          \n            \n                        cls.addMember(registerListener);\n          \n          \n            \n                    }\n          \n          \n            \n                    internalConfigure(processMetaData).ifPresent(cls::addMember);\n          \n          \n            \n                    internalRegisterListeners(processMetaData).ifPresent(cls::addMember);", "author": "danielezonca", "createdAt": "2020-09-15T15:31:38Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -382,76 +343,113 @@ public ClassOrInterfaceDeclaration classDeclaration() {\n         ClassOrInterfaceDeclaration cls = new ClassOrInterfaceDeclaration()\n                 .setName(targetTypeName)\n                 .setModifiers(Modifier.Keyword.PUBLIC);\n-\n-        if (useInjection()) {\n-            annotator.withNamedApplicationComponent(cls, process.getId());\n-            \n-            FieldDeclaration handlersInjectFieldDeclaration = new FieldDeclaration()\n-                    .addVariable(new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(annotator.multiInstanceInjectionType()), NodeList.nodeList(new ClassOrInterfaceType(null, WorkItemHandler.class.getCanonicalName()))), \"handlers\"));\n-            annotator.withOptionalInjection(handlersInjectFieldDeclaration);\n-            \n-            cls.addMember(handlersInjectFieldDeclaration);\n-        }\n-\n+        ProcessMetaData processMetaData = processGenerator.generate();\n         String processInstanceFQCN = ProcessInstanceGenerator.qualifiedName(packageName, typeName);\n-\n-        FieldDeclaration fieldDeclaration = new FieldDeclaration()\n-                .addVariable(new VariableDeclarator(new ClassOrInterfaceType(null, appCanonicalName), \"app\"));\n-\n-        ConstructorDeclaration constructorDeclaration = new ConstructorDeclaration()\n-                .setName(targetTypeName)\n-                .addModifier(Modifier.Keyword.PUBLIC)\n-                .addParameter(appCanonicalName, \"app\")\n-                .setBody(new BlockStmt()\n-                                 // super(module.config().process())\n-                                 .addStatement(new MethodCallExpr(null, \"super\")\n-                                              .addArgument(\n-                                                      new MethodCallExpr(\n-                                                              new MethodCallExpr(new NameExpr(\"app\"), \"config\"),\n-                                                              \"process\")))\n-                                 .addStatement(\n-                                         new AssignExpr(new FieldAccessExpr(new ThisExpr(), \"app\"), new NameExpr(\"app\"), AssignExpr.Operator.ASSIGN)));\n-        \n-        ConstructorDeclaration emptyConstructorDeclaration = new ConstructorDeclaration()\n-                .setName(targetTypeName)\n-                .addModifier(Modifier.Keyword.PUBLIC);\n-        \n+        ConstructorDeclaration constructorDeclaration = getConstructorDeclaration().addParameter(appCanonicalName, APPLICATION);\n+        BlockStmt constructorBody = new BlockStmt()\n+                // super(module.config().process())\n+                .addStatement(\n+                              new MethodCallExpr(null, \"super\")\n+                                  .addArgument(\n+                                               new MethodCallExpr(\n+                                                   new MethodCallExpr(new NameExpr(APPLICATION), \"config\"),\n+                                                   \"process\")))\n+                .addStatement(\n+                              new AssignExpr(\n+                                  new FieldAccessExpr(new ThisExpr(), APPLICATION),\n+                                  new NameExpr(APPLICATION),\n+                                  AssignExpr.Operator.ASSIGN));\n+        constructorDeclaration.setBody(constructorBody);\n         if (useInjection()) {\n+            annotator.withNamedApplicationComponent(cls, process.getId());\n             annotator.withInjection(constructorDeclaration);\n-        } else {\n-        \n-            emptyConstructorDeclaration\n-                .setBody(new BlockStmt()\n-                                 .addStatement(\n-                                         new MethodCallExpr(null, \"this\").addArgument(new ObjectCreationExpr().setType(appCanonicalName))));\n         }\n         \n-        MethodDeclaration createModelMethod = new MethodDeclaration()\n-                .addModifier(Keyword.PUBLIC)\n-                .setName(CREATE_MODEL)\n-                .setType(modelTypeName)\n-                .setBody(new BlockStmt()\n-                         .addStatement(new ReturnStmt(new ObjectCreationExpr(null, \n-                                                                             new ClassOrInterfaceType(null, modelTypeName), \n-                                                                             NodeList.nodeList()))));               \n+        Map<String, CompilationUnit> handlers = processMetaData.getGeneratedHandlers();\n+        if (!handlers.isEmpty()) {\n+            constructorBody.addStatement(\n+                          new VariableDeclarationExpr(\n+                              new VariableDeclarator(\n+                                  parseClassOrInterfaceType(WorkItemManager.class.getCanonicalName()),\n+                                  WORK_ITEM_MANAGER,\n+                                  new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\"))));\n+            \n+            MethodCallExpr initMethodCall = new MethodCallExpr(null, \"this\").addArgument(new NameExpr(APPLICATION));\n+            cls\n+                .addMember(\n+                           getConstructorDeclaration()\n+                               .addParameter(appCanonicalName, APPLICATION)\n+                               .setBody(new BlockStmt().addStatement(initMethodCall)));\n+\n+            for (Entry<String, CompilationUnit> handler : handlers.entrySet()) {\n+                String varName = handler.getKey().substring(handler.getKey().lastIndexOf('.') + 1);\n+                varName = Character.toLowerCase(varName.charAt(0)) + varName.substring(1);\n+                ClassOrInterfaceDeclaration clazz =\n+                        handler\n+                            .getValue()\n+                            .findFirst(ClassOrInterfaceDeclaration.class)\n+                            .orElseThrow(() -> new NoSuchElementException(\"Compilation unit doesn't contain a method declaration!\"));\n+                String clazzName =\n+                        handler.getValue().getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\") +\n+                                   '.' + clazz.getName();\n+\n+                Parameter parameter = new Parameter(parseClassOrInterfaceType(clazzName), varName);\n+                if (useInjection()) {\n+                    annotator.withApplicationComponent(clazz);\n+                    annotator.withLazyInit(parameter);\n+                } \n+                initMethodCall\n+                    .addArgument(\n+                                 new ObjectCreationExpr(\n+                                     null,\n+                                     new ClassOrInterfaceType(null, clazzName),\n+                                     NodeList.nodeList()));\n+\n+                constructorDeclaration.addParameter(parameter);\n+                constructorBody\n+                    .addStatement(\n+                                  new MethodCallExpr(new NameExpr(WORK_ITEM_MANAGER), \"registerWorkItemHandler\")\n+                                      .addArgument(new StringLiteralExpr(handler.getKey()))\n+                                      .addArgument(new NameExpr(varName)));\n+                handler.getValue().findAll(FieldDeclaration.class).forEach(fd -> forEachField(clazz, fd));\n+                additionalClasses.add(handler.getValue());\n+            }\n+        }\n         \n-        ProcessMetaData processMetaData = processGenerator.generate();\n+        constructorBody.addStatement(new MethodCallExpr(new ThisExpr(), \"activate\"));\n \n         cls.addExtendedType(abstractProcessType(modelTypeName))\n-                .addMember(fieldDeclaration)\n-                .addMember(emptyConstructorDeclaration)\n+                .addMember(new FieldDeclaration()\n+                           .addVariable(new VariableDeclarator(new ClassOrInterfaceType(null, appCanonicalName), APPLICATION)))\n                 .addMember(constructorDeclaration)\n+                .addMember(getConstructorDeclaration())\n                 .addMember(createInstanceMethod(processInstanceFQCN))\n                 .addMember(createInstanceWithBusinessKeyMethod(processInstanceFQCN))\n-                .addMember(createModelMethod)\n+                .addMember(new MethodDeclaration()\n+                           .addModifier(Keyword.PUBLIC)\n+                           .setName(CREATE_MODEL)\n+                           .setType(modelTypeName)\n+                           .addAnnotation(Override.class)\n+                           .setBody(new BlockStmt()\n+                                    .addStatement(new ReturnStmt(new ObjectCreationExpr(null, \n+                                                                                        new ClassOrInterfaceType(null, modelTypeName), \n+                                                                                        NodeList.nodeList())))))\n                 .addMember(createInstanceGenericMethod(processInstanceFQCN))\n                 .addMember(createInstanceGenericWithBusinessKeyMethod(processInstanceFQCN))\n                 .addMember(createInstanceGenericWithWorkflowInstanceMethod(processInstanceFQCN))\n                 .addMember(createReadOnlyInstanceGenericWithWorkflowInstanceMethod(processInstanceFQCN))\n-                .addMember(internalConfigure(processMetaData))\n-                .addMember(internalRegisterListeners(processMetaData))\n                 .addMember(process(processMetaData));\n+\n         \n+        MethodDeclaration configure = internalConfigure(processMetaData);\n+        if (configure != null) {\n+            cls.addMember(configure);\n+        }\n+        MethodDeclaration registerListener = internalRegisterListeners(processMetaData);\n+        if (registerListener != null) {\n+            cls.addMember(registerListener);\n+        }", "originalCommit": "f4a7419d6f6c290514b84794ebb10760db8f4f2c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3679780366a503252dd72447f32d79ccecd0a91", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\nindex bf56f8891c..da3c048df4 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n\n@@ -343,7 +344,7 @@ public class ProcessGenerator {\n         ClassOrInterfaceDeclaration cls = new ClassOrInterfaceDeclaration()\n                 .setName(targetTypeName)\n                 .setModifiers(Modifier.Keyword.PUBLIC);\n-        ProcessMetaData processMetaData = processGenerator.generate();\n+        ProcessMetaData processMetaData = processExecutable.generate();\n         String processInstanceFQCN = ProcessInstanceGenerator.qualifiedName(packageName, typeName);\n         ConstructorDeclaration constructorDeclaration = getConstructorDeclaration().addParameter(appCanonicalName, APPLICATION);\n         BlockStmt constructorBody = new BlockStmt()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2NzEyNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488767126", "bodyText": "If getPackageDeclaration() returns an empty Optional this will produce an invalid string: .ClassName\nCan you please verify if getPackageDeclaration() can be empty (i.e. default package)?\nIf not I think it is better to throw an exception like \"This should never happen\" instead of a empty string.\nIn general we can probably replace the code with this alternative\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\") + \".\" +clazz.getName()),\n          \n          \n            \n                                            listener.getPackageDeclaration().map(pd -> pd.getName().toString() + \".\" + clazz.getName()).orElse(clazz.getName()),\n          \n      \n    \n    \n  \n\nWdyt?", "author": "danielezonca", "createdAt": "2020-09-15T15:38:24Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -268,105 +276,58 @@ private MethodCallExpr createProcessRuntime() {\n     }\n     \n     private MethodDeclaration internalConfigure(ProcessMetaData processMetaData) {\n-        BlockStmt body = new BlockStmt();\n-        MethodDeclaration internalConfigure = new MethodDeclaration()\n-                .setModifiers(Modifier.Keyword.PUBLIC)\n-                .setType(targetTypeName)\n-                .setName(\"configure\")\n-                .setBody(body);   \n-        \n-        // always call super.configure\n-        body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n-\n-        if (!processMetaData.getGeneratedHandlers().isEmpty()) {\n-            \n-            processMetaData.getGeneratedHandlers().forEach((name, handler) -> {\n-                ClassOrInterfaceDeclaration clazz = handler.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                if (useInjection()) {\n-                                       \n-                    annotator.withApplicationComponent(clazz);\n-                    BlockStmt actionBody = new BlockStmt();\n-                    LambdaExpr forachBody = new LambdaExpr(new Parameter(new UnknownType(), \"h\"), actionBody);\n-                    MethodCallExpr forachHandler = new MethodCallExpr(new NameExpr(\"handlers\"), \"forEach\");                    \n-                    forachHandler.addArgument(forachBody);\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new MethodCallExpr(new NameExpr(\"h\"), \"getName\")).addArgument(new NameExpr(\"h\"));\n-                    \n-                    actionBody.addStatement(registerHandler);\n-                    \n-                    body.addStatement(forachHandler);\n-                } else {\n-                \n-                    String packageName = handler.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                    String clazzName = clazz.getName().toString();\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new StringLiteralExpr(name)).addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n-                    \n-                    body.addStatement(registerHandler);\n-                }\n-                // annotate for injection or add constructor for initialization\n-                handler.findAll(FieldDeclaration.class).forEach(fd -> {\n-                    if (useInjection()) {\n-                        annotator.withInjection(fd);\n-                    } else {\n-                        BlockStmt constructorBody = new BlockStmt();\n-                        AssignExpr assignExpr = new AssignExpr(\n-                                                               new FieldAccessExpr(new ThisExpr(), fd.getVariable(0).getNameAsString()),\n-                                                               new ObjectCreationExpr().setType(fd.getVariable(0).getType().toString()),\n-                                                               AssignExpr.Operator.ASSIGN);\n-                        \n-                        constructorBody.addStatement(assignExpr);\n-                        clazz.addConstructor(Keyword.PUBLIC).setBody(constructorBody);\n-                    }\n-                });\n-                \n-                \n-                additionalClasses.add(handler);\n-            });\n-        }\n+       \n         if (!processMetaData.getGeneratedListeners().isEmpty()) {\n+            BlockStmt body = new BlockStmt();\n+            MethodDeclaration internalConfigure = new MethodDeclaration()\n+                    .setModifiers(Modifier.Keyword.PUBLIC)\n+                    .setType(targetTypeName)\n+                    .setName(\"configure\")\n+                    .setBody(body);   \n             \n+            // always call super.configure\n+            body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n             processMetaData.getGeneratedListeners().forEach(listener -> {\n-                \n                 ClassOrInterfaceDeclaration clazz = listener.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                String packageName = listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                String clazzName = clazz.getName().toString();\n-                \n-                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");            \n-                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n+                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");\n+                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\")\n+                    .addArgument(\n+                        new ObjectCreationExpr(\n+                            null,\n+                            new ClassOrInterfaceType(\n+                                null,\n+                                listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\") + \".\" +clazz.getName()),", "originalCommit": "f4a7419d6f6c290514b84794ebb10760db8f4f2c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3679780366a503252dd72447f32d79ccecd0a91", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\nindex bf56f8891c..da3c048df4 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java\n\n@@ -275,7 +276,7 @@ public class ProcessGenerator {\n                 \"createProcessRuntime\");\n     }\n     \n-    private MethodDeclaration internalConfigure(ProcessMetaData processMetaData) {\n+    private Optional<MethodDeclaration> internalConfigure(ProcessMetaData processMetaData) {\n        \n         if (!processMetaData.getGeneratedListeners().isEmpty()) {\n             BlockStmt body = new BlockStmt();\n"}}, {"oid": "b3679780366a503252dd72447f32d79ccecd0a91", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b3679780366a503252dd72447f32d79ccecd0a91", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod", "committedDate": "2020-09-15T16:01:34Z", "type": "forcePushed"}, {"oid": "5b06fe0f50ce60a7fcab5194995d45518360f0f0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/5b06fe0f50ce60a7fcab5194995d45518360f0f0", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod", "committedDate": "2020-09-15T16:23:33Z", "type": "forcePushed"}, {"oid": "64c760c6733ab705a3f46d3a0240c0c2eec88926", "url": "https://github.com/kiegroup/kogito-runtimes/commit/64c760c6733ab705a3f46d3a0240c0c2eec88926", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod", "committedDate": "2020-09-15T16:29:21Z", "type": "forcePushed"}, {"oid": "8a6d8cf8f0bb7d3c08affb6d16138ad98b5deb56", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8a6d8cf8f0bb7d3c08affb6d16138ad98b5deb56", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod", "committedDate": "2020-09-15T16:35:05Z", "type": "forcePushed"}, {"oid": "668b8e79abdda43f950a77e32491698567ea5e7f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/668b8e79abdda43f950a77e32491698567ea5e7f", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod", "committedDate": "2020-09-16T11:35:04Z", "type": "forcePushed"}, {"oid": "3d2ad936d693997dbfbc15bfe60ead62fe128ed0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/3d2ad936d693997dbfbc15bfe60ead62fe128ed0", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-16T11:42:56Z", "type": "forcePushed"}, {"oid": "2d7d170ffc68fe262f7348ff7f06f3e2e85a7c6f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/2d7d170ffc68fe262f7348ff7f06f3e2e85a7c6f", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-16T12:18:16Z", "type": "forcePushed"}, {"oid": "621cf3fb7cd161c75ffccb2582f07e54510e0f45", "url": "https://github.com/kiegroup/kogito-runtimes/commit/621cf3fb7cd161c75ffccb2582f07e54510e0f45", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-16T12:21:49Z", "type": "forcePushed"}, {"oid": "cc5bec2f30055b626143312e7df259fffb856d9e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/cc5bec2f30055b626143312e7df259fffb856d9e", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-16T12:31:11Z", "type": "forcePushed"}, {"oid": "1a4e7812c48f489300dfbe6621c4c4c51a7a723b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1a4e7812c48f489300dfbe6621c4c4c51a7a723b", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-16T12:53:18Z", "type": "forcePushed"}, {"oid": "ce2470fec8eb328521d6acec77e0852de84b500f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/ce2470fec8eb328521d6acec77e0852de84b500f", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-16T13:07:28Z", "type": "forcePushed"}, {"oid": "fb526db31592ec6f425ebda7d6dc712967f99898", "url": "https://github.com/kiegroup/kogito-runtimes/commit/fb526db31592ec6f425ebda7d6dc712967f99898", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-16T13:41:46Z", "type": "forcePushed"}, {"oid": "eb8ba60cd15d8df5774f11cfc4eaac7b1c0b6a60", "url": "https://github.com/kiegroup/kogito-runtimes/commit/eb8ba60cd15d8df5774f11cfc4eaac7b1c0b6a60", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-16T13:42:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3NTI0Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489575247", "bodyText": "What about rename lazy to something like forceLazyInit or similar? Mainly because lazy=false doesn't mean eager but means \"use framework default\"", "author": "danielezonca", "createdAt": "2020-09-16T16:39:15Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java", "diffHunk": "@@ -86,8 +85,19 @@\n      * Annotates given node with injection annotations e.g. Inject, Autowire\n      *\n      * @param node node to be annotated\n+     * @boolean lazy use lazy initialization\n      */\n-    <T extends NodeWithAnnotations<?>> T withInjection(T node);\n+    <T extends NodeWithAnnotations<?>> T withInjection(T node, boolean lazy);", "originalCommit": "eb8ba60cd15d8df5774f11cfc4eaac7b1c0b6a60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU4MDQyNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489580424", "bodyText": "good point, done", "author": "fjtirado", "createdAt": "2020-09-16T16:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3NTI0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "9df588b31e9c9cac222fb124e25d9aa0f4aacdf7", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java\nindex 89d412bb2c..7f273dd360 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java\n\n@@ -85,9 +85,9 @@ public interface DependencyInjectionAnnotator {\n      * Annotates given node with injection annotations e.g. Inject, Autowire\n      *\n      * @param node node to be annotated\n-     * @boolean lazy use lazy initialization\n+     * @boolean forceLazyInit use lazy initialization (for those container that applies)\n      */\n-    <T extends NodeWithAnnotations<?>> T withInjection(T node, boolean lazy);\n+    <T extends NodeWithAnnotations<?>> T withInjection(T node, boolean forceLazyInit);\n \n     /**\n      * Annotates given node with injection annotations e.g. Inject, Autowire\n"}}, {"oid": "9df588b31e9c9cac222fb124e25d9aa0f4aacdf7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9df588b31e9c9cac222fb124e25d9aa0f4aacdf7", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-16T16:46:59Z", "type": "forcePushed"}, {"oid": "b58330fba2f3e7d9c2da3d994470c40dbd0b8f66", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b58330fba2f3e7d9c2da3d994470c40dbd0b8f66", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-16T16:47:27Z", "type": "commit"}, {"oid": "b58330fba2f3e7d9c2da3d994470c40dbd0b8f66", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b58330fba2f3e7d9c2da3d994470c40dbd0b8f66", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now.", "committedDate": "2020-09-16T16:47:27Z", "type": "forcePushed"}]}