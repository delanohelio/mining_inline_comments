{"pr_number": 537, "pr_title": "[KOGITO-2168] Implement Conditions for Milestones", "pr_createdAt": "2020-06-01T16:00:20Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/537", "timeline": [{"oid": "f8da34386aa5a84bb6593aa79058778079d318e0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f8da34386aa5a84bb6593aa79058778079d318e0", "message": "[KOGITO-2168] Implemented conditions for Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-02T07:22:05Z", "type": "forcePushed"}, {"oid": "94377400c07ac62733b6c2e72a5a7d2a5addd40d", "url": "https://github.com/kiegroup/kogito-runtimes/commit/94377400c07ac62733b6c2e72a5a7d2a5addd40d", "message": "[KOGITO-2168] Implement conditions for Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-03T09:23:13Z", "type": "forcePushed"}, {"oid": "9ea08aafe0617605b53f9a3dc9dc532f8f5f8fc0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9ea08aafe0617605b53f9a3dc9dc532f8f5f8fc0", "message": "[KOGITO-2168] Implement conditions for Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-03T09:25:13Z", "type": "forcePushed"}, {"oid": "1b4926c544907c28b5d9a323118bbe9972b1f9db", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1b4926c544907c28b5d9a323118bbe9972b1f9db", "message": "[KOGITO-2168] Implement conditions for Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-03T09:31:07Z", "type": "forcePushed"}, {"oid": "f2741024e7a8f8c7f204503b1ceea4a7387c04a1", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f2741024e7a8f8c7f204503b1ceea4a7387c04a1", "message": "[KOGITO-2168] Implement conditions for Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-03T09:38:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNjExNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r434516117", "bodyText": "if this is a constraint expression why is it a string and not an expression?", "author": "evacchi", "createdAt": "2020-06-03T12:05:22Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/MilestoneNodeVisitor.java", "diffHunk": "@@ -37,13 +48,36 @@ protected String getNodeKey() {\n     @Override\n     public void visitNode(String factoryField, MilestoneNode node, BlockStmt body, VariableScope variableScope, ProcessMetaData metadata) {\n         body.addStatement(getAssignedFactoryMethod(factoryField, MilestoneNodeFactory.class, getNodeId(node), getNodeKey(), new LongLiteralExpr(node.getId())))\n-                .addStatement(getNameMethod(node, \"Milestone\"))\n-                .addStatement(getFactoryMethod(getNodeId(node), METHOD_CONSTRAINT, new StringLiteralExpr(StringEscapeUtils.escapeJava(node.getConstraint()))));\n+                .addStatement(getNameMethod(node, \"Milestone\"));\n+        if(node.getConstraint() != null && !node.getConstraint().trim().isEmpty()) {\n+            body.addStatement(getFactoryMethod(getNodeId(node), METHOD_CONSTRAINT, new StringLiteralExpr(StringEscapeUtils.escapeJava(node.getConstraint()))));", "originalCommit": "f2741024e7a8f8c7f204503b1ceea4a7387c04a1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "148c721391839a23b44f63f269c2682e664417d9", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/MilestoneNodeVisitor.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/MilestoneNodeVisitor.java\nindex 089977d140..f3d52bbba2 100644\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/MilestoneNodeVisitor.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/MilestoneNodeVisitor.java\n\n@@ -49,20 +46,16 @@ public class MilestoneNodeVisitor extends AbstractNodeVisitor<MilestoneNode> {\n     public void visitNode(String factoryField, MilestoneNode node, BlockStmt body, VariableScope variableScope, ProcessMetaData metadata) {\n         body.addStatement(getAssignedFactoryMethod(factoryField, MilestoneNodeFactory.class, getNodeId(node), getNodeKey(), new LongLiteralExpr(node.getId())))\n                 .addStatement(getNameMethod(node, \"Milestone\"));\n-        if(node.getConstraint() != null && !node.getConstraint().trim().isEmpty()) {\n-            body.addStatement(getFactoryMethod(getNodeId(node), METHOD_CONSTRAINT, new StringLiteralExpr(StringEscapeUtils.escapeJava(node.getConstraint()))));\n+        if(node.getMetaData(CONDITION) != null) {\n             body.addStatement(getConditionStatement(node, variableScope));\n         }\n-        if (node.getMatchVariable() != null) {\n-            body.addStatement(getFactoryMethod(getNodeId(node), METHOD_MATCH_VARIABLE, new StringLiteralExpr(node.getMatchVariable())));\n-        }\n         body.addStatement(getDoneMethod(getNodeId(node)));\n         visitMetaData(node.getMetaData(), body, getNodeId(node));\n     }\n \n     private MethodCallExpr getConditionStatement(MilestoneNode node, VariableScope scope) {\n-        String consequence = node.getConstraint();\n-        if (consequence == null ) {\n+        String consequence = (String) node.getMetaData(CONDITION);\n+        if (consequence == null || consequence.trim().isEmpty() ) {\n             throw new IllegalStateException(\"Milestone node \" + node.getId() + \" name \" + node.getName() + \" has no condition defined\");\n         }\n         BlockStmt conditionBody = new BlockStmt();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNzU0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r434517545", "bodyText": "not your code, but I am noticing that an exception is thrown after fail(); so, I believe it's actually never thrown. You can probably remove the throw?", "author": "evacchi", "createdAt": "2020-06-03T12:08:03Z", "path": "jbpm/jbpm-flow-builder/src/test/java/org/jbpm/test/util/AbstractBaseTest.java", "diffHunk": "@@ -46,7 +46,7 @@ public KieSession createKieSession(KiePackage... pkg) {\n         try { \n             return createKieSession(false, pkg);\n         } catch(Exception e ) { \n-            String msg = \"There's no reason fo an exception to be thrown here (because the kbase is not being serialized)!\";\n+            String msg = \"There's no reason for an exception to be thrown here (because the kbase is not being serialized)!\";\n             fail( msg );\n             throw new RuntimeException(msg, e);", "originalCommit": "f2741024e7a8f8c7f204503b1ceea4a7387c04a1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "148c721391839a23b44f63f269c2682e664417d9", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/test/java/org/jbpm/test/util/AbstractBaseTest.java b/jbpm/jbpm-flow-builder/src/test/java/org/jbpm/test/util/AbstractBaseTest.java\nindex 59af035d22..1f8c3b525a 100755\n--- a/jbpm/jbpm-flow-builder/src/test/java/org/jbpm/test/util/AbstractBaseTest.java\n+++ b/jbpm/jbpm-flow-builder/src/test/java/org/jbpm/test/util/AbstractBaseTest.java\n\n@@ -45,10 +45,8 @@ public abstract class AbstractBaseTest {\n     public KieSession createKieSession(KiePackage... pkg) { \n         try { \n             return createKieSession(false, pkg);\n-        } catch(Exception e ) { \n-            String msg = \"There's no reason for an exception to be thrown here (because the kbase is not being serialized)!\";\n-            fail( msg );\n-            throw new RuntimeException(msg, e);\n+        } catch(Exception e ) {\n+            throw new RuntimeException(\"There's no reason for an exception to be thrown here (because the kbase is not being serialized)!\", e);\n         }\n     } \n    \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxODEyOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r434518128", "bodyText": "if there is a rule flow group is no longer used, do we still need this line?", "author": "evacchi", "createdAt": "2020-06-03T12:09:03Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java", "diffHunk": "@@ -79,9 +79,8 @@ public void internalTrigger(NodeInstance from, String type) {\n                 agenda.getRuleFlowGroup(ruleFlowGroup).setAutoDeactivate(false);\n                 agenda.activateRuleFlowGroup(ruleFlowGroup, getProcessInstance().getId(), getUniqueId());\n             }\n-            String rule =  \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId() + \"-\" + getDynamicNode().getUniqueId();\n             isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                    .isRuleActiveInRuleFlowGroup(getRuleFlowGroupName(), rule, getProcessInstance().getId());\n+                    .isRuleActiveInRuleFlowGroup(getRuleFlowGroupName(), getActivationEventType(), getProcessInstance().getId());", "originalCommit": "f2741024e7a8f8c7f204503b1ceea4a7387c04a1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java\nindex 69f0e61272..ebdc993eee 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java\n\n@@ -66,133 +73,138 @@ public class DynamicNodeInstance extends CompositeContextNodeInstance implements\n         triggerTime = new Date();\n         triggerEvent(EVENT_NODE_ENTER);\n \n-    \t// if node instance was cancelled, abort\n-\t\tif (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n-\t\t\treturn;\n-\t\t}\n-        boolean isActive = false;\n-        // KOGITO-2168 Conditions not supported\n-        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n-            InternalAgenda agenda = (InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda();\n-            String ruleFlowGroup = getRuleFlowGroupName();\n-            if (ruleFlowGroup != null && !agenda.getRuleFlowGroup(ruleFlowGroup).isActive()) {\n-                agenda.getRuleFlowGroup(ruleFlowGroup).setAutoDeactivate(false);\n-                agenda.activateRuleFlowGroup(ruleFlowGroup, getProcessInstance().getId(), getUniqueId());\n-            }\n-            isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                    .isRuleActiveInRuleFlowGroup(getRuleFlowGroupName(), getActivationEventType(), getProcessInstance().getId());\n+        // if node instance was cancelled, abort\n+        if (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n+            return;\n         }\n-        if (isActive) {\n-            triggerCompleted();\n+        if (canActivate()) {\n+            triggerActivated();\n         } else {\n+            setState(ProcessInstance.STATE_PENDING);\n             addActivationListener();\n         }\n+    }\n \n-    \t// activate ad hoc fragments if they are marked as such\n+    private void triggerActivated() {\n+        setState(ProcessInstance.STATE_ACTIVE);\n+        // activate ad hoc fragments if they are marked as such\n         List<Node> autoStartNodes = getDynamicNode().getAutoStartNodes();\n-        autoStartNodes.forEach(austoStartNode -> triggerSelectedNode(austoStartNode, null));\n+        autoStartNodes.forEach(autoStartNode -> triggerSelectedNode(autoStartNode, null));\n+        addCompletionListener();\n     }\n \n-    @Override\n-    public void addEventListeners() {\n-        super.addEventListeners();\n-        addActivationListener();\n+    private boolean canActivate() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getDynamicNode().testActivation(context);\n     }\n \n-    @Override\n-    public void removeEventListeners() {\n-        super.removeEventListeners();\n-        getProcessInstance().getKnowledgeRuntime().removeEventListener(this);\n-        getProcessInstance().removeEventListener(getActivationEventType(), this, true);\n+    private boolean canComplete() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getNodeInstances().isEmpty() && getDynamicNode().testCompletion(context);\n     }\n-    \n+\n     private void addActivationListener() {\n-        getProcessInstance().getKnowledgeRuntime().addEventListener(this);\n-        getProcessInstance().addEventListener(getActivationEventType(), this, true);\n+        getProcessInstance().getKnowledgeRuntime().getProcessRuntime().addEventListener(ContextAwareEventListener.using(listener -> {\n+            if (canActivate() && getState() == ProcessInstance.STATE_PENDING) {\n+                triggerActivated();\n+                getProcessInstance().getKnowledgeRuntime().getProcessRuntime().removeEventListener(listener);\n+            }\n+        }));\n     }\n-    \n-    private String getActivationEventType() {\n-        return \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId()\n-            + \"-\" + getDynamicNode().getUniqueId();\n+\n+    private void addCompletionListener() {\n+        getProcessInstance().getKnowledgeRuntime()\n+                .getProcessRuntime()\n+                .addEventListener(ContextAwareEventListener.using(listener -> {\n+                    if (canComplete()) {\n+                        triggerCompleted();\n+                        getProcessInstance().getKnowledgeRuntime().getProcessRuntime().removeEventListener(listener);\n+                    }\n+                }));\n     }\n \n     @Override\n-\tpublic void nodeInstanceCompleted(org.jbpm.workflow.instance.NodeInstance nodeInstance, String outType) {\n-\t    Node nodeInstanceNode = nodeInstance.getNode();\n-\t    if( nodeInstanceNode != null ) {\n-\t        Object compensationBoolObj =  nodeInstanceNode.getMetaData().get(\"isForCompensation\");\n-\t        boolean isForCompensation = compensationBoolObj == null ? false : ((Boolean) compensationBoolObj);\n-\t        if( isForCompensation ) {\n-\t            return;\n-\t        }\n-\t    }\n-\t    String completionCondition = getDynamicNode().getCompletionExpression();\n-\t\t// TODO what if we reach the end of one branch but others might still need to be created ?\n-\t\t// TODO are we sure there will always be node instances left if we are not done yet?\n-\t\tif (isTerminated(nodeInstance)) {\n-\t\t    triggerCompleted(CONNECTION_DEFAULT_TYPE);\n-\t\t} else if (getDynamicNode().isAutoComplete() && getNodeInstances(false).isEmpty()) {\n-    \t\ttriggerCompleted(CONNECTION_DEFAULT_TYPE);\n-    \t} else if (completionCondition != null && \"mvel\".equals(getDynamicNode().getLanguage())) {\n-    \t\tObject value = MVELSafeHelper.getEvaluator().eval(completionCondition, new NodeInstanceResolverFactory(this));\n-    \t\tif ( !(value instanceof Boolean) ) {\n-                throw new RuntimeException( \"Completion condition expression must return boolean values: \" + value\n-                \t\t+ \" for expression \" + completionCondition);\n+    public void nodeInstanceCompleted(org.jbpm.workflow.instance.NodeInstance nodeInstance, String outType) {\n+        Node nodeInstanceNode = nodeInstance.getNode();\n+        if (nodeInstanceNode != null) {\n+            Object compensationBoolObj = nodeInstanceNode.getMetaData().get(IS_FOR_COMPENSATION);\n+            if (Boolean.TRUE.equals(compensationBoolObj)) {\n+                return;\n             }\n-            if (((Boolean) value).booleanValue()) {\n-            \ttriggerCompleted(CONNECTION_DEFAULT_TYPE);\n+        }\n+        String completionCondition = getDynamicNode().getCompletionExpression();\n+        // TODO what if we reach the end of one branch but others might still need to be created ?\n+        // TODO are we sure there will always be node instances left if we are not done yet?\n+        if (isTerminated(nodeInstance)) {\n+            triggerCompleted(CONNECTION_DEFAULT_TYPE);\n+        } else if (getDynamicNode().isAutoComplete() && getNodeInstances(false).isEmpty()) {\n+            triggerCompleted(CONNECTION_DEFAULT_TYPE);\n+        } else if (completionCondition != null && \"mvel\".equals(getDynamicNode().getLanguage())) {\n+            Object value = MVELSafeHelper.getEvaluator().eval(completionCondition, new NodeInstanceResolverFactory(this));\n+            if (!(value instanceof Boolean)) {\n+                throw new RuntimeException(\"Completion condition expression must return boolean values: \" + value\n+                        + \" for expression \" + completionCondition);\n+            }\n+            if ((Boolean) value) {\n+                triggerCompleted(CONNECTION_DEFAULT_TYPE);\n             }\n-    \t}\n-\t}\n+        }\n+    }\n \n-\t@Override\n+    @Override\n     public void triggerCompleted(String outType) {\n-\t    if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n-\t        ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n+        if (getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n+            ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n                     .deactivateRuleFlowGroup(getRuleFlowGroupName());\n         }\n-    \tsuper.triggerCompleted(outType);\n+        super.triggerCompleted(outType);\n+    }\n+\n+    private String getActivationEventType() {\n+        return \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId()\n+                + \"-\" + getDynamicNode().getUniqueId();\n     }\n \n-    \n     @Override\n-\tpublic void signalEvent(String type, Object event) {\n+    public void signalEvent(String type, Object event) {\n         if (type.startsWith(\"RuleFlow-AdHocActivate\")) {\n             if (event instanceof MatchCreatedEvent) {\n-                Match match = ((MatchCreatedEvent) event).getMatch();                \n-                match.getDeclarationIds().forEach(s -> this.setVariable(s.replaceFirst(\"\\\\$\", \"\"), match.getDeclarationValue(s)));                \n-            }            \n+                Match match = ((MatchCreatedEvent) event).getMatch();\n+                match.getDeclarationIds().forEach(s -> this.setVariable(s.replaceFirst(\"\\\\$\", \"\"), match.getDeclarationValue(s)));\n+            }\n             trigger(null, CONNECTION_DEFAULT_TYPE);\n         } else if (getActivationEventType().equals(type)) {\n             if (event instanceof MatchCreatedEvent) {\n                 matchCreated((MatchCreatedEvent) event);\n             }\n         } else {\n-    \t\tsuper.signalEvent(type, event);\n-    \t\tfor (Node node: getCompositeNode().getNodes()) {\n-    \t\t    \n-    \t\t\tif (type.equals(resolveVariable(node.getName())) && node.getIncomingConnections().isEmpty()) {\n-        \t\t\ttriggerSelectedNode(node, event);\n-        \t\t}\n-    \t\t}\n+            super.signalEvent(type, event);\n+            for (Node node : getCompositeNode().getNodes()) {\n+\n+                if (type.equals(resolveVariable(node.getName())) && node.getIncomingConnections().isEmpty()) {\n+                    triggerSelectedNode(node, event);\n+                }\n+            }\n         }\n-\t}\n+    }\n \n     protected boolean isTerminated(NodeInstance from) {\n         if (from instanceof EndNodeInstance) {\n             return ((EndNodeInstance) from).getEndNode().isTerminate();\n         }\n-        \n+\n         return false;\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     protected void triggerSelectedNode(Node node, Object event) {\n         org.jbpm.workflow.instance.NodeInstance nodeInstance = getNodeInstance(node);\n-        if (event != null) {                             \n+        if (event != null) {\n             Map<String, Object> dynamicParams = new HashMap<>();\n             if (event instanceof Map) {\n-                dynamicParams.putAll((Map<String, Object>) event);                                  \n+                dynamicParams.putAll((Map<String, Object>) event);\n             } else {\n                 dynamicParams.put(\"Data\", event);\n             }\n"}}, {"oid": "148c721391839a23b44f63f269c2682e664417d9", "url": "https://github.com/kiegroup/kogito-runtimes/commit/148c721391839a23b44f63f269c2682e664417d9", "message": "[KOGITO-2168] Remove tests\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-05T07:28:07Z", "type": "forcePushed"}, {"oid": "0f977170608dcb5f53296d8673928ac2b897eb41", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0f977170608dcb5f53296d8673928ac2b897eb41", "message": "[KOGITO-2168] Remove tests\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-05T07:35:26Z", "type": "forcePushed"}, {"oid": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9247a78035bd43d0e0a253ede4d635d39acc7aa6", "message": "[KOGITO-2168] Add DynamicNode activation/completion conditions\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-08T19:56:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMwNDk1OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437304959", "bodyText": "why not keep as Milestone?", "author": "cristianonicolai", "createdAt": "2020-06-09T10:25:25Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "diffHunk": "@@ -189,7 +189,7 @@\n      *\n      * @return All the process milestones with their current status\n      */\n-    Collection<Milestone> milestones();", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxNjExNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437416116", "bodyText": "reverting", "author": "ruromero", "createdAt": "2020-06-09T13:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMwNDk1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "19cae39940a1bf24deaaf43eb5b3325219e8c424", "chunk": "diff --git a/api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java b/api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java\nindex 08160e82d0..2ce90e56bb 100644\n--- a/api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java\n+++ b/api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java\n\n@@ -189,7 +189,7 @@ public interface ProcessInstance<T> {\n      *\n      * @return All the process milestones with their current status\n      */\n-    Collection<ItemDescription> milestones();\n+    Collection<Milestone> milestones();\n \n     /**\n      * Returns the process adHocFragments\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwOTQ1MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437409451", "bodyText": "what about isActivated(ProcessContext context)?", "author": "tiagodolphine", "createdAt": "2020-06-09T13:18:27Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java", "diffHunk": "@@ -109,4 +119,22 @@ public String getActivationEventName() {\n         \n         return activationSignalName;\n     }\n+\n+    public DynamicNode setActivationExpression(Predicate<ProcessContext> activationPredicate) {\n+        this.activationPredicate = activationPredicate;\n+        return this;\n+    }\n+\n+    public DynamicNode setCompletionExpression(Predicate<ProcessContext> copmletionPredicate) {\n+        this.completionPredicate = copmletionPredicate;\n+        return this;\n+    }\n+\n+    public boolean testActivation(ProcessContext context) {", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19cae39940a1bf24deaaf43eb5b3325219e8c424", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java\nindex 151ca86378..4e4b1dd03b 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java\n\n@@ -31,93 +28,37 @@ import static org.jbpm.ruleflow.core.Metadata.CUSTOM_AUTO_START;\n \n public class DynamicNode extends CompositeContextNode {\n \n-\tprivate static final long serialVersionUID = 510l;\n-\t\n-\tprivate String activationExpression;\n-\tprivate String completionExpression;\n+    private static final long serialVersionUID = 510L;\n+\n     private Predicate<ProcessContext> activationPredicate;\n     private Predicate<ProcessContext> completionPredicate;\n-\tprivate String language;\n+    private String language;\n \n     public DynamicNode() {\n-        autoComplete = false;\n+        setAutoComplete(false);\n     }\n \n     @Override\n-    public boolean acceptsEvent(String type, Object event, Function<String, String> resolver) {\n-        if (type.equals(getActivationEventName())) {\n-            return true;\n-        }\n-\n-        for (Node node : getNodes()) {\n-            if (resolver.apply(node.getName()).contains(type) && node.getIncomingConnections().isEmpty()) {\n-                return true;\n-            }\n-        }\n-        return super.acceptsEvent(type, event);\n-    }\n-\n-    public boolean acceptsEvent(String type, Object event) {\n-        if (type.equals(getActivationEventName())) {\n-            return true;\n-        }\n-\n-        for (Node node : getNodes()) {\n-            if (type.equals(node.getName()) && node.getIncomingConnections().isEmpty()) {\n-                return true;\n-            }\n-        }\n-        return super.acceptsEvent(type, event);\n-    }\n-\t\n     public Node internalGetNode(long id) {\n-    \ttry {\n-    \t\treturn getNode(id);\n-    \t} catch (IllegalArgumentException e) {\n-    \t\treturn null;\n-    \t}\n-    }\n-\n-\tpublic String getCompletionExpression() {\n-\t\treturn completionExpression;\n-\t}\n-\n-\tpublic void setCompletionExpression(String expression) {\n-\t\tthis.completionExpression = expression;\n-\t}\n-\n-    public String getActivationExpression() {\n-        return activationExpression;\n-    }\n-    \n-    public void setActivationExpression(String activationExpression) {\n-        this.activationExpression = activationExpression;\n+        try {\n+            return getNode(id);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n     }\n \n     public String getLanguage() {\n         return language;\n     }\n-   \n+\n     public void setLanguage(String language) {\n         this.language = language;\n     }\n \n     public List<Node> getAutoStartNodes() {\n-  \n-        List<Node> nodes = Arrays.stream(getNodes())\n-                .filter(n -> n.getIncomingConnections().isEmpty() && \"true\".equalsIgnoreCase((String)n.getMetaData().get(CUSTOM_AUTO_START)))\n+        return Arrays.stream(getNodes())\n+                .filter(n -> n.getIncomingConnections().isEmpty() && \"true\".equalsIgnoreCase((String) n.getMetaData().get(CUSTOM_AUTO_START)))\n                 .collect(Collectors.toList());\n-                \n-        return nodes;\n-    }\n-    \n-    public String getActivationEventName() {\n-        if (activationExpression == null || activationExpression.isEmpty()) {\n-            return null;\n-        }\n-        String activationSignalName = \"RuleFlow-AdHocActivate-\" + ((WorkflowProcess) getParentContainer()).getId() + \"-\" + getUniqueId();\n-        \n-        return activationSignalName;\n     }\n \n     public DynamicNode setActivationExpression(Predicate<ProcessContext> activationPredicate) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwOTc4Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437409782", "bodyText": "what about  isCompleted(ProcessContext context)?", "author": "tiagodolphine", "createdAt": "2020-06-09T13:18:57Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java", "diffHunk": "@@ -109,4 +119,22 @@ public String getActivationEventName() {\n         \n         return activationSignalName;\n     }\n+\n+    public DynamicNode setActivationExpression(Predicate<ProcessContext> activationPredicate) {\n+        this.activationPredicate = activationPredicate;\n+        return this;\n+    }\n+\n+    public DynamicNode setCompletionExpression(Predicate<ProcessContext> copmletionPredicate) {\n+        this.completionPredicate = copmletionPredicate;\n+        return this;\n+    }\n+\n+    public boolean testActivation(ProcessContext context) {\n+        return activationPredicate == null || activationPredicate.test(context);\n+    }\n+\n+    public boolean testCompletion(ProcessContext context) {", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19cae39940a1bf24deaaf43eb5b3325219e8c424", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java\nindex 151ca86378..4e4b1dd03b 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java\n\n@@ -31,93 +28,37 @@ import static org.jbpm.ruleflow.core.Metadata.CUSTOM_AUTO_START;\n \n public class DynamicNode extends CompositeContextNode {\n \n-\tprivate static final long serialVersionUID = 510l;\n-\t\n-\tprivate String activationExpression;\n-\tprivate String completionExpression;\n+    private static final long serialVersionUID = 510L;\n+\n     private Predicate<ProcessContext> activationPredicate;\n     private Predicate<ProcessContext> completionPredicate;\n-\tprivate String language;\n+    private String language;\n \n     public DynamicNode() {\n-        autoComplete = false;\n+        setAutoComplete(false);\n     }\n \n     @Override\n-    public boolean acceptsEvent(String type, Object event, Function<String, String> resolver) {\n-        if (type.equals(getActivationEventName())) {\n-            return true;\n-        }\n-\n-        for (Node node : getNodes()) {\n-            if (resolver.apply(node.getName()).contains(type) && node.getIncomingConnections().isEmpty()) {\n-                return true;\n-            }\n-        }\n-        return super.acceptsEvent(type, event);\n-    }\n-\n-    public boolean acceptsEvent(String type, Object event) {\n-        if (type.equals(getActivationEventName())) {\n-            return true;\n-        }\n-\n-        for (Node node : getNodes()) {\n-            if (type.equals(node.getName()) && node.getIncomingConnections().isEmpty()) {\n-                return true;\n-            }\n-        }\n-        return super.acceptsEvent(type, event);\n-    }\n-\t\n     public Node internalGetNode(long id) {\n-    \ttry {\n-    \t\treturn getNode(id);\n-    \t} catch (IllegalArgumentException e) {\n-    \t\treturn null;\n-    \t}\n-    }\n-\n-\tpublic String getCompletionExpression() {\n-\t\treturn completionExpression;\n-\t}\n-\n-\tpublic void setCompletionExpression(String expression) {\n-\t\tthis.completionExpression = expression;\n-\t}\n-\n-    public String getActivationExpression() {\n-        return activationExpression;\n-    }\n-    \n-    public void setActivationExpression(String activationExpression) {\n-        this.activationExpression = activationExpression;\n+        try {\n+            return getNode(id);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n     }\n \n     public String getLanguage() {\n         return language;\n     }\n-   \n+\n     public void setLanguage(String language) {\n         this.language = language;\n     }\n \n     public List<Node> getAutoStartNodes() {\n-  \n-        List<Node> nodes = Arrays.stream(getNodes())\n-                .filter(n -> n.getIncomingConnections().isEmpty() && \"true\".equalsIgnoreCase((String)n.getMetaData().get(CUSTOM_AUTO_START)))\n+        return Arrays.stream(getNodes())\n+                .filter(n -> n.getIncomingConnections().isEmpty() && \"true\".equalsIgnoreCase((String) n.getMetaData().get(CUSTOM_AUTO_START)))\n                 .collect(Collectors.toList());\n-                \n-        return nodes;\n-    }\n-    \n-    public String getActivationEventName() {\n-        if (activationExpression == null || activationExpression.isEmpty()) {\n-            return null;\n-        }\n-        String activationSignalName = \"RuleFlow-AdHocActivate-\" + ((WorkflowProcess) getParentContainer()).getId() + \"-\" + getUniqueId();\n-        \n-        return activationSignalName;\n     }\n \n     public DynamicNode setActivationExpression(Predicate<ProcessContext> activationPredicate) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxOTU5OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437419599", "bodyText": "isConditionAchived? isConditionMatched? well no idea what would be a better name, just thinking the \"test\" prefix is strange...", "author": "tiagodolphine", "createdAt": "2020-06-09T13:33:00Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java", "diffHunk": "@@ -16,71 +16,56 @@\n \n package org.jbpm.workflow.core.node;\n \n+import java.util.function.Predicate;\n+\n import org.kie.api.definition.process.Connection;\n-import org.jbpm.workflow.core.Constraint;\n-import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.kie.api.runtime.process.ProcessContext;\n+\n+import static org.jbpm.ruleflow.core.Metadata.UNIQUE_ID;\n \n /**\n  * Default implementation of a milestone node.\n- * \n  */\n public class MilestoneNode extends StateBasedNode implements Constrainable {\n \n-\tprivate static final long serialVersionUID = 510l;\n+    private static final long serialVersionUID = 510L;\n \n-\tprivate String constraint;\n-\tprivate String matchVariable;\n+    private Predicate<ProcessContext> conditionPredicate;\n \n-    public void addConstraint(ConnectionRef connection, Constraint constraint) {\n-    \tif (connection != null) {\n-    \t\tthrow new IllegalArgumentException(\n-\t\t\t\t\"A Milestone node only accepts one simple constraint\");\n-    \t}\n-        this.constraint = constraint.getConstraint();\n-    }\n-    \n-    public void setConstraint(String constraint){\n-        this.constraint = constraint;\n+    public void setCondition(Predicate<ProcessContext> conditionPredicate) {\n+        this.conditionPredicate = conditionPredicate;\n     }\n \n-    public String getConstraint(){\n-        return this.constraint;\n-    }    \n-    \n-    public String getMatchVariable() {\n-        return matchVariable;\n-    }\n-    \n-    public void setMatchVariable(String matchVariable) {\n-        this.matchVariable = matchVariable;\n+    public boolean testCondition(ProcessContext context) {", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NjMwOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437856308", "bodyText": "+1", "author": "cristianonicolai", "createdAt": "2020-06-10T04:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxOTU5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java\nindex 9a93f559b1..79ba078f51 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java\n\n@@ -30,13 +30,25 @@ public class MilestoneNode extends StateBasedNode implements Constrainable {\n \n     private static final long serialVersionUID = 510L;\n \n+    /**\n+     * String representation of the conditionPredicate. Not used at runtime\n+     */\n+    private String condition;\n     private Predicate<ProcessContext> conditionPredicate;\n \n+    public void setCondition(String condition) {\n+        this.condition = condition;\n+    }\n+\n+    public String getCondition() {\n+        return condition;\n+    }\n+\n     public void setCondition(Predicate<ProcessContext> conditionPredicate) {\n         this.conditionPredicate = conditionPredicate;\n     }\n \n-    public boolean testCondition(ProcessContext context) {\n+    public boolean canComplete(ProcessContext context) {\n         return conditionPredicate == null || conditionPredicate.test(context);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNjY2Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437426667", "bodyText": "one option is to add a constructor to initialize this the field and keep the default as true.", "author": "tiagodolphine", "createdAt": "2020-06-09T13:41:56Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/CompositeNode.java", "diffHunk": "@@ -41,7 +38,7 @@\n     private Map<String, CompositeNode.NodeAndType> outConnectionMap = new HashMap<String, CompositeNode.NodeAndType>();\n \tprivate boolean cancelRemainingInstances = true;\n \n-\tprivate boolean autoComplete = true;\n+\tboolean autoComplete = true;", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MTY5MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437441690", "bodyText": "that is a mistake, indeed. I already reverted it", "author": "ruromero", "createdAt": "2020-06-09T13:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNjY2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "19cae39940a1bf24deaaf43eb5b3325219e8c424", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/CompositeNode.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/CompositeNode.java\nindex 561c5a37e5..7ffd3347f1 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/CompositeNode.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/CompositeNode.java\n\n@@ -37,8 +37,7 @@ public class CompositeNode extends StateBasedNode implements NodeContainer, Even\n     private Map<String, CompositeNode.NodeAndType> inConnectionMap = new HashMap<String, CompositeNode.NodeAndType>();\n     private Map<String, CompositeNode.NodeAndType> outConnectionMap = new HashMap<String, CompositeNode.NodeAndType>();\n \tprivate boolean cancelRemainingInstances = true;\n-\n-\tboolean autoComplete = true;\n+\tprivate boolean autoComplete = true;\n \t\n     public CompositeNode() {\n         this.nodeContainer = new NodeContainerImpl();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNzM2NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437427365", "bodyText": "one option is to use a constructor on the superclass.", "author": "tiagodolphine", "createdAt": "2020-06-09T13:42:35Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java", "diffHunk": "@@ -19,20 +19,30 @@\n import java.util.Arrays;\n import java.util.List;\n import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n+import org.jbpm.ruleflow.core.Metadata;\n import org.jbpm.workflow.core.WorkflowProcess;\n import org.kie.api.definition.process.Node;\n+import org.kie.api.runtime.process.ProcessContext;\n \n+import static org.jbpm.ruleflow.core.Metadata.CUSTOM_AUTO_START;\n \n public class DynamicNode extends CompositeContextNode {\n \n \tprivate static final long serialVersionUID = 510l;\n \t\n \tprivate String activationExpression;\n \tprivate String completionExpression;\n+    private Predicate<ProcessContext> activationPredicate;\n+    private Predicate<ProcessContext> completionPredicate;\n \tprivate String language;\n-\t\t\t\n+\n+    public DynamicNode() {\n+        autoComplete = false;", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19cae39940a1bf24deaaf43eb5b3325219e8c424", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java\nindex 151ca86378..4e4b1dd03b 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java\n\n@@ -18,12 +18,9 @@ package org.jbpm.workflow.core.node;\n \n import java.util.Arrays;\n import java.util.List;\n-import java.util.function.Function;\n import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n-import org.jbpm.ruleflow.core.Metadata;\n-import org.jbpm.workflow.core.WorkflowProcess;\n import org.kie.api.definition.process.Node;\n import org.kie.api.runtime.process.ProcessContext;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437436063", "bodyText": "What about keeping the method getConstraint() and just returning the getMetadata(\"CONDITION\") on it, or change to getCondition(), just to simplify for callers, instead of doing the milestone.getMetadata(CONDITION)...", "author": "tiagodolphine", "createdAt": "2020-06-09T13:50:52Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java", "diffHunk": "@@ -16,71 +16,56 @@\n \n package org.jbpm.workflow.core.node;\n \n+import java.util.function.Predicate;\n+\n import org.kie.api.definition.process.Connection;\n-import org.jbpm.workflow.core.Constraint;\n-import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.kie.api.runtime.process.ProcessContext;\n+\n+import static org.jbpm.ruleflow.core.Metadata.UNIQUE_ID;\n \n /**\n  * Default implementation of a milestone node.\n- * \n  */\n public class MilestoneNode extends StateBasedNode implements Constrainable {\n \n-\tprivate static final long serialVersionUID = 510l;\n+    private static final long serialVersionUID = 510L;\n \n-\tprivate String constraint;\n-\tprivate String matchVariable;\n+    private Predicate<ProcessContext> conditionPredicate;\n \n-    public void addConstraint(ConnectionRef connection, Constraint constraint) {\n-    \tif (connection != null) {\n-    \t\tthrow new IllegalArgumentException(\n-\t\t\t\t\"A Milestone node only accepts one simple constraint\");\n-    \t}\n-        this.constraint = constraint.getConstraint();\n-    }\n-    \n-    public void setConstraint(String constraint){\n-        this.constraint = constraint;\n+    public void setCondition(Predicate<ProcessContext> conditionPredicate) {\n+        this.conditionPredicate = conditionPredicate;\n     }\n \n-    public String getConstraint(){", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NjkzNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437446934", "bodyText": "with what purpose?", "author": "ruromero", "createdAt": "2020-06-09T14:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ2ODM5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437468392", "bodyText": "to make the usage better and simpler, in this way the callers don't need to know the value is gotten from the metadata and even the key to be used of the metadata that would be used to get the value...", "author": "tiagodolphine", "createdAt": "2020-06-09T14:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3MjAyMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437472022", "bodyText": "I mean, who needs to know about the condition? Do you think this should be exposed to the Milestone object? Same for the activation/completion conditions in the AdHocSubProcess", "author": "ruromero", "createdAt": "2020-06-09T14:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3NjQ2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437476463", "bodyText": "mmm if the condition value would be accessed outside the class I think it would be great, to simplify getting the information... otherwise yeah.. it does not make sense...", "author": "tiagodolphine", "createdAt": "2020-06-09T14:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2ODk0OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437868949", "bodyText": "@ruromero I think we're overusing the metadata for this, keeping a specific attribute and method I think is more clear unles there is a specific reason for this change. I would actually prefer to keep getContraint() and same for node.getActivationExpression() and node.getCompletionExpression()", "author": "cristianonicolai", "createdAt": "2020-06-10T05:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5MDAyMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437890022", "bodyText": "The purpose of keeping these expressions in the metadata is only to allow the nodeVisitor access so it can generate the lambdas. What I could do is to remove them in the visitors.\nWhy would they be needed further this point?", "author": "ruromero", "createdAt": "2020-06-10T06:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java\nindex 9a93f559b1..79ba078f51 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java\n\n@@ -30,13 +30,25 @@ public class MilestoneNode extends StateBasedNode implements Constrainable {\n \n     private static final long serialVersionUID = 510L;\n \n+    /**\n+     * String representation of the conditionPredicate. Not used at runtime\n+     */\n+    private String condition;\n     private Predicate<ProcessContext> conditionPredicate;\n \n+    public void setCondition(String condition) {\n+        this.condition = condition;\n+    }\n+\n+    public String getCondition() {\n+        return condition;\n+    }\n+\n     public void setCondition(Predicate<ProcessContext> conditionPredicate) {\n         this.conditionPredicate = conditionPredicate;\n     }\n \n-    public boolean testCondition(ProcessContext context) {\n+    public boolean canComplete(ProcessContext context) {\n         return conditionPredicate == null || conditionPredicate.test(context);\n     }\n \n"}}, {"oid": "19cae39940a1bf24deaaf43eb5b3325219e8c424", "url": "https://github.com/kiegroup/kogito-runtimes/commit/19cae39940a1bf24deaaf43eb5b3325219e8c424", "message": "[KOGITO-2168] Add DynamicNode activation/completion conditions\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-09T14:32:07Z", "type": "forcePushed"}, {"oid": "754914b60f6ae6838e0c2ba317c5f53334799612", "url": "https://github.com/kiegroup/kogito-runtimes/commit/754914b60f6ae6838e0c2ba317c5f53334799612", "message": "[KOGITO-2168] Add DynamicNode activation/completion conditions\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-09T15:28:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NTY3MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437855670", "bodyText": "can we use a constant here?", "author": "cristianonicolai", "createdAt": "2020-06-10T04:38:55Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/DynamicNodeHandler.java", "diffHunk": "@@ -28,9 +33,24 @@ protected Node createNode() {\n     public Class<?> generateNodeFor() {\n         return DynamicNode.class;\n     }\n-    \n+\n     protected String getNodeName() {\n-    \treturn \"dynamic\";\n+        return \"dynamic\";\n     }\n \n+    @Override\n+    protected void handleNode(Node node, Element element, String uri, String localName, ExtensibleXmlParser parser) throws SAXException {\n+        super.handleNode(node, element, uri, localName, parser);\n+        DynamicNode dynamicNode = (DynamicNode) node;\n+        for (int i = 0; i < element.getChildNodes().getLength(); i++) {\n+            org.w3c.dom.Node n = element.getChildNodes().item(i);\n+            if (COMPLETION_CONDITION.equals(n.getNodeName())) {\n+                if (\"autocomplete\".equals(n.getTextContent())) {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/DynamicNodeHandler.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/DynamicNodeHandler.java\nindex 84ae52fb8f..4d7d16aea0 100755\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/DynamicNodeHandler.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/DynamicNodeHandler.java\n\n@@ -26,6 +26,8 @@ import static org.jbpm.ruleflow.core.Metadata.COMPLETION_CONDITION;\n \n public class DynamicNodeHandler extends CompositeNodeHandler {\n \n+    public static final String AUTOCOMPLETE_COMPLETION_CONDITION = \"autocomplete\";\n+\n     protected Node createNode() {\n         return new DynamicNode();\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NzM2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437857363", "bodyText": "@ruromero so why only when state is pending? can't milestone nodes get activated when the process is for instance in Active state?", "author": "cristianonicolai", "createdAt": "2020-06-10T04:45:58Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java", "diffHunk": "@@ -66,188 +55,103 @@ public void internalTrigger(NodeInstance from, String type) {\n         triggerTime = new Date();\n         triggerEvent(EVENT_NODE_ENTER);\n \n-    \t// if node instance was cancelled, abort\n-\t\tif (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n-\t\t\treturn;\n-\t\t}\n-        boolean isActive = false;\n-        // KOGITO-2168 Conditions not supported\n-        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n-            InternalAgenda agenda = (InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda();\n-            String ruleFlowGroup = getRuleFlowGroupName();\n-            if (ruleFlowGroup != null && !agenda.getRuleFlowGroup(ruleFlowGroup).isActive()) {\n-                agenda.getRuleFlowGroup(ruleFlowGroup).setAutoDeactivate(false);\n-                agenda.activateRuleFlowGroup(ruleFlowGroup, getProcessInstance().getId(), getUniqueId());\n-            }\n-            String rule =  \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId() + \"-\" + getDynamicNode().getUniqueId();\n-            isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                    .isRuleActiveInRuleFlowGroup(getRuleFlowGroupName(), rule, getProcessInstance().getId());\n+        // if node instance was cancelled, abort\n+        if (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n+            return;\n         }\n-        if (isActive) {\n-            triggerCompleted();\n+        if (canActivate()) {\n+            triggerActivated();\n         } else {\n+            setState(ProcessInstance.STATE_PENDING);\n             addActivationListener();\n         }\n+    }\n \n-    \t// activate ad hoc fragments if they are marked as such\n+    private void triggerActivated() {\n+        setState(ProcessInstance.STATE_ACTIVE);\n+        // activate ad hoc fragments if they are marked as such\n         List<Node> autoStartNodes = getDynamicNode().getAutoStartNodes();\n-        autoStartNodes.forEach(austoStartNode -> triggerSelectedNode(austoStartNode, null));\n+        autoStartNodes.forEach(autoStartNode -> triggerSelectedNode(autoStartNode, null));\n     }\n \n-    @Override\n-    public void addEventListeners() {\n-        super.addEventListeners();\n-        addActivationListener();\n+    private boolean canActivate() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getDynamicNode().testActivation(context);\n     }\n \n-    @Override\n-    public void removeEventListeners() {\n-        super.removeEventListeners();\n-        getProcessInstance().getKnowledgeRuntime().removeEventListener(this);\n-        getProcessInstance().removeEventListener(getActivationEventType(), this, true);\n+    private boolean canComplete() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getNodeInstances(false).isEmpty() && getDynamicNode().testCompletion(context);\n     }\n-    \n+\n     private void addActivationListener() {\n-        getProcessInstance().getKnowledgeRuntime().addEventListener(this);\n-        getProcessInstance().addEventListener(getActivationEventType(), this, true);\n+        getProcessInstance().getKnowledgeRuntime().getProcessRuntime().addEventListener(ContextAwareEventListener.using(listener -> {\n+            if (canActivate() && getState() == ProcessInstance.STATE_PENDING) {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MTQ3MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437881470", "bodyText": "It's the state of the node instance. As it is a CompositeNode, it has a state and the state constants used are the same as for the ProcessInstance.\nWhat I'm trying to do here is to set the state to pending when it is not ready to be activated to avoid triggering the inner nodes multiple times", "author": "ruromero", "createdAt": "2020-06-10T06:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NzM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNzQyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437927427", "bodyText": "hm, ok, that is strange to see the process state enum reused in here.", "author": "cristianonicolai", "createdAt": "2020-06-10T07:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NzM2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java\nindex 179b7c4388..d57132f5ad 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java\n\n@@ -77,13 +77,13 @@ public class DynamicNodeInstance extends CompositeContextNodeInstance {\n     private boolean canActivate() {\n         ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n                 .setNodeInstance(this);\n-        return getDynamicNode().testActivation(context);\n+        return getDynamicNode().canActivate(context);\n     }\n \n     private boolean canComplete() {\n         ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n                 .setNodeInstance(this);\n-        return getNodeInstances(false).isEmpty() && getDynamicNode().testCompletion(context);\n+        return getNodeInstances(false).isEmpty() && getDynamicNode().canComplete(context);\n     }\n \n     private void addActivationListener() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1ODYyNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437858624", "bodyText": "this means that if a process ends, the milestones that are activated will be left as is. Is that right?", "author": "cristianonicolai", "createdAt": "2020-06-10T04:51:05Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java", "diffHunk": "@@ -66,188 +55,103 @@ public void internalTrigger(NodeInstance from, String type) {\n         triggerTime = new Date();\n         triggerEvent(EVENT_NODE_ENTER);\n \n-    \t// if node instance was cancelled, abort\n-\t\tif (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n-\t\t\treturn;\n-\t\t}\n-        boolean isActive = false;\n-        // KOGITO-2168 Conditions not supported\n-        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n-            InternalAgenda agenda = (InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda();\n-            String ruleFlowGroup = getRuleFlowGroupName();\n-            if (ruleFlowGroup != null && !agenda.getRuleFlowGroup(ruleFlowGroup).isActive()) {\n-                agenda.getRuleFlowGroup(ruleFlowGroup).setAutoDeactivate(false);\n-                agenda.activateRuleFlowGroup(ruleFlowGroup, getProcessInstance().getId(), getUniqueId());\n-            }\n-            String rule =  \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId() + \"-\" + getDynamicNode().getUniqueId();\n-            isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                    .isRuleActiveInRuleFlowGroup(getRuleFlowGroupName(), rule, getProcessInstance().getId());\n+        // if node instance was cancelled, abort\n+        if (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n+            return;\n         }\n-        if (isActive) {\n-            triggerCompleted();\n+        if (canActivate()) {\n+            triggerActivated();\n         } else {\n+            setState(ProcessInstance.STATE_PENDING);\n             addActivationListener();\n         }\n+    }\n \n-    \t// activate ad hoc fragments if they are marked as such\n+    private void triggerActivated() {\n+        setState(ProcessInstance.STATE_ACTIVE);\n+        // activate ad hoc fragments if they are marked as such\n         List<Node> autoStartNodes = getDynamicNode().getAutoStartNodes();\n-        autoStartNodes.forEach(austoStartNode -> triggerSelectedNode(austoStartNode, null));\n+        autoStartNodes.forEach(autoStartNode -> triggerSelectedNode(autoStartNode, null));\n     }\n \n-    @Override\n-    public void addEventListeners() {\n-        super.addEventListeners();\n-        addActivationListener();\n+    private boolean canActivate() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getDynamicNode().testActivation(context);\n     }\n \n-    @Override\n-    public void removeEventListeners() {\n-        super.removeEventListeners();\n-        getProcessInstance().getKnowledgeRuntime().removeEventListener(this);\n-        getProcessInstance().removeEventListener(getActivationEventType(), this, true);\n+    private boolean canComplete() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getNodeInstances(false).isEmpty() && getDynamicNode().testCompletion(context);\n     }\n-    \n+\n     private void addActivationListener() {\n-        getProcessInstance().getKnowledgeRuntime().addEventListener(this);\n-        getProcessInstance().addEventListener(getActivationEventType(), this, true);\n+        getProcessInstance().getKnowledgeRuntime().getProcessRuntime().addEventListener(ContextAwareEventListener.using(listener -> {\n+            if (canActivate() && getState() == ProcessInstance.STATE_PENDING) {\n+                triggerActivated();\n+                getProcessInstance().getKnowledgeRuntime().getProcessRuntime().removeEventListener(listener);\n+            }\n+        }));\n     }\n-    \n-    private String getActivationEventType() {\n-        return \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId()\n-            + \"-\" + getDynamicNode().getUniqueId();\n+\n+    private void addCompletionListener() {\n+        getProcessInstance().getKnowledgeRuntime()\n+                .getProcessRuntime()\n+                .addEventListener(ContextAwareEventListener.using(listener -> {\n+                    if (canComplete()) {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java\nindex 179b7c4388..d57132f5ad 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java\n\n@@ -77,13 +77,13 @@ public class DynamicNodeInstance extends CompositeContextNodeInstance {\n     private boolean canActivate() {\n         ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n                 .setNodeInstance(this);\n-        return getDynamicNode().testActivation(context);\n+        return getDynamicNode().canActivate(context);\n     }\n \n     private boolean canComplete() {\n         ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n                 .setNodeInstance(this);\n-        return getNodeInstances(false).isEmpty() && getDynamicNode().testCompletion(context);\n+        return getNodeInstances(false).isEmpty() && getDynamicNode().canComplete(context);\n     }\n \n     private void addActivationListener() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1OTIzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437859236", "bodyText": "I think it actually makes sense to leave the old name method, is quite clear that it is specific about activation.", "author": "cristianonicolai", "createdAt": "2020-06-10T04:53:38Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java", "diffHunk": "@@ -53,112 +45,42 @@ public void internalTrigger(final NodeInstance from, String type) {\n             throw new IllegalArgumentException(\n                     \"A MilestoneNode only accepts default incoming connections!\");\n         }\n-        boolean isActive = true;\n-        // KOGITO-2168 Conditions not supported\n-        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n-            String rule = \"RuleFlow-Milestone-\" + getProcessInstance().getProcessId()\n-                    + \"-\" + getMilestoneNode().getUniqueId();\n-            isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                    .isRuleActiveInRuleFlowGroup(\"DROOLS_SYSTEM\", rule, getProcessInstance().getId());\n-        }\n-        if (isActive) {\n+        if (isCompleted()) {\n             triggerCompleted();\n         } else {\n-            addActivationEventListener();\n+            addEventListener();\n         }\n     }\n \n+    private boolean isCompleted() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getMilestoneNode().testCondition(context);\n+    }\n+\n     @Override\n     public void addEventListeners() {\n         super.addEventListeners();\n-        addActivationEventListener();", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4NDI4MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437884281", "bodyText": "This is actually about completion. The node is activated once the signal is received but it won't complete until the condition is met. I will rename it", "author": "ruromero", "createdAt": "2020-06-10T06:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1OTIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\nindex 44ab133c3a..2d688ac46c 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\n\n@@ -48,23 +46,23 @@ public class MilestoneNodeInstance extends StateBasedNodeInstance {\n         if (isCompleted()) {\n             triggerCompleted();\n         } else {\n-            addEventListener();\n+            addCompletionEventListener();\n         }\n     }\n \n     private boolean isCompleted() {\n         ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n                 .setNodeInstance(this);\n-        return getMilestoneNode().testCondition(context);\n+        return getMilestoneNode().canComplete(context);\n     }\n \n     @Override\n     public void addEventListeners() {\n         super.addEventListeners();\n-        addEventListener();\n+        addCompletionEventListener();\n     }\n \n-    private void addEventListener() {\n+    private void addCompletionEventListener() {\n         getProcessInstance().getKnowledgeRuntime().getProcessRuntime().addEventListener(ContextAwareEventListener.using(listener -> {\n             if(isCompleted()) {\n                 triggerCompleted();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2Mjk3Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437862973", "bodyText": "@ruromero I think there is some inconsistency on how the events are handled here. See how the events used to be registered and remove. Is this intentional or should we reevaluate to use the same mechanism? For instance on line 79, the listener for getActivationEventType is never added, the the one add here is not removed.", "author": "cristianonicolai", "createdAt": "2020-06-10T05:08:50Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java", "diffHunk": "@@ -53,112 +45,42 @@ public void internalTrigger(final NodeInstance from, String type) {\n             throw new IllegalArgumentException(\n                     \"A MilestoneNode only accepts default incoming connections!\");\n         }\n-        boolean isActive = true;\n-        // KOGITO-2168 Conditions not supported\n-        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n-            String rule = \"RuleFlow-Milestone-\" + getProcessInstance().getProcessId()\n-                    + \"-\" + getMilestoneNode().getUniqueId();\n-            isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                    .isRuleActiveInRuleFlowGroup(\"DROOLS_SYSTEM\", rule, getProcessInstance().getId());\n-        }\n-        if (isActive) {\n+        if (isCompleted()) {\n             triggerCompleted();\n         } else {\n-            addActivationEventListener();\n+            addEventListener();\n         }\n     }\n \n+    private boolean isCompleted() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getMilestoneNode().testCondition(context);\n+    }\n+\n     @Override\n     public void addEventListeners() {\n         super.addEventListeners();\n-        addActivationEventListener();\n+        addEventListener();\n     }\n \n-    private void addActivationEventListener() {\n-        getProcessInstance().getKnowledgeRuntime().addEventListener(this);\n-        getProcessInstance().addEventListener(getActivationEventType(), this, true);\n+    private void addEventListener() {\n+        getProcessInstance().getKnowledgeRuntime().getProcessRuntime().addEventListener(ContextAwareEventListener.using(listener -> {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\nindex 44ab133c3a..2d688ac46c 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java\n\n@@ -48,23 +46,23 @@ public class MilestoneNodeInstance extends StateBasedNodeInstance {\n         if (isCompleted()) {\n             triggerCompleted();\n         } else {\n-            addEventListener();\n+            addCompletionEventListener();\n         }\n     }\n \n     private boolean isCompleted() {\n         ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n                 .setNodeInstance(this);\n-        return getMilestoneNode().testCondition(context);\n+        return getMilestoneNode().canComplete(context);\n     }\n \n     @Override\n     public void addEventListeners() {\n         super.addEventListeners();\n-        addEventListener();\n+        addCompletionEventListener();\n     }\n \n-    private void addEventListener() {\n+    private void addCompletionEventListener() {\n         getProcessInstance().getKnowledgeRuntime().getProcessRuntime().addEventListener(ContextAwareEventListener.using(listener -> {\n             if(isCompleted()) {\n                 triggerCompleted();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2Mzk1NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437863955", "bodyText": "maybe add an accessor method for the builder:\n    public static Builder builder(){ return new Builder(); }", "author": "cristianonicolai", "createdAt": "2020-06-10T05:12:21Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java", "diffHunk": "@@ -18,40 +18,29 @@\n \n public class Milestone extends ItemDescription {\n \n-    private final String condition;\n-\n-    private Milestone(String id, String name, Status status, String condition) {\n+    private Milestone(String id, String name, Status status) {\n         super(id, name, status);\n-        this.condition = condition;\n-    }\n-\n-    public String getCondition() {\n-        return condition;\n     }\n \n     @Override\n     public String toString() {\n-        return \"Milestone{\" +\n-                \"condition='\" + condition + '\\'' +\n-                \", {\" + super.toString() + \"}\";\n+        return \"Milestone{\" + super.toString() + \"}\";\n     }", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java b/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\nindex 18318c74ff..654fd066ab 100644\n--- a/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\n+++ b/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\n\n@@ -29,20 +29,14 @@ public class Milestone extends ItemDescription {\n \n     public static class Builder {\n \n-        protected String id;\n-        protected String name;\n-        protected Status status;\n+        private String id;\n+        private String name;\n+        private Status status;\n \n         public Builder(String id) {\n             this.id = id;\n         }\n \n-        public Builder(ItemDescription i) {\n-            this.id = i.getId();\n-            this.name = i.getName();\n-            this.status = i.getStatus();\n-        }\n-\n         public Builder withName(String name) {\n             this.name = name;\n             return this;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDA0OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437864048", "bodyText": "should this remain as private?", "author": "cristianonicolai", "createdAt": "2020-06-10T05:12:40Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java", "diffHunk": "@@ -18,40 +18,29 @@\n \n public class Milestone extends ItemDescription {\n \n-    private final String condition;\n-\n-    private Milestone(String id, String name, Status status, String condition) {\n+    private Milestone(String id, String name, Status status) {\n         super(id, name, status);\n-        this.condition = condition;\n-    }\n-\n-    public String getCondition() {\n-        return condition;\n     }\n \n     @Override\n     public String toString() {\n-        return \"Milestone{\" +\n-                \"condition='\" + condition + '\\'' +\n-                \", {\" + super.toString() + \"}\";\n+        return \"Milestone{\" + super.toString() + \"}\";\n     }\n \n     public static class Builder {\n \n-        private String id;\n-        private String name;\n-        private Status status;\n-        private String condition;\n+        protected String id;", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4ODc4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437888786", "bodyText": "yes, reverted. It was a refactoring leftover", "author": "ruromero", "createdAt": "2020-06-10T06:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDA0OA=="}], "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java b/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\nindex 18318c74ff..654fd066ab 100644\n--- a/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\n+++ b/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\n\n@@ -29,20 +29,14 @@ public class Milestone extends ItemDescription {\n \n     public static class Builder {\n \n-        protected String id;\n-        protected String name;\n-        protected Status status;\n+        private String id;\n+        private String name;\n+        private Status status;\n \n         public Builder(String id) {\n             this.id = id;\n         }\n \n-        public Builder(ItemDescription i) {\n-            this.id = i.getId();\n-            this.name = i.getName();\n-            this.status = i.getStatus();\n-        }\n-\n         public Builder withName(String name) {\n             this.name = name;\n             return this;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDQyMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437864421", "bodyText": "a builder constructor should be without parameter, then you could add a id or withId method.", "author": "cristianonicolai", "createdAt": "2020-06-10T05:13:52Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java", "diffHunk": "@@ -18,40 +18,29 @@\n \n public class Milestone extends ItemDescription {\n \n-    private final String condition;\n-\n-    private Milestone(String id, String name, Status status, String condition) {\n+    private Milestone(String id, String name, Status status) {\n         super(id, name, status);\n-        this.condition = condition;\n-    }\n-\n-    public String getCondition() {\n-        return condition;\n     }\n \n     @Override\n     public String toString() {\n-        return \"Milestone{\" +\n-                \"condition='\" + condition + '\\'' +\n-                \", {\" + super.toString() + \"}\";\n+        return \"Milestone{\" + super.toString() + \"}\";\n     }\n \n     public static class Builder {\n \n-        private String id;\n-        private String name;\n-        private Status status;\n-        private String condition;\n+        protected String id;\n+        protected String name;\n+        protected Status status;\n \n         public Builder(String id) {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4NTA0OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437885049", "bodyText": "That means the id is mandatory. I prefer to keep it like this to make it more evident.", "author": "ruromero", "createdAt": "2020-06-10T06:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNTA1NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437925054", "bodyText": "I guess that would be a not null check in the constructor then. A builder is just a facilitator to create the object IMHO.", "author": "cristianonicolai", "createdAt": "2020-06-10T07:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDQyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java b/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\nindex 18318c74ff..654fd066ab 100644\n--- a/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\n+++ b/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\n\n@@ -29,20 +29,14 @@ public class Milestone extends ItemDescription {\n \n     public static class Builder {\n \n-        protected String id;\n-        protected String name;\n-        protected Status status;\n+        private String id;\n+        private String name;\n+        private Status status;\n \n         public Builder(String id) {\n             this.id = id;\n         }\n \n-        public Builder(ItemDescription i) {\n-            this.id = i.getId();\n-            this.name = i.getName();\n-            this.status = i.getStatus();\n-        }\n-\n         public Builder withName(String name) {\n             this.name = name;\n             return this;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NjQyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437866423", "bodyText": "I'm not sure why we need a builder that takes an instance with all the parameters, this feels more like a clone method.\nIn the tests, it seems that only the name is reused, so why not create a new builder instance, then withName, withStatus?", "author": "cristianonicolai", "createdAt": "2020-06-10T05:21:15Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java", "diffHunk": "@@ -18,40 +18,29 @@\n \n public class Milestone extends ItemDescription {\n \n-    private final String condition;\n-\n-    private Milestone(String id, String name, Status status, String condition) {\n+    private Milestone(String id, String name, Status status) {\n         super(id, name, status);\n-        this.condition = condition;\n-    }\n-\n-    public String getCondition() {\n-        return condition;\n     }\n \n     @Override\n     public String toString() {\n-        return \"Milestone{\" +\n-                \"condition='\" + condition + '\\'' +\n-                \", {\" + super.toString() + \"}\";\n+        return \"Milestone{\" + super.toString() + \"}\";\n     }\n \n     public static class Builder {\n \n-        private String id;\n-        private String name;\n-        private Status status;\n-        private String condition;\n+        protected String id;\n+        protected String name;\n+        protected Status status;\n \n         public Builder(String id) {\n             this.id = id;\n         }\n \n-        public Builder(Milestone m) {\n-            this.id = m.getId();\n-            this.name = m.getName();\n-            this.status = m.getStatus();\n-            this.condition = m.getCondition();\n+        public Builder(ItemDescription i) {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4ODYwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437888604", "bodyText": "removed", "author": "ruromero", "createdAt": "2020-06-10T06:31:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NjQyMw=="}], "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java b/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\nindex 18318c74ff..654fd066ab 100644\n--- a/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\n+++ b/api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java\n\n@@ -29,20 +29,14 @@ public class Milestone extends ItemDescription {\n \n     public static class Builder {\n \n-        protected String id;\n-        protected String name;\n-        protected Status status;\n+        private String id;\n+        private String name;\n+        private Status status;\n \n         public Builder(String id) {\n             this.id = id;\n         }\n \n-        public Builder(ItemDescription i) {\n-            this.id = i.getId();\n-            this.name = i.getName();\n-            this.status = i.getStatus();\n-        }\n-\n         public Builder withName(String name) {\n             this.name = name;\n             return this;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NzQyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437867423", "bodyText": "missing assertMilestones(expected, processInstance.milestones()); ?", "author": "cristianonicolai", "createdAt": "2020-06-10T05:24:51Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java", "diffHunk": "@@ -75,20 +79,32 @@ void testSimpleMilestone() throws Exception {\n \n     @Test\n     void testConditionalMilestone() throws Exception {\n-        Application app = generateCodeProcessesOnly(\"cases/UserTaskCase.bpmn2\");\n+        Application app = generateCodeProcessesOnly(\"cases/milestones/ConditionalMilestone.bpmn\");\n         assertThat(app).isNotNull();\n \n-        Process<? extends Model> p = app.processes().processById(\"UserTaskCase\");\n-        ProcessInstance<?> processInstance = p.createInstance(p.createModel());\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.ConditionalMilestone\");\n+        Model model = p.createModel();\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"favouriteColour\", \"orange\");\n+        model.fromMap(params);\n+        ProcessInstance<?> processInstance = p.createInstance(model);\n         assertState(processInstance, ProcessInstance.STATE_PENDING);\n \n-\n         Collection<Milestone> expected = new ArrayList<>();\n-        expected.add(new Milestone.Builder(\"\").withName(\"Milestone1\").withStatus(AVAILABLE).withCondition(\"\").build());\n-        expected.add(new Milestone.Builder(\"\").withName(\"Milestone2\").withStatus(AVAILABLE).withCondition(\"CaseData(data.get(\\\"dataComplete\\\") == true)\").build());\n+        expected.add(new Milestone.Builder(\"\").withName(\"Milestone\").withStatus(AVAILABLE).build());\n+        assertMilestones(expected, processInstance.milestones());\n+\n+        processInstance.start();\n+        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n \n-        Collection<Milestone> milestones = processInstance.milestones();\n-        assertMilestones(expected, milestones);\n+        expected = expected.stream().map(m -> new Milestone.Builder(m).withStatus(AVAILABLE).build()).collect(Collectors.toList());", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "chunk": "diff --git a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\nindex 2e95898caf..5cd7e6c974 100644\n--- a/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n+++ b/kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java\n\n@@ -97,13 +97,14 @@ class MilestoneTest extends AbstractCodegenTest {\n         processInstance.start();\n         assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n \n-        expected = expected.stream().map(m -> new Milestone.Builder(m).withStatus(AVAILABLE).build()).collect(Collectors.toList());\n+        expected = expected.stream().map(m -> new Milestone.Builder(m.getId()).withName(m.getName()).withStatus(AVAILABLE).build()).collect(Collectors.toList());\n+        assertMilestones(expected, processInstance.milestones());\n \n         List<WorkItem> workItems = processInstance.workItems();\n         params.put(\"favouriteColour\", \"blue\");\n         processInstance.completeWorkItem(workItems.get(0).getId(), params);\n \n-        expected = expected.stream().map(m -> new Milestone.Builder(m).withStatus(COMPLETED).build()).collect(Collectors.toList());\n+        expected = expected.stream().map(m -> new Milestone.Builder(m.getId()).withName(m.getName()).withStatus(COMPLETED).build()).collect(Collectors.toList());\n         assertMilestones(expected, processInstance.milestones());\n     }\n \n"}}, {"oid": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8b2a05b84496497e6a472fcce5fbbf1097760c5c", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-15T06:14:45Z", "type": "forcePushed"}, {"oid": "9d1aff4d5edc36e07ea571e7dafd3cea27c5565e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9d1aff4d5edc36e07ea571e7dafd3cea27c5565e", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-15T07:18:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMTE0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r440001145", "bodyText": "please remove unused import", "author": "cristianonicolai", "createdAt": "2020-06-15T08:10:16Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java", "diffHunk": "@@ -46,6 +46,7 @@\n import org.jbpm.workflow.instance.impl.ExtendedNodeInstanceImpl;\n import org.jbpm.workflow.instance.impl.NodeInstanceResolverFactory;\n import org.jbpm.workflow.instance.impl.WorkflowProcessInstanceImpl;\n+import org.kie.api.event.process.ProcessEventListener;", "originalCommit": "9d1aff4d5edc36e07ea571e7dafd3cea27c5565e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c0a05ef27da9509c88ba24a82c94bda1312e88b", "chunk": "diff --git a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java\nindex d12b785259..d858fb2761 100755\n--- a/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java\n+++ b/jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java\n\n@@ -46,7 +46,6 @@ import org.jbpm.workflow.core.node.StateBasedNode;\n import org.jbpm.workflow.instance.impl.ExtendedNodeInstanceImpl;\n import org.jbpm.workflow.instance.impl.NodeInstanceResolverFactory;\n import org.jbpm.workflow.instance.impl.WorkflowProcessInstanceImpl;\n-import org.kie.api.event.process.ProcessEventListener;\n import org.kie.api.event.rule.MatchCreatedEvent;\n import org.kie.api.runtime.KieRuntime;\n import org.kie.api.runtime.process.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwNTg4MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r440005880", "bodyText": "unused import", "author": "cristianonicolai", "createdAt": "2020-06-15T08:19:02Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/MilestoneNodeHandler.java", "diffHunk": "@@ -18,6 +18,7 @@\n \n import org.drools.compiler.compiler.xml.XmlDumper;\n import org.drools.core.xml.ExtensibleXmlParser;\n+import org.jbpm.ruleflow.core.Metadata;", "originalCommit": "9d1aff4d5edc36e07ea571e7dafd3cea27c5565e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c0a05ef27da9509c88ba24a82c94bda1312e88b", "chunk": "diff --git a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/MilestoneNodeHandler.java b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/MilestoneNodeHandler.java\nindex b95ce09ecf..c24a630dd3 100755\n--- a/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/MilestoneNodeHandler.java\n+++ b/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/MilestoneNodeHandler.java\n\n@@ -18,7 +18,6 @@ package org.jbpm.compiler.xml.processes;\n \n import org.drools.compiler.compiler.xml.XmlDumper;\n import org.drools.core.xml.ExtensibleXmlParser;\n-import org.jbpm.ruleflow.core.Metadata;\n import org.jbpm.workflow.core.Node;\n import org.jbpm.workflow.core.node.MilestoneNode;\n import org.w3c.dom.Element;\n"}}, {"oid": "8c0a05ef27da9509c88ba24a82c94bda1312e88b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8c0a05ef27da9509c88ba24a82c94bda1312e88b", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-15T08:30:56Z", "type": "forcePushed"}, {"oid": "6e6289ad498e1a8f56e7a58820ee1441a8b64858", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6e6289ad498e1a8f56e7a58820ee1441a8b64858", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-15T10:04:37Z", "type": "forcePushed"}, {"oid": "a8ed8031e7845fab754c895bfad495c2cd0af894", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a8ed8031e7845fab754c895bfad495c2cd0af894", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-16T08:28:10Z", "type": "commit"}, {"oid": "a8ed8031e7845fab754c895bfad495c2cd0af894", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a8ed8031e7845fab754c895bfad495c2cd0af894", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-16T08:28:10Z", "type": "forcePushed"}, {"oid": "85d3f36869b1781caf8875f7af8e81a5b2052551", "url": "https://github.com/kiegroup/kogito-runtimes/commit/85d3f36869b1781caf8875f7af8e81a5b2052551", "message": "[KOGITO-2168] Remove some codesmells\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-16T09:54:30Z", "type": "commit"}]}