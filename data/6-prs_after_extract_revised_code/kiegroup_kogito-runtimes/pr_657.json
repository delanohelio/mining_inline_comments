{"pr_number": 657, "pr_title": "KOGITO-2757 Application.java: Refactor Codegen", "pr_createdAt": "2020-07-28T10:16:43Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/657", "timeline": [{"oid": "73105b3f95a5524ddff951ff2b49a2d676952653", "url": "https://github.com/kiegroup/kogito-runtimes/commit/73105b3f95a5524ddff951ff2b49a2d676952653", "message": "fix build", "committedDate": "2020-07-29T12:04:36Z", "type": "forcePushed"}, {"oid": "cb86a4dcda7390185f6c6aeac6e1cd734812cd0f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/cb86a4dcda7390185f6c6aeac6e1cd734812cd0f", "message": "KOGITO-2757 Application.java: Refactor Codegen", "committedDate": "2020-07-29T14:22:29Z", "type": "commit"}, {"oid": "901decbc41febf26460a7cfa9d4ba75aa5721e65", "url": "https://github.com/kiegroup/kogito-runtimes/commit/901decbc41febf26460a7cfa9d4ba75aa5721e65", "message": "fix build", "committedDate": "2020-07-29T14:22:29Z", "type": "commit"}, {"oid": "a73b9f5b69517931336532d0ee22c925dfdade17", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a73b9f5b69517931336532d0ee22c925dfdade17", "message": "fix constructors", "committedDate": "2020-07-29T14:22:29Z", "type": "commit"}, {"oid": "c5a5408f901a9d5e1921ae46df11348757831d70", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c5a5408f901a9d5e1921ae46df11348757831d70", "message": "addons", "committedDate": "2020-07-29T14:22:29Z", "type": "commit"}, {"oid": "e8d08c7e4f425621a8c6c898f3973a077c3588e3", "url": "https://github.com/kiegroup/kogito-runtimes/commit/e8d08c7e4f425621a8c6c898f3973a077c3588e3", "message": "rename StaticApplication to AbstractApplication", "committedDate": "2020-07-29T14:22:29Z", "type": "commit"}, {"oid": "e8d08c7e4f425621a8c6c898f3973a077c3588e3", "url": "https://github.com/kiegroup/kogito-runtimes/commit/e8d08c7e4f425621a8c6c898f3973a077c3588e3", "message": "rename StaticApplication to AbstractApplication", "committedDate": "2020-07-29T14:22:29Z", "type": "forcePushed"}, {"oid": "7a8dfffa42a7fce8620d76bc8d623d153154131a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7a8dfffa42a7fce8620d76bc8d623d153154131a", "message": "cleanup", "committedDate": "2020-07-29T14:50:11Z", "type": "commit"}, {"oid": "03923e38df2017e32da4cfcd703ad17d43ff24fd", "url": "https://github.com/kiegroup/kogito-runtimes/commit/03923e38df2017e32da4cfcd703ad17d43ff24fd", "message": "formatting", "committedDate": "2020-07-29T15:00:55Z", "type": "commit"}, {"oid": "e6abc1e0729c80f332c0fe2cf6c041898a1428d7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/e6abc1e0729c80f332c0fe2cf6c041898a1428d7", "message": "fix conditional codegen", "committedDate": "2020-07-29T15:59:34Z", "type": "commit"}, {"oid": "af7a6ce89395dbf25122d90214d170a1f37b47c3", "url": "https://github.com/kiegroup/kogito-runtimes/commit/af7a6ce89395dbf25122d90214d170a1f37b47c3", "message": "cleanup", "committedDate": "2020-07-30T07:42:13Z", "type": "commit"}, {"oid": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0da4398b54f9772423bc586e157b5be3e68ea4fe", "message": "align naming", "committedDate": "2020-07-30T08:01:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNDkxNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463014914", "bodyText": "What about document this feature in the README somewhere else?", "author": "danielezonca", "createdAt": "2020-07-30T13:56:44Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java", "diffHunk": "@@ -103,84 +108,72 @@ private String getFilePath(String className) {\n         return (this.packageName + \".\" + className).replace('.', '/') + \".java\";\n     }\n \n+    /**\n+     * @deprecated used only in tests?\n+     */\n+    @Deprecated\n     public void addFactoryMethods(Collection<MethodDeclaration> decls) {\n         factoryMethods.addAll(decls);\n     }\n \n     CompilationUnit compilationUnit() {\n         CompilationUnit compilationUnit =\n-                parse(this.getClass().getResourceAsStream(RESOURCE))\n-                        .setPackageDeclaration(packageName);\n+                templatedGenerator.compilationUnit()\n+                        .orElseThrow(() -> new IllegalArgumentException(\"Cannot find template for \" + APPLICATION_CLASS_NAME));\n \n         ClassOrInterfaceDeclaration cls = compilationUnit\n                 .findFirst(ClassOrInterfaceDeclaration.class)\n                 .orElseThrow(() -> new NoSuchElementException(\"Compilation unit doesn't contain a class or interface declaration!\"));\n \n-        VariableDeclarator eventPublishersDeclarator;\n-        FieldDeclaration eventPublishersFieldDeclaration = new FieldDeclaration();\n-\n-        FieldDeclaration kogitoServiceField = new FieldDeclaration().addVariable(new VariableDeclarator()\n-                                                                                .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n-                                                                                .setName(\"kogitoService\"));\n-\n-        cls.addMember(eventPublishersFieldDeclaration);\n-        cls.addMember(kogitoServiceField);\n-        if (useInjection()) {\n-            annotator.withSingletonComponent(cls);\n-\n-            cls.findFirst(MethodDeclaration.class, md -> md.getNameAsString().equals(\"setup\")).\n-            orElseThrow(() -> new RuntimeException(\"setup method template not found\"))\n-            .addAnnotation(\"javax.annotation.PostConstruct\");\n-\n-            annotator.withOptionalInjection(eventPublishersFieldDeclaration);\n-            eventPublishersDeclarator = new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(annotator.multiInstanceInjectionType()), NodeList.nodeList(new ClassOrInterfaceType(null, EventPublisher.class.getCanonicalName()))), \"eventPublishers\");\n-\n-            annotator.withConfigInjection(kogitoServiceField, \"kogito.service.url\");\n-        } else {\n-            eventPublishersDeclarator = new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(List.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, EventPublisher.class.getCanonicalName()))), \"eventPublishers\");\n-            kogitoServiceField.getVariable(0).setInitializer(new MethodCallExpr(new NameExpr(Optional.class.getCanonicalName()), \"empty\"));\n-        }\n+        factoryMethods.forEach(cls::addMember);\n \n-        eventPublishersFieldDeclaration.addVariable(eventPublishersDeclarator);\n-\n-        FieldDeclaration configField = null;\n-        if (useInjection()) {\n-            configField = new FieldDeclaration()\n-                    .addVariable(new VariableDeclarator()\n-                                         .setType(Config.class.getCanonicalName())\n-                                         .setName(\"config\"));\n-            annotator.withInjection(configField);\n-        } else {\n-            configField = new FieldDeclaration()\n-                    .addModifier(Modifier.Keyword.PROTECTED)\n-                    .addVariable(new VariableDeclarator()\n-                            .setType(Config.class.getCanonicalName())\n-                            .setName(\"config\")\n-                            .setInitializer(configGenerator.newInstance()));\n-        }\n-        cls.addMember(configField);\n+        initializeSectionsExplicitly(cls);\n \n-        factoryMethods.forEach(cls::addMember);\n+        cls.getMembers().sort(new BodyDeclarationComparator());\n+        return compilationUnit;\n+    }\n \n-        Optional<BlockStmt> optSetupBody = cls\n-                .findFirst(MethodDeclaration.class, md -> md.getNameAsString().equals(\"setup\"))\n-                .flatMap(MethodDeclaration::getBody);\n+    private void initializeSectionsExplicitly(ClassOrInterfaceDeclaration cls) {\n         for (Generator generator : generators) {\n             ApplicationSection section = generator.section();\n-            if (section == null) {\n-                continue;\n+            if (section != null) {\n+                replaceSectionPlaceHolder(cls, section);\n             }\n-            cls.addMember(section.fieldDeclaration());\n-            cls.addMember(section.factoryMethod());\n-            optSetupBody.ifPresent(b -> section.setupStatements().forEach(b::addStatement));\n         }\n-        cls.getMembers().sort(new BodyDeclarationComparator());\n-        return compilationUnit;\n+    }\n+\n+    private void replaceSectionPlaceHolder(ClassOrInterfaceDeclaration cls, ApplicationSection section) {\n+        // look for an expression of the form: foo = ... /* $SectionName$ */ ;\n+        //      e.g.: this.processes = null /* $Processes$ */;\n+        // and replaces the entire expression with an initializer; e.g.:\n+        //      e.g.: this.processes = new Processes(this);", "originalCommit": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1NjExMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463056113", "bodyText": "what do you mean? this is just a usage pattern in a private method where would you like to document it? maybe you mean adding it to #655 ?", "author": "evacchi", "createdAt": "2020-07-30T14:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNDkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzNTk0OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463135948", "bodyText": "My bad, I considered this \"rewrite\" mechanism like a reusable feature for all TemplatedGenerator based classes but it is not :)", "author": "danielezonca", "createdAt": "2020-07-30T16:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNDkxNA=="}], "type": "inlineReview", "revised_code": {"commit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\nindex 3fcd68b80c..a05f1ce144 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\n\n@@ -108,14 +108,6 @@ public class ApplicationGenerator {\n         return (this.packageName + \".\" + className).replace('.', '/') + \".java\";\n     }\n \n-    /**\n-     * @deprecated used only in tests?\n-     */\n-    @Deprecated\n-    public void addFactoryMethods(Collection<MethodDeclaration> decls) {\n-        factoryMethods.addAll(decls);\n-    }\n-\n     CompilationUnit compilationUnit() {\n         CompilationUnit compilationUnit =\n                 templatedGenerator.compilationUnit()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNTcwMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463015700", "bodyText": "Can you please create a ticket for that?", "author": "danielezonca", "createdAt": "2020-07-30T13:57:44Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/ApplicationGeneratorTest.java", "diffHunk": "@@ -49,6 +50,7 @@\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n+@Disabled(\"Review these tests as some are outdated\")", "originalCommit": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1NzM2MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463057361", "bodyText": "Thanks, I actually forgot about this, I meant to re-enable before un-drafting. Will take a look now.", "author": "evacchi", "createdAt": "2020-07-30T14:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU4MDE2Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463580162", "bodyText": "In case it is still disabled, a JIRA would be beneficial here.", "author": "MarianMacik", "createdAt": "2020-07-31T12:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYyNDMxOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463624319", "bodyText": "I have restored that and removed old tests", "author": "evacchi", "createdAt": "2020-07-31T13:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNTcwMA=="}], "type": "inlineReview", "revised_code": {"commit": "d747f7af4a2501d8d9def03d380c5114465c7ed9", "chunk": "diff --git a/kogito-codegen/src/test/java/org/kie/kogito/codegen/ApplicationGeneratorTest.java b/kogito-codegen/src/test/java/org/kie/kogito/codegen/ApplicationGeneratorTest.java\nindex d009f09625..ebddaf8c1b 100644\n--- a/kogito-codegen/src/test/java/org/kie/kogito/codegen/ApplicationGeneratorTest.java\n+++ b/kogito-codegen/src/test/java/org/kie/kogito/codegen/ApplicationGeneratorTest.java\n\n@@ -32,25 +30,15 @@ import java.util.stream.Stream;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.github.javaparser.ast.CompilationUnit;\n-import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n-import com.github.javaparser.ast.body.FieldDeclaration;\n-import com.github.javaparser.ast.body.MethodDeclaration;\n import com.github.javaparser.ast.body.TypeDeclaration;\n-import com.github.javaparser.ast.body.VariableDeclarator;\n-import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n-import org.kie.kogito.Config;\n import org.kie.kogito.codegen.di.CDIDependencyInjectionAnnotator;\n import org.kie.kogito.codegen.metadata.MetaDataWriter;\n import org.kie.kogito.codegen.metadata.PrometheusLabeler;\n-import org.mockito.Mockito;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n \n-@Disabled(\"Review these tests as some are outdated\")\n public class ApplicationGeneratorTest {\n \n     private static final String PACKAGE_NAME = \"org.drools.test\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0MTUyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463041523", "bodyText": "Is there any reason why TemplatedGenerator is used as class to extend in many cases and as delegate in others?", "author": "danielezonca", "createdAt": "2020-07-30T14:33:42Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/ConfigGenerator.java", "diffHunk": "@@ -76,6 +69,11 @@ public ConfigGenerator(String packageName) {\n         this.targetTypeName = \"ApplicationConfig\";\n         this.targetCanonicalName = this.packageName + \".\" + targetTypeName;\n         this.sourceFilePath = targetCanonicalName.replace('.', '/') + \".java\";\n+        this.templatedGenerator = new TemplatedGenerator(packageName,", "originalCommit": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA2MjY1OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463062659", "bodyText": "when it's \"more convenient\" it is extended; in this case it's used as a delegate as it would break the contract of some APIs (compilationUnit() returns an Option in TemplatedGenerator and here it doesn't). In other cases it's because the class is already extending another abstract class.\nThe delegate version is a little more error-prone, as you have to remember to call withDependencyInjection() explicitly.\nI think this generator will disappear at some point, if we get more strict about naming conventions, so I wouldn't care too much about the usage patterns, but we can make it a force delegate by making it final, if we really care. In that case I would open a new Jira. But I like that most classes can inherit for brevity.", "author": "evacchi", "createdAt": "2020-07-30T15:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0MTUyMw=="}], "type": "inlineReview", "revised_code": {"commit": "d747f7af4a2501d8d9def03d380c5114465c7ed9", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/ConfigGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/ConfigGenerator.java\nindex 0e25a42304..88b67d1c8e 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/ConfigGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/ConfigGenerator.java\n\n@@ -60,20 +47,14 @@ public class ConfigGenerator {\n     private final String sourceFilePath;\n     private final String targetTypeName;\n     private final String targetCanonicalName;\n-    private final TemplatedGenerator templatedGenerator;\n-\n-    private ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+    private Collection<String> addons;\n \n     public ConfigGenerator(String packageName) {\n         this.packageName = packageName;\n         this.targetTypeName = \"ApplicationConfig\";\n         this.targetCanonicalName = this.packageName + \".\" + targetTypeName;\n         this.sourceFilePath = targetCanonicalName.replace('.', '/') + \".java\";\n-        this.templatedGenerator = new TemplatedGenerator(packageName,\n-                                                         targetTypeName,\n-                                                         RESOURCE_CDI,\n-                                                         RESOURCE_SPRING,\n-                                                         RESOURCE_DEFAULT);\n+        this.applicationConfigGenerator = new ApplicationConfigGenerator(packageName);\n     }\n \n     public ConfigGenerator withProcessConfig(ProcessConfigGenerator cfg) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0NDgxNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463044815", "bodyText": "To be removed? This override has been removed from DecisionContainerGenerator so I expect it can be removed here too", "author": "danielezonca", "createdAt": "2020-07-30T14:37:54Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionContainerGenerator.java", "diffHunk": "@@ -67,23 +60,6 @@ public ClassOrInterfaceDeclaration classDeclaration() {\n         return typeDeclaration;\n     }\n \n-    @Override\n-    public List<Statement> setupStatements() {\n-        return Collections.singletonList(\n-                new IfStmt(\n-                        new BinaryExpr(\n-                                new MethodCallExpr(new MethodCallExpr(null, \"config\"), \"prediction\"),\n-                                new NullLiteralExpr(),\n-                                BinaryExpr.Operator.NOT_EQUALS\n-                        ),\n-                        new BlockStmt().addStatement(new ExpressionStmt(new MethodCallExpr(\n-                                new NameExpr(\"predictionModels\"), \"init\", NodeList.nodeList(new ThisExpr())\n-                        ))),\n-                        null\n-                )\n-        );\n-    }\n-\n     @Override\n     protected boolean useApplication() {\n         return false;", "originalCommit": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionContainerGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionContainerGenerator.java\nindex 631c39afd0..8b927b4ce1 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionContainerGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionContainerGenerator.java\n\n@@ -60,11 +60,6 @@ public class PredictionContainerGenerator extends AbstractApplicationSection {\n         return typeDeclaration;\n     }\n \n-    @Override\n-    protected boolean useApplication() {\n-        return false;\n-    }\n-\n     private void populateStaticKieRuntimeFactoryFunctionInit(ClassOrInterfaceDeclaration typeDeclaration) {\n         final InitializerDeclaration staticDeclaration = typeDeclaration.getMembers()\n                 .stream()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0NjM4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463046383", "bodyText": "Can you please create a ticket to verify this?", "author": "danielezonca", "createdAt": "2020-07-30T14:40:06Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java", "diffHunk": "@@ -103,84 +108,72 @@ private String getFilePath(String className) {\n         return (this.packageName + \".\" + className).replace('.', '/') + \".java\";\n     }\n \n+    /**\n+     * @deprecated used only in tests?\n+     */\n+    @Deprecated", "originalCommit": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1ODU2Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463058567", "bodyText": "I think I'll re-check and delete it altogether if it's not necessary", "author": "evacchi", "createdAt": "2020-07-30T14:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0NjM4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\nindex 3fcd68b80c..a05f1ce144 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\n\n@@ -108,14 +108,6 @@ public class ApplicationGenerator {\n         return (this.packageName + \".\" + className).replace('.', '/') + \".java\";\n     }\n \n-    /**\n-     * @deprecated used only in tests?\n-     */\n-    @Deprecated\n-    public void addFactoryMethods(Collection<MethodDeclaration> decls) {\n-        factoryMethods.addAll(decls);\n-    }\n-\n     CompilationUnit compilationUnit() {\n         CompilationUnit compilationUnit =\n                 templatedGenerator.compilationUnit()\n"}}, {"oid": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "message": "remove old methods, and deprecated tests", "committedDate": "2020-07-30T15:26:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MDM3Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463550373", "bodyText": "What does fae mean? Something like Found AssignExpr? Maybe the name could be more descriptive.", "author": "MarianMacik", "createdAt": "2020-07-31T11:11:30Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java", "diffHunk": "@@ -103,84 +108,54 @@ private String getFilePath(String className) {\n         return (this.packageName + \".\" + className).replace('.', '/') + \".java\";\n     }\n \n-    public void addFactoryMethods(Collection<MethodDeclaration> decls) {\n-        factoryMethods.addAll(decls);\n-    }\n-\n     CompilationUnit compilationUnit() {\n         CompilationUnit compilationUnit =\n-                parse(this.getClass().getResourceAsStream(RESOURCE))\n-                        .setPackageDeclaration(packageName);\n+                templatedGenerator.compilationUnit()\n+                        .orElseThrow(() -> new IllegalArgumentException(\"Cannot find template for \" + APPLICATION_CLASS_NAME));\n \n         ClassOrInterfaceDeclaration cls = compilationUnit\n                 .findFirst(ClassOrInterfaceDeclaration.class)\n                 .orElseThrow(() -> new NoSuchElementException(\"Compilation unit doesn't contain a class or interface declaration!\"));\n \n-        VariableDeclarator eventPublishersDeclarator;\n-        FieldDeclaration eventPublishersFieldDeclaration = new FieldDeclaration();\n-\n-        FieldDeclaration kogitoServiceField = new FieldDeclaration().addVariable(new VariableDeclarator()\n-                                                                                .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n-                                                                                .setName(\"kogitoService\"));\n-\n-        cls.addMember(eventPublishersFieldDeclaration);\n-        cls.addMember(kogitoServiceField);\n-        if (useInjection()) {\n-            annotator.withSingletonComponent(cls);\n-\n-            cls.findFirst(MethodDeclaration.class, md -> md.getNameAsString().equals(\"setup\")).\n-            orElseThrow(() -> new RuntimeException(\"setup method template not found\"))\n-            .addAnnotation(\"javax.annotation.PostConstruct\");\n-\n-            annotator.withOptionalInjection(eventPublishersFieldDeclaration);\n-            eventPublishersDeclarator = new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(annotator.multiInstanceInjectionType()), NodeList.nodeList(new ClassOrInterfaceType(null, EventPublisher.class.getCanonicalName()))), \"eventPublishers\");\n-\n-            annotator.withConfigInjection(kogitoServiceField, \"kogito.service.url\");\n-        } else {\n-            eventPublishersDeclarator = new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(List.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, EventPublisher.class.getCanonicalName()))), \"eventPublishers\");\n-            kogitoServiceField.getVariable(0).setInitializer(new MethodCallExpr(new NameExpr(Optional.class.getCanonicalName()), \"empty\"));\n-        }\n+        factoryMethods.forEach(cls::addMember);\n \n-        eventPublishersFieldDeclaration.addVariable(eventPublishersDeclarator);\n-\n-        FieldDeclaration configField = null;\n-        if (useInjection()) {\n-            configField = new FieldDeclaration()\n-                    .addVariable(new VariableDeclarator()\n-                                         .setType(Config.class.getCanonicalName())\n-                                         .setName(\"config\"));\n-            annotator.withInjection(configField);\n-        } else {\n-            configField = new FieldDeclaration()\n-                    .addModifier(Modifier.Keyword.PROTECTED)\n-                    .addVariable(new VariableDeclarator()\n-                            .setType(Config.class.getCanonicalName())\n-                            .setName(\"config\")\n-                            .setInitializer(configGenerator.newInstance()));\n-        }\n-        cls.addMember(configField);\n+        initializeSectionsExplicitly(cls);\n \n-        factoryMethods.forEach(cls::addMember);\n+        cls.getMembers().sort(new BodyDeclarationComparator());\n+        return compilationUnit;\n+    }\n \n-        Optional<BlockStmt> optSetupBody = cls\n-                .findFirst(MethodDeclaration.class, md -> md.getNameAsString().equals(\"setup\"))\n-                .flatMap(MethodDeclaration::getBody);\n+    private void initializeSectionsExplicitly(ClassOrInterfaceDeclaration cls) {\n         for (Generator generator : generators) {\n             ApplicationSection section = generator.section();\n-            if (section == null) {\n-                continue;\n+            if (section != null) {\n+                replaceSectionPlaceHolder(cls, section);\n             }\n-            cls.addMember(section.fieldDeclaration());\n-            cls.addMember(section.factoryMethod());\n-            optSetupBody.ifPresent(b -> section.setupStatements().forEach(b::addStatement));\n         }\n-        cls.getMembers().sort(new BodyDeclarationComparator());\n-        return compilationUnit;\n+    }\n+\n+    private void replaceSectionPlaceHolder(ClassOrInterfaceDeclaration cls, ApplicationSection section) {\n+        // look for an expression of the form: foo = ... /* $SectionName$ */ ;\n+        //      e.g.: this.processes = null /* $Processes$ */;\n+        // and replaces the entire expression with an initializer; e.g.:\n+        //      e.g.: this.processes = new Processes(this);\n+\n+        Optional<AssignExpr> fae = cls.findFirst(", "originalCommit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYyNDc4NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463624784", "bodyText": "it was a FieldAccessExpression before :P good point.", "author": "evacchi", "createdAt": "2020-07-31T13:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MDM3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d747f7af4a2501d8d9def03d380c5114465c7ed9", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\nindex a05f1ce144..957f217e94 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\n\n@@ -66,96 +52,37 @@ public class ApplicationGenerator {\n     private DependencyInjectionAnnotator annotator;\n \n     private boolean hasRuleUnits;\n-    private final List<BodyDeclaration<?>> factoryMethods;\n+    private final ApplicationContainerGenerator applicationMainGenerator;\n     private ConfigGenerator configGenerator;\n     private List<Generator> generators = new ArrayList<>();\n     private Map<Class, Labeler> labelers = new HashMap<>();\n \n     private GeneratorContext context;\n-    private final TemplatedGenerator templatedGenerator;\n+    private ClassLoader classLoader;\n \n     public ApplicationGenerator(String packageName, File targetDirectory) {\n-        if (packageName == null) {\n-            throw new IllegalArgumentException(\"Package name cannot be undefined (null), please specify a package name!\");\n-        }\n-        if (!SourceVersion.isName(packageName)) {\n-            throw new IllegalArgumentException(\n-                    MessageFormat.format(\n-                            \"Package name \\\"{0}\\\" is not valid. It should be a valid Java package name.\", packageName));\n-        }\n+\n         this.packageName = packageName;\n         this.targetDirectory = targetDirectory;\n-        this.factoryMethods = new ArrayList<>();\n-        this.configGenerator = new ConfigGenerator(packageName);\n+        this.classLoader = Thread.currentThread().getContextClassLoader();\n+        this.applicationMainGenerator = new ApplicationContainerGenerator(packageName);\n \n-        this.templatedGenerator = new TemplatedGenerator(\n-                packageName,\n-                APPLICATION_CLASS_NAME,\n-                RESOURCE_CDI,\n-                RESOURCE_SPRING,\n-                RESOURCE_DEFAULT);\n+        this.configGenerator = new ConfigGenerator(packageName);\n+        this.configGenerator.withAddons(loadAddonList());\n     }\n \n     public String targetCanonicalName() {\n         return this.packageName + \".\" + APPLICATION_CLASS_NAME;\n     }\n \n-    public String generatedFilePath() {\n-        return getFilePath(APPLICATION_CLASS_NAME);\n-    }\n-\n     private String getFilePath(String className) {\n         return (this.packageName + \".\" + className).replace('.', '/') + \".java\";\n     }\n \n-    CompilationUnit compilationUnit() {\n-        CompilationUnit compilationUnit =\n-                templatedGenerator.compilationUnit()\n-                        .orElseThrow(() -> new IllegalArgumentException(\"Cannot find template for \" + APPLICATION_CLASS_NAME));\n-\n-        ClassOrInterfaceDeclaration cls = compilationUnit\n-                .findFirst(ClassOrInterfaceDeclaration.class)\n-                .orElseThrow(() -> new NoSuchElementException(\"Compilation unit doesn't contain a class or interface declaration!\"));\n-\n-        factoryMethods.forEach(cls::addMember);\n-\n-        initializeSectionsExplicitly(cls);\n-\n-        cls.getMembers().sort(new BodyDeclarationComparator());\n-        return compilationUnit;\n-    }\n-\n-    private void initializeSectionsExplicitly(ClassOrInterfaceDeclaration cls) {\n-        for (Generator generator : generators) {\n-            ApplicationSection section = generator.section();\n-            if (section != null) {\n-                replaceSectionPlaceHolder(cls, section);\n-            }\n-        }\n-    }\n-\n-    private void replaceSectionPlaceHolder(ClassOrInterfaceDeclaration cls, ApplicationSection section) {\n-        // look for an expression of the form: foo = ... /* $SectionName$ */ ;\n-        //      e.g.: this.processes = null /* $Processes$ */;\n-        // and replaces the entire expression with an initializer; e.g.:\n-        //      e.g.: this.processes = new Processes(this);\n-\n-        Optional<AssignExpr> fae = cls.findFirst(\n-                BlockComment.class, c -> c.getContent().trim().equals('$' + section.sectionClassName() + '$'))\n-                .flatMap(Node::getParentNode)\n-                .map(ExpressionStmt.class::cast)\n-                .map(e -> e.getExpression().asAssignExpr());\n-\n-        fae.ifPresent(\n-                assignExpr -> assignExpr.setValue(section.newInstance()));\n-        // else ignore: there is no such templated argument\n-\n-    }\n-\n     public ApplicationGenerator withDependencyInjection(DependencyInjectionAnnotator annotator) {\n         this.annotator = annotator;\n-        configGenerator.withDependencyInjection(annotator);\n-        templatedGenerator.withDependencyInjection(annotator);\n+        this.applicationMainGenerator.withDependencyInjection(annotator);\n+        this.configGenerator.withDependencyInjection(annotator);\n         return this;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MTQ4NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463551485", "bodyText": "Maybe this TemplatedGenerator could also be extracted into its own type as with ConfigBeanGenerator? As those resource files URLs are not needed in this class, just in the TemplatedGenerator itself.", "author": "MarianMacik", "createdAt": "2020-07-31T11:14:44Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java", "diffHunk": "@@ -89,6 +87,13 @@ public ApplicationGenerator(String packageName, File targetDirectory) {\n         this.targetDirectory = targetDirectory;\n         this.factoryMethods = new ArrayList<>();\n         this.configGenerator = new ConfigGenerator(packageName);\n+\n+        this.templatedGenerator = new TemplatedGenerator(\n+                packageName,\n+                APPLICATION_CLASS_NAME,\n+                RESOURCE_CDI,\n+                RESOURCE_SPRING,\n+                RESOURCE_DEFAULT);", "originalCommit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYyNjc1NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463626755", "bodyText": "it's just used as a delegate instead of inheriting. But you have a point, let me see.", "author": "evacchi", "createdAt": "2020-07-31T13:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MTQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d747f7af4a2501d8d9def03d380c5114465c7ed9", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\nindex a05f1ce144..957f217e94 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java\n\n@@ -66,96 +52,37 @@ public class ApplicationGenerator {\n     private DependencyInjectionAnnotator annotator;\n \n     private boolean hasRuleUnits;\n-    private final List<BodyDeclaration<?>> factoryMethods;\n+    private final ApplicationContainerGenerator applicationMainGenerator;\n     private ConfigGenerator configGenerator;\n     private List<Generator> generators = new ArrayList<>();\n     private Map<Class, Labeler> labelers = new HashMap<>();\n \n     private GeneratorContext context;\n-    private final TemplatedGenerator templatedGenerator;\n+    private ClassLoader classLoader;\n \n     public ApplicationGenerator(String packageName, File targetDirectory) {\n-        if (packageName == null) {\n-            throw new IllegalArgumentException(\"Package name cannot be undefined (null), please specify a package name!\");\n-        }\n-        if (!SourceVersion.isName(packageName)) {\n-            throw new IllegalArgumentException(\n-                    MessageFormat.format(\n-                            \"Package name \\\"{0}\\\" is not valid. It should be a valid Java package name.\", packageName));\n-        }\n+\n         this.packageName = packageName;\n         this.targetDirectory = targetDirectory;\n-        this.factoryMethods = new ArrayList<>();\n-        this.configGenerator = new ConfigGenerator(packageName);\n+        this.classLoader = Thread.currentThread().getContextClassLoader();\n+        this.applicationMainGenerator = new ApplicationContainerGenerator(packageName);\n \n-        this.templatedGenerator = new TemplatedGenerator(\n-                packageName,\n-                APPLICATION_CLASS_NAME,\n-                RESOURCE_CDI,\n-                RESOURCE_SPRING,\n-                RESOURCE_DEFAULT);\n+        this.configGenerator = new ConfigGenerator(packageName);\n+        this.configGenerator.withAddons(loadAddonList());\n     }\n \n     public String targetCanonicalName() {\n         return this.packageName + \".\" + APPLICATION_CLASS_NAME;\n     }\n \n-    public String generatedFilePath() {\n-        return getFilePath(APPLICATION_CLASS_NAME);\n-    }\n-\n     private String getFilePath(String className) {\n         return (this.packageName + \".\" + className).replace('.', '/') + \".java\";\n     }\n \n-    CompilationUnit compilationUnit() {\n-        CompilationUnit compilationUnit =\n-                templatedGenerator.compilationUnit()\n-                        .orElseThrow(() -> new IllegalArgumentException(\"Cannot find template for \" + APPLICATION_CLASS_NAME));\n-\n-        ClassOrInterfaceDeclaration cls = compilationUnit\n-                .findFirst(ClassOrInterfaceDeclaration.class)\n-                .orElseThrow(() -> new NoSuchElementException(\"Compilation unit doesn't contain a class or interface declaration!\"));\n-\n-        factoryMethods.forEach(cls::addMember);\n-\n-        initializeSectionsExplicitly(cls);\n-\n-        cls.getMembers().sort(new BodyDeclarationComparator());\n-        return compilationUnit;\n-    }\n-\n-    private void initializeSectionsExplicitly(ClassOrInterfaceDeclaration cls) {\n-        for (Generator generator : generators) {\n-            ApplicationSection section = generator.section();\n-            if (section != null) {\n-                replaceSectionPlaceHolder(cls, section);\n-            }\n-        }\n-    }\n-\n-    private void replaceSectionPlaceHolder(ClassOrInterfaceDeclaration cls, ApplicationSection section) {\n-        // look for an expression of the form: foo = ... /* $SectionName$ */ ;\n-        //      e.g.: this.processes = null /* $Processes$ */;\n-        // and replaces the entire expression with an initializer; e.g.:\n-        //      e.g.: this.processes = new Processes(this);\n-\n-        Optional<AssignExpr> fae = cls.findFirst(\n-                BlockComment.class, c -> c.getContent().trim().equals('$' + section.sectionClassName() + '$'))\n-                .flatMap(Node::getParentNode)\n-                .map(ExpressionStmt.class::cast)\n-                .map(e -> e.getExpression().asAssignExpr());\n-\n-        fae.ifPresent(\n-                assignExpr -> assignExpr.setValue(section.newInstance()));\n-        // else ignore: there is no such templated argument\n-\n-    }\n-\n     public ApplicationGenerator withDependencyInjection(DependencyInjectionAnnotator annotator) {\n         this.annotator = annotator;\n-        configGenerator.withDependencyInjection(annotator);\n-        templatedGenerator.withDependencyInjection(annotator);\n+        this.applicationMainGenerator.withDependencyInjection(annotator);\n+        this.configGenerator.withDependencyInjection(annotator);\n         return this;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1ODM1MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463558350", "bodyText": "This implies that first we have to call compilationUnit(). Wouldn't it be better for selectResource() to have the return value and call it also here and in compilationUnit every time? It would be less stateless...", "author": "MarianMacik", "createdAt": "2020-07-31T11:33:02Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/TemplatedGenerator.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen;\n+\n+import java.text.MessageFormat;\n+import java.util.Optional;\n+\n+import javax.lang.model.SourceVersion;\n+\n+import com.github.javaparser.ParseProblemException;\n+import com.github.javaparser.ast.CompilationUnit;\n+import org.kie.kogito.codegen.di.CDIDependencyInjectionAnnotator;\n+import org.kie.kogito.codegen.di.DependencyInjectionAnnotator;\n+import org.kie.kogito.codegen.di.SpringDependencyInjectionAnnotator;\n+\n+import static com.github.javaparser.StaticJavaParser.parse;\n+\n+public class TemplatedGenerator {\n+\n+    private final String packageName;\n+    private final String sourceFilePath;\n+\n+    private final String resourceCdi;\n+    private final String resourceSpring;\n+    private final String resourceDefault;\n+\n+    private DependencyInjectionAnnotator annotator;\n+    private String targetTypeName;\n+    private String selectedResource;\n+\n+    public TemplatedGenerator(\n+            String packageName,\n+            String targetTypeName,\n+            String resourceCdi,\n+            String resourceSpring,\n+            String resourceDefault) {\n+        if (packageName == null) {\n+            throw new IllegalArgumentException(\"Package name cannot be undefined (null), please specify a package name!\");\n+        }\n+        if (!SourceVersion.isName(packageName)) {\n+            throw new IllegalArgumentException(\n+                    MessageFormat.format(\n+                            \"Package name \\\"{0}\\\" is not valid. It should be a valid Java package name.\", packageName));\n+        }\n+\n+        this.packageName = packageName;\n+        this.targetTypeName = targetTypeName;\n+        String targetCanonicalName = this.packageName + \".\" + this.targetTypeName;\n+        this.sourceFilePath = targetCanonicalName.replace('.', '/') + \".java\";\n+        this.resourceCdi = resourceCdi;\n+        this.resourceSpring = resourceSpring;\n+        this.resourceDefault = resourceDefault;\n+    }\n+\n+    public TemplatedGenerator(\n+            String packageName,\n+            String targetTypeName,\n+            String resourceCdi,\n+            String resourceSpring) {\n+        this(packageName,\n+             targetTypeName,\n+             resourceCdi,\n+             resourceSpring,\n+             null);\n+    }\n+\n+    public String generatedFilePath() {\n+        return sourceFilePath;\n+    }\n+\n+    public String templatePath() {\n+        return selectedResource;", "originalCommit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYyNTI5MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463625291", "bodyText": "correct. I thought about adding selectResource() here too, I can do that", "author": "evacchi", "createdAt": "2020-07-31T13:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1ODM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc3NTMzOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463775339", "bodyText": "So we don't want selectResource() to return the selected resource as the return value? Then we wouldn't need the selectedResource field at all. As we will always call selectResource() anyway.", "author": "MarianMacik", "createdAt": "2020-07-31T18:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1ODM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIzNDQzOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r464234439", "bodyText": "done. Don't love it, I actually intended the selection to be cached (but of course I was not really doing it), but we can optimize later, and indeed the code is clearer this way", "author": "evacchi", "createdAt": "2020-08-03T07:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1ODM1MA=="}], "type": "inlineReview", "revised_code": {"commit": "d747f7af4a2501d8d9def03d380c5114465c7ed9", "chunk": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/TemplatedGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/TemplatedGenerator.java\nindex f7c58b30eb..33cd5e8249 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/TemplatedGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/TemplatedGenerator.java\n\n@@ -38,7 +38,7 @@ public class TemplatedGenerator {\n     private final String resourceDefault;\n \n     private DependencyInjectionAnnotator annotator;\n-    private String targetTypeName;\n+    private final String targetTypeName;\n     private String selectedResource;\n \n     public TemplatedGenerator(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1OTAwMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463559000", "bodyText": "Same here, maybe a separate type as with ConfigBeanGenerator would be cleaner?", "author": "MarianMacik", "createdAt": "2020-07-31T11:34:43Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessContainerGenerator.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NullLiteralExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.kie.kogito.codegen.AbstractApplicationSection;\n+import org.kie.kogito.codegen.InvalidTemplateException;\n+import org.kie.kogito.codegen.TemplatedGenerator;\n+import org.kie.kogito.codegen.di.DependencyInjectionAnnotator;\n+import org.kie.kogito.process.Processes;\n+\n+public class ProcessContainerGenerator extends AbstractApplicationSection {\n+\n+    private static final String RESOURCE = \"/class-templates/ProcessContainerTemplate.java\";\n+    private static final String RESOURCE_CDI = \"/class-templates/CdiProcessContainerTemplate.java\";\n+    private static final String RESOURCE_SPRING = \"/class-templates/SpringProcessContainerTemplate.java\";\n+    public static final String SECTION_CLASS_NAME = \"Processes\";\n+\n+    private final String packageName;\n+    private final List<ProcessGenerator> processes;\n+    private final List<BodyDeclaration<?>> factoryMethods;\n+\n+    private DependencyInjectionAnnotator annotator;\n+\n+    private BlockStmt byProcessIdBody = new BlockStmt();\n+    private BlockStmt processesBody = new BlockStmt();\n+    private final TemplatedGenerator templatedGenerator;\n+\n+    public ProcessContainerGenerator(String packageName) {\n+        super(SECTION_CLASS_NAME, \"processes\", Processes.class);\n+        this.packageName = packageName;\n+        this.processes = new ArrayList<>();\n+        this.factoryMethods = new ArrayList<>();\n+\n+        this.templatedGenerator = new TemplatedGenerator(\n+                packageName,\n+                SECTION_CLASS_NAME,\n+                RESOURCE_CDI,\n+                RESOURCE_SPRING,\n+                RESOURCE);", "originalCommit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU3MTA1MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463571051", "bodyText": "Maybe a check that only one Processes bean is present wouldn't be bad, or?", "author": "MarianMacik", "createdAt": "2020-07-31T12:04:56Z", "path": "kogito-codegen/src/main/resources/class-templates/SpringApplicationTemplate.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package $Package$;\n+\n+import org.kie.kogito.Config;\n+import org.kie.kogito.StaticApplication;\n+import org.kie.kogito.process.Processes;\n+\n+@org.springframework.stereotype.Component\n+@org.springframework.web.context.annotation.ApplicationScope\n+public class Application extends StaticApplication {\n+\n+    @org.springframework.beans.factory.annotation.Autowired()\n+    public Application(\n+            Config config,\n+            java.util.Collection<Processes> processes/*,\n+            java.util.Collection<RuleUnits> ruleUnits,\n+            java.util.Collection<DecisionModels> decisionModels,\n+            java.util.Collection<PredictionModels> predictionModels,\n+            */) {\n+        this.config = config;\n+        this.processes = orNull(processes);\n+        this.ruleUnits = null /* $RuleUnits$ */;\n+        this.decisionModels = null /* $DecisionModels$ */;\n+        this.predictionModels = null /* $PredictionModels$ */;\n+\n+        if (config().process() != null) {\n+            unitOfWorkManager().eventManager().setAddons(config().addons());\n+        }\n+    }\n+\n+    private static <T> T orNull(java.util.Collection<T> collection) {\n+        if (collection.isEmpty()) {\n+            return null;\n+        } else {\n+            return collection.iterator().next();", "originalCommit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYyNTg5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463625892", "bodyText": "sure let's do that", "author": "evacchi", "createdAt": "2020-07-31T13:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU3MTA1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d747f7af4a2501d8d9def03d380c5114465c7ed9", "chunk": "diff --git a/kogito-codegen/src/main/resources/class-templates/SpringApplicationTemplate.java b/kogito-codegen/src/main/resources/class-templates/SpringApplicationTemplate.java\nindex d6cea98a16..fd5223ce15 100644\n--- a/kogito-codegen/src/main/resources/class-templates/SpringApplicationTemplate.java\n+++ b/kogito-codegen/src/main/resources/class-templates/SpringApplicationTemplate.java\n\n@@ -31,8 +31,10 @@ public class Application extends StaticApplication {\n         if (collection.isEmpty()) {\n             return null;\n         } else {\n+            if (collection.size() > 1) {\n+                throw new IllegalArgumentException(\"Found too many injection candidates \" + collection);\n+            }\n             return collection.iterator().next();\n         }\n     }\n-\n }\n"}}, {"oid": "d747f7af4a2501d8d9def03d380c5114465c7ed9", "url": "https://github.com/kiegroup/kogito-runtimes/commit/d747f7af4a2501d8d9def03d380c5114465c7ed9", "message": "address comments, further refactoring and cleanup", "committedDate": "2020-07-31T15:34:55Z", "type": "commit"}, {"oid": "4faf0a2609fc311b78239eb484c94dfbdb30726e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/4faf0a2609fc311b78239eb484c94dfbdb30726e", "message": "always select resource", "committedDate": "2020-08-03T07:16:10Z", "type": "commit"}]}