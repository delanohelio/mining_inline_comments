{"pr_number": 2022, "pr_title": "DBZ-2167 Use legacy parser for testing purposes only", "pr_createdAt": "2020-12-17T14:02:05Z", "pr_url": "https://github.com/debezium/debezium/pull/2022", "timeline": [{"oid": "64bdb03d74055a7ebb9f0d849aff9cc18f5130c4", "url": "https://github.com/debezium/debezium/commit/64bdb03d74055a7ebb9f0d849aff9cc18f5130c4", "message": "DBZ-2167 Use legacy parser for testing purposes only", "committedDate": "2020-12-17T14:05:28Z", "type": "commit"}, {"oid": "64bdb03d74055a7ebb9f0d849aff9cc18f5130c4", "url": "https://github.com/debezium/debezium/commit/64bdb03d74055a7ebb9f0d849aff9cc18f5130c4", "message": "DBZ-2167 Use legacy parser for testing purposes only", "committedDate": "2020-12-17T14:05:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYyNDQ3MA==", "url": "https://github.com/debezium/debezium/pull/2022#discussion_r545624470", "bodyText": "Ugh :) Why again do we need TokenStream in main? And if it's truly needed over there (and not test-only), can't we extend?", "author": "gunnarmorling", "createdAt": "2020-12-18T07:42:00Z", "path": "debezium-core/src/test/java/io/debezium/util/parser/TokenStream.java", "diffHunk": "@@ -0,0 +1,2592 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.util.parser;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.IntConsumer;\n+import java.util.function.LongConsumer;\n+\n+import io.debezium.annotation.Immutable;\n+import io.debezium.annotation.NotThreadSafe;\n+import io.debezium.function.BooleanConsumer;\n+import io.debezium.text.ParsingException;\n+import io.debezium.text.Position;\n+import io.debezium.text.XmlCharacters;\n+import io.debezium.util.Strings;\n+\n+/**\n+ * A copy of {@link io.debezium.text.TokenStream} class that provides additional methods necessary for test parser.", "originalCommit": "64bdb03d74055a7ebb9f0d849aff9cc18f5130c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYyOTEzNQ==", "url": "https://github.com/debezium/debezium/pull/2022#discussion_r545629135", "bodyText": "It is used in TableIdParser and in Strings.\nI was attemptin to do the extension first but that would need not insignificant changes including even generfication of the class which I thought is unnecessary complication. Hence I followed the path of the least resistence and made the copy so the original tokenizer is not polluted with SQL specific stuff.", "author": "jpechane", "createdAt": "2020-12-18T07:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYyNDQ3MA=="}], "type": "inlineReview", "revised_code": {"commit": "e59fa6f7071621d24f35a5b3b5dac9da3270dfa0", "chunk": "diff --git a/debezium-core/src/test/java/io/debezium/util/parser/TokenStream.java b/debezium-core/src/test/java/io/debezium/util/parser/TokenStream.java\ndeleted file mode 100644\nindex 86c967d08..000000000\n--- a/debezium-core/src/test/java/io/debezium/util/parser/TokenStream.java\n+++ /dev/null\n\n@@ -1,2592 +0,0 @@\n-/*\n- * Copyright Debezium Authors.\n- *\n- * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n- */\n-package io.debezium.util.parser;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.util.function.IntConsumer;\n-import java.util.function.LongConsumer;\n-\n-import io.debezium.annotation.Immutable;\n-import io.debezium.annotation.NotThreadSafe;\n-import io.debezium.function.BooleanConsumer;\n-import io.debezium.text.ParsingException;\n-import io.debezium.text.Position;\n-import io.debezium.text.XmlCharacters;\n-import io.debezium.util.Strings;\n-\n-/**\n- * A copy of {@link io.debezium.text.TokenStream} class that provides additional methods necessary for test parser.\n- */\n-@NotThreadSafe\n-public class TokenStream {\n-\n-    /**\n-     * An opaque marker for a position within the token stream.\n-     *\n-     * @see TokenStream#mark()\n-     */\n-    public static final class Marker implements Comparable<Marker> {\n-        protected final int tokenIndex;\n-        protected final Position position;\n-\n-        protected Marker(Position position, int index) {\n-            this.position = position;\n-            this.tokenIndex = index;\n-        }\n-\n-        /**\n-         * Get the position of this marker, or null if this is at the start or end of the token stream.\n-         *\n-         * @return the position.\n-         */\n-        public Position position() {\n-            return position;\n-        }\n-\n-        @Override\n-        public int compareTo(Marker that) {\n-            if (this == that) {\n-                return 0;\n-            }\n-            return this.tokenIndex - that.tokenIndex;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return Integer.toString(tokenIndex);\n-        }\n-    }\n-\n-    /**\n-     * A constant that can be used with the {@link #matches(String)}, {@link #matches(String, String...)},\n-     * {@link #consume(String)}, {@link #consume(String, String...)}, {@link #canConsume(String)} and\n-     * {@link #canConsume(String, String...)} methods to signal that any value is allowed to be matched.\n-     * <p>\n-     * Note that this exact instance must be used; an equivalent string will not work.\n-     * </p>\n-     */\n-    public static final String ANY_VALUE = \"any value\";\n-    /**\n-     * A constant that can be used with the {@link #matches(int)}, {@link #matches(int, int...)}, {@link #consume(int)}, and\n-     * {@link #canConsume(int)} methods to signal that any token type is allowed to be matched.\n-     */\n-    public static final int ANY_TYPE = Integer.MIN_VALUE;\n-\n-    protected final String inputString;\n-    private final char[] inputContent;\n-    private final boolean caseSensitive;\n-    private final Tokenizer tokenizer;\n-    private List<Token> tokens;\n-    /**\n-     * This class navigates the Token objects using this iterator. However, because it very often needs to access the\n-     * \"current token\" in the \"consume(...)\" and \"canConsume(...)\" and \"matches(...)\" methods, the class caches a \"current token\"\n-     * and makes this iterator point to the 2nd token.\n-     *\n-     * <pre>\n-     *     T1     T2    T3    T4    T5\n-     *         &circ;   &circ;  &circ;\n-     *         |   |  |\n-     *         |   |  +- The position of the tokenIterator, where tokenIterator.hasNext() will return T3\n-     *         |   +---- The token referenced by currentToken\n-     *         +-------- The logical position of the TokenStream object, where the &quot;consume()&quot; would return T2\n-     * </pre>\n-     */\n-    private ListIterator<Token> tokenIterator;\n-    private Token currentToken;\n-    private boolean completed;\n-\n-    public TokenStream(String content,\n-                       Tokenizer tokenizer,\n-                       boolean caseSensitive) {\n-        Objects.requireNonNull(content, \"content\");\n-        Objects.requireNonNull(tokenizer, \"tokenizer\");\n-        this.inputString = content;\n-        this.inputContent = content.toCharArray();\n-        this.caseSensitive = caseSensitive;\n-        this.tokenizer = tokenizer;\n-    }\n-\n-    /**\n-     * Begin the token stream, including (if required) the tokenization of the input content.\n-     *\n-     * @return this object for easy method chaining; never null\n-     * @throws ParsingException if an error occurs during tokenization of the content\n-     */\n-    public TokenStream start() throws ParsingException {\n-        // Create the tokens ...\n-        if (tokens == null) {\n-            TokenFactory tokenFactory = caseSensitive ? new CaseSensitiveTokenFactory() : new CaseInsensitiveTokenFactory();\n-            CharacterStream characterStream = new CharacterArrayStream(inputContent);\n-            tokenizer.tokenize(characterStream, tokenFactory);\n-            this.tokens = initializeTokens(tokenFactory.getTokens());\n-        }\n-\n-        // Create the iterator ...\n-        tokenIterator = this.tokens.listIterator();\n-        moveToNextToken();\n-        return this;\n-    }\n-\n-    /**\n-     * Method to allow subclasses to pre-process the set of tokens and return the correct tokens to use. The default behavior is\n-     * to simply return the supplied tokens.\n-     *\n-     * @param tokens the tokens\n-     * @return list of tokens.\n-     */\n-    protected List<Token> initializeTokens(List<Token> tokens) {\n-        return tokens;\n-    }\n-\n-    /**\n-     * Method to allow tokens to be re-used from the start without re-tokenizing content.\n-     */\n-    public void rewind() {\n-        // recreate the iterator ...\n-        tokenIterator = this.tokens.listIterator();\n-        completed = false;\n-        currentToken = null;\n-        moveToNextToken();\n-    }\n-\n-    /**\n-     * Obtain a marker that records the current position so that the stream can be {@link #rewind(Marker)} back to the mark even\n-     * after having been advanced beyond the mark.\n-     *\n-     * @return the marker; never null\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     * @throws NoSuchElementException if there are no more tokens\n-     */\n-    public Marker mark() {\n-        if (completed) {\n-            return new Marker(null, tokenIterator.previousIndex());\n-        }\n-        Token currentToken = currentToken();\n-        Position currentPosition = currentToken != null ? currentToken.position() : null;\n-        return new Marker(currentPosition, tokenIterator.previousIndex());\n-    }\n-\n-    /**\n-     * Reset the stream back to the position described by the supplied marker. This method does nothing if the mark is invalid.\n-     * For example, it is not possible to advance the token stream beyond the current position.\n-     *\n-     * @param marker the marker\n-     * @return true if the token stream was reset, or false if the marker was invalid\n-     * @see #advance(Marker)\n-     */\n-    public boolean rewind(Marker marker) {\n-        if (marker.tokenIndex >= 0 && marker.tokenIndex <= this.tokenIterator.nextIndex()) {\n-            completed = false;\n-            currentToken = null;\n-            tokenIterator = this.tokens.listIterator(marker.tokenIndex);\n-            moveToNextToken();\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Advance the stream back to the position described by the supplied marker. This method does nothing if the mark is invalid.\n-     * For example, it is not possible to rewind the token stream beyond the current position.\n-     *\n-     * @param marker the marker\n-     * @return true if the token stream was advanced, or false if the marker was invalid\n-     * @see #rewind(Marker)\n-     */\n-    public boolean advance(Marker marker) {\n-        if (marker.tokenIndex >= 0 && marker.tokenIndex >= this.tokenIterator.nextIndex()) {\n-            completed = false;\n-            currentToken = null;\n-            tokenIterator = this.tokens.listIterator(marker.tokenIndex);\n-            moveToNextToken();\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Get the position of the previous token.\n-     *\n-     * @return the previous token's position; never null\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     * @throws NoSuchElementException if there is no previous token\n-     */\n-    public Position previousPosition() {\n-        return previousPosition(1);\n-    }\n-\n-    /**\n-     * Get the position of a token earlier in the stream from the current position.\n-     *\n-     * @param count the number of tokens before the current position (e.g., 1 for the previous position)\n-     * @return the previous token's position; never null\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     * @throws NoSuchElementException if there is no previous token\n-     */\n-    public Position previousPosition(int count) {\n-        return previousToken(1).position();\n-    }\n-\n-    /**\n-     * Get the position of the next (or current) token.\n-     *\n-     * @return the current token's position; never null\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     * @throws NoSuchElementException if there is no previous token\n-     */\n-    public Position nextPosition() {\n-        return currentToken().position();\n-    }\n-\n-    /**\n-     * Convert the value of this token to an integer, return it, and move to the next token.\n-     *\n-     * @return the current token's value, converted to an integer\n-     * @throws ParsingException if there is no such token to consume, or if the token cannot be converted to an integer\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public int consumeInteger() throws ParsingException, IllegalStateException {\n-        if (completed) {\n-            throwNoMoreContent();\n-        }\n-        // Get the value from the current token ...\n-        String value = currentToken().value().toUpperCase();\n-        try {\n-            List<Token> newTokens = new ArrayList<>();\n-            int ePos = value.indexOf(\"E\");\n-            // Scientific format, need to identify mantissa and exponent and put it back to stream\n-            if (ePos != -1) {\n-                String mantissa = value.substring(0, ePos);\n-                newTokens.add(new CaseInsensitiveToken(currentToken().startIndex() + ePos, currentToken().startIndex() + ePos + 1, DdlTokenizer.WORD,\n-                        currentToken().position()));\n-                // Number is in format xxxEyyy\n-                if (ePos != value.length() - 1) {\n-                    newTokens.add(\n-                            new CaseInsensitiveToken(currentToken().startIndex() + ePos + 1, currentToken().endIndex(), DdlTokenizer.WORD, currentToken().position()));\n-                }\n-                value = mantissa;\n-            }\n-            int result = Integer.parseInt(value);\n-            moveToNextToken(newTokens);\n-            return result;\n-        }\n-        catch (NumberFormatException e) {\n-            Position position = currentToken().position();\n-            throw new ParsingException(position,\n-                    \"Expecting integer at line \" + position.line() + \", column \" + position.column() + \" but found '\" + value + \"'\");\n-        }\n-    }\n-\n-    /**\n-     * Convert the value of this token to a long, return it, and move to the next token.\n-     *\n-     * @return the current token's value, converted to an integer\n-     * @throws ParsingException if there is no such token to consume, or if the token cannot be converted to a long\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public long consumeLong() throws ParsingException, IllegalStateException {\n-        if (completed) {\n-            throwNoMoreContent();\n-        }\n-        // Get the value from the current token ...\n-        String value = currentToken().value();\n-        try {\n-            long result = Long.parseLong(value);\n-            moveToNextToken();\n-            return result;\n-        }\n-        catch (NumberFormatException e) {\n-            Position position = currentToken().position();\n-            throw new ParsingException(position,\n-                    \"Expecting long at line \" + position.line() + \", column \" + position.column() + \" but found '\" + value + \"'\");\n-        }\n-    }\n-\n-    /**\n-     * Convert the value of this token to an integer, return it, and move to the next token.\n-     *\n-     * @return the current token's value, converted to an integer\n-     * @throws ParsingException if there is no such token to consume, or if the token cannot be converted to an integer\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean consumeBoolean() throws ParsingException, IllegalStateException {\n-        if (completed) {\n-            throwNoMoreContent();\n-        }\n-        // Get the value from the current token ...\n-        String value = currentToken().value();\n-        try {\n-            boolean result = Boolean.parseBoolean(value);\n-            moveToNextToken();\n-            return result;\n-        }\n-        catch (NumberFormatException e) {\n-            Position position = currentToken().position();\n-            throw new ParsingException(position,\n-                    \"Expecting boolean at line \" + position.line() + \", column \" + position.column() + \" but found '\" + value + \"'\");\n-        }\n-    }\n-\n-    /**\n-     * Return the value of this token and move to the next token.\n-     *\n-     * @return the value of the current token\n-     * @throws ParsingException if there is no such token to consume\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public String consume() throws ParsingException, IllegalStateException {\n-        if (completed) {\n-            throwNoMoreContent();\n-        }\n-        // Get the value from the current token ...\n-        String result = currentToken().value();\n-        moveToNextToken();\n-        return result;\n-    }\n-\n-    protected void throwNoMoreContent() throws ParsingException {\n-        Position pos = tokens.isEmpty() ? new Position(-1, 1, 0) : tokens.get(tokens.size() - 1).position();\n-        throw new ParsingException(pos, \"No more content\");\n-    }\n-\n-    public String peek() throws IllegalStateException {\n-        if (completed) {\n-            throwNoMoreContent();\n-        }\n-        // Get the value from the current token but do NOT advance ...\n-        return currentToken().value();\n-    }\n-\n-    /**\n-     * Attempt to consume this current token as long as it matches the expected value, or throw an exception if the token does not\n-     * match.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the expected value of the current token\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the current token doesn't match the supplied value\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consume(String expected) throws ParsingException, IllegalStateException {\n-        if (completed) {\n-            throw new ParsingException(tokens.get(tokens.size() - 1).position(), \"No more content but was expecting token \" + expected);\n-        }\n-        // Get the value from the current token ...\n-        if (expected != ANY_VALUE && !currentToken().matches(expected)) {\n-            String found = currentToken().value();\n-            Position pos = currentToken().position();\n-            String fragment = generateFragment();\n-            String msg = \"Expecting \" + expected + \" at line \" + pos.line() + \", column \" + pos.column() + \" but found '\" + found\n-                    + \"': \" + fragment;\n-            throw new ParsingException(pos, msg);\n-        }\n-        moveToNextToken();\n-        return this;\n-    }\n-\n-    /**\n-     * Attempt to consume this current token as long as it matches the expected character, or throw an exception if the token does\n-     * not match.\n-     *\n-     * @param expected the expected character of the current token\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the current token doesn't match the supplied value\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consume(char expected) throws ParsingException, IllegalStateException {\n-        if (completed) {\n-            throw new ParsingException(tokens.get(tokens.size() - 1).position(), \"No more content but was expecting '\" + expected + \"'\");\n-        }\n-        // Get the value from the current token ...\n-        if (!currentToken().matches(expected)) {\n-            String found = currentToken().value();\n-            Position pos = currentToken().position();\n-            String fragment = generateFragment();\n-            String msg = \"Expecting '\" + expected + \"' at line \" + pos.line() + \", column \" + pos.column() + \" but found '\" + found\n-                    + \"': \" + fragment;\n-            throw new ParsingException(pos, msg);\n-        }\n-        moveToNextToken();\n-        return this;\n-    }\n-\n-    /**\n-     * Attempt to consume this current token as long as it matches the expected character, or throw an exception if the token does\n-     * not match.\n-     * <p>\n-     * The {@link #ANY_TYPE ANY_TYPE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param expectedType the expected token type of the current token\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the current token doesn't match the supplied value\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consume(int expectedType) throws ParsingException, IllegalStateException {\n-        if (completed) {\n-            throw new ParsingException(tokens.get(tokens.size() - 1).position(),\n-                    \"No more content but was expecting token of type \" + expectedType);\n-        }\n-        // Get the value from the current token ...\n-        if (expectedType != ANY_TYPE && (currentToken().type() & expectedType) != expectedType) {\n-            String found = currentToken().value();\n-            Position pos = currentToken().position();\n-            String fragment = generateFragment();\n-            String msg = \"Expecting token type \" + expectedType + \" at line \" + pos.line() + \", column \" + pos.column()\n-                    + \" but found '\" + found\n-                    + \"': \" + fragment;\n-            throw new ParsingException(pos, msg);\n-        }\n-        moveToNextToken();\n-        return this;\n-    }\n-\n-    /**\n-     * Attempt to consume this current token as the next tokens as long as they match the expected values, or throw an exception\n-     * if the token does not match.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the expected value of the current token\n-     * @param expectedForNextTokens the expected values of the following tokens\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the current token doesn't match the supplied value\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consume(String expected,\n-                               String... expectedForNextTokens)\n-            throws ParsingException, IllegalStateException {\n-        consume(expected);\n-        for (String nextExpected : expectedForNextTokens) {\n-            consume(nextExpected);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Attempt to consume this current token as the next tokens as long as they match the expected values, or throw an exception\n-     * if the token does not match.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param nextTokens the expected values for the next tokens\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the current token doesn't match the supplied value\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consume(String[] nextTokens) throws ParsingException, IllegalStateException {\n-        for (String nextExpected : nextTokens) {\n-            consume(nextExpected);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Attempt to consume this current token as the next tokens as long as they match the expected values, or throw an exception\n-     * if the token does not match.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param nextTokens the expected values for the next tokens\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the current token doesn't match the supplied value\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consume(Iterable<String> nextTokens) throws ParsingException, IllegalStateException {\n-        for (String nextExpected : nextTokens) {\n-            consume(nextExpected);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Consume and return the next token that must match one of the supplied values.\n-     *\n-     * @param typeOptions the options for the type of the current token\n-     * @return the token that was consumed and that matches one of the supplied options\n-     * @throws ParsingException if the current token doesn't match the supplied value\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public String consumeAnyOf(int... typeOptions) throws IllegalStateException {\n-        if (completed) {\n-            throw new ParsingException(tokens.get(tokens.size() - 1).position(),\n-                    \"No more content but was expecting one token of type \" + Strings.join(\"|\", typeOptions));\n-        }\n-        for (int typeOption : typeOptions) {\n-            if (typeOption == ANY_TYPE || matches(typeOption)) {\n-                return consume();\n-            }\n-        }\n-        // Failed to find a match ...\n-        String found = currentToken().value();\n-        Position pos = currentToken().position();\n-        String fragment = generateFragment();\n-        String msg = \"Expecting \" + Strings.join(\"|\", typeOptions) + \" at line \" + pos.line() + \", column \" + pos.column() + \" but found '\"\n-                + found + \"': \" + fragment;\n-        throw new ParsingException(pos, msg);\n-    }\n-\n-    /**\n-     * Consume and return the next token that must match one of the supplied values.\n-     *\n-     * @param options the additional options for the value of the current token\n-     * @return the token that was consumed and that matches one of the supplied options\n-     * @throws ParsingException if the current token doesn't match the supplied value\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public String consumeAnyOf(String... options) throws IllegalStateException {\n-        if (completed) {\n-            throw new ParsingException(tokens.get(tokens.size() - 1).position(),\n-                    \"No more content but was expecting one token of \" + String.join(\"|\", options));\n-        }\n-        for (String option : options) {\n-            if (option == ANY_VALUE || matches(option)) {\n-                return consume();\n-            }\n-        }\n-        // Failed to find a match ...\n-        String found = currentToken().value();\n-        Position pos = currentToken().position();\n-        String fragment = generateFragment();\n-        String msg = \"Expecting \" + String.join(\"|\", options) + \" at line \" + pos.line() + \", column \" + pos.column() + \" but found '\"\n-                + found + \"': \" + fragment;\n-        throw new ParsingException(pos, msg);\n-    }\n-\n-    /**\n-     * Attempt to consume all tokens until the specified token is consumed, and then stop. If it is not found, then the token\n-     * stream is left untouched and a ParsingException is thrown.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the token that is to be found\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the specified token cannot be found\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consumeThrough(char expected) throws ParsingException, IllegalStateException {\n-        return consumeThrough(String.valueOf(expected), null);\n-    }\n-\n-    /**\n-     * Attempt to consume all tokens until the specified token is consumed, and then stop. If it is not found, then the token\n-     * stream is left untouched and a ParsingException is thrown.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the token that is to be found\n-     * @param skipMatchingTokens the token that, if found, should result in skipping {@code expected} once for each occurrence\n-     *            of {@code skipMatchingTokens}; may be null\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the specified token cannot be found\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consumeThrough(char expected, char skipMatchingTokens) throws ParsingException, IllegalStateException {\n-        return consumeThrough(String.valueOf(expected), String.valueOf(skipMatchingTokens));\n-    }\n-\n-    /**\n-     * Attempt to consume all tokens until the specified token is consumed, and then stop. If it is not found, then the token\n-     * stream is left untouched and a ParsingException is thrown.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the token that is to be found\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the specified token cannot be found\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consumeThrough(String expected) throws ParsingException, IllegalStateException {\n-        return consumeThrough(expected, null);\n-    }\n-\n-    /**\n-     * Attempt to consume all tokens until the specified token is consumed, and then stop. If it is not found, then the token\n-     * stream is left untouched and a ParsingException is thrown.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the token that is to be found\n-     * @param skipMatchingTokens the token that, if found, should result in skipping {@code expected} once for each occurrence\n-     *            of {@code skipMatchingTokens}; may be null\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the specified token cannot be found\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consumeThrough(String expected, String skipMatchingTokens) throws ParsingException, IllegalStateException {\n-        if (ANY_VALUE == expected) {\n-            consume();\n-            return this;\n-        }\n-        consumeUntil(expected, skipMatchingTokens);\n-        consume(expected);\n-        return this;\n-    }\n-\n-    /**\n-     * Attempt to consume all tokens until the specified token is found, and then stop before consuming that token.\n-     * If it is not found, then the token stream is left untouched and a ParsingException is thrown.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the token that is to be found\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the specified token cannot be found\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consumeUntil(char expected) throws ParsingException, IllegalStateException {\n-        return consumeUntil(String.valueOf(expected), (String[]) null);\n-    }\n-\n-    /**\n-     * Attempt to consume all tokens until the specified token is found, and then stop before consuming that token.\n-     * If it is not found, then the token stream is left untouched and a ParsingException is thrown.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the token that is to be found\n-     * @param skipMatchingTokens the token that, if found, should result in skipping {@code expected} once for each occurrence\n-     *            of {@code skipMatchingTokens}\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the specified token cannot be found\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consumeUntil(char expected, char skipMatchingTokens) throws ParsingException, IllegalStateException {\n-        return consumeUntil(String.valueOf(expected), String.valueOf(skipMatchingTokens));\n-    }\n-\n-    /**\n-     * Attempt to consume all tokens until the specified token is found, and then stop before consuming that token.\n-     * If it is not found, then the token stream is left untouched and a ParsingException is thrown.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the token that is to be found\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the specified token cannot be found\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consumeUntil(String expected) throws ParsingException, IllegalStateException {\n-        return consumeUntil(expected, (String[]) null);\n-    }\n-\n-    /**\n-     * Attempt to consume all tokens until the specified token is found, and then stop before consuming that token.\n-     * If it is not found, then the token stream is left untouched and a ParsingException is thrown.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the token that is to be found\n-     * @param skipMatchingTokens the token that, if found, should result in skipping {@code expected} once for each occurrence\n-     *            of {@code skipMatchingTokens}; may be null\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if the specified token cannot be found\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consumeUntil(String expected, String... skipMatchingTokens) throws ParsingException, IllegalStateException {\n-        if (ANY_VALUE == expected) {\n-            consume();\n-            return this;\n-        }\n-        Marker start = mark();\n-        int remaining = 0;\n-        while (hasNext()) {\n-            if (skipMatchingTokens != null && matchesAnyOf(skipMatchingTokens)) {\n-                ++remaining;\n-            }\n-            if (matches(expected)) {\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                --remaining;\n-            }\n-            consume();\n-        }\n-        if (completed) {\n-            rewind(start);\n-            throw new ParsingException(tokens.get(tokens.size() - 1).position(),\n-                    \"No more content but was expecting to find \" + expected);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Consume the token stream until one of the stop tokens or the end of the stream is found.\n-     *\n-     * @param stopTokens the stop tokens; may not be null\n-     * @return this token stream instance so callers can chain together methods; never null\n-     * @throws ParsingException if none of the specified tokens can be found\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public TokenStream consumeUntilEndOrOneOf(String... stopTokens)\n-            throws ParsingException, IllegalStateException {\n-        while (hasNext()) {\n-            if (matchesAnyOf(stopTokens)) {\n-                break;\n-            }\n-            consume();\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Attempt to consume this current token if it can be parsed as an integer, and return whether this method was indeed able to\n-     * consume the token.\n-     *\n-     * @param consumer the function that should be called with the integer value if the current token token could be parsed\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsumeInteger(IntConsumer consumer) throws IllegalStateException {\n-        if (completed) {\n-            throwNoMoreContent();\n-        }\n-        // Get the value from the current token ...\n-        String value = currentToken().value();\n-        try {\n-            int result = Integer.parseInt(value);\n-            moveToNextToken();\n-            consumer.accept(result);\n-            return true;\n-        }\n-        catch (NumberFormatException e) {\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Attempt to consume this current token if it can be parsed as a boolean, and return whether this method was indeed able to\n-     * consume the token.\n-     *\n-     * @param consumer the function that should be called with the boolean value if the current token token could be parsed\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsumeBoolean(BooleanConsumer consumer) throws IllegalStateException {\n-        if (completed) {\n-            throwNoMoreContent();\n-        }\n-        // Get the value from the current token ...\n-        String value = currentToken().value();\n-        try {\n-            boolean result = Boolean.parseBoolean(value);\n-            moveToNextToken();\n-            consumer.accept(result);\n-            return true;\n-        }\n-        catch (NumberFormatException e) {\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Attempt to consume this current token if it can be parsed as a long, and return whether this method was indeed able to\n-     * consume the token.\n-     *\n-     * @param consumer the function that should be called with the long value if the current token token could be parsed\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsumeLong(LongConsumer consumer) throws IllegalStateException {\n-        if (completed) {\n-            throwNoMoreContent();\n-        }\n-        // Get the value from the current token ...\n-        String value = currentToken().value();\n-        try {\n-            long result = Long.parseLong(value);\n-            moveToNextToken();\n-            consumer.accept(result);\n-            return true;\n-        }\n-        catch (NumberFormatException e) {\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Attempt to consume this current token if it matches the expected value, and return whether this method was indeed able to\n-     * consume the token.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected value as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the expected value of the current token\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsume(String expected) throws IllegalStateException {\n-        return canConsume(ANY_TYPE, expected);\n-    }\n-\n-    /**\n-     * Attempt to consume this current token if it matches the expected value, and return whether this method was indeed able to\n-     * consume the token.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected value as a wildcard.\n-     * </p>\n-     *\n-     * @param type the expected type of the current token\n-     * @param expected the expected value of the current token\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsume(int type, String expected) throws IllegalStateException {\n-        if (!(matches(expected) && matches(type))) {\n-            return false;\n-        }\n-        moveToNextToken();\n-        return true;\n-    }\n-\n-    /**\n-     * Attempt to consume this current token if it is {@link BasicTokenizer#WORD} and it matches the expected value,\n-     * and return whether this method was indeed able to consume the token.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected value as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the expected value of the current token\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsumeWord(String expected) throws IllegalStateException {\n-        return canConsume(BasicTokenizer.WORD, expected);\n-    }\n-\n-    /**\n-     * Attempt to consume this current token if it matches the expected value, and return whether this method was indeed able to\n-     * consume the token.\n-     *\n-     * @param expected the expected value of the current token token\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsume(char expected) throws IllegalStateException {\n-        if (!matches(expected)) {\n-            return false;\n-        }\n-        moveToNextToken();\n-        return true;\n-    }\n-\n-    /**\n-     * Attempt to consume this current token if it matches the expected token type, and return whether this method was indeed able\n-     * to consume the token.\n-     * <p>\n-     * The {@link #ANY_TYPE ANY_TYPE} constant can be used in the expected type as a wildcard.\n-     * </p>\n-     *\n-     * @param expectedType the expected token type of the current token\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsume(int expectedType) throws IllegalStateException {\n-        if (!matches(expectedType)) {\n-            return false;\n-        }\n-        moveToNextToken();\n-        return true;\n-    }\n-\n-    /**\n-     * Attempt to consume this current token and the next tokens if and only if they match the expected values, and return whether\n-     * this method was indeed able to consume all of the supplied tokens.\n-     * <p>\n-     * This is <i>not</i> the same as calling {@link #canConsume(String)} for each of the supplied arguments, since this method\n-     * ensures that <i>all</i> of the supplied values can be consumed.\n-     * </p>\n-     * <p>\n-     * This method <i>is</i> equivalent to calling the following:\n-     *\n-     * <pre>\n-     *\n-     * if (tokens.matches(currentExpected, expectedForNextTokens)) {\n-     *     tokens.consume(currentExpected, expectedForNextTokens);\n-     * }\n-     *\n-     * </pre>\n-     *\n-     * </p>\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param currentExpected the expected value of the current token\n-     * @param expectedForNextTokens the expected values fo the following tokens\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsume(String currentExpected,\n-                              String... expectedForNextTokens)\n-            throws IllegalStateException {\n-        return canConsume(ANY_TYPE, currentExpected, expectedForNextTokens);\n-    }\n-\n-    /**\n-     * Attempt to consume this current token and the next tokens if and only if they match the expected type and values,\n-     *  and return whether this method was indeed able to consume all of the supplied tokens.\n-     * <p>\n-     * This is <i>not</i> the same as calling {@link #canConsume(type String)} for each of the supplied arguments, since this method\n-     * ensures that <i>all</i> of the supplied values can be consumed.\n-     * </p>\n-     * <p>\n-     * This method <i>is</i> equivalent to calling the following:\n-     *\n-     * <pre>\n-     *\n-     * if (tokens.matches(currentExpected, expectedForNextTokens) && tokens.matches(type, type, ...)) {\n-     *     tokens.consume(currentExpected, expectedForNextTokens);\n-     * }\n-     *\n-     * </pre>\n-     *\n-     * </p>\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param type the expect type of the tokens\n-     * @param currentExpected the expected value of the current token\n-     * @param expectedForNextTokens the expected values fo the following tokens\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsume(int type, String currentExpected, String... expectedForNextTokens)\n-            throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        ListIterator<Token> iter = tokens.listIterator(tokenIterator.previousIndex());\n-        if (!iter.hasNext()) {\n-            return false;\n-        }\n-        Token token = iter.next();\n-        if (currentExpected != ANY_VALUE && !token.matches(type, currentExpected)) {\n-            return false;\n-        }\n-        for (String nextExpected : expectedForNextTokens) {\n-            if (!iter.hasNext()) {\n-                return false;\n-            }\n-            token = iter.next();\n-            if (nextExpected == ANY_VALUE) {\n-                continue;\n-            }\n-            if (!token.matches(type, nextExpected)) {\n-                return false;\n-            }\n-        }\n-        this.tokenIterator = iter;\n-        this.currentToken = tokenIterator.hasNext() ? tokenIterator.next() : null;\n-        this.completed = this.currentToken == null;\n-        return true;\n-    }\n-\n-    /**\n-     * Attempt to consume this current token and the next tokens if and only if they are of {@link BasicTokenizer#WORD} and match the expected values,\n-     * and return whether this method was indeed able to consume all of the supplied tokens.\n-     *\n-     * @param currentExpected the expected value of the current token\n-     * @param expectedForNextTokens the expected values fo the following tokens\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     * @see #canConsume(int, String, String...)\n-     */\n-    public boolean canConsumeWords(String currentExpected, String... expectedForNextTokens) throws IllegalStateException {\n-        return canConsume(BasicTokenizer.WORD, currentExpected, expectedForNextTokens);\n-    }\n-\n-    /**\n-     * Attempt to consume this current token and the next tokens if and only if they match the expected values, and return whether\n-     * this method was indeed able to consume all of the supplied tokens.\n-     * <p>\n-     * This is <i>not</i> the same as calling {@link #canConsume(String)} for each of the supplied arguments, since this method\n-     * ensures that <i>all</i> of the supplied values can be consumed.\n-     * </p>\n-     * <p>\n-     * This method <i>is</i> equivalent to calling the following:\n-     *\n-     * <pre>\n-     *\n-     * if (tokens.matches(currentExpected, expectedForNextTokens)) {\n-     *     tokens.consume(currentExpected, expectedForNextTokens);\n-     * }\n-     *\n-     * </pre>\n-     *\n-     * </p>\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param nextTokens the expected values of the next tokens\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsume(String[] nextTokens) throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        ListIterator<Token> iter = tokens.listIterator(tokenIterator.previousIndex());\n-        Token token = null;\n-        for (String nextExpected : nextTokens) {\n-            if (!iter.hasNext()) {\n-                return false;\n-            }\n-            token = iter.next();\n-            if (nextExpected == ANY_VALUE) {\n-                continue;\n-            }\n-            if (!token.matches(nextExpected)) {\n-                return false;\n-            }\n-        }\n-        this.tokenIterator = iter;\n-        this.currentToken = tokenIterator.hasNext() ? tokenIterator.next() : null;\n-        this.completed = this.currentToken == null;\n-        return true;\n-    }\n-\n-    /**\n-     * Attempt to consume this current token and the next tokens if and only if they match the expected values, and return whether\n-     * this method was indeed able to consume all of the supplied tokens.\n-     * <p>\n-     * This is <i>not</i> the same as calling {@link #canConsume(String)} for each of the supplied arguments, since this method\n-     * ensures that <i>all</i> of the supplied values can be consumed.\n-     * </p>\n-     * <p>\n-     * This method <i>is</i> equivalent to calling the following:\n-     *\n-     * <pre>\n-     *\n-     * if (tokens.matches(currentExpected, expectedForNextTokens)) {\n-     *     tokens.consume(currentExpected, expectedForNextTokens);\n-     * }\n-     *\n-     * </pre>\n-     *\n-     * </p>\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param nextTokens the expected values of the next tokens\n-     * @return true if the current token did match and was consumed, or false if the current token did not match and therefore was\n-     *         not consumed\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsume(Iterable<String> nextTokens) throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        ListIterator<Token> iter = tokens.listIterator(tokenIterator.previousIndex());\n-        Token token = null;\n-        for (String nextExpected : nextTokens) {\n-            if (!iter.hasNext()) {\n-                return false;\n-            }\n-            token = iter.next();\n-            if (nextExpected == ANY_VALUE) {\n-                continue;\n-            }\n-            if (!token.matches(nextExpected)) {\n-                return false;\n-            }\n-        }\n-        this.tokenIterator = iter;\n-        this.currentToken = tokenIterator.hasNext() ? tokenIterator.next() : null;\n-        this.completed = this.currentToken == null;\n-        return true;\n-    }\n-\n-    /**\n-     * Attempt to consume the next token if it matches one of the supplied values.\n-     *\n-     * @param firstOption the first option for the value of the current token\n-     * @param additionalOptions the additional options for the value of the current token\n-     * @return true if the current token's value did match one of the supplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsumeAnyOf(String firstOption,\n-                                   String... additionalOptions)\n-            throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        if (canConsume(firstOption)) {\n-            return true;\n-        }\n-        for (String nextOption : additionalOptions) {\n-            if (canConsume(nextOption)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Attempt to consume the next token if it matches one of the supplied values.\n-     *\n-     * @param options the options for the value of the current token\n-     * @return true if the current token's value did match one of the suplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsumeAnyOf(String[] options) throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        for (String option : options) {\n-            if (canConsume(option)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Attempt to consume the next token if it matches one of the supplied values.\n-     *\n-     * @param options the options for the value of the current token\n-     * @return true if the current token's value did match one of the supplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsumeAnyOf(Iterable<String> options) throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        for (String option : options) {\n-            if (canConsume(option)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Attempt to consume the next token if it matches one of the supplied types.\n-     *\n-     * @param firstTypeOption the first option for the type of the current token\n-     * @param additionalTypeOptions the additional options for the type of the current token\n-     * @return true if the current token's type matched one of the supplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsumeAnyOf(int firstTypeOption,\n-                                   int... additionalTypeOptions)\n-            throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        if (canConsume(firstTypeOption)) {\n-            return true;\n-        }\n-        for (int nextTypeOption : additionalTypeOptions) {\n-            if (canConsume(nextTypeOption)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Attempt to consume the next token if it matches one of the supplied types.\n-     *\n-     * @param typeOptions the options for the type of the current token\n-     * @return true if the current token's type matched one of the supplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean canConsumeAnyOf(int[] typeOptions) throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        for (int nextTypeOption : typeOptions) {\n-            if (canConsume(nextTypeOption)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Determine if the current token matches the expected value.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the expected value of the current token\n-     * @return true if the current token did match, or false if the current token did not match\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matches(String expected) throws IllegalStateException {\n-        return matches(ANY_TYPE, expected);\n-    }\n-\n-    /**\n-     * Determine if the current token matches the expected type and a value.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used as a wildcard.\n-     * </p>\n-     *\n-     * @param type the expected type of the curent token\n-     * @param expected the expected value of the current token\n-     * @return true if the current token did match, or false if the current token did not match\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matches(int type, String expected) throws IllegalStateException {\n-        return !completed && (expected == ANY_VALUE || currentToken().matches(expected)) && currentToken().matches(type);\n-    }\n-\n-    /**\n-     * Determine if the current token is {@link BasicTokenizer#WORD} and matches the expected value.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used as a wildcard.\n-     * </p>\n-     *\n-     * @param expected the expected value of the current token\n-     * @return true if the current token did match, or false if the current token did not match\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matchesWord(String expected) throws IllegalStateException {\n-        return matches(BasicTokenizer.WORD, expected);\n-    }\n-\n-    /**\n-     * Determine if the current token matches the expected value.\n-     *\n-     * @param expected the expected value of the current token token\n-     * @return true if the current token did match, or false if the current token did not match\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matches(char expected) throws IllegalStateException {\n-        return !completed && currentToken().matches(expected);\n-    }\n-\n-    /**\n-     * Determine if the current token matches the expected token type.\n-     *\n-     * @param expectedType the expected token type of the current token\n-     * @return true if the current token did match, or false if the current token did not match\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matches(int expectedType) throws IllegalStateException {\n-        return !completed && currentToken().matches(expectedType);\n-    }\n-\n-    /**\n-     * Determine if the next few tokens match the expected values.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param currentExpected the expected value of the current token\n-     * @param expectedForNextTokens the expected values for the following tokens\n-     * @return true if the tokens did match, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matches(String currentExpected,\n-                           String... expectedForNextTokens)\n-            throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        ListIterator<Token> iter = tokens.listIterator(tokenIterator.previousIndex());\n-        if (!iter.hasNext()) {\n-            return false;\n-        }\n-        Token token = iter.next();\n-        if (currentExpected != ANY_VALUE && !token.matches(currentExpected)) {\n-            return false;\n-        }\n-        for (String nextExpected : expectedForNextTokens) {\n-            if (!iter.hasNext()) {\n-                return false;\n-            }\n-            token = iter.next();\n-            if (nextExpected == ANY_VALUE) {\n-                continue;\n-            }\n-            if (!token.matches(nextExpected)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Determine if the next few tokens match the expected values.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param nextTokens the expected value of the next tokens\n-     * @return true if the tokens did match, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matches(String[] nextTokens) throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        ListIterator<Token> iter = tokens.listIterator(tokenIterator.previousIndex());\n-        Token token = null;\n-        for (String nextExpected : nextTokens) {\n-            if (!iter.hasNext()) {\n-                return false;\n-            }\n-            token = iter.next();\n-            if (nextExpected == ANY_VALUE) {\n-                continue;\n-            }\n-            if (!token.matches(nextExpected)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Determine if the next few tokens match the expected values.\n-     * <p>\n-     * The {@link #ANY_VALUE ANY_VALUE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param nextTokens the expected value of the next tokens\n-     * @return true if the tokens did match, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matches(Iterable<String> nextTokens) throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        ListIterator<Token> iter = tokens.listIterator(tokenIterator.previousIndex());\n-        Token token = null;\n-        for (String nextExpected : nextTokens) {\n-            if (!iter.hasNext()) {\n-                return false;\n-            }\n-            token = iter.next();\n-            if (nextExpected == ANY_VALUE) {\n-                continue;\n-            }\n-            if (!token.matches(nextExpected)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Determine if the next few tokens have the supplied types.\n-     * <p>\n-     * The {@link #ANY_TYPE ANY_TYPE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param currentExpectedType the expected type of the current token\n-     * @param expectedTypeForNextTokens the expected type for the following tokens\n-     * @return true if the tokens did match, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matches(int currentExpectedType,\n-                           int... expectedTypeForNextTokens)\n-            throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        ListIterator<Token> iter = tokens.listIterator(tokenIterator.previousIndex());\n-        if (!iter.hasNext()) {\n-            return false;\n-        }\n-        Token token = iter.next();\n-        if (currentExpectedType != ANY_TYPE && (currentToken().type() & currentExpectedType) != currentExpectedType) {\n-            return false;\n-        }\n-        for (int nextExpectedType : expectedTypeForNextTokens) {\n-            if (!iter.hasNext()) {\n-                return false;\n-            }\n-            token = iter.next();\n-            if (nextExpectedType == ANY_TYPE) {\n-                continue;\n-            }\n-            if ((token.type() & nextExpectedType) != nextExpectedType) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Determine if the next few tokens have the supplied types.\n-     * <p>\n-     * The {@link #ANY_TYPE ANY_TYPE} constant can be used in the expected values as a wildcard.\n-     * </p>\n-     *\n-     * @param typesForNextTokens the expected type for each of the next tokens\n-     * @return true if the tokens did match, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matches(int[] typesForNextTokens) throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        ListIterator<Token> iter = tokens.listIterator(tokenIterator.previousIndex());\n-        Token token = null;\n-        for (int nextExpectedType : typesForNextTokens) {\n-            if (!iter.hasNext()) {\n-                return false;\n-            }\n-            token = iter.next();\n-            if (nextExpectedType == ANY_TYPE) {\n-                continue;\n-            }\n-            if (!token.matches(nextExpectedType)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Determine if the next token matches one of the supplied values.\n-     *\n-     * @param firstOption the first option for the value of the current token\n-     * @param additionalOptions the additional options for the value of the current token\n-     * @return true if the current token's value did match one of the supplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matchesAnyOf(String firstOption,\n-                                String... additionalOptions)\n-            throws IllegalStateException {\n-        return matchesAnyOf(ANY_TYPE, firstOption, additionalOptions);\n-    }\n-\n-    /**\n-     * Determine if the next token matches one of the supplied values of the expected type.\n-     *\n-     * @param type the expected type of tokens\n-     * @param firstOption the first option for the value of the current token\n-     * @param additionalOptions the additional options for the value of the current token\n-     * @return true if the current token's value did match one of the supplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matchesAnyOf(int type, String firstOption, String... additionalOptions)\n-            throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        Token current = currentToken();\n-        if (current.matches(type, firstOption)) {\n-            return true;\n-        }\n-        for (String nextOption : additionalOptions) {\n-            if (current.matches(type, nextOption)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Determine if the next token matches one of the supplied values of the type {@link BasicTokenizer#WORD}\n-     *\n-     * @param firstOption the first option for the value of the current token\n-     * @param additionalOptions the additional options for the value of the current token\n-     * @return true if the current token's value did match one of the supplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matchesAnyWordOf(String firstOption, String... additionalOptions)\n-            throws IllegalStateException {\n-        return matchesAnyOf(BasicTokenizer.WORD, firstOption, additionalOptions);\n-    }\n-\n-    /**\n-     * Determine if the next token matches one of the supplied values.\n-     *\n-     * @param options the options for the value of the current token\n-     * @return true if the current token's value did match one of the supplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matchesAnyOf(String[] options) throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        Token current = currentToken();\n-        for (String option : options) {\n-            if (current.matches(option)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Determine if the next token matches one of the supplied values.\n-     *\n-     * @param options the options for the value of the current token\n-     * @return true if the current token's value did match one of the supplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matchesAnyOf(Iterable<String> options) throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        Token current = currentToken();\n-        for (String option : options) {\n-            if (current.matches(option)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Determine if the next token have one of the supplied types.\n-     *\n-     * @param firstTypeOption the first option for the type of the current token\n-     * @param additionalTypeOptions the additional options for the type of the current token\n-     * @return true if the current token's type matched one of the supplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matchesAnyOf(int firstTypeOption,\n-                                int... additionalTypeOptions)\n-            throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        Token current = currentToken();\n-        if (current.matches(firstTypeOption)) {\n-            return true;\n-        }\n-        for (int nextTypeOption : additionalTypeOptions) {\n-            if (current.matches(nextTypeOption)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Determine if the next token have one of the supplied types.\n-     *\n-     * @param typeOptions the options for the type of the current token\n-     * @return true if the current token's type matched one of the supplied options, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean matchesAnyOf(int[] typeOptions) throws IllegalStateException {\n-        if (completed) {\n-            return false;\n-        }\n-        Token current = currentToken();\n-        for (int nextTypeOption : typeOptions) {\n-            if (current.matches(nextTypeOption)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Determine if this stream has another token to be consumed.\n-     *\n-     * @return true if there is another token ready for consumption, or false otherwise\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     */\n-    public boolean hasNext() {\n-        if (tokenIterator == null) {\n-            throw new IllegalStateException(\"start() method must be called before hasNext()\");\n-        }\n-        return !completed;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        ListIterator<Token> iter = tokens.listIterator(tokenIterator.previousIndex());\n-        StringBuilder sb = new StringBuilder();\n-        if (iter.hasNext()) {\n-            sb.append(iter.next());\n-            int count = 1;\n-            while (iter.hasNext()) {\n-                if (count > 20) {\n-                    sb.append(\" ...\");\n-                    break;\n-                }\n-                sb.append(\"  \");\n-                ++count;\n-                sb.append(iter.next());\n-            }\n-        }\n-        return sb.toString();\n-    }\n-\n-    private void moveToNextToken(List<Token> newTokens) {\n-        if (newTokens != null && !newTokens.isEmpty()) {\n-            for (Token t : newTokens) {\n-                tokenIterator.add(t);\n-            }\n-            for (int i = 0; i < newTokens.size() - 1; i++) {\n-                tokenIterator.previous();\n-            }\n-            currentToken = newTokens.get(0);\n-            return;\n-        }\n-        // And move the currentToken to the next token ...\n-        if (!tokenIterator.hasNext()) {\n-            completed = true;\n-            currentToken = null;\n-        }\n-        else {\n-            currentToken = tokenIterator.next();\n-        }\n-    }\n-\n-    private void moveToNextToken() {\n-        moveToNextToken(null);\n-    }\n-\n-    /**\n-     * Get the current token.\n-     *\n-     * @return the current token; never null\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     * @throws NoSuchElementException if there are no more tokens\n-     */\n-    final Token currentToken() throws IllegalStateException, NoSuchElementException {\n-        if (currentToken == null) {\n-            if (completed) {\n-                throw new NoSuchElementException(\"No more content\");\n-            }\n-            throw new IllegalStateException(\"start() method must be called before consuming or matching\");\n-        }\n-        assert currentToken != null;\n-        return currentToken;\n-    }\n-\n-    /**\n-     * Gets the content string starting at the specified marker (inclusive) and continuing up to the next position (exclusive).\n-     *\n-     * @param starting the marker describing a point in the stream; may not be null\n-     * @return the content string; never null\n-     */\n-    public String getContentFrom(Marker starting) {\n-        Objects.requireNonNull(starting, \"starting\");\n-        int startIndex = starting.position != null ? starting.position.index() : 0;\n-        return getContentBetween(startIndex, hasNext() ? nextPosition() : null);\n-    }\n-\n-    /**\n-     * Gets the content string starting at the specified marker (inclusive) and continuing up to the end position (exclusive).\n-     *\n-     * @param starting the marker describing a point in the stream; may not be null\n-     * @param end the position located directly after the returned content string; can be null, which means end of content\n-     * @return the content string; never null\n-     */\n-    public String getContentBetween(Marker starting,\n-                                    Position end) {\n-        Objects.requireNonNull(starting, \"starting\");\n-        int startIndex = starting.position != null ? starting.position.index() : 0;\n-        return getContentBetween(startIndex, end);\n-    }\n-\n-    /**\n-     * Gets the content string starting at the first position (inclusive) and continuing up to the end position (exclusive).\n-     *\n-     * @param starting the position marking the beginning of the desired content string; may not be null\n-     * @param end the position located directly after the returned content string; can be null, which means end of content\n-     * @return the content string; never null\n-     */\n-    public String getContentBetween(Position starting,\n-                                    Position end) {\n-        Objects.requireNonNull(starting, \"starting\");\n-        return getContentBetween(starting.index(), end);\n-    }\n-\n-    protected String getContentBetween(int startIndex,\n-                                       Position end) {\n-        int endIndex = end != null ? end.index() : inputString.length();\n-        if (startIndex >= endIndex) {\n-            throw new IllegalArgumentException(\"The starting position \" + startIndex + \" must be before the end position \" + end);\n-        }\n-\n-        return inputString.substring(startIndex, endIndex);\n-    }\n-\n-    /**\n-     * Get the previous token. This does not modify the state.\n-     *\n-     * @param count the number of tokens back from the current position that this method should return\n-     * @return the previous token; never null\n-     * @throws IllegalStateException if this method was called before the stream was {@link #start() started}\n-     * @throws NoSuchElementException if there is no previous token\n-     */\n-    public final Token previousToken(int count) throws IllegalStateException, NoSuchElementException {\n-        if (count < 1) {\n-            throw new IllegalArgumentException(\"The count must be positive\");\n-        }\n-        if (currentToken == null) {\n-            if (completed) {\n-                if (tokens.isEmpty()) {\n-                    throw new NoSuchElementException(\"No more content\");\n-                }\n-                return tokens.get(tokens.size() - 1);\n-            }\n-            throw new IllegalStateException(\"start() method must be called before consuming or matching\");\n-        }\n-        int index = tokenIterator.previousIndex() - count;\n-        if (index < 0) {\n-            throw new NoSuchElementException(\"No more content\");\n-        }\n-        return tokens.get(tokenIterator.previousIndex() - count);\n-    }\n-\n-    String generateFragment() {\n-        // Find the current position ...\n-        assert currentToken != null;\n-        int startIndex = currentToken.startIndex();\n-        return generateFragment(inputString, startIndex, 20, \" ===>> \");\n-    }\n-\n-    /**\n-     * Utility method to generate a highlighted fragment of a particular point in the stream.\n-     *\n-     * @param content the content from which the fragment should be taken; may not be null\n-     * @param indexOfProblem the index of the problem point that should be highlighted; must be a valid index in the content\n-     * @param charactersToIncludeBeforeAndAfter the maximum number of characters before and after the problem point to include in\n-     *            the fragment\n-     * @param highlightText the text that should be included in the fragment at the problem point to highlight the location, or an\n-     *            empty string if there should be no highlighting\n-     * @return the highlighted fragment; never null\n-     */\n-    static String generateFragment(String content,\n-                                   int indexOfProblem,\n-                                   int charactersToIncludeBeforeAndAfter,\n-                                   String highlightText) {\n-        assert content != null;\n-        assert indexOfProblem < content.length();\n-        // Find the substring that immediately precedes the current position ...\n-        int beforeStart = Math.max(0, indexOfProblem - charactersToIncludeBeforeAndAfter);\n-        String before = content.substring(beforeStart, indexOfProblem);\n-\n-        // Find the substring that immediately follows the current position ...\n-        int afterEnd = Math.min(indexOfProblem + charactersToIncludeBeforeAndAfter, content.length());\n-        String after = content.substring(indexOfProblem, afterEnd);\n-\n-        return before + (highlightText != null ? highlightText : \"\") + after;\n-    }\n-\n-    /**\n-     * Interface for a Tokenizer component responsible for processing the characters in a {@link CharacterStream} and constructing\n-     * the appropriate {@link Token} objects.\n-     */\n-    public static interface Tokenizer {\n-        /**\n-         * Process the supplied characters and construct the appropriate {@link Token} objects.\n-         *\n-         * @param input the character input stream; never null\n-         * @param tokens the factory for {@link Token} objects, which records the order in which the tokens are created\n-         * @throws ParsingException if there is an error while processing the character stream (e.g., a quote is not closed, etc.)\n-         */\n-        void tokenize(CharacterStream input,\n-                      Tokens tokens)\n-                throws ParsingException;\n-    }\n-\n-    /**\n-     * Interface used by a {@link Tokenizer} to iterate through the characters in the content input to the {@link TokenStream}.\n-     */\n-    public static interface CharacterStream {\n-\n-        /**\n-         * Determine if there is another character available in this stream.\n-         *\n-         * @return true if there is another character (and {@link #next()} can be called), or false otherwise\n-         */\n-        boolean hasNext();\n-\n-        /**\n-         * Obtain the next character value, and advance the stream.\n-         *\n-         * @return the next character\n-         * @throws NoSuchElementException if there is no {@link #hasNext() next character}\n-         */\n-        char next();\n-\n-        /**\n-         * Get the index for the last character returned from {@link #next()}.\n-         *\n-         * @return the index of the last character returned\n-         */\n-        int index();\n-\n-        /**\n-         * Get the position for the last character returned from {@link #next()}.\n-         *\n-         * @param startIndex the starting index\n-         * @return the position of the last character returned; never null\n-         */\n-        Position position(int startIndex);\n-\n-        /**\n-         * Get the content from the start position to the end position.\n-         *\n-         * @param startIndex the starting index\n-         * @param endIndex the index after the last character to include\n-         * @return the content\n-         */\n-        String substring(int startIndex, int endIndex);\n-\n-        /**\n-         * Determine if the next character on the stream is a {@link Character#isWhitespace(char) whitespace character}. This\n-         * method does <i>not</i> advance the stream.\n-         *\n-         * @return true if there is a {@link #next() next} character and it is a whitespace character, or false otherwise\n-         */\n-        boolean isNextWhitespace();\n-\n-        /**\n-         * Determine if the next character on the stream is a {@link Character#isLetterOrDigit(char) letter or digit}. This method\n-         * does <i>not</i> advance the stream.\n-         *\n-         * @return true if there is a {@link #next() next} character and it is a letter or digit, or false otherwise\n-         */\n-        boolean isNextLetterOrDigit();\n-\n-        /**\n-         * Determine if the next character on the stream is a {@link XmlCharacters#isValid(int) valid XML character}. This method\n-         * does <i>not</i> advance the stream.\n-         *\n-         * @return true if there is a {@link #next() next} character and it is a valid XML character, or false otherwise\n-         */\n-        boolean isNextValidXmlCharacter();\n-\n-        /**\n-         * Determine if the next character on the sream is a {@link XmlCharacters#isValidName(int) valid XML NCName character}.\n-         * This method does <i>not</i> advance the stream.\n-         *\n-         * @return true if there is a {@link #next() next} character and it is a valid XML Name character, or false otherwise\n-         */\n-        boolean isNextValidXmlNameCharacter();\n-\n-        /**\n-         * Determine if the next character on the sream is a {@link XmlCharacters#isValidNcName(int) valid XML NCName character}.\n-         * This method does <i>not</i> advance the stream.\n-         *\n-         * @return true if there is a {@link #next() next} character and it is a valid XML NCName character, or false otherwise\n-         */\n-        boolean isNextValidXmlNcNameCharacter();\n-\n-        /**\n-         * Determine if the next character on the sream is the supplied value. This method does <i>not</i> advance the stream.\n-         *\n-         * @param c the character value to compare to the next character on the stream\n-         * @return true if there is a {@link #next() next} character and it is the supplied character, or false otherwise\n-         */\n-        boolean isNext(char c);\n-\n-        /**\n-         * Determine if the next two characters on the stream match the supplied values. This method does <i>not</i> advance the\n-         * stream.\n-         *\n-         * @param nextChar the character value to compare to the next character on the stream\n-         * @param followingChar the character value to compare to the character immediately after the next character on the stream\n-         * @return true if there are at least two characters left on the stream and the first matches <code>nextChar</code> and\n-         *         the second matches <code>followingChar</code>\n-         */\n-        boolean isNext(char nextChar,\n-                       char followingChar);\n-\n-        /**\n-         * Determine if the next three characters on the sream match the supplied values. This method does <i>not</i> advance the\n-         * stream.\n-         *\n-         * @param nextChar the character value to compare to the next character on the stream\n-         * @param nextChar2 the character value to compare to the second character on the stream\n-         * @param nextChar3 the character value to compare to the second character on the stream\n-         * @return true if there are at least two characters left on the stream and the first matches <code>nextChar</code> and\n-         *         the second matches <code>followingChar</code>\n-         */\n-        boolean isNext(char nextChar,\n-                       char nextChar2,\n-                       char nextChar3);\n-\n-        /**\n-         * Determine if the next character on the stream matches one of the supplied characters. This method does <i>not</i>\n-         * advance the stream.\n-         *\n-         * @param characters the characters to match\n-         * @return true if there is a {@link #next() next} character and it does match one of the supplied characters, or false\n-         *         otherwise\n-         */\n-        boolean isNextAnyOf(char[] characters);\n-\n-        /**\n-         * Determine if the next character on the stream matches one of the supplied characters. This method does <i>not</i>\n-         * advance the stream.\n-         *\n-         * @param characters the characters to match\n-         * @return true if there is a {@link #next() next} character and it does match one of the supplied characters, or false\n-         *         otherwise\n-         */\n-        boolean isNextAnyOf(String characters);\n-\n-    }\n-\n-    /**\n-     * A factory for Token objects, used by a {@link Tokenizer} to create tokens in the correct order.\n-     */\n-    public static interface Tokens {\n-        /**\n-         * Create a single-character token at the supplied index in the character stream. The token type is set to 0, meaning this\n-         * is equivalent to calling <code>addToken(index,index+1)</code> or <code>addToken(index,index+1,0)</code>.\n-         *\n-         * @param position the position (line and column numbers) of this new token; may not be null\n-         * @param index the index of the character to appear in the token; must be a valid index in the stream\n-         */\n-        default void addToken(Position position,\n-                              int index) {\n-            addToken(position, index, index + 1, 0);\n-        }\n-\n-        /**\n-         * Create a single- or multi-character token with the characters in the range given by the starting and ending index in\n-         * the character stream. The character at the ending index is <i>not</i> included in the token (as this is standard\n-         * practice when using 0-based indexes). The token type is set to 0, meaning this is equivalent to calling <code>\n-         * addToken(startIndex,endIndex,0)</code> .\n-         *\n-         * @param position the position (line and column numbers) of this new token; may not be null\n-         * @param startIndex the index of the first character to appear in the token; must be a valid index in the stream\n-         * @param endIndex the index just past the last character to appear in the token; must be a valid index in the stream\n-         */\n-        default void addToken(Position position,\n-                              int startIndex,\n-                              int endIndex) {\n-            addToken(position, startIndex, endIndex, 0);\n-        }\n-\n-        /**\n-         * Create a single- or multi-character token with the supplied type and with the characters in the range given by the\n-         * starting and ending index in the character stream. The character at the ending index is <i>not</i> included in the\n-         * token (as this is standard practice when using 0-based indexes).\n-         *\n-         * @param position the position (line and column numbers) of this new token; may not be null\n-         * @param startIndex the index of the first character to appear in the token; must be a valid index in the stream\n-         * @param endIndex the index just past the last character to appear in the token; must be a valid index in the stream\n-         * @param type the type of the token\n-         */\n-        void addToken(Position position,\n-                      int startIndex,\n-                      int endIndex,\n-                      int type);\n-    }\n-\n-    /**\n-     * The interface defining a token, which references the characters in the actual input character stream.\n-     *\n-     * @see CaseSensitiveTokenFactory\n-     * @see CaseInsensitiveTokenFactory\n-     */\n-    @Immutable\n-    public interface Token {\n-        /**\n-         * Get the value of the token, in actual case.\n-         *\n-         * @return the value\n-         */\n-        String value();\n-\n-        /**\n-         * Determine if the token matches the supplied string.\n-         *\n-         * @param expected the expected value\n-         * @return true if the token's value matches the supplied value, or false otherwise\n-         */\n-        boolean matches(String expected);\n-\n-        /**\n-         * Determine if the token matches the supplied string and is of a requested type.\n-         *\n-         * @param expectedType the expected token type\n-         * @param expected the expected value\n-         * @return true if the token's type and value matches the supplied type and value, or false otherwise\n-         */\n-        default boolean matches(int expectedType, String expected) {\n-            return matches(expectedType) && matches(expected);\n-        }\n-\n-        /**\n-         * Determine if the token matches the supplied character.\n-         *\n-         * @param expected the expected character value\n-         * @return true if the token's value matches the supplied character value, or false otherwise\n-         */\n-        boolean matches(char expected);\n-\n-        /**\n-         * Determine if the token matches the supplied type.\n-         *\n-         * @param expectedType the expected integer type\n-         * @return true if the token's value matches the supplied integer type, or false otherwise\n-         */\n-        boolean matches(int expectedType);\n-\n-        /**\n-         * Get the type of the token.\n-         *\n-         * @return the token's type\n-         */\n-        int type();\n-\n-        /**\n-         * Get the index in the raw stream for the first character in the token.\n-         *\n-         * @return the starting index of the token\n-         */\n-        int startIndex();\n-\n-        /**\n-         * Get the index in the raw stream past the last character in the token.\n-         *\n-         * @return the ending index of the token, which is past the last character\n-         */\n-        int endIndex();\n-\n-        /**\n-         * Get the length of the token, which is equivalent to <code>endIndex() - startIndex()</code>.\n-         *\n-         * @return the length\n-         */\n-        int length();\n-\n-        /**\n-         * Get the position of this token, which includes the line number and column number of the first character in the token.\n-         *\n-         * @return the position; never null\n-         */\n-        Position position();\n-\n-        /**\n-         * Bitmask ORed with existing type value.\n-         *\n-         * @param typeMask the mask of types\n-         * @return copy of Token with new type\n-         */\n-        Token withType(int typeMask);\n-    }\n-\n-    /**\n-     * An immutable {@link Token} that implements matching using case-sensitive logic.\n-     */\n-    @Immutable\n-    protected class CaseSensitiveToken implements Token {\n-        private final int startIndex;\n-        private final int endIndex;\n-        private final int type;\n-        private final Position position;\n-\n-        public CaseSensitiveToken(int startIndex,\n-                                  int endIndex,\n-                                  int type,\n-                                  Position position) {\n-            this.startIndex = startIndex;\n-            this.endIndex = endIndex;\n-            this.type = type;\n-            this.position = position;\n-        }\n-\n-        @Override\n-        public Token withType(int typeMask) {\n-            int type = this.type | typeMask;\n-            return new CaseSensitiveToken(startIndex, endIndex, type, position);\n-        }\n-\n-        @Override\n-        public final int type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public final int startIndex() {\n-            return startIndex;\n-        }\n-\n-        @Override\n-        public final int endIndex() {\n-            return endIndex;\n-        }\n-\n-        @Override\n-        public final int length() {\n-            return endIndex - startIndex;\n-        }\n-\n-        @Override\n-        public final boolean matches(char expected) {\n-            return length() == 1 && matchString().charAt(startIndex) == expected;\n-        }\n-\n-        @Override\n-        public boolean matches(String expected) {\n-            return matchString().substring(startIndex, endIndex).equals(expected);\n-        }\n-\n-        @Override\n-        public final boolean matches(int expectedType) {\n-            return expectedType == ANY_TYPE || (currentToken().type() & expectedType) == expectedType;\n-        }\n-\n-        @Override\n-        public final String value() {\n-            return inputString.substring(startIndex, endIndex);\n-        }\n-\n-        @Override\n-        public Position position() {\n-            return position;\n-        }\n-\n-        protected String matchString() {\n-            return inputString;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return value();\n-        }\n-    }\n-\n-    @Immutable\n-    protected class CaseInsensitiveToken extends CaseSensitiveToken {\n-        public CaseInsensitiveToken(int startIndex,\n-                                    int endIndex,\n-                                    int type,\n-                                    Position position) {\n-            super(startIndex, endIndex, type, position);\n-        }\n-\n-        @Override\n-        public boolean matches(String expected) {\n-            return matchString().substring(startIndex(), endIndex()).toUpperCase().equals(expected);\n-        }\n-\n-        @Override\n-        public Token withType(int typeMask) {\n-            int type = this.type() | typeMask;\n-            return new CaseInsensitiveToken(startIndex(), endIndex(), type, position());\n-        }\n-    }\n-\n-    protected abstract class TokenFactory implements Tokens {\n-        protected final List<Token> tokens = new ArrayList<Token>();\n-\n-        public List<Token> getTokens() {\n-            return tokens;\n-        }\n-    }\n-\n-    public class CaseSensitiveTokenFactory extends TokenFactory {\n-        @Override\n-        public void addToken(Position position,\n-                             int startIndex,\n-                             int endIndex,\n-                             int type) {\n-            tokens.add(new CaseSensitiveToken(startIndex, endIndex, type, position));\n-        }\n-    }\n-\n-    public class CaseInsensitiveTokenFactory extends TokenFactory {\n-        @Override\n-        public void addToken(Position position,\n-                             int startIndex,\n-                             int endIndex,\n-                             int type) {\n-            tokens.add(new CaseInsensitiveToken(startIndex, endIndex, type, position));\n-        }\n-    }\n-\n-    /**\n-     * An implementation of {@link CharacterStream} that works with a single character array.\n-     */\n-    public static final class CharacterArrayStream implements CharacterStream {\n-        private final char[] content;\n-        private int lastIndex = -1;\n-        private final int maxIndex;\n-        private int lineNumber = 1;\n-        private int columnNumber = 0;\n-        private boolean nextCharMayBeLineFeed;\n-\n-        public CharacterArrayStream(char[] content) {\n-            this.content = content;\n-            this.maxIndex = content.length - 1;\n-        }\n-\n-        @Override\n-        public boolean hasNext() {\n-            return lastIndex < maxIndex;\n-        }\n-\n-        @Override\n-        public int index() {\n-            return lastIndex;\n-        }\n-\n-        @Override\n-        public Position position(int startIndex) {\n-            return new Position(startIndex, lineNumber, columnNumber);\n-        }\n-\n-        @Override\n-        public String substring(int startIndex, int endIndex) {\n-            return new String(content, startIndex, endIndex - startIndex);\n-        }\n-\n-        @Override\n-        public char next() {\n-            if (lastIndex >= maxIndex) {\n-                throw new NoSuchElementException();\n-            }\n-            char result = content[++lastIndex];\n-            ++columnNumber;\n-            if (result == '\\r') {\n-                nextCharMayBeLineFeed = true;\n-                ++lineNumber;\n-                columnNumber = 0;\n-            }\n-            else if (result == '\\n') {\n-                if (!nextCharMayBeLineFeed) {\n-                    ++lineNumber;\n-                }\n-                columnNumber = 0;\n-            }\n-            else if (nextCharMayBeLineFeed) {\n-                nextCharMayBeLineFeed = false;\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public boolean isNext(char c) {\n-            int nextIndex = lastIndex + 1;\n-            return nextIndex <= maxIndex && content[nextIndex] == c;\n-        }\n-\n-        @Override\n-        public boolean isNext(char nextChar1,\n-                              char nextChar2) {\n-            int nextIndex1 = lastIndex + 1;\n-            int nextIndex2 = lastIndex + 2;\n-            return nextIndex2 <= maxIndex && content[nextIndex1] == nextChar1 && content[nextIndex2] == nextChar2;\n-        }\n-\n-        @Override\n-        public boolean isNext(char nextChar1,\n-                              char nextChar2,\n-                              char nextChar3) {\n-            int nextIndex1 = lastIndex + 1;\n-            int nextIndex2 = lastIndex + 2;\n-            int nextIndex3 = lastIndex + 3;\n-            return nextIndex3 <= maxIndex && content[nextIndex1] == nextChar1 && content[nextIndex2] == nextChar2\n-                    && content[nextIndex3] == nextChar3;\n-        }\n-\n-        @Override\n-        public boolean isNextAnyOf(char[] characters) {\n-            int nextIndex = lastIndex + 1;\n-            if (nextIndex <= maxIndex) {\n-                char nextChar = content[lastIndex + 1];\n-                for (char c : characters) {\n-                    if (c == nextChar) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean isNextAnyOf(String characters) {\n-            int nextIndex = lastIndex + 1;\n-            if (nextIndex <= maxIndex) {\n-                char nextChar = content[lastIndex + 1];\n-                if (characters.indexOf(nextChar) != -1) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean isNextWhitespace() {\n-            int nextIndex = lastIndex + 1;\n-            return nextIndex <= maxIndex && Character.isWhitespace(content[nextIndex]);\n-        }\n-\n-        @Override\n-        public boolean isNextLetterOrDigit() {\n-            int nextIndex = lastIndex + 1;\n-            return nextIndex <= maxIndex && Character.isLetterOrDigit(content[nextIndex]);\n-        }\n-\n-        @Override\n-        public boolean isNextValidXmlCharacter() {\n-            int nextIndex = lastIndex + 1;\n-            return nextIndex <= maxIndex && XmlCharacters.isValid(content[nextIndex]);\n-        }\n-\n-        @Override\n-        public boolean isNextValidXmlNameCharacter() {\n-            int nextIndex = lastIndex + 1;\n-            return nextIndex <= maxIndex && XmlCharacters.isValidName(content[nextIndex]);\n-        }\n-\n-        @Override\n-        public boolean isNextValidXmlNcNameCharacter() {\n-            int nextIndex = lastIndex + 1;\n-            return nextIndex <= maxIndex && XmlCharacters.isValidNcName(content[nextIndex]);\n-        }\n-    }\n-\n-    /**\n-     * Obtain a basic {@link Tokenizer} implementation that ignores whitespace but includes tokens for individual symbols, the\n-     * period ('.'), single-quoted strings, double-quoted strings, whitespace-delimited words, and optionally comments.\n-     * <p>\n-     * Note that the resulting Tokenizer may not be appropriate in many situations, but is provided merely as a convenience for\n-     * those situations that happen to be able to use it.\n-     * </p>\n-     *\n-     * @param includeComments true if the comments should be retained and be included in the token stream, or false if comments\n-     *            should be stripped and not included in the token stream\n-     * @return the tokenizer; never null\n-     */\n-    public static BasicTokenizer basicTokenizer(boolean includeComments) {\n-        return new BasicTokenizer(includeComments);\n-    }\n-\n-    /**\n-     * A basic {@link Tokenizer} implementation that ignores whitespace but includes tokens for individual symbols, the period\n-     * ('.'), single-quoted strings, double-quoted strings, whitespace-delimited words, and optionally comments.\n-     * <p>\n-     * Note this Tokenizer may not be appropriate in many situations, but is provided merely as a convenience for those situations\n-     * that happen to be able to use it.\n-     * </p>\n-     */\n-    public static class BasicTokenizer implements Tokenizer {\n-        /**\n-         * The {@link Token#type() token type} for tokens that represent an unquoted string containing a character sequence made\n-         * up of non-whitespace and non-symbol characters.\n-         */\n-        public static final int WORD = 1;\n-        /**\n-         * The {@link Token#type() token type} for tokens that consist of an individual \"symbol\" character. The set of characters\n-         * includes: <code>-(){}*,;+%?$[]!<>|=:</code>\n-         */\n-        public static final int SYMBOL = 2;\n-        /**\n-         * The {@link Token#type() token type} for tokens that consist of an individual '.' character.\n-         */\n-        public static final int DECIMAL = 4;\n-        /**\n-         * The {@link Token#type() token type} for tokens that consist of all the characters within single-quotes. Single quote\n-         * characters are included if they are preceded (escaped) by a '\\' character.\n-         */\n-        public static final int SINGLE_QUOTED_STRING = 8;\n-        /**\n-         * The {@link Token#type() token type} for tokens that consist of all the characters within double-quotes. Double quote\n-         * characters are included if they are preceded (escaped) by a '\\' character.\n-         */\n-        public static final int DOUBLE_QUOTED_STRING = 16;\n-        /**\n-         * The {@link Token#type() token type} for tokens that consist of all the characters between \"/*\" and \"&#42;/\" or between\n-         * \"//\" and the next line terminator (e.g., '\\n', '\\r' or \"\\r\\n\").\n-         */\n-        public static final int COMMENT = 32;\n-\n-        private final boolean useComments;\n-\n-        protected BasicTokenizer(boolean useComments) {\n-            this.useComments = useComments;\n-        }\n-\n-        @Override\n-        public void tokenize(CharacterStream input,\n-                             Tokens tokens)\n-                throws ParsingException {\n-            while (input.hasNext()) {\n-                char c = input.next();\n-                switch (c) {\n-                    case ' ':\n-                    case '\\t':\n-                    case '\\n':\n-                    case '\\r':\n-                        // Just skip these whitespace characters ...\n-                        break;\n-                    case '-':\n-                    case '(':\n-                    case ')':\n-                    case '{':\n-                    case '}':\n-                    case '*':\n-                    case ',':\n-                    case ';':\n-                    case '+':\n-                    case '%':\n-                    case '?':\n-                    case '$':\n-                    case '[':\n-                    case ']':\n-                    case '!':\n-                    case '<':\n-                    case '>':\n-                    case '|':\n-                    case '=':\n-                    case ':':\n-                        tokens.addToken(input.position(input.index()), input.index(), input.index() + 1, SYMBOL);\n-                        break;\n-                    case '.':\n-                        tokens.addToken(input.position(input.index()), input.index(), input.index() + 1, DECIMAL);\n-                        break;\n-                    case '\\\"':\n-                        int startIndex = input.index();\n-                        Position startingPosition = input.position(startIndex);\n-                        boolean foundClosingQuote = false;\n-                        while (input.hasNext()) {\n-                            c = input.next();\n-                            if (c == '\\\\' && input.isNext('\"')) {\n-                                c = input.next(); // consume the \" character since it is escaped \\\"\n-                            }\n-                            else if (c == '\"' && input.isNext('\"')) {\n-                                c = input.next(); // consume the \" character since it is escaped \"\"\n-                            }\n-                            else if (c == '\"') {\n-                                foundClosingQuote = true;\n-                                break;\n-                            }\n-                        }\n-                        if (!foundClosingQuote) {\n-                            String msg = \"No matching double quote found at line \" + startingPosition.line() + \", column \"\n-                                    + startingPosition.column();\n-                            throw new ParsingException(startingPosition, msg);\n-                        }\n-                        int endIndex = input.index() + 1; // beyond last character read\n-                        tokens.addToken(startingPosition, startIndex, endIndex, DOUBLE_QUOTED_STRING);\n-                        break;\n-                    case '\\'':\n-                        startIndex = input.index();\n-                        startingPosition = input.position(startIndex);\n-                        foundClosingQuote = false;\n-                        while (input.hasNext()) {\n-                            c = input.next();\n-                            if (c == '\\\\' && input.isNext('\\'')) {\n-                                c = input.next(); // consume the ' character since it is escaped \\'\n-                            }\n-                            else if (c == '\\'' && input.isNext('\\'')) {\n-                                c = input.next(); // consume the ' character since it is escaped ''\n-                            }\n-                            else if (c == '\\'') {\n-                                foundClosingQuote = true;\n-                                break;\n-                            }\n-                        }\n-                        if (!foundClosingQuote) {\n-                            String msg = \"No matching single quote found at line \" + startingPosition.line() + \", column \"\n-                                    + startingPosition.column();\n-                            throw new ParsingException(startingPosition, msg);\n-                        }\n-                        endIndex = input.index() + 1; // beyond last character read\n-                        tokens.addToken(startingPosition, startIndex, endIndex, SINGLE_QUOTED_STRING);\n-                        break;\n-                    case '/':\n-                        startIndex = input.index();\n-                        startingPosition = input.position(startIndex);\n-                        if (input.isNext('/')) {\n-                            // End-of-line comment ...\n-                            boolean foundLineTerminator = false;\n-                            while (input.hasNext()) {\n-                                c = input.next();\n-                                if (c == '\\n' || c == '\\r') {\n-                                    foundLineTerminator = true;\n-                                    break;\n-                                }\n-                            }\n-                            endIndex = input.index(); // the token won't include the '\\n' or '\\r' character(s)\n-                            if (!foundLineTerminator) {\n-                                ++endIndex; // must point beyond last char\n-                            }\n-                            if (c == '\\r' && input.isNext('\\n')) {\n-                                input.next();\n-                            }\n-                            if (useComments) {\n-                                tokens.addToken(startingPosition, startIndex, endIndex, COMMENT);\n-                            }\n-                        }\n-                        else if (input.isNext('*')) {\n-                            // Multi-line comment ...\n-                            while (input.hasNext() && !input.isNext('*', '/')) {\n-                                c = input.next();\n-                            }\n-                            if (input.hasNext()) {\n-                                input.next(); // consume the '*'\n-                            }\n-                            if (input.hasNext()) {\n-                                input.next(); // consume the '/'\n-                            }\n-                            if (useComments) {\n-                                endIndex = input.index() + 1; // the token will include the '/' and '*' characters\n-                                tokens.addToken(startingPosition, startIndex, endIndex, COMMENT);\n-                            }\n-                        }\n-                        else {\n-                            // just a regular slash ...\n-                            tokens.addToken(startingPosition, startIndex, startIndex + 1, SYMBOL);\n-                        }\n-                        break;\n-                    default:\n-                        startIndex = input.index();\n-                        startingPosition = input.position(startIndex);\n-                        // Read until another whitespace/symbol/decimal/slash is found\n-                        while (input.hasNext() && !(input.isNextWhitespace() || input.isNextAnyOf(\"/.-(){}*,;+%?$[]!<>|=:\"))) {\n-                            c = input.next();\n-                        }\n-                        endIndex = input.index() + 1; // beyond last character that was included\n-                        tokens.addToken(startingPosition, startIndex, endIndex, WORD);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * @return a string to be parsed\n-     */\n-    public String getInputString() {\n-        return inputString;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1ODA3Mg==", "url": "https://github.com/debezium/debezium/pull/2022#discussion_r546558072", "bodyText": "How about moving the affected tests to the MySQL connector module then, so we could get rid of the Legacy parser impl altogether?", "author": "gunnarmorling", "createdAt": "2020-12-21T07:56:28Z", "path": "debezium-core/src/test/java/io/debezium/relational/history/KafkaDatabaseHistoryTest.java", "diffHunk": "@@ -29,11 +29,11 @@\n import io.debezium.doc.FixFor;\n import io.debezium.kafka.KafkaCluster;\n import io.debezium.relational.Tables;\n-import io.debezium.relational.ddl.DdlParserSql2003;\n-import io.debezium.relational.ddl.LegacyDdlParser;\n import io.debezium.text.ParsingException;\n import io.debezium.util.Collect;\n import io.debezium.util.Testing;\n+import io.debezium.util.parser.DdlParserSql2003;\n+import io.debezium.util.parser.LegacyDdlParser;", "originalCommit": "64bdb03d74055a7ebb9f0d849aff9cc18f5130c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYxOTk5Nw==", "url": "https://github.com/debezium/debezium/pull/2022#discussion_r546619997", "bodyText": "@gunnarmorling Done. I am not sure if it is structurally clean but as a pragmatic solution it works.", "author": "jpechane", "createdAt": "2020-12-21T10:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1ODA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYyOTQzNg==", "url": "https://github.com/debezium/debezium/pull/2022#discussion_r546629436", "bodyText": "Yes, it's a bit of a blurry line. But maintaining a whole parser impl only for testing seems like too much of an overhead to me. I think it's the better approach now.", "author": "gunnarmorling", "createdAt": "2020-12-21T10:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1ODA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e59fa6f7071621d24f35a5b3b5dac9da3270dfa0", "chunk": "diff --git a/debezium-core/src/test/java/io/debezium/relational/history/KafkaDatabaseHistoryTest.java b/debezium-connector-mysql/src/test/java/io/debezium/relational/history/KafkaDatabaseHistoryTest.java\nsimilarity index 98%\nrename from debezium-core/src/test/java/io/debezium/relational/history/KafkaDatabaseHistoryTest.java\nrename to debezium-connector-mysql/src/test/java/io/debezium/relational/history/KafkaDatabaseHistoryTest.java\nindex e9a155ed1..768a55f4d 100644\n--- a/debezium-core/src/test/java/io/debezium/relational/history/KafkaDatabaseHistoryTest.java\n+++ b/debezium-connector-mysql/src/test/java/io/debezium/relational/history/KafkaDatabaseHistoryTest.java\n\n@@ -26,14 +26,14 @@\n import org.junit.Test;\n \n import io.debezium.config.Configuration;\n+import io.debezium.connector.mysql.antlr.MySqlAntlrDdlParser;\n import io.debezium.doc.FixFor;\n import io.debezium.kafka.KafkaCluster;\n import io.debezium.relational.Tables;\n+import io.debezium.relational.ddl.DdlParser;\n import io.debezium.text.ParsingException;\n import io.debezium.util.Collect;\n import io.debezium.util.Testing;\n-import io.debezium.util.parser.DdlParserSql2003;\n-import io.debezium.util.parser.LegacyDdlParser;\n \n /**\n  * @author Randall Hauch\n"}}, {"oid": "e59fa6f7071621d24f35a5b3b5dac9da3270dfa0", "url": "https://github.com/debezium/debezium/commit/e59fa6f7071621d24f35a5b3b5dac9da3270dfa0", "message": "DBZ-2167 Remove legacy parser completely; tests depending on parser move to MySQL", "committedDate": "2020-12-21T10:11:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYyODc5Mw==", "url": "https://github.com/debezium/debezium/pull/2022#discussion_r546628793", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    record(23, 1, \"CREATE TABLE\\nnperson ( name VARCHAR(22) NOT NULL );\", all, t3, t2, t1);\n          \n          \n            \n                    record(23, 1, \"CREATE TABLE\\nperson ( name VARCHAR(22) NOT NULL );\", all, t3, t2, t1);\n          \n      \n    \n    \n  \n\nOne \"n\" too much?", "author": "gunnarmorling", "createdAt": "2020-12-21T10:31:08Z", "path": "debezium-connector-mysql/src/test/java/io/debezium/relational/history/AbstractDatabaseHistoryTest.java", "diffHunk": "@@ -94,8 +94,8 @@ protected Tables recover(long pos, int entry) {\n     @Test\n     public void shouldRecordChangesAndRecoverToVariousPoints() {\n         record(01, 0, \"CREATE TABLE foo ( first VARCHAR(22) NOT NULL );\", all, t3, t2, t1, t0);\n-        record(23, 1, \"CREATE TABLE\\\\nperson ( name VARCHAR(22) NOT NULL );\", all, t3, t2, t1);\n-        record(30, 2, \"CREATE TABLE address\\\\n( street VARCHAR(22) NOT NULL );\", all, t3, t2);\n+        record(23, 1, \"CREATE TABLE\\nnperson ( name VARCHAR(22) NOT NULL );\", all, t3, t2, t1);", "originalCommit": "e59fa6f7071621d24f35a5b3b5dac9da3270dfa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzMzU5OA==", "url": "https://github.com/debezium/debezium/pull/2022#discussion_r546633598", "bodyText": "ns are for free so I probably wanted to be generous with them before Christmas ;-)", "author": "jpechane", "createdAt": "2020-12-21T10:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYyODc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzNjU5Ng==", "url": "https://github.com/debezium/debezium/pull/2022#discussion_r546636596", "bodyText": "LOL :)", "author": "gunnarmorling", "createdAt": "2020-12-21T10:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYyODc5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2150e9ad66e7ca73b41bee05287cf3c33315755f", "chunk": "diff --git a/debezium-connector-mysql/src/test/java/io/debezium/relational/history/AbstractDatabaseHistoryTest.java b/debezium-connector-mysql/src/test/java/io/debezium/relational/history/AbstractDatabaseHistoryTest.java\nindex 0adf1c773..acc113580 100644\n--- a/debezium-connector-mysql/src/test/java/io/debezium/relational/history/AbstractDatabaseHistoryTest.java\n+++ b/debezium-connector-mysql/src/test/java/io/debezium/relational/history/AbstractDatabaseHistoryTest.java\n\n@@ -94,7 +94,7 @@ protected Tables recover(long pos, int entry) {\n     @Test\n     public void shouldRecordChangesAndRecoverToVariousPoints() {\n         record(01, 0, \"CREATE TABLE foo ( first VARCHAR(22) NOT NULL );\", all, t3, t2, t1, t0);\n-        record(23, 1, \"CREATE TABLE\\nnperson ( name VARCHAR(22) NOT NULL );\", all, t3, t2, t1);\n+        record(23, 1, \"CREATE TABLE\\nperson ( name VARCHAR(22) NOT NULL );\", all, t3, t2, t1);\n         record(30, 2, \"CREATE TABLE address\\n( street VARCHAR(22) NOT NULL );\", all, t3, t2);\n         record(32, 3, \"ALTER TABLE address ADD city VARCHAR(22) NOT NULL;\", all, t3);\n \n"}}, {"oid": "2150e9ad66e7ca73b41bee05287cf3c33315755f", "url": "https://github.com/debezium/debezium/commit/2150e9ad66e7ca73b41bee05287cf3c33315755f", "message": "DBZ-2167 Remove superfluous char\n\nCo-authored-by: Gunnar Morling <gunnar.morling@googlemail.com>", "committedDate": "2020-12-21T10:40:45Z", "type": "commit"}]}