{"pr_number": 7835, "pr_title": "IGNITE-13012 Make node connection checking rely on the configuration. Simplify node ping routine.", "pr_createdAt": "2020-05-22T10:08:23Z", "pr_url": "https://github.com/apache/ignite/pull/7835", "timeline": [{"oid": "3b668562077ada39800f8010bf28bc084218b462", "url": "https://github.com/apache/ignite/commit/3b668562077ada39800f8010bf28bc084218b462", "message": "IGNITE-13021 : First impl.", "committedDate": "2020-05-22T09:53:22Z", "type": "commit"}, {"oid": "675c069ef7efbb85c03ed072fe4d497194d04d27", "url": "https://github.com/apache/ignite/commit/675c069ef7efbb85c03ed072fe4d497194d04d27", "message": "IGNITE-13012 : merged with master. Minor fixes.", "committedDate": "2020-05-22T14:56:12Z", "type": "commit"}, {"oid": "e4ddf057eb49db983c57a22461b0f8644afaa422", "url": "https://github.com/apache/ignite/commit/e4ddf057eb49db983c57a22461b0f8644afaa422", "message": "IGNITE-13012 : merged with master. Minor fixes.", "committedDate": "2020-05-25T08:23:03Z", "type": "commit"}, {"oid": "bf93ac157526169db0d1cac1bdb19905d472fdab", "url": "https://github.com/apache/ignite/commit/bf93ac157526169db0d1cac1bdb19905d472fdab", "message": "IGNITE-13012 : halt timeouts on the ping.", "committedDate": "2020-05-25T11:29:29Z", "type": "commit"}, {"oid": "e729270020ab8274d32f922596be716f1829d028", "url": "https://github.com/apache/ignite/commit/e729270020ab8274d32f922596be716f1829d028", "message": "Merge remote-tracking branch 'origin/IGNITE-13012' into IGNITE-13012\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "committedDate": "2020-05-25T11:29:55Z", "type": "commit"}, {"oid": "47a9f7dfaa08052a64a4a229743eef0c4628fad8", "url": "https://github.com/apache/ignite/commit/47a9f7dfaa08052a64a4a229743eef0c4628fad8", "message": "IGNITE-13012 : +test.", "committedDate": "2020-05-25T16:24:18Z", "type": "commit"}, {"oid": "2c929faf829c3243b4b511e0fb13ce867a83642e", "url": "https://github.com/apache/ignite/commit/2c929faf829c3243b4b511e0fb13ce867a83642e", "message": "IGNITE-13012 : redeem of the timeouts. Fixed test.", "committedDate": "2020-05-25T17:38:09Z", "type": "commit"}, {"oid": "245943a154e0e8cd083ad90a552ce69cf4b989f6", "url": "https://github.com/apache/ignite/commit/245943a154e0e8cd083ad90a552ce69cf4b989f6", "message": "IGNITE-13012 : redeem of the timeouts. Fixed test.", "committedDate": "2020-05-25T17:46:11Z", "type": "commit"}, {"oid": "f7d58aea09f78dec4f99080f70b472da50b3796f", "url": "https://github.com/apache/ignite/commit/f7d58aea09f78dec4f99080f70b472da50b3796f", "message": "Merge branch 'master' into IGNITE-13012", "committedDate": "2020-05-26T15:43:07Z", "type": "commit"}, {"oid": "8f4dabf5a0bdab538fc9aaa37383880772b80cac", "url": "https://github.com/apache/ignite/commit/8f4dabf5a0bdab538fc9aaa37383880772b80cac", "message": "IGNITE-13012 : Fixed tests. + a test.", "committedDate": "2020-05-27T10:25:23Z", "type": "commit"}, {"oid": "62f5d6a2b67ff97a94d08f19c9d4ff4dfff4a3ed", "url": "https://github.com/apache/ignite/commit/62f5d6a2b67ff97a94d08f19c9d4ff4dfff4a3ed", "message": "IGNITE-13012 : fix of coordinator failure test.", "committedDate": "2020-05-27T14:13:48Z", "type": "commit"}, {"oid": "dc2375627a678008cef6256546af8b333135c941", "url": "https://github.com/apache/ignite/commit/dc2375627a678008cef6256546af8b333135c941", "message": "IGNITE-13012 : test fix", "committedDate": "2020-05-28T07:51:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMTA5NQ==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433121095", "bodyText": "Do we need a method with a single usage?\nWill it be more suitable to inline it?", "author": "anton-vinogradov", "createdAt": "2020-06-01T09:01:42Z", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -1916,6 +1924,12 @@ private void clearNodeAddedMessage(TcpDiscoveryAbstractMessage msg) {\n         return threads;\n     }\n \n+    /** @return Total timeout on complete message exchange in network over established connection. */\n+    protected long effectiveExchangeTimeout() {", "originalCommit": "dc2375627a678008cef6256546af8b333135c941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIxOTUyNg==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433219526", "bodyText": "Removed.", "author": "Vladsz83", "createdAt": "2020-06-01T13:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMTA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "708934305864f86b40d35a54d71d59c43a248cc5", "chunk": "diff --git a/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java b/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java\nindex b86e71bec5..f4416ea9d7 100644\n--- a/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java\n+++ b/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java\n\n@@ -1924,12 +1929,6 @@ class ServerImpl extends TcpDiscoveryImpl {\n         return threads;\n     }\n \n-    /** @return Total timeout on complete message exchange in network over established connection. */\n-    protected long effectiveExchangeTimeout() {\n-        return spi.failureDetectionTimeoutEnabled() ? spi.failureDetectionTimeout() :\n-            spi.getSocketTimeout() + spi.getAckTimeout();\n-    }\n-\n     /** {@inheritDoc} */\n     @Override public void updateMetrics(UUID nodeId,\n         ClusterMetrics metrics,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNzcyOA==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433137728", "bodyText": "magic number?", "author": "anton-vinogradov", "createdAt": "2020-06-01T09:40:50Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/GridFailFastNodeFailureDetectionSelfTest.java", "diffHunk": "@@ -107,7 +107,7 @@ public void testFailFast() throws Exception {\n \n         failNode(ignite1);\n \n-        assert failLatch.await(1500, MILLISECONDS);\n+        assert failLatch.await(ignite1.configuration().getFailureDetectionTimeout() + 50, MILLISECONDS);", "originalCommit": "dc2375627a678008cef6256546af8b333135c941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIyMDIyMw==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433220223", "bodyText": "We always can be hit by GC pause, timer granulation, delays in other code. Not giving additional time to wait can lead to flaky tests. Makes sense?", "author": "Vladsz83", "createdAt": "2020-06-01T13:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNzcyOA=="}], "type": "inlineReview", "revised_code": {"commit": "708934305864f86b40d35a54d71d59c43a248cc5", "chunk": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/GridFailFastNodeFailureDetectionSelfTest.java b/modules/core/src/test/java/org/apache/ignite/internal/GridFailFastNodeFailureDetectionSelfTest.java\nindex 00d508fdf9..73cb5f7011 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/GridFailFastNodeFailureDetectionSelfTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/GridFailFastNodeFailureDetectionSelfTest.java\n\n@@ -107,7 +107,7 @@ public class GridFailFastNodeFailureDetectionSelfTest extends GridCommonAbstract\n \n         failNode(ignite1);\n \n-        assert failLatch.await(ignite1.configuration().getFailureDetectionTimeout() + 50, MILLISECONDS);\n+        assert failLatch.await(1500, MILLISECONDS);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDQ2Ng==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433154466", "bodyText": "We should wait FDT - (cutTime - lastMesssentTime) here, not full FDT.\n\n\nThis code will fail if we wait for 0.8 of FDT in the first case and 0.1 in the second, but everything will be fine in general.\nIt seems you should wait for the rest of the timeout at the first case, but for the rest of the rest it at second.", "author": "anton-vinogradov", "createdAt": "2020-06-01T10:21:01Z", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -3611,15 +3602,26 @@ else if (!spi.failureDetectionTimeoutEnabled() && (e instanceof\n                                 if (latencyCheck && log.isInfoEnabled())\n                                     log.info(\"Latency check message has been written to socket: \" + msg.id());\n \n+                                boolean ping = msg instanceof TcpDiscoveryConnectionCheckMessage;\n+\n+                                long timeout = timeoutHelper.nextTimeoutChunk(spi.getSocketTimeout());\n+\n+                                // For the ping we take half of actual failure detection. Another half is the interval.\n                                 spi.writeToSocket(newNextNode ? newNext : next,\n                                     sock,\n                                     out,\n                                     msg,\n-                                    timeoutHelper.nextTimeoutChunk(spi.getSocketTimeout()));\n+                                    ping && spi.failureDetectionTimeoutEnabled() ? timeout / 2 : timeout\n+                                );\n+\n+                                timeout = timeoutHelper.nextTimeoutChunk(ackTimeout0);\n \n                                 long tsNanos0 = System.nanoTime();\n \n-                                int res = spi.readReceipt(sock, timeoutHelper.nextTimeoutChunk(ackTimeout0));\n+                                int res = spi.readReceipt(sock, ping && spi.failureDetectionTimeoutEnabled() ?\n+                                    timeout / 2 : timeout);\n+\n+                                updateLastSentMessageTime();", "originalCommit": "dc2375627a678008cef6256546af8b333135c941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI0Nzk3NQ==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433247975", "bodyText": "This would require us to check connection often. Like connCheckInterval = spi.failureDetectionTimeout() / 4.. Otherwise we can leave too short timeout to any message if it is being sent just before next ping: quite long time passed since the last message. Is it OK?\n\n\nDidn't catch you. We do wait for rest of the rest in second case:\n\n\ntimeout = timeoutHelper.nextTimeoutChunk(ackTimeout0); - this is rest of the rest. Makes sense?", "author": "Vladsz83", "createdAt": "2020-06-01T13:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDQ2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "708934305864f86b40d35a54d71d59c43a248cc5", "chunk": "diff --git a/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java b/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java\nindex b86e71bec5..f4416ea9d7 100644\n--- a/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java\n+++ b/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java\n\n@@ -3602,24 +3606,15 @@ class ServerImpl extends TcpDiscoveryImpl {\n                                 if (latencyCheck && log.isInfoEnabled())\n                                     log.info(\"Latency check message has been written to socket: \" + msg.id());\n \n-                                boolean ping = msg instanceof TcpDiscoveryConnectionCheckMessage;\n-\n-                                long timeout = timeoutHelper.nextTimeoutChunk(spi.getSocketTimeout());\n-\n-                                // For the ping we take half of actual failure detection. Another half is the interval.\n                                 spi.writeToSocket(newNextNode ? newNext : next,\n                                     sock,\n                                     out,\n                                     msg,\n-                                    ping && spi.failureDetectionTimeoutEnabled() ? timeout / 2 : timeout\n-                                );\n-\n-                                timeout = timeoutHelper.nextTimeoutChunk(ackTimeout0);\n+                                    timeoutHelper.nextTimeoutChunk(spi.getSocketTimeout()));\n \n                                 long tsNanos0 = System.nanoTime();\n \n-                                int res = spi.readReceipt(sock, ping && spi.failureDetectionTimeoutEnabled() ?\n-                                    timeout / 2 : timeout);\n+                                int res = spi.readReceipt(sock, timeoutHelper.nextTimeoutChunk(ackTimeout0));\n \n                                 updateLastSentMessageTime();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MTUwMw==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433171503", "bodyText": "what the reason to set sent time here?", "author": "anton-vinogradov", "createdAt": "2020-06-01T11:03:11Z", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -3469,6 +3456,8 @@ else if (log.isTraceEnabled())\n                                         }\n                                     }\n \n+                                    updateLastSentMessageTime();", "originalCommit": "dc2375627a678008cef6256546af8b333135c941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIyODE1OA==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433228158", "bodyText": "We\u2019ve just initialized successful connection to next node. We just sent TcpDiscoveryHandshakeRequest message. This means: this connection is definitely ok and should not be checked right now. Also, we just sent a message. We rely on the time of last message sent and we fixate it here. Looks correct to me.", "author": "Vladsz83", "createdAt": "2020-06-01T13:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MTUwMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MTU0Ng==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433171546", "bodyText": "what the reason to set sent time here?", "author": "anton-vinogradov", "createdAt": "2020-06-01T11:03:17Z", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -3574,6 +3563,8 @@ else if (!spi.failureDetectionTimeoutEnabled() && (e instanceof\n \n                                     int res = spi.readReceipt(sock, timeoutHelper.nextTimeoutChunk(ackTimeout0));\n \n+                                    updateLastSentMessageTime();", "originalCommit": "dc2375627a678008cef6256546af8b333135c941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIyOTU1NQ==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433229555", "bodyText": "We just sent one or several pending messages. Every message can take time, also every message checks connection. We rely on the time of last sent message. We should fixate this time when do really send message. We do it in this part of code too.", "author": "Vladsz83", "createdAt": "2020-06-01T13:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MTU0Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzE4Mg==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433173182", "bodyText": "why changed?", "author": "anton-vinogradov", "createdAt": "2020-06-01T11:07:07Z", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoveryImpl.java", "diffHunk": "@@ -303,7 +303,7 @@ public int boundPort() throws IgniteSpiException {\n     /**\n      * @return connection check interval.\n      */\n-    public long connectionCheckInterval() {\n+    long connectionCheckInterval() {", "originalCommit": "dc2375627a678008cef6256546af8b333135c941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIzMTE0OA==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433231148", "bodyText": "To increase encapsulation once we touched it. Internal usages inly, not an interface.", "author": "Vladsz83", "createdAt": "2020-06-01T13:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE2MjUyNg==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r444162526", "bodyText": "We shouldn't reduce visibility of methods in public API. It is highly unlikely of course that there are users calling this method directly but concealing of method is definitely a breaking change. We could target it to 3.0 version but in minor releases it is not acceptable.", "author": "sergey-chugunov-1985", "createdAt": "2020-06-23T11:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE3MTUwMA==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r444171500", "bodyText": "We shouldn't reduce visibility of methods in public API. It is highly unlikely of course that there are users calling this method directly but concealing of method is definitely a breaking change. We could target it to 3.0 version but in minor releases it is not acceptable.\n\nFixed.", "author": "Vladsz83", "createdAt": "2020-06-23T12:05:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzE4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "71435c2c9bebd50ba06a9acdf33a4a42ab064c1f", "chunk": "diff --git a/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoveryImpl.java b/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoveryImpl.java\nindex b4a71c387f..7f80610846 100644\n--- a/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoveryImpl.java\n+++ b/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoveryImpl.java\n\n@@ -303,7 +303,7 @@ abstract class TcpDiscoveryImpl {\n     /**\n      * @return connection check interval.\n      */\n-    long connectionCheckInterval() {\n+    public long connectionCheckInterval() {\n         return 0;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzM5MQ==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433173391", "bodyText": "magic number", "author": "anton-vinogradov", "createdAt": "2020-06-01T11:07:34Z", "path": "modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/ConnectionCheckTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+import java.util.concurrent.Exchanger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.util.GridTestClockTimer;\n+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryAbstractMessage;\n+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryConnectionCheckMessage;\n+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryNodeFailedMessage;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static com.sun.tools.javac.util.Assert.check;\n+\n+/**\n+ * Checks pinging next node in the ring relies on configured timeouts.\n+ */\n+public class ConnectionCheckTest extends GridCommonAbstractTest {\n+    /** Number of the ping messages to ensure node pinging works well. */\n+    private static final int PING_MESSAGES_CNT_TO_ENSURE = 15;\n+\n+    /** Timer granulation in milliseconds. See {@link GridTestClockTimer}. */\n+    private static final int TIMER_GRANULATION = 10;\n+\n+    /**\n+     * Maximal additional delay before sending the ping message including timer granulation in and other delays\n+     * like code delays and/or GC.\n+     */\n+    private static final int ACCEPTABLE_ADDITIONAL_DELAY = TIMER_GRANULATION + 50;", "originalCommit": "dc2375627a678008cef6256546af8b333135c941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIyNDg1Mg==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433224852", "bodyText": "magic number\n\nThere is a comment: \"Maximal additional delay before sending the ping message including timer granulation in and other delays like code delays and/or GC\"\nWe always can be hit by GC pause, timer granulation, delays in other code. Not giving additional time to wait can lead to flaky tests. Makes sense?", "author": "Vladsz83", "createdAt": "2020-06-01T13:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzM5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "708934305864f86b40d35a54d71d59c43a248cc5", "chunk": "diff --git a/modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/ConnectionCheckTest.java b/modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/ConnectionCheckTest.java\ndeleted file mode 100644\nindex 69cc55da4c..0000000000\n--- a/modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/ConnectionCheckTest.java\n+++ /dev/null\n\n@@ -1,310 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.ignite.spi.discovery.tcp;\n-\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.net.Socket;\n-import java.util.concurrent.Exchanger;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicReference;\n-import org.apache.ignite.IgniteCheckedException;\n-import org.apache.ignite.configuration.IgniteConfiguration;\n-import org.apache.ignite.internal.util.GridTestClockTimer;\n-import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryAbstractMessage;\n-import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryConnectionCheckMessage;\n-import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryNodeFailedMessage;\n-import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n-import org.junit.Test;\n-\n-import static com.sun.tools.javac.util.Assert.check;\n-\n-/**\n- * Checks pinging next node in the ring relies on configured timeouts.\n- */\n-public class ConnectionCheckTest extends GridCommonAbstractTest {\n-    /** Number of the ping messages to ensure node pinging works well. */\n-    private static final int PING_MESSAGES_CNT_TO_ENSURE = 15;\n-\n-    /** Timer granulation in milliseconds. See {@link GridTestClockTimer}. */\n-    private static final int TIMER_GRANULATION = 10;\n-\n-    /**\n-     * Maximal additional delay before sending the ping message including timer granulation in and other delays\n-     * like code delays and/or GC.\n-     */\n-    private static final int ACCEPTABLE_ADDITIONAL_DELAY = TIMER_GRANULATION + 50;\n-\n-    /** Metric message period. Quite long by default to prevent other but ping discovery messages. */\n-    private long metricsUpdateFreq = 60 * 60 * 1000;\n-\n-    /** */\n-    private long failureDetectionTimeout = 500;\n-\n-    /** Checks TcpDiscoveryConnectionCheckMessage is send depending on failure detection timeout. */\n-    @Test\n-    public void testWithFailureDetectionTimeout() throws Exception {\n-        for (long failureDetectionTimeout = 300; failureDetectionTimeout <= 600; failureDetectionTimeout += 100) {\n-            this.failureDetectionTimeout = failureDetectionTimeout;\n-\n-            IgniteConfiguration cfg = getConfiguration(getTestIgniteInstanceName(1));\n-\n-            launchConnectionCheckingTest(cfg);\n-        }\n-    }\n-\n-    /** Checks TcpDiscoveryConnectionCheckMessage is send depending on socket and acknowledgement timeouts. */\n-    @Test\n-    public void testWithSocketAndAckTimeouts() throws Exception {\n-        for (long sockTimeout = 300; sockTimeout <= 500; sockTimeout += 100) {\n-            for (long ackTimeout = 300; ackTimeout <= 500; ackTimeout += 100) {\n-                IgniteConfiguration cfg = getConfiguration(getTestIgniteInstanceName(1));\n-\n-                ((TcpDiscoverySpi)cfg.getDiscoverySpi()).setSocketTimeout(sockTimeout);\n-\n-                ((TcpDiscoverySpi)cfg.getDiscoverySpi()).setAckTimeout(sockTimeout);\n-\n-                ((TcpDiscoverySpi)cfg.getDiscoverySpi()).setReconnectCount(1);\n-\n-                launchConnectionCheckingTest(cfg);\n-            }\n-        }\n-    }\n-\n-    /** Checks other than TcpDiscoveryConnectionCheckMessage message detects node failure. */\n-    @Test\n-    public void testNodeFailureWithoutPing() throws Exception {\n-        // Set metrics frequency more often than failure detection timeout.\n-        failureDetectionTimeout = 5_000;\n-\n-        metricsUpdateFreq = 300;\n-\n-        Exchanger<String> errHolder = new Exchanger<>();\n-\n-        IgniteConfiguration cfg = getConfiguration(getTestIgniteInstanceName(0));\n-\n-        cfg.setDiscoverySpi(new TcpDiscoverySpi() {\n-            /** {@inheritDoc} */\n-            @Override protected void writeToSocket(Socket sock, OutputStream out, TcpDiscoveryAbstractMessage msg,\n-                long timeout) throws IOException, IgniteCheckedException {\n-                super.writeToSocket(sock, out, msg, timeout);\n-\n-                // Connection check message must not appear because of frequent metrics update message.\n-                if (msg instanceof TcpDiscoveryConnectionCheckMessage) {\n-                    try {\n-                        errHolder.exchange(msg.getClass().getSimpleName() + \" must not appear in the message traffic.\");\n-                    }\n-                    catch (InterruptedException e) {\n-                        // No-op.\n-                    }\n-                }\n-\n-                // Stop test once failed node detected.\n-                if (msg instanceof TcpDiscoveryNodeFailedMessage) {\n-                    TcpDiscoveryNodeFailedMessage nodeFailedMsg = (TcpDiscoveryNodeFailedMessage)msg;\n-\n-                    try {\n-                        // We simulate failure of node 2.\n-                        errHolder.exchange(nodeFailedMsg.internalOrder() == 2 ? null :\n-                            \"Wrong order of failed node: \" + nodeFailedMsg.internalOrder() + \". Expected: 2\");\n-                    }\n-                    catch (InterruptedException e) {\n-                        // No-op.\n-                    }\n-                }\n-            }\n-        });\n-\n-        startGrid(cfg);\n-\n-        startGrid(1);\n-\n-        startGrid(2);\n-\n-        // Let cluster breathe.\n-        Thread.sleep(2000);\n-\n-        // Simulate failure of the second node.\n-        TcpDiscoverySpi disco1 = (TcpDiscoverySpi)grid(1).configuration().getDiscoverySpi();\n-\n-        disco1.simulateNodeFailure();\n-\n-        String err = errHolder.exchange(null);\n-\n-        check(err == null, err);\n-    }\n-\n-    /** */\n-    private void launchConnectionCheckingTest(IgniteConfiguration cfg) throws Exception {\n-        startGrid(0);\n-\n-        Exchanger<String> errHolder = new Exchanger<>();\n-\n-        AtomicBoolean beginFlag = new AtomicBoolean();\n-\n-        TcpDiscoverySpi prevSpi = (TcpDiscoverySpi)cfg.getDiscoverySpi();\n-\n-        TcpDiscoverySpi spi = tcpDiscoverySpi(errHolder, beginFlag);\n-\n-        spi.setIpFinder(LOCAL_IP_FINDER);\n-\n-        cfg.setDiscoverySpi(spi);\n-\n-        if (!prevSpi.failureDetectionTimeoutEnabled()) {\n-            spi.setReconnectCount(prevSpi.getReconnectCount());\n-\n-            spi.setSocketTimeout(prevSpi.getSocketTimeout());\n-\n-            spi.setAckTimeout(prevSpi.getAckTimeout());\n-        }\n-\n-        startGrid(cfg);\n-\n-        // Let cluster breathe.\n-        Thread.sleep(2000);\n-\n-        beginFlag.set(true);\n-\n-        String errMsg = errHolder.exchange(null);\n-\n-        check(errMsg == null, errMsg);\n-\n-        stopAllGrids(true);\n-    }\n-\n-    /**\n-     * @return Testing TCP discovery monitoring the message traffic.\n-     */\n-    private TcpDiscoverySpi tcpDiscoverySpi(Exchanger<String> errHolder, AtomicBoolean beginFlag) {\n-        return new TcpDiscoverySpi() {\n-            /** Last sent message. */\n-            private final AtomicReference<TcpDiscoveryAbstractMessage> lastMsg = new AtomicReference<>();\n-\n-            /** Time of the last sent message. */\n-            private long lastSentMsgTime;\n-\n-            /** Cycles counter. */\n-            private long cycles;\n-\n-            /** Stop flag. */\n-            private boolean stop;\n-\n-            /** {@inheritDoc} */\n-            @Override protected void writeToSocket(Socket sock, OutputStream out, TcpDiscoveryAbstractMessage msg,\n-                long timeout) throws IOException, IgniteCheckedException {\n-                super.writeToSocket(sock, out, msg, timeout);\n-\n-                if (!beginFlag.get())\n-                    return;\n-\n-                TcpDiscoveryAbstractMessage prevMsg = lastMsg.getAndSet(msg);\n-\n-                if (msg instanceof TcpDiscoveryConnectionCheckMessage) {\n-                    synchronized (lastMsg) {\n-                        if (!stop && prevMsg instanceof TcpDiscoveryConnectionCheckMessage) {\n-                            long period = System.currentTimeMillis() - lastSentMsgTime;\n-\n-                            lastSentMsgTime = System.currentTimeMillis();\n-\n-                            long msgExchangeTimeout = failureDetectionTimeoutEnabled() ? failureDetectionTimeout() :\n-                                getSocketTimeout() + getAckTimeout();\n-\n-                            if (period > msgExchangeTimeout / 2 + ACCEPTABLE_ADDITIONAL_DELAY ||\n-                                period < msgExchangeTimeout / 2 - TIMER_GRANULATION) {\n-                                stop(\"Invalid interval of sending TcpDiscoveryConnectionCheckMessage: \" + period +\n-                                    \"ms. Expected value is near \" + msgExchangeTimeout / 2 + \"ms, half of message \" +\n-                                    \"exchange timeout (\" + msgExchangeTimeout + \"ms).\");\n-                            }\n-                            else if (failureDetectionTimeoutEnabled() &&\n-                                timeout > msgExchangeTimeout / 2 + TIMER_GRANULATION) {\n-                                stop(\"Invalid timeout on sending TcpDiscoveryConnectionCheckMessage: \" + timeout +\n-                                    \"ms. Expected value is near \" + failureDetectionTimeout() / 2 + \"ms, half of \" +\n-                                    \"IgniteConfiguration.failureDetectionTimeout (\" + msgExchangeTimeout + \"ms).\");\n-                            }\n-                            else if (++cycles == PING_MESSAGES_CNT_TO_ENSURE)\n-                                stop(null);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override protected int readReceipt(Socket sock, long timeout) throws IOException {\n-                int res = super.readReceipt(sock, timeout);\n-\n-                if (!beginFlag.get())\n-                    return res;\n-\n-                synchronized (lastMsg) {\n-                    lastSentMsgTime = System.currentTimeMillis();\n-\n-                    if ((lastMsg.get() instanceof TcpDiscoveryConnectionCheckMessage) &&\n-                        failureDetectionTimeoutEnabled() &&\n-                        timeout > failureDetectionTimeout() / 2 + TIMER_GRANULATION) {\n-                        stop(\"Invalid timeout set on reading acknowledgement for TcpDiscoveryConnectionCheckMessage: \" +\n-                            timeout + \"ms. Expected value is up to \" + failureDetectionTimeout() / 2 + \"ms, half of \" +\n-                            \"IgniteConfiguration.failureDetectionTimeout (\" + failureDetectionTimeout() + \"ms).\");\n-                    }\n-                }\n-\n-                return res;\n-            }\n-\n-            /** Stops watching messages and notifies the exchanger. */\n-            private void stop(String errMsg) {\n-                stop = true;\n-\n-                try {\n-                    errHolder.exchange(errMsg);\n-                }\n-                catch (InterruptedException e) {\n-                    // No-op.\n-                }\n-            }\n-        };\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n-        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n-\n-        cfg.setSystemWorkerBlockedTimeout(20_000);\n-\n-        cfg.setMetricsUpdateFrequency(metricsUpdateFreq);\n-\n-        cfg.setFailureDetectionTimeout(failureDetectionTimeout);\n-\n-        cfg.setClientFailureDetectionTimeout(cfg.getMetricsUpdateFrequency());\n-\n-        ((TcpDiscoverySpi)cfg.getDiscoverySpi()).setIpFinder(LOCAL_IP_FINDER);\n-\n-        return cfg;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override protected void afterTest() throws Exception {\n-        super.afterTest();\n-\n-        stopAllGrids(true);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override protected long getTestTimeout() {\n-        return 3 * 60 * 1000;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzQ0Nw==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433173447", "bodyText": "magic number?", "author": "anton-vinogradov", "createdAt": "2020-06-01T11:07:46Z", "path": "modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java", "diffHunk": "@@ -1976,7 +1976,8 @@ private void checkFailedCoordinatorNode(SegmentationPolicy segPlc) throws Except\n \n             ignite1.configuration().getDiscoverySpi().failNode(coordId, null);\n \n-            assertTrue(failedLatch.await(2000, MILLISECONDS));\n+            // Wait for the configured timeout + other possible code delays.\n+            assertTrue(failedLatch.await(ignite1.configuration().getFailureDetectionTimeout() + 50, MILLISECONDS));", "originalCommit": "dc2375627a678008cef6256546af8b333135c941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIyNTIxMw==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433225213", "bodyText": "Same here.\nThere is a comment: \"Wait for the configured timeout + other possible code delays.\"\nWe always can be hit by GC pause, timer granulation, delays in other code. Not giving additional time to wait can lead to flaky tests. Makes sense?", "author": "Vladsz83", "createdAt": "2020-06-01T13:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzQ0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "708934305864f86b40d35a54d71d59c43a248cc5", "chunk": "diff --git a/modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java b/modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java\nindex c4bc8aa0b2..16fd75115a 100644\n--- a/modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java\n\n@@ -1976,8 +1976,7 @@ public class TcpDiscoverySelfTest extends GridCommonAbstractTest {\n \n             ignite1.configuration().getDiscoverySpi().failNode(coordId, null);\n \n-            // Wait for the configured timeout + other possible code delays.\n-            assertTrue(failedLatch.await(ignite1.configuration().getFailureDetectionTimeout() + 50, MILLISECONDS));\n+            assertTrue(failedLatch.await(2000, MILLISECONDS));\n \n             assertTrue(coordSegmented.get());\n \n"}}, {"oid": "708934305864f86b40d35a54d71d59c43a248cc5", "url": "https://github.com/apache/ignite/commit/708934305864f86b40d35a54d71d59c43a248cc5", "message": "IGNITE-13012 : Reverted tests. Failure detection timeout is shared with\nprevious message.", "committedDate": "2020-06-02T09:46:43Z", "type": "commit"}, {"oid": "3515f40a973c3fb542af32154a626b1d61e92d8e", "url": "https://github.com/apache/ignite/commit/3515f40a973c3fb542af32154a626b1d61e92d8e", "message": "IGNITE-13012 : fix.", "committedDate": "2020-06-02T10:18:25Z", "type": "commit"}, {"oid": "9dca4f19e4c0a06972fd249d22fb15953d1cb21c", "url": "https://github.com/apache/ignite/commit/9dca4f19e4c0a06972fd249d22fb15953d1cb21c", "message": "IGNITE-13012 : + test.", "committedDate": "2020-06-03T10:01:37Z", "type": "commit"}, {"oid": "bd00c208bb41836b0d5ef08fdcb6565e517f94eb", "url": "https://github.com/apache/ignite/commit/bd00c208bb41836b0d5ef08fdcb6565e517f94eb", "message": "IGNITE-13012 : + test fix.", "committedDate": "2020-06-03T15:07:44Z", "type": "commit"}, {"oid": "c4647253ac8e76f9f2f9c39f51f150b101c05917", "url": "https://github.com/apache/ignite/commit/c4647253ac8e76f9f2f9c39f51f150b101c05917", "message": "IGNITE-13012 : +10ms as the timer granulation.", "committedDate": "2020-06-04T08:50:02Z", "type": "commit"}, {"oid": "5370831f07938f4b54cd8ec8dcd012d9d58242d5", "url": "https://github.com/apache/ignite/commit/5370831f07938f4b54cd8ec8dcd012d9d58242d5", "message": "IGNITE-13012 : test fixes.", "committedDate": "2020-06-04T10:34:41Z", "type": "commit"}, {"oid": "a9ad35e89369cc452f2955e19377d4c250523637", "url": "https://github.com/apache/ignite/commit/a9ad35e89369cc452f2955e19377d4c250523637", "message": "IGNITE-13012 : + 10ms as acceptable code delay.", "committedDate": "2020-06-04T15:15:22Z", "type": "commit"}, {"oid": "a8fad436597bfc36d538f8e6897dc6f5ec0a037a", "url": "https://github.com/apache/ignite/commit/a8fad436597bfc36d538f8e6897dc6f5ec0a037a", "message": "IGNITE-13012 : test redeemed.", "committedDate": "2020-06-05T07:17:08Z", "type": "commit"}, {"oid": "45c426fcd0e63144924c819eadf830ad90392595", "url": "https://github.com/apache/ignite/commit/45c426fcd0e63144924c819eadf830ad90392595", "message": "IGNITE-13016 : faster test.", "committedDate": "2020-06-05T12:07:33Z", "type": "commit"}, {"oid": "0d58fe44f892978025bedd323d1394e4ee826f8c", "url": "https://github.com/apache/ignite/commit/0d58fe44f892978025bedd323d1394e4ee826f8c", "message": "Revert \"IGNITE-13134 : test duration fix.", "committedDate": "2020-06-08T22:20:21Z", "type": "commit"}, {"oid": "7f7a6082f889c34a588f6d3f07a20612dd723dcc", "url": "https://github.com/apache/ignite/commit/7f7a6082f889c34a588f6d3f07a20612dd723dcc", "message": "IGNITE-13012 : faster test.", "committedDate": "2020-06-09T07:07:25Z", "type": "commit"}, {"oid": "dde7e7cafb15365b133c133415b54e8a24ae039b", "url": "https://github.com/apache/ignite/commit/dde7e7cafb15365b133c133415b54e8a24ae039b", "message": "IGNITE-13012 : minority.", "committedDate": "2020-06-09T07:10:13Z", "type": "commit"}, {"oid": "7b40043b97ab210ea2781b70f08be424f100e65f", "url": "https://github.com/apache/ignite/commit/7b40043b97ab210ea2781b70f08be424f100e65f", "message": "Merge branch 'master' into IGNITE-13012", "committedDate": "2020-06-09T07:10:39Z", "type": "commit"}, {"oid": "e1b9735e692e1ff9ff88b2b5c983f9383317726d", "url": "https://github.com/apache/ignite/commit/e1b9735e692e1ff9ff88b2b5c983f9383317726d", "message": "IGNITE-13012 : spelling fix.", "committedDate": "2020-06-15T13:51:49Z", "type": "commit"}, {"oid": "1b07dd53e3c313e407f892b2b3fe7681f44a2ca4", "url": "https://github.com/apache/ignite/commit/1b07dd53e3c313e407f892b2b3fe7681f44a2ca4", "message": "IGNITE-13012 : empty lines.", "committedDate": "2020-06-15T13:54:04Z", "type": "commit"}, {"oid": "a4be00090b35127a537b1959dee4cca2f0ba5732", "url": "https://github.com/apache/ignite/commit/a4be00090b35127a537b1959dee4cca2f0ba5732", "message": "IGNITE-13012 :renaming.", "committedDate": "2020-06-15T14:37:54Z", "type": "commit"}, {"oid": "d9c3108fd15e34c0d9ccc59eedfe41f1b3d256b4", "url": "https://github.com/apache/ignite/commit/d9c3108fd15e34c0d9ccc59eedfe41f1b3d256b4", "message": "IGNITE-13012 :renamings. Removes test.", "committedDate": "2020-06-15T14:38:57Z", "type": "commit"}, {"oid": "71435c2c9bebd50ba06a9acdf33a4a42ab064c1f", "url": "https://github.com/apache/ignite/commit/71435c2c9bebd50ba06a9acdf33a4a42ab064c1f", "message": "reverted removal of 'public'", "committedDate": "2020-06-23T12:04:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4MzkwMA==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r444183900", "bodyText": "Why not to call updateLastSentMessageTime method here as well?", "author": "sergey-chugunov-1985", "createdAt": "2020-06-23T12:27:56Z", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -6192,40 +6188,21 @@ private void checkMetricsReceiving() {\n         }\n \n         /**\n-         * Check connection aliveness status.\n+         * Check connection to next node in the ring.\n          */\n         private void checkConnection() {\n             Boolean hasRemoteSrvNodes = null;\n \n-            if (spi.failureDetectionTimeoutEnabled() && !failureThresholdReached &&\n-                U.millisSinceNanos(locNode.lastExchangeTimeNanos()) >= connCheckThreshold &&\n-                spiStateCopy() == CONNECTED &&\n-                (hasRemoteSrvNodes = ring.hasRemoteServerNodes())) {\n-\n-                if (log.isInfoEnabled())\n-                    log.info(\"Local node seems to be disconnected from topology (failure detection timeout \" +\n-                        \"is reached) [failureDetectionTimeout=\" + spi.failureDetectionTimeout() +\n-                        \", connCheckInterval=\" + CON_CHECK_INTERVAL + ']');\n-\n-                failureThresholdReached = true;\n-\n-                // Reset sent time deliberately to force sending connection check message.\n-                lastTimeConnCheckMsgSent = 0;\n-            }\n-\n-            long elapsed = (lastTimeConnCheckMsgSent + CON_CHECK_INTERVAL) - U.currentTimeMillis();\n+            long elapsed = (lastRingMsgSentTime + U.millisToNanos(connCheckInterval)) - System.nanoTime();\n \n             if (elapsed > 0)\n                 return;\n \n             if (hasRemoteSrvNodes == null)\n                 hasRemoteSrvNodes = ring.hasRemoteServerNodes();\n \n-            if (hasRemoteSrvNodes) {\n+            if (hasRemoteSrvNodes)", "originalCommit": "d9c3108fd15e34c0d9ccc59eedfe41f1b3d256b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4OTAwMg==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r444189002", "bodyText": "Why not to call updateLastSentMessageTime method here as well?\n\nWe hasn't successfully sent message here, we hasn't received RES_OK.", "author": "Vladsz83", "createdAt": "2020-06-23T12:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4MzkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE5MjMyNQ==", "url": "https://github.com/apache/ignite/pull/7835#discussion_r444192325", "bodyText": "As you can see, we call updateLastSentMessageTime() after successful reading spi.readReceipt or proper TcpDiscoveryHandshakeResponse. These are the places where we are sure the message was sent and connection is OK.", "author": "Vladsz83", "createdAt": "2020-06-23T12:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4MzkwMA=="}], "type": "inlineReview", "revised_code": {"commit": "322242a42206004bf73a8dfa9583329eba87b918", "chunk": "diff --git a/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java b/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java\nindex 78f3a5dcde..3fa8939690 100644\n--- a/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java\n+++ b/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java\n\n@@ -6191,17 +6191,12 @@ class ServerImpl extends TcpDiscoveryImpl {\n          * Check connection to next node in the ring.\n          */\n         private void checkConnection() {\n-            Boolean hasRemoteSrvNodes = null;\n-\n             long elapsed = (lastRingMsgSentTime + U.millisToNanos(connCheckInterval)) - System.nanoTime();\n \n             if (elapsed > 0)\n                 return;\n \n-            if (hasRemoteSrvNodes == null)\n-                hasRemoteSrvNodes = ring.hasRemoteServerNodes();\n-\n-            if (hasRemoteSrvNodes)\n+            if (ring.hasRemoteServerNodes())\n                 sendMessageAcrossRing(new TcpDiscoveryConnectionCheckMessage(locNode));\n         }\n \n"}}, {"oid": "322242a42206004bf73a8dfa9583329eba87b918", "url": "https://github.com/apache/ignite/commit/322242a42206004bf73a8dfa9583329eba87b918", "message": "IGNITE-13012 : removed redundant hasRemoteSrvNodes", "committedDate": "2020-06-23T13:12:04Z", "type": "commit"}, {"oid": "be6e2ed4e22a4cb6b3135f873c030ab2536c6398", "url": "https://github.com/apache/ignite/commit/be6e2ed4e22a4cb6b3135f873c030ab2536c6398", "message": "Merge branch 'master' into IGNITE-13012", "committedDate": "2020-06-23T14:03:28Z", "type": "commit"}]}