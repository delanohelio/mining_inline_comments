{"pr_number": 7461, "pr_title": "IGNITE-12710 Extension log in rebuild indexes to search problems.", "pr_createdAt": "2020-02-20T21:47:31Z", "pr_url": "https://github.com/apache/ignite/pull/7461", "timeline": [{"oid": "04d2a79157058bbc36d9d9ff24a7ddef95dff34a", "url": "https://github.com/apache/ignite/commit/04d2a79157058bbc36d9d9ff24a7ddef95dff34a", "message": "IGNITE-12710 Extension log in rebuild indexes to search problems.", "committedDate": "2020-02-20T21:46:55Z", "type": "commit"}, {"oid": "05da1511f529e282ad26eaa1571134ef94328526", "url": "https://github.com/apache/ignite/commit/05da1511f529e282ad26eaa1571134ef94328526", "message": "IGNITE-12710 Fix codestyle.", "committedDate": "2020-02-20T21:57:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ0MDY4NQ==", "url": "https://github.com/apache/ignite/pull/7461#discussion_r382440685", "bodyText": "Before the change we were waiting complete compound future, now we can skip it. It looks strange.", "author": "ygerzhedovich", "createdAt": "2020-02-21T07:56:18Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/SchemaIndexCacheVisitorImpl.java", "diffHunk": "@@ -157,8 +171,55 @@ public SchemaIndexCacheVisitorImpl(GridCacheContext cctx, SchemaIndexCacheFilter\n             throw e;\n         }\n \n-        if (fut != null)\n-            fut.get();\n+        if (fut != null && stat != null) {", "originalCommit": "05da1511f529e282ad26eaa1571134ef94328526", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b5aa697d8dbe440b8ddb56c04311b882480510c4", "chunk": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/SchemaIndexCacheVisitorImpl.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/SchemaIndexCacheVisitorImpl.java\nindex 5ccb4f7e41..337ae15efa 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/SchemaIndexCacheVisitorImpl.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/SchemaIndexCacheVisitorImpl.java\n\n@@ -77,417 +46,98 @@ public class SchemaIndexCacheVisitorImpl implements SchemaIndexCacheVisitor {\n     /** Cancellation token. */\n     private final SchemaIndexOperationCancellationToken cancel;\n \n-    /** Parallelism. */\n-    private final int parallelism;\n-\n-    /** Whether to stop the process. */\n-    private volatile boolean stop;\n-\n-    /** Count of partitions to be processed. */\n-    private final AtomicInteger partsCnt = new AtomicInteger();\n+    /** Future for create/rebuild index. */\n+    protected final GridFutureAdapter<Void> buildIdxFut;\n \n     /** Logger. */\n     protected IgniteLogger log;\n \n-    static {\n-        int parallelism = IgniteSystemProperties.getInteger(INDEX_REBUILDING_PARALLELISM, 0);\n-\n-        // Parallelism lvl is bounded to range of [1, CPUs count]\n-        if (parallelism > 0)\n-            DFLT_INDEX_REBUILDING_PARALLELISM = Math.min(parallelism, Runtime.getRuntime().availableProcessors());\n-        else\n-            DFLT_INDEX_REBUILDING_PARALLELISM = Math.min(4, Math.max(1, Runtime.getRuntime().availableProcessors() / 4));\n-    }\n-\n-    /**\n-     * Constructor.\n-     *  @param cctx Cache context.\n-     */\n-    public SchemaIndexCacheVisitorImpl(GridCacheContext cctx) {\n-        this(cctx, null, null, 0);\n-    }\n-\n     /**\n      * Constructor.\n      *\n      * @param cctx Cache context.\n      * @param rowFilter Row filter.\n      * @param cancel Cancellation token.\n-     * @param parallelism Degree of parallelism.\n+     * @param buildIdxFut Future for create/rebuild index.\n      */\n-    public SchemaIndexCacheVisitorImpl(GridCacheContext cctx, SchemaIndexCacheFilter rowFilter,\n-        SchemaIndexOperationCancellationToken cancel, int parallelism) {\n-        this.rowFilter = rowFilter;\n-        this.cancel = cancel;\n-\n-        // Parallelism lvl is bounded to range of [1, CPUs count]\n-        if (parallelism > 0)\n-            this.parallelism = Math.min(Runtime.getRuntime().availableProcessors(), parallelism);\n-        else\n-            this.parallelism = DFLT_INDEX_REBUILDING_PARALLELISM;\n+    public SchemaIndexCacheVisitorImpl(\n+        GridCacheContext cctx,\n+        @Nullable SchemaIndexCacheFilter rowFilter,\n+        @Nullable SchemaIndexOperationCancellationToken cancel,\n+        GridFutureAdapter<Void> buildIdxFut\n+    ) {\n+        assert nonNull(cctx);\n+        assert nonNull(buildIdxFut);\n \n         if (cctx.isNear())\n             cctx = ((GridNearCacheAdapter)cctx.cache()).dht().context();\n \n         this.cctx = cctx;\n+        this.buildIdxFut = buildIdxFut;\n+\n+        this.cancel = cancel;\n+        this.rowFilter = rowFilter;\n \n         log = cctx.kernalContext().log(getClass());\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void visit(SchemaIndexCacheVisitorClosure clo) throws IgniteCheckedException {\n-        assert clo != null;\n-\n-        List<GridDhtLocalPartition> parts = cctx.topology().localPartitions();\n-\n-        if (parts.isEmpty())\n-            return;\n-\n-        partsCnt.set(parts.size());\n-\n-        GridCompoundFuture<SchemaIndexCacheStat, SchemaIndexCacheStat> fut = null;\n-\n-        if (parallelism > 1) {\n-            fut = new GridCompoundFuture<>(new SchemaIndexCacheStatFutureReducer());\n-\n-            for (int i = 1; i < parallelism; i++)\n-                fut.add(processPartitionsAsync(parts, clo, i));\n-\n-            fut.markInitialized();\n-        }\n-\n-        final SchemaIndexCacheStat stat;\n-\n-        try {\n-            stat = processPartitions(parts, clo, 0);\n-        }\n-        catch (Throwable e) {\n-            U.error(log, \"Error during parallel index create/rebuild.\", e);\n+    @Override public void visit(SchemaIndexCacheVisitorClosure clo) {\n+        assert nonNull(clo);\n \n-            stop = true;\n+        List<GridDhtLocalPartition> locParts = cctx.topology().localPartitions();\n \n-            resetPartitionsCount();\n+        if (locParts.isEmpty()) {\n+            buildIdxFut.onDone();\n \n-            throw e;\n-        }\n-\n-        if (fut != null && stat != null) {\n-            final SchemaIndexCacheStat st = fut.get();\n-\n-            stat.scanned += st.scanned;\n-            stat.types.putAll(st.types);\n-        }\n-\n-        printIndexStats(stat);\n-    }\n-\n-    /**\n-     * Prints index cache stats to log.\n-     *\n-     * @param stat Index cache stats.\n-     * @throws IgniteCheckedException if failed to get index size.\n-     */\n-    private void printIndexStats(@Nullable SchemaIndexCacheStat stat) throws IgniteCheckedException {\n-        if (stat == null)\n             return;\n-\n-        SB res = new SB();\n-\n-        res.a(\"Details for cache rebuilding [name=\" + cctx.cache().name() + \", grpName=\" + cctx.group().name() + ']');\n-        res.a(U.nl());\n-        res.a(\"   Scanned rows \" + stat.scanned + \", visited types \" + stat.types.keySet());\n-        res.a(U.nl());\n-\n-        final GridQueryIndexing idx = cctx.kernalContext().query().getIndexing();\n-\n-        for (QueryTypeDescriptorImpl type : stat.types.values()) {\n-            res.a(\"        Type name=\" + type.name());\n-            res.a(U.nl());\n-\n-            final String pk = \"_key_PK\";\n-\n-            res.a(\"            Index: name=\" + pk + \", size=\" + idx.indexSize(type.schemaName(), pk));\n-            res.a(U.nl());\n-\n-            final Map<String, GridQueryIndexDescriptor> indexes = type.indexes();\n-\n-            for (GridQueryIndexDescriptor descriptor : indexes.values()) {\n-                final long size = idx.indexSize(type.schemaName(), descriptor.name());\n-\n-                res.a(\"            Index: name=\" + descriptor.name() + \", size=\" + size);\n-                res.a(U.nl());\n-            }\n         }\n \n-        log.info(res.toString());\n-    }\n+        cctx.group().metrics().addIndexBuildCountPartitionsLeft(locParts.size());\n \n-    /**\n-     * Process partitions asynchronously.\n-     *\n-     * @param parts Partitions.\n-     * @param clo Closure.\n-     * @param remainder Remainder.\n-     * @return Future.\n-     */\n-    private GridFutureAdapter<SchemaIndexCacheStat> processPartitionsAsync(List<GridDhtLocalPartition> parts,\n-        SchemaIndexCacheVisitorClosure clo, int remainder) {\n-        GridFutureAdapter<SchemaIndexCacheStat> fut = new GridFutureAdapter<>();\n+        beforeExecute();\n \n-        AsyncWorker worker = new AsyncWorker(parts, clo, remainder, fut);\n+        AtomicInteger partsCnt = new AtomicInteger(locParts.size());\n \n-        new IgniteThread(worker).start();\n+        AtomicBoolean stop = new AtomicBoolean();\n \n-        return fut;\n-    }\n+        GridCompoundFuture<Void, Void> buildIdxCompoundFut = new GridCompoundFuture<>();\n \n-    /**\n-     * Process partitions.\n-     *\n-     * @param parts Partitions.\n-     * @param clo Closure.\n-     * @param remainder Remainder.\n-     * @return Index rebuild statistics or {@code null}, if\n-     * {@link IgniteSystemProperties#IGNITE_ENABLE_EXTRA_INDEX_REBUILD_LOGGING} is {@code false}.\n-     * @throws IgniteCheckedException If failed.\n-     */\n-    @Nullable private SchemaIndexCacheStat processPartitions(List<GridDhtLocalPartition> parts, SchemaIndexCacheVisitorClosure clo,\n-        int remainder)\n-        throws IgniteCheckedException {\n+        for (GridDhtLocalPartition locPart : locParts) {\n+            GridWorkerFuture<Void> workerFut = new GridWorkerFuture<>();\n \n-        SchemaIndexCacheStat stat = collectStat ? new SchemaIndexCacheStat() : null;\n+            GridWorker worker = new SchemaIndexCachePartitionWorker(\n+                cctx,\n+                locPart,\n+                stop,\n+                cancel,\n+                clo,\n+                workerFut,\n+                rowFilter,\n+                partsCnt\n+            );\n \n-        for (int i = 0, size = parts.size(); i < size; i++) {\n-            if (stop)\n-                break;\n+            workerFut.setWorker(worker);\n+            buildIdxCompoundFut.add(workerFut);\n \n-            if ((i % parallelism) == remainder)\n-                processPartition(parts.get(i), clo, stat);\n+            cctx.kernalContext().buildIndexExecutorService().execute(worker);\n         }\n \n-        return stat;\n-    }\n+        buildIdxCompoundFut.listen(fut -> buildIdxFut.onDone(fut.error()));\n \n-    /**\n-     * Process partition.\n-     *\n-     * @param part Partition.\n-     * @param clo Index closure.\n-     * @param stat Index build statistics accumulator (can be {@code null}).\n-     * @throws IgniteCheckedException If failed.\n-     */\n-    private void processPartition(\n-        GridDhtLocalPartition part,\n-        SchemaIndexCacheVisitorClosure clo,\n-        @Nullable SchemaIndexCacheStat stat\n-    ) throws IgniteCheckedException {\n-        checkCancelled();\n-\n-        boolean reserved = false;\n-\n-        if (part != null && part.state() != EVICTED)\n-            reserved = (part.state() == OWNING || part.state() == RENTING || part.state() == MOVING) && part.reserve();\n-\n-        if (!reserved)\n-            return;\n-\n-        try {\n-            GridCursor<? extends CacheDataRow> cursor = part.dataStore().cursor(cctx.cacheId(), null, null,\n-                CacheDataRowAdapter.RowData.KEY_ONLY);\n-\n-            boolean locked = false;\n-\n-            try {\n-                int cntr = 0;\n-\n-                while (cursor.next() && !stop) {\n-                    KeyCacheObject key = cursor.get().key();\n-\n-                    if (!locked) {\n-                        cctx.shared().database().checkpointReadLock();\n-\n-                        locked = true;\n-                    }\n-\n-                    processKey(key, clo, stat);\n-\n-                    if (++cntr % BATCH_SIZE == 0) {\n-                        cctx.shared().database().checkpointReadUnlock();\n-\n-                        locked = false;\n-                    }\n-\n-                    if (part.state() == RENTING)\n-                        break;\n-                }\n-\n-                if (stat != null)\n-                    stat.scanned += cntr;\n-            }\n-            finally {\n-                if (locked)\n-                    cctx.shared().database().checkpointReadUnlock();\n-            }\n-        }\n-        finally {\n-            part.release();\n-\n-            if (partsCnt.getAndUpdate(v -> v > 0 ? v - 1 : 0) > 0)\n-                cctx.group().metrics().decrementIndexBuildCountPartitionsLeft();\n-        }\n-    }\n-\n-    /**\n-     * Process single key.\n-     *\n-     * @param key Key.\n-     * @param clo Closure.\n-     * @param stat Index build statistics accumulator (can be {@code null}).\n-     * @throws IgniteCheckedException If failed.\n-     */\n-    private void processKey(\n-        KeyCacheObject key,\n-        SchemaIndexCacheVisitorClosure clo,\n-        @Nullable SchemaIndexCacheStat stat\n-    ) throws IgniteCheckedException {\n-        while (true) {\n-            try {\n-                checkCancelled();\n-\n-                GridCacheEntryEx entry = cctx.cache().entryEx(key);\n-\n-                try {\n-                    entry.updateIndex(rowFilter, clo, stat);\n-                }\n-                finally {\n-                    entry.touch();\n-                }\n-\n-                break;\n-            }\n-            catch (GridDhtInvalidPartitionException ignore) {\n-                break;\n-            }\n-            catch (GridCacheEntryRemovedException ignored) {\n-                // No-op.\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if visit process is not cancelled.\n-     *\n-     * @throws IgniteCheckedException If cancelled.\n-     */\n-    private void checkCancelled() throws IgniteCheckedException {\n-        if (cancel != null && cancel.isCancelled())\n-            throw new IgniteCheckedException(\"Index creation was cancelled.\");\n+        buildIdxCompoundFut.markInitialized();\n     }\n \n     /**\n-     * Resets value of partitions count to be processed and update metrics.\n+     * This method is called before creating or rebuilding indexes.\n+     * Used only for test.\n      */\n-    private void resetPartitionsCount() {\n-        int cnt = partsCnt.getAndSet(0);\n-\n-        if (cnt > 0)\n-            cctx.group().metrics().addIndexBuildCountPartitionsLeft(-cnt);\n+    protected void beforeExecute(){\n+        //no-op\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(SchemaIndexCacheVisitorImpl.class, this);\n     }\n-\n-    /**\n-     * Async worker.\n-     */\n-    private class AsyncWorker extends GridWorker {\n-        /** Partitions. */\n-        private final List<GridDhtLocalPartition> parts;\n-\n-        /** Closure. */\n-        private final SchemaIndexCacheVisitorClosure clo;\n-\n-        /** Remained.. */\n-        private final int remainder;\n-\n-        /** Future. */\n-        private final GridFutureAdapter<SchemaIndexCacheStat> fut;\n-\n-        /**\n-         * Constructor.\n-         *\n-         * @param parts Partitions.\n-         * @param clo Closure.\n-         * @param remainder Remainder.\n-         * @param fut Future.\n-         */\n-        @SuppressWarnings(\"unchecked\")\n-        public AsyncWorker(\n-            List<GridDhtLocalPartition> parts,\n-            SchemaIndexCacheVisitorClosure clo,\n-            int remainder,\n-            GridFutureAdapter<SchemaIndexCacheStat> fut\n-        ) {\n-            super(cctx.igniteInstanceName(), \"parallel-idx-worker-\" + cctx.cache().name() + \"-\" + remainder,\n-                cctx.logger(AsyncWorker.class));\n-\n-            this.parts = parts;\n-            this.clo = clo;\n-            this.remainder = remainder;\n-            this.fut = fut;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n-            Throwable err = null;\n-\n-            try {\n-                processPartitions(parts, clo, remainder);\n-            }\n-            catch (Throwable e) {\n-                err = e;\n-\n-                U.error(log, \"Error during parallel index create/rebuild.\", e);\n-\n-                stop = true;\n-\n-                resetPartitionsCount();\n-            }\n-            finally {\n-                fut.onDone(err);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Reducer for parallel index rebuild.\n-     */\n-    private static class SchemaIndexCacheStatFutureReducer implements IgniteReducer<SchemaIndexCacheStat, SchemaIndexCacheStat> {\n-        /** */\n-        private static final long serialVersionUID = 0L;\n-\n-        /**  */\n-        private final SchemaIndexCacheStat res = new SchemaIndexCacheStat();\n-\n-        /** {@inheritDoc} */\n-        @Override public boolean collect(SchemaIndexCacheStat stat) {\n-            if (stat != null) {\n-                synchronized (res) {\n-                    res.scanned += stat.scanned;\n-                    res.types.putAll(stat.types);\n-                }\n-            }\n-\n-            return true;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public SchemaIndexCacheStat reduce() {\n-            synchronized (res) {\n-                return res;\n-            }\n-        }\n-    }\n }\n"}}, {"oid": "b5aa697d8dbe440b8ddb56c04311b882480510c4", "url": "https://github.com/apache/ignite/commit/b5aa697d8dbe440b8ddb56c04311b882480510c4", "message": "Merge branch 'ai-master' into ignite-12710", "committedDate": "2020-03-27T17:59:44Z", "type": "commit"}, {"oid": "93bed1cbf6aa2558e05c1c6f6120b577667e1e0e", "url": "https://github.com/apache/ignite/commit/93bed1cbf6aa2558e05c1c6f6120b577667e1e0e", "message": "IGNITE-12710 Fix merge errors.", "committedDate": "2020-03-27T18:21:02Z", "type": "commit"}, {"oid": "b7accac1bcc0fb03ff91bd114f615c675e7710f9", "url": "https://github.com/apache/ignite/commit/b7accac1bcc0fb03ff91bd114f615c675e7710f9", "message": "IGNITE-12710 Fix merge errors.", "committedDate": "2020-03-27T18:30:40Z", "type": "commit"}, {"oid": "6a16f92d88856d696559999d3a3e8e23e9983c88", "url": "https://github.com/apache/ignite/commit/6a16f92d88856d696559999d3a3e8e23e9983c88", "message": "IGNITE-12710 WIP.", "committedDate": "2020-03-27T19:32:15Z", "type": "commit"}, {"oid": "5762c4df36a8fb6455e4636f875ebe8973078b3a", "url": "https://github.com/apache/ignite/commit/5762c4df36a8fb6455e4636f875ebe8973078b3a", "message": "IGNITE-12710 Small fix.", "committedDate": "2020-03-27T19:34:55Z", "type": "commit"}, {"oid": "feedacc0414a96b22fb4e1bc4ff2e7a7066d5eb4", "url": "https://github.com/apache/ignite/commit/feedacc0414a96b22fb4e1bc4ff2e7a7066d5eb4", "message": "IGNITE-12710 Fix javadoc.", "committedDate": "2020-03-27T19:40:09Z", "type": "commit"}, {"oid": "b45ee2acfda933f28ce7fd7bef3b08467fe5f7c7", "url": "https://github.com/apache/ignite/commit/b45ee2acfda933f28ce7fd7bef3b08467fe5f7c7", "message": "IGNITE-12710 Fix javadoc.", "committedDate": "2020-03-27T19:40:34Z", "type": "commit"}, {"oid": "8ad8238acfc5d7b029d5292adfbc73ad1519edd1", "url": "https://github.com/apache/ignite/commit/8ad8238acfc5d7b029d5292adfbc73ad1519edd1", "message": "IGNITE-12710 Fix type.", "committedDate": "2020-03-27T19:44:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgwNjcwOA==", "url": "https://github.com/apache/ignite/pull/7461#discussion_r400806708", "bodyText": "Looks like all of these 3 params can be squashed into single closure right here.", "author": "AMashenkov", "createdAt": "2020-03-31T10:29:25Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/SchemaIndexCachePartitionWorker.java", "diffHunk": "@@ -227,7 +237,7 @@ private void processKey(KeyCacheObject key) throws IgniteCheckedException {\n                 GridCacheEntryEx entry = cctx.cache().entryEx(key);\n \n                 try {\n-                    entry.updateIndex(rowFilter, clo);\n+                    entry.updateIndex(rowFilter, clo, indexCacheStat);", "originalCommit": "8ad8238acfc5d7b029d5292adfbc73ad1519edd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg4MzYzNw==", "url": "https://github.com/apache/ignite/pull/7461#discussion_r400883637", "bodyText": "Done", "author": "antonovsergey93", "createdAt": "2020-03-31T12:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgwNjcwOA=="}], "type": "inlineReview", "revised_code": {"commit": "e35adbaeb64ad5d7b5a79a4ff64aec544c6a106f", "chunk": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/SchemaIndexCachePartitionWorker.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/SchemaIndexCachePartitionWorker.java\nindex ef1962e9df..be8eba5b54 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/SchemaIndexCachePartitionWorker.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/SchemaIndexCachePartitionWorker.java\n\n@@ -237,7 +227,7 @@ public class SchemaIndexCachePartitionWorker extends GridWorker {\n                 GridCacheEntryEx entry = cctx.cache().entryEx(key);\n \n                 try {\n-                    entry.updateIndex(rowFilter, clo, indexCacheStat);\n+                    entry.updateIndex(wrappedClo);\n                 }\n                 finally {\n                     entry.touch();\n"}}, {"oid": "e35adbaeb64ad5d7b5a79a4ff64aec544c6a106f", "url": "https://github.com/apache/ignite/commit/e35adbaeb64ad5d7b5a79a4ff64aec544c6a106f", "message": "IGNITE-12710. Code review fixes.", "committedDate": "2020-03-31T12:45:48Z", "type": "commit"}, {"oid": "bbf62434ac6e3ae31451fe7d6963fdc0e2f7a914", "url": "https://github.com/apache/ignite/commit/bbf62434ac6e3ae31451fe7d6963fdc0e2f7a914", "message": "IGNITE-12710 Fix codestyle.", "committedDate": "2020-03-31T13:23:39Z", "type": "commit"}]}