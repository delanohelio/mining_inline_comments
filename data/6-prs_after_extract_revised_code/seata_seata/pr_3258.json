{"pr_number": 3258, "pr_title": "bugfix: fix AsyncWorker potential OOM problem", "pr_createdAt": "2020-11-05T03:37:28Z", "pr_url": "https://github.com/seata/seata/pull/3258", "timeline": [{"oid": "12380808a8210f22b2ae37b0c83009ce4e89e996", "url": "https://github.com/seata/seata/commit/12380808a8210f22b2ae37b0c83009ce4e89e996", "message": "bugfix: fix AsyncWorker potential OOM problem", "committedDate": "2020-11-05T03:30:17Z", "type": "commit"}, {"oid": "ecbd202d47550ab618490afb41af1a91d39845c8", "url": "https://github.com/seata/seata/commit/ecbd202d47550ab618490afb41af1a91d39845c8", "message": "fix style", "committedDate": "2020-11-05T05:28:12Z", "type": "commit"}, {"oid": "ab9382750e63068b69958dec5f733c97047151a8", "url": "https://github.com/seata/seata/commit/ab9382750e63068b69958dec5f733c97047151a8", "message": "Merge branch 'develop' into bugfix-AsyncWorker-OOM", "committedDate": "2020-11-06T02:08:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzA4Mg==", "url": "https://github.com/seata/seata/pull/3258#discussion_r521097082", "bodyText": "error", "author": "xingfudeshi", "createdAt": "2020-11-11T03:56:53Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +58,121 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n+        timerExecutor.scheduleAtFixedRate(() -> {\n+            try {\n+\n+                doBranchCommits();\n+\n+            } catch (Throwable e) {\n+                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());", "originalCommit": "ab9382750e63068b69958dec5f733c97047151a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMDg1MQ==", "url": "https://github.com/seata/seata/pull/3258#discussion_r521110851", "bodyText": "updated.", "author": "selfishlover", "createdAt": "2020-11-11T04:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1f1aea172c1ae5c0f5f0559a089046ffd6883e93", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\nindex 7e86f2cf..75e59df4 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n\n@@ -77,17 +78,9 @@ public class AsyncWorker implements ResourceManagerInbound {\n      */\n     public void init() {\n         LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n-        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n-        timerExecutor.scheduleAtFixedRate(() -> {\n-            try {\n-\n-                doBranchCommits();\n-\n-            } catch (Throwable e) {\n-                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());\n-\n-            }\n-        }, 10, 1000, TimeUnit.MILLISECONDS);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n     }\n \n     private void doBranchCommits() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzE5MQ==", "url": "https://github.com/seata/seata/pull/3258#discussion_r521097191", "bodyText": "LOGGER.warn(\"Failed to get connection for async committing on:{} \"  resourceId, sqle);", "author": "xingfudeshi", "createdAt": "2020-11-11T03:57:22Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +58,121 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n+        timerExecutor.scheduleAtFixedRate(() -> {\n+            try {\n+\n+                doBranchCommits();\n+\n+            } catch (Throwable e) {\n+                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());\n+\n+            }\n+        }, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n \n-    private static class Phase2Context {\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\" + resourceId);\n+            return;\n+        }\n+\n+        Connection conn;\n+        try {\n+            conn = dataSourceProxy.getPlainConnection();\n+        } catch (SQLException sqle) {\n+            LOGGER.warn(\"Failed to get connection for async committing on \" + resourceId, sqle);", "originalCommit": "ab9382750e63068b69958dec5f733c97047151a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMDkwNg==", "url": "https://github.com/seata/seata/pull/3258#discussion_r521110906", "bodyText": "updated.", "author": "selfishlover", "createdAt": "2020-11-11T04:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzE5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "1f1aea172c1ae5c0f5f0559a089046ffd6883e93", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\nindex 7e86f2cf..75e59df4 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n\n@@ -77,17 +78,9 @@ public class AsyncWorker implements ResourceManagerInbound {\n      */\n     public void init() {\n         LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n-        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n-        timerExecutor.scheduleAtFixedRate(() -> {\n-            try {\n-\n-                doBranchCommits();\n-\n-            } catch (Throwable e) {\n-                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());\n-\n-            }\n-        }, 10, 1000, TimeUnit.MILLISECONDS);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n     }\n \n     private void doBranchCommits() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzI0Mg==", "url": "https://github.com/seata/seata/pull/3258#discussion_r521097242", "bodyText": "LOGGER.warn(\"Failed to find resource for {}\" , resourceId);", "author": "xingfudeshi", "createdAt": "2020-11-11T03:57:38Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +58,121 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n+        timerExecutor.scheduleAtFixedRate(() -> {\n+            try {\n+\n+                doBranchCommits();\n+\n+            } catch (Throwable e) {\n+                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());\n+\n+            }\n+        }, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n \n-    private static class Phase2Context {\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\" + resourceId);", "originalCommit": "ab9382750e63068b69958dec5f733c97047151a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMDk0OA==", "url": "https://github.com/seata/seata/pull/3258#discussion_r521110948", "bodyText": "updated.", "author": "selfishlover", "createdAt": "2020-11-11T04:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NzI0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1f1aea172c1ae5c0f5f0559a089046ffd6883e93", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\nindex 7e86f2cf..75e59df4 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n\n@@ -77,17 +78,9 @@ public class AsyncWorker implements ResourceManagerInbound {\n      */\n     public void init() {\n         LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n-        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"AsyncWorker\", 1, true));\n-        timerExecutor.scheduleAtFixedRate(() -> {\n-            try {\n-\n-                doBranchCommits();\n-\n-            } catch (Throwable e) {\n-                LOGGER.info(\"Failed at async committing ... {}\", e.getMessage());\n-\n-            }\n-        }, 10, 1000, TimeUnit.MILLISECONDS);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n     }\n \n     private void doBranchCommits() {\n"}}, {"oid": "1f1aea172c1ae5c0f5f0559a089046ffd6883e93", "url": "https://github.com/seata/seata/commit/1f1aea172c1ae5c0f5f0559a089046ffd6883e93", "message": "adjust logger", "committedDate": "2020-11-11T04:43:47Z", "type": "commit"}, {"oid": "5d80fb0e128f238e9536dc733ae434c1e0125bb0", "url": "https://github.com/seata/seata/commit/5d80fb0e128f238e9536dc733ae434c1e0125bb0", "message": "append", "committedDate": "2020-11-11T04:53:13Z", "type": "commit"}, {"oid": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e", "url": "https://github.com/seata/seata/commit/b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e", "message": "Merge branch 'develop' into bugfix-AsyncWorker-OOM", "committedDate": "2020-11-11T07:40:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTEyMA==", "url": "https://github.com/seata/seata/pull/3258#discussion_r523705120", "bodyText": "\u8fd9\u91ccoffer\u8fd4\u56de\u4e86false\u4e4b\u540e\uff0c\u8fd9\u91cc\u6253\u4e86\u4e2awarn\u7684\u65e5\u5fd7\uff0c\u4f46\u662f\u8fd8\u662f\u8fd4\u56de\u4e86\u4e8c\u9636\u6bb5\u63d0\u4ea4\u6210\u529f\u3002\u4f1a\u4e0d\u4f1a\u5bfc\u81f4seata\u8ba4\u4e3a\u8fd9\u6761\u5206\u652f\u5df2\u7ecf\u63d0\u4ea4\u6210\u529f\u4e86\uff0c\u4f46\u662f\u4e8b\u5b9e\u4e0a\u6ca1\u6709\u63d0\u4ea4\uff1f", "author": "caohdgege", "createdAt": "2020-11-15T04:17:25Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {", "originalCommit": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNjk4Ng==", "url": "https://github.com/seata/seata/pull/3258#discussion_r523706986", "bodyText": "\u8fd9\u91cc\u63d0\u4ea4\u7684\u5185\u5bb9\u5c31\u662f\u5220\u9664\u56de\u6eda\u65e5\u5fd7\uff0c  \u4f1a\u53d1\u751f\u4f60\u8bf4\u7684\u60c5\u51b5\n\u8fd9\u4e5f\u662fAT\u6a21\u5f0f\u72ec\u6709\u7684\u63d0\u4ea4\u65b9\u5f0f\uff0c \u56de\u6eda\u65e5\u5fd7\u53ef\u4ee5\u4e0d\u5220\u9664\uff0c \u7b49\u5f85\u4e03\u5929\u540e\u5220\u9664\u3002\n\u6240\u4ee5\u8fd9\u91cc\u53ef\u4ee5\u7528\u5f02\u6b65\u63d0\u4ea4\u6027\u80fd\u3002 \u5176\u4ed6\u6a21\u5f0f\u7684\u63d0\u4ea4\u56de\u6eda\uff0c\u4ee5\u53caAT\u6a21\u5f0f\u7684\u56de\u6eda\u90fd\u5fc5\u987b\u8981\u540c\u6b65\u64cd\u4f5c\u5b8c\u6210\u624d\u884c\u3002", "author": "ls9527", "createdAt": "2020-11-15T04:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODMzMTc4OA==", "url": "https://github.com/seata/seata/pull/3258#discussion_r528331788", "bodyText": "\u8fd9\u91cc\u793e\u533a\u4e4b\u524d\u6709\u8ba8\u8bba\u8fc7\uff0c\u540e\u9762\u9700\u8981\u6539\u6210\uff0cstatus=1\u7684undo_log\u53ef\u4ee5\u76f4\u63a5\u7b49\u5f85\u4e03\u5929\u540e\u5220\u9664\uff0cstatus=0\u7684undo_log\u9700\u8981\u786e\u4fddlock_table\u7684\u6570\u636e\u5df2\u7ecf\u5220\u9664\u4e86\u624d\u80fd\u5220\u9664\uff0c\u8fd9\u4e2a\u5ef6\u6977\u54e5\u4e4b\u540e\u4e5f\u5173\u6ce8\u4e00\u4e0b\u3002", "author": "caohdgege", "createdAt": "2020-11-22T12:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "79d47739d5a5bd573a110c3f703303c1dad15229", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\nindex 6cb203c6..854e4d9a 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n\n@@ -62,25 +63,37 @@ public class AsyncWorker implements ResourceManagerInbound {\n     private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n         CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n \n-    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+    private final BlockingQueue<Phase2Context> commitQueue;\n+\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    public AsyncWorker() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 2, true);\n+        scheduledExecutor = new ScheduledThreadPoolExecutor(2, threadFactory);\n+        scheduledExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n \n     @Override\n     public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n                                      String applicationData) {\n-        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n-            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n-        }\n+        Phase2Context context = new Phase2Context(branchType, xid, branchId, resourceId, applicationData);\n+        addToCommitQueue(context);\n         return BranchStatus.PhaseTwo_Committed;\n     }\n \n     /**\n-     * Init worker thread to do branch commit\n+     * try add context to commitQueue directly, if fail(which means the queue is full),\n+     * then doBranchCommits urgently(so that the queue could be empty again) and retry this process.\n      */\n-    public void init() {\n-        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n-        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n-        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n-        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    private void addToCommitQueue(Phase2Context context) {\n+        if (commitQueue.offer(context)) {\n+            return;\n+        }\n+        CompletableFuture.runAsync(this::doBranchCommits, scheduledExecutor)\n+                .thenRun(() -> addToCommitQueue(context));\n     }\n \n     private void doBranchCommits() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTM2Mw==", "url": "https://github.com/seata/seata/pull/3258#discussion_r523705363", "bodyText": "\u8fd9\u91cc\u662f\u4e0d\u662f\u5e94\u8be5\u76f4\u63a5\u629b\u51fa\u5f02\u5e38\uff1f\u800c\u4e0d\u662f\u6253\u4e86\u65e5\u5fd7\u4e4b\u540ereturn\uff1f", "author": "caohdgege", "createdAt": "2020-11-15T04:21:01Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n+\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\", resourceId);", "originalCommit": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcxMjA3Mw==", "url": "https://github.com/seata/seata/pull/3258#discussion_r523712073", "bodyText": "\u8fd9\u91cc\u5e94\u8be5\u4e0d\u80fd\u629b\u51fa\u5f02\u5e38\uff0c \u629b\u51fa\u5f02\u5e38\u7684\u8bddfor\u5faa\u73af\u5904\u7406\u5c31\u4e2d\u65ad\u4e86\u3002\n\u5728\u591a\u6570\u636e\u6e90\u7684\u573a\u666f\u4e0b\uff0c\u7b2c\u4e00\u4e2a\u6570\u636e\u6e90\u627e\u4e0d\u5230\u5f71\u54cd\u7b2c\u4e8c\u4e2a\u6570\u636e\u6e90\u65e0\u6cd5\u63d0\u4ea4\u4e5f\u4e0d\u5408\u7406\u3002\n\u662f\u4e0d\u662f\u641e\u4e2a\u5927catch\uff0c\u8ba9\u8fd9\u4e2adealWithGroupedContexts\u4e0d\u629b\u51fa\u5f02\u5e38\u6bd4\u8f83\u597d\uff1f", "author": "ls9527", "createdAt": "2020-11-15T05:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg1OTMzMQ==", "url": "https://github.com/seata/seata/pull/3258#discussion_r523859331", "bodyText": "\u5927\u800c\u5168\u5730catch\u7684\u8bdd\uff0c\u4e0d\u597d\u533a\u5206\u5f02\u5e38\u53d1\u751f\u7684\u5730\u65b9(\u4ee5\u4fbf\u9488\u5bf9\u6027\u5730\u8f93\u51fa\u65e5\u5fd7)", "author": "selfishlover", "createdAt": "2020-11-16T02:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwNjE2OA==", "url": "https://github.com/seata/seata/pull/3258#discussion_r534006168", "bodyText": "\u5206\u7ec4\u51fd\u6570\u6709\u70b9\u4e11", "author": "LiujunjieALiling", "createdAt": "2020-12-02T09:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTM2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "79d47739d5a5bd573a110c3f703303c1dad15229", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\nindex 6cb203c6..854e4d9a 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n\n@@ -62,25 +63,37 @@ public class AsyncWorker implements ResourceManagerInbound {\n     private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n         CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n \n-    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+    private final BlockingQueue<Phase2Context> commitQueue;\n+\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    public AsyncWorker() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 2, true);\n+        scheduledExecutor = new ScheduledThreadPoolExecutor(2, threadFactory);\n+        scheduledExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n \n     @Override\n     public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n                                      String applicationData) {\n-        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n-            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n-        }\n+        Phase2Context context = new Phase2Context(branchType, xid, branchId, resourceId, applicationData);\n+        addToCommitQueue(context);\n         return BranchStatus.PhaseTwo_Committed;\n     }\n \n     /**\n-     * Init worker thread to do branch commit\n+     * try add context to commitQueue directly, if fail(which means the queue is full),\n+     * then doBranchCommits urgently(so that the queue could be empty again) and retry this process.\n      */\n-    public void init() {\n-        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n-        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n-        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n-        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    private void addToCommitQueue(Phase2Context context) {\n+        if (commitQueue.offer(context)) {\n+            return;\n+        }\n+        CompletableFuture.runAsync(this::doBranchCommits, scheduledExecutor)\n+                .thenRun(() -> addToCommitQueue(context));\n     }\n \n     private void doBranchCommits() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTQwOQ==", "url": "https://github.com/seata/seata/pull/3258#discussion_r523705409", "bodyText": "\u4e3a\u4ec0\u4e48\u4e0d\u628a\u5f02\u5e38\u629b\u51fa\u53bb\uff1f", "author": "caohdgege", "createdAt": "2020-11-15T04:21:44Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();\n+        commitQueue.drainTo(allContexts);\n+\n+        // group context by their resourceId\n+        Map<String, List<Phase2Context>> groupedContexts = groupedByResourceId(allContexts);\n+\n+        groupedContexts.forEach(this::dealWithGroupedContexts);\n+    }\n+\n+    Map<String, List<Phase2Context>> groupedByResourceId(List<Phase2Context> contexts) {\n+        Map<String, List<Phase2Context>> groupedContexts = new HashMap<>(DEFAULT_RESOURCE_SIZE);\n+        contexts.forEach(context -> {\n+            List<Phase2Context> group = groupedContexts.computeIfAbsent(context.resourceId, key -> new LinkedList<>());\n+            group.add(context);\n+        });\n+        return groupedContexts;\n+    }\n+\n+    private void dealWithGroupedContexts(String resourceId, List<Phase2Context> contexts) {\n+        DataSourceManager resourceManager = (DataSourceManager) DefaultResourceManager.get().getResourceManager(BranchType.AT);\n+        DataSourceProxy dataSourceProxy = resourceManager.get(resourceId);\n+        if (dataSourceProxy == null) {\n+            LOGGER.warn(\"Failed to find resource for {}\", resourceId);\n+            return;\n+        }\n \n-    private static class Phase2Context {\n+        Connection conn;\n+        try {\n+            conn = dataSourceProxy.getPlainConnection();\n+        } catch (SQLException sqle) {\n+            LOGGER.warn(\"Failed to get connection for async committing on {}\", resourceId, sqle);\n+            return;", "originalCommit": "b0c8bca9e7499dfb1f4f9e93f696c9fb5b8ac92e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg1OTQ3NA==", "url": "https://github.com/seata/seata/pull/3258#discussion_r523859474", "bodyText": "\u540c\u4e0a", "author": "selfishlover", "createdAt": "2020-11-16T02:08:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODMzMTQwNg==", "url": "https://github.com/seata/seata/pull/3258#discussion_r528331406", "bodyText": "\u90a3\u8fd9\u91cc\u7684LOGGER\u7ea7\u522b\u6709\u6ca1\u6709\u5fc5\u8981\u8c03\u9ad8\u4e00\u70b9\u5462\uff1f\u4e00\u822c\u65e5\u5fd7\u4e2d\u5fc3\u4e5f\u53ea\u662f\u76d1\u63a7error\u7ea7\u522b\u7684\u65e5\u5fd7\u3002", "author": "caohdgege", "createdAt": "2020-11-22T12:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3ODYxNw==", "url": "https://github.com/seata/seata/pull/3258#discussion_r543178617", "bodyText": "ok\uff0c\u8c03\u5230error\u4e86", "author": "selfishlover", "createdAt": "2020-12-15T09:24:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzcwNTQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "79d47739d5a5bd573a110c3f703303c1dad15229", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\nindex 6cb203c6..854e4d9a 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n\n@@ -62,25 +63,37 @@ public class AsyncWorker implements ResourceManagerInbound {\n     private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n         CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n \n-    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+    private final BlockingQueue<Phase2Context> commitQueue;\n+\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    public AsyncWorker() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 2, true);\n+        scheduledExecutor = new ScheduledThreadPoolExecutor(2, threadFactory);\n+        scheduledExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n \n     @Override\n     public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n                                      String applicationData) {\n-        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n-            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n-        }\n+        Phase2Context context = new Phase2Context(branchType, xid, branchId, resourceId, applicationData);\n+        addToCommitQueue(context);\n         return BranchStatus.PhaseTwo_Committed;\n     }\n \n     /**\n-     * Init worker thread to do branch commit\n+     * try add context to commitQueue directly, if fail(which means the queue is full),\n+     * then doBranchCommits urgently(so that the queue could be empty again) and retry this process.\n      */\n-    public void init() {\n-        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n-        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n-        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n-        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    private void addToCommitQueue(Phase2Context context) {\n+        if (commitQueue.offer(context)) {\n+            return;\n+        }\n+        CompletableFuture.runAsync(this::doBranchCommits, scheduledExecutor)\n+                .thenRun(() -> addToCommitQueue(context));\n     }\n \n     private void doBranchCommits() {\n"}}, {"oid": "19d7fe661be13444c71f7fddad759573cba453d2", "url": "https://github.com/seata/seata/commit/19d7fe661be13444c71f7fddad759573cba453d2", "message": "Merge branch 'develop' into bugfix-AsyncWorker-OOM", "committedDate": "2020-11-22T12:19:34Z", "type": "commit"}, {"oid": "907a8aedad03e3d096ae54ab086611f535d026fc", "url": "https://github.com/seata/seata/commit/907a8aedad03e3d096ae54ab086611f535d026fc", "message": "Merge branch 'develop' into bugfix-AsyncWorker-OOM", "committedDate": "2020-12-02T06:49:09Z", "type": "commit"}, {"oid": "b989cd73977897154c80a3b9e3326cdb2ff65895", "url": "https://github.com/seata/seata/commit/b989cd73977897154c80a3b9e3326cdb2ff65895", "message": "Merge branch 'develop' into bugfix-AsyncWorker-OOM", "committedDate": "2020-12-15T05:49:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyOTI5Mw==", "url": "https://github.com/seata/seata/pull/3258#discussion_r543129293", "bodyText": "why use LinkedList?", "author": "jsbxyyx", "createdAt": "2020-12-15T08:09:12Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void doBranchCommits() {\n+        if (commitQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        // transfer all context currently received to this list\n+        List<Phase2Context> allContexts = new LinkedList<>();", "originalCommit": "907a8aedad03e3d096ae54ab086611f535d026fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79d47739d5a5bd573a110c3f703303c1dad15229", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\nindex 6cb203c6..854e4d9a 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n\n@@ -62,25 +63,37 @@ public class AsyncWorker implements ResourceManagerInbound {\n     private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n         CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n \n-    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+    private final BlockingQueue<Phase2Context> commitQueue;\n+\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    public AsyncWorker() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 2, true);\n+        scheduledExecutor = new ScheduledThreadPoolExecutor(2, threadFactory);\n+        scheduledExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n \n     @Override\n     public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n                                      String applicationData) {\n-        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n-            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n-        }\n+        Phase2Context context = new Phase2Context(branchType, xid, branchId, resourceId, applicationData);\n+        addToCommitQueue(context);\n         return BranchStatus.PhaseTwo_Committed;\n     }\n \n     /**\n-     * Init worker thread to do branch commit\n+     * try add context to commitQueue directly, if fail(which means the queue is full),\n+     * then doBranchCommits urgently(so that the queue could be empty again) and retry this process.\n      */\n-    public void init() {\n-        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n-        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n-        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n-        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    private void addToCommitQueue(Phase2Context context) {\n+        if (commitQueue.offer(context)) {\n+            return;\n+        }\n+        CompletableFuture.runAsync(this::doBranchCommits, scheduledExecutor)\n+                .thenRun(() -> addToCommitQueue(context));\n     }\n \n     private void doBranchCommits() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMzAwMA==", "url": "https://github.com/seata/seata/pull/3258#discussion_r543133000", "bodyText": "doBranchCommits must try catch.", "author": "jsbxyyx", "createdAt": "2020-12-15T08:15:44Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +59,113 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    @Override\n+    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n+                                     String applicationData) {\n+        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n+            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n+        }\n+        return BranchStatus.PhaseTwo_Committed;\n+    }\n+\n+    /**\n+     * Init worker thread to do branch commit\n+     */\n+    public void init() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n+        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);", "originalCommit": "907a8aedad03e3d096ae54ab086611f535d026fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79d47739d5a5bd573a110c3f703303c1dad15229", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\nindex 6cb203c6..854e4d9a 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n\n@@ -62,25 +63,37 @@ public class AsyncWorker implements ResourceManagerInbound {\n     private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n         CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n \n-    private final BlockingQueue<Phase2Context> commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+    private final BlockingQueue<Phase2Context> commitQueue;\n+\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    public AsyncWorker() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 2, true);\n+        scheduledExecutor = new ScheduledThreadPoolExecutor(2, threadFactory);\n+        scheduledExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    }\n \n     @Override\n     public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,\n                                      String applicationData) {\n-        if (!commitQueue.offer(new Phase2Context(branchType, xid, branchId, resourceId, applicationData))) {\n-            LOGGER.warn(\"Async commit buffer is FULL. Rejected branch [{}/{}] will be handled by housekeeping later.\", branchId, xid);\n-        }\n+        Phase2Context context = new Phase2Context(branchType, xid, branchId, resourceId, applicationData);\n+        addToCommitQueue(context);\n         return BranchStatus.PhaseTwo_Committed;\n     }\n \n     /**\n-     * Init worker thread to do branch commit\n+     * try add context to commitQueue directly, if fail(which means the queue is full),\n+     * then doBranchCommits urgently(so that the queue could be empty again) and retry this process.\n      */\n-    public void init() {\n-        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n-        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 1, true);\n-        ScheduledExecutorService timerExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);\n-        timerExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);\n+    private void addToCommitQueue(Phase2Context context) {\n+        if (commitQueue.offer(context)) {\n+            return;\n+        }\n+        CompletableFuture.runAsync(this::doBranchCommits, scheduledExecutor)\n+                .thenRun(() -> addToCommitQueue(context));\n     }\n \n     private void doBranchCommits() {\n"}}, {"oid": "79d47739d5a5bd573a110c3f703303c1dad15229", "url": "https://github.com/seata/seata/commit/79d47739d5a5bd573a110c3f703303c1dad15229", "message": "make sure no context will be dropped", "committedDate": "2020-12-15T09:18:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNjcyOA==", "url": "https://github.com/seata/seata/pull/3258#discussion_r543206728", "bodyText": "may be throws thread interrupt exception or Error. suggest try catch Throwable.", "author": "jsbxyyx", "createdAt": "2020-12-15T10:02:45Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java", "diffHunk": "@@ -59,8 +60,125 @@\n \n     private static final int UNDOLOG_DELETE_LIMIT_SIZE = 1000;\n \n+    private static final int ASYNC_COMMIT_BUFFER_LIMIT = ConfigurationFactory.getInstance().getInt(\n+        CLIENT_ASYNC_COMMIT_BUFFER_LIMIT, DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+    private final BlockingQueue<Phase2Context> commitQueue;\n+\n+    private final ScheduledExecutorService scheduledExecutor;\n+\n+    public AsyncWorker() {\n+        LOGGER.info(\"Async Commit Buffer Limit: {}\", ASYNC_COMMIT_BUFFER_LIMIT);\n+        commitQueue = new LinkedBlockingQueue<>(ASYNC_COMMIT_BUFFER_LIMIT);\n+\n+        ThreadFactory threadFactory = new NamedThreadFactory(\"AsyncWorker\", 2, true);\n+        scheduledExecutor = new ScheduledThreadPoolExecutor(2, threadFactory);\n+        scheduledExecutor.scheduleAtFixedRate(this::doBranchCommits, 10, 1000, TimeUnit.MILLISECONDS);", "originalCommit": "79d47739d5a5bd573a110c3f703303c1dad15229", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg4MDc1MQ==", "url": "https://github.com/seata/seata/pull/3258#discussion_r543880751", "bodyText": "fixed", "author": "selfishlover", "createdAt": "2020-12-16T03:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNjcyOA=="}], "type": "inlineReview", "revised_code": {"commit": "d19bf23cedd3139c40a4664354ad306fe3f8d48a", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\nindex 854e4d9a..c95a0f05 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/AsyncWorker.java\n\n@@ -52,7 +48,7 @@ import static io.seata.common.DefaultValues.DEFAULT_CLIENT_ASYNC_COMMIT_BUFFER_L\n  *\n  * @author sharajava\n  */\n-public class AsyncWorker implements ResourceManagerInbound {\n+public class AsyncWorker {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(AsyncWorker.class);\n \n"}}, {"oid": "d19bf23cedd3139c40a4664354ad306fe3f8d48a", "url": "https://github.com/seata/seata/commit/d19bf23cedd3139c40a4664354ad306fe3f8d48a", "message": "minify AsyncWorker", "committedDate": "2020-12-16T03:01:34Z", "type": "commit"}, {"oid": "8e49f8e9de44c8704ca814213f072e4616a5a6a6", "url": "https://github.com/seata/seata/commit/8e49f8e9de44c8704ca814213f072e4616a5a6a6", "message": "test ci again", "committedDate": "2020-12-17T03:37:27Z", "type": "commit"}, {"oid": "c63fe60a00918bd1126b8128a0d079f9d46a0446", "url": "https://github.com/seata/seata/commit/c63fe60a00918bd1126b8128a0d079f9d46a0446", "message": "Merge branch 'develop' into bugfix-AsyncWorker-OOM", "committedDate": "2020-12-21T02:07:45Z", "type": "commit"}]}