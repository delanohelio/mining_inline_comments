{"pr_number": 2398, "pr_title": "feature: support multi pk for mysql", "pr_createdAt": "2020-03-13T08:56:49Z", "pr_url": "https://github.com/seata/seata/pull/2398", "timeline": [{"oid": "96fb100aa6ac14e789f8a29344f5546480f09439", "url": "https://github.com/seata/seata/commit/96fb100aa6ac14e789f8a29344f5546480f09439", "message": "\u65b0\u589e\u5168\u5c40\u56de\u8c03", "committedDate": "2020-02-17T01:43:09Z", "type": "commit"}, {"oid": "ade5100bc7b4d951ccf18504af74e6235ecc3d41", "url": "https://github.com/seata/seata/commit/ade5100bc7b4d951ccf18504af74e6235ecc3d41", "message": "\u65b0\u589e\u5168\u5c40\u56de\u8c03", "committedDate": "2020-02-18T01:30:03Z", "type": "commit"}, {"oid": "6d5f1456dee19e82811cca645c91e5103c367d86", "url": "https://github.com/seata/seata/commit/6d5f1456dee19e82811cca645c91e5103c367d86", "message": "multi-pk", "committedDate": "2020-02-28T10:03:32Z", "type": "commit"}, {"oid": "08ed030798e44046de737ef35ff63bdcd1dd1b26", "url": "https://github.com/seata/seata/commit/08ed030798e44046de737ef35ff63bdcd1dd1b26", "message": "stage", "committedDate": "2020-03-05T09:47:35Z", "type": "commit"}, {"oid": "ca8db9c038ae930b8136f751af0dad411fa5f846", "url": "https://github.com/seata/seata/commit/ca8db9c038ae930b8136f751af0dad411fa5f846", "message": "stage", "committedDate": "2020-03-10T08:54:46Z", "type": "commit"}, {"oid": "7eb03a77e6ac329e004ba96e2c7dc86565a0b5f2", "url": "https://github.com/seata/seata/commit/7eb03a77e6ac329e004ba96e2c7dc86565a0b5f2", "message": "\u5904\u7406sql\u5173\u952e\u5b57\u7684\u95ee\u9898", "committedDate": "2020-03-10T10:32:47Z", "type": "commit"}, {"oid": "5d36978f25cf83f480a05af328452b10b75e21bf", "url": "https://github.com/seata/seata/commit/5d36978f25cf83f480a05af328452b10b75e21bf", "message": "Merge remote-tracking branch 'origin/1.1.0' into mulp-pk_based_on_1.0.0", "committedDate": "2020-03-12T00:42:47Z", "type": "commit"}, {"oid": "420f5b2751ee6df6748dd6844b2b913f78be0181", "url": "https://github.com/seata/seata/commit/420f5b2751ee6df6748dd6844b2b913f78be0181", "message": "Merge remote-tracking branch 'origin/1.1.0' into mulp-pk_based_on_1.0.0", "committedDate": "2020-03-12T00:43:19Z", "type": "commit"}, {"oid": "29687f4a3fbabedf6582cadaf81d7a8f31e2a58d", "url": "https://github.com/seata/seata/commit/29687f4a3fbabedf6582cadaf81d7a8f31e2a58d", "message": "change oracle and postgresql", "committedDate": "2020-03-13T08:26:15Z", "type": "commit"}, {"oid": "2efeb4ec02ce5756fb0cf8c50177e92034caeb7a", "url": "https://github.com/seata/seata/commit/2efeb4ec02ce5756fb0cf8c50177e92034caeb7a", "message": "Merge remote-tracking branch 'origin/develop' into multi-pk_based_on_1.1.0\n\n# Conflicts:\n#\tpom.xml", "committedDate": "2020-03-13T08:32:26Z", "type": "commit"}, {"oid": "7dadb0882dbcc1e2570783264aadcf967b848c9a", "url": "https://github.com/seata/seata/commit/7dadb0882dbcc1e2570783264aadcf967b848c9a", "message": "fix wrong code style", "committedDate": "2020-03-14T09:31:43Z", "type": "commit"}, {"oid": "651fcce8e109b36af41b320794ce1ecc9883992e", "url": "https://github.com/seata/seata/commit/651fcce8e109b36af41b320794ce1ecc9883992e", "message": "fix text cases", "committedDate": "2020-03-16T06:03:29Z", "type": "commit"}, {"oid": "1f56dbc723f206159f7b1e9ae88cc33a61cbdab8", "url": "https://github.com/seata/seata/commit/1f56dbc723f206159f7b1e9ae88cc33a61cbdab8", "message": "Merge remote-tracking branch 'origin/develop' into multi-pk_based_on_1.3.0\n\n# Conflicts:\n#\trm-datasource/src/main/java/io/seata/rm/datasource/AbstractConnectionProxy.java\n#\trm-datasource/src/main/java/io/seata/rm/datasource/exec/InsertExecutor.java\n#\trm-datasource/src/test/java/io/seata/rm/datasource/exec/InsertExecutorTest.java", "committedDate": "2020-04-28T07:52:40Z", "type": "commit"}, {"oid": "eb3a261120e08877d96790f150a2d8cb54b28df7", "url": "https://github.com/seata/seata/commit/eb3a261120e08877d96790f150a2d8cb54b28df7", "message": "catch up 1.3.0", "committedDate": "2020-05-06T03:53:00Z", "type": "commit"}, {"oid": "b3f30a824d7914b30e1a22e1285a69ec21aa3b0a", "url": "https://github.com/seata/seata/commit/b3f30a824d7914b30e1a22e1285a69ec21aa3b0a", "message": "Merge remote-tracking branch 'origin/develop' into multi-pk_based_on_1.1.0\n\n# Conflicts:\n#\trm-datasource/src/main/java/io/seata/rm/datasource/exec/MultiUpdateExecutor.java\n#\trm-datasource/src/main/java/io/seata/rm/datasource/exec/UpdateExecutor.java", "committedDate": "2020-05-06T06:08:29Z", "type": "commit"}, {"oid": "0ea8f142f432db41bafd12423e0a07625801dfbf", "url": "https://github.com/seata/seata/commit/0ea8f142f432db41bafd12423e0a07625801dfbf", "message": "resolve conflict", "committedDate": "2020-05-06T06:56:05Z", "type": "commit"}, {"oid": "61b65c7f0cc78da041c89fc5db4dc5a9fd49ad12", "url": "https://github.com/seata/seata/commit/61b65c7f0cc78da041c89fc5db4dc5a9fd49ad12", "message": "revert file", "committedDate": "2020-05-06T07:08:39Z", "type": "commit"}, {"oid": "3c2c83f41526ff7c53c3d81840d681d4389626be", "url": "https://github.com/seata/seata/commit/3c2c83f41526ff7c53c3d81840d681d4389626be", "message": "fix code style", "committedDate": "2020-05-06T07:42:49Z", "type": "commit"}, {"oid": "333d7ef0358d25a1e7b007684416e9f2b03fd0d1", "url": "https://github.com/seata/seata/commit/333d7ef0358d25a1e7b007684416e9f2b03fd0d1", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-05-09T02:24:33Z", "type": "commit"}, {"oid": "6ba7c237a4ee1ca63b83db10847868d8248fed34", "url": "https://github.com/seata/seata/commit/6ba7c237a4ee1ca63b83db10847868d8248fed34", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-05-09T04:22:59Z", "type": "commit"}, {"oid": "8b1851741983ffc133eef7d70f039244a86bdba8", "url": "https://github.com/seata/seata/commit/8b1851741983ffc133eef7d70f039244a86bdba8", "message": "Merge remote-tracking branch 'origin/develop' into multi-pk_based_on_1.1.0\n\n# Conflicts:\n#\trm-datasource/src/main/java/io/seata/rm/datasource/exec/InsertExecutor.java\n#\trm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\n#\trm-datasource/src/test/java/io/seata/rm/datasource/exec/BatchInsertExecutorTest.java\n#\trm-datasource/src/test/java/io/seata/rm/datasource/exec/OracleInsertExecutorTest.java", "committedDate": "2020-06-01T01:31:57Z", "type": "commit"}, {"oid": "7fbbe87a2fd38ea0bbb347704845a2651cb1429d", "url": "https://github.com/seata/seata/commit/7fbbe87a2fd38ea0bbb347704845a2651cb1429d", "message": "resolve conflicts", "committedDate": "2020-06-02T03:17:40Z", "type": "commit"}, {"oid": "384cbd9d29c60802857b0617d9b6c56c50c85ad7", "url": "https://github.com/seata/seata/commit/384cbd9d29c60802857b0617d9b6c56c50c85ad7", "message": "Merge remote-tracking branch 'myGithub/multi-pk_based_on_1.1.0' into multi-pk_based_on_1.1.0", "committedDate": "2020-06-02T03:18:01Z", "type": "commit"}, {"oid": "d89153096a6859d9dfe36b7480333b675c7251b3", "url": "https://github.com/seata/seata/commit/d89153096a6859d9dfe36b7480333b675c7251b3", "message": "fix code style", "committedDate": "2020-06-02T03:51:43Z", "type": "commit"}, {"oid": "154ca49773b149f87777c3a3858ba77d963e4b71", "url": "https://github.com/seata/seata/commit/154ca49773b149f87777c3a3858ba77d963e4b71", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-06-03T05:54:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0MzQ2Mw==", "url": "https://github.com/seata/seata/pull/2398#discussion_r434943463", "bodyText": "How about remove the GlobalTransactionHookManager, and make it to other pr?", "author": "l81893521", "createdAt": "2020-06-04T01:34:40Z", "path": "rm/src/main/java/io/seata/rm/AbstractRMHandler.java", "diffHunk": "@@ -105,6 +105,13 @@ protected void doBranchCommit(BranchCommitRequest request, BranchCommitResponse\n             LOGGER.info(\"Branch commit result: \" + status);\n         }\n \n+        for (GlobalTransactionHook hook : GlobalTransactionHookManager.popHooks(xid)) {", "originalCommit": "154ca49773b149f87777c3a3858ba77d963e4b71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNDcyNA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447534724", "bodyText": "ok", "author": "0000005", "createdAt": "2020-06-30T09:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0MzQ2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "74eb5f5cb2f0f5ea917734c62e25c0832ebf4616", "chunk": "diff --git a/rm/src/main/java/io/seata/rm/AbstractRMHandler.java b/rm/src/main/java/io/seata/rm/AbstractRMHandler.java\nindex 2db2941c23..1cbb163ede 100644\n--- a/rm/src/main/java/io/seata/rm/AbstractRMHandler.java\n+++ b/rm/src/main/java/io/seata/rm/AbstractRMHandler.java\n\n@@ -105,13 +105,6 @@ public abstract class AbstractRMHandler extends AbstractExceptionHandler\n             LOGGER.info(\"Branch commit result: \" + status);\n         }\n \n-        for (GlobalTransactionHook hook : GlobalTransactionHookManager.popHooks(xid)) {\n-            try {\n-                hook.afterCommit();\n-            } catch (Exception e) {\n-                LOGGER.error(\"execute callback fail:{}\",e.getMessage(),e);\n-            }\n-        }\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NDc5Mw==", "url": "https://github.com/seata/seata/pull/2398#discussion_r434944793", "bodyText": "I think here keep it origin would be better.", "author": "l81893521", "createdAt": "2020-06-04T01:39:38Z", "path": "rm/src/main/java/io/seata/rm/DefaultResourceManager.java", "diffHunk": "@@ -121,7 +121,7 @@ public void unregisterResource(Resource resource) {\n \n     @Override\n     public Map<String, Resource> getManagedResources() {\n-        Map<String, Resource> allResource = new HashMap<>();\n+        Map<String, Resource> allResource = new HashMap<>(10);", "originalCommit": "154ca49773b149f87777c3a3858ba77d963e4b71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3ODMyNA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r434978324", "bodyText": "ok", "author": "0000005", "createdAt": "2020-06-04T03:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NDc5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "34d7f9bd6e8c25dbb662bf56f1265c7063b6ac58", "chunk": "diff --git a/rm/src/main/java/io/seata/rm/DefaultResourceManager.java b/rm/src/main/java/io/seata/rm/DefaultResourceManager.java\nindex dc37a02b31..71264d1b7a 100644\n--- a/rm/src/main/java/io/seata/rm/DefaultResourceManager.java\n+++ b/rm/src/main/java/io/seata/rm/DefaultResourceManager.java\n\n@@ -121,7 +121,7 @@ public class DefaultResourceManager implements ResourceManager {\n \n     @Override\n     public Map<String, Resource> getManagedResources() {\n-        Map<String, Resource> allResource = new HashMap<>(10);\n+        Map<String, Resource> allResource = new HashMap<>();\n         for (ResourceManager rm : resourceManagers.values()) {\n             Map<String, Resource> tempResources = rm.getManagedResources();\n             if (tempResources != null) {\n"}}, {"oid": "a98d41411deefc0a9a1acc52e8313edb556e25d3", "url": "https://github.com/seata/seata/commit/a98d41411deefc0a9a1acc52e8313edb556e25d3", "message": "add not support", "committedDate": "2020-06-04T03:56:10Z", "type": "commit"}, {"oid": "7a99b4aaa5610888ea6dd963f5bb110ded58de2e", "url": "https://github.com/seata/seata/commit/7a99b4aaa5610888ea6dd963f5bb110ded58de2e", "message": "Merge remote-tracking branch 'origin/develop' into multi-pk_based_on_1.1.0\n\n# Conflicts:\n#\trm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java", "committedDate": "2020-06-04T07:03:01Z", "type": "commit"}, {"oid": "5b53d53c38da8f919d002f6a7c348e6ed70b9297", "url": "https://github.com/seata/seata/commit/5b53d53c38da8f919d002f6a7c348e6ed70b9297", "message": "fix bugs", "committedDate": "2020-06-09T09:01:19Z", "type": "commit"}, {"oid": "94b2d3b2efeec7c4e1e6f7463de5adadcc4ca04a", "url": "https://github.com/seata/seata/commit/94b2d3b2efeec7c4e1e6f7463de5adadcc4ca04a", "message": "Merge remote-tracking branch 'myGithub/multi-pk_based_on_1.1.0' into multi-pk_based_on_1.1.0", "committedDate": "2020-06-09T09:02:02Z", "type": "commit"}, {"oid": "74eb5f5cb2f0f5ea917734c62e25c0832ebf4616", "url": "https://github.com/seata/seata/commit/74eb5f5cb2f0f5ea917734c62e25c0832ebf4616", "message": "remove GlobalTransactionHook", "committedDate": "2020-06-09T09:05:59Z", "type": "commit"}, {"oid": "610bdee2e388a2b6f77ad3e34a3d1b5f0f83e5e3", "url": "https://github.com/seata/seata/commit/610bdee2e388a2b6f77ad3e34a3d1b5f0f83e5e3", "message": "Merge remote-tracking branch 'origin/develop' into multi-pk_based_on_1.1.0\n\n# Conflicts:\n#\trm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java\n#\trm-datasource/src/test/java/io/seata/rm/datasource/exec/MySQLInsertExecutorTest.java", "committedDate": "2020-06-09T09:13:12Z", "type": "commit"}, {"oid": "6ae3d8fd7e8b1e4a85b2287f4f7d618450d4af20", "url": "https://github.com/seata/seata/commit/6ae3d8fd7e8b1e4a85b2287f4f7d618450d4af20", "message": "fix test cases", "committedDate": "2020-06-09T09:37:52Z", "type": "commit"}, {"oid": "34d7f9bd6e8c25dbb662bf56f1265c7063b6ac58", "url": "https://github.com/seata/seata/commit/34d7f9bd6e8c25dbb662bf56f1265c7063b6ac58", "message": "code optimize", "committedDate": "2020-06-09T09:40:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NDU2Ng==", "url": "https://github.com/seata/seata/pull/2398#discussion_r439174566", "bodyText": "Why getPrimaryKeyOnlyName() here will be orderd?", "author": "l81893521", "createdAt": "2020-06-12T02:31:01Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java", "diffHunk": "@@ -306,27 +316,106 @@ protected TableRecords queryCurrentRecords(Connection conn) throws SQLException\n         return currentRecords;\n     }\n \n+    protected List<Field> getOrderedPkList(TableRecords image,Row row,String dbType) {\n+        List<Field> pkFields = new ArrayList<>();\n+        // To ensure the order of the pk, the order should based on getPrimaryKeyOnlyName.\n+        List<String> pkColumnNameListByOrder = image.getTableMeta().getPrimaryKeyOnlyName();", "originalCommit": "34d7f9bd6e8c25dbb662bf56f1265c7063b6ac58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc3Mjc0Nw==", "url": "https://github.com/seata/seata/pull/2398#discussion_r440772747", "bodyText": "I still have some question here.\n\nyou do not sort the list, why call it 'ordered'?\n\n2.If you just want to get the same order of field in 'undo sql' and 'undo prepare', I think the order of field would be same when you get it in different time.", "author": "l81893521", "createdAt": "2020-06-16T11:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NDU2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\nindex c48eb39e22..b529acaedb 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\n\n@@ -316,13 +320,13 @@ public abstract class AbstractUndoExecutor {\n         return currentRecords;\n     }\n \n-    protected List<Field> getOrderedPkList(TableRecords image,Row row,String dbType) {\n+    protected List<Field> getOrderedPkList(TableRecords image, Row row, String dbType) {\n         List<Field> pkFields = new ArrayList<>();\n         // To ensure the order of the pk, the order should based on getPrimaryKeyOnlyName.\n         List<String> pkColumnNameListByOrder = image.getTableMeta().getPrimaryKeyOnlyName();\n         List<String> pkColumnNameListNoOrder = row.primaryKeys()\n                 .stream()\n-                .map(e -> ColumnUtils.delEscape(e.getName(),dbType))\n+                .map(e -> ColumnUtils.delEscape(e.getName(), dbType))\n                 .collect(Collectors.toList());\n         pkColumnNameListByOrder.forEach(pkName -> {\n             int pkIndex = pkColumnNameListNoOrder.indexOf(pkName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTQ5OA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r439175498", "bodyText": "How about remove this? And create a new pr to support H2 keyword checker?", "author": "l81893521", "createdAt": "2020-06-12T02:35:14Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/KeywordCheckerFactory.java", "diffHunk": "@@ -36,6 +37,10 @@\n      * @return keyword checker\n      */\n     public static KeywordChecker getKeywordChecker(String dbType) {\n+        if (JdbcConstants.H2.equalsIgnoreCase(dbType)) {", "originalCommit": "34d7f9bd6e8c25dbb662bf56f1265c7063b6ac58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0MTQ1Nw==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447341457", "bodyText": "ok", "author": "0000005", "createdAt": "2020-06-30T00:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTQ5OA=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/KeywordCheckerFactory.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/KeywordCheckerFactory.java\nindex 3a35808299..54f34da70d 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/KeywordCheckerFactory.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/KeywordCheckerFactory.java\n\n@@ -37,10 +37,6 @@ public class KeywordCheckerFactory {\n      * @return keyword checker\n      */\n     public static KeywordChecker getKeywordChecker(String dbType) {\n-        if (JdbcConstants.H2.equalsIgnoreCase(dbType)) {\n-            //otherwise it can't get a H2 KeywordChecker\n-            dbType = JdbcConstants.MYSQL;\n-        }\n         if (KEYWORD_CHECKER_MAP.get(dbType) != null) {\n             return KEYWORD_CHECKER_MAP.get(dbType);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzMjAwNg==", "url": "https://github.com/seata/seata/pull/2398#discussion_r439332006", "bodyText": "How about change to\ntmeta.getPrimaryKeyMap().containsKey(colName)", "author": "l81893521", "createdAt": "2020-06-12T10:13:54Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/TableRecords.java", "diffHunk": "@@ -190,7 +193,7 @@ public static TableRecords buildRecords(TableMeta tmeta, ResultSet resultSet) th\n                 int dataType = col.getDataType();\n                 Field field = new Field();\n                 field.setName(col.getColumnName());\n-                if (tmeta.getPkName().equalsIgnoreCase(field.getName())) {\n+                if (tmeta.getPrimaryKeyOnlyName().stream().anyMatch(e -> field.getName().equalsIgnoreCase(e))) {", "originalCommit": "34d7f9bd6e8c25dbb662bf56f1265c7063b6ac58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0MTU0Mw==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447341543", "bodyText": "ok", "author": "0000005", "createdAt": "2020-06-30T00:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzMjAwNg=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/TableRecords.java b/rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/TableRecords.java\nindex f0a47f6a2a..0f9c47d619 100755\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/TableRecords.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/TableRecords.java\n\n@@ -193,7 +193,7 @@ public class TableRecords {\n                 int dataType = col.getDataType();\n                 Field field = new Field();\n                 field.setName(col.getColumnName());\n-                if (tmeta.getPrimaryKeyOnlyName().stream().anyMatch(e -> field.getName().equalsIgnoreCase(e))) {\n+                if (tmeta.getPrimaryKeyMap().containsKey(colName)) {\n                     field.setKeyType(KeyType.PRIMARY_KEY);\n                 }\n                 field.setType(dataType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzNzE1Nw==", "url": "https://github.com/seata/seata/pull/2398#discussion_r439337157", "bodyText": "How about change to\nfinal Map<String, ColumnMeta> primaryKeyMap = getTableMeta().getPrimaryKeyMap();\n...\nif (primaryKeyMap.containsKey(field.getName())) {", "author": "l81893521", "createdAt": "2020-06-12T10:25:56Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/TableRecords.java", "diffHunk": "@@ -133,19 +135,20 @@ public void add(Row row) {\n     /**\n      * Pk rows list.\n      *\n-     * @return the list\n+     * @return return a list. each element of list is a map,the map hold the pk column name as a key and field as the value\n      */\n-    public List<Field> pkRows() {\n-        final String pkName = getTableMeta().getPkName();\n-        List<Field> pkRows = new ArrayList<>();\n+    public List<Map<String,Field>> pkRows() {\n+        final List<String> pkNameList = getTableMeta().getPrimaryKeyOnlyName();", "originalCommit": "34d7f9bd6e8c25dbb662bf56f1265c7063b6ac58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0MTU3Ng==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447341576", "bodyText": "ok", "author": "0000005", "createdAt": "2020-06-30T00:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzNzE1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/TableRecords.java b/rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/TableRecords.java\nindex f0a47f6a2a..0f9c47d619 100755\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/TableRecords.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/sql/struct/TableRecords.java\n\n@@ -138,13 +138,13 @@ public class TableRecords {\n      * @return return a list. each element of list is a map,the map hold the pk column name as a key and field as the value\n      */\n     public List<Map<String,Field>> pkRows() {\n-        final List<String> pkNameList = getTableMeta().getPrimaryKeyOnlyName();\n+        final Map<String, ColumnMeta> primaryKeyMap = getTableMeta().getPrimaryKeyMap();\n         List<Map<String,Field>> pkRows = new ArrayList<>();\n         for (Row row : rows) {\n             List<Field> fields = row.getFields();\n             Map<String,Field> rowMap = new HashMap<>(3);\n             for (Field field : fields) {\n-                if (pkNameList.stream().anyMatch(e -> field.getName().equalsIgnoreCase(e))) {\n+                if (primaryKeyMap.containsKey(field.getName())) {\n                     rowMap.put(field.getName(),field);\n                 }\n             }\n"}}, {"oid": "af3cfb043af10b5c82758abbfaedec910794744d", "url": "https://github.com/seata/seata/commit/af3cfb043af10b5c82758abbfaedec910794744d", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-06-19T07:20:01Z", "type": "commit"}, {"oid": "3870bb6f0670c28b25f36a87e9802bef3f7b2321", "url": "https://github.com/seata/seata/commit/3870bb6f0670c28b25f36a87e9802bef3f7b2321", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-06-23T02:17:02Z", "type": "commit"}, {"oid": "746f6dcf83991422cf5769b4ca873b6b45875832", "url": "https://github.com/seata/seata/commit/746f6dcf83991422cf5769b4ca873b6b45875832", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-06-23T07:42:27Z", "type": "commit"}, {"oid": "c0151f38efaf13359ae97aab147152193fcc646e", "url": "https://github.com/seata/seata/commit/c0151f38efaf13359ae97aab147152193fcc646e", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-06-24T07:52:44Z", "type": "commit"}, {"oid": "15685c6f0fd62277cf98106be371b5edefd4f2a7", "url": "https://github.com/seata/seata/commit/15685c6f0fd62277cf98106be371b5edefd4f2a7", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-06-28T13:59:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3MDIwMg==", "url": "https://github.com/seata/seata/pull/2398#discussion_r446670202", "bodyText": "sqlUndoLog.getTableName() always has escape.", "author": "slievrly", "createdAt": "2020-06-28T16:24:47Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java", "diffHunk": "@@ -273,30 +280,33 @@ protected boolean dataValidationAndGoOn(Connection conn) throws SQLException {\n     protected TableRecords queryCurrentRecords(Connection conn) throws SQLException {\n         TableRecords undoRecords = getUndoRows();\n         TableMeta tableMeta = undoRecords.getTableMeta();\n-        String pkName = tableMeta.getPkName();\n-        int pkType = tableMeta.getColumnMeta(pkName).getDataType();\n+        //the order of element matters\n+        List<String> pkNameList = tableMeta.getPrimaryKeyOnlyName();\n \n         // pares pk values\n-        Object[] pkValues = parsePkValues(getUndoRows());\n-        if (pkValues.length == 0) {\n+        Map<String,List<Field>> pkRowValues = parsePkValues(getUndoRows());\n+        if (pkRowValues.size() == 0) {\n             return TableRecords.empty(tableMeta);\n         }\n-        StringBuilder replace = new StringBuilder();\n-        for (int i = 0; i < pkValues.length; i++) {\n-            replace.append(\"?,\");\n-        }\n         // build check sql\n         String dbType = getDbType(conn);\n-        String checkSQL = String.format(CHECK_SQL_TEMPLATE, sqlUndoLog.getTableName(),\n-            tableMeta.getEscapePkName(dbType), replace.substring(0, replace.length() - 1));\n+        String checkSQL = String.format(CHECK_SQL_TEMPLATE, ColumnUtils.addEscape(sqlUndoLog.getTableName(), dbType),", "originalCommit": "15685c6f0fd62277cf98106be371b5edefd4f2a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0MTY1Mg==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447341652", "bodyText": "ok", "author": "0000005", "createdAt": "2020-06-30T00:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3MDIwMg=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\nindex c48eb39e22..b529acaedb 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\n\n@@ -284,14 +285,15 @@ public abstract class AbstractUndoExecutor {\n         List<String> pkNameList = tableMeta.getPrimaryKeyOnlyName();\n \n         // pares pk values\n-        Map<String,List<Field>> pkRowValues = parsePkValues(getUndoRows());\n+        Map<String, List<Field>> pkRowValues = parsePkValues(getUndoRows());\n         if (pkRowValues.size() == 0) {\n             return TableRecords.empty(tableMeta);\n         }\n         // build check sql\n-        String dbType = getDbType(conn);\n-        String checkSQL = String.format(CHECK_SQL_TEMPLATE, ColumnUtils.addEscape(sqlUndoLog.getTableName(), dbType),\n-                buildWhereConditionByPKs(pkNameList,pkRowValues,conn));\n+        String firstKey = pkRowValues.keySet().stream().findFirst().get();\n+        int pkRowSize = pkRowValues.get(firstKey).size();\n+        String checkSQL = String.format(CHECK_SQL_TEMPLATE, sqlUndoLog.getTableName(),\n+                SqlGenerateUtils.buildWhereConditionByPKs(pkNameList, pkRowSize, getDbType(conn)));\n \n         PreparedStatement statement = null;\n         ResultSet checkSet = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3MzQ5NQ==", "url": "https://github.com/seata/seata/pull/2398#discussion_r446673495", "bodyText": "When comparing should ignore case", "author": "slievrly", "createdAt": "2020-06-28T16:59:40Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java", "diffHunk": "@@ -306,27 +316,106 @@ protected TableRecords queryCurrentRecords(Connection conn) throws SQLException\n         return currentRecords;\n     }\n \n+    protected List<Field> getOrderedPkList(TableRecords image,Row row,String dbType) {\n+        List<Field> pkFields = new ArrayList<>();\n+        // To ensure the order of the pk, the order should based on getPrimaryKeyOnlyName.\n+        List<String> pkColumnNameListByOrder = image.getTableMeta().getPrimaryKeyOnlyName();\n+        List<String> pkColumnNameListNoOrder = row.primaryKeys()\n+                .stream()\n+                .map(e -> ColumnUtils.delEscape(e.getName(),dbType))\n+                .collect(Collectors.toList());\n+        pkColumnNameListByOrder.forEach(pkName -> {\n+            int pkIndex = pkColumnNameListNoOrder.indexOf(pkName);", "originalCommit": "15685c6f0fd62277cf98106be371b5edefd4f2a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4MTMxNA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447481314", "bodyText": "The source of the column name is the same.\nYou will find out that they are coming from Tablemate if you track the invocation chain.", "author": "0000005", "createdAt": "2020-06-30T07:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3MzQ5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\nindex c48eb39e22..b529acaedb 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\n\n@@ -316,13 +320,13 @@ public abstract class AbstractUndoExecutor {\n         return currentRecords;\n     }\n \n-    protected List<Field> getOrderedPkList(TableRecords image,Row row,String dbType) {\n+    protected List<Field> getOrderedPkList(TableRecords image, Row row, String dbType) {\n         List<Field> pkFields = new ArrayList<>();\n         // To ensure the order of the pk, the order should based on getPrimaryKeyOnlyName.\n         List<String> pkColumnNameListByOrder = image.getTableMeta().getPrimaryKeyOnlyName();\n         List<String> pkColumnNameListNoOrder = row.primaryKeys()\n                 .stream()\n-                .map(e -> ColumnUtils.delEscape(e.getName(),dbType))\n+                .map(e -> ColumnUtils.delEscape(e.getName(), dbType))\n                 .collect(Collectors.toList());\n         pkColumnNameListByOrder.forEach(pkName -> {\n             int pkIndex = pkColumnNameListNoOrder.indexOf(pkName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3NTkxMA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r446675910", "bodyText": "(a1 and b1) or ( a1 and b2 ) or (a2 and b2)  <=>  A in (a1,a2) and B in (b1,b2) ?", "author": "slievrly", "createdAt": "2020-06-28T17:23:49Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java", "diffHunk": "@@ -306,27 +316,106 @@ protected TableRecords queryCurrentRecords(Connection conn) throws SQLException\n         return currentRecords;\n     }\n \n+    protected List<Field> getOrderedPkList(TableRecords image,Row row,String dbType) {\n+        List<Field> pkFields = new ArrayList<>();\n+        // To ensure the order of the pk, the order should based on getPrimaryKeyOnlyName.\n+        List<String> pkColumnNameListByOrder = image.getTableMeta().getPrimaryKeyOnlyName();\n+        List<String> pkColumnNameListNoOrder = row.primaryKeys()\n+                .stream()\n+                .map(e -> ColumnUtils.delEscape(e.getName(),dbType))\n+                .collect(Collectors.toList());\n+        pkColumnNameListByOrder.forEach(pkName -> {\n+            int pkIndex = pkColumnNameListNoOrder.indexOf(pkName);\n+            if (pkIndex != -1) {\n+                // add PK to the last of the list.\n+                pkFields.add(row.primaryKeys().get(pkIndex));\n+            }\n+        });\n+        return pkFields;\n+    }\n+\n+    /**\n+     * each pk is a condition.the result will like :\" id =? and userCode =?\"\n+     * @param pkNameList\n+     * @return return where condition sql string.the sql can just search one related record.\n+     */\n+    protected String buildWhereConditionByPKs(List<String> pkNameList,KeywordChecker keywordChecker) {\n+        StringBuilder whereStr = new StringBuilder();\n+        //we must consider the situation of composite primary key\n+        for (int i = 0;i < pkNameList.size(); i++) {\n+            if (i > 0) {\n+                whereStr.append(\" and \");\n+            }\n+            String pkName = pkNameList.get(i);\n+            whereStr.append(keywordChecker.checkAndReplace(pkName));\n+            whereStr.append(\" = ? \");\n+        }\n+        return whereStr.toString();\n+\n+    }\n+    /**\n+     * each pk is a condition.the result will like :\" id in (?,?,?) and userCode in (?,?,?)\"\n+     * @param pkNameList\n+     * @param pkRowValues  the kye of map is pk name ,and value of map is pk's value\n+     * @return return where condition sql string.the sql can search all related records not just one.\n+     */\n+    protected String buildWhereConditionByPKs(List<String> pkNameList,Map<String,List<Field>> pkRowValues,Connection conn) throws SQLException {", "originalCommit": "15685c6f0fd62277cf98106be371b5edefd4f2a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ5NTY1Ng==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447495656", "bodyText": "ok", "author": "0000005", "createdAt": "2020-06-30T08:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3NTkxMA=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\nindex c48eb39e22..b529acaedb 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\n\n@@ -316,13 +320,13 @@ public abstract class AbstractUndoExecutor {\n         return currentRecords;\n     }\n \n-    protected List<Field> getOrderedPkList(TableRecords image,Row row,String dbType) {\n+    protected List<Field> getOrderedPkList(TableRecords image, Row row, String dbType) {\n         List<Field> pkFields = new ArrayList<>();\n         // To ensure the order of the pk, the order should based on getPrimaryKeyOnlyName.\n         List<String> pkColumnNameListByOrder = image.getTableMeta().getPrimaryKeyOnlyName();\n         List<String> pkColumnNameListNoOrder = row.primaryKeys()\n                 .stream()\n-                .map(e -> ColumnUtils.delEscape(e.getName(),dbType))\n+                .map(e -> ColumnUtils.delEscape(e.getName(), dbType))\n                 .collect(Collectors.toList());\n         pkColumnNameListByOrder.forEach(pkName -> {\n             int pkIndex = pkColumnNameListNoOrder.indexOf(pkName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3NjUxOA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r446676518", "bodyText": "ignoreCasesEqual?", "author": "slievrly", "createdAt": "2020-06-28T17:29:24Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java", "diffHunk": "@@ -306,27 +316,106 @@ protected TableRecords queryCurrentRecords(Connection conn) throws SQLException\n         return currentRecords;\n     }\n \n+    protected List<Field> getOrderedPkList(TableRecords image,Row row,String dbType) {\n+        List<Field> pkFields = new ArrayList<>();\n+        // To ensure the order of the pk, the order should based on getPrimaryKeyOnlyName.\n+        List<String> pkColumnNameListByOrder = image.getTableMeta().getPrimaryKeyOnlyName();\n+        List<String> pkColumnNameListNoOrder = row.primaryKeys()\n+                .stream()\n+                .map(e -> ColumnUtils.delEscape(e.getName(),dbType))\n+                .collect(Collectors.toList());\n+        pkColumnNameListByOrder.forEach(pkName -> {\n+            int pkIndex = pkColumnNameListNoOrder.indexOf(pkName);\n+            if (pkIndex != -1) {\n+                // add PK to the last of the list.\n+                pkFields.add(row.primaryKeys().get(pkIndex));\n+            }\n+        });\n+        return pkFields;\n+    }\n+\n+    /**\n+     * each pk is a condition.the result will like :\" id =? and userCode =?\"\n+     * @param pkNameList\n+     * @return return where condition sql string.the sql can just search one related record.\n+     */\n+    protected String buildWhereConditionByPKs(List<String> pkNameList,KeywordChecker keywordChecker) {\n+        StringBuilder whereStr = new StringBuilder();\n+        //we must consider the situation of composite primary key\n+        for (int i = 0;i < pkNameList.size(); i++) {\n+            if (i > 0) {\n+                whereStr.append(\" and \");\n+            }\n+            String pkName = pkNameList.get(i);\n+            whereStr.append(keywordChecker.checkAndReplace(pkName));\n+            whereStr.append(\" = ? \");\n+        }\n+        return whereStr.toString();\n+\n+    }\n+    /**\n+     * each pk is a condition.the result will like :\" id in (?,?,?) and userCode in (?,?,?)\"\n+     * @param pkNameList\n+     * @param pkRowValues  the kye of map is pk name ,and value of map is pk's value\n+     * @return return where condition sql string.the sql can search all related records not just one.\n+     */\n+    protected String buildWhereConditionByPKs(List<String> pkNameList,Map<String,List<Field>> pkRowValues,Connection conn) throws SQLException {\n+        StringBuilder whereStr = new StringBuilder();\n+        //we must consider the situation of composite primary key\n+        for (int i = 0;i < pkNameList.size(); i++) {\n+            if (i > 0) {\n+                whereStr.append(\" and \");\n+            }\n+            String pkName = pkNameList.get(i);\n+            whereStr.append(ColumnUtils.addEscape(pkName,getDbType(conn)));\n+            whereStr.append(\" in ( \");\n+            List<Field> valueList = pkRowValues.get(pkName);\n+            StringBuffer pkValueStr = new StringBuffer();\n+            for (int r = 0;r < valueList.size(); r++) {\n+                if (r > 0) {\n+                    pkValueStr.append(\",\");\n+                }\n+                pkValueStr.append(\"?\");\n+            }\n+            whereStr.append(pkValueStr);\n+            whereStr.append(\" )\");\n+        }\n+\n+        return whereStr.toString();\n+\n+    }\n+\n     /**\n-     * Parse pk values object [ ].\n+     * Parse pk values Field List.\n      *\n      * @param records the records\n-     * @return the object [ ]\n+     * @return List<List<Field>>   each element represents a row. And inside a row list contains pk columns(Field).\n+     */\n+    protected Map<String,List<Field>> parsePkValues(TableRecords records) {\n+        return parsePkValues(records.getRows(),records.getTableMeta().getPrimaryKeyOnlyName());\n+    }\n+\n+    /**\n+     * Parse pk values Field List.\n+     *\n+     * @param rows  pk rows\n+     * @param pkNameList  pk column name\n+     * @return List<List<Field>>   each element represents a row. And inside a row list contains pk columns(Field).\n      */\n-    protected Object[] parsePkValues(TableRecords records) {\n-        String pkName = records.getTableMeta().getPkName();\n-        List<Row> undoRows = records.getRows();\n-        Object[] pkValues = new Object[undoRows.size()];\n-        for (int i = 0; i < undoRows.size(); i++) {\n-            List<Field> fields = undoRows.get(i).getFields();\n+    protected Map<String,List<Field>> parsePkValues(List<Row> rows, List<String> pkNameList) {\n+        List<Field> pkFieldList = new ArrayList<>();\n+        for (int i = 0; i < rows.size(); i++) {\n+            List<Field> fields = rows.get(i).getFields();\n             if (fields != null) {\n                 for (Field field : fields) {\n-                    if (StringUtils.equalsIgnoreCase(pkName, field.getName())) {\n-                        pkValues[i] = field.getValue();\n+                    if (pkNameList.stream().anyMatch(e -> field.getName().equals(e))) {", "originalCommit": "15685c6f0fd62277cf98106be371b5edefd4f2a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0MTcwMg==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447341702", "bodyText": "ok", "author": "0000005", "createdAt": "2020-06-30T00:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3NjUxOA=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\nindex c48eb39e22..b529acaedb 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/AbstractUndoExecutor.java\n\n@@ -316,13 +320,13 @@ public abstract class AbstractUndoExecutor {\n         return currentRecords;\n     }\n \n-    protected List<Field> getOrderedPkList(TableRecords image,Row row,String dbType) {\n+    protected List<Field> getOrderedPkList(TableRecords image, Row row, String dbType) {\n         List<Field> pkFields = new ArrayList<>();\n         // To ensure the order of the pk, the order should based on getPrimaryKeyOnlyName.\n         List<String> pkColumnNameListByOrder = image.getTableMeta().getPrimaryKeyOnlyName();\n         List<String> pkColumnNameListNoOrder = row.primaryKeys()\n                 .stream()\n-                .map(e -> ColumnUtils.delEscape(e.getName(),dbType))\n+                .map(e -> ColumnUtils.delEscape(e.getName(), dbType))\n                 .collect(Collectors.toList());\n         pkColumnNameListByOrder.forEach(pkName -> {\n             int pkIndex = pkColumnNameListNoOrder.indexOf(pkName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5OTgxNA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r446799814", "bodyText": "break\uff0c mysql can only have one auto-inc col", "author": "slievrly", "createdAt": "2020-06-29T06:31:39Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertExecutor.java", "diffHunk": "@@ -63,19 +68,55 @@ public MySQLInsertExecutor(StatementProxy statementProxy, StatementCallback stat\n     }\n \n     @Override\n-    public List<Object> getPkValues() throws SQLException {\n-        return containsPK() ? getPkValuesByColumn() :\n-                (containsColumns() ? getPkValuesByAuto() : getPkValuesByColumn());\n+    public Map<String,List<Object>> getPkValues() throws SQLException {\n+        Map<String,List<Object>> pkValuesMap = null;\n+        List<String> pkColumnNameList = getTableMeta().getPrimaryKeyOnlyName();\n+        Boolean isContainsPk = containsPK();\n+        //when there is only one pk in the table\n+        if (getTableMeta().getPrimaryKeyOnlyName().size() == 1) {\n+            if (isContainsPk) {\n+                pkValuesMap = getPkValuesByColumn();\n+            }\n+            else if (containsColumns()) {\n+                pkValuesMap = getPkValuesByAuto();\n+            }\n+            else {\n+                pkValuesMap = getPkValuesByColumn();\n+            }\n+        } else {\n+            //when there is multiple pk in the table\n+            //1,all pk columns are filled value.\n+            //2,the auto increment pk column value is null, and other pk value are not null.\n+            pkValuesMap = getPkValuesByColumn();\n+            for (String columnName:pkColumnNameList) {\n+                if (!pkValuesMap.containsKey(columnName)) {\n+                    ColumnMeta pkColumnMeta = getTableMeta().getColumnMeta(columnName);\n+                    if (Objects.nonNull(pkColumnMeta) && pkColumnMeta.isAutoincrement()) {\n+                        //3,the auto increment pk column is not exits in sql, and other pk are exits also the value is not null.\n+                        pkValuesMap.putAll(getPkValuesByAuto());\n+                    }\n+                }\n+            }\n+        }\n+        return pkValuesMap;\n     }\n \n     /**\n      * the modify for test\n      */\n-    public List<Object> getPkValuesByAuto() throws SQLException {\n+    public Map<String, List<Object>> getPkValuesByAuto() throws SQLException {\n         // PK is just auto generated\n+        Map<String, List<Object>> pkValuesMap = new HashMap<>(8);\n         Map<String, ColumnMeta> pkMetaMap = getTableMeta().getPrimaryKeyMap();\n-        ColumnMeta pkMeta = pkMetaMap.values().iterator().next();\n-        if (!pkMeta.isAutoincrement()) {\n+        String autoColumnName = \"\";\n+        for (String pkColumnName : pkMetaMap.keySet()) {\n+            if (pkMetaMap.get(pkColumnName).isAutoincrement())\n+            {\n+                autoColumnName = pkColumnName;", "originalCommit": "15685c6f0fd62277cf98106be371b5edefd4f2a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM4NzU2Nw==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447387567", "bodyText": "ok", "author": "0000005", "createdAt": "2020-06-30T03:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5OTgxNA=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertExecutor.java\nindex 9ccec29e50..51295508bb 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertExecutor.java\n\n@@ -113,6 +113,7 @@ public class MySQLInsertExecutor extends BaseInsertExecutor implements Defaultab\n             if (pkMetaMap.get(pkColumnName).isAutoincrement())\n             {\n                 autoColumnName = pkColumnName;\n+                break;\n             }\n         }\n         if (StringUtils.isBlank(autoColumnName))\n"}}, {"oid": "a8b106c334c830be6a9dc77fa86bbb3db5b29cd4", "url": "https://github.com/seata/seata/commit/a8b106c334c830be6a9dc77fa86bbb3db5b29cd4", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-06-30T01:31:44Z", "type": "commit"}, {"oid": "f553f4d2ecbf4a351d7bbc39b5e5b6c2f224d893", "url": "https://github.com/seata/seata/commit/f553f4d2ecbf4a351d7bbc39b5e5b6c2f224d893", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-06-30T10:18:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNDQ0Mw==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447604443", "bodyText": "sqlUndoLog.getTableName() always has escape.", "author": "slievrly", "createdAt": "2020-06-30T11:15:19Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/mysql/MySQLUndoInsertExecutor.java", "diffHunk": "@@ -54,18 +56,26 @@ protected String buildUndoSQL() {\n         if (CollectionUtils.isEmpty(afterImageRows)) {\n             throw new ShouldNeverHappenException(\"Invalid UNDO LOG\");\n         }\n-        Row row = afterImageRows.get(0);\n-        Field pkField = row.primaryKeys().get(0);\n-        // insert sql undo log after image all field come from table meta, need add escape.\n-        // see BaseTransactionalExecutor#buildTableRecords\n-        return String.format(DELETE_SQL_TEMPLATE, sqlUndoLog.getTableName(),\n-                             ColumnUtils.addEscape(pkField.getName(), JdbcConstants.MYSQL));\n+        return generateDeleteSql(afterImageRows,afterImage);\n     }\n \n     @Override\n-    protected void undoPrepare(PreparedStatement undoPST, ArrayList<Field> undoValues, Field pkValue)\n-        throws SQLException {\n-        undoPST.setObject(1, pkValue.getValue(), pkValue.getType());\n+    protected void undoPrepare(PreparedStatement undoPST, ArrayList<Field> undoValues, List<Field> pkValueList)\n+            throws SQLException {\n+        int undoIndex = 0;\n+        for (Field pkField:pkValueList) {\n+            undoIndex++;\n+            undoPST.setObject(undoIndex, pkField.getValue(), pkField.getType());\n+        }\n+    }\n+\n+    private String generateDeleteSql(List<Row> rows,TableRecords afterImage) {\n+        KeywordChecker keywordChecker = KeywordCheckerFactory.getKeywordChecker(JdbcConstants.MYSQL);\n+        List<String> pkNameList = getOrderedPkList(afterImage,rows.get(0),JdbcConstants.MYSQL)\n+                .stream().map(e -> e.getName())\n+                .collect(Collectors.toList());\n+        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n+        return String.format(DELETE_SQL_TEMPLATE,keywordChecker.checkAndReplace(sqlUndoLog.getTableName()), whereSql);", "originalCommit": "f553f4d2ecbf4a351d7bbc39b5e5b6c2f224d893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NjAyMA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r448056020", "bodyText": "ok", "author": "0000005", "createdAt": "2020-07-01T00:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNDQ0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/mysql/MySQLUndoInsertExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/mysql/MySQLUndoInsertExecutor.java\nindex 9a514ab082..79a553273a 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/mysql/MySQLUndoInsertExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/mysql/MySQLUndoInsertExecutor.java\n\n@@ -74,8 +75,8 @@ public class MySQLUndoInsertExecutor extends AbstractUndoExecutor {\n         List<String> pkNameList = getOrderedPkList(afterImage,rows.get(0),JdbcConstants.MYSQL)\n                 .stream().map(e -> e.getName())\n                 .collect(Collectors.toList());\n-        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n-        return String.format(DELETE_SQL_TEMPLATE,keywordChecker.checkAndReplace(sqlUndoLog.getTableName()), whereSql);\n+        String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList,keywordChecker);\n+        return String.format(DELETE_SQL_TEMPLATE,sqlUndoLog.getTableName(), whereSql);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNDYxOA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447604618", "bodyText": "sqlUndoLog.getTableName() always has escape.", "author": "slievrly", "createdAt": "2020-06-30T11:15:39Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/mysql/MySQLUndoUpdateExecutor.java", "diffHunk": "@@ -47,21 +49,27 @@\n      */\n     @Override\n     protected String buildUndoSQL() {\n+        KeywordChecker keywordChecker = KeywordCheckerFactory.getKeywordChecker(JdbcConstants.MYSQL);\n         TableRecords beforeImage = sqlUndoLog.getBeforeImage();\n         List<Row> beforeImageRows = beforeImage.getRows();\n         if (CollectionUtils.isEmpty(beforeImageRows)) {\n             throw new ShouldNeverHappenException(\"Invalid UNDO LOG\"); // TODO\n         }\n         Row row = beforeImageRows.get(0);\n-        Field pkField = row.primaryKeys().get(0);\n+\n         List<Field> nonPkFields = row.nonPrimaryKeys();\n         // update sql undo log before image all field come from table meta. need add escape.\n         // see BaseTransactionalExecutor#buildTableRecords\n         String updateColumns = nonPkFields.stream()\n             .map(field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.MYSQL) + \" = ?\")\n             .collect(Collectors.joining(\", \"));\n-        return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(), updateColumns,\n-                ColumnUtils.addEscape(pkField.getName(), JdbcConstants.MYSQL));\n+\n+        List<String> pkNameList = getOrderedPkList(beforeImage,row,JdbcConstants.MYSQL)\n+                .stream().map(e -> e.getName())\n+                .collect(Collectors.toList());\n+        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n+\n+        return String.format(UPDATE_SQL_TEMPLATE, keywordChecker.checkAndReplace(sqlUndoLog.getTableName()),updateColumns, whereSql);", "originalCommit": "f553f4d2ecbf4a351d7bbc39b5e5b6c2f224d893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NjE1NA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r448056154", "bodyText": "ok", "author": "0000005", "createdAt": "2020-07-01T00:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNDYxOA=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/mysql/MySQLUndoUpdateExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/mysql/MySQLUndoUpdateExecutor.java\nindex 1013a894a1..4c0bab3413 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/mysql/MySQLUndoUpdateExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/mysql/MySQLUndoUpdateExecutor.java\n\n@@ -67,9 +68,9 @@ public class MySQLUndoUpdateExecutor extends AbstractUndoExecutor {\n         List<String> pkNameList = getOrderedPkList(beforeImage,row,JdbcConstants.MYSQL)\n                 .stream().map(e -> e.getName())\n                 .collect(Collectors.toList());\n-        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n+        String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList,keywordChecker);\n \n-        return String.format(UPDATE_SQL_TEMPLATE, keywordChecker.checkAndReplace(sqlUndoLog.getTableName()),updateColumns, whereSql);\n+        return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(),updateColumns, whereSql);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNDg4MQ==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447604881", "bodyText": "sqlUndoLog.getTableName() always has escape.", "author": "slievrly", "createdAt": "2020-06-30T11:16:07Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/oracle/OracleUndoInsertExecutor.java", "diffHunk": "@@ -49,18 +51,27 @@ protected String buildUndoSQL() {\n         if (CollectionUtils.isEmpty(afterImageRows)) {\n             throw new ShouldNeverHappenException(\"Invalid UNDO LOG\");\n         }\n-        Row row = afterImageRows.get(0);\n-        Field pkField = row.primaryKeys().get(0);\n-        // insert sql undo log after image all field come from table meta, need add escape.\n-        // see BaseTransactionalExecutor#buildTableRecords\n-        return String.format(DELETE_SQL_TEMPLATE, sqlUndoLog.getTableName(),\n-                ColumnUtils.addEscape(pkField.getName(), JdbcConstants.ORACLE));\n+        return generateDeleteSql(afterImageRows,afterImage);\n     }\n \n     @Override\n-    protected void undoPrepare(PreparedStatement undoPST, ArrayList<Field> undoValues, Field pkValue)\n-        throws SQLException {\n-        undoPST.setObject(1, pkValue.getValue(), pkValue.getType());\n+    protected void undoPrepare(PreparedStatement undoPST, ArrayList<Field> undoValues, List<Field> pkValueList)\n+            throws SQLException {\n+        int undoIndex = 0;\n+        for (Field pkField:pkValueList) {\n+            undoIndex++;\n+            undoPST.setObject(undoIndex, pkField.getValue(), pkField.getType());\n+        }\n+    }\n+\n+\n+    private String generateDeleteSql(List<Row> rows,TableRecords afterImage) {\n+        KeywordChecker keywordChecker = KeywordCheckerFactory.getKeywordChecker(JdbcConstants.ORACLE);\n+        List<String> pkNameList = getOrderedPkList(afterImage,rows.get(0),JdbcConstants.ORACLE)\n+                .stream().map(e -> e.getName())\n+                .collect(Collectors.toList());\n+        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n+        return String.format(DELETE_SQL_TEMPLATE,keywordChecker.checkAndReplace(sqlUndoLog.getTableName()), whereSql);", "originalCommit": "f553f4d2ecbf4a351d7bbc39b5e5b6c2f224d893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NjMwMA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r448056300", "bodyText": "ok", "author": "0000005", "createdAt": "2020-07-01T00:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNDg4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/oracle/OracleUndoInsertExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/oracle/OracleUndoInsertExecutor.java\nindex 2bb28e2d98..732d8f4db1 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/oracle/OracleUndoInsertExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/oracle/OracleUndoInsertExecutor.java\n\n@@ -70,8 +71,8 @@ public class OracleUndoInsertExecutor extends AbstractUndoExecutor {\n         List<String> pkNameList = getOrderedPkList(afterImage,rows.get(0),JdbcConstants.ORACLE)\n                 .stream().map(e -> e.getName())\n                 .collect(Collectors.toList());\n-        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n-        return String.format(DELETE_SQL_TEMPLATE,keywordChecker.checkAndReplace(sqlUndoLog.getTableName()), whereSql);\n+        String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList,keywordChecker);\n+        return String.format(DELETE_SQL_TEMPLATE,sqlUndoLog.getTableName(), whereSql);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNDk5OA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447604998", "bodyText": "sqlUndoLog.getTableName() always has escape.", "author": "slievrly", "createdAt": "2020-06-30T11:16:20Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/oracle/OracleUndoUpdateExecutor.java", "diffHunk": "@@ -36,28 +38,33 @@\n public class OracleUndoUpdateExecutor extends AbstractUndoExecutor {\n \n     /**\n-     * UPDATE a SET x = ?, y = ?, z = ? WHERE pk = ?\n+     * UPDATE a SET x = ?, y = ?, z = ? WHERE pk1 in (?) pk2 in (?)\n      */\n     private static final String UPDATE_SQL_TEMPLATE = \"UPDATE %s SET %s WHERE %s = ?\";\n \n     @Override\n     protected String buildUndoSQL() {\n+        KeywordChecker keywordChecker = KeywordCheckerFactory.getKeywordChecker(JdbcConstants.ORACLE);\n         TableRecords beforeImage = sqlUndoLog.getBeforeImage();\n         List<Row> beforeImageRows = beforeImage.getRows();\n         if (CollectionUtils.isEmpty(beforeImageRows)) {\n             throw new ShouldNeverHappenException(\"Invalid UNDO LOG\"); // TODO\n         }\n-\n         Row row = beforeImageRows.get(0);\n-        Field pkField = row.primaryKeys().get(0);\n+\n         List<Field> nonPkFields = row.nonPrimaryKeys();\n-        // update sql undo log before image all field name come from table meta, need add escape.\n+        // update sql undo log before image all field come from table meta. need add escape.\n         // see BaseTransactionalExecutor#buildTableRecords\n         String updateColumns = nonPkFields.stream()\n-            .map(field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.ORACLE) + \" = ?\")\n-            .collect(Collectors.joining(\", \"));\n-        return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(), updateColumns,\n-                ColumnUtils.addEscape(pkField.getName(), JdbcConstants.ORACLE));\n+                .map(field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.ORACLE) + \" = ?\")\n+                .collect(Collectors.joining(\", \"));\n+\n+        List<String> pkNameList = getOrderedPkList(beforeImage,row,JdbcConstants.ORACLE)\n+                .stream().map(e -> e.getName())\n+                .collect(Collectors.toList());\n+        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n+\n+        return String.format(UPDATE_SQL_TEMPLATE, keywordChecker.checkAndReplace(sqlUndoLog.getTableName()),updateColumns, whereSql);", "originalCommit": "f553f4d2ecbf4a351d7bbc39b5e5b6c2f224d893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NjQ2OA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r448056468", "bodyText": "ok", "author": "0000005", "createdAt": "2020-07-01T00:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNDk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/oracle/OracleUndoUpdateExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/oracle/OracleUndoUpdateExecutor.java\nindex 01f563481c..51ebb7724c 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/oracle/OracleUndoUpdateExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/oracle/OracleUndoUpdateExecutor.java\n\n@@ -62,9 +63,9 @@ public class OracleUndoUpdateExecutor extends AbstractUndoExecutor {\n         List<String> pkNameList = getOrderedPkList(beforeImage,row,JdbcConstants.ORACLE)\n                 .stream().map(e -> e.getName())\n                 .collect(Collectors.toList());\n-        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n+        String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList,keywordChecker);\n \n-        return String.format(UPDATE_SQL_TEMPLATE, keywordChecker.checkAndReplace(sqlUndoLog.getTableName()),updateColumns, whereSql);\n+        return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(),updateColumns, whereSql);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNTA4MA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447605080", "bodyText": "sqlUndoLog.getTableName() always has escape.", "author": "slievrly", "createdAt": "2020-06-30T11:16:31Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoInsertExecutor.java", "diffHunk": "@@ -49,18 +51,26 @@ protected String buildUndoSQL() {\n         if (CollectionUtils.isEmpty(afterImageRows)) {\n             throw new ShouldNeverHappenException(\"Invalid UNDO LOG\");\n         }\n-        Row row = afterImageRows.get(0);\n-        Field pkField = row.primaryKeys().get(0);\n-        // insert sql undo log after image all field come from table meta, need add escape.\n-        // see BaseTransactionalExecutor#buildTableRecords\n-        return String.format(DELETE_SQL_TEMPLATE, sqlUndoLog.getTableName(),\n-                ColumnUtils.addEscape(pkField.getName(), JdbcConstants.POSTGRESQL));\n+        return generateDeleteSql(afterImageRows,afterImage);\n     }\n \n     @Override\n-    protected void undoPrepare(PreparedStatement undoPST, ArrayList<Field> undoValues,\n-                               Field pkValue) throws SQLException {\n-        undoPST.setObject(1, pkValue.getValue(), pkValue.getType());\n+    protected void undoPrepare(PreparedStatement undoPST, ArrayList<Field> undoValues, List<Field> pkValueList) throws SQLException {\n+        int undoIndex = 0;\n+        for (Field pkField:pkValueList) {\n+            undoIndex++;\n+            undoPST.setObject(undoIndex, pkField.getValue(), pkField.getType());\n+        }\n+    }\n+\n+\n+    private String generateDeleteSql(List<Row> rows,TableRecords afterImage) {\n+        KeywordChecker keywordChecker = KeywordCheckerFactory.getKeywordChecker(JdbcConstants.POSTGRESQL);\n+        List<String> pkNameList = getOrderedPkList(afterImage,rows.get(0),JdbcConstants.POSTGRESQL)\n+                .stream().map(e -> e.getName())\n+                .collect(Collectors.toList());\n+        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n+        return String.format(DELETE_SQL_TEMPLATE,keywordChecker.checkAndReplace(sqlUndoLog.getTableName()), whereSql);", "originalCommit": "f553f4d2ecbf4a351d7bbc39b5e5b6c2f224d893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NjYwNA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r448056604", "bodyText": "ok", "author": "0000005", "createdAt": "2020-07-01T00:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNTA4MA=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoInsertExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoInsertExecutor.java\nindex 5af8888943..47ad0a5019 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoInsertExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoInsertExecutor.java\n\n@@ -69,8 +70,8 @@ public class PostgresqlUndoInsertExecutor extends AbstractUndoExecutor {\n         List<String> pkNameList = getOrderedPkList(afterImage,rows.get(0),JdbcConstants.POSTGRESQL)\n                 .stream().map(e -> e.getName())\n                 .collect(Collectors.toList());\n-        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n-        return String.format(DELETE_SQL_TEMPLATE,keywordChecker.checkAndReplace(sqlUndoLog.getTableName()), whereSql);\n+        String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList,keywordChecker);\n+        return String.format(DELETE_SQL_TEMPLATE,sqlUndoLog.getTableName(), whereSql);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNTE0MQ==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447605141", "bodyText": "sqlUndoLog.getTableName() always has escape.", "author": "slievrly", "createdAt": "2020-06-30T11:16:40Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoUpdateExecutor.java", "diffHunk": "@@ -34,27 +36,33 @@\n public class PostgresqlUndoUpdateExecutor extends AbstractUndoExecutor {\n \n     /**\n-     * UPDATE a SET x = ?, y = ?, z = ? WHERE pk = ?\n+     * UPDATE a SET x = ?, y = ?, z = ? WHERE pk1 in (?) pk2 in (?)\n      */\n-    private static final String UPDATE_SQL_TEMPLATE = \"UPDATE %s SET %s WHERE %s = ?\";\n+    private static final String UPDATE_SQL_TEMPLATE = \"UPDATE %s SET %s WHERE %s \";\n \n     @Override\n     protected String buildUndoSQL() {\n+        KeywordChecker keywordChecker = KeywordCheckerFactory.getKeywordChecker(JdbcConstants.POSTGRESQL);\n         TableRecords beforeImage = sqlUndoLog.getBeforeImage();\n         List<Row> beforeImageRows = beforeImage.getRows();\n         if (CollectionUtils.isEmpty(beforeImageRows)) {\n             throw new ShouldNeverHappenException(\"Invalid UNDO LOG\"); // TODO\n         }\n         Row row = beforeImageRows.get(0);\n-        Field pkField = row.primaryKeys().get(0);\n+\n         List<Field> nonPkFields = row.nonPrimaryKeys();\n         // update sql undo log before image all field come from table meta. need add escape.\n         // see BaseTransactionalExecutor#buildTableRecords\n         String updateColumns = nonPkFields.stream()\n                 .map(field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.POSTGRESQL) + \" = ?\")\n                 .collect(Collectors.joining(\", \"));\n-        return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(), updateColumns,\n-                ColumnUtils.addEscape(pkField.getName(), JdbcConstants.POSTGRESQL));\n+\n+        List<String> pkNameList = getOrderedPkList(beforeImage,row,JdbcConstants.POSTGRESQL)\n+                .stream().map(e -> e.getName())\n+                .collect(Collectors.toList());\n+        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n+\n+        return String.format(UPDATE_SQL_TEMPLATE, keywordChecker.checkAndReplace(sqlUndoLog.getTableName()),updateColumns, whereSql);", "originalCommit": "f553f4d2ecbf4a351d7bbc39b5e5b6c2f224d893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NjcwMw==", "url": "https://github.com/seata/seata/pull/2398#discussion_r448056703", "bodyText": "ok", "author": "0000005", "createdAt": "2020-07-01T00:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwNTE0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoUpdateExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoUpdateExecutor.java\nindex fb439f118d..3e52ca56ee 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoUpdateExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/undo/postgresql/PostgresqlUndoUpdateExecutor.java\n\n@@ -60,9 +61,9 @@ public class PostgresqlUndoUpdateExecutor extends AbstractUndoExecutor {\n         List<String> pkNameList = getOrderedPkList(beforeImage,row,JdbcConstants.POSTGRESQL)\n                 .stream().map(e -> e.getName())\n                 .collect(Collectors.toList());\n-        String whereSql = buildWhereConditionByPKs(pkNameList,keywordChecker);\n+        String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList,keywordChecker);\n \n-        return String.format(UPDATE_SQL_TEMPLATE, keywordChecker.checkAndReplace(sqlUndoLog.getTableName()),updateColumns, whereSql);\n+        return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(),updateColumns, whereSql);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYyOTEyOA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447629128", "bodyText": "same  as  another buildWhereConditionByPKs", "author": "slievrly", "createdAt": "2020-06-30T12:03:13Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseTransactionalExecutor.java", "diffHunk": "@@ -120,18 +124,34 @@ public T execute(Object... args) throws Throwable {\n     protected abstract T doExecute(Object... args) throws Throwable;\n \n     /**\n-     * Build where condition by p ks string.\n+     * Build where condition by pks string.\n      *\n      * @param pkRows the pk rows\n      * @return the string\n      * @throws SQLException the sql exception\n      */\n-    protected String buildWhereConditionByPKs(List<Field> pkRows) throws SQLException {\n-        StringJoiner whereConditionAppender = new StringJoiner(\",\", getColumnNameInSQL(pkRows.get(0).getName()) + \" in (\", \")\");\n-        for (Field field : pkRows) {\n-            whereConditionAppender.add(\"?\");\n+    protected String buildWhereConditionByPKs(List<Map<String,Field>> pkRows) throws SQLException {\n+        StringBuilder sql = new StringBuilder();\n+        List<String> pkColumnNameList = getTableMeta().getPrimaryKeyOnlyName();", "originalCommit": "f553f4d2ecbf4a351d7bbc39b5e5b6c2f224d893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5MjE3NQ==", "url": "https://github.com/seata/seata/pull/2398#discussion_r448092175", "bodyText": "ok", "author": "0000005", "createdAt": "2020-07-01T03:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYyOTEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseTransactionalExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseTransactionalExecutor.java\nindex 2abbb998ab..5f35bd1b04 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseTransactionalExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseTransactionalExecutor.java\n\n@@ -123,37 +124,6 @@ public abstract class BaseTransactionalExecutor<T, S extends Statement> implemen\n      */\n     protected abstract T doExecute(Object... args) throws Throwable;\n \n-    /**\n-     * Build where condition by pks string.\n-     *\n-     * @param pkRows the pk rows\n-     * @return the string\n-     * @throws SQLException the sql exception\n-     */\n-    protected String buildWhereConditionByPKs(List<Map<String,Field>> pkRows) throws SQLException {\n-        StringBuilder sql = new StringBuilder();\n-        List<String> pkColumnNameList = getTableMeta().getPrimaryKeyOnlyName();\n-        for (int i = 0;i < pkColumnNameList.size();i++)\n-        {\n-            if (i > 0)\n-            {\n-                sql.append(\" AND \");\n-            }\n-            String pkKey = pkColumnNameList.get(i);\n-            StringJoiner pkValuesJoiner = new StringJoiner(\" , \",\n-                    \" \" + pkKey + \" in (\", \")\");\n-            List<Field> pkFieldList = pkRows.stream()\n-                    .map(e -> e.get(pkKey))\n-                    .filter(e -> Objects.nonNull(e))\n-                    .collect(Collectors.toList());\n-            for (Field pkValue : pkFieldList) {\n-                pkValuesJoiner.add(\"?\");\n-            }\n-            sql.append(pkValuesJoiner.toString());\n-        }\n-        return sql.toString();\n-\n-    }\n \n     /**\n      * build buildWhereCondition\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY0MTIzNg==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447641236", "bodyText": "same as another buildWhereConditionByPKs", "author": "slievrly", "createdAt": "2020-06-30T12:24:47Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseTransactionalExecutor.java", "diffHunk": "@@ -331,22 +388,45 @@ protected TableRecords buildTableRecords(TableMeta tableMeta, String selectSQL,\n     /**\n      * build TableRecords\n      *\n-     * @param pkValues the pkValues\n+     * @param pkValuesMap the pkValuesMap\n      * @return return TableRecords;\n      * @throws SQLException\n      */\n-    protected TableRecords buildTableRecords(List<Object> pkValues) throws SQLException {\n-        String pk = getTableMeta().getEscapePkName(getDbType());\n-        StringJoiner pkValuesJoiner = new StringJoiner(\" , \",\n-                \"SELECT * FROM \" + getFromTableInSQL() + \" WHERE \" + pk + \" in (\", \")\");\n-        for (Object pkValue : pkValues) {\n-            pkValuesJoiner.add(\"?\");\n+    protected TableRecords buildTableRecords(Map<String,List<Object>> pkValuesMap) throws SQLException {\n+        TableRecords afterImage;\n+        StringBuilder sql =  new StringBuilder()\n+                .append(\"SELECT * FROM \")\n+                .append(getFromTableInSQL())\n+                .append(\" WHERE \");\n+\n+        List<String> pkColumnNameList = getTableMeta().getPrimaryKeyOnlyName();\n+        for (int i = 0;i < pkColumnNameList.size();i++)\n+        {\n+            if (i > 0)\n+            {", "originalCommit": "f553f4d2ecbf4a351d7bbc39b5e5b6c2f224d893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5MjE0Mg==", "url": "https://github.com/seata/seata/pull/2398#discussion_r448092142", "bodyText": "ok", "author": "0000005", "createdAt": "2020-07-01T03:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY0MTIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseTransactionalExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseTransactionalExecutor.java\nindex 2abbb998ab..5f35bd1b04 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseTransactionalExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseTransactionalExecutor.java\n\n@@ -392,28 +373,16 @@ public abstract class BaseTransactionalExecutor<T, S extends Statement> implemen\n      * @return return TableRecords;\n      * @throws SQLException\n      */\n-    protected TableRecords buildTableRecords(Map<String,List<Object>> pkValuesMap) throws SQLException {\n-        TableRecords afterImage;\n-        StringBuilder sql =  new StringBuilder()\n+    protected TableRecords buildTableRecords(Map<String, List<Object>> pkValuesMap) throws SQLException {\n+        List<String> pkColumnNameList = getTableMeta().getPrimaryKeyOnlyName();\n+        StringBuilder sql = new StringBuilder()\n                 .append(\"SELECT * FROM \")\n                 .append(getFromTableInSQL())\n                 .append(\" WHERE \");\n-\n-        List<String> pkColumnNameList = getTableMeta().getPrimaryKeyOnlyName();\n-        for (int i = 0;i < pkColumnNameList.size();i++)\n-        {\n-            if (i > 0)\n-            {\n-                sql.append(\" AND \");\n-            }\n-            String pkKey = pkColumnNameList.get(i);\n-            StringJoiner pkValuesJoiner = new StringJoiner(\" , \",\n-                    \" \" + ColumnUtils.addEscape(pkKey,getDbType()) + \" in (\", \")\");\n-            for (Object pkValue : pkValuesMap.get(pkKey)) {\n-                pkValuesJoiner.add(\"?\");\n-            }\n-            sql.append(pkValuesJoiner.toString());\n-        }\n+        // build check sql\n+        String firstKey = pkValuesMap.keySet().stream().findFirst().get();\n+        int rowSize = pkValuesMap.get(firstKey).size();\n+        sql.append(SqlGenerateUtils.buildWhereConditionByPKs(pkColumnNameList, rowSize, getDbType()));\n \n         PreparedStatement ps = null;\n         ResultSet rs = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcyMTc4Mw==", "url": "https://github.com/seata/seata/pull/2398#discussion_r447721783", "bodyText": "StringUtils.empty", "author": "slievrly", "createdAt": "2020-06-30T14:21:16Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/DataCompareUtils.java", "diffHunk": "@@ -180,20 +182,28 @@ private static void convertType(Field f0, Field f1) {\n         return Result.ok();\n     }\n \n-    private static Map<String, Map<String, Field>> rowListToMap(List<Row> rowList, String primaryKey) {\n+    private static Map<String, Map<String, Field>> rowListToMap(List<Row> rowList, List<String> primaryKeyList) {\n         // {value of primaryKey, value of all columns}\n         Map<String, Map<String, Field>> rowMap = new HashMap<>();\n         for (Row row : rowList) {\n+            //ensure the order of column\n+            List<Field> rowFieldList = row.getFields().stream()\n+                    .sorted(Comparator.comparing(Field::getName))\n+                    .collect(Collectors.toList());\n             // {uppercase fieldName : field}\n             Map<String, Field> colsMap = new HashMap<>();\n-            String rowKey = null;\n-            for (int j = 0; j < row.getFields().size(); j++) {\n-                Field field = row.getFields().get(j);\n-                if (field.getName().equalsIgnoreCase(primaryKey)) {\n-                    rowKey = String.valueOf(field.getValue());\n+            String rowKey = new String();", "originalCommit": "f553f4d2ecbf4a351d7bbc39b5e5b6c2f224d893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMTMzOA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r448101338", "bodyText": "ok", "author": "0000005", "createdAt": "2020-07-01T03:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcyMTc4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/DataCompareUtils.java b/rm-datasource/src/main/java/io/seata/rm/datasource/DataCompareUtils.java\nindex a5ae1e7bb1..4e1ec2903e 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/DataCompareUtils.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/DataCompareUtils.java\n\n@@ -182,7 +182,7 @@ public class DataCompareUtils {\n         return Result.ok();\n     }\n \n-    private static Map<String, Map<String, Field>> rowListToMap(List<Row> rowList, List<String> primaryKeyList) {\n+    public static Map<String, Map<String, Field>> rowListToMap(List<Row> rowList, List<String> primaryKeyList) {\n         // {value of primaryKey, value of all columns}\n         Map<String, Map<String, Field>> rowMap = new HashMap<>();\n         for (Row row : rowList) {\n"}}, {"oid": "b8028e31eba42784d1eb57b5d5616023f00918a2", "url": "https://github.com/seata/seata/commit/b8028e31eba42784d1eb57b5d5616023f00918a2", "message": "resolve review", "committedDate": "2020-07-01T07:02:47Z", "type": "commit"}, {"oid": "7a1f98ea4d72bbd38a8011d8e55495e393ca2666", "url": "https://github.com/seata/seata/commit/7a1f98ea4d72bbd38a8011d8e55495e393ca2666", "message": "Merge remote-tracking branch 'myGithub/multi-pk_based_on_1.1.0' into multi-pk_based_on_1.1.0", "committedDate": "2020-07-01T07:03:41Z", "type": "commit"}, {"oid": "d3351b566bfb9a66a4fe211c7893b04c255f618e", "url": "https://github.com/seata/seata/commit/d3351b566bfb9a66a4fe211c7893b04c255f618e", "message": "optimize import", "committedDate": "2020-07-01T07:09:02Z", "type": "commit"}, {"oid": "76eaaf169a6c3b5dd459c9f42018ce28085ff5aa", "url": "https://github.com/seata/seata/commit/76eaaf169a6c3b5dd459c9f42018ce28085ff5aa", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-07-01T07:57:56Z", "type": "commit"}, {"oid": "473b6703a5a3147bc4a1dd9bf520f1160e3bd8fd", "url": "https://github.com/seata/seata/commit/473b6703a5a3147bc4a1dd9bf520f1160e3bd8fd", "message": "fix test cases", "committedDate": "2020-07-01T08:50:42Z", "type": "commit"}, {"oid": "813020914058e4a043a5b9ec21525b4e5b2d5638", "url": "https://github.com/seata/seata/commit/813020914058e4a043a5b9ec21525b4e5b2d5638", "message": "Merge remote-tracking branch 'myGithub/multi-pk_based_on_1.1.0' into multi-pk_based_on_1.1.0", "committedDate": "2020-07-01T08:51:22Z", "type": "commit"}, {"oid": "7d755a20d7352b030195e161830f355c9022aa96", "url": "https://github.com/seata/seata/commit/7d755a20d7352b030195e161830f355c9022aa96", "message": "fix oracle build sql\nfix comments", "committedDate": "2020-07-01T09:17:22Z", "type": "commit"}, {"oid": "7ac27435fedb86a2e82381878d628d55c84f0758", "url": "https://github.com/seata/seata/commit/7ac27435fedb86a2e82381878d628d55c84f0758", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-07-01T09:24:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyNTc0OA==", "url": "https://github.com/seata/seata/pull/2398#discussion_r444025748", "bodyText": "You can not use\nrecognizer.getInsertColumns()\n\nfor key of the map from sqlRecognizer.\nBecause they come from users, they may look different from different time, for example the column name 'stock', it would like below\n`stock`\nstock\nStock\nSTOCK", "author": "l81893521", "createdAt": "2020-06-23T07:43:22Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java", "diffHunk": "@@ -94,102 +99,122 @@ protected boolean containsColumns() {\n     }\n \n     /**\n-     * get primary key column index.\n-     * @return -1: not found.\n+     * get pk index\n+     * @return the key is pk column name and the value is index of the pk column\n      */\n-    protected int getPkIndex() {\n+    protected Map<String,Integer> getPkIndex() {", "originalCommit": "746f6dcf83991422cf5769b4ca873b6b45875832", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b8028e31eba42784d1eb57b5d5616023f00918a2", "chunk": "diff --git a/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java b/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java\nindex d5661aa3cf..7b418e2a1e 100644\n--- a/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java\n+++ b/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java\n\n@@ -109,8 +109,9 @@ public abstract class BaseInsertExecutor<T, S extends Statement> extends Abstrac\n         if (CollectionUtils.isNotEmpty(insertColumns)) {\n             final int insertColumnsSize = insertColumns.size();\n             for (int paramIdx = 0; paramIdx < insertColumnsSize; paramIdx++) {\n-                if (containPK(insertColumns.get(paramIdx))) {\n-                    pkIndexMap.put(ColumnUtils.delEscape(insertColumns.get(paramIdx),getDbType()),paramIdx);\n+                String sqlColumnName = insertColumns.get(paramIdx);\n+                if (containPK(sqlColumnName)) {\n+                    pkIndexMap.put(getStandardColumnName(sqlColumnName),paramIdx);\n                 }\n             }\n             return pkIndexMap;\n"}}, {"oid": "ee2ed8f5936f35e34c4d0638de3bdb77782a9bfe", "url": "https://github.com/seata/seata/commit/ee2ed8f5936f35e34c4d0638de3bdb77782a9bfe", "message": "Merge branch 'develop' into multi-pk_based_on_1.1.0", "committedDate": "2020-07-02T12:31:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk4MDc5Mg==", "url": "https://github.com/seata/seata/pull/2398#discussion_r448980792", "bodyText": "why only  mysql?", "author": "slievrly", "createdAt": "2020-07-02T12:56:19Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/AbstractDMLBaseExecutor.java", "diffHunk": "@@ -83,6 +85,10 @@ public T doExecute(Object... args) throws Throwable {\n      * @throws Exception the exception\n      */\n     protected T executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1)", "originalCommit": "ee2ed8f5936f35e34c4d0638de3bdb77782a9bfe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5Mzc1OQ==", "url": "https://github.com/seata/seata/pull/2398#discussion_r448993759", "bodyText": "Is it in the wrong place?", "author": "slievrly", "createdAt": "2020-07-02T13:16:28Z", "path": "rm-datasource/src/test/java/io/seata/rm/datasource/undo/h2/keyword/H2KeywordChecker.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package io.seata.rm.datasource.undo.h2.keyword;\n+\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.rm.datasource.undo.mysql.keyword.MySQLKeywordChecker;\n+import io.seata.sqlparser.util.JdbcConstants;\n+\n+/**\n+ * @author JerryYin\n+ */\n+@LoadLevel(name = JdbcConstants.H2)", "originalCommit": "ee2ed8f5936f35e34c4d0638de3bdb77782a9bfe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}