{"pr_number": 1920, "pr_title": "GH-1484 rdfstar and sparqlstar support", "pr_createdAt": "2020-02-14T02:58:32Z", "pr_url": "https://github.com/eclipse/rdf4j/pull/1920", "timeline": [{"oid": "86b60e7b7b3769314cf67ce52fc5335be52d9b3e", "url": "https://github.com/eclipse/rdf4j/commit/86b60e7b7b3769314cf67ce52fc5335be52d9b3e", "message": "GH-1484: Minimal RDF* model and parser/writers for Turtle* and TriG*\n\nSigned-off-by: Pavel Mihaylov <pavel@ontotext.com>", "committedDate": "2020-03-19T23:39:04Z", "type": "commit"}, {"oid": "34ecb47212ad8971bd3ede34b023f22db7e0d9dc", "url": "https://github.com/eclipse/rdf4j/commit/34ecb47212ad8971bd3ede34b023f22db7e0d9dc", "message": "GH-1484: Changed SPARQLUpdateDataBlockParser to use TriGStar instead of TriG to support future RDF* data blocks\n\nSigned-off-by: Pavel Mihaylov <pavel@ontotext.com>", "committedDate": "2020-03-19T23:39:04Z", "type": "commit"}, {"oid": "f94dac411b3dbb0a420cb950c37f75a012ab2253", "url": "https://github.com/eclipse/rdf4j/commit/f94dac411b3dbb0a420cb950c37f75a012ab2253", "message": "GH-1484: RDF* <-> RDF reification conversion utility classes and RDF* -> RDF reification support in RDF serializers\n\nSigned-off-by: Pavel Mihaylov <pavel@ontotext.com>", "committedDate": "2020-03-19T23:40:37Z", "type": "commit"}, {"oid": "cc27d527a8d8e6c837c1d474a2182282ab1fb8ff", "url": "https://github.com/eclipse/rdf4j/commit/cc27d527a8d8e6c837c1d474a2182282ab1fb8ff", "message": "GH-1484: RDF* triple support in the HTTP protocol (via NTriplesUtil) and RDF* triple support in the binary RDF result format\n\nSigned-off-by: Pavel Mihaylov <pavel@ontotext.com>", "committedDate": "2020-03-19T23:40:37Z", "type": "commit"}, {"oid": "251c979f835af8f9f995bca85621df0d144944a2", "url": "https://github.com/eclipse/rdf4j/commit/251c979f835af8f9f995bca85621df0d144944a2", "message": "SPARQL grammar update to support SPARQL*\n\nSigned-off-by: damyan.ognyanov <damyan.ognyanov@ontotext.com>", "committedDate": "2020-03-19T23:40:37Z", "type": "commit"}, {"oid": "26a234f8570659ad77e1ab03f183d6ff5002c84d", "url": "https://github.com/eclipse/rdf4j/commit/26a234f8570659ad77e1ab03f183d6ff5002c84d", "message": "GH-1484: RDF* serialization for Binary query results (extended existing format) and two new formats, SPARQL* JSON and SPARQL* TSV\n\n - RDF* compatibility serialization (as IRIs) for all RDF formats\n - Added another MIME type for Turtle* to better reflect its Turtle origin\n - Parser/writer (both RDF and query result) cleanup and contract enforcement, improved tests\n - NTriplesUtil moved outside NTriples module (similar to some other NTriples related classes used in multiple places)\n - Moved Turtle* and TriG* to Turtle and TriG modules instead of separate modules\n - Compare Triple in ValueComparator\n\nSigned-off-by: Pavel Mihaylov <pavel@ontotext.com>", "committedDate": "2020-03-19T23:51:55Z", "type": "commit"}, {"oid": "26a234f8570659ad77e1ab03f183d6ff5002c84d", "url": "https://github.com/eclipse/rdf4j/commit/26a234f8570659ad77e1ab03f183d6ff5002c84d", "message": "GH-1484: RDF* serialization for Binary query results (extended existing format) and two new formats, SPARQL* JSON and SPARQL* TSV\n\n - RDF* compatibility serialization (as IRIs) for all RDF formats\n - Added another MIME type for Turtle* to better reflect its Turtle origin\n - Parser/writer (both RDF and query result) cleanup and contract enforcement, improved tests\n - NTriplesUtil moved outside NTriples module (similar to some other NTriples related classes used in multiple places)\n - Moved Turtle* and TriG* to Turtle and TriG modules instead of separate modules\n - Compare Triple in ValueComparator\n\nSigned-off-by: Pavel Mihaylov <pavel@ontotext.com>", "committedDate": "2020-03-19T23:51:55Z", "type": "forcePushed"}, {"oid": "2ce1a86dfc19e209eb360f7d03702ec8125eb942", "url": "https://github.com/eclipse/rdf4j/commit/2ce1a86dfc19e209eb360f7d03702ec8125eb942", "message": "GH-1484 clean up handling of writingStarted check in AbstractRDFWriter\n\n- writingStarted now a private boolean field\n- renamed handleStatementImpl to consumeStatement\n- made consumeStatement concrete no-op method to provide backward\n  compatibility\n\nSigned-off-by: Jeen Broekstra <jeen.broekstra@gmail.com>", "committedDate": "2020-03-21T06:06:05Z", "type": "forcePushed"}, {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342", "url": "https://github.com/eclipse/rdf4j/commit/ccaba597aaa337a243b94f82baa9c35e6b01f342", "message": "GH-1484 clean up handling of writingStarted check in AbstractRDFWriter\n\n- writingStarted now a private boolean field\n- renamed handleStatementImpl to consumeStatement\n- made consumeStatement concrete no-op method to provide backward\n  compatibility\n\nSigned-off-by: Jeen Broekstra <jeen.broekstra@gmail.com>", "committedDate": "2020-03-21T06:06:53Z", "type": "commit"}, {"oid": "ccaba597aaa337a243b94f82baa9c35e6b01f342", "url": "https://github.com/eclipse/rdf4j/commit/ccaba597aaa337a243b94f82baa9c35e6b01f342", "message": "GH-1484 clean up handling of writingStarted check in AbstractRDFWriter\n\n- writingStarted now a private boolean field\n- renamed handleStatementImpl to consumeStatement\n- made consumeStatement concrete no-op method to provide backward\n  compatibility\n\nSigned-off-by: Jeen Broekstra <jeen.broekstra@gmail.com>", "committedDate": "2020-03-21T06:06:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMTMzMA==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396011330", "bodyText": "Could be use the new DynamicModel here?", "author": "hmottestad", "createdAt": "2020-03-21T17:26:32Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "diffHunk": "@@ -753,4 +758,152 @@ private static Model toModel(Iterable<? extends Statement> iterable) {\n \tpublic static Model synchronizedModel(Model toSynchronize) {\n \t\treturn new SynchronizedModel(toSynchronize);\n \t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t *\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creating statements.\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n+\t\tModel reificationModel = new LinkedHashModel();", "originalCommit": "ccaba597aaa337a243b94f82baa9c35e6b01f342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0MDY3OA==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396040678", "bodyText": "I'll have a look, and perhaps also create an overload that accepts a ModelFactory.", "author": "jeenbroekstra", "createdAt": "2020-03-22T00:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMTMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "cc9affbaf26a8a259360592015b01aa0eeab9cfb", "chunk": "diff --git a/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java b/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java\nindex bfd2cff81a..c9afc36fef 100644\n--- a/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java\n+++ b/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java\n\n@@ -738,172 +950,4 @@ public class Models {\n \n \t}\n \n-\t/**\n-\t * Creates a {@link Supplier} of {@link ModelException} objects that be passed to\n-\t * {@link Optional#orElseThrow(Supplier)} to generate exceptions as necessary.\n-\t *\n-\t * @param message The message to be used for the exception\n-\t * @return A {@link Supplier} that will create {@link ModelException} objects with the given message.\n-\t */\n-\tpublic static Supplier<ModelException> modelException(String message) {\n-\t\treturn () -> new ModelException(message);\n-\t}\n-\n-\t/**\n-\t * Make a model thread-safe by synchronizing all its methods. Iterators will still not be thread-safe!\n-\t *\n-\t * @param toSynchronize the model that should be synchronized\n-\t * @return Synchronized Model\n-\t */\n-\tpublic static Model synchronizedModel(Model toSynchronize) {\n-\t\treturn new SynchronizedModel(toSynchronize);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf       the {@link ValueFactory} to use for creating statements.\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n-\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t *\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n-\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to an RDF reification model.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf    the {@link ValueFactory} to use for creating statements.\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n-\t\tModel reificationModel = new LinkedHashModel();\n-\t\tconvertRDFStarToReification(vf, model, reificationModel::add);\n-\t\treturn reificationModel;\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to an RDF reification model.\n-\t *\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertRDFStarToReification(Model model) {\n-\t\treturn convertRDFStarToReification(SimpleValueFactory.getInstance(), model);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf       the {@link ValueFactory} to use for creating statements.\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertReificationToRDFStar(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n-\t\tMap<Resource, Triple> convertedStatements = new HashMap<>();\n-\t\tmodel.filter(null, RDF.TYPE, RDF.STATEMENT).forEach((s) -> {\n-\t\t\tValue subject = object(model.filter(s.getSubject(), RDF.SUBJECT, null)).orElse(null);\n-\t\t\tif (!(subject instanceof IRI) && !(subject instanceof BNode)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tValue predicate = object(model.filter(s.getSubject(), RDF.PREDICATE, null)).orElse(null);\n-\t\t\tif (!(predicate instanceof IRI)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tValue object = object(model.filter(s.getSubject(), RDF.OBJECT, null)).orElse(null);\n-\t\t\tif (!(object instanceof Value)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tTriple t = vf.createTriple((Resource) subject, (IRI) predicate, object);\n-\t\t\tconvertedStatements.put(s.getSubject(), t);\n-\t\t});\n-\n-\t\tfor (Map.Entry<Resource, Triple> e : convertedStatements.entrySet()) {\n-\t\t\tTriple t = e.getValue();\n-\t\t\tResource subject = convertedStatements.get(t.getSubject());\n-\t\t\tResource object = convertedStatements.get(t.getObject());\n-\t\t\tif (subject != null || object != null) {\n-\t\t\t\t// Triples within triples, replace them in the map\n-\t\t\t\tTriple nt = vf.createTriple(subject != null ? subject : t.getSubject(), t.getPredicate(),\n-\t\t\t\t\t\tobject != null ? object : t.getObject());\n-\t\t\t\te.setValue(nt);\n-\t\t\t}\n-\t\t}\n-\n-\t\tmodel.forEach((s) -> {\n-\t\t\tResource subject = s.getSubject();\n-\t\t\tIRI predicate = s.getPredicate();\n-\t\t\tValue object = s.getObject();\n-\t\t\tTriple subjectTriple = convertedStatements.get(subject);\n-\t\t\tTriple objectTriple = convertedStatements.get(object);\n-\n-\t\t\tif (subjectTriple == null && objectTriple == null) {\n-\t\t\t\t// Statement not part of detected reification, add it as is\n-\t\t\t\tconsumer.accept(s);\n-\t\t\t} else if (subjectTriple == null || ((!RDF.TYPE.equals(predicate) || !RDF.STATEMENT.equals(object))\n-\t\t\t\t\t&& !RDF.SUBJECT.equals(predicate) && !RDF.PREDICATE.equals(predicate)\n-\t\t\t\t\t&& !RDF.OBJECT.equals(predicate))) {\n-\t\t\t\t// Statement uses reified data and needs to be converted\n-\t\t\t\tStatement ns = vf.createStatement(subjectTriple != null ? subjectTriple : s.getSubject(),\n-\t\t\t\t\t\ts.getPredicate(), objectTriple != null ? objectTriple : s.getObject(), s.getContext());\n-\t\t\t\tconsumer.accept(ns);\n-\t\t\t} // else: Statement part of reification and needs to be removed (skipped)\n-\t\t});\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t *\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertReificationToRDFStar(Model model, Consumer<Statement> consumer) {\n-\t\tconvertReificationToRDFStar(SimpleValueFactory.getInstance(), model, consumer);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to an RDF* model.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf    the {@link ValueFactory} to use for creating statements.\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertReificationToRDFStar(ValueFactory vf, Model model) {\n-\t\tModel rdfStarModel = new LinkedHashModel();\n-\t\tconvertReificationToRDFStar(vf, model, rdfStarModel::add);\n-\t\treturn rdfStarModel;\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to an RDF* model.\n-\t *\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertReificationToRDFStar(Model model) {\n-\t\treturn convertReificationToRDFStar(SimpleValueFactory.getInstance(), model);\n-\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMTY3Mw==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396011673", "bodyText": "This kind of use of .filter(....) shows that we really need a .select(...) instead. I think .filter(....) is too heavyweight with all its guarantees about returning a model that reflects the underlying model...while all we really need here is at iterator.", "author": "hmottestad", "createdAt": "2020-03-21T17:30:39Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "diffHunk": "@@ -753,4 +758,152 @@ private static Model toModel(Iterable<? extends Statement> iterable) {\n \tpublic static Model synchronizedModel(Model toSynchronize) {\n \t\treturn new SynchronizedModel(toSynchronize);\n \t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t *\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creating statements.\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n+\t\tModel reificationModel = new LinkedHashModel();\n+\t\tconvertRDFStarToReification(vf, model, reificationModel::add);\n+\t\treturn reificationModel;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t *\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(Model model) {\n+\t\treturn convertRDFStarToReification(SimpleValueFactory.getInstance(), model);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertReificationToRDFStar(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tMap<Resource, Triple> convertedStatements = new HashMap<>();\n+\t\tmodel.filter(null, RDF.TYPE, RDF.STATEMENT).forEach((s) -> {\n+\t\t\tValue subject = object(model.filter(s.getSubject(), RDF.SUBJECT, null)).orElse(null);", "originalCommit": "ccaba597aaa337a243b94f82baa9c35e6b01f342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjI5MQ==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396012291", "bodyText": "I think it might be faster to have a java switch over model.filter(s.getSubject(), null, null) instead of doing a model.filter for each.", "author": "hmottestad", "createdAt": "2020-03-21T17:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMTY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0MDYzOA==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396040638", "bodyText": "This kind of use of .filter(....) shows that we really need a .select(...) instead. I think .filter(....) is too heavyweight with all its guarantees about returning a model that reflects the underlying model...while all we really need here is at iterator.\n\nAgreed. Issue logged: #2030", "author": "jeenbroekstra", "createdAt": "2020-03-22T00:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMTY3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "cc9affbaf26a8a259360592015b01aa0eeab9cfb", "chunk": "diff --git a/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java b/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java\nindex bfd2cff81a..c9afc36fef 100644\n--- a/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java\n+++ b/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java\n\n@@ -738,172 +950,4 @@ public class Models {\n \n \t}\n \n-\t/**\n-\t * Creates a {@link Supplier} of {@link ModelException} objects that be passed to\n-\t * {@link Optional#orElseThrow(Supplier)} to generate exceptions as necessary.\n-\t *\n-\t * @param message The message to be used for the exception\n-\t * @return A {@link Supplier} that will create {@link ModelException} objects with the given message.\n-\t */\n-\tpublic static Supplier<ModelException> modelException(String message) {\n-\t\treturn () -> new ModelException(message);\n-\t}\n-\n-\t/**\n-\t * Make a model thread-safe by synchronizing all its methods. Iterators will still not be thread-safe!\n-\t *\n-\t * @param toSynchronize the model that should be synchronized\n-\t * @return Synchronized Model\n-\t */\n-\tpublic static Model synchronizedModel(Model toSynchronize) {\n-\t\treturn new SynchronizedModel(toSynchronize);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf       the {@link ValueFactory} to use for creating statements.\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n-\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t *\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n-\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to an RDF reification model.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf    the {@link ValueFactory} to use for creating statements.\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n-\t\tModel reificationModel = new LinkedHashModel();\n-\t\tconvertRDFStarToReification(vf, model, reificationModel::add);\n-\t\treturn reificationModel;\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to an RDF reification model.\n-\t *\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertRDFStarToReification(Model model) {\n-\t\treturn convertRDFStarToReification(SimpleValueFactory.getInstance(), model);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf       the {@link ValueFactory} to use for creating statements.\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertReificationToRDFStar(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n-\t\tMap<Resource, Triple> convertedStatements = new HashMap<>();\n-\t\tmodel.filter(null, RDF.TYPE, RDF.STATEMENT).forEach((s) -> {\n-\t\t\tValue subject = object(model.filter(s.getSubject(), RDF.SUBJECT, null)).orElse(null);\n-\t\t\tif (!(subject instanceof IRI) && !(subject instanceof BNode)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tValue predicate = object(model.filter(s.getSubject(), RDF.PREDICATE, null)).orElse(null);\n-\t\t\tif (!(predicate instanceof IRI)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tValue object = object(model.filter(s.getSubject(), RDF.OBJECT, null)).orElse(null);\n-\t\t\tif (!(object instanceof Value)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tTriple t = vf.createTriple((Resource) subject, (IRI) predicate, object);\n-\t\t\tconvertedStatements.put(s.getSubject(), t);\n-\t\t});\n-\n-\t\tfor (Map.Entry<Resource, Triple> e : convertedStatements.entrySet()) {\n-\t\t\tTriple t = e.getValue();\n-\t\t\tResource subject = convertedStatements.get(t.getSubject());\n-\t\t\tResource object = convertedStatements.get(t.getObject());\n-\t\t\tif (subject != null || object != null) {\n-\t\t\t\t// Triples within triples, replace them in the map\n-\t\t\t\tTriple nt = vf.createTriple(subject != null ? subject : t.getSubject(), t.getPredicate(),\n-\t\t\t\t\t\tobject != null ? object : t.getObject());\n-\t\t\t\te.setValue(nt);\n-\t\t\t}\n-\t\t}\n-\n-\t\tmodel.forEach((s) -> {\n-\t\t\tResource subject = s.getSubject();\n-\t\t\tIRI predicate = s.getPredicate();\n-\t\t\tValue object = s.getObject();\n-\t\t\tTriple subjectTriple = convertedStatements.get(subject);\n-\t\t\tTriple objectTriple = convertedStatements.get(object);\n-\n-\t\t\tif (subjectTriple == null && objectTriple == null) {\n-\t\t\t\t// Statement not part of detected reification, add it as is\n-\t\t\t\tconsumer.accept(s);\n-\t\t\t} else if (subjectTriple == null || ((!RDF.TYPE.equals(predicate) || !RDF.STATEMENT.equals(object))\n-\t\t\t\t\t&& !RDF.SUBJECT.equals(predicate) && !RDF.PREDICATE.equals(predicate)\n-\t\t\t\t\t&& !RDF.OBJECT.equals(predicate))) {\n-\t\t\t\t// Statement uses reified data and needs to be converted\n-\t\t\t\tStatement ns = vf.createStatement(subjectTriple != null ? subjectTriple : s.getSubject(),\n-\t\t\t\t\t\ts.getPredicate(), objectTriple != null ? objectTriple : s.getObject(), s.getContext());\n-\t\t\t\tconsumer.accept(ns);\n-\t\t\t} // else: Statement part of reification and needs to be removed (skipped)\n-\t\t});\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t *\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertReificationToRDFStar(Model model, Consumer<Statement> consumer) {\n-\t\tconvertReificationToRDFStar(SimpleValueFactory.getInstance(), model, consumer);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to an RDF* model.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf    the {@link ValueFactory} to use for creating statements.\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertReificationToRDFStar(ValueFactory vf, Model model) {\n-\t\tModel rdfStarModel = new LinkedHashModel();\n-\t\tconvertReificationToRDFStar(vf, model, rdfStarModel::add);\n-\t\treturn rdfStarModel;\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to an RDF* model.\n-\t *\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertReificationToRDFStar(Model model) {\n-\t\treturn convertReificationToRDFStar(SimpleValueFactory.getInstance(), model);\n-\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjU3OA==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396012578", "bodyText": "DynamicModel", "author": "hmottestad", "createdAt": "2020-03-21T17:41:38Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java", "diffHunk": "@@ -753,4 +758,152 @@ private static Model toModel(Iterable<? extends Statement> iterable) {\n \tpublic static Model synchronizedModel(Model toSynchronize) {\n \t\treturn new SynchronizedModel(toSynchronize);\n \t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t *\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n+\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creating statements.\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n+\t\tModel reificationModel = new LinkedHashModel();\n+\t\tconvertRDFStarToReification(vf, model, reificationModel::add);\n+\t\treturn reificationModel;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF* model to an RDF reification model.\n+\t *\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertRDFStarToReification(Model model) {\n+\t\treturn convertRDFStarToReification(SimpleValueFactory.getInstance(), model);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf       the {@link ValueFactory} to use for creating statements.\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertReificationToRDFStar(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n+\t\tMap<Resource, Triple> convertedStatements = new HashMap<>();\n+\t\tmodel.filter(null, RDF.TYPE, RDF.STATEMENT).forEach((s) -> {\n+\t\t\tValue subject = object(model.filter(s.getSubject(), RDF.SUBJECT, null)).orElse(null);\n+\t\t\tif (!(subject instanceof IRI) && !(subject instanceof BNode)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tValue predicate = object(model.filter(s.getSubject(), RDF.PREDICATE, null)).orElse(null);\n+\t\t\tif (!(predicate instanceof IRI)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tValue object = object(model.filter(s.getSubject(), RDF.OBJECT, null)).orElse(null);\n+\t\t\tif (!(object instanceof Value)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tTriple t = vf.createTriple((Resource) subject, (IRI) predicate, object);\n+\t\t\tconvertedStatements.put(s.getSubject(), t);\n+\t\t});\n+\n+\t\tfor (Map.Entry<Resource, Triple> e : convertedStatements.entrySet()) {\n+\t\t\tTriple t = e.getValue();\n+\t\t\tResource subject = convertedStatements.get(t.getSubject());\n+\t\t\tResource object = convertedStatements.get(t.getObject());\n+\t\t\tif (subject != null || object != null) {\n+\t\t\t\t// Triples within triples, replace them in the map\n+\t\t\t\tTriple nt = vf.createTriple(subject != null ? subject : t.getSubject(), t.getPredicate(),\n+\t\t\t\t\t\tobject != null ? object : t.getObject());\n+\t\t\t\te.setValue(nt);\n+\t\t\t}\n+\t\t}\n+\n+\t\tmodel.forEach((s) -> {\n+\t\t\tResource subject = s.getSubject();\n+\t\t\tIRI predicate = s.getPredicate();\n+\t\t\tValue object = s.getObject();\n+\t\t\tTriple subjectTriple = convertedStatements.get(subject);\n+\t\t\tTriple objectTriple = convertedStatements.get(object);\n+\n+\t\t\tif (subjectTriple == null && objectTriple == null) {\n+\t\t\t\t// Statement not part of detected reification, add it as is\n+\t\t\t\tconsumer.accept(s);\n+\t\t\t} else if (subjectTriple == null || ((!RDF.TYPE.equals(predicate) || !RDF.STATEMENT.equals(object))\n+\t\t\t\t\t&& !RDF.SUBJECT.equals(predicate) && !RDF.PREDICATE.equals(predicate)\n+\t\t\t\t\t&& !RDF.OBJECT.equals(predicate))) {\n+\t\t\t\t// Statement uses reified data and needs to be converted\n+\t\t\t\tStatement ns = vf.createStatement(subjectTriple != null ? subjectTriple : s.getSubject(),\n+\t\t\t\t\t\ts.getPredicate(), objectTriple != null ? objectTriple : s.getObject(), s.getContext());\n+\t\t\t\tconsumer.accept(ns);\n+\t\t\t} // else: Statement part of reification and needs to be removed (skipped)\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n+\t * consumer function.\n+\t *\n+\t * @param model    the {@link Model} to convert.\n+\t * @param consumer the {@link Consumer} function for the produced statements.\n+\t */\n+\tpublic static void convertReificationToRDFStar(Model model, Consumer<Statement> consumer) {\n+\t\tconvertReificationToRDFStar(SimpleValueFactory.getInstance(), model, consumer);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied RDF reification model to an RDF* model.\n+\t * <p>\n+\t * The supplied value factory is used to create all new statements.\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creating statements.\n+\t * @param model the {@link Model} to convert.\n+\t * @return the converted {@link Model}.\n+\t */\n+\tpublic static Model convertReificationToRDFStar(ValueFactory vf, Model model) {\n+\t\tModel rdfStarModel = new LinkedHashModel();", "originalCommit": "ccaba597aaa337a243b94f82baa9c35e6b01f342", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cc9affbaf26a8a259360592015b01aa0eeab9cfb", "chunk": "diff --git a/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java b/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java\nindex bfd2cff81a..c9afc36fef 100644\n--- a/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java\n+++ b/core/model/src/main/java/org/eclipse/rdf4j/model/util/Models.java\n\n@@ -738,172 +950,4 @@ public class Models {\n \n \t}\n \n-\t/**\n-\t * Creates a {@link Supplier} of {@link ModelException} objects that be passed to\n-\t * {@link Optional#orElseThrow(Supplier)} to generate exceptions as necessary.\n-\t *\n-\t * @param message The message to be used for the exception\n-\t * @return A {@link Supplier} that will create {@link ModelException} objects with the given message.\n-\t */\n-\tpublic static Supplier<ModelException> modelException(String message) {\n-\t\treturn () -> new ModelException(message);\n-\t}\n-\n-\t/**\n-\t * Make a model thread-safe by synchronizing all its methods. Iterators will still not be thread-safe!\n-\t *\n-\t * @param toSynchronize the model that should be synchronized\n-\t * @return Synchronized Model\n-\t */\n-\tpublic static Model synchronizedModel(Model toSynchronize) {\n-\t\treturn new SynchronizedModel(toSynchronize);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf       the {@link ValueFactory} to use for creating statements.\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertRDFStarToReification(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n-\t\tmodel.forEach(st -> Statements.convertRDFStarToReification(vf, st, consumer));\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to RDF reification statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t *\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertRDFStarToReification(Model model, Consumer<Statement> consumer) {\n-\t\tconvertRDFStarToReification(SimpleValueFactory.getInstance(), model, consumer);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to an RDF reification model.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf    the {@link ValueFactory} to use for creating statements.\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertRDFStarToReification(ValueFactory vf, Model model) {\n-\t\tModel reificationModel = new LinkedHashModel();\n-\t\tconvertRDFStarToReification(vf, model, reificationModel::add);\n-\t\treturn reificationModel;\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF* model to an RDF reification model.\n-\t *\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertRDFStarToReification(Model model) {\n-\t\treturn convertRDFStarToReification(SimpleValueFactory.getInstance(), model);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf       the {@link ValueFactory} to use for creating statements.\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertReificationToRDFStar(ValueFactory vf, Model model, Consumer<Statement> consumer) {\n-\t\tMap<Resource, Triple> convertedStatements = new HashMap<>();\n-\t\tmodel.filter(null, RDF.TYPE, RDF.STATEMENT).forEach((s) -> {\n-\t\t\tValue subject = object(model.filter(s.getSubject(), RDF.SUBJECT, null)).orElse(null);\n-\t\t\tif (!(subject instanceof IRI) && !(subject instanceof BNode)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tValue predicate = object(model.filter(s.getSubject(), RDF.PREDICATE, null)).orElse(null);\n-\t\t\tif (!(predicate instanceof IRI)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tValue object = object(model.filter(s.getSubject(), RDF.OBJECT, null)).orElse(null);\n-\t\t\tif (!(object instanceof Value)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tTriple t = vf.createTriple((Resource) subject, (IRI) predicate, object);\n-\t\t\tconvertedStatements.put(s.getSubject(), t);\n-\t\t});\n-\n-\t\tfor (Map.Entry<Resource, Triple> e : convertedStatements.entrySet()) {\n-\t\t\tTriple t = e.getValue();\n-\t\t\tResource subject = convertedStatements.get(t.getSubject());\n-\t\t\tResource object = convertedStatements.get(t.getObject());\n-\t\t\tif (subject != null || object != null) {\n-\t\t\t\t// Triples within triples, replace them in the map\n-\t\t\t\tTriple nt = vf.createTriple(subject != null ? subject : t.getSubject(), t.getPredicate(),\n-\t\t\t\t\t\tobject != null ? object : t.getObject());\n-\t\t\t\te.setValue(nt);\n-\t\t\t}\n-\t\t}\n-\n-\t\tmodel.forEach((s) -> {\n-\t\t\tResource subject = s.getSubject();\n-\t\t\tIRI predicate = s.getPredicate();\n-\t\t\tValue object = s.getObject();\n-\t\t\tTriple subjectTriple = convertedStatements.get(subject);\n-\t\t\tTriple objectTriple = convertedStatements.get(object);\n-\n-\t\t\tif (subjectTriple == null && objectTriple == null) {\n-\t\t\t\t// Statement not part of detected reification, add it as is\n-\t\t\t\tconsumer.accept(s);\n-\t\t\t} else if (subjectTriple == null || ((!RDF.TYPE.equals(predicate) || !RDF.STATEMENT.equals(object))\n-\t\t\t\t\t&& !RDF.SUBJECT.equals(predicate) && !RDF.PREDICATE.equals(predicate)\n-\t\t\t\t\t&& !RDF.OBJECT.equals(predicate))) {\n-\t\t\t\t// Statement uses reified data and needs to be converted\n-\t\t\t\tStatement ns = vf.createStatement(subjectTriple != null ? subjectTriple : s.getSubject(),\n-\t\t\t\t\t\ts.getPredicate(), objectTriple != null ? objectTriple : s.getObject(), s.getContext());\n-\t\t\t\tconsumer.accept(ns);\n-\t\t\t} // else: Statement part of reification and needs to be removed (skipped)\n-\t\t});\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to RDF* statements. The converted statements are sent to the supplied\n-\t * consumer function.\n-\t *\n-\t * @param model    the {@link Model} to convert.\n-\t * @param consumer the {@link Consumer} function for the produced statements.\n-\t */\n-\tpublic static void convertReificationToRDFStar(Model model, Consumer<Statement> consumer) {\n-\t\tconvertReificationToRDFStar(SimpleValueFactory.getInstance(), model, consumer);\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to an RDF* model.\n-\t * <p>\n-\t * The supplied value factory is used to create all new statements.\n-\t *\n-\t * @param vf    the {@link ValueFactory} to use for creating statements.\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertReificationToRDFStar(ValueFactory vf, Model model) {\n-\t\tModel rdfStarModel = new LinkedHashModel();\n-\t\tconvertReificationToRDFStar(vf, model, rdfStarModel::add);\n-\t\treturn rdfStarModel;\n-\t}\n-\n-\t/**\n-\t * Converts the supplied RDF reification model to an RDF* model.\n-\t *\n-\t * @param model the {@link Model} to convert.\n-\t * @return the converted {@link Model}.\n-\t */\n-\tpublic static Model convertReificationToRDFStar(Model model) {\n-\t\treturn convertReificationToRDFStar(SimpleValueFactory.getInstance(), model);\n-\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjg2OQ==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396012869", "bodyText": "Does this risk bnode identifiers being really long of the Triple contains a long literal?", "author": "hmottestad", "createdAt": "2020-03-21T17:45:17Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java", "diffHunk": "@@ -26,6 +31,16 @@\n  */\n public class Statements {\n \n+\t/**\n+\t * A {@link Function} that maps {@link Triple} to {@link org.eclipse.rdf4j.model.BNode} consistently. Multiple\n+\t * invocations for the same {@link Triple} will return the same {@link org.eclipse.rdf4j.model.BNode}.\n+\t *\n+\t * The current implementation creates a {@link org.eclipse.rdf4j.model.BNode} by encoding the string representation\n+\t * of the {@link Triple} using base64 URL-safe encoding.\n+\t */\n+\tpublic static Function<Triple, Resource> TRIPLE_BNODE_MAPPER = (t) -> SimpleValueFactory.getInstance()\n+\t\t\t.createBNode(Base64.getUrlEncoder().encodeToString(t.stringValue().getBytes(StandardCharsets.UTF_8)));\n+", "originalCommit": "ccaba597aaa337a243b94f82baa9c35e6b01f342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0MTQwNg==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396041406", "bodyText": "I don't see that as a major issue, but if it becomes a problem we could switch to using a fixed-length message digest hash (MD5) as an alternative. I'd suggest it's YAGNI for now though.", "author": "jeenbroekstra", "createdAt": "2020-03-22T00:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA3NDcxNA==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396074714", "bodyText": "Would collisions be an issue then?", "author": "hmottestad", "createdAt": "2020-03-22T09:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTMxMw==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396159313", "bodyText": "IIRC collision risk of MD5 is 1:2^128. For our purposes safe enough I'd say.", "author": "jeenbroekstra", "createdAt": "2020-03-22T23:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjg2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "cc9affbaf26a8a259360592015b01aa0eeab9cfb", "chunk": "diff --git a/core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java b/core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java\nindex aa583cd7fe..beca06a434 100644\n--- a/core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java\n+++ b/core/model/src/main/java/org/eclipse/rdf4j/model/util/Statements.java\n\n@@ -38,6 +39,7 @@ public class Statements {\n \t * The current implementation creates a {@link org.eclipse.rdf4j.model.BNode} by encoding the string representation\n \t * of the {@link Triple} using base64 URL-safe encoding.\n \t */\n+\t@Experimental\n \tpublic static Function<Triple, Resource> TRIPLE_BNODE_MAPPER = (t) -> SimpleValueFactory.getInstance()\n \t\t\t.createBNode(Base64.getUrlEncoder().encodeToString(t.stringValue().getBytes(StandardCharsets.UTF_8)));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzIxNA==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396013214", "bodyText": "I believe you can use .equals on models and it uses isomorphic underneath.", "author": "hmottestad", "createdAt": "2020-03-21T17:48:12Z", "path": "core/model/src/test/java/org/eclipse/rdf4j/model/util/ModelsTest.java", "diffHunk": "@@ -445,4 +446,77 @@ public void testStripContextsSpecificContext() {\n \t\tassertThat(graph2Stripped.size()).isEqualTo(model1.size());\n \t}\n \n+\t@Test\n+\tpublic void testConvertReificationToRDFStar() {\n+\t\tModel reificationModel = RDFStarTestHelper.createRDFReificationModel();\n+\t\tModel referenceRDFStarModel = RDFStarTestHelper.createRDFStarModel();\n+\n+\t\tModel rdfStarModel1 = Models.convertReificationToRDFStar(VF, reificationModel);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with explicit VF, model-to-model\",\n+\t\t\t\tModels.isomorphic(rdfStarModel1, referenceRDFStarModel));\n+\n+\t\tModel rdfStarModel2 = Models.convertReificationToRDFStar(reificationModel);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with implicit VF, model-to-model\",\n+\t\t\t\tModels.isomorphic(rdfStarModel2, referenceRDFStarModel));\n+\n+\t\tModel rdfStarModel3 = new TreeModel();\n+\t\tModels.convertReificationToRDFStar(VF, reificationModel, rdfStarModel3::add);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with explicit VF, model-to-consumer\",\n+\t\t\t\tModels.isomorphic(rdfStarModel3, referenceRDFStarModel));\n+\n+\t\tModel rdfStarModel4 = new TreeModel();\n+\t\tModels.convertReificationToRDFStar(reificationModel, rdfStarModel4::add);\n+\t\tassertTrue(\"RDF reification conversion to RDF* with implicit VF, model-to-consumer\",\n+\t\t\t\tModels.isomorphic(rdfStarModel4, referenceRDFStarModel));", "originalCommit": "ccaba597aaa337a243b94f82baa9c35e6b01f342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0MTM3NQ==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396041375", "bodyText": "I believe you can use .equals on models and it uses isomorphic underneath.\n\nIt does but I've just checked and we don't actually specify this in the API, as far as I can tell. So I'll leave this explicit for now.", "author": "jeenbroekstra", "createdAt": "2020-03-22T00:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzIxNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzMyNw==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396013327", "bodyText": "{ } is missing", "author": "hmottestad", "createdAt": "2020-03-21T17:49:43Z", "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/IsTripleFunction.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+package org.eclipse.rdf4j.query.algebra.evaluation.function.triple;\n+\n+import org.eclipse.rdf4j.model.Triple;\n+import org.eclipse.rdf4j.model.Value;\n+import org.eclipse.rdf4j.model.ValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.query.algebra.evaluation.ValueExprEvaluationException;\n+import org.eclipse.rdf4j.query.algebra.evaluation.function.Function;\n+\n+/**\n+ * Function that return \"true\"^^xsd:boolean if its argument is RDF* Triple otherwise return \"false\"^^xsd:boolean the\n+ * function's IRI uses RDF namespace to match the other functions in the package\n+ * \n+ * @author damyan.ognyanov\n+ *\n+ */\n+public class IsTripleFunction implements Function {\n+\t@Override\n+\tpublic String getURI() {\n+\t\treturn RDF.NAMESPACE + \"isTriple\";\n+\t}\n+\n+\t@Override\n+\tpublic Value evaluate(ValueFactory vf, Value... args) throws ValueExprEvaluationException {\n+\t\tif (args.length != 1)\n+\t\t\tthrow new ValueExprEvaluationException(\"expect exactly 1 argument\");", "originalCommit": "ccaba597aaa337a243b94f82baa9c35e6b01f342", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cc9affbaf26a8a259360592015b01aa0eeab9cfb", "chunk": "diff --git a/core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/IsTripleFunction.java b/core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/IsTripleFunction.java\nindex 3336cd5d53..56d6a1b2d9 100644\n--- a/core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/IsTripleFunction.java\n+++ b/core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/IsTripleFunction.java\n\n@@ -29,8 +29,9 @@ public class IsTripleFunction implements Function {\n \n \t@Override\n \tpublic Value evaluate(ValueFactory vf, Value... args) throws ValueExprEvaluationException {\n-\t\tif (args.length != 1)\n+\t\tif (args.length != 1) {\n \t\t\tthrow new ValueExprEvaluationException(\"expect exactly 1 argument\");\n+\t\t}\n \t\treturn vf.createLiteral((args[0] instanceof Triple));\n \t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzM2MQ==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396013361", "bodyText": "{ }  is missing", "author": "hmottestad", "createdAt": "2020-03-21T17:50:05Z", "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/StatementFunction.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+package org.eclipse.rdf4j.query.algebra.evaluation.function.triple;\n+\n+import org.eclipse.rdf4j.model.IRI;\n+import org.eclipse.rdf4j.model.Resource;\n+import org.eclipse.rdf4j.model.Value;\n+import org.eclipse.rdf4j.model.ValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.query.algebra.evaluation.ValueExprEvaluationException;\n+import org.eclipse.rdf4j.query.algebra.evaluation.function.Function;\n+\n+/**\n+ * Function constructing RDF* Triple from its 3 arguments reused the IRI of rdf:Statement as name\n+ * \n+ * @author damyan.ognyanov\n+ *\n+ */\n+public class StatementFunction implements Function {\n+\t@Override\n+\tpublic String getURI() {\n+\t\treturn RDF.STATEMENT.toString();\n+\t}\n+\n+\t@Override\n+\tpublic Value evaluate(ValueFactory vf, Value... args) throws ValueExprEvaluationException {\n+\t\tif (args.length != 3)\n+\t\t\tthrow new ValueExprEvaluationException(\"expect exactly 3 arguments\");", "originalCommit": "ccaba597aaa337a243b94f82baa9c35e6b01f342", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cc9affbaf26a8a259360592015b01aa0eeab9cfb", "chunk": "diff --git a/core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/StatementFunction.java b/core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/StatementFunction.java\nindex bae184e792..34f8004b54 100644\n--- a/core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/StatementFunction.java\n+++ b/core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/function/triple/StatementFunction.java\n\n@@ -29,14 +29,18 @@ public class StatementFunction implements Function {\n \n \t@Override\n \tpublic Value evaluate(ValueFactory vf, Value... args) throws ValueExprEvaluationException {\n-\t\tif (args.length != 3)\n+\t\tif (args.length != 3) {\n \t\t\tthrow new ValueExprEvaluationException(\"expect exactly 3 arguments\");\n-\t\tif (!(args[0] instanceof Resource))\n+\t\t}\n+\t\tif (!(args[0] instanceof Resource)) {\n \t\t\tthrow new ValueExprEvaluationException(\"arg1 must be Resource\");\n-\t\tif (!(args[1] instanceof IRI))\n+\t\t}\n+\t\tif (!(args[1] instanceof IRI)) {\n \t\t\tthrow new ValueExprEvaluationException(\"arg2 must be IRI\");\n-\t\tif (!(args[2] instanceof Value))\n+\t\t}\n+\t\tif (!(args[2] instanceof Value)) {\n \t\t\tthrow new ValueExprEvaluationException(\"arg3 must be Value\");\n-\t\treturn vf.createTriple((Resource) args[0], (IRI) args[1], (Value) args[2]);\n+\t\t}\n+\t\treturn vf.createTriple((Resource) args[0], (IRI) args[1], args[2]);\n \t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzQ5MQ==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396013491", "bodyText": "@jeenbroekstra why do we have two ValueComapartors?", "author": "hmottestad", "createdAt": "2020-03-21T17:51:14Z", "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/util/ValueComparator.java", "diffHunk": "@@ -69,8 +70,21 @@ public int compare(Value o1, Value o2) {\n \t\t\treturn 1;\n \t\t}\n \n-\t\t// 4. RDF literals\n-\t\treturn compareLiterals((Literal) o1, (Literal) o2);\n+\t\t// 4. Literals", "originalCommit": "ccaba597aaa337a243b94f82baa9c35e6b01f342", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0MDg2OA==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396040868", "bodyText": "@jeenbroekstra why do we have two ValueComapartors?\n\nI'm probably overlooking something. What other one besides this class do you see?", "author": "jeenbroekstra", "createdAt": "2020-03-22T00:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzQ5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIzNDM0MA==", "url": "https://github.com/eclipse/rdf4j/pull/1920#discussion_r396234340", "bodyText": "Never mind, my fault. I had mistaken the LexicalValueComparator for being SPARQL compliant.", "author": "hmottestad", "createdAt": "2020-03-23T06:29:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMzQ5MQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "cc9affbaf26a8a259360592015b01aa0eeab9cfb", "url": "https://github.com/eclipse/rdf4j/commit/cc9affbaf26a8a259360592015b01aa0eeab9cfb", "message": "GH-1484 ModelFactory injection and javadoc improvements\n\n- marked utility functions as Experimental\n- added method overloads to allow ModelFactory injection\n- use DynamicModel as default implementation\n- editoral changes to javadoc", "committedDate": "2020-03-22T01:09:20Z", "type": "commit"}, {"oid": "b3860257957881ba2408ad01463c0ad8d13d37c9", "url": "https://github.com/eclipse/rdf4j/commit/b3860257957881ba2408ad01463c0ad8d13d37c9", "message": "Merge branch 'develop' into GH-1484-rdfstar", "committedDate": "2020-03-28T00:20:44Z", "type": "commit"}]}