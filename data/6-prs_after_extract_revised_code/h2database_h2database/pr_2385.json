{"pr_number": 2385, "pr_title": "Memory estimate", "pr_createdAt": "2020-01-09T01:02:29Z", "pr_url": "https://github.com/h2database/h2database/pull/2385", "timeline": [{"oid": "fd35f4fd708371fcb1add97c8adff4f9474ac31d", "url": "https://github.com/h2database/h2database/commit/fd35f4fd708371fcb1add97c8adff4f9474ac31d", "message": "Estimate key/value memory", "committedDate": "2020-01-08T00:38:59Z", "type": "commit"}, {"oid": "8a23342d0140f8343e3d16cd7f8c4c4cc0c4cf52", "url": "https://github.com/h2database/h2database/commit/8a23342d0140f8343e3d16cd7f8c4c4cc0c4cf52", "message": "make memory estimation vs. calculation optional", "committedDate": "2020-01-08T00:38:59Z", "type": "commit"}, {"oid": "559d5e5cb52e0696d2c5bea9c2bb92070f0cf1df", "url": "https://github.com/h2database/h2database/commit/559d5e5cb52e0696d2c5bea9c2bb92070f0cf1df", "message": "Update copyright notice", "committedDate": "2020-01-08T00:38:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3Nzc1OQ==", "url": "https://github.com/h2database/h2database/pull/2385#discussion_r364577759", "bodyText": "would be nice to copy/paste the PR description you provided as class javadoc here", "author": "grandinj", "createdAt": "2020-01-09T06:36:41Z", "path": "h2/src/main/org/h2/util/MemoryEstimator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2004-2020 H2 Group. Multiple-Licensed under the MPL 2.0,\n+ * and the EPL 1.0 (https://h2database.com/html/license.html).\n+ * Initial Developer: H2 Group\n+ */\n+package org.h2.util;\n+\n+import static org.h2.engine.Constants.MEMORY_POINTER;\n+import org.h2.mvstore.type.DataType;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Class MemoryEstimator.\n+ * <UL>\n+ * <LI> 12/7/19 10:45 PM initial creation\n+ * </UL>\n+ *\n+ * @author <a href='mailto:andrei.tokar@gmail.com'>Andrei Tokar</a>", "originalCommit": "559d5e5cb52e0696d2c5bea9c2bb92070f0cf1df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97eacd76c100e9829fd58624aa161e762d1f1922", "chunk": "diff --git a/h2/src/main/org/h2/util/MemoryEstimator.java b/h2/src/main/org/h2/util/MemoryEstimator.java\nindex 43a5c359b..8cfe3599e 100644\n--- a/h2/src/main/org/h2/util/MemoryEstimator.java\n+++ b/h2/src/main/org/h2/util/MemoryEstimator.java\n\n@@ -11,54 +11,97 @@\n \n /**\n  * Class MemoryEstimator.\n- * <UL>\n- * <LI> 12/7/19 10:45 PM initial creation\n- * </UL>\n+ *\n+ * Calculation of the amount of memory taken by keys, values and pages of the MVTable\n+ * may become expensive operation for complex data types like Row.\n+ * On the other hand, result of the calculation is used by page cache to limit it's size\n+ * and determine when eviction is needed. Another usage is to trigger auto commit,\n+ * based on amount of unsaved changes. In both cases reasonable (lets say ~30%) approximation\n+ * would be good enough and do the job.\n+ * This class replaces exact calculation with an estimate based on\n+ * a sliding window average of last 256 values.\n+ * If estimation gets close to the exact value, then next N calculations are skipped\n+ * and replaced with the estimate, where N depends on the estimation error.\n  *\n  * @author <a href='mailto:andrei.tokar@gmail.com'>Andrei Tokar</a>\n  */\n public final class MemoryEstimator\n {\n+    // Structure of statsData long value:\n+    // 0 - 7   skip counter (how many more requests will skip calculation and use estimate instead)\n+    // 8 - 23  total number of skips between last 256 calculations\n+    //         (used for sampling percentage calculation only)\n+    // 24      bit is 0 when window is not completely filled yet, 1 when it become full\n+    // 25 - 31 unused\n+    // 32 - 63 sliding window sum of estimated values\n+\n+    private static final int SKIP_SUM_SHIFT = 8;\n+    private static final int COUNTER_MASK = (1 << SKIP_SUM_SHIFT) - 1;\n+    private static final int SKIP_SUM_MASK = 0xFFFF;\n+    private static final int INIT_BIT_SHIFT = 24;\n+    private static final int INIT_BIT = 1 << INIT_BIT_SHIFT;\n+    private static final int WINDOW_SHIFT = 8;\n+    private static final int MAGNITUTE_LIMIT = WINDOW_SHIFT - 1;\n+    private static final int WINDOW_SIZE = 1 << WINDOW_SHIFT;\n+    private static final int WINDOW_HALF_SIZE = WINDOW_SIZE >> 1;\n+    private static final int SUM_SHIFT = 32;\n+\n     private MemoryEstimator() {}\n \n+    /**\n+     * Estimates memory size of the data based on previous values.\n+     * @param stats AtomicLong holding statistical data about the estimated sequence\n+     * @param dataType used for calculation of the next sequence value, if necessary\n+     * @param data which size is to be calculated as the next sequence value, if necessary\n+     * @param <T> type of the data\n+     * @return next estimated or calculated value of the sequence\n+     */\n     public static <T> int estimateMemory(AtomicLong stats, DataType<T> dataType, T data) {\n         long statsData = stats.get();\n-        int counter = (int)(statsData & 0xFF);\n-        int skipSum = (int)((statsData >> 8) & 0xFFFF);\n-        long initialized = statsData & 0x1000000;\n-        long sum = statsData >> 32;\n+        int counter = getCounter(statsData);\n+        int skipSum = getSkipSum(statsData);\n+        long initialized = statsData & INIT_BIT;\n+        long sum = statsData >> SUM_SHIFT;\n         int mem = 0;\n         int cnt = 0;\n         if (initialized == 0 || counter-- == 0) {\n             cnt = 1;\n             mem = data == null ? 0 : dataType.getMemory(data);\n-            long delta = (mem << 8) - sum;\n+            long delta = (mem << WINDOW_SHIFT) - sum;\n             if (initialized == 0) {\n-                if (++counter == 256) {\n-                    initialized = 0x1000000;\n+                if (++counter == WINDOW_SIZE) {\n+                    initialized = INIT_BIT;\n                 }\n                 sum = (sum * counter + delta + (counter >> 1)) / counter;\n             } else {\n                 long absDelta = delta >= 0 ? delta : -delta;\n                 int magnitude = calculateMagnitude(sum, absDelta);\n-                sum += ((delta >> (7 - magnitude)) + 1) >> 1;\n-                counter = ((1 << magnitude) - 1) & 0xFF;\n+                sum += ((delta >> (MAGNITUTE_LIMIT - magnitude)) + 1) >> 1;\n+                counter = ((1 << magnitude) - 1) & COUNTER_MASK;\n \n-                delta = (counter << 8) - skipSum;\n-                skipSum += (delta + 128) >> 8;\n+                delta = (counter << WINDOW_SHIFT) - skipSum;\n+                skipSum += (delta + WINDOW_HALF_SIZE) >> WINDOW_SHIFT;\n             }\n         }\n-        long updatedStatsData = sum << 32 | initialized | (skipSum << 8) | counter;\n-        updatedStatsData = updateStatsData(stats, statsData, updatedStatsData, mem, cnt);\n-        return (int)(updatedStatsData >> 40);\n+        long updatedStatsData = updateStatsData(stats, statsData, counter, skipSum, initialized, sum, cnt, mem);\n+        return getAverage(updatedStatsData);\n     }\n \n+    /**\n+     * Estimates memory size of the data set based on previous values.\n+     * @param stats AtomicLong holding statistical data about the estimated sequence\n+     * @param dataType used for calculation of the next sequence value, if necessary\n+     * @param storage of the data set, which size is to be calculated\n+     * @param count number of data items in the storage\n+     * @param <T> type of the data in the storage\n+     * @return next estimated or calculated size of the storage\n+     */\n     public static <T> int estimateMemory(AtomicLong stats, DataType<T> dataType, T[] storage, int count) {\n         long statsData = stats.get();\n-        int counter = (int)(statsData & 0xFF);\n-        int skipSum = (int)((statsData >> 8) & 0xFFFF);\n-        long initialized = statsData & 0x1000000;\n-        long sum = statsData >> 32;\n+        int counter = getCounter(statsData);\n+        int skipSum = getSkipSum(statsData);\n+        long initialized = statsData & INIT_BIT;\n+        long sum = statsData >> SUM_SHIFT;\n         int indx = 0;\n         int memSum = 0;\n         if (initialized != 0 && counter >= count) {\n"}}, {"oid": "97eacd76c100e9829fd58624aa161e762d1f1922", "url": "https://github.com/h2database/h2database/commit/97eacd76c100e9829fd58624aa161e762d1f1922", "message": "extract constants, javadoc", "committedDate": "2020-01-11T12:46:27Z", "type": "commit"}]}