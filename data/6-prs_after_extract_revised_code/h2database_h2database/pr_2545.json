{"pr_number": 2545, "pr_title": "#2530 improve handling of many AND/OR conditions", "pr_createdAt": "2020-04-06T18:45:56Z", "pr_url": "https://github.com/h2database/h2database/pull/2545", "timeline": [{"oid": "92f0f377a3de66555179a8c477507c0c6d673ec8", "url": "https://github.com/h2database/h2database/commit/92f0f377a3de66555179a8c477507c0c6d673ec8", "message": "#2530 improve handling of many AND/OR conditions\n\ncreate a custom Condition class so we don't need so much stack to process very large AND/OR lists", "committedDate": "2020-04-06T18:45:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxODczNQ==", "url": "https://github.com/h2database/h2database/pull/2545#discussion_r404518735", "bodyText": "Conditions should use castToBoolean(\u2026) to ensure BOOLEAN data type of optimized expression.", "author": "katzyn", "createdAt": "2020-04-07T03:47:46Z", "path": "h2/src/main/org/h2/expression/condition/ConditionAndOrN.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2004-2020 H2 Group. Multiple-Licensed under the MPL 2.0, and the\n+ * EPL 1.0 (https://h2database.com/html/license.html). Initial Developer: H2\n+ * Group\n+ */\n+package org.h2.expression.condition;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import org.h2.engine.Session;\n+import org.h2.expression.Expression;\n+import org.h2.expression.ExpressionVisitor;\n+import org.h2.message.DbException;\n+import org.h2.table.ColumnResolver;\n+import org.h2.table.TableFilter;\n+import org.h2.value.Value;\n+import org.h2.value.ValueBoolean;\n+import org.h2.value.ValueNull;\n+\n+/**\n+ * An 'and' or 'or' condition as in WHERE ID=1 AND NAME=? with N operands.\n+ * Mostly useful for optimisation and preventing stack overflow where generated\n+ * SQL has tons of conditions.\n+ */\n+public class ConditionAndOrN extends Condition {\n+\n+    /**\n+     * The AND condition type as in ID=1 AND NAME='Hello'.\n+     */\n+    public static final int AND = 0;\n+\n+    /**\n+     * The OR condition type as in ID=1 OR NAME='Hello'.\n+     */\n+    public static final int OR = 1;\n+\n+    private final int andOrType;\n+    /**\n+     * Use an ArrayDeque because we primarily insert at the front.\n+     */\n+    private final List<Expression> expressions;\n+\n+    /**\n+     * Additional conditions for index only.\n+     */\n+    private List<Expression> added;\n+\n+    public ConditionAndOrN(int andOrType, Expression expr1, Expression expr2, Expression expr3) {\n+        this.andOrType = andOrType;\n+        this.expressions = new LinkedList<>();\n+        expressions.add(expr1);\n+        expressions.add(expr2);\n+        expressions.add(expr3);\n+    }\n+\n+    public ConditionAndOrN(int andOrType, List<Expression> expressions) {\n+        this.andOrType = andOrType;\n+        this.expressions = expressions;\n+    }\n+\n+    int getAndOrType() {\n+        return andOrType;\n+    }\n+\n+    void addFirst(Expression e) {\n+        expressions.add(0, e);\n+    }\n+\n+    @Override\n+    public StringBuilder getSQL(StringBuilder builder, int sqlFlags) {\n+        builder.append('(');\n+        Iterator<Expression> it = expressions.iterator();\n+        it.next().getSQL(builder, sqlFlags);\n+        while (it.hasNext()) {\n+            switch (andOrType) {\n+            case AND:\n+                builder.append(\"\\n    AND \");\n+                break;\n+            case OR:\n+                builder.append(\"\\n    OR \");\n+                break;\n+            default:\n+                throw DbException.throwInternalError(\"andOrType=\" + andOrType);\n+            }\n+            it.next().getSQL(builder, sqlFlags);\n+        }\n+        builder.append(')');\n+        return builder;\n+    }\n+\n+    @Override\n+    public void createIndexConditions(Session session, TableFilter filter) {\n+        if (andOrType == AND) {\n+            for (Expression e : expressions) {\n+                e.createIndexConditions(session, filter);\n+            }\n+            if (added != null) {\n+                for (Expression e : added) {\n+                    e.createIndexConditions(session, filter);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Expression getNotIfPossible(Session session) {\n+        // (NOT (A OR B)): (NOT(A) AND NOT(B))\n+        // (NOT (A AND B)): (NOT(A) OR NOT(B))\n+        final ArrayList<Expression> newList = new ArrayList<>(expressions.size());\n+        for (Expression e : expressions) {\n+            Expression l = e.getNotIfPossible(session);\n+            if (l == null) {\n+                l = new ConditionNot(e);\n+            }\n+            newList.add(l);\n+        }\n+        int reversed = andOrType == AND ? OR : AND;\n+        return new ConditionAndOrN(reversed, newList);\n+    }\n+\n+    @Override\n+    public Value getValue(Session session) {\n+        switch (andOrType) {\n+        case AND: {\n+            for (Expression e : expressions) {\n+                Value v = e.getValue(session);\n+                if (v == ValueNull.INSTANCE) {\n+                    return ValueBoolean.FALSE;\n+                }\n+                if (!v.getBoolean()) {\n+                    return ValueBoolean.FALSE;\n+                }\n+            }\n+            return ValueBoolean.TRUE;\n+        }\n+        case OR: {\n+            for (Expression e : expressions) {\n+                Value v = e.getValue(session);\n+                if (v == ValueNull.INSTANCE) {\n+                    return ValueBoolean.FALSE;\n+                }\n+                if (v.getBoolean()) {\n+                    return ValueBoolean.TRUE;\n+                }\n+            }\n+            return ValueBoolean.FALSE;\n+        }\n+        default:\n+            throw DbException.throwInternalError(\"type=\" + andOrType);\n+        }\n+    }\n+\n+    private static final Comparator<Expression> COMPARE_BY_COST = new Comparator<Expression>() {\n+        public int compare(Expression lhs, Expression rhs) {\n+            return lhs.getCost() - rhs.getCost();\n+        }\n+        \n+    };\n+\n+    @Override\n+    public Expression optimize(Session session) {        \n+        // NULL handling: see wikipedia,\n+        // http://www-cs-students.stanford.edu/~wlam/compsci/sqlnulls\n+\n+        // first pass, optimize individual sub-expressions\n+        for (int i = 0; i < expressions.size(); i++ ) {\n+            expressions.set(i, expressions.get(i).optimize(session));\n+        }\n+        \n+        Collections.sort(expressions, COMPARE_BY_COST);\n+        \n+        // TODO we're only matching pairs so that are next to each other, so in complex expressions\n+        //   we will miss opportunities\n+\n+        // second pass, optimize combinations\n+        optimizeMerge(0);\n+        for (int i = 1; i < expressions.size(); ) {\n+            Expression left = expressions.get(i-1);\n+            Expression right = expressions.get(i);\n+            switch (andOrType) {\n+            case AND:\n+                if (!session.getDatabase().getSettings().optimizeTwoEquals) {\n+                    break;\n+                }\n+                // this optimization does not work in the following case,\n+                // but NOT is optimized before:\n+                // CREATE TABLE TEST(A INT, B INT);\n+                // INSERT INTO TEST VALUES(1, NULL);\n+                // SELECT * FROM TEST WHERE NOT (B=A AND B=0); // no rows\n+                // SELECT * FROM TEST WHERE NOT (B=A AND B=0 AND A=0); // 1,\n+                // NULL\n+                // try to add conditions (A=B AND B=1: add A=1)\n+                if (left instanceof Comparison && right instanceof Comparison) {\n+                    // try to add conditions (A=B AND B=1: add A=1)\n+                    Expression added = ((Comparison) left).getAdditionalAnd(session, (Comparison) right);\n+                    if (added != null) {\n+                        if (this.added == null) {\n+                            this.added = new ArrayList<>();\n+                        }\n+                        this.added.add(added.optimize(session));\n+                    }\n+                }\n+                break;\n+            case OR:\n+                if (!session.getDatabase().getSettings().optimizeOr) {\n+                    break;\n+                }\n+                Expression reduced;\n+                if (left instanceof Comparison && right instanceof Comparison) {\n+                    reduced = ((Comparison) left).optimizeOr(session, (Comparison) right);\n+                } else if (left instanceof ConditionIn && right instanceof Comparison) {\n+                    reduced = ((ConditionIn) left).getAdditional((Comparison) right);\n+                } else if (right instanceof ConditionIn && left instanceof Comparison) {\n+                    reduced = ((ConditionIn) right).getAdditional((Comparison) left);\n+                } else if (left instanceof ConditionInConstantSet && right instanceof Comparison) {\n+                    reduced = ((ConditionInConstantSet) left).getAdditional(session, (Comparison) right);\n+                } else if (right instanceof ConditionInConstantSet && left instanceof Comparison) {\n+                    reduced = ((ConditionInConstantSet) right).getAdditional(session, (Comparison) left);\n+                } else if (left instanceof ConditionAndOr && right instanceof ConditionAndOr) {\n+                    reduced = ConditionAndOr.optimizeConditionAndOr((ConditionAndOr) left, (ConditionAndOr) right);\n+                } else {\n+                    // TODO optimization: convert .. OR .. to UNION if the cost\n+                    // is lower\n+                    break;\n+                }\n+                if (reduced != null) {\n+                    expressions.remove(i);\n+                    expressions.set(i-1, reduced);\n+                    continue; // because we don't want to increment, we want to compare the new pair exposed\n+                }\n+            }\n+\n+            Expression e = ConditionAndOr.optimizeConstant(session, this, andOrType, left, right);\n+            if (e != this) {\n+                expressions.remove(i);\n+                expressions.set(i-1, e);                \n+                continue; // because we don't want to increment, we want to compare the new pair exposed\n+            }\n+\n+            if (optimizeMerge(i)) {\n+                continue;\n+            }\n+\n+            i++;\n+        }\n+\n+        Collections.sort(expressions, COMPARE_BY_COST);\n+        \n+        if (expressions.size() == 1) {\n+            return expressions.get(0);", "originalCommit": "92f0f377a3de66555179a8c477507c0c6d673ec8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2626000543fb857c17ce9470135337b2cee4693d", "chunk": "diff --git a/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java b/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java\nindex 4bccae2bb..04421ed3b 100644\n--- a/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java\n+++ b/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java\n\n@@ -251,7 +251,7 @@ public Expression optimize(Session session) {\n         Collections.sort(expressions, COMPARE_BY_COST);\n         \n         if (expressions.size() == 1) {\n-            return expressions.get(0);\n+            return Condition.castToBoolean(session, expressions.get(0));\n         }\n         return this;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyMDM2MQ==", "url": "https://github.com/h2database/h2database/pull/2545#discussion_r404520361", "bodyText": "These constants can be removed, we have exactly the same constants in the old class.", "author": "katzyn", "createdAt": "2020-04-07T03:55:26Z", "path": "h2/src/main/org/h2/expression/condition/ConditionAndOrN.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2004-2020 H2 Group. Multiple-Licensed under the MPL 2.0, and the\n+ * EPL 1.0 (https://h2database.com/html/license.html). Initial Developer: H2\n+ * Group\n+ */\n+package org.h2.expression.condition;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import org.h2.engine.Session;\n+import org.h2.expression.Expression;\n+import org.h2.expression.ExpressionVisitor;\n+import org.h2.message.DbException;\n+import org.h2.table.ColumnResolver;\n+import org.h2.table.TableFilter;\n+import org.h2.value.Value;\n+import org.h2.value.ValueBoolean;\n+import org.h2.value.ValueNull;\n+\n+/**\n+ * An 'and' or 'or' condition as in WHERE ID=1 AND NAME=? with N operands.\n+ * Mostly useful for optimisation and preventing stack overflow where generated\n+ * SQL has tons of conditions.\n+ */\n+public class ConditionAndOrN extends Condition {\n+\n+    /**\n+     * The AND condition type as in ID=1 AND NAME='Hello'.\n+     */\n+    public static final int AND = 0;\n+\n+    /**\n+     * The OR condition type as in ID=1 OR NAME='Hello'.\n+     */\n+    public static final int OR = 1;", "originalCommit": "92f0f377a3de66555179a8c477507c0c6d673ec8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2626000543fb857c17ce9470135337b2cee4693d", "chunk": "diff --git a/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java b/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java\nindex 4bccae2bb..04421ed3b 100644\n--- a/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java\n+++ b/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java\n\n@@ -251,7 +251,7 @@ public Expression optimize(Session session) {\n         Collections.sort(expressions, COMPARE_BY_COST);\n         \n         if (expressions.size() == 1) {\n-            return expressions.get(0);\n+            return Condition.castToBoolean(session, expressions.get(0));\n         }\n         return this;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU1OTM1Ng==", "url": "https://github.com/h2database/h2database/pull/2545#discussion_r404559356", "bodyText": "Why a LinkedList is used here and another constructor stores a passed ArrayList? If different implementations really behave better, it should be documented somehow in comments.", "author": "katzyn", "createdAt": "2020-04-07T06:15:29Z", "path": "h2/src/main/org/h2/expression/condition/ConditionAndOrN.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2004-2020 H2 Group. Multiple-Licensed under the MPL 2.0, and the\n+ * EPL 1.0 (https://h2database.com/html/license.html). Initial Developer: H2\n+ * Group\n+ */\n+package org.h2.expression.condition;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import org.h2.engine.Session;\n+import org.h2.expression.Expression;\n+import org.h2.expression.ExpressionVisitor;\n+import org.h2.message.DbException;\n+import org.h2.table.ColumnResolver;\n+import org.h2.table.TableFilter;\n+import org.h2.value.Value;\n+import org.h2.value.ValueBoolean;\n+import org.h2.value.ValueNull;\n+\n+/**\n+ * An 'and' or 'or' condition as in WHERE ID=1 AND NAME=? with N operands.\n+ * Mostly useful for optimisation and preventing stack overflow where generated\n+ * SQL has tons of conditions.\n+ */\n+public class ConditionAndOrN extends Condition {\n+\n+    /**\n+     * The AND condition type as in ID=1 AND NAME='Hello'.\n+     */\n+    public static final int AND = 0;\n+\n+    /**\n+     * The OR condition type as in ID=1 OR NAME='Hello'.\n+     */\n+    public static final int OR = 1;\n+\n+    private final int andOrType;\n+    /**\n+     * Use an ArrayDeque because we primarily insert at the front.\n+     */\n+    private final List<Expression> expressions;\n+\n+    /**\n+     * Additional conditions for index only.\n+     */\n+    private List<Expression> added;\n+\n+    public ConditionAndOrN(int andOrType, Expression expr1, Expression expr2, Expression expr3) {\n+        this.andOrType = andOrType;\n+        this.expressions = new LinkedList<>();", "originalCommit": "92f0f377a3de66555179a8c477507c0c6d673ec8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU2NDIzMQ==", "url": "https://github.com/h2database/h2database/pull/2545#discussion_r404564231", "bodyText": "Good catch, will fix that. Was because at one point in the evolution of the feature I was doing insert at the front.", "author": "grandinj", "createdAt": "2020-04-07T06:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU1OTM1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2626000543fb857c17ce9470135337b2cee4693d", "chunk": "diff --git a/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java b/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java\nindex 4bccae2bb..04421ed3b 100644\n--- a/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java\n+++ b/h2/src/main/org/h2/expression/condition/ConditionAndOrN.java\n\n@@ -251,7 +251,7 @@ public Expression optimize(Session session) {\n         Collections.sort(expressions, COMPARE_BY_COST);\n         \n         if (expressions.size() == 1) {\n-            return expressions.get(0);\n+            return Condition.castToBoolean(session, expressions.get(0));\n         }\n         return this;\n     }\n"}}, {"oid": "2626000543fb857c17ce9470135337b2cee4693d", "url": "https://github.com/h2database/h2database/commit/2626000543fb857c17ce9470135337b2cee4693d", "message": "use castToBoolean", "committedDate": "2020-04-07T10:30:04Z", "type": "commit"}, {"oid": "80d4127081a6d4d34bec9a1bf37b3ce0bbad9e3c", "url": "https://github.com/h2database/h2database/commit/80d4127081a6d4d34bec9a1bf37b3ce0bbad9e3c", "message": "remove duplicate declarations", "committedDate": "2020-04-07T10:31:14Z", "type": "commit"}, {"oid": "98dce64c3d3e1239e2ab59b996a67520d9ecd7e8", "url": "https://github.com/h2database/h2database/commit/98dce64c3d3e1239e2ab59b996a67520d9ecd7e8", "message": "no need to use LinkedList here\n\nwas a leftover from development", "committedDate": "2020-04-07T10:32:04Z", "type": "commit"}, {"oid": "e326823c3c83f8d41cc93cb3d30eed6a1ca9faa1", "url": "https://github.com/h2database/h2database/commit/e326823c3c83f8d41cc93cb3d30eed6a1ca9faa1", "message": "update test script", "committedDate": "2020-04-07T10:35:52Z", "type": "commit"}, {"oid": "cc69fd8d776349afc183d8d4a61439f2d287d924", "url": "https://github.com/h2database/h2database/commit/cc69fd8d776349afc183d8d4a61439f2d287d924", "message": "fix bug\n\ncannot call convertToEnum with a ValueNull", "committedDate": "2020-04-07T15:44:30Z", "type": "commit"}]}