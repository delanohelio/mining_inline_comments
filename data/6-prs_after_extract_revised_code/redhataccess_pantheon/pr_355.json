{"pr_number": 355, "pr_title": "improve management of resources during uploads", "pr_createdAt": "2020-07-28T00:53:13Z", "pr_url": "https://github.com/redhataccess/pantheon/pull/355", "timeline": [{"oid": "0ff8c88e6878555800a4ddcb47c8700473cbc0f1", "url": "https://github.com/redhataccess/pantheon/commit/0ff8c88e6878555800a4ddcb47c8700473cbc0f1", "message": "improve management of resources during uploads\n\na. Use InputStreams when dealing with content\nb. restore the checksum validation to prevent unnecesary load on the JCR repository if there are no changes", "committedDate": "2020-07-28T00:51:07Z", "type": "commit"}, {"oid": "09daa02e61edf382fab6c0092e114ec72cffc2b9", "url": "https://github.com/redhataccess/pantheon/commit/09daa02e61edf382fab6c0092e114ec72cffc2b9", "message": "add a type-safe mechanism to cast fields to other types", "committedDate": "2020-07-28T16:43:16Z", "type": "commit"}, {"oid": "d5bf3b1c225cea477672e36579defa29d2faba22", "url": "https://github.com/redhataccess/pantheon/commit/d5bf3b1c225cea477672e36579defa29d2faba22", "message": "minor code improvement", "committedDate": "2020-07-28T16:48:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyNjM0Nw==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r461826347", "bodyText": "This is interesting. I suppose this is to load the entire stream into memory as a prerequisite to hash. I'm curious if this would necessitate a call to Stream.reset() later or something?", "author": "benradey", "createdAt": "2020-07-28T19:38:42Z", "path": "pantheon-bundle/src/main/java/com/redhat/pantheon/jcr/JcrResources.java", "diffHunk": "@@ -20,11 +23,24 @@ public static void rename(Resource resource, String newName) throws RepositoryEx\n         session.move(resource.getPath(), resource.getParent().getPath() + \"/\" + newName);\n     }\n \n-    /*\n-     * calculates a hash for a string\n+    /**\n+     * calculates a checksum hash for a string using the adler32 algorithm\n      *\n      */\n     public static HashCode hash(String str) {\n         return Hashing.adler32().hashString(str == null ? \"\" : str, Charsets.UTF_8);\n     }\n+\n+    /**\n+     * Calculates a checksum hash for the contents for an input stream usng the adler32 algorithm.\n+     * @param is The input stream. The stream is NOT closed after reading from it.\n+     * @return A {@link HashCode} for the contents of the given InputStream\n+     * @throws IOException If there is a problem accessing the contents of the InputStream\n+     */\n+    public static HashCode hash(InputStream is) throws IOException {\n+        try (HashingInputStream his = new HashingInputStream(Hashing.adler32(), is)) {\n+            while (his.read() != -1) ;", "originalCommit": "d5bf3b1c225cea477672e36579defa29d2faba22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0MjcxOQ==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r461842719", "bodyText": "The use of a HashingInputStream is to avoid loading the entire content into memory; it hashes as it consumes.\nBut you bring up a good point: the stream is potentially useless after it has been consumed. The way we are using it right now is safe as it is being closed, but a comment in the javadoc wouldn't hurt.", "author": "carlosmunoz", "createdAt": "2020-07-28T20:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyNjM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MzAwNA==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r461873004", "bodyText": "Never mind... I did have a comment there already \ud83d\ude0a", "author": "carlosmunoz", "createdAt": "2020-07-28T20:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyNjM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxODU2Mw==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r462518563", "bodyText": "The use of a HashingInputStream is to avoid loading the entire content into memory; it hashes as it consumes.\n\nWell, I understand that's the goal, but while (his.read() != -1) ; makes me think that that's not what's happening. The stream reads until there is nothing left, thereby loading everything into memory, then it hashes. Is that not what's happening?", "author": "benradey", "createdAt": "2020-07-29T18:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyNjM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMTY3MA==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r462521670", "bodyText": "It does read the whole stream, but not into memory. It hashes as it reads, modifying the hash as it consumes the contents. The end result is the same as if the entire content were hashed.", "author": "carlosmunoz", "createdAt": "2020-07-29T19:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyNjM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyNTE4MA==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r462525180", "bodyText": "Ok, so you are asserting that the hashing actually happens in the read() method, and that the subsequent call to hash() doesn't actually do any work, it just returns the precomputed hash. If that's the case, then I'm good with it.", "author": "benradey", "createdAt": "2020-07-29T19:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyNjM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzMDE3Mw==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r462530173", "bodyText": "correct.\nBut this is not because of the HashingInputStream only, it also depends on the hashing function behind it, in this case adler32, which happens to operate in that way you described (confirmed by stepping through it).", "author": "carlosmunoz", "createdAt": "2020-07-29T19:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyNjM0Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzMDQ2Mg==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r461830462", "bodyText": "Interesting that you chose to leave asciidocContent as a String here, rather than reworking it to be an InputStream instead. Was that intentional?", "author": "benradey", "createdAt": "2020-07-28T19:43:54Z", "path": "pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/assembly/AssemblyVersionUpload.java", "diffHunk": "@@ -81,7 +82,7 @@ protected void doRun(SlingHttpServletRequest request, PostResponse response, Lis\n                     .draft().getOrCreate();\n \n             // Check if the content is the same as what is hashed already\n-            HashCode incomingSrcHash = hash(asciidocContent);\n+            HashCode incomingSrcHash = JcrResources.hash(asciidocContent);", "originalCommit": "d5bf3b1c225cea477672e36579defa29d2faba22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzOTIxNg==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r461839216", "bodyText": "The change to use a single checksum hash method is intentional, but I focused on the module uploading initially and not the assembly upload. Perhaps that is the next step after this is reviewed.", "author": "carlosmunoz", "createdAt": "2020-07-28T19:55:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzMDQ2Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzNDI1NQ==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r461834255", "bodyText": "Isn't this fancy! What's going on here? Is this a magic way to convert the Stream to a String so that it can be persisted in the jcr?\nAlso, are you sure this works? My concern is that the Stream has already been consumed by the hashing method, and nothing ever reset it?", "author": "benradey", "createdAt": "2020-07-28T19:48:28Z", "path": "pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/module/ModuleVersionUpload.java", "diffHunk": "@@ -106,14 +105,29 @@ protected void doRun(SlingHttpServletRequest request, PostResponse response, Lis\n                     .draft().getOrCreate();\n \n             // Check if the content is the same as what is hashed already\n-            HashCode incomingSrcHash = hash(asciidocContent);\n+            HashCode incomingSrcHash =\n+                ServletUtils.handleParamAsStream(request, \"asciidoc\",\n+                        inputStream -> {\n+                            try {\n+                                return JcrResources.hash(inputStream);\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        });\n             String storedSrcHash = draftSrc.hash().get();\n             // If the source content is the same, don't update it\n             if(incomingSrcHash.toString().equals( storedSrcHash )) {\n                 responseCode = HttpServletResponse.SC_NOT_MODIFIED;\n             } else {\n-                draftSrc.jcrContent().getOrCreate()\n-                        .jcrData().set(asciidocContent);\n+                ServletUtils.handleParamAsStream(request, \"asciidoc\", encoding,\n+                        inputStream -> {\n+                            Session session = resolver.adaptTo(Session.class);\n+                            draftSrc.jcrContent().getOrCreate()\n+                                    .jcrData().toFieldType(InputStream.class)\n+                                    .set(inputStream);", "originalCommit": "d5bf3b1c225cea477672e36579defa29d2faba22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0MDY0NA==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r461840644", "bodyText": "It's not that magical (you can see that it's just calling some JCR utilities), but it is exactly for the purpose of what you described.\nIt does work (at least tested locally), but now that you ask the question, the input stream is not being closed anywhere so perhaps there is still a memory leak here.", "author": "carlosmunoz", "createdAt": "2020-07-28T19:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzNDI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3NDQxMg==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r461874412", "bodyText": "reviewed again... there are no problems because the input stream is being passed as the argument to the function, and it's being closed in the method after being used up by the function. All good \ud83d\ude0a", "author": "carlosmunoz", "createdAt": "2020-07-28T20:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzNDI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMDgzNQ==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r462520835", "bodyText": "Can you point me to \"the function\" that you are referring to? I am genuinely curious how this works. AFAIK, Sling has to resolve this stream to some base type in order to be able to persist it, but how does it do that? It has no hint in this code that the stream here represents a string. It could be a stream of bytes, or anything, right? Did we write the method that resolves this and we are making that assumption? Or is something else going on?", "author": "benradey", "createdAt": "2020-07-29T19:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzNDI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyNDA0NQ==", "url": "https://github.com/redhataccess/pantheon/pull/355#discussion_r462524045", "bodyText": "You are correct, the input stream can be of anything, and because we are 'setting' an InputStream into a jcr field this results in jackrabbit slurping the contents of the stream into the node's field.\nNow we (as in the caller) determine what stream is being passed to the 'set' method, in this case it's a character stream (UTF-8 or whatever encoding we decided on) directly from the sling request.\nBecause the content is being pushed to the sling API as an nt:file type sling smartly creates a temporary file where it stores the content, and in practice this is the stream that we are getting.", "author": "carlosmunoz", "createdAt": "2020-07-29T19:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzNDI1NQ=="}], "type": "inlineReview", "revised_code": null}]}