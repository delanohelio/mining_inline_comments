{"pr_number": 1212, "pr_title": "issue-557 added automatically span creation for DispatcherTypes: FORWARD, INCLUDE, ERROR", "pr_createdAt": "2020-06-01T18:47:37Z", "pr_url": "https://github.com/elastic/apm-agent-java/pull/1212", "timeline": [{"oid": "e33b14d3c9653ded790ad9609470b83f792a204c", "url": "https://github.com/elastic/apm-agent-java/commit/e33b14d3c9653ded790ad9609470b83f792a204c", "message": "issue-557 added automatically span creation for DispatcherTypes: FORWARD, INCLUDE, ERROR", "committedDate": "2020-06-01T20:01:28Z", "type": "forcePushed"}, {"oid": "722d42a183c275c40baeeac707fcf1c121d790c5", "url": "https://github.com/elastic/apm-agent-java/commit/722d42a183c275c40baeeac707fcf1c121d790c5", "message": "clear", "committedDate": "2020-06-02T11:29:30Z", "type": "forcePushed"}, {"oid": "99a0789c1ecd67af76eef0a2b199311605b892e8", "url": "https://github.com/elastic/apm-agent-java/commit/99a0789c1ecd67af76eef0a2b199311605b892e8", "message": "clear", "committedDate": "2020-06-02T11:35:36Z", "type": "forcePushed"}, {"oid": "6eef95e0b3154103e28940fe58474d994b65ab1e", "url": "https://github.com/elastic/apm-agent-java/commit/6eef95e0b3154103e28940fe58474d994b65ab1e", "message": "added path info for span name of FORWARD, INCLUDE dispatcher types.", "committedDate": "2020-06-09T05:26:35Z", "type": "forcePushed"}, {"oid": "db73c877c9ba112d75d5dd2bff71ecca2c509365", "url": "https://github.com/elastic/apm-agent-java/commit/db73c877c9ba112d75d5dd2bff71ecca2c509365", "message": "delete testTransactionReportingWithErrorHandling test", "committedDate": "2020-06-09T18:52:46Z", "type": "forcePushed"}, {"oid": "ede29338fb5a47532d42ec1b61a46634299cd594", "url": "https://github.com/elastic/apm-agent-java/commit/ede29338fb5a47532d42ec1b61a46634299cd594", "message": "return setFramework", "committedDate": "2020-06-14T20:36:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI4Mjk3Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442282977", "bodyText": "This is allocating four String objects every time. Please use the AbstractSpan#appendToName() API instead (create it before).\nSame for the other ones.", "author": "eyalkoren", "createdAt": "2020-06-18T14:45:38Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n+            final AbstractSpan<?> parent = tracer.getActive();\n+            if (parent != null) {\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                DispatcherType dispatcherType = request.getDispatcherType();\n+                boolean isAllowedType = false;\n+                String spanAction = null, spanName = null;\n+                if (dispatcherType == DispatcherType.FORWARD) {\n+                    String pathInfo = request.getPathInfo();\n+                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);", "originalCommit": "96711728acd8fb3d4b652c676cf29ee656ecd085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwODI4Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r465908282", "bodyText": "repalced with appendToName", "author": "kananindzya", "createdAt": "2020-08-05T18:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI4Mjk3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "db15630aa76758604b14c0b2365512207fd3a1ac", "chunk": "diff --git a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nindex f5d5b2c26..ae738bc14 100644\n--- a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n+++ b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n\n@@ -156,52 +120,29 @@ public class ServletApiAdvice {\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n-        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n-            final AbstractSpan<?> parent = tracer.getActive();\n-            if (parent != null) {\n-                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                DispatcherType dispatcherType = request.getDispatcherType();\n-                boolean isAllowedType = false;\n-                String spanAction = null, spanName = null;\n-                if (dispatcherType == DispatcherType.FORWARD) {\n-                    String pathInfo = request.getPathInfo();\n-                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);\n-                    spanAction = FORWARD_SPAN_ACTION;\n-                    isAllowedType = true;\n-                } else if (dispatcherType == DispatcherType.INCLUDE) {\n-                    Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n-                    spanName = INCLUDE + SPACE + request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH) + (pathInfo != null ? pathInfo : EMPTY);\n-                    spanAction = INCLUDE_SPAN_ACTION;\n-                    isAllowedType = true;\n-                } else if (dispatcherType == DispatcherType.ERROR) {\n-                    spanName = ERROR + SPACE + request.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH);\n-                    spanAction = ERROR_SPAN_ACTION;\n-                    isAllowedType = true;\n-                }\n-                if (isAllowedType && !parent.getNameAsString().equals(spanName)) {\n-                    span = parent.createSpan()\n-                        .withType(SPAN_TYPE)\n-                        .withSubtype(SPAN_SUBTYPE)\n-                        .withAction(spanAction)\n-                        .withName(spanName)\n-                        .activate();\n-                }\n-            }\n         }\n+        return transaction;\n     }\n \n-    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class)\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n     public static void onExitServletService(@Advice.Argument(0) ServletRequest servletRequest,\n                                             @Advice.Argument(1) ServletResponse servletResponse,\n-                                            @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                            @Advice.Local(\"scope\") @Nullable Scope scope,\n+                                            @Advice.Enter @Nullable Object transactionOrScope,\n                                             @Advice.Thrown @Nullable Throwable t,\n-                                            @Advice.This Object thiz,\n-                                            @Advice.Local(\"span\") @Nullable Span span) {\n+                                            @Advice.This Object thiz) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n             return;\n         }\n-        excluded.set(Boolean.FALSE);\n+        Transaction transaction = null;\n+        Scope scope = null;\n+        if (transactionOrScope instanceof Transaction) {\n+            transaction = (Transaction) transactionOrScope;\n+        } else if (transactionOrScope instanceof Scope) {\n+            scope = (Scope) transactionOrScope;\n+        }\n+\n+        excluded.set(FALSE);\n         if (scope != null) {\n             scope.close();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5MTE2Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442291166", "bodyText": "This else statement looks misplaced. Its content should go inside the if above and you can do else with the servletRequest.getDispatcherType() == DispatcherType.REQUEST check.", "author": "eyalkoren", "createdAt": "2020-06-18T14:56:27Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {", "originalCommit": "96711728acd8fb3d4b652c676cf29ee656ecd085", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db15630aa76758604b14c0b2365512207fd3a1ac", "chunk": "diff --git a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nindex f5d5b2c26..ae738bc14 100644\n--- a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n+++ b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n\n@@ -156,52 +120,29 @@ public class ServletApiAdvice {\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n-        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n-            final AbstractSpan<?> parent = tracer.getActive();\n-            if (parent != null) {\n-                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                DispatcherType dispatcherType = request.getDispatcherType();\n-                boolean isAllowedType = false;\n-                String spanAction = null, spanName = null;\n-                if (dispatcherType == DispatcherType.FORWARD) {\n-                    String pathInfo = request.getPathInfo();\n-                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);\n-                    spanAction = FORWARD_SPAN_ACTION;\n-                    isAllowedType = true;\n-                } else if (dispatcherType == DispatcherType.INCLUDE) {\n-                    Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n-                    spanName = INCLUDE + SPACE + request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH) + (pathInfo != null ? pathInfo : EMPTY);\n-                    spanAction = INCLUDE_SPAN_ACTION;\n-                    isAllowedType = true;\n-                } else if (dispatcherType == DispatcherType.ERROR) {\n-                    spanName = ERROR + SPACE + request.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH);\n-                    spanAction = ERROR_SPAN_ACTION;\n-                    isAllowedType = true;\n-                }\n-                if (isAllowedType && !parent.getNameAsString().equals(spanName)) {\n-                    span = parent.createSpan()\n-                        .withType(SPAN_TYPE)\n-                        .withSubtype(SPAN_SUBTYPE)\n-                        .withAction(spanAction)\n-                        .withName(spanName)\n-                        .activate();\n-                }\n-            }\n         }\n+        return transaction;\n     }\n \n-    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class)\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n     public static void onExitServletService(@Advice.Argument(0) ServletRequest servletRequest,\n                                             @Advice.Argument(1) ServletResponse servletResponse,\n-                                            @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                            @Advice.Local(\"scope\") @Nullable Scope scope,\n+                                            @Advice.Enter @Nullable Object transactionOrScope,\n                                             @Advice.Thrown @Nullable Throwable t,\n-                                            @Advice.This Object thiz,\n-                                            @Advice.Local(\"span\") @Nullable Span span) {\n+                                            @Advice.This Object thiz) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n             return;\n         }\n-        excluded.set(Boolean.FALSE);\n+        Transaction transaction = null;\n+        Scope scope = null;\n+        if (transactionOrScope instanceof Transaction) {\n+            transaction = (Transaction) transactionOrScope;\n+        } else if (transactionOrScope instanceof Scope) {\n+            scope = (Scope) transactionOrScope;\n+        }\n+\n+        excluded.set(FALSE);\n         if (scope != null) {\n             scope.close();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5ODQzMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442298433", "bodyText": "Why using RequestDispatcher.FORWARD_SERVLET_PATH in this case? I think we want the error page path. The transaction will contain the original servlet path.", "author": "eyalkoren", "createdAt": "2020-06-18T15:06:55Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n+            final AbstractSpan<?> parent = tracer.getActive();\n+            if (parent != null) {\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                DispatcherType dispatcherType = request.getDispatcherType();\n+                boolean isAllowedType = false;\n+                String spanAction = null, spanName = null;\n+                if (dispatcherType == DispatcherType.FORWARD) {\n+                    String pathInfo = request.getPathInfo();\n+                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = FORWARD_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                    Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                    spanName = INCLUDE + SPACE + request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH) + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = INCLUDE_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.ERROR) {\n+                    spanName = ERROR + SPACE + request.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH);", "originalCommit": "96711728acd8fb3d4b652c676cf29ee656ecd085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwODk5NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r465908994", "bodyText": "changed to getting\nObject servletPath = request.getServletPath();", "author": "kananindzya", "createdAt": "2020-08-05T18:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5ODQzMw=="}], "type": "inlineReview", "revised_code": {"commit": "db15630aa76758604b14c0b2365512207fd3a1ac", "chunk": "diff --git a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nindex f5d5b2c26..ae738bc14 100644\n--- a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n+++ b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n\n@@ -156,52 +120,29 @@ public class ServletApiAdvice {\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n-        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n-            final AbstractSpan<?> parent = tracer.getActive();\n-            if (parent != null) {\n-                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                DispatcherType dispatcherType = request.getDispatcherType();\n-                boolean isAllowedType = false;\n-                String spanAction = null, spanName = null;\n-                if (dispatcherType == DispatcherType.FORWARD) {\n-                    String pathInfo = request.getPathInfo();\n-                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);\n-                    spanAction = FORWARD_SPAN_ACTION;\n-                    isAllowedType = true;\n-                } else if (dispatcherType == DispatcherType.INCLUDE) {\n-                    Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n-                    spanName = INCLUDE + SPACE + request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH) + (pathInfo != null ? pathInfo : EMPTY);\n-                    spanAction = INCLUDE_SPAN_ACTION;\n-                    isAllowedType = true;\n-                } else if (dispatcherType == DispatcherType.ERROR) {\n-                    spanName = ERROR + SPACE + request.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH);\n-                    spanAction = ERROR_SPAN_ACTION;\n-                    isAllowedType = true;\n-                }\n-                if (isAllowedType && !parent.getNameAsString().equals(spanName)) {\n-                    span = parent.createSpan()\n-                        .withType(SPAN_TYPE)\n-                        .withSubtype(SPAN_SUBTYPE)\n-                        .withAction(spanAction)\n-                        .withName(spanName)\n-                        .activate();\n-                }\n-            }\n         }\n+        return transaction;\n     }\n \n-    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class)\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n     public static void onExitServletService(@Advice.Argument(0) ServletRequest servletRequest,\n                                             @Advice.Argument(1) ServletResponse servletResponse,\n-                                            @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                            @Advice.Local(\"scope\") @Nullable Scope scope,\n+                                            @Advice.Enter @Nullable Object transactionOrScope,\n                                             @Advice.Thrown @Nullable Throwable t,\n-                                            @Advice.This Object thiz,\n-                                            @Advice.Local(\"span\") @Nullable Span span) {\n+                                            @Advice.This Object thiz) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n             return;\n         }\n-        excluded.set(Boolean.FALSE);\n+        Transaction transaction = null;\n+        Scope scope = null;\n+        if (transactionOrScope instanceof Transaction) {\n+            transaction = (Transaction) transactionOrScope;\n+        } else if (transactionOrScope instanceof Scope) {\n+            scope = (Scope) transactionOrScope;\n+        }\n+\n+        excluded.set(FALSE);\n         if (scope != null) {\n             scope.close();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMwMDU3MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442300571", "bodyText": "Please check if you already get the Exception object stored in the RequestDispatcher.ERROR_EXCEPTION attribute somewhere else. If not, let's create and send an error here with captureException through the parent span.", "author": "eyalkoren", "createdAt": "2020-06-18T15:10:09Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n+            final AbstractSpan<?> parent = tracer.getActive();\n+            if (parent != null) {\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                DispatcherType dispatcherType = request.getDispatcherType();\n+                boolean isAllowedType = false;\n+                String spanAction = null, spanName = null;\n+                if (dispatcherType == DispatcherType.FORWARD) {\n+                    String pathInfo = request.getPathInfo();\n+                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = FORWARD_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                    Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                    spanName = INCLUDE + SPACE + request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH) + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = INCLUDE_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.ERROR) {\n+                    spanName = ERROR + SPACE + request.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH);\n+                    spanAction = ERROR_SPAN_ACTION;\n+                    isAllowedType = true;", "originalCommit": "96711728acd8fb3d4b652c676cf29ee656ecd085", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db15630aa76758604b14c0b2365512207fd3a1ac", "chunk": "diff --git a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nindex f5d5b2c26..ae738bc14 100644\n--- a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n+++ b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n\n@@ -156,52 +120,29 @@ public class ServletApiAdvice {\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n-        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n-            final AbstractSpan<?> parent = tracer.getActive();\n-            if (parent != null) {\n-                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                DispatcherType dispatcherType = request.getDispatcherType();\n-                boolean isAllowedType = false;\n-                String spanAction = null, spanName = null;\n-                if (dispatcherType == DispatcherType.FORWARD) {\n-                    String pathInfo = request.getPathInfo();\n-                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);\n-                    spanAction = FORWARD_SPAN_ACTION;\n-                    isAllowedType = true;\n-                } else if (dispatcherType == DispatcherType.INCLUDE) {\n-                    Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n-                    spanName = INCLUDE + SPACE + request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH) + (pathInfo != null ? pathInfo : EMPTY);\n-                    spanAction = INCLUDE_SPAN_ACTION;\n-                    isAllowedType = true;\n-                } else if (dispatcherType == DispatcherType.ERROR) {\n-                    spanName = ERROR + SPACE + request.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH);\n-                    spanAction = ERROR_SPAN_ACTION;\n-                    isAllowedType = true;\n-                }\n-                if (isAllowedType && !parent.getNameAsString().equals(spanName)) {\n-                    span = parent.createSpan()\n-                        .withType(SPAN_TYPE)\n-                        .withSubtype(SPAN_SUBTYPE)\n-                        .withAction(spanAction)\n-                        .withName(spanName)\n-                        .activate();\n-                }\n-            }\n         }\n+        return transaction;\n     }\n \n-    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class)\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n     public static void onExitServletService(@Advice.Argument(0) ServletRequest servletRequest,\n                                             @Advice.Argument(1) ServletResponse servletResponse,\n-                                            @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                            @Advice.Local(\"scope\") @Nullable Scope scope,\n+                                            @Advice.Enter @Nullable Object transactionOrScope,\n                                             @Advice.Thrown @Nullable Throwable t,\n-                                            @Advice.This Object thiz,\n-                                            @Advice.Local(\"span\") @Nullable Span span) {\n+                                            @Advice.This Object thiz) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n             return;\n         }\n-        excluded.set(Boolean.FALSE);\n+        Transaction transaction = null;\n+        Scope scope = null;\n+        if (transactionOrScope instanceof Transaction) {\n+            transaction = (Transaction) transactionOrScope;\n+        } else if (transactionOrScope instanceof Scope) {\n+            scope = (Scope) transactionOrScope;\n+        }\n+\n+        excluded.set(FALSE);\n         if (scope != null) {\n             scope.close();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMxMTExMA==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442311110", "bodyText": "You need to assert that exactly the expected spans are captured. Potentially, this can pass if two non-related spans are captured.\nYou can filter the span collection for each and assert you get exactly one that contains the required info.", "author": "eyalkoren", "createdAt": "2020-06-18T15:25:21Z", "path": "integration-tests/application-server-integration-tests/src/test/java/co/elastic/apm/servlet/tests/ServletApiTestApp.java", "diffHunk": "@@ -75,6 +78,58 @@ private void testCaptureBody(AbstractServletContainerIntegrationTest test) throw\n         }\n     }\n \n+    private void testTransactionReportingWithForward(AbstractServletContainerIntegrationTest test) throws Exception {\n+        String pathToTest = \"/simple-webapp\" + \"/forward\";\n+        boolean isExistForwardSpan = false;\n+        boolean isExistDbH2QuerySpan = false;\n+        test.clearMockServerLog();\n+\n+        test.executeAndValidateRequest(pathToTest, \"Hello World\", 200, null);\n+\n+        JsonNode transaction = test.assertTransactionReported(pathToTest, 200);\n+\n+        List<JsonNode> reportedSpans = test.getReportedSpans();\n+        assertThat(reportedSpans.size()).isEqualTo(2);\n+\n+        for (JsonNode span : test.getReportedSpans()) {\n+            String spanType = span.get(\"type\").textValue();\n+            if (\"servlet.request-dispatcher.forward\".equals(spanType)) {\n+                isExistForwardSpan = true;\n+                assertThat(span.get(\"name\").textValue()).isEqualTo(\"FORWARD /servlet\");\n+            } else if (\"db.h2.query\".equals(spanType)) {\n+                isExistDbH2QuerySpan = true;\n+            }\n+        }", "originalCommit": "96711728acd8fb3d4b652c676cf29ee656ecd085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwOTk4Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r465909986", "bodyText": "added filter before assert.", "author": "kananindzya", "createdAt": "2020-08-05T18:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMxMTExMA=="}], "type": "inlineReview", "revised_code": {"commit": "db15630aa76758604b14c0b2365512207fd3a1ac", "chunk": "diff --git a/integration-tests/application-server-integration-tests/src/test/java/co/elastic/apm/servlet/tests/ServletApiTestApp.java b/integration-tests/application-server-integration-tests/src/test/java/co/elastic/apm/servlet/tests/ServletApiTestApp.java\nindex 87a3cf7e6..bac3199f3 100644\n--- a/integration-tests/application-server-integration-tests/src/test/java/co/elastic/apm/servlet/tests/ServletApiTestApp.java\n+++ b/integration-tests/application-server-integration-tests/src/test/java/co/elastic/apm/servlet/tests/ServletApiTestApp.java\n\n@@ -80,34 +80,23 @@ public class ServletApiTestApp extends TestApp {\n \n     private void testTransactionReportingWithForward(AbstractServletContainerIntegrationTest test) throws Exception {\n         String pathToTest = \"/simple-webapp\" + \"/forward\";\n-        boolean isExistForwardSpan = false;\n-        boolean isExistDbH2QuerySpan = false;\n         test.clearMockServerLog();\n \n         test.executeAndValidateRequest(pathToTest, \"Hello World\", 200, null);\n \n         JsonNode transaction = test.assertTransactionReported(pathToTest, 200);\n-\n         List<JsonNode> reportedSpans = test.getReportedSpans();\n         assertThat(reportedSpans.size()).isEqualTo(2);\n \n-        for (JsonNode span : test.getReportedSpans()) {\n-            String spanType = span.get(\"type\").textValue();\n-            if (\"servlet.request-dispatcher.forward\".equals(spanType)) {\n-                isExistForwardSpan = true;\n-                assertThat(span.get(\"name\").textValue()).isEqualTo(\"FORWARD /servlet\");\n-            } else if (\"db.h2.query\".equals(spanType)) {\n-                isExistDbH2QuerySpan = true;\n-            }\n-        }\n-        assertThat(isExistForwardSpan).isEqualTo(true);\n-        assertThat(isExistDbH2QuerySpan).isEqualTo(true);\n+        List<JsonNode> h2dbSpans = test.getReportedSpans().stream().filter(k -> k.get(\"type\").equals(\"db.h2.query\")).collect(Collectors.toList());\n+        List<JsonNode> forwardSpans = test.getReportedSpans().stream().filter(k -> k.get(\"type\").equals(\"servlet.request-dispatcher.forward\")).collect(Collectors.toList());\n+        assertThat(h2dbSpans.size()).isEqualTo(1);\n+        assertThat(forwardSpans.size()).isEqualTo(1);\n+        assertThat(forwardSpans.get(0).get(\"name\")).isEqualTo(\"FORWARD /servlet\");\n     }\n \n     private void testTransactionReportingWithInclude(AbstractServletContainerIntegrationTest test) throws Exception {\n         String pathToTest = \"/simple-webapp\" + \"/include\";\n-        boolean isExistIncludeSpan = false;\n-        boolean isExistDbH2QuerySpan = false;\n         test.clearMockServerLog();\n \n         test.executeAndValidateRequest(pathToTest, \"Hello World\", 200, null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3NzUxOA==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449977518", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String FORWARD = \"FORWARD\";\n          \n          \n            \n                private static final String INCLUDE = \"INCLUDE\";\n          \n          \n            \n                private static final String ERROR = \"ERROR\";\n          \n          \n            \n                private static final String SPACE = \" \";\n          \n          \n            \n                private static final String EMPTY = \"\";\n          \n          \n            \n                private static final String FORWARD = \"FORWARD \";\n          \n          \n            \n                private static final String INCLUDE = \"INCLUDE \";\n          \n          \n            \n                private static final String ERROR = \"ERROR \";", "author": "eyalkoren", "createdAt": "2020-07-06T04:27:39Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -60,6 +63,16 @@\n public class ServletApiAdvice {\n \n     private static final String FRAMEWORK_NAME = \"Servlet API\";\n+    private static final String SPAN_TYPE = \"servlet\";\n+    private static final String SPAN_SUBTYPE = \"request-dispatcher\";\n+    private static final String FORWARD_SPAN_ACTION = \"forward\";\n+    private static final String INCLUDE_SPAN_ACTION = \"include\";\n+    private static final String ERROR_SPAN_ACTION = \"error\";\n+    private static final String FORWARD = \"FORWARD\";\n+    private static final String INCLUDE = \"INCLUDE\";\n+    private static final String ERROR = \"ERROR\";\n+    private static final String SPACE = \" \";\n+    private static final String EMPTY = \"\";", "originalCommit": "4be406076c63ed4421d7b9e4fa1a9faec3914b18", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db15630aa76758604b14c0b2365512207fd3a1ac", "chunk": "diff --git a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nindex 28c8b633b..ae738bc14 100644\n--- a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n+++ b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n\n@@ -53,186 +52,97 @@ import java.util.Map;\n \n import static co.elastic.apm.agent.servlet.ServletTransactionHelper.TRANSACTION_ATTRIBUTE;\n import static co.elastic.apm.agent.servlet.ServletTransactionHelper.determineServiceName;\n+import static java.lang.Boolean.FALSE;\n \n-/**\n- * Only the methods annotated with {@link Advice.OnMethodEnter} and {@link Advice.OnMethodExit} may contain references to\n- * {@code javax.servlet}, as these are inlined into the matching methods.\n- * The agent itself does not have access to the Servlet API classes, as they are loaded by a child class loader.\n- * See https://github.com/raphw/byte-buddy/issues/465 for more information.\n- */\n public class ServletApiAdvice {\n \n     private static final String FRAMEWORK_NAME = \"Servlet API\";\n-    private static final String SPAN_TYPE = \"servlet\";\n-    private static final String SPAN_SUBTYPE = \"request-dispatcher\";\n-    private static final String FORWARD_SPAN_ACTION = \"forward\";\n-    private static final String INCLUDE_SPAN_ACTION = \"include\";\n-    private static final String ERROR_SPAN_ACTION = \"error\";\n-    private static final String FORWARD = \"FORWARD\";\n-    private static final String INCLUDE = \"INCLUDE\";\n-    private static final String ERROR = \"ERROR\";\n-    private static final String SPACE = \" \";\n-    private static final String EMPTY = \"\";\n-\n-    @Nullable\n-    @VisibleForAdvice\n-    public static ServletTransactionHelper servletTransactionHelper;\n-\n-    @Nullable\n-    @VisibleForAdvice\n-    public static ElasticApmTracer tracer;\n-\n-    @VisibleForAdvice\n-    public static ThreadLocal<Boolean> excluded = new ThreadLocal<Boolean>() {\n-        @Override\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n-\n-    @VisibleForAdvice\n-    public static ThreadLocal<Boolean> isNeedCloseSpan = new ThreadLocal<Boolean>() {\n-        @Override\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n+    private static final ServletTransactionHelper servletTransactionHelper;\n+    private static final ServletTransactionCreationHelper servletTransactionCreationHelper;\n \n-    @VisibleForAdvice\n-    public static final List<String> requestExceptionAttributes = Arrays.asList(\"javax.servlet.error.exception\", \"exception\", \"org.springframework.web.servlet.DispatcherServlet.EXCEPTION\", \"co.elastic.apm.exception\");\n-\n-    static void init(ElasticApmTracer tracer) {\n-        ServletApiAdvice.tracer = tracer;\n-        servletTransactionHelper = new ServletTransactionHelper(tracer);\n+    static {\n+        servletTransactionHelper = new ServletTransactionHelper(GlobalTracer.requireTracerImpl());\n+        servletTransactionCreationHelper = new ServletTransactionCreationHelper(GlobalTracer.requireTracerImpl());\n     }\n \n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static void onEnterServletService(@Advice.Argument(0) ServletRequest servletRequest,\n-                                             @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                             @Advice.Local(\"scope\") Scope scope,\n-                                             @Advice.Local(\"span\") @Nullable Span span) {\n+    private static final GlobalThreadLocal<Boolean> excluded = GlobalThreadLocal.get(ServletApiAdvice.class, \"excluded\", false);\n+    private static final List<String> requestExceptionAttributes = Arrays.asList(\"javax.servlet.error.exception\", \"exception\", \"org.springframework.web.servlet.DispatcherServlet.EXCEPTION\", \"co.elastic.apm.exception\");\n+\n+    @Nullable\n+    @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+    public static Object onEnterServletService(@Advice.Argument(0) ServletRequest servletRequest) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n-            return;\n+            return null;\n         }\n+        Transaction transaction = null;\n         // re-activate transactions for async requests\n         final Transaction transactionAttr = (Transaction) servletRequest.getAttribute(TRANSACTION_ATTRIBUTE);\n         if (tracer.currentTransaction() == null && transactionAttr != null) {\n-            scope = transactionAttr.activateInScope();\n+            return transactionAttr.activateInScope();\n         }\n         if (tracer.isRunning() &&\n-            servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n+            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n-            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n-                ServletContext servletContext = servletRequest.getServletContext();\n-                if (servletContext != null) {\n-                    // this makes sure service name discovery also works when attaching at runtime\n-                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-                }\n \n-                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                    if (helper != null) {\n-                        transaction = helper.createAndActivateTransaction(request);\n-                    }\n-                }\n-\n-                if (transaction == null) {\n-                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                    excluded.set(Boolean.TRUE);\n-                    return;\n-                }\n-                final Request req = transaction.getContext().getRequest();\n-                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                    if (request.getCookies() != null) {\n-                        for (Cookie cookie : request.getCookies()) {\n-                            req.addCookie(cookie.getName(), cookie.getValue());\n-                        }\n-                    }\n-                    final Enumeration<String> headerNames = request.getHeaderNames();\n-                    if (headerNames != null) {\n-                        while (headerNames.hasMoreElements()) {\n-                            final String headerName = headerNames.nextElement();\n-                            req.addHeader(headerName, request.getHeaders(headerName));\n-                        }\n-                    }\n-                }\n-                transaction.setFrameworkName(FRAMEWORK_NAME);\n+            ServletContext servletContext = servletRequest.getServletContext();\n+            if (servletContext != null) {\n+                // this makes sure service name discovery also works when attaching at runtime\n+                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+            }\n \n-                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n-                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n-                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n-            } else if (transaction == null) {\n-                final AbstractSpan<?> parent = tracer.getActive();\n-                if (parent != null) {\n-                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                    DispatcherType dispatcherType = request.getDispatcherType();\n-                    boolean isSpannableDispatcherType = false;\n-                    span = parent.createSpan()\n-                        .withType(SPAN_TYPE)\n-                        .withSubtype(SPAN_SUBTYPE);\n+            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+            transaction = servletTransactionCreationHelper.createAndActivateTransaction(request);\n \n-                    if (dispatcherType == DispatcherType.FORWARD) {\n-                        span.appendToName(FORWARD)\n-                            .appendToName(SPACE)\n-                            .appendToName(request.getServletPath());\n-                        if (request.getPathInfo() != null) {\n-                            span.appendToName(request.getPathInfo());\n-                        }\n-                        span.withAction(FORWARD_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n-                    } else if (dispatcherType == DispatcherType.INCLUDE) {\n-                        Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n-                        Object includeServletPath = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\n-                        span.appendToName(INCLUDE)\n-                            .appendToName(SPACE);\n-                        if (includeServletPath != null) {\n-                            span.appendToName((String) includeServletPath);\n-                        }\n-                        if (pathInfo != null) {\n-                            span.appendToName((String) pathInfo);\n-                        }\n-                        span.withAction(FORWARD_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n-                    } else if (dispatcherType == DispatcherType.ERROR) {\n-                        Object servletPath = request.getServletPath();\n-                        span.appendToName(ERROR)\n-                            .appendToName(SPACE);\n-                        if (servletPath != null) {\n-                            span.appendToName((String) servletPath);\n-                        }\n-                        span.withAction(ERROR_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n+            if (transaction == null) {\n+                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                excluded.set(Boolean.TRUE);\n+                return null;\n+            }\n+            final Request req = transaction.getContext().getRequest();\n+            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                if (request.getCookies() != null) {\n+                    for (Cookie cookie : request.getCookies()) {\n+                        req.addCookie(cookie.getName(), cookie.getValue());\n                     }\n-                    if (isSpannableDispatcherType && !parent.getNameAsString().equals(span.getNameAsString())) {\n-                        isNeedCloseSpan.set(Boolean.TRUE);\n-                        span.activate();\n+                }\n+                final Enumeration<String> headerNames = request.getHeaderNames();\n+                if (headerNames != null) {\n+                    while (headerNames.hasMoreElements()) {\n+                        final String headerName = headerNames.nextElement();\n+                        req.addHeader(headerName, request.getHeaders(headerName));\n                     }\n                 }\n             }\n+            transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+            servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n         }\n+        return transaction;\n     }\n \n-    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class)\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n     public static void onExitServletService(@Advice.Argument(0) ServletRequest servletRequest,\n                                             @Advice.Argument(1) ServletResponse servletResponse,\n-                                            @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                            @Advice.Local(\"scope\") @Nullable Scope scope,\n+                                            @Advice.Enter @Nullable Object transactionOrScope,\n                                             @Advice.Thrown @Nullable Throwable t,\n-                                            @Advice.This Object thiz,\n-                                            @Advice.Local(\"span\") @Nullable Span span) {\n+                                            @Advice.This Object thiz) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n             return;\n         }\n-        excluded.set(Boolean.FALSE);\n-        if (span != null && Boolean.TRUE.equals(isNeedCloseSpan.get())) {\n-            isNeedCloseSpan.set(Boolean.FALSE);\n-            span.captureException(t)\n-                .deactivate()\n-                .end();\n+        Transaction transaction = null;\n+        Scope scope = null;\n+        if (transactionOrScope instanceof Transaction) {\n+            transaction = (Transaction) transactionOrScope;\n+        } else if (transactionOrScope instanceof Scope) {\n+            scope = (Scope) transactionOrScope;\n         }\n+\n+        excluded.set(FALSE);\n         if (scope != null) {\n             scope.close();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Nzg2Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449977862", "bodyText": "Why is the transaction == null required here? Seems it will always be null", "author": "eyalkoren", "createdAt": "2020-07-06T04:29:14Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {", "originalCommit": "4be406076c63ed4421d7b9e4fa1a9faec3914b18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwOTY0OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r465909648", "bodyText": "i changed here condition to ->\nservletRequest.getDispatcherType() != DispatcherType.ASYNC", "author": "kananindzya", "createdAt": "2020-08-05T18:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Nzg2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "db15630aa76758604b14c0b2365512207fd3a1ac", "chunk": "diff --git a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nindex 28c8b633b..ae738bc14 100644\n--- a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n+++ b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n\n@@ -53,186 +52,97 @@ import java.util.Map;\n \n import static co.elastic.apm.agent.servlet.ServletTransactionHelper.TRANSACTION_ATTRIBUTE;\n import static co.elastic.apm.agent.servlet.ServletTransactionHelper.determineServiceName;\n+import static java.lang.Boolean.FALSE;\n \n-/**\n- * Only the methods annotated with {@link Advice.OnMethodEnter} and {@link Advice.OnMethodExit} may contain references to\n- * {@code javax.servlet}, as these are inlined into the matching methods.\n- * The agent itself does not have access to the Servlet API classes, as they are loaded by a child class loader.\n- * See https://github.com/raphw/byte-buddy/issues/465 for more information.\n- */\n public class ServletApiAdvice {\n \n     private static final String FRAMEWORK_NAME = \"Servlet API\";\n-    private static final String SPAN_TYPE = \"servlet\";\n-    private static final String SPAN_SUBTYPE = \"request-dispatcher\";\n-    private static final String FORWARD_SPAN_ACTION = \"forward\";\n-    private static final String INCLUDE_SPAN_ACTION = \"include\";\n-    private static final String ERROR_SPAN_ACTION = \"error\";\n-    private static final String FORWARD = \"FORWARD\";\n-    private static final String INCLUDE = \"INCLUDE\";\n-    private static final String ERROR = \"ERROR\";\n-    private static final String SPACE = \" \";\n-    private static final String EMPTY = \"\";\n-\n-    @Nullable\n-    @VisibleForAdvice\n-    public static ServletTransactionHelper servletTransactionHelper;\n-\n-    @Nullable\n-    @VisibleForAdvice\n-    public static ElasticApmTracer tracer;\n-\n-    @VisibleForAdvice\n-    public static ThreadLocal<Boolean> excluded = new ThreadLocal<Boolean>() {\n-        @Override\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n-\n-    @VisibleForAdvice\n-    public static ThreadLocal<Boolean> isNeedCloseSpan = new ThreadLocal<Boolean>() {\n-        @Override\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n+    private static final ServletTransactionHelper servletTransactionHelper;\n+    private static final ServletTransactionCreationHelper servletTransactionCreationHelper;\n \n-    @VisibleForAdvice\n-    public static final List<String> requestExceptionAttributes = Arrays.asList(\"javax.servlet.error.exception\", \"exception\", \"org.springframework.web.servlet.DispatcherServlet.EXCEPTION\", \"co.elastic.apm.exception\");\n-\n-    static void init(ElasticApmTracer tracer) {\n-        ServletApiAdvice.tracer = tracer;\n-        servletTransactionHelper = new ServletTransactionHelper(tracer);\n+    static {\n+        servletTransactionHelper = new ServletTransactionHelper(GlobalTracer.requireTracerImpl());\n+        servletTransactionCreationHelper = new ServletTransactionCreationHelper(GlobalTracer.requireTracerImpl());\n     }\n \n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static void onEnterServletService(@Advice.Argument(0) ServletRequest servletRequest,\n-                                             @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                             @Advice.Local(\"scope\") Scope scope,\n-                                             @Advice.Local(\"span\") @Nullable Span span) {\n+    private static final GlobalThreadLocal<Boolean> excluded = GlobalThreadLocal.get(ServletApiAdvice.class, \"excluded\", false);\n+    private static final List<String> requestExceptionAttributes = Arrays.asList(\"javax.servlet.error.exception\", \"exception\", \"org.springframework.web.servlet.DispatcherServlet.EXCEPTION\", \"co.elastic.apm.exception\");\n+\n+    @Nullable\n+    @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+    public static Object onEnterServletService(@Advice.Argument(0) ServletRequest servletRequest) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n-            return;\n+            return null;\n         }\n+        Transaction transaction = null;\n         // re-activate transactions for async requests\n         final Transaction transactionAttr = (Transaction) servletRequest.getAttribute(TRANSACTION_ATTRIBUTE);\n         if (tracer.currentTransaction() == null && transactionAttr != null) {\n-            scope = transactionAttr.activateInScope();\n+            return transactionAttr.activateInScope();\n         }\n         if (tracer.isRunning() &&\n-            servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n+            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n-            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n-                ServletContext servletContext = servletRequest.getServletContext();\n-                if (servletContext != null) {\n-                    // this makes sure service name discovery also works when attaching at runtime\n-                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-                }\n \n-                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                    if (helper != null) {\n-                        transaction = helper.createAndActivateTransaction(request);\n-                    }\n-                }\n-\n-                if (transaction == null) {\n-                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                    excluded.set(Boolean.TRUE);\n-                    return;\n-                }\n-                final Request req = transaction.getContext().getRequest();\n-                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                    if (request.getCookies() != null) {\n-                        for (Cookie cookie : request.getCookies()) {\n-                            req.addCookie(cookie.getName(), cookie.getValue());\n-                        }\n-                    }\n-                    final Enumeration<String> headerNames = request.getHeaderNames();\n-                    if (headerNames != null) {\n-                        while (headerNames.hasMoreElements()) {\n-                            final String headerName = headerNames.nextElement();\n-                            req.addHeader(headerName, request.getHeaders(headerName));\n-                        }\n-                    }\n-                }\n-                transaction.setFrameworkName(FRAMEWORK_NAME);\n+            ServletContext servletContext = servletRequest.getServletContext();\n+            if (servletContext != null) {\n+                // this makes sure service name discovery also works when attaching at runtime\n+                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+            }\n \n-                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n-                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n-                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n-            } else if (transaction == null) {\n-                final AbstractSpan<?> parent = tracer.getActive();\n-                if (parent != null) {\n-                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                    DispatcherType dispatcherType = request.getDispatcherType();\n-                    boolean isSpannableDispatcherType = false;\n-                    span = parent.createSpan()\n-                        .withType(SPAN_TYPE)\n-                        .withSubtype(SPAN_SUBTYPE);\n+            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+            transaction = servletTransactionCreationHelper.createAndActivateTransaction(request);\n \n-                    if (dispatcherType == DispatcherType.FORWARD) {\n-                        span.appendToName(FORWARD)\n-                            .appendToName(SPACE)\n-                            .appendToName(request.getServletPath());\n-                        if (request.getPathInfo() != null) {\n-                            span.appendToName(request.getPathInfo());\n-                        }\n-                        span.withAction(FORWARD_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n-                    } else if (dispatcherType == DispatcherType.INCLUDE) {\n-                        Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n-                        Object includeServletPath = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\n-                        span.appendToName(INCLUDE)\n-                            .appendToName(SPACE);\n-                        if (includeServletPath != null) {\n-                            span.appendToName((String) includeServletPath);\n-                        }\n-                        if (pathInfo != null) {\n-                            span.appendToName((String) pathInfo);\n-                        }\n-                        span.withAction(FORWARD_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n-                    } else if (dispatcherType == DispatcherType.ERROR) {\n-                        Object servletPath = request.getServletPath();\n-                        span.appendToName(ERROR)\n-                            .appendToName(SPACE);\n-                        if (servletPath != null) {\n-                            span.appendToName((String) servletPath);\n-                        }\n-                        span.withAction(ERROR_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n+            if (transaction == null) {\n+                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                excluded.set(Boolean.TRUE);\n+                return null;\n+            }\n+            final Request req = transaction.getContext().getRequest();\n+            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                if (request.getCookies() != null) {\n+                    for (Cookie cookie : request.getCookies()) {\n+                        req.addCookie(cookie.getName(), cookie.getValue());\n                     }\n-                    if (isSpannableDispatcherType && !parent.getNameAsString().equals(span.getNameAsString())) {\n-                        isNeedCloseSpan.set(Boolean.TRUE);\n-                        span.activate();\n+                }\n+                final Enumeration<String> headerNames = request.getHeaderNames();\n+                if (headerNames != null) {\n+                    while (headerNames.hasMoreElements()) {\n+                        final String headerName = headerNames.nextElement();\n+                        req.addHeader(headerName, request.getHeaders(headerName));\n                     }\n                 }\n             }\n+            transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+            servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n         }\n+        return transaction;\n     }\n \n-    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class)\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n     public static void onExitServletService(@Advice.Argument(0) ServletRequest servletRequest,\n                                             @Advice.Argument(1) ServletResponse servletResponse,\n-                                            @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                            @Advice.Local(\"scope\") @Nullable Scope scope,\n+                                            @Advice.Enter @Nullable Object transactionOrScope,\n                                             @Advice.Thrown @Nullable Throwable t,\n-                                            @Advice.This Object thiz,\n-                                            @Advice.Local(\"span\") @Nullable Span span) {\n+                                            @Advice.This Object thiz) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n             return;\n         }\n-        excluded.set(Boolean.FALSE);\n-        if (span != null && Boolean.TRUE.equals(isNeedCloseSpan.get())) {\n-            isNeedCloseSpan.set(Boolean.FALSE);\n-            span.captureException(t)\n-                .deactivate()\n-                .end();\n+        Transaction transaction = null;\n+        Scope scope = null;\n+        if (transactionOrScope instanceof Transaction) {\n+            transaction = (Transaction) transactionOrScope;\n+        } else if (transactionOrScope instanceof Scope) {\n+            scope = (Scope) transactionOrScope;\n         }\n+\n+        excluded.set(FALSE);\n         if (scope != null) {\n             scope.close();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Nzk0NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449977945", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    span.withAction(FORWARD_SPAN_ACTION);\n          \n          \n            \n                                    span.withAction(INCLUDE_SPAN_ACTION);", "author": "eyalkoren", "createdAt": "2020-07-06T04:29:41Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {\n+                final AbstractSpan<?> parent = tracer.getActive();\n+                if (parent != null) {\n+                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                    DispatcherType dispatcherType = request.getDispatcherType();\n+                    boolean isSpannableDispatcherType = false;\n+                    span = parent.createSpan()\n+                        .withType(SPAN_TYPE)\n+                        .withSubtype(SPAN_SUBTYPE);\n+\n+                    if (dispatcherType == DispatcherType.FORWARD) {\n+                        span.appendToName(FORWARD)\n+                            .appendToName(SPACE)\n+                            .appendToName(request.getServletPath());\n+                        if (request.getPathInfo() != null) {\n+                            span.appendToName(request.getPathInfo());\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                        Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                        Object includeServletPath = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\n+                        span.appendToName(INCLUDE)\n+                            .appendToName(SPACE);\n+                        if (includeServletPath != null) {\n+                            span.appendToName((String) includeServletPath);\n+                        }\n+                        if (pathInfo != null) {\n+                            span.appendToName((String) pathInfo);\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);", "originalCommit": "4be406076c63ed4421d7b9e4fa1a9faec3914b18", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db15630aa76758604b14c0b2365512207fd3a1ac", "chunk": "diff --git a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nindex 28c8b633b..ae738bc14 100644\n--- a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n+++ b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n\n@@ -53,186 +52,97 @@ import java.util.Map;\n \n import static co.elastic.apm.agent.servlet.ServletTransactionHelper.TRANSACTION_ATTRIBUTE;\n import static co.elastic.apm.agent.servlet.ServletTransactionHelper.determineServiceName;\n+import static java.lang.Boolean.FALSE;\n \n-/**\n- * Only the methods annotated with {@link Advice.OnMethodEnter} and {@link Advice.OnMethodExit} may contain references to\n- * {@code javax.servlet}, as these are inlined into the matching methods.\n- * The agent itself does not have access to the Servlet API classes, as they are loaded by a child class loader.\n- * See https://github.com/raphw/byte-buddy/issues/465 for more information.\n- */\n public class ServletApiAdvice {\n \n     private static final String FRAMEWORK_NAME = \"Servlet API\";\n-    private static final String SPAN_TYPE = \"servlet\";\n-    private static final String SPAN_SUBTYPE = \"request-dispatcher\";\n-    private static final String FORWARD_SPAN_ACTION = \"forward\";\n-    private static final String INCLUDE_SPAN_ACTION = \"include\";\n-    private static final String ERROR_SPAN_ACTION = \"error\";\n-    private static final String FORWARD = \"FORWARD\";\n-    private static final String INCLUDE = \"INCLUDE\";\n-    private static final String ERROR = \"ERROR\";\n-    private static final String SPACE = \" \";\n-    private static final String EMPTY = \"\";\n-\n-    @Nullable\n-    @VisibleForAdvice\n-    public static ServletTransactionHelper servletTransactionHelper;\n-\n-    @Nullable\n-    @VisibleForAdvice\n-    public static ElasticApmTracer tracer;\n-\n-    @VisibleForAdvice\n-    public static ThreadLocal<Boolean> excluded = new ThreadLocal<Boolean>() {\n-        @Override\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n-\n-    @VisibleForAdvice\n-    public static ThreadLocal<Boolean> isNeedCloseSpan = new ThreadLocal<Boolean>() {\n-        @Override\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n+    private static final ServletTransactionHelper servletTransactionHelper;\n+    private static final ServletTransactionCreationHelper servletTransactionCreationHelper;\n \n-    @VisibleForAdvice\n-    public static final List<String> requestExceptionAttributes = Arrays.asList(\"javax.servlet.error.exception\", \"exception\", \"org.springframework.web.servlet.DispatcherServlet.EXCEPTION\", \"co.elastic.apm.exception\");\n-\n-    static void init(ElasticApmTracer tracer) {\n-        ServletApiAdvice.tracer = tracer;\n-        servletTransactionHelper = new ServletTransactionHelper(tracer);\n+    static {\n+        servletTransactionHelper = new ServletTransactionHelper(GlobalTracer.requireTracerImpl());\n+        servletTransactionCreationHelper = new ServletTransactionCreationHelper(GlobalTracer.requireTracerImpl());\n     }\n \n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static void onEnterServletService(@Advice.Argument(0) ServletRequest servletRequest,\n-                                             @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                             @Advice.Local(\"scope\") Scope scope,\n-                                             @Advice.Local(\"span\") @Nullable Span span) {\n+    private static final GlobalThreadLocal<Boolean> excluded = GlobalThreadLocal.get(ServletApiAdvice.class, \"excluded\", false);\n+    private static final List<String> requestExceptionAttributes = Arrays.asList(\"javax.servlet.error.exception\", \"exception\", \"org.springframework.web.servlet.DispatcherServlet.EXCEPTION\", \"co.elastic.apm.exception\");\n+\n+    @Nullable\n+    @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+    public static Object onEnterServletService(@Advice.Argument(0) ServletRequest servletRequest) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n-            return;\n+            return null;\n         }\n+        Transaction transaction = null;\n         // re-activate transactions for async requests\n         final Transaction transactionAttr = (Transaction) servletRequest.getAttribute(TRANSACTION_ATTRIBUTE);\n         if (tracer.currentTransaction() == null && transactionAttr != null) {\n-            scope = transactionAttr.activateInScope();\n+            return transactionAttr.activateInScope();\n         }\n         if (tracer.isRunning() &&\n-            servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n+            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n-            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n-                ServletContext servletContext = servletRequest.getServletContext();\n-                if (servletContext != null) {\n-                    // this makes sure service name discovery also works when attaching at runtime\n-                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-                }\n \n-                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                    if (helper != null) {\n-                        transaction = helper.createAndActivateTransaction(request);\n-                    }\n-                }\n-\n-                if (transaction == null) {\n-                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                    excluded.set(Boolean.TRUE);\n-                    return;\n-                }\n-                final Request req = transaction.getContext().getRequest();\n-                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                    if (request.getCookies() != null) {\n-                        for (Cookie cookie : request.getCookies()) {\n-                            req.addCookie(cookie.getName(), cookie.getValue());\n-                        }\n-                    }\n-                    final Enumeration<String> headerNames = request.getHeaderNames();\n-                    if (headerNames != null) {\n-                        while (headerNames.hasMoreElements()) {\n-                            final String headerName = headerNames.nextElement();\n-                            req.addHeader(headerName, request.getHeaders(headerName));\n-                        }\n-                    }\n-                }\n-                transaction.setFrameworkName(FRAMEWORK_NAME);\n+            ServletContext servletContext = servletRequest.getServletContext();\n+            if (servletContext != null) {\n+                // this makes sure service name discovery also works when attaching at runtime\n+                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+            }\n \n-                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n-                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n-                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n-            } else if (transaction == null) {\n-                final AbstractSpan<?> parent = tracer.getActive();\n-                if (parent != null) {\n-                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                    DispatcherType dispatcherType = request.getDispatcherType();\n-                    boolean isSpannableDispatcherType = false;\n-                    span = parent.createSpan()\n-                        .withType(SPAN_TYPE)\n-                        .withSubtype(SPAN_SUBTYPE);\n+            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+            transaction = servletTransactionCreationHelper.createAndActivateTransaction(request);\n \n-                    if (dispatcherType == DispatcherType.FORWARD) {\n-                        span.appendToName(FORWARD)\n-                            .appendToName(SPACE)\n-                            .appendToName(request.getServletPath());\n-                        if (request.getPathInfo() != null) {\n-                            span.appendToName(request.getPathInfo());\n-                        }\n-                        span.withAction(FORWARD_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n-                    } else if (dispatcherType == DispatcherType.INCLUDE) {\n-                        Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n-                        Object includeServletPath = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\n-                        span.appendToName(INCLUDE)\n-                            .appendToName(SPACE);\n-                        if (includeServletPath != null) {\n-                            span.appendToName((String) includeServletPath);\n-                        }\n-                        if (pathInfo != null) {\n-                            span.appendToName((String) pathInfo);\n-                        }\n-                        span.withAction(FORWARD_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n-                    } else if (dispatcherType == DispatcherType.ERROR) {\n-                        Object servletPath = request.getServletPath();\n-                        span.appendToName(ERROR)\n-                            .appendToName(SPACE);\n-                        if (servletPath != null) {\n-                            span.appendToName((String) servletPath);\n-                        }\n-                        span.withAction(ERROR_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n+            if (transaction == null) {\n+                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                excluded.set(Boolean.TRUE);\n+                return null;\n+            }\n+            final Request req = transaction.getContext().getRequest();\n+            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                if (request.getCookies() != null) {\n+                    for (Cookie cookie : request.getCookies()) {\n+                        req.addCookie(cookie.getName(), cookie.getValue());\n                     }\n-                    if (isSpannableDispatcherType && !parent.getNameAsString().equals(span.getNameAsString())) {\n-                        isNeedCloseSpan.set(Boolean.TRUE);\n-                        span.activate();\n+                }\n+                final Enumeration<String> headerNames = request.getHeaderNames();\n+                if (headerNames != null) {\n+                    while (headerNames.hasMoreElements()) {\n+                        final String headerName = headerNames.nextElement();\n+                        req.addHeader(headerName, request.getHeaders(headerName));\n                     }\n                 }\n             }\n+            transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+            servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n         }\n+        return transaction;\n     }\n \n-    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class)\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n     public static void onExitServletService(@Advice.Argument(0) ServletRequest servletRequest,\n                                             @Advice.Argument(1) ServletResponse servletResponse,\n-                                            @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                            @Advice.Local(\"scope\") @Nullable Scope scope,\n+                                            @Advice.Enter @Nullable Object transactionOrScope,\n                                             @Advice.Thrown @Nullable Throwable t,\n-                                            @Advice.This Object thiz,\n-                                            @Advice.Local(\"span\") @Nullable Span span) {\n+                                            @Advice.This Object thiz) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n             return;\n         }\n-        excluded.set(Boolean.FALSE);\n-        if (span != null && Boolean.TRUE.equals(isNeedCloseSpan.get())) {\n-            isNeedCloseSpan.set(Boolean.FALSE);\n-            span.captureException(t)\n-                .deactivate()\n-                .end();\n+        Transaction transaction = null;\n+        Scope scope = null;\n+        if (transactionOrScope instanceof Transaction) {\n+            transaction = (Transaction) transactionOrScope;\n+        } else if (transactionOrScope instanceof Scope) {\n+            scope = (Scope) transactionOrScope;\n         }\n+\n+        excluded.set(FALSE);\n         if (scope != null) {\n             scope.close();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk4MDU0NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449980544", "bodyText": "Do not create a span unless you know we need one. Currently these spans can leak. You must always end a span you created, like you must always deactivate a span you activated (which you did).\nIn rare cases (this is not one), you may create a span and then requestDiscarding it, but you still must end it.", "author": "eyalkoren", "createdAt": "2020-07-06T04:42:06Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {\n+                final AbstractSpan<?> parent = tracer.getActive();\n+                if (parent != null) {\n+                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                    DispatcherType dispatcherType = request.getDispatcherType();\n+                    boolean isSpannableDispatcherType = false;\n+                    span = parent.createSpan()\n+                        .withType(SPAN_TYPE)\n+                        .withSubtype(SPAN_SUBTYPE);", "originalCommit": "4be406076c63ed4421d7b9e4fa1a9faec3914b18", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db15630aa76758604b14c0b2365512207fd3a1ac", "chunk": "diff --git a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nindex 28c8b633b..ae738bc14 100644\n--- a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n+++ b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n\n@@ -53,186 +52,97 @@ import java.util.Map;\n \n import static co.elastic.apm.agent.servlet.ServletTransactionHelper.TRANSACTION_ATTRIBUTE;\n import static co.elastic.apm.agent.servlet.ServletTransactionHelper.determineServiceName;\n+import static java.lang.Boolean.FALSE;\n \n-/**\n- * Only the methods annotated with {@link Advice.OnMethodEnter} and {@link Advice.OnMethodExit} may contain references to\n- * {@code javax.servlet}, as these are inlined into the matching methods.\n- * The agent itself does not have access to the Servlet API classes, as they are loaded by a child class loader.\n- * See https://github.com/raphw/byte-buddy/issues/465 for more information.\n- */\n public class ServletApiAdvice {\n \n     private static final String FRAMEWORK_NAME = \"Servlet API\";\n-    private static final String SPAN_TYPE = \"servlet\";\n-    private static final String SPAN_SUBTYPE = \"request-dispatcher\";\n-    private static final String FORWARD_SPAN_ACTION = \"forward\";\n-    private static final String INCLUDE_SPAN_ACTION = \"include\";\n-    private static final String ERROR_SPAN_ACTION = \"error\";\n-    private static final String FORWARD = \"FORWARD\";\n-    private static final String INCLUDE = \"INCLUDE\";\n-    private static final String ERROR = \"ERROR\";\n-    private static final String SPACE = \" \";\n-    private static final String EMPTY = \"\";\n-\n-    @Nullable\n-    @VisibleForAdvice\n-    public static ServletTransactionHelper servletTransactionHelper;\n-\n-    @Nullable\n-    @VisibleForAdvice\n-    public static ElasticApmTracer tracer;\n-\n-    @VisibleForAdvice\n-    public static ThreadLocal<Boolean> excluded = new ThreadLocal<Boolean>() {\n-        @Override\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n-\n-    @VisibleForAdvice\n-    public static ThreadLocal<Boolean> isNeedCloseSpan = new ThreadLocal<Boolean>() {\n-        @Override\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n+    private static final ServletTransactionHelper servletTransactionHelper;\n+    private static final ServletTransactionCreationHelper servletTransactionCreationHelper;\n \n-    @VisibleForAdvice\n-    public static final List<String> requestExceptionAttributes = Arrays.asList(\"javax.servlet.error.exception\", \"exception\", \"org.springframework.web.servlet.DispatcherServlet.EXCEPTION\", \"co.elastic.apm.exception\");\n-\n-    static void init(ElasticApmTracer tracer) {\n-        ServletApiAdvice.tracer = tracer;\n-        servletTransactionHelper = new ServletTransactionHelper(tracer);\n+    static {\n+        servletTransactionHelper = new ServletTransactionHelper(GlobalTracer.requireTracerImpl());\n+        servletTransactionCreationHelper = new ServletTransactionCreationHelper(GlobalTracer.requireTracerImpl());\n     }\n \n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static void onEnterServletService(@Advice.Argument(0) ServletRequest servletRequest,\n-                                             @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                             @Advice.Local(\"scope\") Scope scope,\n-                                             @Advice.Local(\"span\") @Nullable Span span) {\n+    private static final GlobalThreadLocal<Boolean> excluded = GlobalThreadLocal.get(ServletApiAdvice.class, \"excluded\", false);\n+    private static final List<String> requestExceptionAttributes = Arrays.asList(\"javax.servlet.error.exception\", \"exception\", \"org.springframework.web.servlet.DispatcherServlet.EXCEPTION\", \"co.elastic.apm.exception\");\n+\n+    @Nullable\n+    @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+    public static Object onEnterServletService(@Advice.Argument(0) ServletRequest servletRequest) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n-            return;\n+            return null;\n         }\n+        Transaction transaction = null;\n         // re-activate transactions for async requests\n         final Transaction transactionAttr = (Transaction) servletRequest.getAttribute(TRANSACTION_ATTRIBUTE);\n         if (tracer.currentTransaction() == null && transactionAttr != null) {\n-            scope = transactionAttr.activateInScope();\n+            return transactionAttr.activateInScope();\n         }\n         if (tracer.isRunning() &&\n-            servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n+            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n-            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n-                ServletContext servletContext = servletRequest.getServletContext();\n-                if (servletContext != null) {\n-                    // this makes sure service name discovery also works when attaching at runtime\n-                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-                }\n \n-                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                    if (helper != null) {\n-                        transaction = helper.createAndActivateTransaction(request);\n-                    }\n-                }\n-\n-                if (transaction == null) {\n-                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                    excluded.set(Boolean.TRUE);\n-                    return;\n-                }\n-                final Request req = transaction.getContext().getRequest();\n-                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                    if (request.getCookies() != null) {\n-                        for (Cookie cookie : request.getCookies()) {\n-                            req.addCookie(cookie.getName(), cookie.getValue());\n-                        }\n-                    }\n-                    final Enumeration<String> headerNames = request.getHeaderNames();\n-                    if (headerNames != null) {\n-                        while (headerNames.hasMoreElements()) {\n-                            final String headerName = headerNames.nextElement();\n-                            req.addHeader(headerName, request.getHeaders(headerName));\n-                        }\n-                    }\n-                }\n-                transaction.setFrameworkName(FRAMEWORK_NAME);\n+            ServletContext servletContext = servletRequest.getServletContext();\n+            if (servletContext != null) {\n+                // this makes sure service name discovery also works when attaching at runtime\n+                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+            }\n \n-                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n-                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n-                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n-            } else if (transaction == null) {\n-                final AbstractSpan<?> parent = tracer.getActive();\n-                if (parent != null) {\n-                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                    DispatcherType dispatcherType = request.getDispatcherType();\n-                    boolean isSpannableDispatcherType = false;\n-                    span = parent.createSpan()\n-                        .withType(SPAN_TYPE)\n-                        .withSubtype(SPAN_SUBTYPE);\n+            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+            transaction = servletTransactionCreationHelper.createAndActivateTransaction(request);\n \n-                    if (dispatcherType == DispatcherType.FORWARD) {\n-                        span.appendToName(FORWARD)\n-                            .appendToName(SPACE)\n-                            .appendToName(request.getServletPath());\n-                        if (request.getPathInfo() != null) {\n-                            span.appendToName(request.getPathInfo());\n-                        }\n-                        span.withAction(FORWARD_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n-                    } else if (dispatcherType == DispatcherType.INCLUDE) {\n-                        Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n-                        Object includeServletPath = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\n-                        span.appendToName(INCLUDE)\n-                            .appendToName(SPACE);\n-                        if (includeServletPath != null) {\n-                            span.appendToName((String) includeServletPath);\n-                        }\n-                        if (pathInfo != null) {\n-                            span.appendToName((String) pathInfo);\n-                        }\n-                        span.withAction(FORWARD_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n-                    } else if (dispatcherType == DispatcherType.ERROR) {\n-                        Object servletPath = request.getServletPath();\n-                        span.appendToName(ERROR)\n-                            .appendToName(SPACE);\n-                        if (servletPath != null) {\n-                            span.appendToName((String) servletPath);\n-                        }\n-                        span.withAction(ERROR_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n+            if (transaction == null) {\n+                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                excluded.set(Boolean.TRUE);\n+                return null;\n+            }\n+            final Request req = transaction.getContext().getRequest();\n+            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                if (request.getCookies() != null) {\n+                    for (Cookie cookie : request.getCookies()) {\n+                        req.addCookie(cookie.getName(), cookie.getValue());\n                     }\n-                    if (isSpannableDispatcherType && !parent.getNameAsString().equals(span.getNameAsString())) {\n-                        isNeedCloseSpan.set(Boolean.TRUE);\n-                        span.activate();\n+                }\n+                final Enumeration<String> headerNames = request.getHeaderNames();\n+                if (headerNames != null) {\n+                    while (headerNames.hasMoreElements()) {\n+                        final String headerName = headerNames.nextElement();\n+                        req.addHeader(headerName, request.getHeaders(headerName));\n                     }\n                 }\n             }\n+            transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+            servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n         }\n+        return transaction;\n     }\n \n-    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class)\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n     public static void onExitServletService(@Advice.Argument(0) ServletRequest servletRequest,\n                                             @Advice.Argument(1) ServletResponse servletResponse,\n-                                            @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                            @Advice.Local(\"scope\") @Nullable Scope scope,\n+                                            @Advice.Enter @Nullable Object transactionOrScope,\n                                             @Advice.Thrown @Nullable Throwable t,\n-                                            @Advice.This Object thiz,\n-                                            @Advice.Local(\"span\") @Nullable Span span) {\n+                                            @Advice.This Object thiz) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n             return;\n         }\n-        excluded.set(Boolean.FALSE);\n-        if (span != null && Boolean.TRUE.equals(isNeedCloseSpan.get())) {\n-            isNeedCloseSpan.set(Boolean.FALSE);\n-            span.captureException(t)\n-                .deactivate()\n-                .end();\n+        Transaction transaction = null;\n+        Scope scope = null;\n+        if (transactionOrScope instanceof Transaction) {\n+            transaction = (Transaction) transactionOrScope;\n+        } else if (transactionOrScope instanceof Scope) {\n+            scope = (Scope) transactionOrScope;\n         }\n+\n+        excluded.set(FALSE);\n         if (scope != null) {\n             scope.close();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk4MTc1Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449981752", "bodyText": "getNameAsString is allocating a String objects (so two in this comparison).\nThere are better ways to avoid creation of same nested spans. For example, before creating a span, see if the parent span has the same type, subtype and action.\nWhat cases are you trying to prevent with this comparison?", "author": "eyalkoren", "createdAt": "2020-07-06T04:48:40Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {\n+                final AbstractSpan<?> parent = tracer.getActive();\n+                if (parent != null) {\n+                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                    DispatcherType dispatcherType = request.getDispatcherType();\n+                    boolean isSpannableDispatcherType = false;\n+                    span = parent.createSpan()\n+                        .withType(SPAN_TYPE)\n+                        .withSubtype(SPAN_SUBTYPE);\n+\n+                    if (dispatcherType == DispatcherType.FORWARD) {\n+                        span.appendToName(FORWARD)\n+                            .appendToName(SPACE)\n+                            .appendToName(request.getServletPath());\n+                        if (request.getPathInfo() != null) {\n+                            span.appendToName(request.getPathInfo());\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                        Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                        Object includeServletPath = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\n+                        span.appendToName(INCLUDE)\n+                            .appendToName(SPACE);\n+                        if (includeServletPath != null) {\n+                            span.appendToName((String) includeServletPath);\n+                        }\n+                        if (pathInfo != null) {\n+                            span.appendToName((String) pathInfo);\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    } else if (dispatcherType == DispatcherType.ERROR) {\n+                        Object servletPath = request.getServletPath();\n+                        span.appendToName(ERROR)\n+                            .appendToName(SPACE);\n+                        if (servletPath != null) {\n+                            span.appendToName((String) servletPath);\n+                        }\n+                        span.withAction(ERROR_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    }\n+                    if (isSpannableDispatcherType && !parent.getNameAsString().equals(span.getNameAsString())) {", "originalCommit": "4be406076c63ed4421d7b9e4fa1a9faec3914b18", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db15630aa76758604b14c0b2365512207fd3a1ac", "chunk": "diff --git a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nindex 28c8b633b..ae738bc14 100644\n--- a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n+++ b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n\n@@ -53,186 +52,97 @@ import java.util.Map;\n \n import static co.elastic.apm.agent.servlet.ServletTransactionHelper.TRANSACTION_ATTRIBUTE;\n import static co.elastic.apm.agent.servlet.ServletTransactionHelper.determineServiceName;\n+import static java.lang.Boolean.FALSE;\n \n-/**\n- * Only the methods annotated with {@link Advice.OnMethodEnter} and {@link Advice.OnMethodExit} may contain references to\n- * {@code javax.servlet}, as these are inlined into the matching methods.\n- * The agent itself does not have access to the Servlet API classes, as they are loaded by a child class loader.\n- * See https://github.com/raphw/byte-buddy/issues/465 for more information.\n- */\n public class ServletApiAdvice {\n \n     private static final String FRAMEWORK_NAME = \"Servlet API\";\n-    private static final String SPAN_TYPE = \"servlet\";\n-    private static final String SPAN_SUBTYPE = \"request-dispatcher\";\n-    private static final String FORWARD_SPAN_ACTION = \"forward\";\n-    private static final String INCLUDE_SPAN_ACTION = \"include\";\n-    private static final String ERROR_SPAN_ACTION = \"error\";\n-    private static final String FORWARD = \"FORWARD\";\n-    private static final String INCLUDE = \"INCLUDE\";\n-    private static final String ERROR = \"ERROR\";\n-    private static final String SPACE = \" \";\n-    private static final String EMPTY = \"\";\n-\n-    @Nullable\n-    @VisibleForAdvice\n-    public static ServletTransactionHelper servletTransactionHelper;\n-\n-    @Nullable\n-    @VisibleForAdvice\n-    public static ElasticApmTracer tracer;\n-\n-    @VisibleForAdvice\n-    public static ThreadLocal<Boolean> excluded = new ThreadLocal<Boolean>() {\n-        @Override\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n-\n-    @VisibleForAdvice\n-    public static ThreadLocal<Boolean> isNeedCloseSpan = new ThreadLocal<Boolean>() {\n-        @Override\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n+    private static final ServletTransactionHelper servletTransactionHelper;\n+    private static final ServletTransactionCreationHelper servletTransactionCreationHelper;\n \n-    @VisibleForAdvice\n-    public static final List<String> requestExceptionAttributes = Arrays.asList(\"javax.servlet.error.exception\", \"exception\", \"org.springframework.web.servlet.DispatcherServlet.EXCEPTION\", \"co.elastic.apm.exception\");\n-\n-    static void init(ElasticApmTracer tracer) {\n-        ServletApiAdvice.tracer = tracer;\n-        servletTransactionHelper = new ServletTransactionHelper(tracer);\n+    static {\n+        servletTransactionHelper = new ServletTransactionHelper(GlobalTracer.requireTracerImpl());\n+        servletTransactionCreationHelper = new ServletTransactionCreationHelper(GlobalTracer.requireTracerImpl());\n     }\n \n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static void onEnterServletService(@Advice.Argument(0) ServletRequest servletRequest,\n-                                             @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                             @Advice.Local(\"scope\") Scope scope,\n-                                             @Advice.Local(\"span\") @Nullable Span span) {\n+    private static final GlobalThreadLocal<Boolean> excluded = GlobalThreadLocal.get(ServletApiAdvice.class, \"excluded\", false);\n+    private static final List<String> requestExceptionAttributes = Arrays.asList(\"javax.servlet.error.exception\", \"exception\", \"org.springframework.web.servlet.DispatcherServlet.EXCEPTION\", \"co.elastic.apm.exception\");\n+\n+    @Nullable\n+    @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+    public static Object onEnterServletService(@Advice.Argument(0) ServletRequest servletRequest) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n-            return;\n+            return null;\n         }\n+        Transaction transaction = null;\n         // re-activate transactions for async requests\n         final Transaction transactionAttr = (Transaction) servletRequest.getAttribute(TRANSACTION_ATTRIBUTE);\n         if (tracer.currentTransaction() == null && transactionAttr != null) {\n-            scope = transactionAttr.activateInScope();\n+            return transactionAttr.activateInScope();\n         }\n         if (tracer.isRunning() &&\n-            servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n+            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n-            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n-                ServletContext servletContext = servletRequest.getServletContext();\n-                if (servletContext != null) {\n-                    // this makes sure service name discovery also works when attaching at runtime\n-                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-                }\n \n-                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                    if (helper != null) {\n-                        transaction = helper.createAndActivateTransaction(request);\n-                    }\n-                }\n-\n-                if (transaction == null) {\n-                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                    excluded.set(Boolean.TRUE);\n-                    return;\n-                }\n-                final Request req = transaction.getContext().getRequest();\n-                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                    if (request.getCookies() != null) {\n-                        for (Cookie cookie : request.getCookies()) {\n-                            req.addCookie(cookie.getName(), cookie.getValue());\n-                        }\n-                    }\n-                    final Enumeration<String> headerNames = request.getHeaderNames();\n-                    if (headerNames != null) {\n-                        while (headerNames.hasMoreElements()) {\n-                            final String headerName = headerNames.nextElement();\n-                            req.addHeader(headerName, request.getHeaders(headerName));\n-                        }\n-                    }\n-                }\n-                transaction.setFrameworkName(FRAMEWORK_NAME);\n+            ServletContext servletContext = servletRequest.getServletContext();\n+            if (servletContext != null) {\n+                // this makes sure service name discovery also works when attaching at runtime\n+                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+            }\n \n-                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n-                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n-                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n-            } else if (transaction == null) {\n-                final AbstractSpan<?> parent = tracer.getActive();\n-                if (parent != null) {\n-                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-                    DispatcherType dispatcherType = request.getDispatcherType();\n-                    boolean isSpannableDispatcherType = false;\n-                    span = parent.createSpan()\n-                        .withType(SPAN_TYPE)\n-                        .withSubtype(SPAN_SUBTYPE);\n+            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+            transaction = servletTransactionCreationHelper.createAndActivateTransaction(request);\n \n-                    if (dispatcherType == DispatcherType.FORWARD) {\n-                        span.appendToName(FORWARD)\n-                            .appendToName(SPACE)\n-                            .appendToName(request.getServletPath());\n-                        if (request.getPathInfo() != null) {\n-                            span.appendToName(request.getPathInfo());\n-                        }\n-                        span.withAction(FORWARD_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n-                    } else if (dispatcherType == DispatcherType.INCLUDE) {\n-                        Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n-                        Object includeServletPath = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\n-                        span.appendToName(INCLUDE)\n-                            .appendToName(SPACE);\n-                        if (includeServletPath != null) {\n-                            span.appendToName((String) includeServletPath);\n-                        }\n-                        if (pathInfo != null) {\n-                            span.appendToName((String) pathInfo);\n-                        }\n-                        span.withAction(FORWARD_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n-                    } else if (dispatcherType == DispatcherType.ERROR) {\n-                        Object servletPath = request.getServletPath();\n-                        span.appendToName(ERROR)\n-                            .appendToName(SPACE);\n-                        if (servletPath != null) {\n-                            span.appendToName((String) servletPath);\n-                        }\n-                        span.withAction(ERROR_SPAN_ACTION);\n-                        isSpannableDispatcherType = true;\n+            if (transaction == null) {\n+                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                excluded.set(Boolean.TRUE);\n+                return null;\n+            }\n+            final Request req = transaction.getContext().getRequest();\n+            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                if (request.getCookies() != null) {\n+                    for (Cookie cookie : request.getCookies()) {\n+                        req.addCookie(cookie.getName(), cookie.getValue());\n                     }\n-                    if (isSpannableDispatcherType && !parent.getNameAsString().equals(span.getNameAsString())) {\n-                        isNeedCloseSpan.set(Boolean.TRUE);\n-                        span.activate();\n+                }\n+                final Enumeration<String> headerNames = request.getHeaderNames();\n+                if (headerNames != null) {\n+                    while (headerNames.hasMoreElements()) {\n+                        final String headerName = headerNames.nextElement();\n+                        req.addHeader(headerName, request.getHeaders(headerName));\n                     }\n                 }\n             }\n+            transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+            servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n         }\n+        return transaction;\n     }\n \n-    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class)\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n     public static void onExitServletService(@Advice.Argument(0) ServletRequest servletRequest,\n                                             @Advice.Argument(1) ServletResponse servletResponse,\n-                                            @Advice.Local(\"transaction\") @Nullable Transaction transaction,\n-                                            @Advice.Local(\"scope\") @Nullable Scope scope,\n+                                            @Advice.Enter @Nullable Object transactionOrScope,\n                                             @Advice.Thrown @Nullable Throwable t,\n-                                            @Advice.This Object thiz,\n-                                            @Advice.Local(\"span\") @Nullable Span span) {\n+                                            @Advice.This Object thiz) {\n+        ElasticApmTracer tracer = GlobalTracer.getTracerImpl();\n         if (tracer == null) {\n             return;\n         }\n-        excluded.set(Boolean.FALSE);\n-        if (span != null && Boolean.TRUE.equals(isNeedCloseSpan.get())) {\n-            isNeedCloseSpan.set(Boolean.FALSE);\n-            span.captureException(t)\n-                .deactivate()\n-                .end();\n+        Transaction transaction = null;\n+        Scope scope = null;\n+        if (transactionOrScope instanceof Transaction) {\n+            transaction = (Transaction) transactionOrScope;\n+        } else if (transactionOrScope instanceof Scope) {\n+            scope = (Scope) transactionOrScope;\n         }\n+\n+        excluded.set(FALSE);\n         if (scope != null) {\n             scope.close();\n         }\n"}}, {"oid": "db15630aa76758604b14c0b2365512207fd3a1ac", "url": "https://github.com/elastic/apm-agent-java/commit/db15630aa76758604b14c0b2365512207fd3a1ac", "message": "issue-557 added automatically span creation for DispatcherTypes: FORWARD, INCLUDE, ERROR\nminor fixes with creating span that has same names\nadded path info for span name of FORWARD, INCLUDE dispatcher types.\ndelete testTransactionReportingWithErrorHandling test\nUpdate apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nCo-authored-by: eyalkoren <41850454+eyalkoren@users.noreply.github.com>\nUpdate apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nCo-authored-by: eyalkoren <41850454+eyalkoren@users.noreply.github.com>", "committedDate": "2020-08-05T16:21:11Z", "type": "commit"}, {"oid": "e77603e4d1477333942461bf64062d50fe2e104a", "url": "https://github.com/elastic/apm-agent-java/commit/e77603e4d1477333942461bf64062d50fe2e104a", "message": "merged from master", "committedDate": "2020-08-05T17:52:02Z", "type": "commit"}, {"oid": "e77603e4d1477333942461bf64062d50fe2e104a", "url": "https://github.com/elastic/apm-agent-java/commit/e77603e4d1477333942461bf64062d50fe2e104a", "message": "merged from master", "committedDate": "2020-08-05T17:52:02Z", "type": "forcePushed"}, {"oid": "52b87b92acaaaec5c596f67c873c3859705fa7d7", "url": "https://github.com/elastic/apm-agent-java/commit/52b87b92acaaaec5c596f67c873c3859705fa7d7", "message": "fixed logic with excluded for psans", "committedDate": "2020-08-06T21:48:30Z", "type": "commit"}, {"oid": "c0dee5794e079384260e3539dae85bde745f34d9", "url": "https://github.com/elastic/apm-agent-java/commit/c0dee5794e079384260e3539dae85bde745f34d9", "message": "fixed logic with span creating, before we check that parent span is has same name", "committedDate": "2020-08-07T19:15:15Z", "type": "commit"}, {"oid": "df6c456152ce9e9e57bbdf3a071c992c49369e64", "url": "https://github.com/elastic/apm-agent-java/commit/df6c456152ce9e9e57bbdf3a071c992c49369e64", "message": "Suggested changes", "committedDate": "2020-08-11T13:02:43Z", "type": "commit"}, {"oid": "deed18c5c5d999c9c105c61164fd9a3a28394fdd", "url": "https://github.com/elastic/apm-agent-java/commit/deed18c5c5d999c9c105c61164fd9a3a28394fdd", "message": "Merge pull request #6 from eyalkoren/suggested-changes\n\nSuggested changes", "committedDate": "2020-08-11T16:39:51Z", "type": "commit"}, {"oid": "0dc1a1f568d8be0fe364e63bff92b4834200b73c", "url": "https://github.com/elastic/apm-agent-java/commit/0dc1a1f568d8be0fe364e63bff92b4834200b73c", "message": "added RequestDispatcher.ERROR_EXCEPTION attribute exception handling", "committedDate": "2020-08-11T19:28:23Z", "type": "commit"}, {"oid": "532276b369f6339d1ffaf0dd80848bfdb5d12715", "url": "https://github.com/elastic/apm-agent-java/commit/532276b369f6339d1ffaf0dd80848bfdb5d12715", "message": "Merge remote-tracking branch 'upstream/master' into issue-557-track-spans-request-dispatcher-forward-include", "committedDate": "2020-08-12T06:44:39Z", "type": "commit"}, {"oid": "02605be8d4fb2a99161c4a503a079c150764e1ad", "url": "https://github.com/elastic/apm-agent-java/commit/02605be8d4fb2a99161c4a503a079c150764e1ad", "message": "Error handling", "committedDate": "2020-08-12T07:16:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzNjE1Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r469036152", "bodyText": "No, we can't do that as we don't know if it's the same exception or not.", "author": "eyalkoren", "createdAt": "2020-08-12T06:37:31Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -253,8 +254,12 @@ public static void onExitServletService(@Advice.Argument(0) ServletRequest servl\n                         Object throwable = request.getAttribute(attributeName);\n                         if (throwable instanceof Throwable) {\n                             t2 = (Throwable) throwable;\n-                            if (!attributeName.equals(\"javax.servlet.error.exception\")) {\n+                            if (!attributeName.equals(RequestDispatcher.ERROR_EXCEPTION)) {\n                                 overrideStatusCodeOnThrowable = false;\n+                            } else {\n+                                if (Boolean.TRUE.equals(isExceptionAttributeCaptured.get())) {\n+                                    t2 = null;\n+                                }", "originalCommit": "0dc1a1f568d8be0fe364e63bff92b4834200b73c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "02605be8d4fb2a99161c4a503a079c150764e1ad", "chunk": "diff --git a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nindex a723f6c27..91d902eb1 100644\n--- a/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n+++ b/apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n\n@@ -256,10 +255,6 @@ public class ServletApiAdvice {\n                             t2 = (Throwable) throwable;\n                             if (!attributeName.equals(RequestDispatcher.ERROR_EXCEPTION)) {\n                                 overrideStatusCodeOnThrowable = false;\n-                            } else {\n-                                if (Boolean.TRUE.equals(isExceptionAttributeCaptured.get())) {\n-                                    t2 = null;\n-                                }\n                             }\n                             break;\n                         }\n"}}, {"oid": "50290852236aeb820f6ea322844d71a2a94caf61", "url": "https://github.com/elastic/apm-agent-java/commit/50290852236aeb820f6ea322844d71a2a94caf61", "message": "Merge branch 'master' into issue-557-track-spans-request-dispatcher-forward-include\n\nAlso apply few minor changes", "committedDate": "2020-08-21T14:30:44Z", "type": "commit"}]}