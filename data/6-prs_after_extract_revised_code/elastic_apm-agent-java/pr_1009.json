{"pr_number": 1009, "pr_title": "Implement Binary TraceParent", "pr_createdAt": "2020-01-26T19:52:47Z", "pr_url": "https://github.com/elastic/apm-agent-java/pull/1009", "timeline": [{"oid": "0768b8137d5af485b249bd39d3d2ac2be5be6d07", "url": "https://github.com/elastic/apm-agent-java/commit/0768b8137d5af485b249bd39d3d2ac2be5be6d07", "message": "Implement Binary TraceParent", "committedDate": "2020-01-26T19:49:42Z", "type": "commit"}, {"oid": "21ad3b9f50cba0ae56861c3729d189f098ca4fa0", "url": "https://github.com/elastic/apm-agent-java/commit/21ad3b9f50cba0ae56861c3729d189f098ca4fa0", "message": "Cosmetic changes", "committedDate": "2020-01-27T02:34:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE3NTI5Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1009#discussion_r371175293", "bodyText": "Is there a chance that the header gets written after the TraceContext has been recycled?", "author": "felixbarny", "createdAt": "2020-01-27T10:58:15Z", "path": "apm-agent-plugins/apm-kafka-plugin/apm-kafka-headers-plugin/src/main/java/co/elastic/apm/agent/kafka/KafkaProducerHeadersInstrumentation.java", "diffHunk": "@@ -103,7 +103,7 @@ public static Span beforeSend(@Advice.FieldValue(\"apiVersions\") final ApiVersion\n             // https://kafka.apache.org/0110/documentation.html#messageformat\n             if (apiVersions.maxUsableProduceMagic() >= RecordBatch.MAGIC_VALUE_V2 && headersSupported) {\n                 try {\n-                    record.headers().add(TraceContext.TRACE_PARENT_HEADER,\n+                    record.headers().add(TraceContext.TRACE_PARENT_BINARY_HEADER_NAME,\n                         span.getTraceContext().getOutgoingTraceParentBinaryHeader());", "originalCommit": "21ad3b9f50cba0ae56861c3729d189f098ca4fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIyOTU5MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1009#discussion_r371229591", "bodyText": "This send method returns a callback that we wrap and the span is ended only when the callback's onCompletion method is called, so I can't see how...", "author": "eyalkoren", "createdAt": "2020-01-27T13:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE3NTI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMxMjEwOQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1009#discussion_r371312109", "bodyText": "What I would do is to have a ThreadLocal<RecordHeader>\nThen you can do :\nRecordHeader header = headerThreadLocal.get();\nspan.getTraceContext().fillOutgoingTraceParentBinaryHeader(header.value());\nThis minimizes allocations, as you don't have to allocate a Header each time, the TraceContext object does not get bigger in size and you also don't have to allocate a byte[] for the value. Additionally, there's no risk of using the value returned by span.getTraceContext().getOutgoingTraceParentBinaryHeader() at a wrong point in time.\nThe ThreadLocal works because after the send method got invoked, the header has already been serialized and sent out of process, thus it's safe to be re-used afterwards.\nIf you don't like", "author": "felixbarny", "createdAt": "2020-01-27T15:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE3NTI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMzNjEzNg==", "url": "https://github.com/elastic/apm-agent-java/pull/1009#discussion_r371336136", "bodyText": "I thought of reusing a header, but I decided not to do so as it increases dependency on internals. Both the Header implementation and relying on the headers being serialized during send (and not after - the record data is appended to some accumulator and handled asynchronously, I can imagine this being changed to defer headers serialization).\nI must admit this is very elegant though and it looks stable since 0.11.0.0....\nLet me think a bit on that", "author": "eyalkoren", "createdAt": "2020-01-27T16:15:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE3NTI5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "1b16bceb3b30f73a3e22ab6f2be42e10e69a2268", "chunk": "diff --git a/apm-agent-plugins/apm-kafka-plugin/apm-kafka-headers-plugin/src/main/java/co/elastic/apm/agent/kafka/KafkaProducerHeadersInstrumentation.java b/apm-agent-plugins/apm-kafka-plugin/apm-kafka-headers-plugin/src/main/java/co/elastic/apm/agent/kafka/KafkaProducerHeadersInstrumentation.java\nindex 79f4fc99c..9951b91b8 100644\n--- a/apm-agent-plugins/apm-kafka-plugin/apm-kafka-headers-plugin/src/main/java/co/elastic/apm/agent/kafka/KafkaProducerHeadersInstrumentation.java\n+++ b/apm-agent-plugins/apm-kafka-plugin/apm-kafka-headers-plugin/src/main/java/co/elastic/apm/agent/kafka/KafkaProducerHeadersInstrumentation.java\n\n@@ -103,8 +106,13 @@ public class KafkaProducerHeadersInstrumentation extends BaseKafkaHeadersInstrum\n             // https://kafka.apache.org/0110/documentation.html#messageformat\n             if (apiVersions.maxUsableProduceMagic() >= RecordBatch.MAGIC_VALUE_V2 && headersSupported) {\n                 try {\n-                    record.headers().add(TraceContext.TRACE_PARENT_BINARY_HEADER_NAME,\n-                        span.getTraceContext().getOutgoingTraceParentBinaryHeader());\n+                    //noinspection ConstantConditions\n+                    KafkaInstrumentationHeadersHelper<ConsumerRecord, ProducerRecord, Header> kafkaInstrumentationHelper =\n+                        kafkaInstrHeadersHelperManager.getForClassLoaderOfClass(KafkaProducer.class);\n+                    if (kafkaInstrumentationHelper != null) {\n+                        Header elasticHeader = kafkaInstrumentationHelper.getOutgoingTraceparentHeader(span);\n+                        record.headers().add(elasticHeader);\n+                    }\n                 } catch (final IllegalStateException e) {\n                     // headers are in a read-only state\n                     logger.debug(\"Failed to add header to Kafka record {}, probably to headers' read-only state.\", record);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE3NzI5OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1009#discussion_r371177298", "bodyText": "The use of binary headers is relatively rare but adding the outgoingBinaryHeader variable increases the memory consumption of each object in the pool.\nAny chance to use write the value to thread-local-buffered byte arrays? Caching in outgoingBinaryHeader does not seem to have much benefit, as I don't see how the same TraceContext would be injected multiple times in its binary form.\npublic void fillOutgoingTraceParentBinaryHeader(byte[] header) {", "author": "felixbarny", "createdAt": "2020-01-27T11:02:57Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceContext.java", "diffHunk": "@@ -384,11 +451,29 @@ private void fillTraceParentHeader(StringBuilder sb, Id spanId) {\n         spanId.writeAsHex(sb);\n         sb.append('-');\n         HexUtils.writeByteAsHex(flags, sb);\n+    }\n \n-        // todo: traceparent header- apply agreed binary format\n-        for (int i = 0; i < sb.length(); i++) {\n-            outgoingBinaryHeader[i] = (byte) sb.charAt(i);\n+    /**\n+     * Returns a binary representation of the {@code traceparent} header for downstream services.\n+     * <p>\n+     * NOTE: CALLER MAY NOT KEEP A REFERENCE TO THE RETURNED BYTE ARRAY, AS IT BELONGS TO THE TRACE CONTEXT INSTANCE\n+     */\n+    public byte[] getOutgoingTraceParentBinaryHeader() {", "originalCommit": "21ad3b9f50cba0ae56861c3729d189f098ca4fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIzMjg1Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1009#discussion_r371232853", "bodyText": "The use of binary headers is relatively rare but adding the outgoingBinaryHeader variable increases the memory consumption of each object in the pool.\n\nIt's 29 bytes. What we can do is lazily create the array only when used for the first time, so it will take this space only where used.\n\nAny chance to use write the value to thread-local-buffered byte arrays?\n\nSee the answer above- in Kafka another thread ends the span. It is possible that the thread sending the record will handle the send of another one before completion.", "author": "eyalkoren", "createdAt": "2020-01-27T13:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE3NzI5OA=="}], "type": "inlineReview", "revised_code": {"commit": "1b16bceb3b30f73a3e22ab6f2be42e10e69a2268", "chunk": "diff --git a/apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceContext.java b/apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceContext.java\nindex 0388d7ab2..731cbe631 100644\n--- a/apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceContext.java\n+++ b/apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceContext.java\n\n@@ -454,26 +451,28 @@ public class TraceContext extends TraceContextHolder {\n     }\n \n     /**\n-     * Returns a binary representation of the {@code traceparent} header for downstream services.\n-     * <p>\n-     * NOTE: CALLER MAY NOT KEEP A REFERENCE TO THE RETURNED BYTE ARRAY, AS IT BELONGS TO THE TRACE CONTEXT INSTANCE\n+     * Fills the given byte array with a binary representation of the {@code traceparent} header for downstream services.\n+     *\n+     * @param buffer buffer to fill\n+     * @return true if buffer was filled, false otherwise\n      */\n-    public byte[] getOutgoingTraceParentBinaryHeader() {\n-        if (!outgoingBinaryHeaderSet) {\n-            outgoingBinaryHeader[0] = BINARY_FORMAT_CURRENT_VERSION;\n-            outgoingBinaryHeader[BINARY_FORMAT_TRACE_ID_OFFSET] = BINARY_FORMAT_TRACE_ID_FIELD_ID;\n-            traceId.toBytes(outgoingBinaryHeader, BINARY_FORMAT_TRACE_ID_OFFSET + 1);\n-            outgoingBinaryHeader[BINARY_FORMAT_PARENT_ID_OFFSET] = BINARY_FORMAT_PARENT_ID_FIELD_ID;\n-            // for unsampled traces, propagate the ID of the transaction in calls to downstream services\n-            // such that the parentID of those transactions point to a transaction that exists\n-            // remember that we do report unsampled transactions\n-            Id parentId = isSampled() ? id : transactionId;\n-            parentId.toBytes(outgoingBinaryHeader, BINARY_FORMAT_PARENT_ID_OFFSET + 1);\n-            outgoingBinaryHeader[BINARY_FORMAT_FLAGS_OFFSET] = BINARY_FORMAT_FLAGS_FIELD_ID;\n-            outgoingBinaryHeader[BINARY_FORMAT_FLAGS_OFFSET + 1] = flags;\n-            outgoingBinaryHeaderSet = true;\n+    public boolean fillOutgoingTraceParentBinaryHeader(byte[] buffer) {\n+        if (buffer.length < BINARY_FORMAT_EXPECTED_LENGTH) {\n+            logger.warn(\"Given byte array does not have the minimal required length - {}\", BINARY_FORMAT_EXPECTED_LENGTH);\n+            return false;\n         }\n-        return outgoingBinaryHeader;\n+        buffer[0] = BINARY_FORMAT_CURRENT_VERSION;\n+        buffer[BINARY_FORMAT_TRACE_ID_OFFSET] = BINARY_FORMAT_TRACE_ID_FIELD_ID;\n+        traceId.toBytes(buffer, BINARY_FORMAT_TRACE_ID_OFFSET + 1);\n+        buffer[BINARY_FORMAT_PARENT_ID_OFFSET] = BINARY_FORMAT_PARENT_ID_FIELD_ID;\n+        // for unsampled traces, propagate the ID of the transaction in calls to downstream services\n+        // such that the parentID of those transactions point to a transaction that exists\n+        // remember that we do report unsampled transactions\n+        Id parentId = isSampled() ? id : transactionId;\n+        parentId.toBytes(buffer, BINARY_FORMAT_PARENT_ID_OFFSET + 1);\n+        buffer[BINARY_FORMAT_FLAGS_OFFSET] = BINARY_FORMAT_FLAGS_FIELD_ID;\n+        buffer[BINARY_FORMAT_FLAGS_OFFSET + 1] = flags;\n+        return true;\n     }\n \n     @Override\n"}}, {"oid": "1b16bceb3b30f73a3e22ab6f2be42e10e69a2268", "url": "https://github.com/elastic/apm-agent-java/commit/1b16bceb3b30f73a3e22ab6f2be42e10e69a2268", "message": "Apply review comments", "committedDate": "2020-01-29T09:50:21Z", "type": "commit"}, {"oid": "998abc2ee43968bd3026950a408f0bfeca7e8bae", "url": "https://github.com/elastic/apm-agent-java/commit/998abc2ee43968bd3026950a408f0bfeca7e8bae", "message": "Added to CHANGELOG.asciidoc", "committedDate": "2020-01-29T12:59:19Z", "type": "commit"}]}