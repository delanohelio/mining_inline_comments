{"pr_number": 985, "pr_title": "Reduce startup costs for AsyncHttpClient instrumentation", "pr_createdAt": "2020-01-08T10:12:24Z", "pr_url": "https://github.com/elastic/apm-agent-java/pull/985", "timeline": [{"oid": "f7e47b2e0b4474ac4fac7f7735577aee53d3a948", "url": "https://github.com/elastic/apm-agent-java/commit/f7e47b2e0b4474ac4fac7f7735577aee53d3a948", "message": "Reduce startup costs for AsyncHttpClient instrumentation", "committedDate": "2020-01-06T14:37:59Z", "type": "commit"}, {"oid": "a9ecafa89caaa6180b1c02bbb1e07a718f9d4b94", "url": "https://github.com/elastic/apm-agent-java/commit/a9ecafa89caaa6180b1c02bbb1e07a718f9d4b94", "message": "Reduce number of lookups and ResettableClassFileTransformers", "committedDate": "2020-01-08T15:26:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcyMzYzMA==", "url": "https://github.com/elastic/apm-agent-java/pull/985#discussion_r364723630", "bodyText": "Another non-supported case- an instrumentation that matches multiple methods (or multiple method overloads), that are not implemented at the same class in the hierarchy. Consider the StatementInstrumentation for example, where the method matching can apply to a class AND its superclass.\nNot a deal breaker, but can be overcome if instead of returning here, you would chain all matchers this method returns throughout the class inheritance (ie until classToInstrument.getSuperclass() == null)", "author": "eyalkoren", "createdAt": "2020-01-09T12:56:58Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "diffHunk": "@@ -394,4 +407,79 @@ public boolean matches(TypeDescription target) {\n     public static String getAgentHome() {\n         return agentJarFile == null ? null : agentJarFile.getParent();\n     }\n+\n+    public static void ensureInstrumented(Class<?> classToInstrument, Collection<Class<? extends ElasticApmInstrumentation>> instrumentationClasses) {\n+        Set<Collection<Class<? extends ElasticApmInstrumentation>>> appliedInstrumentations = getOrCreate(classToInstrument);\n+\n+        if (!appliedInstrumentations.contains(instrumentationClasses)) {\n+            synchronized (ElasticApmAgent.class) {\n+                ElasticApmTracer tracer = ElasticApmInstrumentation.tracer;\n+                if (tracer == null || instrumentation == null) {\n+                    throw new IllegalStateException(\"Agent is not initialized\");\n+                }\n+\n+                if (!appliedInstrumentations.contains(instrumentationClasses)) {\n+                    appliedInstrumentations = new HashSet<>(appliedInstrumentations);\n+                    appliedInstrumentations.add(instrumentationClasses);\n+                    // immutability guards against race conditions (for example concurrent rehash due to add and lookup)\n+                    appliedInstrumentations = Collections.unmodifiableSet(appliedInstrumentations);\n+                    dynamicallyInstrumentedClasses.put(classToInstrument, appliedInstrumentations);\n+\n+                    CoreConfiguration config = tracer.getConfig(CoreConfiguration.class);\n+                    final Logger logger = LoggerFactory.getLogger(ElasticApmAgent.class);\n+                    final ByteBuddy byteBuddy = new ByteBuddy()\n+                        .with(TypeValidation.of(logger.isDebugEnabled()))\n+                        .with(FailSafeDeclaredMethodsCompiler.INSTANCE);\n+                    AgentBuilder agentBuilder = getAgentBuilder(byteBuddy, config, logger, AgentBuilder.DescriptionStrategy.Default.HYBRID);\n+                    for (Class<? extends ElasticApmInstrumentation> instrumentationClass : instrumentationClasses) {\n+                        ElasticApmInstrumentation apmInstrumentation = instantiate(instrumentationClass);\n+                        ElementMatcher.Junction<TypeDescription> typeMatcher = getTypeMatcher(classToInstrument, apmInstrumentation.getMethodMatcher());\n+                        if (typeMatcher != null && isIncluded(apmInstrumentation, config)) {\n+                            agentBuilder = applyAdvice(tracer, agentBuilder, apmInstrumentation, typeMatcher.and(apmInstrumentation.getTypeMatcher()));\n+                        }\n+                    }\n+                    dynamicClassFileTransformers.add(agentBuilder.installOn(instrumentation));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static Set<Collection<Class<? extends ElasticApmInstrumentation>>> getOrCreate(Class<?> classToInstrument) {\n+        Set<Collection<Class<? extends ElasticApmInstrumentation>>> instrumentedClasses = dynamicallyInstrumentedClasses.get(classToInstrument);\n+        if (instrumentedClasses == null) {\n+            instrumentedClasses = new HashSet<Collection<Class<? extends ElasticApmInstrumentation>>>();\n+            Set<Collection<Class<? extends ElasticApmInstrumentation>>> racy = dynamicallyInstrumentedClasses.put(classToInstrument, instrumentedClasses);\n+            if (racy != null) {\n+                instrumentedClasses = racy;\n+            }\n+        }\n+        return instrumentedClasses;\n+    }\n+\n+    @Nullable\n+    private static ElementMatcher.Junction<TypeDescription> getTypeMatcher(Class<?> classToInstrument, ElementMatcher<? super MethodDescription> methodMatcher) {\n+\n+        MethodList<MethodDescription.InDefinedShape> matchingMethods = TypeDescription.ForLoadedType.of(classToInstrument).getDeclaredMethods().filter(methodMatcher);\n+        if (!matchingMethods.isEmpty()) {\n+            return is(classToInstrument);", "originalCommit": "a9ecafa89caaa6180b1c02bbb1e07a718f9d4b94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81b07fd422f7d680d390bdc967874bf9a1724f4d", "chunk": "diff --git a/apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java b/apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java\nindex 4e7784bb5..29312cbf9 100644\n--- a/apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java\n+++ b/apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java\n\n@@ -408,6 +409,18 @@ public class ElasticApmAgent {\n         return agentJarFile == null ? null : agentJarFile.getParent();\n     }\n \n+    /**\n+     * Instruments a specific class at runtime with one or multiple instrumentation classes.\n+     * <p>\n+     * Note that {@link ElasticApmInstrumentation#getTypeMatcher()} will be\n+     * {@linkplain net.bytebuddy.matcher.ElementMatcher.Junction#and(ElementMatcher) conjoined} with a\n+     * {@linkplain #getTypeMatcher(Class, ElementMatcher, ElementMatcher.Junction) computed} {@link TypeDescription}\n+     * that is specific to the provided class to instrument.\n+     * </p>\n+     *\n+     * @param classToInstrument the class which should be instrumented\n+     * @param instrumentationClasses the instrumentation which should be applied to the class to instrument.\n+     */\n     public static void ensureInstrumented(Class<?> classToInstrument, Collection<Class<? extends ElasticApmInstrumentation>> instrumentationClasses) {\n         Set<Collection<Class<? extends ElasticApmInstrumentation>>> appliedInstrumentations = getOrCreate(classToInstrument);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MzA1NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/985#discussion_r371273055", "bodyText": "maybe add a comment why it's safe to do with any() here", "author": "SylvainJuge", "createdAt": "2020-01-27T14:33:11Z", "path": "apm-agent-plugins/apm-asynchttpclient-plugin/src/main/java/co/elastic/apm/agent/asynchttpclient/AbstractAsyncHttpClientInstrumentation.java", "diffHunk": "@@ -123,7 +132,7 @@ protected AbstractAsyncHandlerInstrumentation(ElementMatcher<? super MethodDescr\n \n         @Override\n         public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n-            return hasSuperType(named(\"org.asynchttpclient.AsyncHandler\"));\n+            return any()/*.and(ElasticApmAgent.getTypeMatcher(asyncHandler.getClass()))*/;", "originalCommit": "a9ecafa89caaa6180b1c02bbb1e07a718f9d4b94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81b07fd422f7d680d390bdc967874bf9a1724f4d", "chunk": "diff --git a/apm-agent-plugins/apm-asynchttpclient-plugin/src/main/java/co/elastic/apm/agent/asynchttpclient/AbstractAsyncHttpClientInstrumentation.java b/apm-agent-plugins/apm-asynchttpclient-plugin/src/main/java/co/elastic/apm/agent/asynchttpclient/AbstractAsyncHttpClientInstrumentation.java\nindex d55418f81..f0a949388 100644\n--- a/apm-agent-plugins/apm-asynchttpclient-plugin/src/main/java/co/elastic/apm/agent/asynchttpclient/AbstractAsyncHttpClientInstrumentation.java\n+++ b/apm-agent-plugins/apm-asynchttpclient-plugin/src/main/java/co/elastic/apm/agent/asynchttpclient/AbstractAsyncHttpClientInstrumentation.java\n\n@@ -130,9 +130,13 @@ public abstract class AbstractAsyncHttpClientInstrumentation extends ElasticApmI\n             this.methodMatcher = methodMatcher;\n         }\n \n+        /**\n+         * Overridden in {@link ElasticApmAgent#ensureInstrumented(Class, Collection)},\n+         * based on the type of the {@linkplain AsyncHandler} implementation class.\n+         */\n         @Override\n         public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n-            return any()/*.and(ElasticApmAgent.getTypeMatcher(asyncHandler.getClass()))*/;\n+            return any();\n         }\n \n         @Override\n"}}, {"oid": "81b07fd422f7d680d390bdc967874bf9a1724f4d", "url": "https://github.com/elastic/apm-agent-java/commit/81b07fd422f7d680d390bdc967874bf9a1724f4d", "message": "Apply suggestions from code review", "committedDate": "2020-01-29T13:04:25Z", "type": "commit"}, {"oid": "13ea3462da0d3ff6eb17c6fe84f4d6d0a43673ea", "url": "https://github.com/elastic/apm-agent-java/commit/13ea3462da0d3ff6eb17c6fe84f4d6d0a43673ea", "message": "Merge remote-tracking branch 'origin/master' into improve-async-http-client-startup-overhead", "committedDate": "2020-01-29T13:33:37Z", "type": "commit"}]}