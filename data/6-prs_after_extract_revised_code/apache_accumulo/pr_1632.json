{"pr_number": 1632, "pr_title": "Fix #1609 dynamically reinitialize compaction services when config ch\u2026", "pr_createdAt": "2020-06-18T01:36:18Z", "pr_url": "https://github.com/apache/accumulo/pull/1632", "timeline": [{"oid": "a9173b735014810ce8514ff251ebff8586b9e71f", "url": "https://github.com/apache/accumulo/commit/a9173b735014810ce8514ff251ebff8586b9e71f", "message": "Fix #1609 dynamically reinitialize compaction services when config changes", "committedDate": "2020-06-18T01:31:03Z", "type": "commit"}, {"oid": "721e6ea24df526cb4c0d22ae4886ca65a13da86a", "url": "https://github.com/apache/accumulo/commit/721e6ea24df526cb4c0d22ae4886ca65a13da86a", "message": "fix spotbugs issue", "committedDate": "2020-06-22T19:56:15Z", "type": "commit"}, {"oid": "2b2469b4b20fe0829bbce081aa3ba0ff70c31b70", "url": "https://github.com/apache/accumulo/commit/2b2469b4b20fe0829bbce081aa3ba0ff70c31b70", "message": "remove TODO", "committedDate": "2020-06-24T00:17:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg3OTg4Nw==", "url": "https://github.com/apache/accumulo/pull/1632#discussion_r453879887", "bodyText": "Did you consider using a ConcurrentHashMap here?  I see you made the map volatile, but was wondering if it would help prevent concurrency issues to have a ConcurrentHashMap as well.", "author": "milleruntime", "createdAt": "2020-07-13T19:26:25Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/compactions/CompactionManager.java", "diffHunk": "@@ -20,34 +20,89 @@\n \n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.conf.Property;\n import org.apache.accumulo.core.dataImpl.KeyExtent;\n import org.apache.accumulo.core.spi.compaction.CompactionKind;\n import org.apache.accumulo.core.spi.compaction.CompactionServiceId;\n import org.apache.accumulo.core.spi.compaction.CompactionServices;\n-import org.apache.accumulo.core.spi.compaction.DefaultCompactionPlanner;\n import org.apache.accumulo.core.util.NamingThreadFactory;\n import org.apache.accumulo.fate.util.Retry;\n import org.apache.accumulo.server.ServerContext;\n-import org.apache.accumulo.tserver.TabletServerResourceManager;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.Sets;\n+\n public class CompactionManager {\n \n   private static final Logger log = LoggerFactory.getLogger(CompactionManager.class);\n \n   private Iterable<Compactable> compactables;\n-  private Map<CompactionServiceId,CompactionService> services;\n+  private volatile Map<CompactionServiceId,CompactionService> services;", "originalCommit": "2b2469b4b20fe0829bbce081aa3ba0ff70c31b70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA1OTYxNw==", "url": "https://github.com/apache/accumulo/pull/1632#discussion_r454059617", "bodyText": "I am using Map.copyOf() for the maps, so its a volatile pointer to an immutable map.   Whenever its updated the entire map is replaced with another immutable map.  This pattern is good for maps that are concurrently read a lot and updated infrequently.  The internal pointers in concurrent hash map are volatile, making all operations on the map slower.  The internal pointers in an immutable map are probably not volatile, just our pointer to the entire map is.", "author": "keith-turner", "createdAt": "2020-07-14T02:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg3OTg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM0NzE4Mg==", "url": "https://github.com/apache/accumulo/pull/1632#discussion_r454347182", "bodyText": "Thanks for the explanation.  I think what you have is fine.  I was just wondering what is the best way to guard against future changes which could introduce concurrency issues.  For example, you used a coding pattern which may not be obvious to a new developer, versus using a concrete type that is less likely to change.  Your code is definitely more efficient but it was not initially clear to me why.  Perhaps just some comments with your explanation or creating a method to specifically update the map would help.", "author": "milleruntime", "createdAt": "2020-07-14T13:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg3OTg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2NDM3MA==", "url": "https://github.com/apache/accumulo/pull/1632#discussion_r454564370", "bodyText": "I will add a comment.", "author": "keith-turner", "createdAt": "2020-07-14T18:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg3OTg4Nw=="}], "type": "inlineReview", "revised_code": null}]}