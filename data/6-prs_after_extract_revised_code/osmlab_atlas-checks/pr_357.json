{"pr_number": 357, "pr_title": "Generic Tag Checking (Osmose 3050, 3150, and 4090)", "pr_createdAt": "2020-09-08T14:18:49Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/357", "timeline": [{"oid": "07832a3079d4889a276ee49920667bb5c01b5e50", "url": "https://github.com/osmlab/atlas-checks/commit/07832a3079d4889a276ee49920667bb5c01b5e50", "message": "InvalidTagsCheck: Check for unwanted tags on objects\n\n* Skip tags that are checked by other tests (requires use of an\n  annotation). This check uses reflection to get annotated fields.\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-08T22:40:14Z", "type": "forcePushed"}, {"oid": "f474eb95010c58f65230c8c07f1fee24203591fb", "url": "https://github.com/osmlab/atlas-checks/commit/f474eb95010c58f65230c8c07f1fee24203591fb", "message": "InvalidTagsCheck: Check for unwanted tags on objects\n\n* Skip tags that are checked by other tests (requires use of an\n  annotation). This check uses reflection to get annotated fields.\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-09T21:44:53Z", "type": "forcePushed"}, {"oid": "68621da56de54e30c3f1a151a519cb9b42c3f805", "url": "https://github.com/osmlab/atlas-checks/commit/68621da56de54e30c3f1a151a519cb9b42c3f805", "message": "InvalidTagsCheck: SonarLint and some better organization\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-10T13:13:36Z", "type": "forcePushed"}, {"oid": "20af11e03774e6028ebbfeebd1a7c81690a491c5", "url": "https://github.com/osmlab/atlas-checks/commit/20af11e03774e6028ebbfeebd1a7c81690a491c5", "message": "InvalidTagsCheckTest: Add configuration method for databases\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-22T20:06:12Z", "type": "forcePushed"}, {"oid": "5e3808dfa9ea5b82bf94bf8f079ba9b6a7805266", "url": "https://github.com/osmlab/atlas-checks/commit/5e3808dfa9ea5b82bf94bf8f079ba9b6a7805266", "message": "InvalidTagsCheck: Documentation + Fix Suggestions\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-23T22:32:39Z", "type": "forcePushed"}, {"oid": "de73e0329829f3c726cb394201276118ac9781a8", "url": "https://github.com/osmlab/atlas-checks/commit/de73e0329829f3c726cb394201276118ac9781a8", "message": "FIXUP: Checkstyle\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-28T18:25:44Z", "type": "forcePushed"}, {"oid": "0296d4d0544e801a198a186462487f2014c8fac5", "url": "https://github.com/osmlab/atlas-checks/commit/0296d4d0544e801a198a186462487f2014c8fac5", "message": "GenericTagCheck: Add tests and some formatting fixes\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-13T17:51:36Z", "type": "forcePushed"}, {"oid": "a8e77a45d3c87074ff89ecb07c951bb66efd7b1e", "url": "https://github.com/osmlab/atlas-checks/commit/a8e77a45d3c87074ff89ecb07c951bb66efd7b1e", "message": "GenericTagCheck: Move fallback out of InvalidTagsCheck\n\n* Add tests and some formatting fixes\n* Move discrete code functions into separate methods", "committedDate": "2020-11-19T20:02:11Z", "type": "forcePushed"}, {"oid": "467bd146c5840938cb7dc1c0ebd5fe7f3d2236d6", "url": "https://github.com/osmlab/atlas-checks/commit/467bd146c5840938cb7dc1c0ebd5fe7f3d2236d6", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-19T20:08:20Z", "type": "forcePushed"}, {"oid": "dd04c146d01304ed90262e6a4a6f69aa2058a093", "url": "https://github.com/osmlab/atlas-checks/commit/dd04c146d01304ed90262e6a4a6f69aa2058a093", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-19T20:22:54Z", "type": "forcePushed"}, {"oid": "8719e529008683abda63b6d20dba449113673744", "url": "https://github.com/osmlab/atlas-checks/commit/8719e529008683abda63b6d20dba449113673744", "message": "GenericTagCheck: Don't add autofixes when not everything will be fixed\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-24T17:32:17Z", "type": "forcePushed"}, {"oid": "0d0d99ee3c7d8af9e78be9415dec2911bab5cb57", "url": "https://github.com/osmlab/atlas-checks/commit/0d0d99ee3c7d8af9e78be9415dec2911bab5cb57", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n        * Update older entries and write changes to a file\n\n        This means that changes can be inspected and verified (future task:\n        insert into an HTML page with links so people can more easily tell if\n        the change is relevant or not).\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-25T19:14:57Z", "type": "forcePushed"}, {"oid": "4968de9c1f4cf78456d6f8d4115f3654b5d2f20e", "url": "https://github.com/osmlab/atlas-checks/commit/4968de9c1f4cf78456d6f8d4115f3654b5d2f20e", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n        * Update older entries and write changes to a file\n\n        This means that changes can be inspected and verified (future task:\n        insert into an HTML page with links so people can more easily tell if\n        the change is relevant or not).\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-25T19:19:04Z", "type": "forcePushed"}, {"oid": "0fcf12a9456e712ed167ceb12410e50a8536f897", "url": "https://github.com/osmlab/atlas-checks/commit/0fcf12a9456e712ed167ceb12410e50a8536f897", "message": "GenericTagCheck: Add method stubs for country and relation checks", "committedDate": "2020-11-30T19:27:38Z", "type": "forcePushed"}, {"oid": "d5ce5e595bdc9c5a3a14ff8077f756862b466c11", "url": "https://github.com/osmlab/atlas-checks/commit/d5ce5e595bdc9c5a3a14ff8077f756862b466c11", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n        * Update older entries and write changes to a file\n\n        This means that changes can be inspected and verified (future task:\n        insert into an HTML page with links so people can more easily tell if\n        the change is relevant or not).\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-12-30T18:17:54Z", "type": "forcePushed"}, {"oid": "6e8daceeb4cee9de81fde07098945d1dda3e0505", "url": "https://github.com/osmlab/atlas-checks/commit/6e8daceeb4cee9de81fde07098945d1dda3e0505", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n        * Update older entries and write changes to a file\n\n        This means that changes can be inspected and verified (future task:\n        insert into an HTML page with links so people can more easily tell if\n        the change is relevant or not).\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-12-30T19:29:36Z", "type": "forcePushed"}, {"oid": "efae0e7a7ff3f6ea62255c92b0f6306a00311bd8", "url": "https://github.com/osmlab/atlas-checks/commit/efae0e7a7ff3f6ea62255c92b0f6306a00311bd8", "message": "GenericTagCheck: Mutation testing coverage\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-01-05T18:28:39Z", "type": "forcePushed"}, {"oid": "45b7e6e5fe7b5f3c96b00f5e1cb26544ebfa0831", "url": "https://github.com/osmlab/atlas-checks/commit/45b7e6e5fe7b5f3c96b00f5e1cb26544ebfa0831", "message": "FIXUP\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-01-12T23:53:50Z", "type": "forcePushed"}, {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8", "url": "https://github.com/osmlab/atlas-checks/commit/89e4aeb45c6c77a109977601606198a8225e3dc8", "message": "GenericTagCheck: Update text to include links for wiki data items\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T19:36:57Z", "type": "forcePushed"}, {"oid": "4eb7bca0cb44799dc57f4a51114e07b9404e74fe", "url": "https://github.com/osmlab/atlas-checks/commit/4eb7bca0cb44799dc57f4a51114e07b9404e74fe", "message": "GenericTagCheck: Update text to include links for wiki data items\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:52:43Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8", "url": "https://github.com/osmlab/atlas-checks/commit/89e4aeb45c6c77a109977601606198a8225e3dc8", "message": "GenericTagCheck: Update text to include links for wiki data items\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T19:36:57Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "0e79c9bf909bba0cfe1108aa793d0a74893c1793", "url": "https://github.com/osmlab/atlas-checks/commit/0e79c9bf909bba0cfe1108aa793d0a74893c1793", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n* Add checks for relations and tags that should only be in specific locations.\n* Attempt to avoid using edges in flags\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\n* FeatureChange: Add interfaces for remove/replace tag changes\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-08T17:34:34Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "6de6a55a77f08594b4a379dc0d1ccc1151e0b475", "url": "https://github.com/osmlab/atlas-checks/commit/6de6a55a77f08594b4a379dc0d1ccc1151e0b475", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n* Add checks for relations and tags that should only be in specific locations.\n* Attempt to avoid using edges in flags\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\n* FeatureChange: Add interfaces for remove/replace tag changes\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-12T13:14:45Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "6de6a55a77f08594b4a379dc0d1ccc1151e0b475", "url": "https://github.com/osmlab/atlas-checks/commit/6de6a55a77f08594b4a379dc0d1ccc1151e0b475", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n* Add checks for relations and tags that should only be in specific locations.\n* Attempt to avoid using edges in flags\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\n* FeatureChange: Add interfaces for remove/replace tag changes\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-12T13:14:45Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "c722599e05d7d2ba2bd117470a4fbf222ec893f7", "url": "https://github.com/osmlab/atlas-checks/commit/c722599e05d7d2ba2bd117470a4fbf222ec893f7", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nFeatureChange: Add interfaces for remove/replace tag changes\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-06-16T14:24:10Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "c3810a7a81523dda96ea4614be6b76da6ca108f3", "url": "https://github.com/osmlab/atlas-checks/commit/c3810a7a81523dda96ea4614be6b76da6ca108f3", "message": "FIXUP: GenericTagCheck: Improve wording for some tasks\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-06-16T15:03:50Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "e72d38256ec3c029927bddf033aef77e0c9a99ed", "url": "https://github.com/osmlab/atlas-checks/commit/e72d38256ec3c029927bddf033aef77e0c9a99ed", "message": "FIXUP: Formatting\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-06-16T17:52:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE4OTY1OA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r658189658", "bodyText": "One more to convert to var\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            final WikiData roleInfo = this\n          \n          \n            \n                            final var roleInfo = this", "author": "atiannicelli", "createdAt": "2021-06-24T18:31:58Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,939 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(((Edge) object).getMainEdge(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final WikiData roleInfo = this", "originalCommit": "65dab299c4c81c793bf8ef2cd78e368bd4332a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODIwMTM4MA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r658201380", "bodyText": "It is always fun when you miss one.\n8999207", "author": "tsmock", "createdAt": "2021-06-24T18:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE4OTY1OA=="}], "type": "inlineReview", "revised_code": {"commit": "66eb8e0d9487e96220bb2c32434857e66de81d09", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\ndeleted file mode 100644\nindex bcecce4..0000000\n--- a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n+++ /dev/null\n\n@@ -1,939 +0,0 @@\n-package org.openstreetmap.atlas.checks.validation.tag;\n-\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.TreeMap;\n-import java.util.TreeSet;\n-import java.util.function.Predicate;\n-import java.util.function.UnaryOperator;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-\n-import org.openstreetmap.atlas.checks.base.BaseCheck;\n-import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n-import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n-import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n-import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n-import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n-import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n-import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n-import org.openstreetmap.atlas.checks.flag.CheckFlag;\n-import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n-import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n-import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n-import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n-import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n-import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n-import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n-import org.openstreetmap.atlas.geography.atlas.items.Area;\n-import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n-import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n-import org.openstreetmap.atlas.geography.atlas.items.Edge;\n-import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n-import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n-import org.openstreetmap.atlas.geography.atlas.items.Relation;\n-import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n-import org.openstreetmap.atlas.locale.IsoCountry;\n-import org.openstreetmap.atlas.streaming.resource.Resource;\n-import org.openstreetmap.atlas.tags.ISOCountryTag;\n-import org.openstreetmap.atlas.tags.Taggable;\n-import org.openstreetmap.atlas.utilities.collections.Iterables;\n-import org.openstreetmap.atlas.utilities.configuration.Configuration;\n-import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Generic tag check using OSM Wiki Data and Tag Info databases.\n- *\n- * @author Taylor Smock\n- */\n-public class GenericTagCheck extends BaseCheck<String>\n-{\n-    private static final long serialVersionUID = 5150282147895785829L;\n-    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n-    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n-    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n-    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n-    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n-    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n-    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n-    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n-    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n-    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n-    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n-    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n-    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n-    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n-    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n-    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n-            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n-            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n-            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n-            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n-            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n-            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n-            .collect(Collectors.toCollection(ArrayList::new));\n-    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n-\n-    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n-    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n-    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n-\n-    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n-\n-    private final Long minTagUsage;\n-    // Due to serialization, this *cannot* be final\n-    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n-            .populateIgnoreTags();\n-\n-    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n-            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n-    private final List<String> tagsToRemove;\n-    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n-    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n-    private SQLiteUtils sqliteUtilsWikiData;\n-    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n-    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n-    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n-    private final String tagInfoDB;\n-    private final String wikiDataDB;\n-    private final String wikiTable;\n-    private final String tagInfoTagTable;\n-    private final String tagInfoKeyTable;\n-    private final int popularTagPercentageKey;\n-\n-    /**\n-     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n-     *\n-     * @param object\n-     *            The object to check\n-     * @return {@code true} if the object is an area\n-     */\n-    private static boolean isArea(final Taggable object)\n-    {\n-        return object instanceof Area\n-                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n-    }\n-\n-    /**\n-     * Check if an object may be an area\n-     *\n-     * @param object\n-     *            The object to check\n-     * @return {@code true} if the object <i>may</i> be an area.\n-     */\n-    private static boolean isClosedLine(final Taggable object)\n-    {\n-        return object instanceof LineItem && ((LineItem) object).isClosed();\n-    }\n-\n-    /**\n-     * Convert a tag entry into a string\n-     *\n-     * @param tag\n-     *            The tag to convert\n-     * @return A &ltkey&gt=&ltvalue&gt string\n-     */\n-    private static String tagToString(final Map.Entry<String, String> tag)\n-    {\n-        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n-                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n-    }\n-\n-    /**\n-     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n-     * checks with this constructor, supplying a configuration that can be used to adjust any\n-     * parameters that the check uses during operation.\n-     *\n-     * @param configuration\n-     *            the JSON configuration for this check\n-     * @param fileFetcher\n-     *            A fetcher to get external data with\n-     */\n-    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n-    {\n-        super(configuration);\n-        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n-                DEFAULT_MIN_TAG_USAGE);\n-\n-        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n-                DEFAULT_TAGS_TO_REMOVE);\n-        this.wikiTable = DEFAULT_WIKI_TABLE;\n-        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n-        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n-        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n-        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n-                DEFAULT_WIKIDATA_DB);\n-\n-        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n-        // a Long.\n-        this.popularTagPercentageKey = this\n-                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n-                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n-                .intValue();\n-\n-        // No matter what the atlas is, we need the db files. But only if we can get\n-        // them.\n-        if (fileFetcher == null)\n-        {\n-            return;\n-        }\n-        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n-        {\n-            final Optional<Resource> resource = fileFetcher.apply(file);\n-            if (!resource.isPresent() && logger.isDebugEnabled())\n-            {\n-                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n-            }\n-        }\n-        this.fetchWikiData(fileFetcher);\n-        this.fetchTagInfo(fileFetcher);\n-    }\n-\n-    /**\n-     * This function will validate if the supplied atlas object is valid for the check.\n-     *\n-     * @param object\n-     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n-     * @return {@code true} if this object should be checked\n-     */\n-    @Override\n-    public boolean validCheckForObject(final AtlasObject object)\n-    {\n-        return !object.getOsmTags().isEmpty()\n-                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n-    }\n-\n-    /**\n-     * This is the actual function that will check to see whether the object needs to be flagged.\n-     *\n-     * @param object\n-     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n-     * @return an optional {@link CheckFlag} object that\n-     */\n-    @Override\n-    protected Optional<CheckFlag> flag(final AtlasObject object)\n-    {\n-        // Test against each filter and create an instruction if the object passes\n-        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n-\n-        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n-        {\n-            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n-            {\n-                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n-            }\n-            this.flagTags(object, instructions);\n-        }\n-\n-        if (!instructions.isEmpty())\n-        {\n-            // Mark objects flagged by their class and id to allow for the same id in\n-            // different object types\n-            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n-\n-            // Create a flag with generic instructions\n-            final String instruction = this.getLocalizedInstruction(\n-                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n-                    object.getOsmIdentifier());\n-            // If the object is an edge add the edges with the same OSM id\n-            final CheckFlag flag = (object instanceof Edge)\n-                    ? this.createFlag(((Edge) object).getMainEdge(), instruction)\n-                    : this.createFlag(object, instruction);\n-\n-            // Add the specific instructions\n-            instructions.keySet().forEach(flag::addInstruction);\n-            /*\n-             * Only add autofixes when instructions are the same size as the changes. This avoids\n-             * situations where a change is available and is valid, but there is an additional issue\n-             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n-             * indicate that a change partially fixes the flag, this can be changed back to {@code\n-             * changes.isEmpty()}.\n-             */\n-            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n-            {\n-                flag.addFixSuggestions(Collections.singleton(\n-                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n-                                instructions.values().stream().flatMap(Collection::stream)\n-                                        .filter(Objects::nonNull).distinct()\n-                                        .collect(Collectors.toList()))));\n-            }\n-            return Optional.of(flag);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    @Override\n-    protected List<String> getFallbackInstructions()\n-    {\n-        return FALLBACK_INSTRUCTIONS;\n-    }\n-\n-    /**\n-     * Check for country specific rules\n-     *\n-     * @param instructions\n-     *            The instructions for the object\n-     * @param object\n-     *            The taggable object which should have country tags\n-     * @param tag\n-     *            The actual tag we are checking\n-     * @param wikiMap\n-     *            The map of wiki information\n-     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n-     */\n-    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n-    {\n-        // P48 shouldn't be used on actual key/tag items\n-        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n-                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n-        {\n-            /* Create a function that converts country/region wiki data into ISO3 codes */\n-            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n-                    .map(this::getWikiDataId)\n-                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n-                    .map(WikiData::getGeographicCodeP49)\n-                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n-                    .flatMap(Collection::stream)\n-                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n-                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n-            // Object ISOCountryTags appear to be ISO3 codes.\n-            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n-            String instruction = null;\n-            // The region keys are one or the other, but should never be both.\n-            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n-            {\n-                final Collection<String> onlyUsedInRegion = toWikiData\n-                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n-                // Some primitives may cross country lines, so if any country is a valid region,\n-                // continue on.\n-                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n-                {\n-                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n-                }\n-            }\n-            // check on P30 becomes redundant due to earlier check.\n-            else\n-            {\n-                final Collection<String> notUsedInRegion = toWikiData\n-                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n-                // If countries is empty, then don't bother checking. Otherwise, allMatch\n-                // returns true.\n-                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n-                {\n-                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n-                }\n-            }\n-            // If the tag shouldn't be used in the region/area, it should be removed\n-            if (instruction != null)\n-            {\n-                instructions.put(\n-                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n-                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n-                                wikiMap.getId()),\n-                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n-            }\n-\n-            return instruction != null;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n-     *\n-     * @param instructions\n-     *            The instructions to add to\n-     * @param tag\n-     *            The tag to check\n-     * @param keyInfo\n-     *            The information for the key\n-     * @param popular\n-     *            {@code true} if the key is \"popular\"\n-     * @param tagOccurrence\n-     *            The information from TagInfo for the tag\n-     * @param keyOccurrence\n-     *            The information from TagInfo for the key\n-     */\n-    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n-            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n-    {\n-        if (keyInfo == null)\n-        {\n-            final String count;\n-            final Map.Entry<String, String> messageTag;\n-            if (tagOccurrence.getCountAll() != null)\n-            {\n-                count = tagOccurrence.getCountAll().toString();\n-                messageTag = tag;\n-            }\n-            else if (keyOccurrence.getCountAll() != null)\n-            {\n-                count = keyOccurrence.getCountAll().toString();\n-                messageTag = Map.entry(tag.getKey(), \"\");\n-            }\n-            else\n-            {\n-                count = \"<\" + this.minTagUsage.toString();\n-                messageTag = tag;\n-            }\n-            // Check for unpopular/bad tags not already caught by wiki check\n-            if (!popular)\n-            {\n-                instructions.put(this.getLocalizedInstruction(\n-                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n-                        tagToString(tag), count), Collections.emptyList());\n-            }\n-            else\n-            {\n-                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n-                instructions.put(this.getLocalizedInstruction(\n-                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n-                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n-                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n-                                .toString()),\n-                        Collections.emptyList());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n-     * instruction and change for that.\n-     *\n-     * @param instructions\n-     *            The instructions collection to add to\n-     * @param changes\n-     *            The changes collection to add to\n-     * @param tag\n-     *            The tag to check\n-     * @param checkInfo\n-     *            Wiki Data information (more specific)\n-     * @return {@code true} if the tag fails the regex\n-     */\n-    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData checkInfo)\n-    {\n-        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n-        {\n-            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n-                    ? checkInfo.getPermanentKeyIdP16()\n-                    : checkInfo.getPermanentTagIdP19();\n-            final Collection<String> redirects = checkInfo.getRedirectToP17();\n-            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n-\n-            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n-\n-            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n-                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n-            final Collection<IFeatureChange> featureChanges;\n-            if (!replacements.isEmpty())\n-            {\n-                featureChanges = new ArrayList<>();\n-                featureChanges.add(new RemoveTagFeatureChange(tag));\n-                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n-                {\n-                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n-                }\n-            }\n-            else\n-            {\n-                featureChanges = Collections.emptyList();\n-            }\n-\n-            instructions.put(\n-                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n-                            value,\n-                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n-                                    .collect(Collectors.joining(\", \")),\n-                            checkInfo.getId()),\n-                    featureChanges);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check regexes for a tag\n-     *\n-     * @param instructions\n-     *            The instruction collection to append instructions to\n-     * @param tag\n-     *            The specific tag to check\n-     * @param checkInfo\n-     *            Wiki Data information (specific, if available)\n-     * @return {@code true} if the regex failed\n-     */\n-    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData checkInfo)\n-    {\n-        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n-        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n-        {\n-            // Reuse the compiled patterns\n-            final var pattern = checkInfo.getValueValidationRegexP13();\n-            if (!pattern.matcher(tag.getValue()).matches())\n-            {\n-                instructions.put(this.getLocalizedInstruction(\n-                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n-                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n-                        Collections.emptyList());\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Do relation specific checks\n-     *\n-     * @param instructions\n-     *            Instructions to add to\n-     * @param The\n-     *            object to check\n-     * @param checkInfo\n-     *            The wiki information for the tag to be checked\n-     * @param tag\n-     *            The tag to be checked\n-     * @return {@code true} if the relation had a problem\n-     */\n-    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n-    {\n-        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n-                && \"type\".equals(tag.getKey()))\n-        {\n-            final var relation = (Relation) object;\n-            final var relationInfo = this.getWikiData(\n-                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n-            if (relationInfo == null)\n-            {\n-                instructions.put(\n-                        this.getLocalizedInstruction(\n-                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n-                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n-                        Collections.emptyList());\n-                return true;\n-            }\n-            final Collection<String> additionalInstructions = new TreeSet<>();\n-            for (final RelationMember relationMember : relation.members())\n-            {\n-                // Empty roles should exist in WikiData\n-                final String role = relationMember.getRole();\n-                final WikiData roleInfo = this\n-                        .getWikiData(Map.of(WikiProperty.RELATION_ROLE_ID_P21.getId(),\n-                                relationInfo.getPermanentRelationTypeIdP41() + \"=\" + role));\n-                if (roleInfo == null)\n-                {\n-                    final var roleMember = relationMember.getEntity();\n-                    additionalInstructions.add(this.getLocalizedInstruction(\n-                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_ROLE),\n-                            relationInfo.getPermanentRelationTypeIdP41(), role,\n-                            AtlasToOsmType.convert(roleMember.getType()),\n-                            roleMember.getOsmIdentifier(), relation.getOsmIdentifier(),\n-                            checkInfo.getId()));\n-                }\n-            }\n-            additionalInstructions\n-                    .forEach(instruction -> instructions.put(instruction, Collections.emptyList()));\n-            return !additionalInstructions.isEmpty();\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check the status of a tag\n-     *\n-     * @param instructions\n-     *            The instruction collection to append instructions to\n-     * @param changes\n-     *            The changes to add a change to (removal)\n-     * @param tag\n-     *            The specific tag to check\n-     * @param checkInfo\n-     *            Wiki Data information (specific, if available)\n-     * @param wellKnown\n-     *            If the tag has well-defined values\n-     * @return {@code true} if the tag should be removed (change already added to {@code changes})\n-     */\n-    private boolean checkStatus(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown)\n-    {\n-        if (wellKnown && checkInfo != null && checkInfo.getStatusP6() != null\n-                && this.tagsToRemove.stream().anyMatch(t -> checkInfo.getStatusP6().matches(t)))\n-        {\n-            instructions.put(\n-                    this.getLocalizedInstruction(\n-                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_WIKI_DATA_REMOVAL),\n-                            tag.getKey(), tag.getValue(),\n-                            checkInfo.getStatusP6().getDescriptor().toLowerCase(Locale.ENGLISH),\n-                            checkInfo.getId()),\n-                    Collections.singleton(new RemoveTagFeatureChange(tag)));\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check for instances where a key is well-known but the value is not one of the well-known\n-     * values.\n-     *\n-     * @param instructions\n-     *            The instructions to add to\n-     * @param changes\n-     *            The changes to add to\n-     * @param tag\n-     *            The tag to check\n-     * @param checkInfo\n-     *            Wiki Data information (more specific)\n-     * @param wellKnown\n-     *            {@code true} if values are well-known\n-     * @param popular\n-     *            {@code true} if the tag is popular\n-     * @param tagOccurrence\n-     *            The TagInfo information for the tag\n-     * @return {@code true} if an issue was found\n-     */\n-    private boolean checkUndocumentedPopularWellDefined(\n-            final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown,\n-            final boolean popular, final TagInfoTags tagOccurrence)\n-    {\n-        if (wellKnown && checkInfo == null)\n-        {\n-            if (popular)\n-            {\n-                instructions.put(\n-                        this.getLocalizedInstruction(\n-                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNDOCUMENTED_POPULAR_TAG),\n-                                tag.getKey(), tag.getValue(), tagOccurrence.getCountAll()),\n-                        Collections.emptyList());\n-            }\n-            else\n-            {\n-                instructions.put(\n-                        this.getLocalizedInstruction(\n-                                FALLBACK_INSTRUCTIONS\n-                                        .indexOf(INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE),\n-                                tag.getValue(), tag.getKey()),\n-                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check the tag against wiki data for cases where it should not appear on the object.\n-     *\n-     * @param changes\n-     *            The changes for the object\n-     * @param instructions\n-     *            The instruction collection to append instructions to\n-     * @param tag\n-     *            The specific tag to check\n-     * @param object\n-     *            The atlas object (used to check if the tag is expected on the object)\n-     * @param checkInfo\n-     *            Wiki Data information (more specific)\n-     * @return {@code true} if there is an unwanted tag on an object\n-     */\n-    private boolean checkUnwantedTagOnObject(final Taggable object,\n-            final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData checkInfo)\n-    {\n-        final List<String> newInstructions = new ArrayList<>();\n-        if (object instanceof LocationItem && !checkInfo.isUseOnNodesP33())\n-        {\n-            newInstructions.add(this.getLocalizedInstruction(\n-                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_PROHIBITED_USAGE), tag.getKey(),\n-                    tag.getValue(), \"node\", checkInfo.getId()));\n-        }\n-\n-        /*\n-         * A line may be considered a way or an area. Account for instances where Atlas doesn't know\n-         * a tag makes something an area. Also account for instances where linear ways have been\n-         * converted into areas.\n-         */\n-        if ((isArea(object) || isClosedLine(object)) && !checkInfo.isUseOnWaysP34()\n-                && !checkInfo.isUseOnAreasP35())\n-        {\n-            newInstructions.add(this.getLocalizedInstruction(\n-                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_PROHIBITED_USAGE), tag.getKey(),\n-                    tag.getValue(), \"area\", checkInfo.getId()));\n-        }\n-        else if (object instanceof LineItem && !checkInfo.isUseOnWaysP34() && !isClosedLine(object))\n-        {\n-            newInstructions.add(this.getLocalizedInstruction(\n-                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_PROHIBITED_USAGE), tag.getKey(),\n-                    tag.getValue(), \"way\", checkInfo.getId()));\n-        }\n-\n-        if (object instanceof Relation && !checkInfo.isUseOnRelationsP36() && !isArea(object))\n-        {\n-            newInstructions.add(this.getLocalizedInstruction(\n-                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_PROHIBITED_USAGE), tag.getKey(),\n-                    tag.getValue(), \"relation\", checkInfo.getId()));\n-        }\n-        if (!newInstructions.isEmpty())\n-        {\n-            final Collection<IFeatureChange> delete = Collections\n-                    .singleton(new RemoveTagFeatureChange(tag));\n-            newInstructions.forEach(instruction -> instructions.put(instruction, delete));\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check the tag to ensure that it exists in Wiki Data Items\n-     *\n-     * @param instructions\n-     *            The instruction collection to append instructions to\n-     * @param tag\n-     *            The specific tag to check\n-     * @param object\n-     *            The atlas object (used to check if the tag is expected on the object)\n-     * @param wellKnown\n-     *            If the tag has well-defined values\n-     * @param checkInfo\n-     *            Wiki Data information (specific, if available)\n-     */\n-    private void checkWikiData(final Taggable object,\n-            final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData keyInfo, final WikiData checkInfo,\n-            final boolean wellKnown)\n-    {\n-        final TagInfoTags tagOccurrence = (TagInfoTags) this.getTagInfo(tag.getKey(),\n-                tag.getValue());\n-        final TagInfoKeys keyOccurrence = (TagInfoKeys) this.getTagInfo(tag.getKey(), null);\n-        final boolean popular = this.isPopular(keyOccurrence, tagOccurrence);\n-        if (this.checkRegex(instructions, tag, checkInfo)\n-                || this.checkUndocumentedPopularWellDefined(instructions, tag, checkInfo, wellKnown,\n-                        popular, tagOccurrence)\n-                || this.checkStatus(instructions, tag, checkInfo, wellKnown)\n-                || this.checkRedirectTo(instructions, tag, checkInfo)\n-                || this.checkRelations(instructions, object, tag, checkInfo)\n-                || this.checkCountrySpecific(instructions, object, tag, checkInfo)\n-                || (checkInfo != null\n-                        && this.checkUnwantedTagOnObject(object, instructions, tag, checkInfo)))\n-        {\n-            return;\n-        }\n-\n-        // Osmose 3040, 3050, and 3150 fallback/extra instructions\n-        this.checkFallback(instructions, tag, keyInfo, popular, tagOccurrence, keyOccurrence);\n-    }\n-\n-    /**\n-     * Fetch tag info\n-     *\n-     * @param fileFetcher\n-     *            The filefetcher to use\n-     */\n-    private void fetchTagInfo(final ExternalDataFetcher fileFetcher)\n-    {\n-        this.sqliteUtilsTagInfoKeyTable = new SQLiteUtils(fileFetcher, this.tagInfoDB,\n-                this.tagInfoKeyTable);\n-        if (!SQLiteUtils.isValidDatabase(this.sqliteUtilsTagInfoKeyTable.getFile()))\n-        {\n-            this.sqliteUtilsTagInfoKeyTable = null;\n-        }\n-        this.sqliteUtilsTagInfoTagTable = new SQLiteUtils(fileFetcher, this.tagInfoDB,\n-                this.tagInfoTagTable);\n-        if (!SQLiteUtils.isValidDatabase(this.sqliteUtilsTagInfoTagTable.getFile()))\n-        {\n-            this.sqliteUtilsTagInfoTagTable = null;\n-        }\n-    }\n-\n-    /**\n-     * Fetch wiki data\n-     *\n-     * @param fileFetcher\n-     *            The filefetcher to use\n-     */\n-    private void fetchWikiData(final ExternalDataFetcher fileFetcher)\n-    {\n-        this.sqliteUtilsWikiData = new SQLiteUtils(fileFetcher, this.wikiDataDB, this.wikiTable);\n-        if (!SQLiteUtils.isValidDatabase(this.sqliteUtilsWikiData.getFile()))\n-        {\n-            this.sqliteUtilsWikiData = null;\n-        }\n-    }\n-\n-    /**\n-     * Flag tags\n-     *\n-     * @param object\n-     *            The object to iterate through\n-     * @param instructions\n-     *            The instructions to add to\n-     */\n-    private void flagTags(final AtlasObject object,\n-            final Map<String, Collection<IFeatureChange>> instructions)\n-    {\n-        // Check for bad tags (i.e., wrong object type, regex doesn't match, wiki data\n-        // doesn't exist)\n-        for (final Map.Entry<String, String> entry : object.getOsmTags().entrySet())\n-        {\n-            for (final String value : entry.getValue().split(\";\", -1))\n-            {\n-                final Map.Entry<String, String> tagEntry = Map.entry(entry.getKey(), value);\n-                // Use TestTaggable to avoid matching on common tags\n-                if (this.ignoreTags.parallelStream().anyMatch(\n-                        p -> p.test(new TestTaggable(tagEntry.getKey(), tagEntry.getValue()))))\n-                {\n-                    continue;\n-                }\n-                // Osmose 3040, 3050, and 3150\n-                final var keyInfo = this.getWikiData(tagEntry.getKey(), null);\n-                WikiData checkInfo = keyInfo;\n-                // \"P9\" is \"key type\", \"Q8\" is \"well-known values\"\n-                final boolean wellKnown = keyInfo != null\n-                        && WikiDataItem.WELL_KNOWN_VALUES_Q8.matches(keyInfo.getKeyTypeP9());\n-                if (wellKnown)\n-                {\n-                    checkInfo = this.getWikiData(tagEntry.getKey(), tagEntry.getValue());\n-                }\n-\n-                this.checkWikiData(object, instructions, tagEntry, keyInfo, checkInfo, wellKnown);\n-            }\n-\n-        }\n-    }\n-\n-    /**\n-     * Get the TagInfo for a specific key and value\n-     *\n-     * @param key\n-     *            The key to get\n-     * @param value\n-     *            The value to get (if {@code null}, information is pulled from the keys table\n-     *            instead of tags)\n-     * @return A map entry with a key of the tag (or key, if value is {@code null}) and the number\n-     *         of worldwide occurrences.\n-     */\n-    @Nonnull\n-    private TagInfoKeyTagCommon getTagInfo(final String key, final String value)\n-    {\n-        final Map<String, Object> map;\n-        if (value != null)\n-        {\n-            map = this.sqliteUtilsTagInfoTagTable.getRows(Map.of(\"key\", key, \"value\", value));\n-            return new TagInfoTags(map);\n-        }\n-        map = this.sqliteUtilsTagInfoKeyTable.getRows(Map.of(\"key\", key));\n-        return new TagInfoKeys(map);\n-    }\n-\n-    /**\n-     * Get the Wiki Data for a specific key and value\n-     *\n-     * @param key\n-     *            The key to get the wiki data for\n-     * @param value\n-     *            The value to get the wiki data for (may be {@code null})\n-     * @return The map for the specified key/value combination\n-     */\n-    @Nullable\n-    private WikiData getWikiData(final String key, final String value)\n-    {\n-        Objects.requireNonNull(key, \"key cannot be null\");\n-        if (value == null || value.isBlank())\n-        {\n-            // \"P16\" is the \"permanent key id\" (e.g. \"highway\")\n-            return this.getWikiData(Map.of(WikiProperty.PERMANENT_KEY_ID_P16.getId(), key));\n-        }\n-        final var tag = String.join(\"=\", key, value);\n-        // \"P19\" is the \"permanent tag id\" (e.g. \"highway=residential\")\n-        return this.getWikiData(Map.of(WikiProperty.PERMANENT_TAG_ID_P19.getId(), tag));\n-    }\n-\n-    /**\n-     * Get arbitrary values from the wiki data\n-     *\n-     * @param searchValues\n-     *            The key-value search map\n-     * @return A wiki data item, if one exists\n-     */\n-    @Nullable\n-    private WikiData getWikiData(final Map<String, String> searchValues)\n-    {\n-        return WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(searchValues));\n-    }\n-\n-    /**\n-     * Get Wiki Data for an id\n-     *\n-     * @param identifier\n-     *            The id to get\n-     * @return The WikiData item\n-     */\n-    @Nullable\n-    private WikiData getWikiDataId(final String identifier)\n-    {\n-        Objects.requireNonNull(identifier, \"id cannot be null\");\n-        final var data = WikiData.getWikiData(identifier);\n-        if (data != null)\n-        {\n-            return data;\n-        }\n-        // The id column has no ID (P2, P3, etc).\n-        return this.getWikiData(Map.of(WikiProperty.ID.getDescriptor(), identifier));\n-    }\n-\n-    private boolean isPopular(final TagInfoKeys keyOccurrence, final TagInfoTags tagOccurrence)\n-    {\n-        if (tagOccurrence != null && tagOccurrence.getCountAll() != null\n-                && tagOccurrence.getCountAll().longValue() > this.minTagUsage)\n-        {\n-            return true;\n-        }\n-        return keyOccurrence.getCountAll() != null\n-                && keyOccurrence.getCountAll().longValue() > this.minTagUsage\n-                && keyOccurrence.getCountAll().longValue()\n-                        / keyOccurrence.getValuesAll().longValue() < this.popularTagPercentageKey;\n-    }\n-\n-    /**\n-     * Parse a tag from a map (wiki data)\n-     *\n-     * @param map\n-     *            The map to parse tags from\n-     * @return An entry for the tag\n-     */\n-    @Nullable\n-    private Map.Entry<String, String> parseTags(@Nonnull final WikiData map)\n-    {\n-        final String key = map.getPermanentKeyIdP16();\n-        if (!key.isBlank())\n-        {\n-            return Map.entry(key, \"\");\n-        }\n-        final String tag = map.getPermanentTagIdP19();\n-        if (!tag.isBlank())\n-        {\n-            final String[] tagId = tag.split(\"=\", 2);\n-            if (tagId.length == 2)\n-            {\n-                return Map.entry(tagId[0], tagId[1]);\n-            }\n-        }\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA4NDU5NA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669084594", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    catch (final IOException e)\n          \n          \n            \n                    catch (final IOException exception)", "author": "Bentleysb", "createdAt": "2021-07-13T20:25:14Z", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/KeyFullyCheckedUtils.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import org.apache.commons.lang3.reflect.FieldUtils;\n+import org.openstreetmap.atlas.checks.validation.tag.GenericTagCheck;\n+import org.openstreetmap.atlas.checks.validation.tag.InvalidTagsCheck;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.reflect.ClassPath;\n+import com.google.common.reflect.ClassPath.ClassInfo;\n+\n+/**\n+ * Utils to find fully checked keys (only use this for generic tests, such as\n+ * {@link GenericTagCheck}).\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class KeyFullyCheckedUtils\n+{\n+    private static final Logger logger = LoggerFactory.getLogger(KeyFullyCheckedUtils.class);\n+\n+    /**\n+     * Populate ignore tags using reflection and looking for annotations using\n+     * {@link KeyFullyChecked} in the current package.\n+     *\n+     * @return A collection of predicates to use to determine if a tag should be ignored.\n+     */\n+    public static Collection<Predicate<Taggable>> populateIgnoreTags()\n+    {\n+        final List<TaggableFilter> filters = new ArrayList<>();\n+        final List<Predicate<Taggable>> predicateFilters = new ArrayList<>();\n+        final var classLoader = InvalidTagsCheck.class.getClassLoader();\n+        Set<ClassInfo> classInfoList;\n+        try\n+        {\n+            classInfoList = ClassPath.from(classLoader)\n+                    .getTopLevelClassesRecursive(InvalidTagsCheck.class.getPackageName());\n+        }\n+        catch (final IOException e)", "originalCommit": "fe33333d169d44c3bb679decd0c7f055d3ed27dd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66eb8e0d9487e96220bb2c32434857e66de81d09", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/utility/KeyFullyCheckedUtils.java b/src/main/java/org/openstreetmap/atlas/checks/utility/KeyFullyCheckedUtils.java\ndeleted file mode 100644\nindex c933142..0000000\n--- a/src/main/java/org/openstreetmap/atlas/checks/utility/KeyFullyCheckedUtils.java\n+++ /dev/null\n\n@@ -1,181 +0,0 @@\n-package org.openstreetmap.atlas.checks.utility;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.function.Predicate;\n-\n-import org.apache.commons.lang3.reflect.FieldUtils;\n-import org.openstreetmap.atlas.checks.validation.tag.GenericTagCheck;\n-import org.openstreetmap.atlas.checks.validation.tag.InvalidTagsCheck;\n-import org.openstreetmap.atlas.tags.Taggable;\n-import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n-import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.reflect.ClassPath;\n-import com.google.common.reflect.ClassPath.ClassInfo;\n-\n-/**\n- * Utils to find fully checked keys (only use this for generic tests, such as\n- * {@link GenericTagCheck}).\n- *\n- * @author Taylor Smock\n- */\n-public final class KeyFullyCheckedUtils\n-{\n-    private static final Logger logger = LoggerFactory.getLogger(KeyFullyCheckedUtils.class);\n-\n-    /**\n-     * Populate ignore tags using reflection and looking for annotations using\n-     * {@link KeyFullyChecked} in the current package.\n-     *\n-     * @return A collection of predicates to use to determine if a tag should be ignored.\n-     */\n-    public static Collection<Predicate<Taggable>> populateIgnoreTags()\n-    {\n-        final List<TaggableFilter> filters = new ArrayList<>();\n-        final List<Predicate<Taggable>> predicateFilters = new ArrayList<>();\n-        final var classLoader = InvalidTagsCheck.class.getClassLoader();\n-        Set<ClassInfo> classInfoList;\n-        try\n-        {\n-            classInfoList = ClassPath.from(classLoader)\n-                    .getTopLevelClassesRecursive(InvalidTagsCheck.class.getPackageName());\n-        }\n-        catch (final IOException e)\n-        {\n-            logger.error(e.getMessage(), e);\n-            classInfoList = Collections.emptySet();\n-        }\n-        for (final ClassPath.ClassInfo info : classInfoList)\n-        {\n-            final Class<?> clazz = info.load();\n-            final Field[] fields = FieldUtils.getFieldsWithAnnotation(clazz, KeyFullyChecked.class);\n-            for (final Field field : fields)\n-            {\n-                getTagFromField(clazz, field, filters, predicateFilters);\n-            }\n-        }\n-        filters.forEach(filter -> predicateFilters.add(filter::test));\n-        return predicateFilters;\n-    }\n-\n-    /**\n-     * Get tag checks from fields\n-     *\n-     * @param clazz\n-     *            The class with the field\n-     * @param field\n-     *            The field to get (must have the {@link KeyFullyChecked} annotation)\n-     * @param filters\n-     *            The filters to add {@link TaggableFilter}s to.\n-     * @param predicateFilters\n-     *            The filters to add {@link Predicate}s to\n-     */\n-    private static void getTagFromField(final Class<?> clazz, final Field field,\n-            final List<TaggableFilter> filters, final List<Predicate<Taggable>> predicateFilters)\n-    {\n-\n-        final KeyFullyChecked annotation = field.getAnnotation(KeyFullyChecked.class);\n-        final Object fieldObject;\n-        try\n-        {\n-            field.trySetAccessible();\n-            fieldObject = field.get(clazz);\n-            if (fieldObject == null)\n-            {\n-                throw new IllegalArgumentException(MessageFormat.format(\n-                        \"@KeyFullyChecked fields must be initialized in a static manner ({0}: {1})\",\n-                        clazz.getSimpleName(), field.getName()));\n-            }\n-        }\n-        catch (IllegalArgumentException | IllegalAccessException e1)\n-        {\n-            logger.error(e1.getMessage(), e1);\n-            return;\n-        }\n-        if (KeyFullyChecked.Type.TAGGABLE_FILTER == annotation.value())\n-        {\n-            getTagFromFieldTaggable(field, fieldObject, filters, predicateFilters);\n-        }\n-        else if (KeyFullyChecked.Type.TAG_KEY == annotation.value())\n-        {\n-            if (fieldObject instanceof Class)\n-            {\n-                predicateFilters.add(Validators.hasValuesFor((Class<?>) fieldObject));\n-            }\n-            else\n-            {\n-                predicateFilters.add(Validators.hasValuesFor(fieldObject.getClass()));\n-            }\n-        }\n-        else if (KeyFullyChecked.Type.PARTIAL == annotation.value())\n-        {\n-            final var value = fieldObject.toString();\n-            predicateFilters.add(taggable -> taggable.getTags().entrySet().parallelStream()\n-                    .anyMatch(e -> e.getKey().contains(value)));\n-        }\n-        else if (logger.isErrorEnabled())\n-        {\n-            logger.error(\n-                    MessageFormat.format(\"We don''t currently handle {0}\", annotation.value()));\n-        }\n-    }\n-\n-    /**\n-     * Get taggable checks from fields\n-     *\n-     * @param field\n-     *            The field to get (must have the {@link KeyFullyChecked} annotation)\n-     * @param fieldObject\n-     *            The field object\n-     * @param filters\n-     *            The filters to add {@link TaggableFilter}s to.\n-     * @param predicateFilters\n-     *            The filters to add {@link Predicate}s to\n-     */\n-    private static void getTagFromFieldTaggable(final Field field, final Object fieldObject,\n-            final List<TaggableFilter> filters, final List<Predicate<Taggable>> predicateFilters)\n-    {\n-        if (fieldObject instanceof TaggableFilter)\n-        {\n-            filters.add((TaggableFilter) fieldObject);\n-        }\n-        else if (fieldObject instanceof String)\n-        {\n-            filters.add(TaggableFilter.forDefinition((String) fieldObject));\n-        }\n-        else if (fieldObject instanceof Predicate)\n-        {\n-            // There isn't really a way to check generics, at least not without a lot of\n-            // code. :(\n-            final var type = field.getGenericType();\n-            if (type instanceof ParameterizedType)\n-            {\n-                final Type[] parameters = ((ParameterizedType) type).getActualTypeArguments();\n-                if (parameters.length == 1 && Taggable.class.equals(parameters[0]))\n-                {\n-                    // We've checked for the appropriate class AND the appropriate generic\n-                    // parameters\n-                    @SuppressWarnings(\"unchecked\")\n-                    final Predicate<Taggable> filter = (Predicate<Taggable>) fieldObject;\n-                    predicateFilters.add(filter);\n-                }\n-            }\n-        }\n-    }\n-\n-    private KeyFullyCheckedUtils()\n-    {\n-        // Hide constructor\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA5MTc0OA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669091748", "bodyText": "I'm guessing this was to test something?", "author": "Bentleysb", "createdAt": "2021-07-13T20:36:26Z", "path": "src/test/java/org/openstreetmap/atlas/checks/validation/intersections/BigNodeBadDataCheckTest.java", "diffHunk": "@@ -73,6 +73,11 @@ private boolean runTest(final Atlas atlas, final Configuration config,\n \n         bigNodes.forEach(bigNode ->\n         {\n+            if (bigNode.nodes().stream().mapToLong(node -> node.getOsmIdentifier())\n+                    .anyMatch(number -> number == 812034701L))\n+            {\n+                logger.info(\"found something\");\n+            }", "originalCommit": "fe33333d169d44c3bb679decd0c7f055d3ed27dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTgxNDIyNQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669814225", "bodyText": "Yes. I think I was having issues with a test failing somewhere when I was updating to newer atlas/atlas-generator versions.", "author": "tsmock", "createdAt": "2021-07-14T17:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA5MTc0OA=="}], "type": "inlineReview", "revised_code": {"commit": "66eb8e0d9487e96220bb2c32434857e66de81d09", "chunk": "diff --git a/src/test/java/org/openstreetmap/atlas/checks/validation/intersections/BigNodeBadDataCheckTest.java b/src/test/java/org/openstreetmap/atlas/checks/validation/intersections/BigNodeBadDataCheckTest.java\nindex a6d96a2..f49dcdb 100644\n--- a/src/test/java/org/openstreetmap/atlas/checks/validation/intersections/BigNodeBadDataCheckTest.java\n+++ b/src/test/java/org/openstreetmap/atlas/checks/validation/intersections/BigNodeBadDataCheckTest.java\n\n@@ -73,11 +73,6 @@ public class BigNodeBadDataCheckTest\n \n         bigNodes.forEach(bigNode ->\n         {\n-            if (bigNode.nodes().stream().mapToLong(node -> node.getOsmIdentifier())\n-                    .anyMatch(number -> number == 812034701L))\n-            {\n-                logger.info(\"found something\");\n-            }\n             final Optional<CheckFlag> checkerFlags = checker.flag(bigNode);\n             checkerFlags.map(flags::add);\n         });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA5NjA3MA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669096070", "bodyText": "The main edge does not encompass all edges with the same ID. It is just the main direction of a way setioned edge.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                ? this.createFlag(((Edge) object).getMainEdge(), instruction)\n          \n          \n            \n                               ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)", "author": "Bentleysb", "createdAt": "2021-07-13T20:42:57Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,940 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(((Edge) object).getMainEdge(), instruction)", "originalCommit": "fe33333d169d44c3bb679decd0c7f055d3ed27dd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66eb8e0d9487e96220bb2c32434857e66de81d09", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\ndeleted file mode 100644\nindex bee1eda..0000000\n--- a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n+++ /dev/null\n\n@@ -1,940 +0,0 @@\n-package org.openstreetmap.atlas.checks.validation.tag;\n-\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.TreeMap;\n-import java.util.TreeSet;\n-import java.util.function.Predicate;\n-import java.util.function.UnaryOperator;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-\n-import org.openstreetmap.atlas.checks.base.BaseCheck;\n-import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n-import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n-import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n-import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n-import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n-import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n-import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n-import org.openstreetmap.atlas.checks.flag.CheckFlag;\n-import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n-import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n-import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n-import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n-import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n-import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n-import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n-import org.openstreetmap.atlas.geography.atlas.items.Area;\n-import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n-import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n-import org.openstreetmap.atlas.geography.atlas.items.Edge;\n-import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n-import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n-import org.openstreetmap.atlas.geography.atlas.items.Relation;\n-import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n-import org.openstreetmap.atlas.locale.IsoCountry;\n-import org.openstreetmap.atlas.streaming.resource.Resource;\n-import org.openstreetmap.atlas.tags.ISOCountryTag;\n-import org.openstreetmap.atlas.tags.Taggable;\n-import org.openstreetmap.atlas.utilities.collections.Iterables;\n-import org.openstreetmap.atlas.utilities.configuration.Configuration;\n-import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Generic tag check using OSM Wiki Data and Tag Info databases.\n- *\n- * @author Taylor Smock\n- */\n-public class GenericTagCheck extends BaseCheck<String>\n-{\n-    private static final long serialVersionUID = 5150282147895785829L;\n-    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n-    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n-    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n-    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n-    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n-    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n-    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n-    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n-    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n-    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n-    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n-    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n-    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n-    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n-    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n-    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n-            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n-            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n-            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n-            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n-            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n-            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n-            .collect(Collectors.toCollection(ArrayList::new));\n-    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n-\n-    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n-    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n-    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n-\n-    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n-\n-    private final Long minTagUsage;\n-    // Due to serialization, this *cannot* be final\n-    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n-            .populateIgnoreTags();\n-\n-    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n-            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n-    private final List<String> tagsToRemove;\n-    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n-    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n-    private SQLiteUtils sqliteUtilsWikiData;\n-    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n-    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n-    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n-    private final String tagInfoDB;\n-    private final String wikiDataDB;\n-    private final String wikiTable;\n-    private final String tagInfoTagTable;\n-    private final String tagInfoKeyTable;\n-    private final int popularTagPercentageKey;\n-\n-    /**\n-     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n-     *\n-     * @param object\n-     *            The object to check\n-     * @return {@code true} if the object is an area\n-     */\n-    private static boolean isArea(final Taggable object)\n-    {\n-        return object instanceof Area\n-                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n-    }\n-\n-    /**\n-     * Check if an object may be an area\n-     *\n-     * @param object\n-     *            The object to check\n-     * @return {@code true} if the object <i>may</i> be an area.\n-     */\n-    private static boolean isClosedLine(final Taggable object)\n-    {\n-        return object instanceof LineItem && ((LineItem) object).isClosed();\n-    }\n-\n-    /**\n-     * Convert a tag entry into a string\n-     *\n-     * @param tag\n-     *            The tag to convert\n-     * @return A &ltkey&gt=&ltvalue&gt string\n-     */\n-    private static String tagToString(final Map.Entry<String, String> tag)\n-    {\n-        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n-                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n-    }\n-\n-    /**\n-     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n-     * checks with this constructor, supplying a configuration that can be used to adjust any\n-     * parameters that the check uses during operation.\n-     *\n-     * @param configuration\n-     *            the JSON configuration for this check\n-     * @param fileFetcher\n-     *            A fetcher to get external data with\n-     */\n-    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n-    {\n-        super(configuration);\n-        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n-                DEFAULT_MIN_TAG_USAGE);\n-\n-        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n-                DEFAULT_TAGS_TO_REMOVE);\n-        this.wikiTable = DEFAULT_WIKI_TABLE;\n-        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n-        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n-        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n-        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n-                DEFAULT_WIKIDATA_DB);\n-\n-        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n-        // a Long.\n-        this.popularTagPercentageKey = this\n-                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n-                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n-                .intValue();\n-\n-        // No matter what the atlas is, we need the db files. But only if we can get\n-        // them.\n-        if (fileFetcher == null)\n-        {\n-            return;\n-        }\n-        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n-        {\n-            final Optional<Resource> resource = fileFetcher.apply(file);\n-            if (!resource.isPresent() && logger.isDebugEnabled())\n-            {\n-                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n-            }\n-        }\n-        this.fetchWikiData(fileFetcher);\n-        this.fetchTagInfo(fileFetcher);\n-    }\n-\n-    /**\n-     * This function will validate if the supplied atlas object is valid for the check.\n-     *\n-     * @param object\n-     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n-     * @return {@code true} if this object should be checked\n-     */\n-    @Override\n-    public boolean validCheckForObject(final AtlasObject object)\n-    {\n-        return !object.getOsmTags().isEmpty()\n-                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n-    }\n-\n-    /**\n-     * This is the actual function that will check to see whether the object needs to be flagged.\n-     *\n-     * @param object\n-     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n-     * @return an optional {@link CheckFlag} object that\n-     */\n-    @Override\n-    protected Optional<CheckFlag> flag(final AtlasObject object)\n-    {\n-        // Test against each filter and create an instruction if the object passes\n-        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n-\n-        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n-        {\n-            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n-            {\n-                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n-            }\n-            this.flagTags(object, instructions);\n-        }\n-\n-        if (!instructions.isEmpty())\n-        {\n-            // Mark objects flagged by their class and id to allow for the same id in\n-            // different object types\n-            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n-\n-            // Create a flag with generic instructions\n-            final String instruction = this.getLocalizedInstruction(\n-                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n-                    object.getOsmIdentifier());\n-            // If the object is an edge add the edges with the same OSM id\n-            final CheckFlag flag = (object instanceof Edge)\n-                    ? this.createFlag(((Edge) object).getMainEdge(), instruction)\n-                    : this.createFlag(object, instruction);\n-\n-            // Add the specific instructions\n-            instructions.keySet().forEach(flag::addInstruction);\n-            /*\n-             * Only add autofixes when instructions are the same size as the changes. This avoids\n-             * situations where a change is available and is valid, but there is an additional issue\n-             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n-             * indicate that a change partially fixes the flag, this can be changed back to {@code\n-             * changes.isEmpty()}.\n-             */\n-            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n-            {\n-                flag.addFixSuggestions(Collections.singleton(\n-                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n-                                instructions.values().stream().flatMap(Collection::stream)\n-                                        .filter(Objects::nonNull).distinct()\n-                                        .collect(Collectors.toList()))));\n-            }\n-            return Optional.of(flag);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    @Override\n-    protected List<String> getFallbackInstructions()\n-    {\n-        return FALLBACK_INSTRUCTIONS;\n-    }\n-\n-    /**\n-     * Check for country specific rules\n-     *\n-     * @param instructions\n-     *            The instructions for the object\n-     * @param object\n-     *            The taggable object which should have country tags\n-     * @param tag\n-     *            The actual tag we are checking\n-     * @param wikiMap\n-     *            The map of wiki information\n-     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n-     */\n-    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n-    {\n-        // P48 shouldn't be used on actual key/tag items\n-        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n-                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n-        {\n-            /* Create a function that converts country/region wiki data into ISO3 codes */\n-            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n-                    .map(this::getWikiDataId)\n-                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n-                    .map(WikiData::getGeographicCodeP49)\n-                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n-                    .flatMap(Collection::stream)\n-                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n-                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n-            // Object ISOCountryTags appear to be ISO3 codes.\n-            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n-            String instruction = null;\n-            // The region keys are one or the other, but should never be both.\n-            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n-            {\n-                final Collection<String> onlyUsedInRegion = toWikiData\n-                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n-                // Some primitives may cross country lines, so if any country is a valid region,\n-                // continue on.\n-                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n-                {\n-                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n-                }\n-            }\n-            // check on P30 becomes redundant due to earlier check.\n-            else\n-            {\n-                final Collection<String> notUsedInRegion = toWikiData\n-                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n-                // If countries is empty, then don't bother checking. Otherwise, allMatch\n-                // returns true.\n-                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n-                {\n-                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n-                }\n-            }\n-            // If the tag shouldn't be used in the region/area, it should be removed\n-            if (instruction != null)\n-            {\n-                instructions.put(\n-                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n-                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n-                                wikiMap.getId()),\n-                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n-            }\n-\n-            return instruction != null;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n-     *\n-     * @param instructions\n-     *            The instructions to add to\n-     * @param tag\n-     *            The tag to check\n-     * @param keyInfo\n-     *            The information for the key\n-     * @param popular\n-     *            {@code true} if the key is \"popular\"\n-     * @param tagOccurrence\n-     *            The information from TagInfo for the tag\n-     * @param keyOccurrence\n-     *            The information from TagInfo for the key\n-     */\n-    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n-            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n-    {\n-        if (keyInfo == null)\n-        {\n-            final String count;\n-            final Map.Entry<String, String> messageTag;\n-            if (tagOccurrence.getCountAll() != null)\n-            {\n-                count = tagOccurrence.getCountAll().toString();\n-                messageTag = tag;\n-            }\n-            else if (keyOccurrence.getCountAll() != null)\n-            {\n-                count = keyOccurrence.getCountAll().toString();\n-                messageTag = Map.entry(tag.getKey(), \"\");\n-            }\n-            else\n-            {\n-                count = \"<\" + this.minTagUsage.toString();\n-                messageTag = tag;\n-            }\n-            // Check for unpopular/bad tags not already caught by wiki check\n-            if (!popular)\n-            {\n-                instructions.put(this.getLocalizedInstruction(\n-                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n-                        tagToString(tag), count), Collections.emptyList());\n-            }\n-            else\n-            {\n-                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n-                instructions.put(this.getLocalizedInstruction(\n-                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n-                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n-                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n-                                .toString()),\n-                        Collections.emptyList());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n-     * instruction and change for that.\n-     *\n-     * @param instructions\n-     *            The instructions collection to add to\n-     * @param changes\n-     *            The changes collection to add to\n-     * @param tag\n-     *            The tag to check\n-     * @param checkInfo\n-     *            Wiki Data information (more specific)\n-     * @return {@code true} if the tag fails the regex\n-     */\n-    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData checkInfo)\n-    {\n-        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n-        {\n-            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n-                    ? checkInfo.getPermanentKeyIdP16()\n-                    : checkInfo.getPermanentTagIdP19();\n-            final Collection<String> redirects = checkInfo.getRedirectToP17();\n-            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n-\n-            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n-\n-            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n-                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n-            final Collection<IFeatureChange> featureChanges;\n-            if (!replacements.isEmpty())\n-            {\n-                featureChanges = new ArrayList<>();\n-                featureChanges.add(new RemoveTagFeatureChange(tag));\n-                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n-                {\n-                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n-                }\n-            }\n-            else\n-            {\n-                featureChanges = Collections.emptyList();\n-            }\n-\n-            instructions.put(\n-                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n-                            value,\n-                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n-                                    .collect(Collectors.joining(\", \")),\n-                            checkInfo.getId()),\n-                    featureChanges);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check regexes for a tag\n-     *\n-     * @param instructions\n-     *            The instruction collection to append instructions to\n-     * @param tag\n-     *            The specific tag to check\n-     * @param checkInfo\n-     *            Wiki Data information (specific, if available)\n-     * @return {@code true} if the regex failed\n-     */\n-    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData checkInfo)\n-    {\n-        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n-        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n-        {\n-            // Reuse the compiled patterns\n-            final var pattern = checkInfo.getValueValidationRegexP13();\n-            if (!pattern.matcher(tag.getValue()).matches())\n-            {\n-                instructions.put(this.getLocalizedInstruction(\n-                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n-                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n-                        Collections.emptyList());\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Do relation specific checks\n-     *\n-     * @param instructions\n-     *            Instructions to add to\n-     * @param The\n-     *            object to check\n-     * @param checkInfo\n-     *            The wiki information for the tag to be checked\n-     * @param tag\n-     *            The tag to be checked\n-     * @return {@code true} if the relation had a problem\n-     */\n-    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n-    {\n-        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n-                && \"type\".equals(tag.getKey()))\n-        {\n-            final var relation = (Relation) object;\n-            final var relationInfo = this.getWikiData(\n-                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n-            if (relationInfo == null)\n-            {\n-                instructions.put(\n-                        this.getLocalizedInstruction(\n-                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n-                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n-                        Collections.emptyList());\n-                return true;\n-            }\n-            final Collection<String> additionalInstructions = new TreeSet<>();\n-            for (final RelationMember relationMember : relation.members())\n-            {\n-                // Empty roles should exist in WikiData\n-                final String role = relationMember.getRole();\n-                final var roleInfo = this\n-                        .getWikiData(Map.of(WikiProperty.RELATION_ROLE_ID_P21.getId(),\n-                                relationInfo.getPermanentRelationTypeIdP41() + \"=\" + role));\n-                if (roleInfo == null)\n-                {\n-                    final var roleMember = relationMember.getEntity();\n-                    additionalInstructions.add(this.getLocalizedInstruction(\n-                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_ROLE),\n-                            relationInfo.getPermanentRelationTypeIdP41(), role,\n-                            AtlasToOsmType.convert(roleMember.getType()),\n-                            roleMember.getOsmIdentifier(), relation.getOsmIdentifier(),\n-                            checkInfo.getId()));\n-                }\n-            }\n-            additionalInstructions\n-                    .forEach(instruction -> instructions.put(instruction, Collections.emptyList()));\n-            return !additionalInstructions.isEmpty();\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check the status of a tag\n-     *\n-     * @param instructions\n-     *            The instruction collection to append instructions to\n-     * @param changes\n-     *            The changes to add a change to (removal)\n-     * @param tag\n-     *            The specific tag to check\n-     * @param checkInfo\n-     *            Wiki Data information (specific, if available)\n-     * @param wellKnown\n-     *            If the tag has well-defined values\n-     * @return {@code true} if the tag should be removed (change already added to {@code changes})\n-     */\n-    private boolean checkStatus(final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown)\n-    {\n-        if (wellKnown && checkInfo != null && checkInfo.getStatusP6() != null\n-                && this.tagsToRemove.stream().anyMatch(t -> checkInfo.getStatusP6().matches(t)))\n-        {\n-            instructions.put(\n-                    this.getLocalizedInstruction(\n-                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_WIKI_DATA_REMOVAL),\n-                            tag.getKey(), tag.getValue(),\n-                            checkInfo.getStatusP6().getDescriptor().toLowerCase(Locale.ENGLISH),\n-                            checkInfo.getId()),\n-                    Collections.singleton(new RemoveTagFeatureChange(tag)));\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check for instances where a key is well-known but the value is not one of the well-known\n-     * values.\n-     *\n-     * @param instructions\n-     *            The instructions to add to\n-     * @param changes\n-     *            The changes to add to\n-     * @param tag\n-     *            The tag to check\n-     * @param checkInfo\n-     *            Wiki Data information (more specific)\n-     * @param wellKnown\n-     *            {@code true} if values are well-known\n-     * @param popular\n-     *            {@code true} if the tag is popular\n-     * @param tagOccurrence\n-     *            The TagInfo information for the tag\n-     * @return {@code true} if an issue was found\n-     */\n-    private boolean checkUndocumentedPopularWellDefined(\n-            final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown,\n-            final boolean popular, final TagInfoTags tagOccurrence)\n-    {\n-        if (wellKnown && checkInfo == null)\n-        {\n-            if (popular)\n-            {\n-                instructions.put(\n-                        this.getLocalizedInstruction(\n-                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNDOCUMENTED_POPULAR_TAG),\n-                                tag.getKey(), tag.getValue(), tagOccurrence.getCountAll()),\n-                        Collections.emptyList());\n-            }\n-            else\n-            {\n-                instructions.put(\n-                        this.getLocalizedInstruction(\n-                                FALLBACK_INSTRUCTIONS\n-                                        .indexOf(INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE),\n-                                tag.getValue(), tag.getKey()),\n-                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check the tag against wiki data for cases where it should not appear on the object.\n-     *\n-     * @param changes\n-     *            The changes for the object\n-     * @param instructions\n-     *            The instruction collection to append instructions to\n-     * @param tag\n-     *            The specific tag to check\n-     * @param object\n-     *            The atlas object (used to check if the tag is expected on the object)\n-     * @param checkInfo\n-     *            Wiki Data information (more specific)\n-     * @return {@code true} if there is an unwanted tag on an object\n-     */\n-    private boolean checkUnwantedTagOnObject(final Taggable object,\n-            final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData checkInfo)\n-    {\n-        final List<String> newInstructions = new ArrayList<>();\n-        if (object instanceof LocationItem && !checkInfo.isUseOnNodesP33())\n-        {\n-            newInstructions.add(this.getLocalizedInstruction(\n-                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_PROHIBITED_USAGE), tag.getKey(),\n-                    tag.getValue(), \"node\", checkInfo.getId()));\n-        }\n-\n-        /*\n-         * A line may be considered a way or an area. Account for instances where Atlas doesn't know\n-         * a tag makes something an area. Also account for instances where linear ways have been\n-         * converted into areas.\n-         */\n-        if ((isArea(object) || isClosedLine(object)) && !checkInfo.isUseOnWaysP34()\n-                && !checkInfo.isUseOnAreasP35())\n-        {\n-            newInstructions.add(this.getLocalizedInstruction(\n-                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_PROHIBITED_USAGE), tag.getKey(),\n-                    tag.getValue(), \"area\", checkInfo.getId()));\n-        }\n-        else if (object instanceof LineItem && !checkInfo.isUseOnWaysP34() && !isClosedLine(object))\n-        {\n-            newInstructions.add(this.getLocalizedInstruction(\n-                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_PROHIBITED_USAGE), tag.getKey(),\n-                    tag.getValue(), \"way\", checkInfo.getId()));\n-        }\n-\n-        if (object instanceof Relation && !checkInfo.isUseOnRelationsP36() && !isArea(object))\n-        {\n-            newInstructions.add(this.getLocalizedInstruction(\n-                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_PROHIBITED_USAGE), tag.getKey(),\n-                    tag.getValue(), \"relation\", checkInfo.getId()));\n-        }\n-        if (!newInstructions.isEmpty())\n-        {\n-            final Collection<IFeatureChange> delete = Collections\n-                    .singleton(new RemoveTagFeatureChange(tag));\n-            newInstructions.forEach(instruction -> instructions.put(instruction, delete));\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check the tag to ensure that it exists in Wiki Data Items\n-     *\n-     * @param instructions\n-     *            The instruction collection to append instructions to\n-     * @param tag\n-     *            The specific tag to check\n-     * @param object\n-     *            The atlas object (used to check if the tag is expected on the object)\n-     * @param wellKnown\n-     *            If the tag has well-defined values\n-     * @param checkInfo\n-     *            Wiki Data information (specific, if available)\n-     */\n-    private void checkWikiData(final Taggable object,\n-            final Map<String, Collection<IFeatureChange>> instructions,\n-            final Map.Entry<String, String> tag, final WikiData keyInfo, final WikiData checkInfo,\n-            final boolean wellKnown)\n-    {\n-        final TagInfoTags tagOccurrence = (TagInfoTags) this.getTagInfo(tag.getKey(),\n-                tag.getValue());\n-        final TagInfoKeys keyOccurrence = (TagInfoKeys) this.getTagInfo(tag.getKey(), null);\n-        final boolean popular = this.isPopular(keyOccurrence, tagOccurrence);\n-        if (this.checkRegex(instructions, tag, checkInfo)\n-                || this.checkUndocumentedPopularWellDefined(instructions, tag, checkInfo, wellKnown,\n-                        popular, tagOccurrence)\n-                || this.checkStatus(instructions, tag, checkInfo, wellKnown)\n-                || this.checkRedirectTo(instructions, tag, checkInfo)\n-                || this.checkRelations(instructions, object, tag, checkInfo)\n-                || this.checkCountrySpecific(instructions, object, tag, checkInfo)\n-                || (checkInfo != null\n-                        && this.checkUnwantedTagOnObject(object, instructions, tag, checkInfo)))\n-        {\n-            return;\n-        }\n-\n-        // Osmose 3040, 3050, and 3150 fallback/extra instructions\n-        this.checkFallback(instructions, tag, keyInfo, popular, tagOccurrence, keyOccurrence);\n-    }\n-\n-    /**\n-     * Fetch tag info\n-     *\n-     * @param fileFetcher\n-     *            The filefetcher to use\n-     */\n-    private void fetchTagInfo(final ExternalDataFetcher fileFetcher)\n-    {\n-        this.sqliteUtilsTagInfoKeyTable = new SQLiteUtils(fileFetcher, this.tagInfoDB,\n-                this.tagInfoKeyTable);\n-        if (!SQLiteUtils.isValidDatabase(this.sqliteUtilsTagInfoKeyTable.getFile()))\n-        {\n-            this.sqliteUtilsTagInfoKeyTable = null;\n-        }\n-        this.sqliteUtilsTagInfoTagTable = new SQLiteUtils(fileFetcher, this.tagInfoDB,\n-                this.tagInfoTagTable);\n-        if (!SQLiteUtils.isValidDatabase(this.sqliteUtilsTagInfoTagTable.getFile()))\n-        {\n-            this.sqliteUtilsTagInfoTagTable = null;\n-        }\n-    }\n-\n-    /**\n-     * Fetch wiki data\n-     *\n-     * @param fileFetcher\n-     *            The filefetcher to use\n-     */\n-    private void fetchWikiData(final ExternalDataFetcher fileFetcher)\n-    {\n-        this.sqliteUtilsWikiData = new SQLiteUtils(fileFetcher, this.wikiDataDB, this.wikiTable);\n-        if (!SQLiteUtils.isValidDatabase(this.sqliteUtilsWikiData.getFile()))\n-        {\n-            this.sqliteUtilsWikiData = null;\n-        }\n-    }\n-\n-    /**\n-     * Flag tags\n-     *\n-     * @param object\n-     *            The object to iterate through\n-     * @param instructions\n-     *            The instructions to add to\n-     */\n-    private void flagTags(final AtlasObject object,\n-            final Map<String, Collection<IFeatureChange>> instructions)\n-    {\n-        // Check for bad tags (i.e., wrong object type, regex doesn't match, wiki data\n-        // doesn't exist)\n-        for (final Map.Entry<String, String> entry : object.getOsmTags().entrySet())\n-        {\n-            for (final String value : entry.getValue().split(\";\", -1))\n-            {\n-                final Map.Entry<String, String> tagEntry = Map.entry(entry.getKey(), value);\n-                // Use TestTaggable to avoid matching on common tags\n-                if (this.ignoreTags.parallelStream().anyMatch(\n-                        p -> p.test(new TestTaggable(tagEntry.getKey(), tagEntry.getValue()))))\n-                {\n-                    continue;\n-                }\n-                // Osmose 3040, 3050, and 3150\n-                final var keyInfo = this.getWikiData(tagEntry.getKey(), null);\n-                // \"P9\" is \"key type\", \"Q8\" is \"well-known values\"\n-                final boolean wellKnown = keyInfo != null\n-                        && WikiDataItem.WELL_KNOWN_VALUES_Q8.matches(keyInfo.getKeyTypeP9());\n-\n-                var checkInfo = this.getWikiData(tagEntry.getKey(), tagEntry.getValue());\n-                if (checkInfo == null && !wellKnown)\n-                {\n-                    checkInfo = keyInfo;\n-                }\n-\n-                this.checkWikiData(object, instructions, tagEntry, keyInfo, checkInfo, wellKnown);\n-            }\n-\n-        }\n-    }\n-\n-    /**\n-     * Get the TagInfo for a specific key and value\n-     *\n-     * @param key\n-     *            The key to get\n-     * @param value\n-     *            The value to get (if {@code null}, information is pulled from the keys table\n-     *            instead of tags)\n-     * @return A map entry with a key of the tag (or key, if value is {@code null}) and the number\n-     *         of worldwide occurrences.\n-     */\n-    @Nonnull\n-    private TagInfoKeyTagCommon getTagInfo(final String key, final String value)\n-    {\n-        final Map<String, Object> map;\n-        if (value != null)\n-        {\n-            map = this.sqliteUtilsTagInfoTagTable.getRows(Map.of(\"key\", key, \"value\", value));\n-            return new TagInfoTags(map);\n-        }\n-        map = this.sqliteUtilsTagInfoKeyTable.getRows(Map.of(\"key\", key));\n-        return new TagInfoKeys(map);\n-    }\n-\n-    /**\n-     * Get the Wiki Data for a specific key and value\n-     *\n-     * @param key\n-     *            The key to get the wiki data for\n-     * @param value\n-     *            The value to get the wiki data for (may be {@code null})\n-     * @return The map for the specified key/value combination\n-     */\n-    @Nullable\n-    private WikiData getWikiData(final String key, final String value)\n-    {\n-        Objects.requireNonNull(key, \"key cannot be null\");\n-        if (value == null || value.isBlank())\n-        {\n-            // \"P16\" is the \"permanent key id\" (e.g. \"highway\")\n-            return this.getWikiData(Map.of(WikiProperty.PERMANENT_KEY_ID_P16.getId(), key));\n-        }\n-        final var tag = String.join(\"=\", key, value);\n-        // \"P19\" is the \"permanent tag id\" (e.g. \"highway=residential\")\n-        return this.getWikiData(Map.of(WikiProperty.PERMANENT_TAG_ID_P19.getId(), tag));\n-    }\n-\n-    /**\n-     * Get arbitrary values from the wiki data\n-     *\n-     * @param searchValues\n-     *            The key-value search map\n-     * @return A wiki data item, if one exists\n-     */\n-    @Nullable\n-    private WikiData getWikiData(final Map<String, String> searchValues)\n-    {\n-        return WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(searchValues));\n-    }\n-\n-    /**\n-     * Get Wiki Data for an id\n-     *\n-     * @param identifier\n-     *            The id to get\n-     * @return The WikiData item\n-     */\n-    @Nullable\n-    private WikiData getWikiDataId(final String identifier)\n-    {\n-        Objects.requireNonNull(identifier, \"id cannot be null\");\n-        final var data = WikiData.getWikiData(identifier);\n-        if (data != null)\n-        {\n-            return data;\n-        }\n-        // The id column has no ID (P2, P3, etc).\n-        return this.getWikiData(Map.of(WikiProperty.ID.getDescriptor(), identifier));\n-    }\n-\n-    private boolean isPopular(final TagInfoKeys keyOccurrence, final TagInfoTags tagOccurrence)\n-    {\n-        if (tagOccurrence != null && tagOccurrence.getCountAll() != null\n-                && tagOccurrence.getCountAll().longValue() > this.minTagUsage)\n-        {\n-            return true;\n-        }\n-        return keyOccurrence.getCountAll() != null\n-                && keyOccurrence.getCountAll().longValue() > this.minTagUsage\n-                && keyOccurrence.getCountAll().longValue()\n-                        / keyOccurrence.getValuesAll().longValue() < this.popularTagPercentageKey;\n-    }\n-\n-    /**\n-     * Parse a tag from a map (wiki data)\n-     *\n-     * @param map\n-     *            The map to parse tags from\n-     * @return An entry for the tag\n-     */\n-    @Nullable\n-    private Map.Entry<String, String> parseTags(@Nonnull final WikiData map)\n-    {\n-        final String key = map.getPermanentKeyIdP16();\n-        if (!key.isBlank())\n-        {\n-            return Map.entry(key, \"\");\n-        }\n-        final String tag = map.getPermanentTagIdP19();\n-        if (!tag.isBlank())\n-        {\n-            final String[] tagId = tag.split(\"=\", 2);\n-            if (tagId.length == 2)\n-            {\n-                return Map.entry(tagId[0], tagId[1]);\n-            }\n-        }\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4NjIwNQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669786205", "bodyText": "nit: please avoid single letter variable", "author": "sayas01", "createdAt": "2021-07-14T16:47:59Z", "path": "src/main/java/org/openstreetmap/atlas/checks/database/wikidata/WikiDataItem.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// License: GPL. For details, see LICENSE file.\n+package org.openstreetmap.atlas.checks.database.wikidata;\n+\n+import java.text.MessageFormat;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * WikiDataItem special entries\n+ *\n+ * @author Taylor Smock\n+ */\n+public enum WikiDataItem implements WikiItemInterface\n+{\n+    // OSM Concepts\n+    ELEMENT_Q9,\n+    KEY_Q7,\n+    TAG_Q2,\n+    /** Status of the key/tag */\n+    STATUS_Q11,\n+    /** Allowed on nodes/ways/relations/areas */\n+    STATUS_Q8010,\n+    // Statuses (STATUS_Q11)\n+    DE_FACTO_Q13(STATUS_Q11),\n+    IN_USE_Q14(STATUS_Q11),\n+    APPROVED_Q15(STATUS_Q11),\n+    REJECTED_Q16(STATUS_Q11),\n+    VOTING_Q17(STATUS_Q11),\n+    DRAFT_Q18(STATUS_Q11),\n+    ABANDONED_Q19(STATUS_Q11),\n+    PROPOSED_Q20(STATUS_Q11),\n+    OBSOLETE_Q5060(STATUS_Q11),\n+    DEPRECATED_Q5061(STATUS_Q11),\n+    DISCARDABLE_Q7550(STATUS_Q11),\n+    IMPORTED_Q21146(STATUS_Q11),\n+    // Statuses (STATUS_Q8010)\n+    IS_ALLOWED_Q8000(STATUS_Q8010),\n+    IS_PROHIBITED_Q8001(STATUS_Q8010),\n+    // Special\n+    WELL_KNOWN_VALUES_Q8,\n+    GROUP_Q12,\n+    OSM_CONCEPT_Q10,\n+    SANDBOX_Q2761;\n+\n+    @Nullable\n+    private final WikiDataItem parent;\n+    @Nonnull\n+    private final String pid;\n+    @Nonnull\n+    private final String rName;\n+\n+    /**\n+     * Get a well-known wiki data item from a value\n+     *\n+     * @param value\n+     *            The value to look for\n+     * @return A WikiDataItem or {@code null}\n+     */\n+    public static WikiDataItem fromValue(final String value)\n+    {\n+        WikiDataItem rItem = Stream.of(WikiDataItem.values())\n+                .filter(p -> p.getId().equalsIgnoreCase(value)).findFirst().orElse(null);", "originalCommit": "9f9616fed683129eba242736296db4af5c8edbcd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66eb8e0d9487e96220bb2c32434857e66de81d09", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/database/wikidata/WikiDataItem.java b/src/main/java/org/openstreetmap/atlas/checks/database/wikidata/WikiDataItem.java\ndeleted file mode 100644\nindex 6c509f1..0000000\n--- a/src/main/java/org/openstreetmap/atlas/checks/database/wikidata/WikiDataItem.java\n+++ /dev/null\n\n@@ -1,138 +0,0 @@\n-// License: GPL. For details, see LICENSE file.\n-package org.openstreetmap.atlas.checks.database.wikidata;\n-\n-import java.text.MessageFormat;\n-import java.util.stream.Stream;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-\n-/**\n- * WikiDataItem special entries\n- *\n- * @author Taylor Smock\n- */\n-public enum WikiDataItem implements WikiItemInterface\n-{\n-    // OSM Concepts\n-    ELEMENT_Q9,\n-    KEY_Q7,\n-    TAG_Q2,\n-    /** Status of the key/tag */\n-    STATUS_Q11,\n-    /** Allowed on nodes/ways/relations/areas */\n-    STATUS_Q8010,\n-    // Statuses (STATUS_Q11)\n-    DE_FACTO_Q13(STATUS_Q11),\n-    IN_USE_Q14(STATUS_Q11),\n-    APPROVED_Q15(STATUS_Q11),\n-    REJECTED_Q16(STATUS_Q11),\n-    VOTING_Q17(STATUS_Q11),\n-    DRAFT_Q18(STATUS_Q11),\n-    ABANDONED_Q19(STATUS_Q11),\n-    PROPOSED_Q20(STATUS_Q11),\n-    OBSOLETE_Q5060(STATUS_Q11),\n-    DEPRECATED_Q5061(STATUS_Q11),\n-    DISCARDABLE_Q7550(STATUS_Q11),\n-    IMPORTED_Q21146(STATUS_Q11),\n-    // Statuses (STATUS_Q8010)\n-    IS_ALLOWED_Q8000(STATUS_Q8010),\n-    IS_PROHIBITED_Q8001(STATUS_Q8010),\n-    // Special\n-    WELL_KNOWN_VALUES_Q8,\n-    GROUP_Q12,\n-    OSM_CONCEPT_Q10,\n-    SANDBOX_Q2761;\n-\n-    @Nullable\n-    private final WikiDataItem parent;\n-    @Nonnull\n-    private final String pid;\n-    @Nonnull\n-    private final String rName;\n-\n-    /**\n-     * Get a well-known wiki data item from a value\n-     *\n-     * @param value\n-     *            The value to look for\n-     * @return A WikiDataItem or {@code null}\n-     */\n-    public static WikiDataItem fromValue(final String value)\n-    {\n-        WikiDataItem rItem = Stream.of(WikiDataItem.values())\n-                .filter(p -> p.getId().equalsIgnoreCase(value)).findFirst().orElse(null);\n-        if (rItem == null)\n-        {\n-            rItem = Stream.of(WikiDataItem.values())\n-                    .filter(p -> p.getDescriptor().equalsIgnoreCase(value)).findFirst()\n-                    .orElse(null);\n-        }\n-        return rItem;\n-    }\n-\n-    WikiDataItem()\n-    {\n-        this(null);\n-    }\n-\n-    WikiDataItem(final WikiDataItem parent)\n-    {\n-        this.parent = parent;\n-        final String[] enumName = this.name().split(\"_\", -1);\n-        this.pid = enumName[enumName.length - 1];\n-        this.rName = this.name().replace(\"_\" + pid, \"\").replace(\"_\", \" \");\n-    }\n-\n-    @Override\n-    public String getDescriptor()\n-    {\n-        return this.rName;\n-    }\n-\n-    @Override\n-    public String getId()\n-    {\n-        return this.pid;\n-    }\n-\n-    /**\n-     * Get the parent WikiDataItem for this, if any\n-     *\n-     * @return The parent item or {@code null}\n-     */\n-    @Nullable\n-    public WikiDataItem getParent()\n-    {\n-        return this.parent;\n-    }\n-\n-    /**\n-     * Check if the object matches this (essentially \"equals\")\n-     *\n-     * @param other\n-     *            The object to check\n-     * @return {@code true} if the object is the same enum OR it is a string that matches the\n-     *         description (ignoring case).\n-     */\n-    public boolean matches(final Object other)\n-    {\n-        if (this == other)\n-        {\n-            return true;\n-        }\n-        else if (other instanceof String)\n-        {\n-            return this.rName.equalsIgnoreCase((String) other)\n-                    || this.pid.equalsIgnoreCase((String) other);\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public String toString()\n-    {\n-        return MessageFormat.format(\"{0}: {1}\", this.pid, this.rName);\n-    }\n-\n-}\n"}}, {"oid": "66eb8e0d9487e96220bb2c32434857e66de81d09", "url": "https://github.com/osmlab/atlas-checks/commit/66eb8e0d9487e96220bb2c32434857e66de81d09", "message": "InvalidMultiPolygonRelationCheck: Extract AtlasToOsmType code\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-07-14T18:27:49Z", "type": "commit"}, {"oid": "c8228d2c5f6ab535b3c97ac290f87d7a7d67a2a3", "url": "https://github.com/osmlab/atlas-checks/commit/c8228d2c5f6ab535b3c97ac290f87d7a7d67a2a3", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nFeatureChange: Add interfaces for remove/replace tag changes\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-07-14T18:27:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669789198", "bodyText": "Looks good, feel like this could be in Atlas project.", "author": "sayas01", "createdAt": "2021-07-14T16:52:09Z", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/AtlasToOsmType.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.util.EnumMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.validation.relations.InvalidMultiPolygonRelationCheck;\n+import org.openstreetmap.atlas.geography.atlas.items.ItemType;\n+\n+/**\n+ * Convert Atlas ItemTypes into OSM types\n+ *\n+ * @author Taylor Smock, extracted from {@link InvalidMultiPolygonRelationCheck}.\n+ */\n+public final class AtlasToOsmType", "originalCommit": "9f9616fed683129eba242736296db4af5c8edbcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk4NDg2MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669984861", "bodyText": "It probably could be. I think I didn't do that since I've got a few projects with various moving parts, and I didn't want to deal with yet another one at the time, and then forgot about it.\nI've had too many PR's that depend upon other PR's that depend upon yet another PR...", "author": "tsmock", "createdAt": "2021-07-14T22:02:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk5MzM1MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669993351", "bodyText": "This can defiantly be something that is done later.", "author": "Bentleysb", "createdAt": "2021-07-14T22:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk5Mzk3NQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669993975", "bodyText": "Yp!!", "author": "sayas01", "createdAt": "2021-07-14T22:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA=="}], "type": "inlineReview", "revised_code": {"commit": "66eb8e0d9487e96220bb2c32434857e66de81d09", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/utility/AtlasToOsmType.java b/src/main/java/org/openstreetmap/atlas/checks/utility/AtlasToOsmType.java\nindex ec2243f..8922081 100644\n--- a/src/main/java/org/openstreetmap/atlas/checks/utility/AtlasToOsmType.java\n+++ b/src/main/java/org/openstreetmap/atlas/checks/utility/AtlasToOsmType.java\n\n@@ -12,7 +12,7 @@ import org.openstreetmap.atlas.geography.atlas.items.ItemType;\n  *\n  * @author Taylor Smock, extracted from {@link InvalidMultiPolygonRelationCheck}.\n  */\n-public final class AtlasToOsmType\n+public class AtlasToOsmType\n {\n     private static final EnumMap<ItemType, String> ATLAS_TO_OSM_TYPE = new EnumMap<>(\n             ItemType.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NjA5MA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669976090", "bodyText": "unused param", "author": "sayas01", "createdAt": "2021-07-14T21:44:44Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes", "originalCommit": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1a01ae743d679f93b0f630a081dd54556013720d", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\nindex 8ea4f31..74d1ecd 100644\n--- a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n+++ b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n\n@@ -418,8 +418,6 @@ public class GenericTagCheck extends BaseCheck<String>\n      *\n      * @param instructions\n      *            The instructions collection to add to\n-     * @param changes\n-     *            The changes collection to add to\n      * @param tag\n      *            The tag to check\n      * @param checkInfo\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3Njc5NQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669976795", "bodyText": "@param object", "author": "sayas01", "createdAt": "2021-07-14T21:46:11Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The", "originalCommit": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1a01ae743d679f93b0f630a081dd54556013720d", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\nindex 8ea4f31..74d1ecd 100644\n--- a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n+++ b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n\n@@ -418,8 +418,6 @@ public class GenericTagCheck extends BaseCheck<String>\n      *\n      * @param instructions\n      *            The instructions collection to add to\n-     * @param changes\n-     *            The changes collection to add to\n      * @param tag\n      *            The tag to check\n      * @param checkInfo\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NzA2Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669977067", "bodyText": "unused param", "author": "sayas01", "createdAt": "2021-07-14T21:46:44Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final var roleInfo = this\n+                        .getWikiData(Map.of(WikiProperty.RELATION_ROLE_ID_P21.getId(),\n+                                relationInfo.getPermanentRelationTypeIdP41() + \"=\" + role));\n+                if (roleInfo == null)\n+                {\n+                    final var roleMember = relationMember.getEntity();\n+                    additionalInstructions.add(this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_ROLE),\n+                            relationInfo.getPermanentRelationTypeIdP41(), role,\n+                            AtlasToOsmType.convert(roleMember.getType()),\n+                            roleMember.getOsmIdentifier(), relation.getOsmIdentifier(),\n+                            checkInfo.getId()));\n+                }\n+            }\n+            additionalInstructions\n+                    .forEach(instruction -> instructions.put(instruction, Collections.emptyList()));\n+            return !additionalInstructions.isEmpty();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the status of a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param changes", "originalCommit": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1a01ae743d679f93b0f630a081dd54556013720d", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\nindex 8ea4f31..74d1ecd 100644\n--- a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n+++ b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n\n@@ -418,8 +418,6 @@ public class GenericTagCheck extends BaseCheck<String>\n      *\n      * @param instructions\n      *            The instructions collection to add to\n-     * @param changes\n-     *            The changes collection to add to\n      * @param tag\n      *            The tag to check\n      * @param checkInfo\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NzE1NQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669977155", "bodyText": "unused param", "author": "sayas01", "createdAt": "2021-07-14T21:46:57Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final var roleInfo = this\n+                        .getWikiData(Map.of(WikiProperty.RELATION_ROLE_ID_P21.getId(),\n+                                relationInfo.getPermanentRelationTypeIdP41() + \"=\" + role));\n+                if (roleInfo == null)\n+                {\n+                    final var roleMember = relationMember.getEntity();\n+                    additionalInstructions.add(this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_ROLE),\n+                            relationInfo.getPermanentRelationTypeIdP41(), role,\n+                            AtlasToOsmType.convert(roleMember.getType()),\n+                            roleMember.getOsmIdentifier(), relation.getOsmIdentifier(),\n+                            checkInfo.getId()));\n+                }\n+            }\n+            additionalInstructions\n+                    .forEach(instruction -> instructions.put(instruction, Collections.emptyList()));\n+            return !additionalInstructions.isEmpty();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the status of a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param changes\n+     *            The changes to add a change to (removal)\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @param wellKnown\n+     *            If the tag has well-defined values\n+     * @return {@code true} if the tag should be removed (change already added to {@code changes})\n+     */\n+    private boolean checkStatus(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown)\n+    {\n+        if (wellKnown && checkInfo != null && checkInfo.getStatusP6() != null\n+                && this.tagsToRemove.stream().anyMatch(t -> checkInfo.getStatusP6().matches(t)))\n+        {\n+            instructions.put(\n+                    this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_WIKI_DATA_REMOVAL),\n+                            tag.getKey(), tag.getValue(),\n+                            checkInfo.getStatusP6().getDescriptor().toLowerCase(Locale.ENGLISH),\n+                            checkInfo.getId()),\n+                    Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for instances where a key is well-known but the value is not one of the well-known\n+     * values.\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param changes", "originalCommit": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1a01ae743d679f93b0f630a081dd54556013720d", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\nindex 8ea4f31..74d1ecd 100644\n--- a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n+++ b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n\n@@ -418,8 +418,6 @@ public class GenericTagCheck extends BaseCheck<String>\n      *\n      * @param instructions\n      *            The instructions collection to add to\n-     * @param changes\n-     *            The changes collection to add to\n      * @param tag\n      *            The tag to check\n      * @param checkInfo\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NzQyOA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669977428", "bodyText": "unused param", "author": "sayas01", "createdAt": "2021-07-14T21:47:28Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final var roleInfo = this\n+                        .getWikiData(Map.of(WikiProperty.RELATION_ROLE_ID_P21.getId(),\n+                                relationInfo.getPermanentRelationTypeIdP41() + \"=\" + role));\n+                if (roleInfo == null)\n+                {\n+                    final var roleMember = relationMember.getEntity();\n+                    additionalInstructions.add(this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_ROLE),\n+                            relationInfo.getPermanentRelationTypeIdP41(), role,\n+                            AtlasToOsmType.convert(roleMember.getType()),\n+                            roleMember.getOsmIdentifier(), relation.getOsmIdentifier(),\n+                            checkInfo.getId()));\n+                }\n+            }\n+            additionalInstructions\n+                    .forEach(instruction -> instructions.put(instruction, Collections.emptyList()));\n+            return !additionalInstructions.isEmpty();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the status of a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param changes\n+     *            The changes to add a change to (removal)\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @param wellKnown\n+     *            If the tag has well-defined values\n+     * @return {@code true} if the tag should be removed (change already added to {@code changes})\n+     */\n+    private boolean checkStatus(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown)\n+    {\n+        if (wellKnown && checkInfo != null && checkInfo.getStatusP6() != null\n+                && this.tagsToRemove.stream().anyMatch(t -> checkInfo.getStatusP6().matches(t)))\n+        {\n+            instructions.put(\n+                    this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_WIKI_DATA_REMOVAL),\n+                            tag.getKey(), tag.getValue(),\n+                            checkInfo.getStatusP6().getDescriptor().toLowerCase(Locale.ENGLISH),\n+                            checkInfo.getId()),\n+                    Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for instances where a key is well-known but the value is not one of the well-known\n+     * values.\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param changes\n+     *            The changes to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @param wellKnown\n+     *            {@code true} if values are well-known\n+     * @param popular\n+     *            {@code true} if the tag is popular\n+     * @param tagOccurrence\n+     *            The TagInfo information for the tag\n+     * @return {@code true} if an issue was found\n+     */\n+    private boolean checkUndocumentedPopularWellDefined(\n+            final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown,\n+            final boolean popular, final TagInfoTags tagOccurrence)\n+    {\n+        if (wellKnown && checkInfo == null)\n+        {\n+            if (popular)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNDOCUMENTED_POPULAR_TAG),\n+                                tag.getKey(), tag.getValue(), tagOccurrence.getCountAll()),\n+                        Collections.emptyList());\n+            }\n+            else\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS\n+                                        .indexOf(INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE),\n+                                tag.getValue(), tag.getKey()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the tag against wiki data for cases where it should not appear on the object.\n+     *\n+     * @param changes", "originalCommit": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1a01ae743d679f93b0f630a081dd54556013720d", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\nindex 8ea4f31..74d1ecd 100644\n--- a/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n+++ b/src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java\n\n@@ -418,8 +418,6 @@ public class GenericTagCheck extends BaseCheck<String>\n      *\n      * @param instructions\n      *            The instructions collection to add to\n-     * @param changes\n-     *            The changes collection to add to\n      * @param tag\n      *            The tag to check\n      * @param checkInfo\n"}}, {"oid": "1a01ae743d679f93b0f630a081dd54556013720d", "url": "https://github.com/osmlab/atlas-checks/commit/1a01ae743d679f93b0f630a081dd54556013720d", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nFeatureChange: Add interfaces for remove/replace tag changes\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-07-14T22:11:37Z", "type": "commit"}, {"oid": "1a01ae743d679f93b0f630a081dd54556013720d", "url": "https://github.com/osmlab/atlas-checks/commit/1a01ae743d679f93b0f630a081dd54556013720d", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nFeatureChange: Add interfaces for remove/replace tag changes\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-07-14T22:11:37Z", "type": "forcePushed"}]}