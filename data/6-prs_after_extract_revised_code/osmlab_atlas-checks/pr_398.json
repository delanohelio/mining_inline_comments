{"pr_number": 398, "pr_title": "ExternalData: Use ResourceCache to get data", "pr_createdAt": "2020-10-20T22:08:32Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/398", "timeline": [{"oid": "5b94453509d9136d2e7333c77b8b8d9123114acf", "url": "https://github.com/osmlab/atlas-checks/commit/5b94453509d9136d2e7333c77b8b8d9123114acf", "message": "ElevationUtilities: External data: Add tests to ensure that data is\nfetched.\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-02T16:11:01Z", "type": "forcePushed"}, {"oid": "94ac48fdd2bf0e10c7a006669e45285cbcb85934", "url": "https://github.com/osmlab/atlas-checks/commit/94ac48fdd2bf0e10c7a006669e45285cbcb85934", "message": "FIXUP: Sonar\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-10T14:55:19Z", "type": "forcePushed"}, {"oid": "63274662b790bdb5699d306e020cebe18e54bb91", "url": "https://github.com/osmlab/atlas-checks/commit/63274662b790bdb5699d306e020cebe18e54bb91", "message": "ElevationUtilities: External data: Add tests to ensure that data is\nfetched.\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-19T20:07:21Z", "type": "forcePushed"}, {"oid": "0c636d008966f6cd18b2891f04683ca77ccd5837", "url": "https://github.com/osmlab/atlas-checks/commit/0c636d008966f6cd18b2891f04683ca77ccd5837", "message": "ElevationUtilities: External data: Add tests to ensure that data is\nfetched.\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-30T19:25:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxODkxOQ==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r532918919", "bodyText": "We could execute doFetching in each ExternalDataUser instance itself to leverage threading. We might need to pass the cache through the constructor though so we could do doFetching in the constructor. Up to you--also lets us see which checks have heavier downloads.", "author": "seancoulter", "createdAt": "2020-11-30T21:36:10Z", "path": "src/main/java/org/openstreetmap/atlas/checks/distributed/IntegrityCheckSparkJob.java", "diffHunk": "@@ -93,12 +95,15 @@ public static void main(final String[] args)\n      * @param configuration\n      *            {@link MapRouletteConfiguration} to create a new {@link MapRouletteClient}s\n      */\n-    @SuppressWarnings(\"rawtypes\")\n     private static void executeChecks(final String country, final Atlas atlas,\n-            final Set<BaseCheck> checksToRun, final MapRouletteConfiguration configuration)\n+            final Set<BaseCheck<?>> checksToRun, final ExternalDataFetcher fetcher,\n+            final MapRouletteConfiguration configuration)\n     {\n         final Pool checkExecutionPool = new Pool(checksToRun.size(), \"Check execution pool\",\n                 POOL_DURATION_BEFORE_KILL);\n+        checksToRun.stream().filter(ExternalDataUser.class::isInstance)", "originalCommit": "0c636d008966f6cd18b2891f04683ca77ccd5837", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MTM2MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r533471361", "bodyText": "My initial implementation actually did use a constructor. IIRC, I had some issues with serialization and deserialization in my runs, along with some odd issues with sparkcontexts. I'll revisit this. And since you mention it, doing the fetching in a threaded manner would probably speed things up a bit.", "author": "tsmock", "createdAt": "2020-12-01T14:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxODkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0MjA2Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r540442066", "bodyText": "I've rewritten the logic to use the constructor. I've now tested it with an HDFS system with multiple nodes, so I'm keeping the constructor logic.", "author": "tsmock", "createdAt": "2020-12-10T19:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxODkxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "758386889547fac0c0d0fbd3ccadb27057002d08", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/distributed/IntegrityCheckSparkJob.java b/src/main/java/org/openstreetmap/atlas/checks/distributed/IntegrityCheckSparkJob.java\nindex 88fdb682..a0a1b332 100644\n--- a/src/main/java/org/openstreetmap/atlas/checks/distributed/IntegrityCheckSparkJob.java\n+++ b/src/main/java/org/openstreetmap/atlas/checks/distributed/IntegrityCheckSparkJob.java\n\n@@ -96,14 +95,10 @@ public class IntegrityCheckSparkJob extends IntegrityChecksCommandArguments\n      *            {@link MapRouletteConfiguration} to create a new {@link MapRouletteClient}s\n      */\n     private static void executeChecks(final String country, final Atlas atlas,\n-            final Set<BaseCheck<?>> checksToRun, final ExternalDataFetcher fetcher,\n-            final MapRouletteConfiguration configuration)\n+            final Set<BaseCheck<?>> checksToRun, final MapRouletteConfiguration configuration)\n     {\n         final Pool checkExecutionPool = new Pool(checksToRun.size(), \"Check execution pool\",\n                 POOL_DURATION_BEFORE_KILL);\n-        checksToRun.stream().filter(ExternalDataUser.class::isInstance)\n-                .map(ExternalDataUser.class::cast)\n-                .forEach(externalDataUser -> externalDataUser.doFetching(fetcher, atlas));\n         checksToRun.forEach(check -> checkExecutionPool.queue(new RunnableCheck(country, check,\n                 objectsToCheck(atlas, check), MapRouletteClient.instance(configuration))));\n         checkExecutionPool.close();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxOTYyMQ==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r532919621", "bodyText": "what's SparkJob.INPUT point to exactly?", "author": "seancoulter", "createdAt": "2020-11-30T21:37:30Z", "path": "src/main/java/org/openstreetmap/atlas/checks/distributed/IntegrityCheckSparkJob.java", "diffHunk": "@@ -133,21 +138,19 @@ public String getName()\n         return \"Integrity Check Spark Job\";\n     }\n \n-    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public void start(final CommandMap commandMap)\n     {\n-        final String atlasDirectory = (String) commandMap.get(ATLAS_FOLDER);\n+        final String atlasDirectory = (String) commandMap.get(SparkJob.INPUT);", "originalCommit": "0c636d008966f6cd18b2891f04683ca77ccd5837", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MTQ1Mg==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r533471452", "bodyText": "public static final Switch<String> INPUT = new Switch<>(\"input\", \"Input path of the Spark Job\", StringConverter.IDENTITY, Optionality.OPTIONAL); in org.openstreetmap.atlas.generator.tools.spark.SparkJob. Notably, ATLAS_FOLDER has been deprecated since atlas-checks 6.0.2, and I didn't see any differences in my runs when I switched it to the recommended switch.", "author": "tsmock", "createdAt": "2020-12-01T14:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxOTYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5MDcxMA==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r533690710", "bodyText": "Ah, thanks!", "author": "seancoulter", "createdAt": "2020-12-01T20:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxOTYyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "02b050e16683734b5f082f2b2ac9669d55d3d4f8", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/distributed/IntegrityCheckSparkJob.java b/src/main/java/org/openstreetmap/atlas/checks/distributed/IntegrityCheckSparkJob.java\nindex 88fdb682..266d025d 100644\n--- a/src/main/java/org/openstreetmap/atlas/checks/distributed/IntegrityCheckSparkJob.java\n+++ b/src/main/java/org/openstreetmap/atlas/checks/distributed/IntegrityCheckSparkJob.java\n\n@@ -138,19 +133,21 @@ public class IntegrityCheckSparkJob extends IntegrityChecksCommandArguments\n         return \"Integrity Check Spark Job\";\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n     @Override\n     public void start(final CommandMap commandMap)\n     {\n-        final String atlasDirectory = (String) commandMap.get(SparkJob.INPUT);\n+        final String atlasDirectory = (String) commandMap.get(ATLAS_FOLDER);\n         final String input = Optional.ofNullable(this.input(commandMap)).orElse(atlasDirectory);\n         final String output = this.output(commandMap);\n+        @SuppressWarnings(\"unchecked\")\n         final Set<OutputFormats> outputFormats = (Set<OutputFormats>) commandMap\n                 .get(OUTPUT_FORMATS);\n         final StringList countries = StringList.split((String) commandMap.get(COUNTRIES),\n                 CommonConstants.COMMA);\n         final MapRouletteConfiguration mapRouletteConfiguration = (MapRouletteConfiguration) commandMap\n                 .get(MAP_ROULETTE);\n+        @SuppressWarnings(\"unchecked\")\n         final Optional<List<String>> checkFilter = (Optional<List<String>>) commandMap\n                 .getOption(CHECK_FILTER);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyMTg1MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r532921851", "bodyText": "Same with this -- might be better off in the check's constructor", "author": "seancoulter", "createdAt": "2020-11-30T21:41:55Z", "path": "src/main/java/org/openstreetmap/atlas/checks/distributed/ShardedIntegrityChecksSparkJob.java", "diffHunk": "@@ -395,8 +396,16 @@ public void process(final CheckFlagEvent event)\n             try (Pool checkPool = new Pool(task.getChecks().size(),\n                     \"Sharded Checks Execution Pool\"))\n             {\n+                // Get the file fetcher\n+                final ExternalDataFetcher fileFetcher = new ExternalDataFetcher(input,\n+                        configurationMap);\n                 for (final Check check : task.getChecks())\n                 {\n+                    if (check instanceof ExternalDataUser)\n+                    {\n+\n+                        ((ExternalDataUser) check).doFetching(fileFetcher, atlas);", "originalCommit": "0c636d008966f6cd18b2891f04683ca77ccd5837", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "758386889547fac0c0d0fbd3ccadb27057002d08", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/distributed/ShardedIntegrityChecksSparkJob.java b/src/main/java/org/openstreetmap/atlas/checks/distributed/ShardedIntegrityChecksSparkJob.java\nindex f744946a..bedfaf41 100644\n--- a/src/main/java/org/openstreetmap/atlas/checks/distributed/ShardedIntegrityChecksSparkJob.java\n+++ b/src/main/java/org/openstreetmap/atlas/checks/distributed/ShardedIntegrityChecksSparkJob.java\n\n@@ -396,16 +400,8 @@ public class ShardedIntegrityChecksSparkJob extends IntegrityChecksCommandArgume\n             try (Pool checkPool = new Pool(task.getChecks().size(),\n                     \"Sharded Checks Execution Pool\"))\n             {\n-                // Get the file fetcher\n-                final ExternalDataFetcher fileFetcher = new ExternalDataFetcher(input,\n-                        configurationMap);\n                 for (final Check check : task.getChecks())\n                 {\n-                    if (check instanceof ExternalDataUser)\n-                    {\n-\n-                        ((ExternalDataUser) check).doFetching(fileFetcher, atlas);\n-                    }\n                     checkPool.queue(new RunnableCheck(task.getCountry(), check,\n                             objectsToCheck(atlas, check, boundaryFilter), eventService));\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyNTMyNw==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r532925327", "bodyText": "nit: tis -> tarInputStream (?) to avoid abbreviations", "author": "seancoulter", "createdAt": "2020-11-30T21:48:46Z", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -314,25 +376,32 @@ public void putMap(final Location location, final short[][] map)\n      */\n     private synchronized short[][] loadMap(final int lat, final int lon)\n     {\n+        if (this.fileFetcher == null)\n+        {\n+            logger.error(\"Cannot load maps -- fileFetcher is not initialized or is null\");\n+            return EMPTY_MAP;\n+        }\n         final String filename = this.getSrtmFileName(lat, lon);\n-        Path path = Paths.get(this.srtmPath, filename);\n-        if (!path.toFile().isFile())\n+        Optional<Resource> path = this.fileFetcher\n+                .apply(Paths.get(this.srtmPath, filename).toString());\n+        if (path.isEmpty())\n         {\n-            for (final String ext : new String[] { \"zip\", \"gz\", \"xz\", \"bz\", \"bz2\", \"tar\" })\n+            for (final String ext : POSSIBLE_COMPRESSED_EXTS)\n             {\n-                path = Paths.get(this.srtmPath, filename + \".\" + ext);\n-                if (path.toFile().isFile())\n+                path = this.fileFetcher\n+                        .apply(Paths.get(this.srtmPath, filename + \".\" + ext).toString());\n+                if (path.isPresent())\n                 {\n                     break;\n                 }\n             }\n         }\n-        if (!path.toFile().isFile())\n+        if (path.isEmpty())\n         {\n             return EMPTY_MAP;\n         }\n-        try (InputStream is = CompressionUtilities\n-                .getUncompressedInputStream(Files.newInputStream(path)))\n+        try (InputStream tis = path.get().read();", "originalCommit": "0c636d008966f6cd18b2891f04683ca77ccd5837", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MjQ4MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r533472481", "bodyText": "Sorry about that. I tend to use abbreviations when writing the code (I usually don't want to accidentally mistype tarInputStream for example, and tis is a bit faster to type).", "author": "tsmock", "createdAt": "2020-12-01T14:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyNTMyNw=="}], "type": "inlineReview", "revised_code": {"commit": "758386889547fac0c0d0fbd3ccadb27057002d08", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java b/src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java\nindex 6bb818da..d21c682c 100644\n--- a/src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java\n+++ b/src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java\n\n@@ -374,6 +401,7 @@ public final class ElevationUtilities implements Serializable, ExternalDataUser\n      *            The longitude to use\n      * @return A short[latitude][longitude] = height in meters array\n      */\n+    @Nonnull\n     private synchronized short[][] loadMap(final int lat, final int lon)\n     {\n         if (this.fileFetcher == null)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyNTM0Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r532925343", "bodyText": "we could instead return EMPTY_MAP after the for loop in the above block, around line 398", "author": "seancoulter", "createdAt": "2020-11-30T21:48:47Z", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -314,25 +376,32 @@ public void putMap(final Location location, final short[][] map)\n      */\n     private synchronized short[][] loadMap(final int lat, final int lon)\n     {\n+        if (this.fileFetcher == null)\n+        {\n+            logger.error(\"Cannot load maps -- fileFetcher is not initialized or is null\");\n+            return EMPTY_MAP;\n+        }\n         final String filename = this.getSrtmFileName(lat, lon);\n-        Path path = Paths.get(this.srtmPath, filename);\n-        if (!path.toFile().isFile())\n+        Optional<Resource> path = this.fileFetcher\n+                .apply(Paths.get(this.srtmPath, filename).toString());\n+        if (path.isEmpty())\n         {\n-            for (final String ext : new String[] { \"zip\", \"gz\", \"xz\", \"bz\", \"bz2\", \"tar\" })\n+            for (final String ext : POSSIBLE_COMPRESSED_EXTS)\n             {\n-                path = Paths.get(this.srtmPath, filename + \".\" + ext);\n-                if (path.toFile().isFile())\n+                path = this.fileFetcher\n+                        .apply(Paths.get(this.srtmPath, filename + \".\" + ext).toString());\n+                if (path.isPresent())\n                 {\n                     break;\n                 }\n             }\n         }\n-        if (!path.toFile().isFile())\n+        if (path.isEmpty())", "originalCommit": "0c636d008966f6cd18b2891f04683ca77ccd5837", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3OTU2OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r533479569", "bodyText": "OK. This is confusing me.\nWhat I think you are saying:\n        if (path.isEmpty())\n        {\n            for (final String ext : POSSIBLE_COMPRESSED_EXTS)\n            {\n                path = this.fileFetcher\n                        .apply(Paths.get(this.srtmPath, filename + \".\" + ext).toString());\n                if (path.isPresent())\n                {\n                    break;\n                }\n            }\n            return EMPTY_MAP;\n        }\nThat would not work, since the whole point of the for loop is to find a file. We don't know if a file is found until after the for loop finishes/is broken, which means that we need to check if the path is empty again.\nThe alternative would be\n        if (path.isEmpty())\n        {\n            for (final String ext : POSSIBLE_COMPRESSED_EXTS)\n            {\n                path = this.fileFetcher\n                        .apply(Paths.get(this.srtmPath, filename + \".\" + ext).toString());\n                if (path.isPresent())\n                {\n                    break;\n                }\n            }\n            if (path.isEmpty())\n            {\n                return EMPTY_MAP;\n            }\n        }\nWhich, in my opinion, is less clear. I could extract the for loop to \"getPath\" or something similar, at which point your suggestion might work.\n       private getPath() {\n        Optional<Resource> path = this.fileFetcher\n                .apply(Paths.get(this.srtmPath, filename).toString());\n        if (!path.isEmpty()) return path;\n        \n            for (final String ext : POSSIBLE_COMPRESSED_EXTS)\n            {\n                path = this.fileFetcher\n                        .apply(Paths.get(this.srtmPath, filename + \".\" + ext).toString());\n                if (path.isPresent())\n                {\n                    return path;\n                }\n            }\n        return Optional.empty();\n    }\n\nprivate synchronized short[][] loadMap(..., ...) {\n...\n    Optional<Resource> path = getPath();\n    if (path.isEmpty()) return EMPTY_MAP;\n....\n}", "author": "tsmock", "createdAt": "2020-12-01T15:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyNTM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwMTk0Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r533701943", "bodyText": "You're right -- I was just trying to avoid having the same if check twice in a row, but it's perfectly valid the way you have it. Just a styling preference on my end as it got me scratching my head for a second. Another way would be to stream POSSIBLE_COMPRESSED_EXTS, something like this after the isEmpty check on line 399---\nArrays.stream(POSSIBLE_COMPRESSED_EXTS).map(ext -> this.fileFetcher.apply(Paths.get(this.srtmPath, filename + \".\" + ext).toString())).filter(Optional::isPresent).findFirst() then return that path or Optional.empty()", "author": "seancoulter", "createdAt": "2020-12-01T20:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyNTM0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "758386889547fac0c0d0fbd3ccadb27057002d08", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java b/src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java\nindex 6bb818da..d21c682c 100644\n--- a/src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java\n+++ b/src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java\n\n@@ -374,6 +401,7 @@ public final class ElevationUtilities implements Serializable, ExternalDataUser\n      *            The longitude to use\n      * @return A short[latitude][longitude] = height in meters array\n      */\n+    @Nonnull\n     private synchronized short[][] loadMap(final int lat, final int lon)\n     {\n         if (this.fileFetcher == null)\n"}}, {"oid": "758386889547fac0c0d0fbd3ccadb27057002d08", "url": "https://github.com/osmlab/atlas-checks/commit/758386889547fac0c0d0fbd3ccadb27057002d08", "message": "ExternalData: Use constructors to fetch data\n\n* Use constructors to fetch necessary data or to store the file fetcher\n  to be used later. Each check can decide how it fetches data.\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-12-09T18:13:19Z", "type": "forcePushed"}, {"oid": "55fc1a855f46a45932454f39235724ee25844626", "url": "https://github.com/osmlab/atlas-checks/commit/55fc1a855f46a45932454f39235724ee25844626", "message": "FIXUP: Use streams to get possible files\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-12-10T19:31:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM3NDQ3Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r541374477", "bodyText": "I think we need to assign this.cache if it's null then return it. Could be causing some cache misses", "author": "seancoulter", "createdAt": "2020-12-11T22:39:36Z", "path": "src/main/java/org/openstreetmap/atlas/checks/base/ExternalDataFetcher.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.openstreetmap.atlas.checks.base;\n+\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.openstreetmap.atlas.checks.distributed.ShardedIntegrityChecksSparkJob;\n+import org.openstreetmap.atlas.exception.CoreException;\n+import org.openstreetmap.atlas.generator.tools.filesystem.FileSystemHelper;\n+import org.openstreetmap.atlas.generator.tools.spark.utilities.SparkFileHelper;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.utilities.caching.ConcurrentResourceCache;\n+import org.openstreetmap.atlas.utilities.caching.strategies.NamespaceCachingStrategy;\n+import org.openstreetmap.atlas.utilities.runtime.Retry;\n+import org.openstreetmap.atlas.utilities.scalars.Duration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The fetcher to use for generic resources. The fetcher uses hadoop cache to reduce remote reads.\n+ * See {@link ShardedIntegrityChecksSparkJob#atlasFetcher}. This a separate class so that it can\n+ * implement {@link Serializable}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class ExternalDataFetcher implements Function<String, Optional<Resource>>, Serializable\n+{\n+    /**\n+     * Cache external data sources locally\n+     *\n+     * @author Taylor Smock\n+     */\n+    private class ExternalDataResourceCache extends ConcurrentResourceCache\n+    {\n+        ExternalDataResourceCache()\n+        {\n+            super(new NamespaceCachingStrategy(GLOBAL_HADOOP_FILECACHE_NAMESPACE),\n+                    new ExternalFileFetcher());\n+        }\n+    }\n+\n+    /**\n+     * Create a serializable function to get external files for use with a\n+     * {@link org.openstreetmap.atlas.utilities.caching.ResourceCache}.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private class ExternalFileFetcher implements Function<URI, Optional<Resource>>, Serializable\n+    {\n+        private static final long serialVersionUID = 1721253891315559418L;\n+\n+        @Override\n+        public Optional<Resource> apply(final URI uri)\n+        {\n+            final Retry retry = new Retry(RETRY_ATTEMPTS, Duration.ONE_SECOND).withQuadratic(true);\n+            final boolean exists = retry.run(() ->\n+            {\n+                try (InputStream inputStream = FileSystemHelper\n+                        .resource(uri.toString(), ExternalDataFetcher.this.configuration).read())\n+                {\n+                    return true;\n+                }\n+                catch (final Exception e)\n+                {\n+                    if (e.getMessage().contains(FileSystemHelper.FILE_NOT_FOUND))\n+                    {\n+                        return false;\n+                    }\n+                    else\n+                    {\n+                        throw new CoreException(\"Unable to test existence of {}\", uri, e);\n+                    }\n+                }\n+            });\n+            if (!exists)\n+            {\n+                if (!ExternalDataFetcher.this.silent)\n+                {\n+                    logger.warn(\"Fetcher: resource {} does not exist!\", uri);\n+                }\n+                return Optional.empty();\n+            }\n+            return Optional.ofNullable(FileSystemHelper.resource(uri.toString(),\n+                    ExternalDataFetcher.this.configuration));\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 724339604023082195L;\n+    private static final String GLOBAL_HADOOP_FILECACHE_NAMESPACE = \"__HadoopExternalFileCache_global_namespace__\";\n+    private static final Logger logger = LoggerFactory.getLogger(ExternalDataFetcher.class);\n+    /** Maximum number of retries for where an error occurs when getting a file */\n+    private static final int RETRY_ATTEMPTS = 5;\n+    /** The input folder path (same as the atlas file paths) */\n+    private final String input;\n+    /** The configuration used to create the cache */\n+    private final Map<String, String> configuration;\n+    /** The actual caching object */\n+    private final transient ExternalDataResourceCache cache;\n+    /**\n+     * {@code true} implies that the caller does not want to log that files are not present\n+     */\n+    private boolean silent;\n+\n+    /**\n+     * Create the fetcher to use for generic resources. The fetcher uses hadoop cache to reduce\n+     * remote reads. See {@link ShardedIntegrityChecksSparkJob#atlasFetcher}.\n+     *\n+     * @param input\n+     *            {@link String} input folder path\n+     * @param configuration\n+     *            {@link org.openstreetmap.atlas.generator.tools.spark.SparkJob} configuration map\n+     */\n+    public ExternalDataFetcher(final String input, final Map<String, String> configuration)\n+    {\n+        this.input = input;\n+        this.configuration = configuration;\n+        this.cache = new ExternalDataResourceCache();\n+    }\n+\n+    @Override\n+    public Optional<Resource> apply(final String string)\n+    {\n+        return this.getCache().get(this.getUri(string));\n+    }\n+\n+    /**\n+     * Make missed file messages silent (use when checking for files -- please log actual issues\n+     * when this is used) Unfortunately, this does not suppress <i>all</i> messages from missed\n+     * files.\n+     *\n+     * @param silent\n+     *            {@code true} suppresses some logging messages from non-existent files\n+     */\n+    public void setSilent(final boolean silent)\n+    {\n+        this.silent = silent;\n+    }\n+\n+    /**\n+     * @return The resource cacher to use\n+     */\n+    @Nonnull\n+    private ExternalDataResourceCache getCache()\n+    {\n+        return this.cache != null ? this.cache : new ExternalDataResourceCache();", "originalCommit": "55fc1a855f46a45932454f39235724ee25844626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQzNTM4Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/398#discussion_r542435387", "bodyText": "I've made this change (I was originally looking at making ExternalDataResourceCache serializable, but that required changing ConcurrentResourceCache in an incompatible way).", "author": "tsmock", "createdAt": "2020-12-14T14:40:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM3NDQ3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "02b050e16683734b5f082f2b2ac9669d55d3d4f8", "chunk": "diff --git a/src/main/java/org/openstreetmap/atlas/checks/base/ExternalDataFetcher.java b/src/main/java/org/openstreetmap/atlas/checks/base/ExternalDataFetcher.java\ndeleted file mode 100644\nindex 48a31216..00000000\n--- a/src/main/java/org/openstreetmap/atlas/checks/base/ExternalDataFetcher.java\n+++ /dev/null\n\n@@ -1,174 +0,0 @@\n-package org.openstreetmap.atlas.checks.base;\n-\n-import java.io.InputStream;\n-import java.io.Serializable;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.function.Function;\n-\n-import javax.annotation.Nonnull;\n-\n-import org.openstreetmap.atlas.checks.distributed.ShardedIntegrityChecksSparkJob;\n-import org.openstreetmap.atlas.exception.CoreException;\n-import org.openstreetmap.atlas.generator.tools.filesystem.FileSystemHelper;\n-import org.openstreetmap.atlas.generator.tools.spark.utilities.SparkFileHelper;\n-import org.openstreetmap.atlas.streaming.resource.Resource;\n-import org.openstreetmap.atlas.utilities.caching.ConcurrentResourceCache;\n-import org.openstreetmap.atlas.utilities.caching.strategies.NamespaceCachingStrategy;\n-import org.openstreetmap.atlas.utilities.runtime.Retry;\n-import org.openstreetmap.atlas.utilities.scalars.Duration;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The fetcher to use for generic resources. The fetcher uses hadoop cache to reduce remote reads.\n- * See {@link ShardedIntegrityChecksSparkJob#atlasFetcher}. This a separate class so that it can\n- * implement {@link Serializable}\n- *\n- * @author Taylor Smock\n- */\n-public class ExternalDataFetcher implements Function<String, Optional<Resource>>, Serializable\n-{\n-    /**\n-     * Cache external data sources locally\n-     *\n-     * @author Taylor Smock\n-     */\n-    private class ExternalDataResourceCache extends ConcurrentResourceCache\n-    {\n-        ExternalDataResourceCache()\n-        {\n-            super(new NamespaceCachingStrategy(GLOBAL_HADOOP_FILECACHE_NAMESPACE),\n-                    new ExternalFileFetcher());\n-        }\n-    }\n-\n-    /**\n-     * Create a serializable function to get external files for use with a\n-     * {@link org.openstreetmap.atlas.utilities.caching.ResourceCache}.\n-     *\n-     * @author Taylor Smock\n-     */\n-    private class ExternalFileFetcher implements Function<URI, Optional<Resource>>, Serializable\n-    {\n-        private static final long serialVersionUID = 1721253891315559418L;\n-\n-        @Override\n-        public Optional<Resource> apply(final URI uri)\n-        {\n-            final Retry retry = new Retry(RETRY_ATTEMPTS, Duration.ONE_SECOND).withQuadratic(true);\n-            final boolean exists = retry.run(() ->\n-            {\n-                try (InputStream inputStream = FileSystemHelper\n-                        .resource(uri.toString(), ExternalDataFetcher.this.configuration).read())\n-                {\n-                    return true;\n-                }\n-                catch (final Exception e)\n-                {\n-                    if (e.getMessage().contains(FileSystemHelper.FILE_NOT_FOUND))\n-                    {\n-                        return false;\n-                    }\n-                    else\n-                    {\n-                        throw new CoreException(\"Unable to test existence of {}\", uri, e);\n-                    }\n-                }\n-            });\n-            if (!exists)\n-            {\n-                if (!ExternalDataFetcher.this.silent)\n-                {\n-                    logger.warn(\"Fetcher: resource {} does not exist!\", uri);\n-                }\n-                return Optional.empty();\n-            }\n-            return Optional.ofNullable(FileSystemHelper.resource(uri.toString(),\n-                    ExternalDataFetcher.this.configuration));\n-        }\n-    }\n-\n-    private static final long serialVersionUID = 724339604023082195L;\n-    private static final String GLOBAL_HADOOP_FILECACHE_NAMESPACE = \"__HadoopExternalFileCache_global_namespace__\";\n-    private static final Logger logger = LoggerFactory.getLogger(ExternalDataFetcher.class);\n-    /** Maximum number of retries for where an error occurs when getting a file */\n-    private static final int RETRY_ATTEMPTS = 5;\n-    /** The input folder path (same as the atlas file paths) */\n-    private final String input;\n-    /** The configuration used to create the cache */\n-    private final Map<String, String> configuration;\n-    /** The actual caching object */\n-    private final transient ExternalDataResourceCache cache;\n-    /**\n-     * {@code true} implies that the caller does not want to log that files are not present\n-     */\n-    private boolean silent;\n-\n-    /**\n-     * Create the fetcher to use for generic resources. The fetcher uses hadoop cache to reduce\n-     * remote reads. See {@link ShardedIntegrityChecksSparkJob#atlasFetcher}.\n-     *\n-     * @param input\n-     *            {@link String} input folder path\n-     * @param configuration\n-     *            {@link org.openstreetmap.atlas.generator.tools.spark.SparkJob} configuration map\n-     */\n-    public ExternalDataFetcher(final String input, final Map<String, String> configuration)\n-    {\n-        this.input = input;\n-        this.configuration = configuration;\n-        this.cache = new ExternalDataResourceCache();\n-    }\n-\n-    @Override\n-    public Optional<Resource> apply(final String string)\n-    {\n-        return this.getCache().get(this.getUri(string));\n-    }\n-\n-    /**\n-     * Make missed file messages silent (use when checking for files -- please log actual issues\n-     * when this is used) Unfortunately, this does not suppress <i>all</i> messages from missed\n-     * files.\n-     *\n-     * @param silent\n-     *            {@code true} suppresses some logging messages from non-existent files\n-     */\n-    public void setSilent(final boolean silent)\n-    {\n-        this.silent = silent;\n-    }\n-\n-    /**\n-     * @return The resource cacher to use\n-     */\n-    @Nonnull\n-    private ExternalDataResourceCache getCache()\n-    {\n-        return this.cache != null ? this.cache : new ExternalDataResourceCache();\n-    }\n-\n-    /**\n-     * Get a URI for a path string\n-     *\n-     * @param string\n-     *            The path\n-     * @return A URI for the string\n-     */\n-    private URI getUri(final String string)\n-    {\n-        final String atlasURIString = SparkFileHelper.combine(this.input, string);\n-        try\n-        {\n-            return new URI(atlasURIString);\n-        }\n-        catch (final URISyntaxException exception)\n-        {\n-            throw new CoreException(\"Bad URI syntax: {}\", atlasURIString, exception);\n-        }\n-    }\n-\n-}\n"}}, {"oid": "02b050e16683734b5f082f2b2ac9669d55d3d4f8", "url": "https://github.com/osmlab/atlas-checks/commit/02b050e16683734b5f082f2b2ac9669d55d3d4f8", "message": "Gradle: Add JUnit5\n\nJUnit5 has better support for exceptions (assertThrows,\nassertDoesNotThrow, etc.).\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-12-16T14:07:27Z", "type": "commit"}, {"oid": "8158f6b4e29f332bd338ca8dfaa7b47761ce7ece", "url": "https://github.com/osmlab/atlas-checks/commit/8158f6b4e29f332bd338ca8dfaa7b47761ce7ece", "message": "ExternalData: Allow checks to obtain and use arbitrary external data\n\nWaterWayChecks: Add note in documentation about resolution and NASA SRTM\nElevationUtilities: External data: Add tests to ensure that data is\nfetched.\nExternalData:\n* Use ResourceCache to get data\n* Use check constructors to fetch necessary data or to store the file fetcher\n  to be used later. Each check can decide how it fetches data.\n* See docs/externalData.md for implementation notes.\nCheckResourceLoader: Fix all code smells\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-12-16T16:24:30Z", "type": "commit"}, {"oid": "8158f6b4e29f332bd338ca8dfaa7b47761ce7ece", "url": "https://github.com/osmlab/atlas-checks/commit/8158f6b4e29f332bd338ca8dfaa7b47761ce7ece", "message": "ExternalData: Allow checks to obtain and use arbitrary external data\n\nWaterWayChecks: Add note in documentation about resolution and NASA SRTM\nElevationUtilities: External data: Add tests to ensure that data is\nfetched.\nExternalData:\n* Use ResourceCache to get data\n* Use check constructors to fetch necessary data or to store the file fetcher\n  to be used later. Each check can decide how it fetches data.\n* See docs/externalData.md for implementation notes.\nCheckResourceLoader: Fix all code smells\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-12-16T16:24:30Z", "type": "forcePushed"}]}