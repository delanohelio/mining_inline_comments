{"pr_number": 4053, "pr_title": "Secondary Storage Usage Improvements", "pr_createdAt": "2020-05-04T04:53:08Z", "pr_url": "https://github.com/apache/cloudstack/pull/4053", "timeline": [{"oid": "a11686d0e6f5d74ca035b22db1c0d66c30eeaede", "url": "https://github.com/apache/cloudstack/commit/a11686d0e6f5d74ca035b22db1c0d66c30eeaede", "message": "Secondary Storage Management", "committedDate": "2020-05-03T12:04:57Z", "type": "commit"}, {"oid": "94275d6e0f5c0ad0415591d9638f8880a8817cbb", "url": "https://github.com/apache/cloudstack/commit/94275d6e0f5c0ad0415591d9638f8880a8817cbb", "message": "Merge branch 'master' of github.com:shapeblue/cloudstack into SecStgMgmt", "committedDate": "2020-05-03T12:05:16Z", "type": "commit"}, {"oid": "ac50ee67e3e46bf8734a55770549f648dae8a1b8", "url": "https://github.com/apache/cloudstack/commit/ac50ee67e3e46bf8734a55770549f648dae8a1b8", "message": "Code clean up and logging", "committedDate": "2020-05-04T04:37:06Z", "type": "commit"}, {"oid": "87f9360d76d514c35fe12b7dfe050bf6a47e7016", "url": "https://github.com/apache/cloudstack/commit/87f9360d76d514c35fe12b7dfe050bf6a47e7016", "message": "Refactored code", "committedDate": "2020-05-04T04:52:17Z", "type": "commit"}, {"oid": "e4b9cca959db74b9904003fc50a5c8002061df7b", "url": "https://github.com/apache/cloudstack/commit/e4b9cca959db74b9904003fc50a5c8002061df7b", "message": "Refactored code", "committedDate": "2020-05-05T13:23:53Z", "type": "commit"}, {"oid": "e4b9cca959db74b9904003fc50a5c8002061df7b", "url": "https://github.com/apache/cloudstack/commit/e4b9cca959db74b9904003fc50a5c8002061df7b", "message": "Refactored code", "committedDate": "2020-05-05T13:23:53Z", "type": "forcePushed"}, {"oid": "db6a434da5382f20c1d8435a4028cc6c41313145", "url": "https://github.com/apache/cloudstack/commit/db6a434da5382f20c1d8435a4028cc6c41313145", "message": "fine tuned scaling condition + allocation algorithm GS", "committedDate": "2020-05-06T12:57:27Z", "type": "commit"}, {"oid": "db6a434da5382f20c1d8435a4028cc6c41313145", "url": "https://github.com/apache/cloudstack/commit/db6a434da5382f20c1d8435a4028cc6c41313145", "message": "fine tuned scaling condition + allocation algorithm GS", "committedDate": "2020-05-06T12:57:27Z", "type": "forcePushed"}, {"oid": "ed2fe4e1289c47ae4ac89c95c09fbee833334ecd", "url": "https://github.com/apache/cloudstack/commit/ed2fe4e1289c47ae4ac89c95c09fbee833334ecd", "message": "Code changes and cleanup", "committedDate": "2020-05-07T04:48:07Z", "type": "commit"}, {"oid": "082c7c73853b95ec40846aaf7b0f1229152740d5", "url": "https://github.com/apache/cloudstack/commit/082c7c73853b95ec40846aaf7b0f1229152740d5", "message": "Refactored code", "committedDate": "2020-05-08T05:18:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAwMzM5OQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422003399", "bodyText": "can you extract this bit like sendToLeastBusyEndPoint()?", "author": "DaanHoogland", "createdAt": "2020-05-08T07:58:47Z", "path": "engine/storage/src/main/java/org/apache/cloudstack/storage/image/BaseImageStoreDriverImpl.java", "diffHunk": "@@ -373,32 +375,26 @@ public void copyAsync(DataObject srcdata, DataObject destData, AsyncCompletionCa\n                 s_logger.error(errMsg);\n                 answer = new Answer(cmd, false, errMsg);\n             } else {\n-                boolean sent = false;\n-                // Find the first endpoint to which the command can be sent to\n-                for (EndPoint ep : eps) {\n-                    if (getCopyCmdsCountToSpecificSSVM(ep.getId()) >= maxConcurrentCopyOpsPerSSVM) {\n-                        continue;\n+                // select endpoint with least number of commands running on them\n+                EndPoint endPoint = null;\n+                Long epId = ssvmWithLeastMigrateJobs();\n+                if (epId == null) {\n+                    Collections.shuffle(eps);\n+                    endPoint = eps.get(0);\n+                } else {\n+                    List<EndPoint> remainingEps = eps.stream().filter(ep -> ep.getId() != epId ).collect(Collectors.toList());\n+                    if (!remainingEps.isEmpty()) {\n+                        Collections.shuffle(remainingEps);\n+                        endPoint = remainingEps.get(0);\n+                    } else {\n+                        endPoint = _defaultEpSelector.getEndPointFromHostId(epId);\n                     }\n-\n-                    CommandExecLogVO execLog = new CommandExecLogVO(ep.getId(), _secStorageVmDao.findByInstanceName(hostDao.findById(ep.getId()).getName()).getId(), cmd.getClass().getSimpleName(), 1);\n-                    Long cmdExecId = _cmdExecLogDao.persist(execLog).getId();\n-                    answer = ep.sendMessage(cmd);\n-                    answer.setContextParam(\"cmd\", cmdExecId.toString());\n-                    sent = true;\n-                    break;\n-                }\n-                // If both SSVMs are pre-occupied with tasks, choose the SSVM with least migrate jobs\n-                if (!sent) {\n-                    // Picking endpoint with least number of copy commands running on it\n-                    Long epId = ssvmWithLeastMigrateJobs();\n-                    EndPoint endPoint = _defaultEpSelector.getEndPointFromHostId(epId);\n-                    CommandExecLogVO execLog = new CommandExecLogVO(epId, _secStorageVmDao.findByInstanceName(hostDao.findById(epId).getName()).getId(), cmd.getClass().getSimpleName(), 1);\n-                    Long cmdExecId = _cmdExecLogDao.persist(execLog).getId();\n-                    answer = endPoint.sendMessage(cmd);\n-                    answer.setContextParam(\"cmd\", cmdExecId.toString());\n                 }\n+                CommandExecLogVO execLog = new CommandExecLogVO(endPoint.getId(), _secStorageVmDao.findByInstanceName(hostDao.findById(endPoint.getId()).getName()).getId(), cmd.getClass().getSimpleName(), 1);\n+                Long cmdExecId = _cmdExecLogDao.persist(execLog).getId();\n+                answer = endPoint.sendMessage(cmd);\n+                answer.setContextParam(\"cmd\", cmdExecId.toString());", "originalCommit": "082c7c73853b95ec40846aaf7b0f1229152740d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAzNTA5Mw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422035093", "bodyText": "Done", "author": "Pearl1594", "createdAt": "2020-05-08T09:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAwMzM5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "228c70377490297afe68779d622bc8c7eff1fb86", "chunk": "diff --git a/engine/storage/src/main/java/org/apache/cloudstack/storage/image/BaseImageStoreDriverImpl.java b/engine/storage/src/main/java/org/apache/cloudstack/storage/image/BaseImageStoreDriverImpl.java\nindex 820c4bdbc4..fc2558495e 100644\n--- a/engine/storage/src/main/java/org/apache/cloudstack/storage/image/BaseImageStoreDriverImpl.java\n+++ b/engine/storage/src/main/java/org/apache/cloudstack/storage/image/BaseImageStoreDriverImpl.java\n\n@@ -376,30 +375,36 @@ public abstract class BaseImageStoreDriverImpl implements ImageStoreDriver {\n                 answer = new Answer(cmd, false, errMsg);\n             } else {\n                 // select endpoint with least number of commands running on them\n-                EndPoint endPoint = null;\n-                Long epId = ssvmWithLeastMigrateJobs();\n-                if (epId == null) {\n-                    Collections.shuffle(eps);\n-                    endPoint = eps.get(0);\n-                } else {\n-                    List<EndPoint> remainingEps = eps.stream().filter(ep -> ep.getId() != epId ).collect(Collectors.toList());\n-                    if (!remainingEps.isEmpty()) {\n-                        Collections.shuffle(remainingEps);\n-                        endPoint = remainingEps.get(0);\n-                    } else {\n-                        endPoint = _defaultEpSelector.getEndPointFromHostId(epId);\n-                    }\n-                }\n-                CommandExecLogVO execLog = new CommandExecLogVO(endPoint.getId(), _secStorageVmDao.findByInstanceName(hostDao.findById(endPoint.getId()).getName()).getId(), cmd.getClass().getSimpleName(), 1);\n-                Long cmdExecId = _cmdExecLogDao.persist(execLog).getId();\n-                answer = endPoint.sendMessage(cmd);\n-                answer.setContextParam(\"cmd\", cmdExecId.toString());\n+                answer = sendToLeastBusyEndpoint(eps, cmd);\n             }\n             CopyCommandResult result = new CopyCommandResult(\"\", answer);\n             callback.complete(result);\n         }\n     }\n \n+    private Answer sendToLeastBusyEndpoint(List<EndPoint> eps, CopyCommand cmd) {\n+        Answer answer = null;\n+        EndPoint endPoint = null;\n+        Long epId = ssvmWithLeastMigrateJobs();\n+        if (epId == null) {\n+            Collections.shuffle(eps);\n+            endPoint = eps.get(0);\n+        } else {\n+            List<EndPoint> remainingEps = eps.stream().filter(ep -> ep.getId() != epId ).collect(Collectors.toList());\n+            if (!remainingEps.isEmpty()) {\n+                Collections.shuffle(remainingEps);\n+                endPoint = remainingEps.get(0);\n+            } else {\n+                endPoint = _defaultEpSelector.getEndPointFromHostId(epId);\n+            }\n+        }\n+        CommandExecLogVO execLog = new CommandExecLogVO(endPoint.getId(), _secStorageVmDao.findByInstanceName(hostDao.findById(endPoint.getId()).getName()).getId(), cmd.getClass().getSimpleName(), 1);\n+        Long cmdExecId = _cmdExecLogDao.persist(execLog).getId();\n+        answer = endPoint.sendMessage(cmd);\n+        answer.setContextParam(\"cmd\", cmdExecId.toString());\n+        return answer;\n+    }\n+\n     @Override\n     public boolean canCopy(DataObject srcData, DataObject destData) {\n         if (srcData.getDataStore().getTO() instanceof NfsTO && destData.getDataStore().getTO() instanceof NfsTO) {\n"}}, {"oid": "228c70377490297afe68779d622bc8c7eff1fb86", "url": "https://github.com/apache/cloudstack/commit/228c70377490297afe68779d622bc8c7eff1fb86", "message": "Added check for templates already present on destination + code refactoring", "committedDate": "2020-05-08T08:41:56Z", "type": "forcePushed"}, {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "url": "https://github.com/apache/cloudstack/commit/3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "message": "Added check for templates already present on destination + code refactoring", "committedDate": "2020-05-08T09:49:40Z", "type": "commit"}, {"oid": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "url": "https://github.com/apache/cloudstack/commit/3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "message": "Added check for templates already present on destination + code refactoring", "committedDate": "2020-05-08T09:49:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MTIxOQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422041219", "bodyText": "how is this used in the API? I could imagine a name like srcStore or srcImage would be more appropriate.", "author": "DaanHoogland", "createdAt": "2020-05-08T09:23:40Z", "path": "api/src/main/java/org/apache/cloudstack/api/ApiConstants.java", "diffHunk": "@@ -777,6 +780,7 @@\n     public static final String EXITCODE = \"exitcode\";\n     public static final String TARGET_ID = \"targetid\";\n     public static final String FILES = \"files\";\n+    public static final String FROM = \"from\";", "originalCommit": "228c70377490297afe68779d622bc8c7eff1fb86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4MDAyMg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422080022", "bodyText": "the API is more:\nmigrate secondarystoragedata from=<> migrateto=<> migrationtype=<> ..\nHowever, I could refactor that", "author": "Pearl1594", "createdAt": "2020-05-08T10:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MTIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3NzgwMQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422977801", "bodyText": "done", "author": "Pearl1594", "createdAt": "2020-05-11T11:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MTIxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/ApiConstants.java b/api/src/main/java/org/apache/cloudstack/api/ApiConstants.java\nindex 1c2cab7124..b294e5b2e5 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/ApiConstants.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/ApiConstants.java\n\n@@ -780,7 +780,8 @@ public class ApiConstants {\n     public static final String EXITCODE = \"exitcode\";\n     public static final String TARGET_ID = \"targetid\";\n     public static final String FILES = \"files\";\n-    public static final String FROM = \"from\";\n+    public static final String SRC_POOL = \"srcpool\";\n+    public static final String DEST_POOLS = \"destpools\";\n     public static final String VOLUME_IDS = \"volumeids\";\n \n     public static final String ROUTER_ID = \"routerid\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MTcyMg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422041722", "bodyText": "new classes should go into org.apache.cloudstack.*", "author": "DaanHoogland", "createdAt": "2020-05-08T09:24:36Z", "path": "api/src/main/java/com/cloud/storage/ImageStoreService.java", "diffHunk": "@@ -0,0 +1,29 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package com.cloud.storage;", "originalCommit": "228c70377490297afe68779d622bc8c7eff1fb86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3Nzk0Mw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422977943", "bodyText": "moved the file to appropriate pkg", "author": "Pearl1594", "createdAt": "2020-05-11T11:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MTcyMg=="}], "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/api/src/main/java/com/cloud/storage/ImageStoreService.java b/api/src/main/java/org/apache/cloudstack/storage/ImageStoreService.java\nsimilarity index 96%\nrename from api/src/main/java/com/cloud/storage/ImageStoreService.java\nrename to api/src/main/java/org/apache/cloudstack/storage/ImageStoreService.java\nindex 1189751d6c..b8f14ad2bf 100644\n--- a/api/src/main/java/com/cloud/storage/ImageStoreService.java\n+++ b/api/src/main/java/org/apache/cloudstack/storage/ImageStoreService.java\n\n@@ -15,7 +15,7 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-package com.cloud.storage;\n+package org.apache.cloudstack.storage;\n \n import org.apache.cloudstack.api.command.admin.storage.MigrateSecondaryStorageDataCmd;\n import org.apache.cloudstack.api.response.MigrationResponse;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MzM3MA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422043370", "bodyText": "I think these should be called sourcePool and destinationPools. In light of conventions srcpool and destpools` are best, I think.", "author": "DaanHoogland", "createdAt": "2020-05-08T09:28:24Z", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+\n+    public static final String APINAME = \"migrateSecondaryStorageData\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Parameter(name = ApiConstants.FROM,\n+            type = CommandType.UUID,\n+            entityType = ImageStoreResponse.class,\n+            description = \"id of the image store from where the data is to be migrated\",\n+    required = true)\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.MIGRATE_TO,\n+    type = CommandType.LIST,\n+    collectionType = CommandType.UUID,\n+    entityType = ImageStoreResponse.class,\n+    description = \"id of the destination secondary storage pool to which the templates are to be migrated to\",\n+    required = true)\n+    private List<Long> migrateTo;", "originalCommit": "228c70377490297afe68779d622bc8c7eff1fb86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODE0Mg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978142", "bodyText": "done", "author": "Pearl1594", "createdAt": "2020-05-11T11:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0MzM3MA=="}], "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\nindex 3a9c68ad98..6e6930c44f 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n\n@@ -24,25 +24,17 @@ import org.apache.cloudstack.api.APICommand;\n import org.apache.cloudstack.api.ApiConstants;\n import org.apache.cloudstack.api.BaseAsyncCmd;\n import org.apache.cloudstack.api.Parameter;\n-import org.apache.cloudstack.api.ServerApiException;\n import org.apache.cloudstack.api.response.ImageStoreResponse;\n import org.apache.cloudstack.api.response.MigrationResponse;\n import org.apache.cloudstack.context.CallContext;\n import org.apache.log4j.Logger;\n \n import com.cloud.event.EventTypes;\n-import com.cloud.exception.ConcurrentOperationException;\n-import com.cloud.exception.InsufficientCapacityException;\n-import com.cloud.exception.NetworkRuleConflictException;\n-import com.cloud.exception.ResourceAllocationException;\n-import com.cloud.exception.ResourceUnavailableException;\n-import com.cloud.storage.ImageStore;\n import com.cloud.utils.StringUtils;\n \n @APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n         description = \"migrates data objects from one secondary storage to destination image store(s)\",\n         responseObject = MigrationResponse.class,\n-        entityType = {ImageStore.class},\n         requestHasSensitiveInfo = false,\n         responseHasSensitiveInfo = false,\n         since = \"4.14.0\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0NTEzMA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422045130", "bodyText": "id(s) of the destination storage pool(s) and remove the last to from the sentence", "author": "DaanHoogland", "createdAt": "2020-05-08T09:32:28Z", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+\n+    public static final String APINAME = \"migrateSecondaryStorageData\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Parameter(name = ApiConstants.FROM,\n+            type = CommandType.UUID,\n+            entityType = ImageStoreResponse.class,\n+            description = \"id of the image store from where the data is to be migrated\",\n+    required = true)\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.MIGRATE_TO,\n+    type = CommandType.LIST,\n+    collectionType = CommandType.UUID,\n+    entityType = ImageStoreResponse.class,\n+    description = \"id of the destination secondary storage pool to which the templates are to be migrated to\",", "originalCommit": "228c70377490297afe68779d622bc8c7eff1fb86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODE4MA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978180", "bodyText": "done", "author": "Pearl1594", "createdAt": "2020-05-11T11:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0NTEzMA=="}], "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\nindex 3a9c68ad98..6e6930c44f 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n\n@@ -24,25 +24,17 @@ import org.apache.cloudstack.api.APICommand;\n import org.apache.cloudstack.api.ApiConstants;\n import org.apache.cloudstack.api.BaseAsyncCmd;\n import org.apache.cloudstack.api.Parameter;\n-import org.apache.cloudstack.api.ServerApiException;\n import org.apache.cloudstack.api.response.ImageStoreResponse;\n import org.apache.cloudstack.api.response.MigrationResponse;\n import org.apache.cloudstack.context.CallContext;\n import org.apache.log4j.Logger;\n \n import com.cloud.event.EventTypes;\n-import com.cloud.exception.ConcurrentOperationException;\n-import com.cloud.exception.InsufficientCapacityException;\n-import com.cloud.exception.NetworkRuleConflictException;\n-import com.cloud.exception.ResourceAllocationException;\n-import com.cloud.exception.ResourceUnavailableException;\n-import com.cloud.storage.ImageStore;\n import com.cloud.utils.StringUtils;\n \n @APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n         description = \"migrates data objects from one secondary storage to destination image store(s)\",\n         responseObject = MigrationResponse.class,\n-        entityType = {ImageStore.class},\n         requestHasSensitiveInfo = false,\n         responseHasSensitiveInfo = false,\n         since = \"4.14.0\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0NTkwNg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422045906", "bodyText": "why is this required, isn't Complete a reasonable default? making this required lays unnecessary burdon on the user.", "author": "DaanHoogland", "createdAt": "2020-05-08T09:34:13Z", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+\n+    public static final String APINAME = \"migrateSecondaryStorageData\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Parameter(name = ApiConstants.FROM,\n+            type = CommandType.UUID,\n+            entityType = ImageStoreResponse.class,\n+            description = \"id of the image store from where the data is to be migrated\",\n+    required = true)\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.MIGRATE_TO,\n+    type = CommandType.LIST,\n+    collectionType = CommandType.UUID,\n+    entityType = ImageStoreResponse.class,\n+    description = \"id of the destination secondary storage pool to which the templates are to be migrated to\",\n+    required = true)\n+    private List<Long> migrateTo;\n+\n+    @Parameter(name = ApiConstants.MIGRATION_TYPE,\n+    type = CommandType.STRING,\n+    description = \"Balance: if you want data to be distributed evenly among the destination stores, \" +\n+            \"Complete: If you want to migrate the entire data from source image store to the destination store(s)\",\n+    required = true)", "originalCommit": "228c70377490297afe68779d622bc8c7eff1fb86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODI2NQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978265", "bodyText": "Made complete migration as default action", "author": "Pearl1594", "createdAt": "2020-05-11T11:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0NTkwNg=="}], "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\nindex 3a9c68ad98..6e6930c44f 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n\n@@ -24,25 +24,17 @@ import org.apache.cloudstack.api.APICommand;\n import org.apache.cloudstack.api.ApiConstants;\n import org.apache.cloudstack.api.BaseAsyncCmd;\n import org.apache.cloudstack.api.Parameter;\n-import org.apache.cloudstack.api.ServerApiException;\n import org.apache.cloudstack.api.response.ImageStoreResponse;\n import org.apache.cloudstack.api.response.MigrationResponse;\n import org.apache.cloudstack.context.CallContext;\n import org.apache.log4j.Logger;\n \n import com.cloud.event.EventTypes;\n-import com.cloud.exception.ConcurrentOperationException;\n-import com.cloud.exception.InsufficientCapacityException;\n-import com.cloud.exception.NetworkRuleConflictException;\n-import com.cloud.exception.ResourceAllocationException;\n-import com.cloud.exception.ResourceUnavailableException;\n-import com.cloud.storage.ImageStore;\n import com.cloud.utils.StringUtils;\n \n @APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n         description = \"migrates data objects from one secondary storage to destination image store(s)\",\n         responseObject = MigrationResponse.class,\n-        entityType = {ImageStore.class},\n         requestHasSensitiveInfo = false,\n         responseHasSensitiveInfo = false,\n         since = \"4.14.0\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1MDg2NQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422050865", "bodyText": "Why throw so many different exceptions? we can catch most of them and give nice consise error messages in a ServerApiException, right?\nMost of these are Runtime exception.\nMentioning them here is also redundant as they are declared in BaseCmd as well.", "author": "DaanHoogland", "createdAt": "2020-05-08T09:45:53Z", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+\n+    public static final String APINAME = \"migrateSecondaryStorageData\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Parameter(name = ApiConstants.FROM,\n+            type = CommandType.UUID,\n+            entityType = ImageStoreResponse.class,\n+            description = \"id of the image store from where the data is to be migrated\",\n+    required = true)\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.MIGRATE_TO,\n+    type = CommandType.LIST,\n+    collectionType = CommandType.UUID,\n+    entityType = ImageStoreResponse.class,\n+    description = \"id of the destination secondary storage pool to which the templates are to be migrated to\",\n+    required = true)\n+    private List<Long> migrateTo;\n+\n+    @Parameter(name = ApiConstants.MIGRATION_TYPE,\n+    type = CommandType.STRING,\n+    description = \"Balance: if you want data to be distributed evenly among the destination stores, \" +\n+            \"Complete: If you want to migrate the entire data from source image store to the destination store(s)\",\n+    required = true)\n+    private String migrationType;\n+\n+    /////////////////////////////////////////////////////\n+    /////////////////// Accessors ///////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public List<Long> getMigrateTo() {\n+        return migrateTo;\n+    }\n+\n+    public String getMigrationType() {\n+        return migrationType;\n+    }\n+\n+    @Override\n+    public String getEventType() {\n+        return EventTypes.EVENT_FILE_MIGRATE;\n+    }\n+\n+    @Override\n+    public String getEventDescription() {\n+        return \"Attempting to migrate files/data objects \" + \"from : \" + this.getId() + \" to: \" + StringUtils.join(getMigrateTo(), \",\");\n+    }\n+\n+    @Override\n+    public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {", "originalCommit": "228c70377490297afe68779d622bc8c7eff1fb86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\nindex 3a9c68ad98..6e6930c44f 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n\n@@ -24,25 +24,17 @@ import org.apache.cloudstack.api.APICommand;\n import org.apache.cloudstack.api.ApiConstants;\n import org.apache.cloudstack.api.BaseAsyncCmd;\n import org.apache.cloudstack.api.Parameter;\n-import org.apache.cloudstack.api.ServerApiException;\n import org.apache.cloudstack.api.response.ImageStoreResponse;\n import org.apache.cloudstack.api.response.MigrationResponse;\n import org.apache.cloudstack.context.CallContext;\n import org.apache.log4j.Logger;\n \n import com.cloud.event.EventTypes;\n-import com.cloud.exception.ConcurrentOperationException;\n-import com.cloud.exception.InsufficientCapacityException;\n-import com.cloud.exception.NetworkRuleConflictException;\n-import com.cloud.exception.ResourceAllocationException;\n-import com.cloud.exception.ResourceUnavailableException;\n-import com.cloud.storage.ImageStore;\n import com.cloud.utils.StringUtils;\n \n @APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n         description = \"migrates data objects from one secondary storage to destination image store(s)\",\n         responseObject = MigrationResponse.class,\n-        entityType = {ImageStore.class},\n         requestHasSensitiveInfo = false,\n         responseHasSensitiveInfo = false,\n         since = \"4.14.0\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1MTUyNw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422051527", "bodyText": "same as above in MigrateSecondaryStorageDataCmd", "author": "DaanHoogland", "createdAt": "2020-05-08T09:47:17Z", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java", "diffHunk": "@@ -0,0 +1,93 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.ApiErrorCode;\n+import org.apache.cloudstack.api.BaseCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+\n+@APICommand(name = UpdateImageStoreCmd.APINAME, description = \"Updates image store read-only status\", responseObject = ImageStoreResponse.class, entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false, responseHasSensitiveInfo = false)\n+public class UpdateImageStoreCmd extends BaseCmd {\n+    private static final Logger LOG = Logger.getLogger(UpdateImageStoreCmd.class.getName());\n+    public static final String APINAME = \"updateImageStore\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+    @Parameter(name = ApiConstants.ID, type = CommandType.UUID, entityType = ImageStoreResponse.class, required = true, description = \"Image Store UUID\")\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.READ_ONLY, type = CommandType.BOOLEAN, required = true, description = \"If set to true, it designates the corresponding image store to read-only\")\n+    private Boolean readonly;\n+\n+    /////////////////////////////////////////////////////\n+    /////////////////// Accessors ///////////////////////\n+    /////////////////////////////////////////////////////\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public Boolean getReadonly() {\n+        return readonly;\n+    }\n+\n+    /////////////////////////////////////////////////////\n+    /////////////// API Implementation///////////////////\n+    /////////////////////////////////////////////////////\n+\n+    @Override\n+    public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {", "originalCommit": "228c70377490297afe68779d622bc8c7eff1fb86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java\nindex d3ae9a91d1..f7ff0d245b 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java\n\n@@ -27,11 +27,6 @@ import org.apache.cloudstack.api.response.ImageStoreResponse;\n import org.apache.cloudstack.context.CallContext;\n import org.apache.log4j.Logger;\n \n-import com.cloud.exception.ConcurrentOperationException;\n-import com.cloud.exception.InsufficientCapacityException;\n-import com.cloud.exception.NetworkRuleConflictException;\n-import com.cloud.exception.ResourceAllocationException;\n-import com.cloud.exception.ResourceUnavailableException;\n import com.cloud.storage.ImageStore;\n \n @APICommand(name = UpdateImageStoreCmd.APINAME, description = \"Updates image store read-only status\", responseObject = ImageStoreResponse.class, entityType = {ImageStore.class},\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1MjY5Mg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422052692", "bodyText": "can you expand on the usefullness of a store being read-only in this - or the API description? I.E. something like (in better English): \"useful for deprecating image stores during storage migrations\"", "author": "DaanHoogland", "createdAt": "2020-05-08T09:49:56Z", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java", "diffHunk": "@@ -0,0 +1,93 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.ApiErrorCode;\n+import org.apache.cloudstack.api.BaseCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.exception.ConcurrentOperationException;\n+import com.cloud.exception.InsufficientCapacityException;\n+import com.cloud.exception.NetworkRuleConflictException;\n+import com.cloud.exception.ResourceAllocationException;\n+import com.cloud.exception.ResourceUnavailableException;\n+import com.cloud.storage.ImageStore;\n+\n+@APICommand(name = UpdateImageStoreCmd.APINAME, description = \"Updates image store read-only status\", responseObject = ImageStoreResponse.class, entityType = {ImageStore.class},\n+        requestHasSensitiveInfo = false, responseHasSensitiveInfo = false)\n+public class UpdateImageStoreCmd extends BaseCmd {\n+    private static final Logger LOG = Logger.getLogger(UpdateImageStoreCmd.class.getName());\n+    public static final String APINAME = \"updateImageStore\";\n+\n+    /////////////////////////////////////////////////////\n+    //////////////// API parameters /////////////////////\n+    /////////////////////////////////////////////////////\n+    @Parameter(name = ApiConstants.ID, type = CommandType.UUID, entityType = ImageStoreResponse.class, required = true, description = \"Image Store UUID\")\n+    private Long id;\n+\n+    @Parameter(name = ApiConstants.READ_ONLY, type = CommandType.BOOLEAN, required = true, description = \"If set to true, it designates the corresponding image store to read-only\")", "originalCommit": "228c70377490297afe68779d622bc8c7eff1fb86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java\nindex d3ae9a91d1..f7ff0d245b 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java\n\n@@ -27,11 +27,6 @@ import org.apache.cloudstack.api.response.ImageStoreResponse;\n import org.apache.cloudstack.context.CallContext;\n import org.apache.log4j.Logger;\n \n-import com.cloud.exception.ConcurrentOperationException;\n-import com.cloud.exception.InsufficientCapacityException;\n-import com.cloud.exception.NetworkRuleConflictException;\n-import com.cloud.exception.ResourceAllocationException;\n-import com.cloud.exception.ResourceUnavailableException;\n import com.cloud.storage.ImageStore;\n \n @APICommand(name = UpdateImageStoreCmd.APINAME, description = \"Updates image store read-only status\", responseObject = ImageStoreResponse.class, entityType = {ImageStore.class},\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1NTE2NA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422055164", "bodyText": "A user might wonder what this means: \"Where does the messsage come from and what will it signify for me?\" Can you expand on that, please?", "author": "DaanHoogland", "createdAt": "2020-05-08T09:55:42Z", "path": "api/src/main/java/org/apache/cloudstack/api/response/MigrationResponse.java", "diffHunk": "@@ -0,0 +1,73 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.response;\n+\n+import org.apache.cloudstack.api.BaseResponse;\n+import org.apache.cloudstack.api.EntityReference;\n+\n+import com.cloud.serializer.Param;\n+import com.cloud.storage.ImageStore;\n+import com.google.gson.annotations.SerializedName;\n+\n+@EntityReference(value = ImageStore.class)\n+public class MigrationResponse extends BaseResponse {\n+    @SerializedName(\"message\")\n+    @Param(description = \"Response message\")", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/response/MigrationResponse.java b/api/src/main/java/org/apache/cloudstack/api/response/MigrationResponse.java\nindex eef959be74..c67b1d2d13 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/response/MigrationResponse.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/response/MigrationResponse.java\n\n@@ -27,7 +27,7 @@ import com.google.gson.annotations.SerializedName;\n @EntityReference(value = ImageStore.class)\n public class MigrationResponse extends BaseResponse {\n     @SerializedName(\"message\")\n-    @Param(description = \"Response message\")\n+    @Param(description = \"Response message from migration of secondary storage data objects\")\n     private String message;\n \n     @SerializedName(\"migrationtype\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1NjI3Mg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422056272", "bodyText": "I don't understand this comment, should it still be here or was it only there as development aid?", "author": "DaanHoogland", "createdAt": "2020-05-08T09:58:08Z", "path": "engine/api/src/main/java/org/apache/cloudstack/engine/subsystem/api/storage/ObjectInDataStoreStateMachine.java", "diffHunk": "@@ -49,8 +50,12 @@ public String getDescription() {\n         DestroyRequested,\n         OperationSuccessed,\n         OperationFailed,\n+        // Added as volume converts migrationrequested to copyrequested - VolumeObject.java", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/engine/api/src/main/java/org/apache/cloudstack/engine/subsystem/api/storage/ObjectInDataStoreStateMachine.java b/engine/api/src/main/java/org/apache/cloudstack/engine/subsystem/api/storage/ObjectInDataStoreStateMachine.java\nindex ae547eb326..3e6134f170 100644\n--- a/engine/api/src/main/java/org/apache/cloudstack/engine/subsystem/api/storage/ObjectInDataStoreStateMachine.java\n+++ b/engine/api/src/main/java/org/apache/cloudstack/engine/subsystem/api/storage/ObjectInDataStoreStateMachine.java\n\n@@ -50,7 +50,6 @@ public interface ObjectInDataStoreStateMachine extends StateObject<ObjectInDataS\n         DestroyRequested,\n         OperationSuccessed,\n         OperationFailed,\n-        // Added as volume converts migrationrequested to copyrequested - VolumeObject.java\n         CopyRequested,\n         CopyingRequested,\n         MigrationRequested,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1NzIyNQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422057225", "bodyText": "makes sense but will lead possibly to unecessary conflicts during rebases, which are inevitable for this PR", "author": "DaanHoogland", "createdAt": "2020-05-08T10:00:19Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/VolumeOrchestrator.java", "diffHunk": "@@ -141,7 +141,6 @@\n import com.cloud.vm.dao.UserVmDao;\n \n public class VolumeOrchestrator extends ManagerBase implements VolumeOrchestrationService, Configurable {\n-", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/VolumeOrchestrator.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/VolumeOrchestrator.java\nindex 6a0a40f24e..9e2168e0bf 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/VolumeOrchestrator.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/VolumeOrchestrator.java\n\n@@ -141,6 +141,7 @@ import com.cloud.vm.dao.UserVmCloneSettingDao;\n import com.cloud.vm.dao.UserVmDao;\n \n public class VolumeOrchestrator extends ManagerBase implements VolumeOrchestrationService, Configurable {\n+\n     public enum UserVmCloneType {\n         full, linked\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1ODM2Nw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422058367", "bodyText": "?", "author": "DaanHoogland", "createdAt": "2020-05-08T10:02:59Z", "path": "engine/schema/src/main/java/com/cloud/secstorage/CommandExecLogDaoImpl.java", "diffHunk": "@@ -43,4 +48,15 @@ public void expungeExpiredRecords(Date cutTime) {\n         sc.setParameters(\"created\", cutTime);\n         expunge(sc);\n     }\n+\n+    @Override\n+    public Integer getCopyCmdCountForSSVM(Long id) {\n+        SearchCriteria<CommandExecLogVO> sc = CommandSearch.create();\n+        sc.setParameters(\"host_id\", id);\n+        sc.setParameters(\"command_name\", \"CopyCommand\");\n+        List<CommandExecLogVO> copyCmds = customSearch(sc, null);\n+        return copyCmds.size();\n+    }\n+\n+", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/engine/schema/src/main/java/com/cloud/secstorage/CommandExecLogDaoImpl.java b/engine/schema/src/main/java/com/cloud/secstorage/CommandExecLogDaoImpl.java\nindex 048064e142..f89a1bbf4c 100644\n--- a/engine/schema/src/main/java/com/cloud/secstorage/CommandExecLogDaoImpl.java\n+++ b/engine/schema/src/main/java/com/cloud/secstorage/CommandExecLogDaoImpl.java\n\n@@ -57,6 +57,4 @@ public class CommandExecLogDaoImpl extends GenericDaoBase<CommandExecLogVO, Long\n         List<CommandExecLogVO> copyCmds = customSearch(sc, null);\n         return copyCmds.size();\n     }\n-\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1OTY2NQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422059665", "bodyText": "this method name is confusing: findByScope but than the scope is allready set to ZoneScope? Wouldn't findByZone be better?\nAlso the method above could probably just be extended with a flag for excludeReadOnly.", "author": "DaanHoogland", "createdAt": "2020-05-08T10:06:17Z", "path": "engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDao.java", "diffHunk": "@@ -31,6 +31,8 @@\n \n     List<ImageStoreVO> findByScope(ZoneScope scope);\n \n+    List<ImageStoreVO> findByScopeExcludingReadOnly(ZoneScope scope);", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDao.java b/engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDao.java\nindex 9ade4f9d08..84cba70e86 100644\n--- a/engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDao.java\n+++ b/engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDao.java\n\n@@ -29,9 +29,7 @@ public interface ImageStoreDao extends GenericDao<ImageStoreVO, Long> {\n \n     List<ImageStoreVO> findByProvider(String provider);\n \n-    List<ImageStoreVO> findByScope(ZoneScope scope);\n-\n-    List<ImageStoreVO> findByScopeExcludingReadOnly(ZoneScope scope);\n+    List<ImageStoreVO> findByZone(ZoneScope scope, Boolean readonly);\n \n     List<ImageStoreVO> findRegionImageStores();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2MDA5Mw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422060093", "bodyText": "so this line could be surrounded by if (readonlyExcludedFlag == true) {}", "author": "DaanHoogland", "createdAt": "2020-05-08T10:07:21Z", "path": "engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDaoImpl.java", "diffHunk": "@@ -91,6 +91,20 @@ public ImageStoreVO findByName(String name) {\n         return listBy(sc);\n     }\n \n+    @Override\n+    public List<ImageStoreVO> findByScopeExcludingReadOnly(ZoneScope scope) {\n+        SearchCriteria<ImageStoreVO> sc = createSearchCriteria();\n+        sc.addAnd(\"role\", SearchCriteria.Op.EQ, DataStoreRole.Image);\n+        if (scope.getScopeId() != null) {\n+            SearchCriteria<ImageStoreVO> scc = createSearchCriteria();\n+            scc.addOr(\"scope\", SearchCriteria.Op.EQ, ScopeType.REGION);\n+            scc.addOr(\"dcId\", SearchCriteria.Op.EQ, scope.getScopeId());\n+            sc.addAnd(\"scope\", SearchCriteria.Op.SC, scc);\n+            sc.addAnd(\"readonly\", SearchCriteria.Op.EQ, Boolean.FALSE);", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDaoImpl.java b/engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDaoImpl.java\nindex 5b73ec2a5e..0350b29074 100644\n--- a/engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDaoImpl.java\n+++ b/engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreDaoImpl.java\n\n@@ -85,26 +85,15 @@ public class ImageStoreDaoImpl extends GenericDaoBase<ImageStoreVO, Long> implem\n             scc.addOr(\"scope\", SearchCriteria.Op.EQ, ScopeType.REGION);\n             scc.addOr(\"dcId\", SearchCriteria.Op.EQ, scope.getScopeId());\n             sc.addAnd(\"scope\", SearchCriteria.Op.SC, scc);\n+            if (readonly != null) {\n+                sc.addAnd(\"readonly\", SearchCriteria.Op.EQ, readonly);\n+            }\n         }\n         // we should return all image stores if cross-zone scope is passed\n         // (scopeId = null)\n         return listBy(sc);\n     }\n \n-    @Override\n-    public List<ImageStoreVO> findByScopeExcludingReadOnly(ZoneScope scope) {\n-        SearchCriteria<ImageStoreVO> sc = createSearchCriteria();\n-        sc.addAnd(\"role\", SearchCriteria.Op.EQ, DataStoreRole.Image);\n-        if (scope.getScopeId() != null) {\n-            SearchCriteria<ImageStoreVO> scc = createSearchCriteria();\n-            scc.addOr(\"scope\", SearchCriteria.Op.EQ, ScopeType.REGION);\n-            scc.addOr(\"dcId\", SearchCriteria.Op.EQ, scope.getScopeId());\n-            sc.addAnd(\"scope\", SearchCriteria.Op.SC, scc);\n-            sc.addAnd(\"readonly\", SearchCriteria.Op.EQ, Boolean.FALSE);\n-        }\n-        return listBy(sc);\n-    }\n-\n     @Override\n     public List<ImageStoreVO> findRegionImageStores() {\n         SearchCriteria<ImageStoreVO> sc = regionSearch.create();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2MTA0Nw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422061047", "bodyText": "unecessary conlict potential", "author": "DaanHoogland", "createdAt": "2020-05-08T10:09:43Z", "path": "engine/storage/datamotion/src/main/java/org/apache/cloudstack/storage/motion/DataMotionServiceImpl.java", "diffHunk": "@@ -39,9 +33,14 @@\n import org.apache.cloudstack.engine.subsystem.api.storage.StorageStrategyFactory;\n import org.apache.cloudstack.engine.subsystem.api.storage.VolumeInfo;\n import org.apache.cloudstack.framework.async.AsyncCompletionCallback;\n+import org.apache.log4j.Logger;\n+import org.springframework.stereotype.Component;\n \n import com.cloud.agent.api.to.VirtualMachineTO;\n import com.cloud.host.Host;\n+import com.cloud.storage.Volume;\n+import com.cloud.storage.VolumeVO;\n+import com.cloud.storage.dao.VolumeDao;", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDQxNQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422064415", "bodyText": "this method is way too long. please modularise it into byte size chunks and factor it out to a worker - or utility class?\nI can not set a rule but in my opinion any method larger than 20 line or any class larger than 300 lines is probably not separating concerns.\nevery comment in this method should probably be converted to a good method name and extracted, and so should many top level blocks (if-, for- and while statements", "author": "DaanHoogland", "createdAt": "2020-05-08T10:18:14Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODQ0Nw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978447", "bodyText": "Created a utility class", "author": "Pearl1594", "createdAt": "2020-05-11T11:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDQxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5OTc4NA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426699784", "bodyText": "It is still 112 lines and there are a lot of comments in it that could serve as method names. This would help make the code more prozaic and thus easier to read. This method could do with some modularisation.", "author": "DaanHoogland", "createdAt": "2020-05-18T15:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDQxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxNDI0OA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427814248", "bodyText": "75 lines, still big but i slowly get the picture ;)", "author": "DaanHoogland", "createdAt": "2020-05-20T08:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDQxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\nindex d0fe0b39e2..2ffe58f2a5 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\n\n@@ -55,6 +55,7 @@ import org.apache.cloudstack.framework.config.ConfigKey;\n import org.apache.cloudstack.framework.config.Configurable;\n import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.ImageStoreService.MigrationPolicy;\n import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NTk4NQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422065985", "bodyText": "example extraction: above code could go in checkCompleteMigrationFor ReadyVolumesOnly(...)", "author": "DaanHoogland", "createdAt": "2020-05-08T10:22:18Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODUyMw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978523", "bodyText": "done", "author": "Pearl1594", "createdAt": "2020-05-11T11:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NTk4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\nindex d0fe0b39e2..2ffe58f2a5 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\n\n@@ -55,6 +55,7 @@ import org.apache.cloudstack.framework.config.ConfigKey;\n import org.apache.cloudstack.framework.config.Configurable;\n import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.ImageStoreService.MigrationPolicy;\n import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NjIyNQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422066225", "bodyText": "or: prepareSourcesList(...)", "author": "DaanHoogland", "createdAt": "2020-05-08T10:23:01Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+\n+        DataStore srcDatastore = dataStoreManager.getDataStore(srcDataStoreId, DataStoreRole.Image);\n+        Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains = new HashMap<>();\n+        files.addAll(getAllValidTemplates(srcDatastore));\n+        files.addAll(getAllValidSnapshotChains(srcDatastore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDatastore));", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODU2Mg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978562", "bodyText": "done", "author": "Pearl1594", "createdAt": "2020-05-11T11:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NjIyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\nindex d0fe0b39e2..2ffe58f2a5 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\n\n@@ -55,6 +55,7 @@ import org.apache.cloudstack.framework.config.ConfigKey;\n import org.apache.cloudstack.framework.config.Configurable;\n import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.ImageStoreService.MigrationPolicy;\n import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NzA0MQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422067041", "bodyText": "sortSources(...), should probably be called from prepareSourcesList()`\netc.\netc.\nhope you get my drift. The code looks good but this is about maintainability. happy to discuss.", "author": "DaanHoogland", "createdAt": "2020-05-08T10:24:58Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+\n+        DataStore srcDatastore = dataStoreManager.getDataStore(srcDataStoreId, DataStoreRole.Image);\n+        Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains = new HashMap<>();\n+        files.addAll(getAllValidTemplates(srcDatastore));\n+        files.addAll(getAllValidSnapshotChains(srcDatastore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDatastore));\n+\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                //return o2.getSize() > o1.getSize() ? 1 : -1;\n+                return size2 > size1 ? 1 : -1;\n+            }\n+        });", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODYyOQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978629", "bodyText": "done", "author": "Pearl1594", "createdAt": "2020-05-11T11:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NzA0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\nindex d0fe0b39e2..2ffe58f2a5 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\n\n@@ -55,6 +55,7 @@ import org.apache.cloudstack.framework.config.ConfigKey;\n import org.apache.cloudstack.framework.config.Configurable;\n import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.ImageStoreService.MigrationPolicy;\n import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2OTk1OA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422069958", "bodyText": "so never 0? Can we return size2 - size1?", "author": "DaanHoogland", "createdAt": "2020-05-08T10:32:09Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java", "diffHunk": "@@ -0,0 +1,629 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.naming.ConfigurationException;\n+\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.engine.orchestration.service.StorageOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStoreManager;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService.DataObjectResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+import org.apache.cloudstack.framework.config.Configurable;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.configuration.Config;\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.server.StatsCollector;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.ImageStoreService.MigrationPolicy;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.StorageService;\n+import com.cloud.storage.StorageStats;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.NumbersUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.StringUtils;\n+import com.cloud.utils.component.ManagerBase;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class StorageOrchestrator extends ManagerBase implements StorageOrchestrationService, Configurable {\n+\n+    private static final Logger s_logger = Logger.getLogger(StorageOrchestrator.class);\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    DataStoreManager dataStoreManager;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    StatsCollector statsCollector;\n+    @Inject\n+    public StorageService storageService;\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    ConfigurationDao configDao;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    private AsyncJobManager jobMgr;\n+    @Inject\n+    private SecondaryStorageService secStgSrv;\n+\n+    ConfigKey<Double> ImageStoreImbalanceThreshold = new ConfigKey<>(\"Advanced\", Double.class,\n+            \"image.store.imbalance.threshold\",\n+            \"0.1\",\n+            \"The storage imbalance threshold that is compared with the standard deviation percentage for a storage utilization metric. \" +\n+                    \"The value is a percentage in decimal format.\",\n+            true, ConfigKey.Scope.Global);\n+\n+    Integer numConcurrentCopyTasksPerSSVM = 2;\n+\n+    private double imageStoreCapacityThreshold = 0.90;\n+\n+    @Override\n+    public String getConfigComponentName() {\n+        return StorageOrchestrationService.class.getName();\n+    }\n+\n+    @Override\n+    public ConfigKey<?>[] getConfigKeys() {\n+        return new ConfigKey<?>[]{ImageStoreImbalanceThreshold};\n+    }\n+\n+    static class MigrateBlockingQueue<T> extends ArrayBlockingQueue<T> {\n+\n+        MigrateBlockingQueue(int size) {\n+            super(size);\n+        }\n+\n+        public boolean offer(T task) {\n+            try {\n+                this.put(task);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {\n+        numConcurrentCopyTasksPerSSVM = NumbersUtil.parseInt(configDao.getValue(Config.SecStorageMaxMigrateSessions.key()), 2);\n+        return true;\n+    }\n+\n+    @Override\n+    public MigrationResponse migrateData(Long srcDataStoreId, List<Long> destDatastores, MigrationPolicy migrationPolicy) {\n+        List<DataObject> files = new LinkedList<>();\n+        int successCount = 0;\n+        boolean success = true;\n+        String message = null;\n+\n+        if (migrationPolicy == MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+\n+        DataStore srcDatastore = dataStoreManager.getDataStore(srcDataStoreId, DataStoreRole.Image);\n+        Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains = new HashMap<>();\n+        files.addAll(getAllValidTemplates(srcDatastore));\n+        files.addAll(getAllValidSnapshotChains(srcDatastore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDatastore));\n+\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                //return o2.getSize() > o1.getSize() ? 1 : -1;\n+                return size2 > size1 ? 1 : -1;", "originalCommit": "3ba480fee5fcd8ef54b9c53662a5e8003560d0c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3ODY2Mg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r422978662", "bodyText": "done", "author": "Pearl1594", "createdAt": "2020-05-11T11:39:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2OTk1OA=="}], "type": "inlineReview", "revised_code": {"commit": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\nindex d0fe0b39e2..2ffe58f2a5 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/StorageOrchestrator.java\n\n@@ -55,6 +55,7 @@ import org.apache.cloudstack.framework.config.ConfigKey;\n import org.apache.cloudstack.framework.config.Configurable;\n import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n import org.apache.cloudstack.framework.jobs.AsyncJobManager;\n+import org.apache.cloudstack.storage.ImageStoreService.MigrationPolicy;\n import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n"}}, {"oid": "b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "url": "https://github.com/apache/cloudstack/commit/b173f788da86bb34ea4d2f177b8a5cb8fe13326f", "message": "Address review comments + make complete migration default", "committedDate": "2020-05-11T06:25:09Z", "type": "commit"}, {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd", "url": "https://github.com/apache/cloudstack/commit/452fe520fbc5ab61c965237febd02e6f75a895bd", "message": "Modularized storageOrchestrator class", "committedDate": "2020-05-18T03:44:49Z", "type": "commit"}, {"oid": "452fe520fbc5ab61c965237febd02e6f75a895bd", "url": "https://github.com/apache/cloudstack/commit/452fe520fbc5ab61c965237febd02e6f75a895bd", "message": "Modularized storageOrchestrator class", "committedDate": "2020-05-18T03:44:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1NDIzNA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426654234", "bodyText": "we wont make \"4.14.0\" ;)", "author": "DaanHoogland", "createdAt": "2020-05-18T14:09:45Z", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,115 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\nindex 6e6930c44f..233f1e8b16 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n\n@@ -37,11 +37,11 @@ import com.cloud.utils.StringUtils;\n         responseObject = MigrationResponse.class,\n         requestHasSensitiveInfo = false,\n         responseHasSensitiveInfo = false,\n-        since = \"4.14.0\",\n+        since = \"4.15.0\",\n         authorized = {RoleType.Admin})\n public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n \n-    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+    public static final Logger LOGGER = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n \n     public static final String APINAME = \"migrateSecondaryStorageData\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1NDc0NQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426654745", "bodyText": "please add since = \"4.15\"", "author": "DaanHoogland", "createdAt": "2020-05-18T14:10:29Z", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/ListImageStoresCmd.java", "diffHunk": "@@ -52,6 +51,9 @@\n     @Parameter(name = ApiConstants.ID, type = CommandType.UUID, entityType = ImageStoreResponse.class, description = \"the ID of the storage pool\")\n     private Long id;\n \n+    @Parameter(name = ApiConstants.READ_ONLY, type = CommandType.BOOLEAN, entityType = ImageStoreResponse.class, description = \"read-only status of the image store\")", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/ListImageStoresCmd.java b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/ListImageStoresCmd.java\nindex 6d11983c14..4f7cf81f20 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/ListImageStoresCmd.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/ListImageStoresCmd.java\n\n@@ -51,7 +51,7 @@ public class ListImageStoresCmd extends BaseListCmd {\n     @Parameter(name = ApiConstants.ID, type = CommandType.UUID, entityType = ImageStoreResponse.class, description = \"the ID of the storage pool\")\n     private Long id;\n \n-    @Parameter(name = ApiConstants.READ_ONLY, type = CommandType.BOOLEAN, entityType = ImageStoreResponse.class, description = \"read-only status of the image store\")\n+    @Parameter(name = ApiConstants.READ_ONLY, type = CommandType.BOOLEAN, entityType = ImageStoreResponse.class, description = \"read-only status of the image store\", since = \"4.15.0\")\n     private Boolean readonly;\n \n     /////////////////////////////////////////////////////\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1NTYyMQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426655621", "bodyText": "this naming convention is not advices for static final fields rather use LOG or LOGGER", "author": "DaanHoogland", "createdAt": "2020-05-18T14:11:40Z", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java", "diffHunk": "@@ -0,0 +1,115 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import java.util.List;\n+\n+import org.apache.cloudstack.acl.RoleType;\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.BaseAsyncCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.api.response.MigrationResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.event.EventTypes;\n+import com.cloud.utils.StringUtils;\n+\n+@APICommand(name = MigrateSecondaryStorageDataCmd.APINAME,\n+        description = \"migrates data objects from one secondary storage to destination image store(s)\",\n+        responseObject = MigrationResponse.class,\n+        requestHasSensitiveInfo = false,\n+        responseHasSensitiveInfo = false,\n+        since = \"4.14.0\",\n+        authorized = {RoleType.Admin})\n+public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n+\n+    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\nindex 6e6930c44f..233f1e8b16 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/MigrateSecondaryStorageDataCmd.java\n\n@@ -37,11 +37,11 @@ import com.cloud.utils.StringUtils;\n         responseObject = MigrationResponse.class,\n         requestHasSensitiveInfo = false,\n         responseHasSensitiveInfo = false,\n-        since = \"4.14.0\",\n+        since = \"4.15.0\",\n         authorized = {RoleType.Admin})\n public class MigrateSecondaryStorageDataCmd extends BaseAsyncCmd {\n \n-    public static final Logger s_logger = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n+    public static final Logger LOGGER = Logger.getLogger(MigrateSecondaryStorageDataCmd.class.getName());\n \n     public static final String APINAME = \"migrateSecondaryStorageData\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1Njg1MQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426656851", "bodyText": "can you add since = \"4.15\"", "author": "DaanHoogland", "createdAt": "2020-05-18T14:13:18Z", "path": "api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java", "diffHunk": "@@ -0,0 +1,89 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.api.command.admin.storage;\n+\n+import org.apache.cloudstack.api.APICommand;\n+import org.apache.cloudstack.api.ApiConstants;\n+import org.apache.cloudstack.api.ApiErrorCode;\n+import org.apache.cloudstack.api.BaseCmd;\n+import org.apache.cloudstack.api.Parameter;\n+import org.apache.cloudstack.api.ServerApiException;\n+import org.apache.cloudstack.api.response.ImageStoreResponse;\n+import org.apache.cloudstack.context.CallContext;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.storage.ImageStore;\n+\n+@APICommand(name = UpdateImageStoreCmd.APINAME, description = \"Updates image store read-only status\", responseObject = ImageStoreResponse.class, entityType = {ImageStore.class},", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1236d660205069e8c2c658fbc6c09268133db8ed", "chunk": "diff --git a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java\nindex f7ff0d245b..d7dca93b48 100644\n--- a/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java\n+++ b/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/UpdateImageStoreCmd.java\n\n@@ -30,7 +30,7 @@ import org.apache.log4j.Logger;\n import com.cloud.storage.ImageStore;\n \n @APICommand(name = UpdateImageStoreCmd.APINAME, description = \"Updates image store read-only status\", responseObject = ImageStoreResponse.class, entityType = {ImageStore.class},\n-        requestHasSensitiveInfo = false, responseHasSensitiveInfo = false)\n+        requestHasSensitiveInfo = false, responseHasSensitiveInfo = false, since = \"4.15.0\")\n public class UpdateImageStoreCmd extends BaseCmd {\n     private static final Logger LOG = Logger.getLogger(UpdateImageStoreCmd.class.getName());\n     public static final String APINAME = \"updateImageStore\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY2NDAwMw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426664003", "bodyText": "some kind of indentation problem here. The method is a bit to long for a clear view on what happened. Can you modularise it a bit more, please? Also there is more than one return points, which makes the flow hard to follow.", "author": "DaanHoogland", "createdAt": "2020-05-18T14:23:16Z", "path": "services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java", "diffHunk": "@@ -1285,6 +1288,75 @@ protected File findFile(String path) {\n         return srcFile;\n     }\n \n+    protected Answer copyFromNfsToNfs(CopyCommand cmd) {\n+        final DataTO srcData = cmd.getSrcTO();\n+        final DataTO destData = cmd.getDestTO();\n+        DataStoreTO srcDataStore = srcData.getDataStore();\n+        NfsTO srcStore = (NfsTO)srcDataStore;\n+        DataStoreTO destDataStore = destData.getDataStore();\n+        final NfsTO destStore = (NfsTO) destDataStore;\n+        try {\n+            File srcFile = new File(getDir(srcStore.getUrl(), _nfsVersion), srcData.getPath());\n+            File destFile = new File(getDir(destStore.getUrl(), _nfsVersion), destData.getPath());\n+            ImageFormat format = getTemplateFormat(srcFile.getName());\n+\n+            if (srcFile == null) {\n+                return new CopyCmdAnswer(\"Can't find src file:\" + srcFile);\n+            }\n+\n+            if (srcData instanceof TemplateObjectTO || srcData instanceof VolumeObjectTO) {\n+                File srcDir = null;\n+                if (srcFile.isFile()) {\n+                    srcDir = new File(srcFile.getParent());\n+                }\n+                File destDir = null;\n+                if (destFile.isFile()) {\n+                    destDir = new File(destFile.getParent());\n+                }\n+\n+                try {\n+                    FileUtils.copyDirectory((srcDir == null ? srcFile : srcDir), (destDir == null? destFile : destDir));\n+                } catch (IOException e) {\n+                    String msg = \"Failed to copy file to destination\";\n+                    s_logger.info(msg);\n+                    return new CopyCmdAnswer(msg);\n+                }\n+            } else {\n+                destFile = new File(destFile, srcFile.getName());\n+                try {\n+                    FileUtils.copyFile(srcFile, destFile);\n+                } catch (IOException e) {\n+                    String msg = \"Failed to copy file to destination\";\n+                    s_logger.info(msg);\n+                    return new CopyCmdAnswer(msg);\n+                }\n+            }\n+\n+            DataTO retObj = null;\n+            if (destData.getObjectType() == DataObjectType.TEMPLATE) {\n+                TemplateObjectTO newTemplate = new TemplateObjectTO();\n+                newTemplate.setPath(destData.getPath() + File.separator + srcFile.getName());\n+                newTemplate.setSize(getVirtualSize(srcFile, format));\n+                newTemplate.setPhysicalSize(srcFile.length());\n+                newTemplate.setFormat(format);\n+                retObj = newTemplate;\n+            } else if (destData.getObjectType() == DataObjectType.VOLUME) {\n+                VolumeObjectTO newVol = new VolumeObjectTO();\n+                newVol.setPath(destData.getPath() + File.separator + srcFile.getName());\n+                newVol.setSize(srcFile.length());\n+                retObj = newVol;\n+            } else if (destData.getObjectType() == DataObjectType.SNAPSHOT) {\n+                SnapshotObjectTO newSnapshot = new SnapshotObjectTO();\n+                newSnapshot.setPath(destData.getPath() + File.separator + destFile.getName());\n+                retObj = newSnapshot;\n+            }\n+            return new CopyCmdAnswer(retObj);\n+            } catch (Exception e) {\n+            s_logger.error(\"failed to copy file\" + srcData.getPath(), e);\n+            return new CopyCmdAnswer(\"failed to copy file\" + srcData.getPath() + e.toString());", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java b/services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java\nindex e00b7a0896..27628a09eb 100644\n--- a/services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java\n+++ b/services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java\n\n@@ -1352,8 +1352,8 @@ public class NfsSecondaryStorageResource extends ServerResourceBase implements S\n             }\n             return new CopyCmdAnswer(retObj);\n             } catch (Exception e) {\n-            s_logger.error(\"failed to copy file\" + srcData.getPath(), e);\n-            return new CopyCmdAnswer(\"failed to copy file\" + srcData.getPath() + e.toString());\n+                s_logger.error(\"failed to copy file\" + srcData.getPath(), e);\n+                return new CopyCmdAnswer(\"failed to copy file\" + srcData.getPath() + e.toString());\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY2NjExMw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426666113", "bodyText": "please factor out in a suitably named method.", "author": "DaanHoogland", "createdAt": "2020-05-18T14:26:18Z", "path": "services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java", "diffHunk": "@@ -135,13 +152,43 @@ public boolean configure(String name, Map<String, Object> params) throws Configu\n             }\n \n             alreadyRunning = _secStorageVmDao.getSecStorageVmListInStates(null, dataCenterId, State.Running, State.Migrating, State.Starting);\n-\n             List<CommandExecLogVO> activeCmds = findActiveCommands(dataCenterId, cutTime);\n+            // Find running copy / migrate commands running arranged in ascending order of their creation time i.e., oldest first\n+            List<CommandExecLogVO> copyCmdsInPipeline = findAllActiveCopyCommands(dataCenterId, cutTime);\n+            // Count of total hosts\n+            Integer hostsCount = _hostDao.countAllByType(Host.Type.Routing);\n+            // Maximum number of allowed SSVMs for migration task\n+            Integer maxSsvms = (hostsCount < MaxNumberOfSsvmsForMigration.value()) ? hostsCount : MaxNumberOfSsvmsForMigration.value();\n+            int halfLimit = Math.round((float) (alreadyRunning.size() * migrateCapPerSSVM) / 2);\n+            currentTime = DateUtil.currentGMTTime().getTime();\n+", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java b/services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java\nindex bb17d18057..ec8d4792eb 100644\n--- a/services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java\n+++ b/services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java\n\n@@ -151,49 +152,55 @@ public class PremiumSecondaryStorageManagerImpl extends SecondaryStorageManagerI\n                 return new Pair<AfterScanAction, Object>(AfterScanAction.nop, null);\n             }\n \n+\n             alreadyRunning = _secStorageVmDao.getSecStorageVmListInStates(null, dataCenterId, State.Running, State.Migrating, State.Starting);\n             List<CommandExecLogVO> activeCmds = findActiveCommands(dataCenterId, cutTime);\n-            // Find running copy / migrate commands running arranged in ascending order of their creation time i.e., oldest first\n             List<CommandExecLogVO> copyCmdsInPipeline = findAllActiveCopyCommands(dataCenterId, cutTime);\n-            // Count of total hosts\n-            Integer hostsCount = _hostDao.countAllByType(Host.Type.Routing);\n-            // Maximum number of allowed SSVMs for migration task\n-            Integer maxSsvms = (hostsCount < MaxNumberOfSsvmsForMigration.value()) ? hostsCount : MaxNumberOfSsvmsForMigration.value();\n-            int halfLimit = Math.round((float) (alreadyRunning.size() * migrateCapPerSSVM) / 2);\n-            currentTime = DateUtil.currentGMTTime().getTime();\n-\n-            if (alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() < _standbyCapacity) {\n-                s_logger.info(\"secondary storage command execution standby capactiy low (running VMs: \" + alreadyRunning.size() + \", active cmds: \" + activeCmds.size() +\n-                        \"), starting a new one\");\n-                return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.commandExecutor);\n-            }\n-            // Scale the number of SSVMs if the number of Copy operations is greater than the number of SSVMs running and the copy operation has been in pipeline for\n-            // more than half of the total time allocated for secondary storage operation\n-            else if (!copyCmdsInPipeline.isEmpty()  && copyCmdsInPipeline.size() >= halfLimit &&\n-                    (((currentTime - copyCmdsInPipeline.get(halfLimit - 1).getCreated().getTime()) > _maxExecutionTimeMs/2 )) &&\n-                            (currentTime > nextSpawnTime) &&  alreadyRunning.size() <=  maxSsvms) {\n-                    nextSpawnTime = currentTime + _maxExecutionTimeMs/2;\n-                    s_logger.debug(\"scaling SSVM to handle migration tasks\");\n-                    return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.templateProcessor);\n-                }\n+            return scaleSSVMOnLoad(alreadyRunning, activeCmds, copyCmdsInPipeline);\n \n-            // Scale down the number of SSVMs if the load on them has reduced\n-            if ((copyCmdsInPipeline.size() < halfLimit && alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() > _standbyCapacity) && alreadyRunning.size() > 1) {\n-                Collections.reverse(alreadyRunning);\n-                for(SecondaryStorageVmVO vm : alreadyRunning) {\n-                    long count = copyCmdsInPipeline.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n-                    count += activeCmds.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n-                    if (count == 0) {\n-                        destroySecStorageVm(vm.getId());\n-                        break;\n-                    }\n-                }\n-            }\n         }\n+        return new Pair<AfterScanAction, Object>(AfterScanAction.nop, null);\n+    }\n \n+    private Pair<AfterScanAction, Object> scaleSSVMOnLoad(List<SecondaryStorageVmVO> alreadyRunning, List<CommandExecLogVO> activeCmds,\n+                                                    List<CommandExecLogVO> copyCmdsInPipeline) {\n+        Integer hostsCount = _hostDao.countAllByType(Host.Type.Routing);\n+        Integer maxSsvms = (hostsCount < MaxNumberOfSsvmsForMigration.value()) ? hostsCount : MaxNumberOfSsvmsForMigration.value();\n+        int halfLimit = Math.round((float) (alreadyRunning.size() * migrateCapPerSSVM) / 2);\n+        currentTime = DateUtil.currentGMTTime().getTime();\n+        if (alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() < _standbyCapacity) {\n+            s_logger.info(\"secondary storage command execution standby capactiy low (running VMs: \" + alreadyRunning.size() + \", active cmds: \" + activeCmds.size() +\n+                    \"), starting a new one\");\n+            return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.commandExecutor);\n+        }\n+        else if (!copyCmdsInPipeline.isEmpty()  && copyCmdsInPipeline.size() >= halfLimit &&\n+                ((Math.abs(currentTime - copyCmdsInPipeline.get(halfLimit - 1).getCreated().getTime()) > _maxExecutionTimeMs/2 )) &&\n+                (currentTime > nextSpawnTime) &&  alreadyRunning.size() <=  maxSsvms) {\n+            nextSpawnTime = currentTime + _maxExecutionTimeMs/2;\n+            s_logger.debug(\"scaling SSVM to handle migration tasks\");\n+            return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.templateProcessor);\n+\n+        }\n+        scaleDownSSVMOnLoad(alreadyRunning, activeCmds, copyCmdsInPipeline);\n         return new Pair<AfterScanAction, Object>(AfterScanAction.nop, null);\n     }\n \n+    private void scaleDownSSVMOnLoad(List<SecondaryStorageVmVO> alreadyRunning, List<CommandExecLogVO> activeCmds,\n+                               List<CommandExecLogVO> copyCmdsInPipeline)  {\n+        int halfLimit = Math.round((float) (alreadyRunning.size() * migrateCapPerSSVM) / 2);\n+        if ((copyCmdsInPipeline.size() < halfLimit && alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() > _standbyCapacity) && alreadyRunning.size() > 1) {\n+            Collections.reverse(alreadyRunning);\n+            for(SecondaryStorageVmVO vm : alreadyRunning) {\n+                long count = copyCmdsInPipeline.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n+                count += activeCmds.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n+                if (count == 0) {\n+                    destroySecStorageVm(vm.getId());\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n     @Override\n     public Pair<HostVO, SecondaryStorageVmVO> assignSecStorageVm(long zoneId, Command cmd) {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY2NzA5Mg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426667092", "bodyText": "please factor this out in suitably called methods. This method was already too long to begin with, but let's not add to the lack of maintainability.", "author": "DaanHoogland", "createdAt": "2020-05-18T14:27:37Z", "path": "services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java", "diffHunk": "@@ -135,13 +152,43 @@ public boolean configure(String name, Map<String, Object> params) throws Configu\n             }\n \n             alreadyRunning = _secStorageVmDao.getSecStorageVmListInStates(null, dataCenterId, State.Running, State.Migrating, State.Starting);\n-\n             List<CommandExecLogVO> activeCmds = findActiveCommands(dataCenterId, cutTime);\n+            // Find running copy / migrate commands running arranged in ascending order of their creation time i.e., oldest first\n+            List<CommandExecLogVO> copyCmdsInPipeline = findAllActiveCopyCommands(dataCenterId, cutTime);\n+            // Count of total hosts\n+            Integer hostsCount = _hostDao.countAllByType(Host.Type.Routing);\n+            // Maximum number of allowed SSVMs for migration task\n+            Integer maxSsvms = (hostsCount < MaxNumberOfSsvmsForMigration.value()) ? hostsCount : MaxNumberOfSsvmsForMigration.value();\n+            int halfLimit = Math.round((float) (alreadyRunning.size() * migrateCapPerSSVM) / 2);\n+            currentTime = DateUtil.currentGMTTime().getTime();\n+\n             if (alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() < _standbyCapacity) {\n                 s_logger.info(\"secondary storage command execution standby capactiy low (running VMs: \" + alreadyRunning.size() + \", active cmds: \" + activeCmds.size() +\n                         \"), starting a new one\");\n                 return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.commandExecutor);\n             }\n+            // Scale the number of SSVMs if the number of Copy operations is greater than the number of SSVMs running and the copy operation has been in pipeline for\n+            // more than half of the total time allocated for secondary storage operation\n+            else if (!copyCmdsInPipeline.isEmpty()  && copyCmdsInPipeline.size() >= halfLimit &&\n+                    (((currentTime - copyCmdsInPipeline.get(halfLimit - 1).getCreated().getTime()) > _maxExecutionTimeMs/2 )) &&\n+                            (currentTime > nextSpawnTime) &&  alreadyRunning.size() <=  maxSsvms) {\n+                    nextSpawnTime = currentTime + _maxExecutionTimeMs/2;\n+                    s_logger.debug(\"scaling SSVM to handle migration tasks\");\n+                    return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.templateProcessor);\n+                }\n+\n+            // Scale down the number of SSVMs if the load on them has reduced\n+            if ((copyCmdsInPipeline.size() < halfLimit && alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() > _standbyCapacity) && alreadyRunning.size() > 1) {\n+                Collections.reverse(alreadyRunning);\n+                for(SecondaryStorageVmVO vm : alreadyRunning) {\n+                    long count = copyCmdsInPipeline.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n+                    count += activeCmds.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n+                    if (count == 0) {\n+                        destroySecStorageVm(vm.getId());\n+                        break;\n+                    }\n+                }\n+            }", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java b/services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java\nindex bb17d18057..ec8d4792eb 100644\n--- a/services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java\n+++ b/services/secondary-storage/controller/src/main/java/org/apache/cloudstack/secondarystorage/PremiumSecondaryStorageManagerImpl.java\n\n@@ -151,49 +152,55 @@ public class PremiumSecondaryStorageManagerImpl extends SecondaryStorageManagerI\n                 return new Pair<AfterScanAction, Object>(AfterScanAction.nop, null);\n             }\n \n+\n             alreadyRunning = _secStorageVmDao.getSecStorageVmListInStates(null, dataCenterId, State.Running, State.Migrating, State.Starting);\n             List<CommandExecLogVO> activeCmds = findActiveCommands(dataCenterId, cutTime);\n-            // Find running copy / migrate commands running arranged in ascending order of their creation time i.e., oldest first\n             List<CommandExecLogVO> copyCmdsInPipeline = findAllActiveCopyCommands(dataCenterId, cutTime);\n-            // Count of total hosts\n-            Integer hostsCount = _hostDao.countAllByType(Host.Type.Routing);\n-            // Maximum number of allowed SSVMs for migration task\n-            Integer maxSsvms = (hostsCount < MaxNumberOfSsvmsForMigration.value()) ? hostsCount : MaxNumberOfSsvmsForMigration.value();\n-            int halfLimit = Math.round((float) (alreadyRunning.size() * migrateCapPerSSVM) / 2);\n-            currentTime = DateUtil.currentGMTTime().getTime();\n-\n-            if (alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() < _standbyCapacity) {\n-                s_logger.info(\"secondary storage command execution standby capactiy low (running VMs: \" + alreadyRunning.size() + \", active cmds: \" + activeCmds.size() +\n-                        \"), starting a new one\");\n-                return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.commandExecutor);\n-            }\n-            // Scale the number of SSVMs if the number of Copy operations is greater than the number of SSVMs running and the copy operation has been in pipeline for\n-            // more than half of the total time allocated for secondary storage operation\n-            else if (!copyCmdsInPipeline.isEmpty()  && copyCmdsInPipeline.size() >= halfLimit &&\n-                    (((currentTime - copyCmdsInPipeline.get(halfLimit - 1).getCreated().getTime()) > _maxExecutionTimeMs/2 )) &&\n-                            (currentTime > nextSpawnTime) &&  alreadyRunning.size() <=  maxSsvms) {\n-                    nextSpawnTime = currentTime + _maxExecutionTimeMs/2;\n-                    s_logger.debug(\"scaling SSVM to handle migration tasks\");\n-                    return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.templateProcessor);\n-                }\n+            return scaleSSVMOnLoad(alreadyRunning, activeCmds, copyCmdsInPipeline);\n \n-            // Scale down the number of SSVMs if the load on them has reduced\n-            if ((copyCmdsInPipeline.size() < halfLimit && alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() > _standbyCapacity) && alreadyRunning.size() > 1) {\n-                Collections.reverse(alreadyRunning);\n-                for(SecondaryStorageVmVO vm : alreadyRunning) {\n-                    long count = copyCmdsInPipeline.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n-                    count += activeCmds.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n-                    if (count == 0) {\n-                        destroySecStorageVm(vm.getId());\n-                        break;\n-                    }\n-                }\n-            }\n         }\n+        return new Pair<AfterScanAction, Object>(AfterScanAction.nop, null);\n+    }\n \n+    private Pair<AfterScanAction, Object> scaleSSVMOnLoad(List<SecondaryStorageVmVO> alreadyRunning, List<CommandExecLogVO> activeCmds,\n+                                                    List<CommandExecLogVO> copyCmdsInPipeline) {\n+        Integer hostsCount = _hostDao.countAllByType(Host.Type.Routing);\n+        Integer maxSsvms = (hostsCount < MaxNumberOfSsvmsForMigration.value()) ? hostsCount : MaxNumberOfSsvmsForMigration.value();\n+        int halfLimit = Math.round((float) (alreadyRunning.size() * migrateCapPerSSVM) / 2);\n+        currentTime = DateUtil.currentGMTTime().getTime();\n+        if (alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() < _standbyCapacity) {\n+            s_logger.info(\"secondary storage command execution standby capactiy low (running VMs: \" + alreadyRunning.size() + \", active cmds: \" + activeCmds.size() +\n+                    \"), starting a new one\");\n+            return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.commandExecutor);\n+        }\n+        else if (!copyCmdsInPipeline.isEmpty()  && copyCmdsInPipeline.size() >= halfLimit &&\n+                ((Math.abs(currentTime - copyCmdsInPipeline.get(halfLimit - 1).getCreated().getTime()) > _maxExecutionTimeMs/2 )) &&\n+                (currentTime > nextSpawnTime) &&  alreadyRunning.size() <=  maxSsvms) {\n+            nextSpawnTime = currentTime + _maxExecutionTimeMs/2;\n+            s_logger.debug(\"scaling SSVM to handle migration tasks\");\n+            return new Pair<AfterScanAction, Object>(AfterScanAction.expand, SecondaryStorageVm.Role.templateProcessor);\n+\n+        }\n+        scaleDownSSVMOnLoad(alreadyRunning, activeCmds, copyCmdsInPipeline);\n         return new Pair<AfterScanAction, Object>(AfterScanAction.nop, null);\n     }\n \n+    private void scaleDownSSVMOnLoad(List<SecondaryStorageVmVO> alreadyRunning, List<CommandExecLogVO> activeCmds,\n+                               List<CommandExecLogVO> copyCmdsInPipeline)  {\n+        int halfLimit = Math.round((float) (alreadyRunning.size() * migrateCapPerSSVM) / 2);\n+        if ((copyCmdsInPipeline.size() < halfLimit && alreadyRunning.size() * _capacityPerSSVM - activeCmds.size() > _standbyCapacity) && alreadyRunning.size() > 1) {\n+            Collections.reverse(alreadyRunning);\n+            for(SecondaryStorageVmVO vm : alreadyRunning) {\n+                long count = copyCmdsInPipeline.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n+                count += activeCmds.stream().map(cmd -> cmd.getInstanceId() == vm.getId()).count();\n+                if (count == 0) {\n+                    destroySecStorageVm(vm.getId());\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n     @Override\n     public Pair<HostVO, SecondaryStorageVmVO> assignSecStorageVm(long zoneId, Command cmd) {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY2OTY1MQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426669651", "bodyText": "is this being overridden by a global setting somewhere, or a hard-coded restiction", "author": "DaanHoogland", "createdAt": "2020-05-18T14:31:06Z", "path": "server/src/main/java/com/cloud/storage/secondary/SecondaryStorageVmManager.java", "diffHunk": "@@ -31,6 +32,7 @@\n     public static final int DEFAULT_SS_VM_CPUMHZ = 500;             // 500 MHz\n     public static final int DEFAULT_SS_VM_MTUSIZE = 1500;\n     public static final int DEFAULT_SS_VM_CAPACITY = 50;            // max command execution session per SSVM\n+    public static final int DEFAULT_MIGRATE_SS_VM_CAPACITY = 2;     // number of concurrent migrate operations to happen per SSVM", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyNzUwNg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426727506", "bodyText": "It is overridden elsewhere", "author": "Pearl1594", "createdAt": "2020-05-18T15:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY2OTY1MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MTIyNw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426671227", "bodyText": "I really like this style but in spite of it looking neater, the removal of the line is a potential conflict before we get a chance to merge. Better have those kind of changes is isolated contributions.", "author": "DaanHoogland", "createdAt": "2020-05-18T14:33:20Z", "path": "server/src/main/java/com/cloud/storage/ImageStoreDetailsUtil.java", "diffHunk": "@@ -30,7 +30,6 @@\n import com.google.common.base.Preconditions;\n \n public class ImageStoreDetailsUtil {\n-", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/server/src/main/java/com/cloud/storage/ImageStoreDetailsUtil.java b/server/src/main/java/com/cloud/storage/ImageStoreDetailsUtil.java\nindex 4ed7962db9..3e27ce6ab4 100755\n--- a/server/src/main/java/com/cloud/storage/ImageStoreDetailsUtil.java\n+++ b/server/src/main/java/com/cloud/storage/ImageStoreDetailsUtil.java\n\n@@ -30,6 +30,7 @@ import com.cloud.capacity.CapacityManager;\n import com.google.common.base.Preconditions;\n \n public class ImageStoreDetailsUtil {\n+\n     @Inject\n     protected ImageStoreDao imageStoreDao;\n     @Inject\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MjUxMA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426672510", "bodyText": "adding keys here is an obsoleted way of creating Configuration details. please use a Configkey<String>", "author": "DaanHoogland", "createdAt": "2020-05-18T14:35:15Z", "path": "server/src/main/java/com/cloud/configuration/Config.java", "diffHunk": "@@ -904,6 +905,14 @@\n             \"random\",\n             \"'random', 'firstfit', 'userdispersing', 'userconcentratedpod_random', 'userconcentratedpod_firstfit', 'firstfitleastconsumed' : Order in which hosts within a cluster will be considered for VM/volume allocation.\",\n             null),\n+    ImageStoreAllocationAlgorithm(", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/server/src/main/java/com/cloud/configuration/Config.java b/server/src/main/java/com/cloud/configuration/Config.java\nindex 769ff505ae..c72eb498b1 100644\n--- a/server/src/main/java/com/cloud/configuration/Config.java\n+++ b/server/src/main/java/com/cloud/configuration/Config.java\n\n@@ -905,14 +905,6 @@ public enum Config {\n             \"random\",\n             \"'random', 'firstfit', 'userdispersing', 'userconcentratedpod_random', 'userconcentratedpod_firstfit', 'firstfitleastconsumed' : Order in which hosts within a cluster will be considered for VM/volume allocation.\",\n             null),\n-    ImageStoreAllocationAlgorithm(\n-            \"Advanced\",\n-            ManagementServer.class,\n-            String.class,\n-            \"image.store.allocation.algorithm\",\n-            \"firstfitleastconsumed\",\n-            \"firstfitleastconsumed','random' : Order in which hosts within a cluster will be considered for VM/volume allocation.\",\n-            null),\n     VmDeploymentPlanner(\n             \"Advanced\",\n             ManagementServer.class,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3Mjk1NQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426672955", "bodyText": "please use ConfigKey<>s", "author": "DaanHoogland", "createdAt": "2020-05-18T14:35:53Z", "path": "server/src/main/java/com/cloud/configuration/Config.java", "diffHunk": "@@ -1808,7 +1817,10 @@\n     // StatsCollector\n     StatsOutPutGraphiteHost(\"Advanced\", ManagementServer.class, String.class, \"stats.output.uri\", \"\", \"URI to additionally send StatsCollector statistics to\", null),\n \n-    SSVMPSK(\"Hidden\", ManagementServer.class, String.class, \"upload.post.secret.key\", \"\", \"PSK with SSVM\", null);\n+    SSVMPSK(\"Hidden\", ManagementServer.class, String.class, \"upload.post.secret.key\", \"\", \"PSK with SSVM\", null),\n+\n+    SecStorageMaxMigrateSessions(\n+            \"Advanced\", AgentManager.class, Integer.class, \"secstorage.max.migrate.sessions\",\"2\",\"The max number of concurrent copy command execution sessions that an SSVM can handle\",null);", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/server/src/main/java/com/cloud/configuration/Config.java b/server/src/main/java/com/cloud/configuration/Config.java\nindex 769ff505ae..c72eb498b1 100644\n--- a/server/src/main/java/com/cloud/configuration/Config.java\n+++ b/server/src/main/java/com/cloud/configuration/Config.java\n\n@@ -1817,10 +1809,7 @@ public enum Config {\n     // StatsCollector\n     StatsOutPutGraphiteHost(\"Advanced\", ManagementServer.class, String.class, \"stats.output.uri\", \"\", \"URI to additionally send StatsCollector statistics to\", null),\n \n-    SSVMPSK(\"Hidden\", ManagementServer.class, String.class, \"upload.post.secret.key\", \"\", \"PSK with SSVM\", null),\n-\n-    SecStorageMaxMigrateSessions(\n-            \"Advanced\", AgentManager.class, Integer.class, \"secstorage.max.migrate.sessions\",\"2\",\"The max number of concurrent copy command execution sessions that an SSVM can handle\",null);\n+    SSVMPSK(\"Hidden\", ManagementServer.class, String.class, \"upload.post.secret.key\", \"\", \"PSK with SSVM\", null);\n \n     private final String _category;\n     private final Class<?> _componentClass;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3NDQ0NA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426674444", "bodyText": "this file is not changed. better remove the diff from the PR", "author": "DaanHoogland", "createdAt": "2020-05-18T14:37:56Z", "path": "server/src/main/java/com/cloud/api/query/ViewResponseHelper.java", "diffHunk": "@@ -84,8 +82,10 @@\n import com.cloud.api.query.vo.UserAccountJoinVO;\n import com.cloud.api.query.vo.UserVmJoinVO;\n import com.cloud.api.query.vo.VolumeJoinVO;\n-import com.cloud.storage.StoragePoolTagVO;\n+import com.cloud.configuration.Resource;\n+import com.cloud.domain.Domain;\n import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.StoragePoolTagVO;\n import com.cloud.storage.VolumeStats;", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3NjM0NQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426676345", "bodyText": "please do not keep comment incode. We have an RCS for keeping save old code.", "author": "DaanHoogland", "createdAt": "2020-05-18T14:40:42Z", "path": "engine/storage/volume/src/main/java/org/apache/cloudstack/storage/volume/VolumeObject.java", "diffHunk": "@@ -392,7 +391,8 @@ public void processEvent(ObjectInDataStoreStateMachine.Event event) {\n                 if (event == ObjectInDataStoreStateMachine.Event.CreateOnlyRequested) {\n                     volEvent = Volume.Event.UploadRequested;\n                 } else if (event == ObjectInDataStoreStateMachine.Event.MigrationRequested) {\n-                    volEvent = Volume.Event.CopyRequested;\n+                    //volEvent = Volume.Event.CopyRequested;", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/storage/volume/src/main/java/org/apache/cloudstack/storage/volume/VolumeObject.java b/engine/storage/volume/src/main/java/org/apache/cloudstack/storage/volume/VolumeObject.java\nindex 6494739204..2bb643bd65 100644\n--- a/engine/storage/volume/src/main/java/org/apache/cloudstack/storage/volume/VolumeObject.java\n+++ b/engine/storage/volume/src/main/java/org/apache/cloudstack/storage/volume/VolumeObject.java\n\n@@ -391,7 +391,6 @@ public class VolumeObject implements VolumeInfo {\n                 if (event == ObjectInDataStoreStateMachine.Event.CreateOnlyRequested) {\n                     volEvent = Volume.Event.UploadRequested;\n                 } else if (event == ObjectInDataStoreStateMachine.Event.MigrationRequested) {\n-                    //volEvent = Volume.Event.CopyRequested;\n                     volEvent = Volume.Event.MigrationRequested;\n                 }\n             } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3ODI0MQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426678241", "bodyText": "Event.OperationSuccessed? or should this be Event.OperationSucceeded?", "author": "DaanHoogland", "createdAt": "2020-05-18T14:43:27Z", "path": "engine/storage/src/main/java/org/apache/cloudstack/storage/datastore/ObjectInDataStoreManagerImpl.java", "diffHunk": "@@ -104,6 +104,14 @@ public ObjectInDataStoreManagerImpl() {\n         // TODO: further investigate why an extra event is sent when it is\n         // alreay Ready for DownloadListener\n         stateMachines.addTransition(State.Ready, Event.OperationSuccessed, State.Ready);\n+        // State transitions for data object migration\n+        stateMachines.addTransition(State.Ready, Event.MigrationRequested, State.Migrating);\n+        stateMachines.addTransition(State.Ready, Event.CopyRequested, State.Copying);\n+        stateMachines.addTransition(State.Allocated, Event.MigrationRequested, State.Migrating);\n+        stateMachines.addTransition(State.Migrating, Event.MigrationFailed, State.Failed);\n+        stateMachines.addTransition(State.Migrating, Event.MigrationSucceeded, State.Destroyed);\n+        stateMachines.addTransition(State.Migrating, Event.OperationSuccessed, State.Ready);", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0NDA1Mg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426744052", "bodyText": "I've reused what existed before", "author": "Pearl1594", "createdAt": "2020-05-18T16:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3ODI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgwNDkwMg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427804902", "bodyText": "yes I saw, maybe separate small issue, thanks", "author": "DaanHoogland", "createdAt": "2020-05-20T07:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3ODI0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "490c235bcbbd8f1a07979bb0219205f795177e5f", "chunk": "diff --git a/engine/storage/src/main/java/org/apache/cloudstack/storage/datastore/ObjectInDataStoreManagerImpl.java b/engine/storage/src/main/java/org/apache/cloudstack/storage/datastore/ObjectInDataStoreManagerImpl.java\nindex 2a12feb5c5..ff8112ccef 100644\n--- a/engine/storage/src/main/java/org/apache/cloudstack/storage/datastore/ObjectInDataStoreManagerImpl.java\n+++ b/engine/storage/src/main/java/org/apache/cloudstack/storage/datastore/ObjectInDataStoreManagerImpl.java\n\n@@ -105,9 +105,9 @@ public class ObjectInDataStoreManagerImpl implements ObjectInDataStoreManager {\n         // alreay Ready for DownloadListener\n         stateMachines.addTransition(State.Ready, Event.OperationSuccessed, State.Ready);\n         // State transitions for data object migration\n-        stateMachines.addTransition(State.Ready, Event.MigrationRequested, State.Migrating);\n+        stateMachines.addTransition(State.Ready, Event.MigrateDataRequested, State.Migrating);\n         stateMachines.addTransition(State.Ready, Event.CopyRequested, State.Copying);\n-        stateMachines.addTransition(State.Allocated, Event.MigrationRequested, State.Migrating);\n+        stateMachines.addTransition(State.Allocated, Event.MigrateDataRequested, State.Migrating);\n         stateMachines.addTransition(State.Migrating, Event.MigrationFailed, State.Failed);\n         stateMachines.addTransition(State.Migrating, Event.MigrationSucceeded, State.Destroyed);\n         stateMachines.addTransition(State.Migrating, Event.OperationSuccessed, State.Ready);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3OTk3Nw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426679977", "bodyText": "please remove commented code", "author": "DaanHoogland", "createdAt": "2020-05-18T14:45:53Z", "path": "engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/TemplateServiceImpl.java", "diffHunk": "@@ -253,7 +253,8 @@ public void downloadBootstrapSysTemplate(DataStore store) {\n     @Override\n     public void handleSysTemplateDownload(HypervisorType hostHyper, Long dcId) {\n         Set<VMTemplateVO> toBeDownloaded = new HashSet<VMTemplateVO>();\n-        List<DataStore> stores = _storeMgr.getImageStoresByScope(new ZoneScope(dcId));\n+        //List<DataStore> stores = _storeMgr.getImageStoresByScope(new ZoneScope(dcId));", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/TemplateServiceImpl.java b/engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/TemplateServiceImpl.java\nindex 57148613ba..01ff126383 100644\n--- a/engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/TemplateServiceImpl.java\n+++ b/engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/TemplateServiceImpl.java\n\n@@ -253,7 +253,6 @@ public class TemplateServiceImpl implements TemplateService {\n     @Override\n     public void handleSysTemplateDownload(HypervisorType hostHyper, Long dcId) {\n         Set<VMTemplateVO> toBeDownloaded = new HashSet<VMTemplateVO>();\n-        //List<DataStore> stores = _storeMgr.getImageStoresByScope(new ZoneScope(dcId));\n         List<DataStore> stores = _storeMgr.getImageStoresByScopeExcludingReadOnly(new ZoneScope(dcId));\n         if (stores == null || stores.isEmpty()) {\n             return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4MTkxNA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426681914", "bodyText": "Are you sure this is the best naming convention here? a StorageService sounds like more basic than a SecondaryStorageService. Is it inteded to implement more Interfaces in the future?", "author": "DaanHoogland", "createdAt": "2020-05-18T14:48:30Z", "path": "engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/StorageServiceImpl.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.storage.image;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.CopyCommandResult;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataMotionService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SecondaryStorageService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateInfo;\n+import org.apache.cloudstack.framework.async.AsyncCallFuture;\n+import org.apache.cloudstack.framework.async.AsyncCallbackDispatcher;\n+import org.apache.cloudstack.framework.async.AsyncCompletionCallback;\n+import org.apache.cloudstack.framework.async.AsyncRpcContext;\n+import org.apache.cloudstack.storage.command.CopyCmdAnswer;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.secstorage.CommandExecLogDao;\n+import com.cloud.utils.Pair;\n+\n+public class StorageServiceImpl implements SecondaryStorageService {", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/StorageServiceImpl.java b/engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/StorageServiceImpl.java\nindex 553223d3c2..e7aee8ec51 100644\n--- a/engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/StorageServiceImpl.java\n+++ b/engine/storage/image/src/main/java/org/apache/cloudstack/storage/image/StorageServiceImpl.java\n\n@@ -36,11 +36,14 @@ import org.apache.cloudstack.framework.async.AsyncCallbackDispatcher;\n import org.apache.cloudstack.framework.async.AsyncCompletionCallback;\n import org.apache.cloudstack.framework.async.AsyncRpcContext;\n import org.apache.cloudstack.storage.command.CopyCmdAnswer;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n import org.apache.log4j.Logger;\n \n import com.cloud.secstorage.CommandExecLogDao;\n+import com.cloud.storage.DataStoreRole;\n import com.cloud.utils.Pair;\n \n public class StorageServiceImpl implements SecondaryStorageService {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4NDUzNw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426684537", "bodyText": "Can you call this static final something all-caps, please?", "author": "DaanHoogland", "createdAt": "2020-05-18T14:52:08Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\nindex fe5d15606e..d768734186 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n\n@@ -43,7 +43,6 @@ import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n-import org.apache.log4j.Logger;\n \n import com.cloud.host.HostVO;\n import com.cloud.host.Status;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4NTk0MA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426685940", "bodyText": "So, if there is any file in any other state, the migration is not ready, is it?", "author": "DaanHoogland", "createdAt": "2020-05-18T14:54:03Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwMDc3NQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427100775", "bodyText": "If files are in copying, migrating or creating states - complete migration will not happen", "author": "Pearl1594", "createdAt": "2020-05-19T07:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4NTk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI1NzAzOQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427257039", "bodyText": "worth mentioning that here as well. also validstates contains more : {\"Ready\", \"Allocated\", \"Destroying\", \"Destroyed\", \"Failed\"}. seems worth noting in the comment.", "author": "DaanHoogland", "createdAt": "2020-05-19T12:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4NTk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\nindex fe5d15606e..d768734186 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n\n@@ -43,7 +43,6 @@ import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n-import org.apache.log4j.Logger;\n \n import com.cloud.host.HostVO;\n import com.cloud.host.Status;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4Njc1Mw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426686753", "bodyText": "filesReady in this case means \"files ready to migrate\" does it? if so can we rename it that please?", "author": "DaanHoogland", "createdAt": "2020-05-18T14:55:07Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\nindex fe5d15606e..d768734186 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n\n@@ -43,7 +43,6 @@ import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n-import org.apache.log4j.Logger;\n \n import com.cloud.host.HostVO;\n import com.cloud.host.Status;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4ODY5Ng==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426688696", "bodyText": "no 0 possible for equal?", "author": "DaanHoogland", "createdAt": "2020-05-18T14:57:35Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwMTIxOA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427101218", "bodyText": "They get sorted properly even on ignoring the equality case", "author": "Pearl1594", "createdAt": "2020-05-19T07:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4ODY5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\nindex fe5d15606e..d768734186 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n\n@@ -43,7 +43,6 @@ import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n-import org.apache.log4j.Logger;\n \n import com.cloud.host.HostVO;\n import com.cloud.host.Status;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MDk1NQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426690955", "bodyText": "I know I asked for this (or such), but overflow is possible if the diff is huge.\nIn relation to the comment to the coomparable above, Is 0 useful? Might we want to reuse this in cases where it is?", "author": "DaanHoogland", "createdAt": "2020-05-18T15:00:37Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\nindex fe5d15606e..d768734186 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n\n@@ -43,7 +43,6 @@ import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n-import org.apache.log4j.Logger;\n \n import com.cloud.host.HostVO;\n import com.cloud.host.Status;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MjM4Mw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426692383", "bodyText": "not a useful comment given the clear method name. extend the method name to be even more clear? make this a javadoc? remove?", "author": "DaanHoogland", "createdAt": "2020-05-18T15:02:35Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);\n+            }\n+        });\n+        return files;\n+    }\n+\n+    // Gets list of all valid templates, i.e, templates in \"Ready\" state for migration", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\nindex fe5d15606e..d768734186 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n\n@@ -43,7 +43,6 @@ import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n-import org.apache.log4j.Logger;\n \n import com.cloud.host.HostVO;\n import com.cloud.host.Status;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MzAwMQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426693001", "bodyText": "methodname says it all", "author": "DaanHoogland", "createdAt": "2020-05-18T15:03:26Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);\n+            }\n+        });\n+        return files;\n+    }\n+\n+    // Gets list of all valid templates, i.e, templates in \"Ready\" state for migration\n+    protected List<DataObject> getAllValidTemplates(DataStore srcDataStore) {\n+\n+        List<DataObject> files = new LinkedList<>();\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStore.getId());\n+        for (TemplateDataStoreVO template : templates) {\n+            VMTemplateVO templateVO = templateDao.findById(template.getTemplateId());\n+            if (template.getState() == ObjectInDataStoreStateMachine.State.Ready && !templateVO.isPublicTemplate()) {\n+                files.add(templateFactory.getTemplate(template.getTemplateId(), srcDataStore));\n+            }\n+        }\n+        return files;\n+    }\n+\n+    /** Returns parent snapshots and snapshots that do not have any children; snapshotChains comprises of the snapshot chain info\n+     * for each parent snapshot and the cumulative size of the chain - this is done to ensure that all the snapshots in a chain\n+     * are migrated to the same datastore\n+     */\n+    protected List<DataObject> getAllValidSnapshotsAndChains(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<SnapshotInfo> files = new LinkedList<>();\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStore.getId(), DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            SnapshotVO snapshotVO = snapshotDao.findById(snapshot.getSnapshotId());\n+            if (snapshot.getState() == ObjectInDataStoreStateMachine.State.Ready && snapshot.getParentSnapshotId() == 0 ) {\n+                SnapshotInfo snap = snapshotFactory.getSnapshot(snapshotVO.getSnapshotId(), DataStoreRole.Image);\n+                files.add(snap);\n+            }\n+        }\n+\n+        for (SnapshotInfo parent : files) {\n+            List<SnapshotInfo> chain = new ArrayList<>();\n+            chain.add(parent);\n+            for (int i =0; i< chain.size(); i++) {\n+                SnapshotInfo child = chain.get(i);\n+                List<SnapshotInfo> children = child.getChildren();\n+                if (children != null) {\n+                    chain.addAll(children);\n+                }\n+            }\n+            snapshotChains.put(parent, new Pair<List<SnapshotInfo>, Long>(chain, getSizeForChain(chain)));\n+        }\n+\n+        return (List<DataObject>) (List<?>) files;\n+    }\n+\n+    // Finds the cumulative file size for all data objects in the chain", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\nindex fe5d15606e..d768734186 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n\n@@ -43,7 +43,6 @@ import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n-import org.apache.log4j.Logger;\n \n import com.cloud.host.HostVO;\n import com.cloud.host.Status;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MzY5MQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426693691", "bodyText": "this triggers the thought: should chain be migrated at all or be coalesced first?", "author": "DaanHoogland", "createdAt": "2020-05-18T15:04:27Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);\n+            }\n+        });\n+        return files;\n+    }\n+\n+    // Gets list of all valid templates, i.e, templates in \"Ready\" state for migration\n+    protected List<DataObject> getAllValidTemplates(DataStore srcDataStore) {\n+\n+        List<DataObject> files = new LinkedList<>();\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStore.getId());\n+        for (TemplateDataStoreVO template : templates) {\n+            VMTemplateVO templateVO = templateDao.findById(template.getTemplateId());\n+            if (template.getState() == ObjectInDataStoreStateMachine.State.Ready && !templateVO.isPublicTemplate()) {\n+                files.add(templateFactory.getTemplate(template.getTemplateId(), srcDataStore));\n+            }\n+        }\n+        return files;\n+    }\n+\n+    /** Returns parent snapshots and snapshots that do not have any children; snapshotChains comprises of the snapshot chain info\n+     * for each parent snapshot and the cumulative size of the chain - this is done to ensure that all the snapshots in a chain\n+     * are migrated to the same datastore\n+     */", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NzQyMA==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427057420", "bodyText": "@DaanHoogland Could you please expand on this", "author": "Pearl1594", "createdAt": "2020-05-19T06:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MzY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMyMjEwMw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427322103", "bodyText": "basic idea is to follow the snapshot creation logic, if there is a chain they all go to the same datastore - otherwise snapshot is created in the datastore with max free capacity", "author": "Pearl1594", "createdAt": "2020-05-19T13:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MzY5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\nindex fe5d15606e..d768734186 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n\n@@ -43,7 +43,6 @@ import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n-import org.apache.log4j.Logger;\n \n import com.cloud.host.HostVO;\n import com.cloud.host.Status;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NDU3NQ==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r426694575", "bodyText": "rename to getAllReadyVolumes and delete comment?", "author": "DaanHoogland", "createdAt": "2020-05-18T15:05:45Z", "path": "engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.cloudstack.engine.orchestration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataObject;\n+import org.apache.cloudstack.engine.subsystem.api.storage.DataStore;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.SnapshotInfo;\n+import org.apache.cloudstack.engine.subsystem.api.storage.TemplateDataFactory;\n+import org.apache.cloudstack.engine.subsystem.api.storage.VolumeDataFactory;\n+import org.apache.cloudstack.storage.ImageStoreService;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.SnapshotDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n+import org.apache.log4j.Logger;\n+\n+import com.cloud.host.HostVO;\n+import com.cloud.host.Status;\n+import com.cloud.host.dao.HostDao;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.SnapshotVO;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.SnapshotDao;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.vm.SecondaryStorageVm;\n+import com.cloud.vm.SecondaryStorageVmVO;\n+import com.cloud.vm.VirtualMachine;\n+import com.cloud.vm.dao.SecondaryStorageVmDao;\n+\n+public class DataMigrationUtility {\n+    @Inject\n+    SecondaryStorageVmDao secStorageVmDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    SnapshotDataStoreDao snapshotDataStoreDao;\n+    @Inject\n+    VolumeDataStoreDao volumeDataStoreDao;\n+    @Inject\n+    VMTemplateDao templateDao;\n+    @Inject\n+    VolumeDataFactory volumeFactory;\n+    @Inject\n+    TemplateDataFactory templateFactory;\n+    @Inject\n+    SnapshotDataFactory snapshotFactory;\n+    @Inject\n+    HostDao hostDao;\n+    @Inject\n+    SnapshotDao snapshotDao;\n+\n+    private static final Logger s_logger = Logger.getLogger(DataMigrationUtility.class);\n+\n+    /** This function verifies if the given image store comprises of data objects that are not in either the \"Ready\" or\n+     * \"Allocated\" state - in such a case, if the migration policy is complete, the migration is terminated\n+     */\n+    private boolean filesReady(Long srcDataStoreId) {\n+        String[] validStates = new String[]{\"Ready\", \"Allocated\"};\n+        boolean isReady = true;\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (TemplateDataStoreVO template : templates) {\n+            isReady &= (Arrays.asList(validStates).contains(template.getState().toString()));\n+        }\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStoreId, DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            isReady &= (Arrays.asList(validStates).contains(snapshot.getState().toString()));\n+        }\n+        List<VolumeDataStoreVO> volumes = volumeDataStoreDao.listByStoreId(srcDataStoreId);\n+        for (VolumeDataStoreVO volume : volumes) {\n+            isReady &= (Arrays.asList(validStates).contains(volume.getState().toString()));\n+        }\n+        return isReady;\n+    }\n+\n+    protected void checkIfCompleteMigrationPossible(ImageStoreService.MigrationPolicy policy, Long srcDataStoreId) {\n+        if (policy == ImageStoreService.MigrationPolicy.COMPLETE) {\n+            if (!filesReady(srcDataStoreId)) {\n+                throw new CloudRuntimeException(\"Complete migration failed as there are data objects which are not Ready\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    protected Long getFileSize(DataObject file, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChain) {\n+        Long size = file.getSize();\n+        Pair<List<SnapshotInfo>, Long> chain = snapshotChain.get(file);\n+        if (file instanceof SnapshotInfo && chain.first() != null) {\n+            size = chain.second();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Sorts the datastores in decreasing order of their free capacities, so as to make\n+     * an informed decision of picking the datastore with maximum free capactiy for migration\n+     */\n+    protected List<Long> sortDataStores(Map<Long, Pair<Long, Long>> storageCapacities) {\n+        List<Map.Entry<Long, Pair<Long, Long>>> list =\n+                new LinkedList<Map.Entry<Long, Pair<Long, Long>>>((storageCapacities.entrySet()));\n+\n+        Collections.sort(list, new Comparator<Map.Entry<Long, Pair<Long, Long>>>() {\n+            @Override\n+            public int compare(Map.Entry<Long, Pair<Long, Long>> e1, Map.Entry<Long, Pair<Long, Long>> e2) {\n+                return e2.getValue().first() > e1.getValue().first() ? 1 : -1;\n+            }\n+        });\n+        HashMap<Long, Pair<Long, Long>> temp = new LinkedHashMap<>();\n+        for (Map.Entry<Long, Pair<Long, Long>> value : list) {\n+            temp.put(value.getKey(), value.getValue());\n+        }\n+\n+        return new ArrayList<>(temp.keySet());\n+    }\n+\n+    protected List<DataObject> getSortedValidSourcesList(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<DataObject> files = new ArrayList<>();\n+        files.addAll(getAllValidTemplates(srcDataStore));\n+        files.addAll(getAllValidSnapshotsAndChains(srcDataStore, snapshotChains));\n+        files.addAll(getAllValidVolumes(srcDataStore));\n+\n+        files = sortFilesOnSize(files, snapshotChains);\n+\n+        return files;\n+    }\n+\n+    protected List<DataObject> sortFilesOnSize(List<DataObject> files, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        Collections.sort(files, new Comparator<DataObject>() {\n+            @Override\n+            public int compare(DataObject o1, DataObject o2) {\n+                Long size1 = o1.getSize();\n+                Long size2 = o2.getSize();\n+                if (o1 instanceof SnapshotInfo) {\n+                    size1 = snapshotChains.get(o1).second();\n+                }\n+                if (o2 instanceof  SnapshotInfo) {\n+                    size2 = snapshotChains.get(o2).second();\n+                }\n+                return (int) (size2 - size1);\n+            }\n+        });\n+        return files;\n+    }\n+\n+    // Gets list of all valid templates, i.e, templates in \"Ready\" state for migration\n+    protected List<DataObject> getAllValidTemplates(DataStore srcDataStore) {\n+\n+        List<DataObject> files = new LinkedList<>();\n+        List<TemplateDataStoreVO> templates = templateDataStoreDao.listByStoreId(srcDataStore.getId());\n+        for (TemplateDataStoreVO template : templates) {\n+            VMTemplateVO templateVO = templateDao.findById(template.getTemplateId());\n+            if (template.getState() == ObjectInDataStoreStateMachine.State.Ready && !templateVO.isPublicTemplate()) {\n+                files.add(templateFactory.getTemplate(template.getTemplateId(), srcDataStore));\n+            }\n+        }\n+        return files;\n+    }\n+\n+    /** Returns parent snapshots and snapshots that do not have any children; snapshotChains comprises of the snapshot chain info\n+     * for each parent snapshot and the cumulative size of the chain - this is done to ensure that all the snapshots in a chain\n+     * are migrated to the same datastore\n+     */\n+    protected List<DataObject> getAllValidSnapshotsAndChains(DataStore srcDataStore, Map<DataObject, Pair<List<SnapshotInfo>, Long>> snapshotChains) {\n+        List<SnapshotInfo> files = new LinkedList<>();\n+        List<SnapshotDataStoreVO> snapshots = snapshotDataStoreDao.listByStoreId(srcDataStore.getId(), DataStoreRole.Image);\n+        for (SnapshotDataStoreVO snapshot : snapshots) {\n+            SnapshotVO snapshotVO = snapshotDao.findById(snapshot.getSnapshotId());\n+            if (snapshot.getState() == ObjectInDataStoreStateMachine.State.Ready && snapshot.getParentSnapshotId() == 0 ) {\n+                SnapshotInfo snap = snapshotFactory.getSnapshot(snapshotVO.getSnapshotId(), DataStoreRole.Image);\n+                files.add(snap);\n+            }\n+        }\n+\n+        for (SnapshotInfo parent : files) {\n+            List<SnapshotInfo> chain = new ArrayList<>();\n+            chain.add(parent);\n+            for (int i =0; i< chain.size(); i++) {\n+                SnapshotInfo child = chain.get(i);\n+                List<SnapshotInfo> children = child.getChildren();\n+                if (children != null) {\n+                    chain.addAll(children);\n+                }\n+            }\n+            snapshotChains.put(parent, new Pair<List<SnapshotInfo>, Long>(chain, getSizeForChain(chain)));\n+        }\n+\n+        return (List<DataObject>) (List<?>) files;\n+    }\n+\n+    // Finds the cumulative file size for all data objects in the chain\n+    protected Long getSizeForChain(List<SnapshotInfo> chain) {\n+        Long size = 0L;\n+        for (SnapshotInfo snapshot : chain) {\n+            size += snapshot.getSize();\n+        }\n+        return size;\n+    }\n+\n+    // Returns a list of volumes that are in \"Ready\" state", "originalCommit": "452fe520fbc5ab61c965237febd02e6f75a895bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a1b524d5f7d21f370afb21749f786fec6250132", "chunk": "diff --git a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\nindex fe5d15606e..d768734186 100644\n--- a/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n+++ b/engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/DataMigrationUtility.java\n\n@@ -43,7 +43,6 @@ import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreDao;\n import org.apache.cloudstack.storage.datastore.db.VolumeDataStoreVO;\n-import org.apache.log4j.Logger;\n \n import com.cloud.host.HostVO;\n import com.cloud.host.Status;\n"}}, {"oid": "0a1b524d5f7d21f370afb21749f786fec6250132", "url": "https://github.com/apache/cloudstack/commit/0a1b524d5f7d21f370afb21749f786fec6250132", "message": "Address review comments", "committedDate": "2020-05-19T07:50:51Z", "type": "forcePushed"}, {"oid": "1236d660205069e8c2c658fbc6c09268133db8ed", "url": "https://github.com/apache/cloudstack/commit/1236d660205069e8c2c658fbc6c09268133db8ed", "message": "Address review comments", "committedDate": "2020-05-19T07:52:10Z", "type": "forcePushed"}, {"oid": "5e403768bd91f6da0b82a59d738786eee4e9650f", "url": "https://github.com/apache/cloudstack/commit/5e403768bd91f6da0b82a59d738786eee4e9650f", "message": "Address review comments", "committedDate": "2020-05-19T08:03:31Z", "type": "forcePushed"}, {"oid": "82f65569a7ec66a46f84d231948111a35bd31548", "url": "https://github.com/apache/cloudstack/commit/82f65569a7ec66a46f84d231948111a35bd31548", "message": "Address review comments", "committedDate": "2020-05-19T08:38:54Z", "type": "commit"}, {"oid": "82f65569a7ec66a46f84d231948111a35bd31548", "url": "https://github.com/apache/cloudstack/commit/82f65569a7ec66a46f84d231948111a35bd31548", "message": "Address review comments", "committedDate": "2020-05-19T08:38:54Z", "type": "forcePushed"}, {"oid": "141635d6386da022a1f081475de3aaedbb1304be", "url": "https://github.com/apache/cloudstack/commit/141635d6386da022a1f081475de3aaedbb1304be", "message": "updated comment", "committedDate": "2020-05-19T12:24:55Z", "type": "commit"}, {"oid": "8a2208e5c0b0482b24a6e45557468e7fecde4782", "url": "https://github.com/apache/cloudstack/commit/8a2208e5c0b0482b24a6e45557468e7fecde4782", "message": "textual change in javadoc", "committedDate": "2020-05-20T06:49:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgwNzU2Mw==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r427807563", "bodyText": "no significant changes in this file", "author": "DaanHoogland", "createdAt": "2020-05-20T07:48:35Z", "path": "server/src/main/java/com/cloud/configuration/Config.java", "diffHunk": "@@ -16,6 +16,15 @@\n // under the License.\n package com.cloud.configuration;\n \n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import org.apache.cloudstack.engine.orchestration.service.NetworkOrchestrationService;\n+import org.apache.cloudstack.engine.subsystem.api.storage.StoragePoolAllocator;\n+import org.apache.cloudstack.framework.config.ConfigKey;\n+", "originalCommit": "8a2208e5c0b0482b24a6e45557468e7fecde4782", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5b4c2414fc108caf3574a693d4b62927c4af811a", "chunk": "diff --git a/server/src/main/java/com/cloud/configuration/Config.java b/server/src/main/java/com/cloud/configuration/Config.java\nindex c72eb498b1..3daf720138 100644\n--- a/server/src/main/java/com/cloud/configuration/Config.java\n+++ b/server/src/main/java/com/cloud/configuration/Config.java\n\n@@ -16,15 +16,6 @@\n // under the License.\n package com.cloud.configuration;\n \n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.StringTokenizer;\n-\n-import org.apache.cloudstack.engine.orchestration.service.NetworkOrchestrationService;\n-import org.apache.cloudstack.engine.subsystem.api.storage.StoragePoolAllocator;\n-import org.apache.cloudstack.framework.config.ConfigKey;\n-\n import com.cloud.agent.AgentManager;\n import com.cloud.consoleproxy.ConsoleProxyManager;\n import com.cloud.ha.HighAvailabilityManager;\n"}}, {"oid": "5b4c2414fc108caf3574a693d4b62927c4af811a", "url": "https://github.com/apache/cloudstack/commit/5b4c2414fc108caf3574a693d4b62927c4af811a", "message": "updated comment", "committedDate": "2020-05-20T08:26:17Z", "type": "commit"}, {"oid": "f64e76f42a7540a1cb5d356d80d374cbfb5d8fb2", "url": "https://github.com/apache/cloudstack/commit/f64e76f42a7540a1cb5d356d80d374cbfb5d8fb2", "message": "Merge branch 'SecStgMgmt' of github.com:shapeblue/cloudstack into SecStgMgmt", "committedDate": "2020-05-22T11:40:18Z", "type": "commit"}, {"oid": "f64e76f42a7540a1cb5d356d80d374cbfb5d8fb2", "url": "https://github.com/apache/cloudstack/commit/f64e76f42a7540a1cb5d356d80d374cbfb5d8fb2", "message": "Merge branch 'SecStgMgmt' of github.com:shapeblue/cloudstack into SecStgMgmt", "committedDate": "2020-05-22T11:40:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMyNjg2Mg==", "url": "https://github.com/apache/cloudstack/pull/4053#discussion_r429326862", "bodyText": "so ./dir/file/file without extra .extension!", "author": "DaanHoogland", "createdAt": "2020-05-22T15:52:15Z", "path": "services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java", "diffHunk": "@@ -1347,7 +1351,11 @@ protected Answer copyFromNfsToNfs(CopyCommand cmd) {\n                 retObj = newVol;\n             } else if (destData.getObjectType() == DataObjectType.SNAPSHOT) {\n                 SnapshotObjectTO newSnapshot = new SnapshotObjectTO();\n-                newSnapshot.setPath(destData.getPath() + File.separator + destFile.getName());\n+                if (srcFile.isFile()) {\n+                    newSnapshot.setPath(destData.getPath() + File.separator + destFile.getName());\n+                } else {\n+                    newSnapshot.setPath(destData.getPath() + File.separator + destFile.getName() + File.separator + destFile.getName());", "originalCommit": "f64e76f42a7540a1cb5d356d80d374cbfb5d8fb2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cb1e5baf7c8933f4295e8bc8056da2a12c6442bc", "chunk": "diff --git a/services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java b/services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java\nindex 5341294cce..c52ac68e3f 100644\n--- a/services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java\n+++ b/services/secondary-storage/server/src/main/java/org/apache/cloudstack/storage/resource/NfsSecondaryStorageResource.java\n\n@@ -1346,7 +1346,11 @@ public class NfsSecondaryStorageResource extends ServerResourceBase implements S\n                 retObj = newTemplate;\n             } else if (destData.getObjectType() == DataObjectType.VOLUME) {\n                 VolumeObjectTO newVol = new VolumeObjectTO();\n-                newVol.setPath(destData.getPath() + File.separator + srcFile.getName());\n+                if (srcFile.isFile()) {\n+                    newVol.setPath(destData.getPath() + File.separator + srcFile.getName());\n+                } else {\n+                    newVol.setPath(destData.getPath());\n+                }\n                 newVol.setSize(srcFile.length());\n                 retObj = newVol;\n             } else if (destData.getObjectType() == DataObjectType.SNAPSHOT) {\n"}}, {"oid": "cb1e5baf7c8933f4295e8bc8056da2a12c6442bc", "url": "https://github.com/apache/cloudstack/commit/cb1e5baf7c8933f4295e8bc8056da2a12c6442bc", "message": "refined error message", "committedDate": "2020-05-29T13:05:12Z", "type": "commit"}, {"oid": "ebaaac50daebb3ac98f3e87c4037dd69cf7ee1f8", "url": "https://github.com/apache/cloudstack/commit/ebaaac50daebb3ac98f3e87c4037dd69cf7ee1f8", "message": "Merge branch 'master' of github.com:shapeblue/cloudstack into SecStgMgmt", "committedDate": "2020-05-29T16:07:05Z", "type": "commit"}, {"oid": "dfe7c855dbe65e400b80bb2919d79d8e746ffdfd", "url": "https://github.com/apache/cloudstack/commit/dfe7c855dbe65e400b80bb2919d79d8e746ffdfd", "message": "Merge branch 'master' of github.com:shapeblue/cloudstack into SecStgMgmt", "committedDate": "2020-06-11T10:01:48Z", "type": "commit"}, {"oid": "d6c1e5dba68e8f754909b173739ae28c5673547a", "url": "https://github.com/apache/cloudstack/commit/d6c1e5dba68e8f754909b173739ae28c5673547a", "message": "Merge branch 'master' of github.com:shapeblue/cloudstack into SecStgMgmt", "committedDate": "2020-06-18T10:02:44Z", "type": "commit"}, {"oid": "b70fc1de84c97404304dc51e0eeef9bc1dc35a5e", "url": "https://github.com/apache/cloudstack/commit/b70fc1de84c97404304dc51e0eeef9bc1dc35a5e", "message": "Adhere to readonly flag when allzones option selected", "committedDate": "2020-06-18T10:20:20Z", "type": "commit"}, {"oid": "cc3ce75dd851210c8e0d9ecd6f588f4587ef33f5", "url": "https://github.com/apache/cloudstack/commit/cc3ce75dd851210c8e0d9ecd6f588f4587ef33f5", "message": "Added event details", "committedDate": "2020-06-18T13:33:31Z", "type": "commit"}, {"oid": "cc3ce75dd851210c8e0d9ecd6f588f4587ef33f5", "url": "https://github.com/apache/cloudstack/commit/cc3ce75dd851210c8e0d9ecd6f588f4587ef33f5", "message": "Added event details", "committedDate": "2020-06-18T13:33:31Z", "type": "forcePushed"}, {"oid": "861c6d5b39ee1580f4f9e6260688c8fef68f383b", "url": "https://github.com/apache/cloudstack/commit/861c6d5b39ee1580f4f9e6260688c8fef68f383b", "message": "event logs modified + vmware changes", "committedDate": "2020-06-22T18:00:42Z", "type": "commit"}, {"oid": "861c6d5b39ee1580f4f9e6260688c8fef68f383b", "url": "https://github.com/apache/cloudstack/commit/861c6d5b39ee1580f4f9e6260688c8fef68f383b", "message": "event logs modified + vmware changes", "committedDate": "2020-06-22T18:00:42Z", "type": "forcePushed"}, {"oid": "4270352bd67309b0e9cda946121506615ecc0359", "url": "https://github.com/apache/cloudstack/commit/4270352bd67309b0e9cda946121506615ecc0359", "message": "Added check for only image store - more restrictive check", "committedDate": "2020-06-23T14:56:10Z", "type": "commit"}, {"oid": "1515108811acd7a0213a207868c14beab2076357", "url": "https://github.com/apache/cloudstack/commit/1515108811acd7a0213a207868c14beab2076357", "message": "Added check for only image store - more restrictive check", "committedDate": "2020-06-24T05:28:38Z", "type": "commit"}, {"oid": "1515108811acd7a0213a207868c14beab2076357", "url": "https://github.com/apache/cloudstack/commit/1515108811acd7a0213a207868c14beab2076357", "message": "Added check for only image store - more restrictive check", "committedDate": "2020-06-24T05:28:38Z", "type": "forcePushed"}, {"oid": "15486b30b87ef933a521ccf44016dc9d3f623776", "url": "https://github.com/apache/cloudstack/commit/15486b30b87ef933a521ccf44016dc9d3f623776", "message": "Added detailed logs", "committedDate": "2020-06-24T09:29:20Z", "type": "commit"}, {"oid": "427b0fbe32aff0790bdfd737641723c470e21d25", "url": "https://github.com/apache/cloudstack/commit/427b0fbe32aff0790bdfd737641723c470e21d25", "message": "Merge branch 'master' of github.com:shapeblue/cloudstack into SecStgMgmt", "committedDate": "2020-06-29T10:22:00Z", "type": "commit"}, {"oid": "8f2b224aebd1c7f3592055e1200a7661460f4371", "url": "https://github.com/apache/cloudstack/commit/8f2b224aebd1c7f3592055e1200a7661460f4371", "message": "handle case for tests", "committedDate": "2020-06-29T12:20:55Z", "type": "commit"}, {"oid": "79d0d8bc111930a8bbfd18093ce999fb31e7f865", "url": "https://github.com/apache/cloudstack/commit/79d0d8bc111930a8bbfd18093ce999fb31e7f865", "message": "template registration failure marvin", "committedDate": "2020-06-29T14:23:23Z", "type": "commit"}, {"oid": "3ef207ae6b0d8dbda03874313c3cb87d5a88b705", "url": "https://github.com/apache/cloudstack/commit/3ef207ae6b0d8dbda03874313c3cb87d5a88b705", "message": "Fixed marvin failures", "committedDate": "2020-06-30T09:47:07Z", "type": "commit"}, {"oid": "8bce77c9bbb62f4ea64fc40a4ac8e036c61d2925", "url": "https://github.com/apache/cloudstack/commit/8bce77c9bbb62f4ea64fc40a4ac8e036c61d2925", "message": "Add fsm check", "committedDate": "2020-06-30T16:28:38Z", "type": "commit"}, {"oid": "357f92469879b5f99a8f0cf24b6576f9ec922c02", "url": "https://github.com/apache/cloudstack/commit/357f92469879b5f99a8f0cf24b6576f9ec922c02", "message": "regression checks", "committedDate": "2020-07-01T16:10:20Z", "type": "commit"}, {"oid": "4df63730f986cee535613a4ae6ceaf6add182f18", "url": "https://github.com/apache/cloudstack/commit/4df63730f986cee535613a4ae6ceaf6add182f18", "message": "Added new tests related to new functionalities introduced with FR76", "committedDate": "2020-07-10T13:59:00Z", "type": "commit"}, {"oid": "276eaa966b6cae69209dcddb5fdd320c31cd9688", "url": "https://github.com/apache/cloudstack/commit/276eaa966b6cae69209dcddb5fdd320c31cd9688", "message": "Added new tests related to new functionalities introduced with FR76", "committedDate": "2020-07-10T13:59:59Z", "type": "commit"}, {"oid": "a68acb7ec8eeae3133c46a5812379efd493bf244", "url": "https://github.com/apache/cloudstack/commit/a68acb7ec8eeae3133c46a5812379efd493bf244", "message": "Removed one case for balanced migration giving different results in Trillian and real environment.", "committedDate": "2020-07-13T20:54:51Z", "type": "commit"}, {"oid": "d5405cedd025dc76639f1ccbbd7f342200dc873b", "url": "https://github.com/apache/cloudstack/commit/d5405cedd025dc76639f1ccbbd7f342200dc873b", "message": "Merge branch 'SecStgMgmt' of github.com:shapeblue/cloudstack into SecStgMgmt", "committedDate": "2020-07-24T03:36:11Z", "type": "commit"}, {"oid": "f5b2ccc297e85b4a4ff820533c3fbfe21a7cfe85", "url": "https://github.com/apache/cloudstack/commit/f5b2ccc297e85b4a4ff820533c3fbfe21a7cfe85", "message": "Merge branch 'master' of github.com:shapeblue/cloudstack into SecStgMgmt", "committedDate": "2020-07-24T03:39:03Z", "type": "commit"}, {"oid": "c5c0dd6c1b6028653805c38ab98720bb3aab7bac", "url": "https://github.com/apache/cloudstack/commit/c5c0dd6c1b6028653805c38ab98720bb3aab7bac", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into SecStgMgmt", "committedDate": "2020-07-24T03:44:56Z", "type": "commit"}, {"oid": "526a6d21e5b37279ddc26038919d990b35c34535", "url": "https://github.com/apache/cloudstack/commit/526a6d21e5b37279ddc26038919d990b35c34535", "message": "Change global setting value", "committedDate": "2020-08-01T14:54:00Z", "type": "commit"}, {"oid": "526a6d21e5b37279ddc26038919d990b35c34535", "url": "https://github.com/apache/cloudstack/commit/526a6d21e5b37279ddc26038919d990b35c34535", "message": "Change global setting value", "committedDate": "2020-08-01T14:54:00Z", "type": "forcePushed"}, {"oid": "59307524bf8543ebdb98c226c695d8f5a32fbcfc", "url": "https://github.com/apache/cloudstack/commit/59307524bf8543ebdb98c226c695d8f5a32fbcfc", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into SecStgMgmt", "committedDate": "2020-08-01T14:58:56Z", "type": "commit"}, {"oid": "78a566766f5a21c7a46063a6b4ab6132a8a15770", "url": "https://github.com/apache/cloudstack/commit/78a566766f5a21c7a46063a6b4ab6132a8a15770", "message": "Update PremiumSecondaryStorageManagerImpl.java", "committedDate": "2020-08-11T18:40:05Z", "type": "commit"}, {"oid": "67b41ecc8f30ba159bcaeadf9a7dffa6bca848a3", "url": "https://github.com/apache/cloudstack/commit/67b41ecc8f30ba159bcaeadf9a7dffa6bca848a3", "message": "code refactor", "committedDate": "2020-08-12T09:08:02Z", "type": "commit"}, {"oid": "32ffa810cf6b6d0379b7f9ed4a02348ca29f7ae4", "url": "https://github.com/apache/cloudstack/commit/32ffa810cf6b6d0379b7f9ed4a02348ca29f7ae4", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into SecStgMgmt", "committedDate": "2020-08-13T12:39:19Z", "type": "commit"}, {"oid": "490c235bcbbd8f1a07979bb0219205f795177e5f", "url": "https://github.com/apache/cloudstack/commit/490c235bcbbd8f1a07979bb0219205f795177e5f", "message": "minor fix", "committedDate": "2020-08-16T03:42:40Z", "type": "commit"}, {"oid": "5f18a7107ed593e85dfe568a22871c40d46adac3", "url": "https://github.com/apache/cloudstack/commit/5f18a7107ed593e85dfe568a22871c40d46adac3", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into SecStgMgmt", "committedDate": "2020-08-16T03:43:07Z", "type": "commit"}, {"oid": "f071131788ab006dd45b36154485548f345cb2fa", "url": "https://github.com/apache/cloudstack/commit/f071131788ab006dd45b36154485548f345cb2fa", "message": "fixes", "committedDate": "2020-08-17T09:53:38Z", "type": "commit"}, {"oid": "f071131788ab006dd45b36154485548f345cb2fa", "url": "https://github.com/apache/cloudstack/commit/f071131788ab006dd45b36154485548f345cb2fa", "message": "fixes", "committedDate": "2020-08-17T09:53:38Z", "type": "forcePushed"}, {"oid": "26e058beaa94dd56a05751370ab72abc7890a7e8", "url": "https://github.com/apache/cloudstack/commit/26e058beaa94dd56a05751370ab72abc7890a7e8", "message": "Check for transitions", "committedDate": "2020-08-19T07:50:25Z", "type": "commit"}, {"oid": "6fa4735fc9ffb6e63c9ed8e31a0b1f86617f4106", "url": "https://github.com/apache/cloudstack/commit/6fa4735fc9ffb6e63c9ed8e31a0b1f86617f4106", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into SecStgMgmt", "committedDate": "2020-08-28T15:32:44Z", "type": "commit"}, {"oid": "6fa4735fc9ffb6e63c9ed8e31a0b1f86617f4106", "url": "https://github.com/apache/cloudstack/commit/6fa4735fc9ffb6e63c9ed8e31a0b1f86617f4106", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into SecStgMgmt", "committedDate": "2020-08-28T15:32:44Z", "type": "forcePushed"}, {"oid": "4862cbc2d43079b87ebfec45068eb0a8d147d4f8", "url": "https://github.com/apache/cloudstack/commit/4862cbc2d43079b87ebfec45068eb0a8d147d4f8", "message": "Added guarding against stores other than NFS", "committedDate": "2020-09-07T05:46:52Z", "type": "commit"}, {"oid": "51934ae4b7c7889cdd419878873b7cc08b9992e4", "url": "https://github.com/apache/cloudstack/commit/51934ae4b7c7889cdd419878873b7cc08b9992e4", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into SecStgMgmt", "committedDate": "2020-09-07T05:47:20Z", "type": "commit"}, {"oid": "4675068d9217e3136ab41626255554bef1543831", "url": "https://github.com/apache/cloudstack/commit/4675068d9217e3136ab41626255554bef1543831", "message": "Update ImageStoreServiceImpl.java", "committedDate": "2020-09-09T08:19:07Z", "type": "commit"}, {"oid": "eed05f97d7e8181430566702d625885dc7b81b93", "url": "https://github.com/apache/cloudstack/commit/eed05f97d7e8181430566702d625885dc7b81b93", "message": "Null check", "committedDate": "2020-09-12T03:14:08Z", "type": "commit"}, {"oid": "e99548f588ee9c1a3e93091c96a3ec73f48e052c", "url": "https://github.com/apache/cloudstack/commit/e99548f588ee9c1a3e93091c96a3ec73f48e052c", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into SecStgMgmt", "committedDate": "2020-09-13T06:02:33Z", "type": "commit"}, {"oid": "e99548f588ee9c1a3e93091c96a3ec73f48e052c", "url": "https://github.com/apache/cloudstack/commit/e99548f588ee9c1a3e93091c96a3ec73f48e052c", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into SecStgMgmt", "committedDate": "2020-09-13T06:02:33Z", "type": "forcePushed"}, {"oid": "40d1818b1687f2bcf99395670c85575326cab712", "url": "https://github.com/apache/cloudstack/commit/40d1818b1687f2bcf99395670c85575326cab712", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into SecStgMgmt", "committedDate": "2020-09-16T06:20:07Z", "type": "commit"}, {"oid": "716e77af138c8dd0bc5af4a334113f3dbb3a36cd", "url": "https://github.com/apache/cloudstack/commit/716e77af138c8dd0bc5af4a334113f3dbb3a36cd", "message": "Correct sql query to get all active commands on ssvms", "committedDate": "2020-09-16T06:36:30Z", "type": "commit"}, {"oid": "8a8552428f02925013f7b2e35efb72ee95704487", "url": "https://github.com/apache/cloudstack/commit/8a8552428f02925013f7b2e35efb72ee95704487", "message": "Removed junk file", "committedDate": "2020-09-16T08:16:24Z", "type": "commit"}]}