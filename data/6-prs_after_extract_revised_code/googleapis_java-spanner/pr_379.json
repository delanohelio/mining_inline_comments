{"pr_number": 379, "pr_title": "feat: support setting timeout per RPC", "pr_createdAt": "2020-08-10T10:28:05Z", "pr_url": "https://github.com/googleapis/java-spanner/pull/379", "timeline": [{"oid": "ec4cc303a4e71dd9ae507124131a8172252a1648", "url": "https://github.com/googleapis/java-spanner/commit/ec4cc303a4e71dd9ae507124131a8172252a1648", "message": "feat: support setting timeout per RPC\n\nThe Spanner client allows a user to set custom timeouts while creating a\nSpannerOptions instance, but these timeouts are static and are applied to\nall invocations of the RPCs. This change introduces the possibility to set\ncustom timeouts and other call options on a per-RPC basis.\n\nFixes #378", "committedDate": "2020-08-10T10:26:13Z", "type": "commit"}, {"oid": "dd2715702423eedc8c9e907e6ccf1e33876f6074", "url": "https://github.com/googleapis/java-spanner/commit/dd2715702423eedc8c9e907e6ccf1e33876f6074", "message": "fix: change grpc deps from test to compile scope", "committedDate": "2020-08-10T13:14:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMDczMQ==", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471230731", "bodyText": "Why do we remove this? This seems to be related to the failed test:\n[ERROR] 7002: com.google.cloud.spanner.spi.v1.GapicSpannerRpc: Method 'public com.google.spanner.v1.ResultSet executePartitionedDml(com.google.spanner.v1.ExecuteSqlRequest, java.util.Map)' has been removed\n[ERROR] 7002: com.google.cloud.spanner.spi.v1.SpannerRpc: Method 'public com.google.spanner.v1.ResultSet executePartitionedDml(com.google.spanner.v1.ExecuteSqlRequest, java.util.Map)' has been removed", "author": "hengfengli", "createdAt": "2020-08-17T04:52:48Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/spi/v1/SpannerRpc.java", "diffHunk": "@@ -287,8 +287,6 @@ StreamingCall read(\n   ApiFuture<ResultSet> executeQueryAsync(\n       ExecuteSqlRequest request, @Nullable Map<Option, ?> options);\n \n-  ResultSet executePartitionedDml(ExecuteSqlRequest request, @Nullable Map<Option, ?> options);", "originalCommit": "dd2715702423eedc8c9e907e6ccf1e33876f6074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMyOTYxMA==", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471329610", "bodyText": "This method is no longer used (instead the client library uses the streaming version), but the removal of it should be moved to a separate PR. I've reverted this change. That should also fix the clirr build failure.", "author": "olavloite", "createdAt": "2020-08-17T08:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMDczMQ=="}], "type": "inlineReview", "revised_code": {"commit": "547a3c3136eeb7ba72942fe1031d622a29e0d61b", "chunk": "diff --git a/google-cloud-spanner/src/main/java/com/google/cloud/spanner/spi/v1/SpannerRpc.java b/google-cloud-spanner/src/main/java/com/google/cloud/spanner/spi/v1/SpannerRpc.java\nindex 9332c859..6b42c0a7 100644\n--- a/google-cloud-spanner/src/main/java/com/google/cloud/spanner/spi/v1/SpannerRpc.java\n+++ b/google-cloud-spanner/src/main/java/com/google/cloud/spanner/spi/v1/SpannerRpc.java\n\n@@ -287,6 +287,8 @@ public interface SpannerRpc extends ServiceRpc {\n   ApiFuture<ResultSet> executeQueryAsync(\n       ExecuteSqlRequest request, @Nullable Map<Option, ?> options);\n \n+  ResultSet executePartitionedDml(ExecuteSqlRequest request, @Nullable Map<Option, ?> options);\n+\n   RetrySettings getPartitionedDmlRetrySettings();\n \n   ServerStream<PartialResultSet> executeStreamingPartitionedDml(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzNDYyMA==", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471234620", "bodyText": "udate to update", "author": "hengfengli", "createdAt": "2020-08-17T05:11:13Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java", "diffHunk": "@@ -336,11 +367,93 @@ public void testNoCallCredentials() {\n             .setCredentials(STATIC_CREDENTIALS)\n             .build();\n     GapicSpannerRpc rpc = new GapicSpannerRpc(options);\n-    assertThat(rpc.newCallContext(optionsMap, \"/some/resource\").getCallOptions().getCredentials())\n+    assertThat(\n+            rpc.newCallContext(\n+                    optionsMap,\n+                    \"/some/resource\",\n+                    GetSessionRequest.getDefaultInstance(),\n+                    SpannerGrpc.getGetSessionMethod())\n+                .getCallOptions()\n+                .getCredentials())\n         .isNull();\n     rpc.shutdown();\n   }\n \n+  private static final class TimeoutHolder {\n+    private Duration timeout;\n+  }\n+\n+  @Test\n+  public void testCallContextTimeout() {\n+    // Create a CallContextConfigurator that uses a variable timeout value.\n+    final TimeoutHolder timeoutHolder = new TimeoutHolder();\n+    CallContextConfigurator configurator =\n+        new CallContextConfigurator() {\n+          @Override\n+          public <ReqT, RespT> ApiCallContext configure(\n+              ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+            // Only configure a timeout for the ExecuteSql method when the request has a ,\n+            // as this method is used for executing DML statements.\n+            if (request instanceof ExecuteSqlRequest\n+                && method.equals(SpannerGrpc.getExecuteSqlMethod())) {\n+              ExecuteSqlRequest sqlRequest = (ExecuteSqlRequest) request;\n+              // Sequence numbers are only assigned for DML statements, which means that\n+              // this is an udate statement.", "originalCommit": "dd2715702423eedc8c9e907e6ccf1e33876f6074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMyOTkzOA==", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471329938", "bodyText": "Fixed.", "author": "olavloite", "createdAt": "2020-08-17T08:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzNDYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "547a3c3136eeb7ba72942fe1031d622a29e0d61b", "chunk": "diff --git a/google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java b/google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java\nindex eb7bb873..bac2c110 100644\n--- a/google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java\n+++ b/google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java\n\n@@ -398,7 +398,7 @@ public class GapicSpannerRpcTest {\n                 && method.equals(SpannerGrpc.getExecuteSqlMethod())) {\n               ExecuteSqlRequest sqlRequest = (ExecuteSqlRequest) request;\n               // Sequence numbers are only assigned for DML statements, which means that\n-              // this is an udate statement.\n+              // this is an update statement.\n               if (sqlRequest.getSeqno() > 0L) {\n                 return context.withTimeout(timeoutHolder.timeout);\n               }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzNDc5Ng==", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471234796", "bodyText": "This sentence is not finished yet.", "author": "hengfengli", "createdAt": "2020-08-17T05:11:59Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java", "diffHunk": "@@ -336,11 +367,93 @@ public void testNoCallCredentials() {\n             .setCredentials(STATIC_CREDENTIALS)\n             .build();\n     GapicSpannerRpc rpc = new GapicSpannerRpc(options);\n-    assertThat(rpc.newCallContext(optionsMap, \"/some/resource\").getCallOptions().getCredentials())\n+    assertThat(\n+            rpc.newCallContext(\n+                    optionsMap,\n+                    \"/some/resource\",\n+                    GetSessionRequest.getDefaultInstance(),\n+                    SpannerGrpc.getGetSessionMethod())\n+                .getCallOptions()\n+                .getCredentials())\n         .isNull();\n     rpc.shutdown();\n   }\n \n+  private static final class TimeoutHolder {\n+    private Duration timeout;\n+  }\n+\n+  @Test\n+  public void testCallContextTimeout() {\n+    // Create a CallContextConfigurator that uses a variable timeout value.\n+    final TimeoutHolder timeoutHolder = new TimeoutHolder();\n+    CallContextConfigurator configurator =\n+        new CallContextConfigurator() {\n+          @Override\n+          public <ReqT, RespT> ApiCallContext configure(\n+              ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+            // Only configure a timeout for the ExecuteSql method when the request has a ,", "originalCommit": "dd2715702423eedc8c9e907e6ccf1e33876f6074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ4NDcyNA==", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471484724", "bodyText": "Done.", "author": "olavloite", "createdAt": "2020-08-17T13:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzNDc5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "547a3c3136eeb7ba72942fe1031d622a29e0d61b", "chunk": "diff --git a/google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java b/google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java\nindex eb7bb873..bac2c110 100644\n--- a/google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java\n+++ b/google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java\n\n@@ -398,7 +398,7 @@ public class GapicSpannerRpcTest {\n                 && method.equals(SpannerGrpc.getExecuteSqlMethod())) {\n               ExecuteSqlRequest sqlRequest = (ExecuteSqlRequest) request;\n               // Sequence numbers are only assigned for DML statements, which means that\n-              // this is an udate statement.\n+              // this is an update statement.\n               if (sqlRequest.getSeqno() > 0L) {\n                 return context.withTimeout(timeoutHolder.timeout);\n               }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI0MTk3Nw==", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471241977", "bodyText": "So this given timeout is for every ExecuteQuery inside this context? If two ExecuteQuery calls are inside this context, each of them will be limited by the 1ns timeout, right?", "author": "hengfengli", "createdAt": "2020-08-17T05:40:26Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/DatabaseClientImplTest.java", "diffHunk": "@@ -1548,4 +1550,40 @@ public void testReadDoesNotIncludeStatement() {\n       assertThat(e.getMessage()).doesNotContain(\"Statement:\");\n     }\n   }\n+\n+  @Test\n+  public void testSpecificTimeout() {\n+    mockSpanner.setExecuteStreamingSqlExecutionTime(\n+        SimulatedExecutionTime.ofMinimumAndRandomTime(10000, 0));\n+    final DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(TEST_PROJECT, TEST_INSTANCE, TEST_DATABASE));\n+    Context.current()\n+        .withValue(\n+            SpannerOptions.CALL_CONTEXT_CONFIGURATOR_KEY,\n+            SpannerCallContextTimeoutConfigurator.create()\n+                .withExecuteQueryTimeout(Duration.ofNanos(1L)))", "originalCommit": "dd2715702423eedc8c9e907e6ccf1e33876f6074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMzMDc2Mw==", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471330763", "bodyText": "Correct.", "author": "olavloite", "createdAt": "2020-08-17T08:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI0MTk3Nw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "547a3c3136eeb7ba72942fe1031d622a29e0d61b", "url": "https://github.com/googleapis/java-spanner/commit/547a3c3136eeb7ba72942fe1031d622a29e0d61b", "message": "fix: address review comments", "committedDate": "2020-08-17T09:01:11Z", "type": "commit"}, {"oid": "4571e58a8a6b44fba75e86cb0e77ecf6e3fd2086", "url": "https://github.com/googleapis/java-spanner/commit/4571e58a8a6b44fba75e86cb0e77ecf6e3fd2086", "message": "fix: resolve review comment", "committedDate": "2020-08-17T13:23:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMyOTI0MQ==", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r475329241", "bodyText": "nit (don't have to change this, just a suggestion): it might be easier to test this / encapsulate the logic if we use a visitor pattern.", "author": "thiagotnunes", "createdAt": "2020-08-24T03:58:04Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SpannerOptions.java", "diffHunk": "@@ -121,6 +129,324 @@\n     CallCredentials getCallCredentials();\n   }\n \n+  /** Context key for the {@link CallContextConfigurator} to use. */\n+  public static final Context.Key<CallContextConfigurator> CALL_CONTEXT_CONFIGURATOR_KEY =\n+      Context.key(\"call-context-configurator\");\n+\n+  /**\n+   * {@link CallContextConfigurator} can be used to modify the {@link ApiCallContext} for one or\n+   * more specific RPCs. This can be used to set specific timeout value for RPCs or use specific\n+   * {@link CallCredentials} for an RPC. The {@link CallContextConfigurator} must be set as a value\n+   * on the {@link Context} using the {@link SpannerOptions#CALL_CONTEXT_CONFIGURATOR_KEY} key.\n+   *\n+   * <p>This API is meant for advanced users. Most users should instead use the {@link\n+   * SpannerCallContextTimeoutConfigurator} for setting timeouts per RPC.\n+   *\n+   * <p>Example usage:\n+   *\n+   * <pre>{@code\n+   * CallContextConfigurator configurator =\n+   *     new CallContextConfigurator() {\n+   *       public <ReqT, RespT> ApiCallContext configure(\n+   *           ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+   *         if (method == SpannerGrpc.getExecuteBatchDmlMethod()) {\n+   *           return GrpcCallContext.createDefault()\n+   *               .withCallOptions(CallOptions.DEFAULT.withDeadlineAfter(60L, TimeUnit.SECONDS));\n+   *         }\n+   *         return null;\n+   *       }\n+   *     };\n+   * Context context =\n+   *     Context.current().withValue(SpannerOptions.CALL_CONTEXT_CONFIGURATOR_KEY, configurator);\n+   * context.run(\n+   *     new Runnable() {\n+   *       public void run() {\n+   *         try {\n+   *           client\n+   *               .readWriteTransaction()\n+   *               .run(\n+   *                   new TransactionCallable<long[]>() {\n+   *                     public long[] run(TransactionContext transaction) throws Exception {\n+   *                       return transaction.batchUpdate(\n+   *                           ImmutableList.of(statement1, statement2));\n+   *                     }\n+   *                   });\n+   *         } catch (SpannerException e) {\n+   *           if (e.getErrorCode() == ErrorCode.DEADLINE_EXCEEDED) {\n+   *             // handle timeout exception.\n+   *           }\n+   *         }\n+   *       }\n+   *     });\n+   * }</pre>\n+   */\n+  public static interface CallContextConfigurator {\n+    /**\n+     * Configure a {@link ApiCallContext} for a specific RPC call.\n+     *\n+     * @param context The default context. This can be used to inspect the current values.\n+     * @param request The request that will be sent.\n+     * @param method The method that is being called.\n+     * @return An {@link ApiCallContext} that will be merged with the default {@link\n+     *     ApiCallContext}. If <code>null</code> is returned, no changes to the default {@link\n+     *     ApiCallContext} will be made.\n+     */\n+    @Nullable\n+    <ReqT, RespT> ApiCallContext configure(\n+        ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method);\n+  }\n+\n+  private enum SpannerMethod {\n+    COMMIT {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getCommitMethod();\n+      }\n+    },\n+    ROLLBACK {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getRollbackMethod();\n+      }\n+    },\n+\n+    EXECUTE_QUERY {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        // This also matches with Partitioned DML calls, but that call will override any timeout\n+        // settings anyway.\n+        return method == SpannerGrpc.getExecuteStreamingSqlMethod();\n+      }\n+    },\n+    READ {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getStreamingReadMethod();\n+      }\n+    },\n+    EXECUTE_UPDATE {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        if (method == SpannerGrpc.getExecuteSqlMethod()) {\n+          ExecuteSqlRequest sqlRequest = (ExecuteSqlRequest) request;\n+          return sqlRequest.getSeqno() != 0L;\n+        }\n+        return false;\n+      }\n+    },\n+    BATCH_UPDATE {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getExecuteBatchDmlMethod();\n+      }\n+    },\n+\n+    PARTITION_QUERY {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getPartitionQueryMethod();\n+      }\n+    },\n+    PARTITION_READ {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getPartitionReadMethod();\n+      }\n+    };\n+\n+    abstract <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method);\n+\n+    static <ReqT, RespT> SpannerMethod valueOf(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+      for (SpannerMethod m : SpannerMethod.values()) {\n+        if (m.isMethod(request, method)) {\n+          return m;\n+        }\n+      }\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Helper class to configure timeouts for specific Spanner RPCs. The {@link\n+   * SpannerCallContextTimeoutConfigurator} must be set as a value on the {@link Context} using the\n+   * {@link SpannerOptions#CALL_CONTEXT_CONFIGURATOR_KEY} key.\n+   *\n+   * <p>Example usage:\n+   *\n+   * <pre>{@code\n+   * // Create a context with a ExecuteQuery timeout of 10 seconds.\n+   * Context context =\n+   *     Context.current()\n+   *         .withValue(\n+   *             SpannerOptions.CALL_CONTEXT_CONFIGURATOR_KEY,\n+   *             SpannerCallContextTimeoutConfigurator.create()\n+   *                 .withExecuteQueryTimeout(Duration.ofSeconds(10L)));\n+   * context.run(\n+   *     new Runnable() {\n+   *       public void run() {\n+   *         try (ResultSet rs =\n+   *             client\n+   *                 .singleUse()\n+   *                 .executeQuery(\n+   *                     Statement.of(\n+   *                         \"SELECT SingerId, FirstName, LastName FROM Singers ORDER BY LastName\"))) {\n+   *           while (rs.next()) {\n+   *             System.out.printf(\"%d %s %s%n\", rs.getLong(0), rs.getString(1), rs.getString(2));\n+   *           }\n+   *         } catch (SpannerException e) {\n+   *           if (e.getErrorCode() == ErrorCode.DEADLINE_EXCEEDED) {\n+   *             // Handle timeout.\n+   *           }\n+   *         }\n+   *       }\n+   *     });\n+   * }</pre>\n+   */\n+  public static class SpannerCallContextTimeoutConfigurator implements CallContextConfigurator {\n+    private Duration commitTimeout;\n+    private Duration rollbackTimeout;\n+\n+    private Duration executeQueryTimeout;\n+    private Duration executeUpdateTimeout;\n+    private Duration batchUpdateTimeout;\n+    private Duration readTimeout;\n+\n+    private Duration partitionQueryTimeout;\n+    private Duration partitionReadTimeout;\n+\n+    public static SpannerCallContextTimeoutConfigurator create() {\n+      return new SpannerCallContextTimeoutConfigurator();\n+    }\n+\n+    private SpannerCallContextTimeoutConfigurator() {}\n+\n+    @Override\n+    public <ReqT, RespT> ApiCallContext configure(\n+        ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+      SpannerMethod spannerMethod = SpannerMethod.valueOf(request, method);\n+      if (spannerMethod == null) {\n+        return null;\n+      }\n+      switch (SpannerMethod.valueOf(request, method)) {", "originalCommit": "4571e58a8a6b44fba75e86cb0e77ecf6e3fd2086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwNzY1MA==", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r476407650", "bodyText": "That's probably a good idea. We would still need some kind of lookup table for the timeout / method combination (i.e. keeping them in a hash map or something), but it might make it somewhat simpler. I'll do that in a separate PR, as it won't change the public interface of it.", "author": "olavloite", "createdAt": "2020-08-25T12:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMyOTI0MQ=="}], "type": "inlineReview", "revised_code": null}]}