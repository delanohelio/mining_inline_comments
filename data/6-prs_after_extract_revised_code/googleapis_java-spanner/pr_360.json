{"pr_number": 360, "pr_title": "fix: retry pdml transaction on EOS internal error", "pr_createdAt": "2020-07-20T23:43:14Z", "pr_url": "https://github.com/googleapis/java-spanner/pull/360", "timeline": [{"oid": "8a1d6902c3ea7b2751d70b0c83e6d0f6793b5451", "url": "https://github.com/googleapis/java-spanner/commit/8a1d6902c3ea7b2751d70b0c83e6d0f6793b5451", "message": "fix: retries PDML transactions on EOS errors\n\nIt is possible to have the stream closed with an EOS internal error.\nThis should be retried by the client. On this PR we add this retry logic.", "committedDate": "2020-07-21T00:49:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4MDUxNA==", "url": "https://github.com/googleapis/java-spanner/pull/360#discussion_r457780514", "bodyText": "This method was just moved down (after the public methods).", "author": "thiagotnunes", "createdAt": "2020-07-21T01:22:46Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java", "diffHunk": "@@ -55,23 +56,6 @@\n     this.rpc = rpc;\n   }\n \n-  private ByteString initTransaction() {", "originalCommit": "8a1d6902c3ea7b2751d70b0c83e6d0f6793b5451", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3683b0890b0e7a016ba923d022287842bc21521", "chunk": "diff --git a/google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java b/google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java\ndeleted file mode 100644\nindex 1c4acbad..00000000\n--- a/google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java\n+++ /dev/null\n\n@@ -1,188 +0,0 @@\n-/*\n- * Copyright 2019 Google LLC\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.google.cloud.spanner;\n-\n-import static com.google.common.base.Preconditions.checkState;\n-\n-import com.google.api.gax.grpc.GrpcStatusCode;\n-import com.google.api.gax.rpc.DeadlineExceededException;\n-import com.google.api.gax.rpc.InternalException;\n-import com.google.api.gax.rpc.ServerStream;\n-import com.google.api.gax.rpc.UnavailableException;\n-import com.google.cloud.spanner.SessionImpl.SessionTransaction;\n-import com.google.cloud.spanner.spi.v1.SpannerRpc;\n-import com.google.common.base.Stopwatch;\n-import com.google.protobuf.ByteString;\n-import com.google.spanner.v1.BeginTransactionRequest;\n-import com.google.spanner.v1.ExecuteSqlRequest;\n-import com.google.spanner.v1.ExecuteSqlRequest.QueryMode;\n-import com.google.spanner.v1.PartialResultSet;\n-import com.google.spanner.v1.Transaction;\n-import com.google.spanner.v1.TransactionOptions;\n-import com.google.spanner.v1.TransactionSelector;\n-import io.grpc.Status.Code;\n-import io.opencensus.trace.Span;\n-import java.util.Map;\n-import java.util.concurrent.TimeUnit;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-import org.threeten.bp.Duration;\n-import org.threeten.bp.temporal.ChronoUnit;\n-\n-/** Partitioned DML transaction for bulk updates and deletes. */\n-class PartitionedDMLTransaction implements SessionTransaction {\n-  private static final Logger log = Logger.getLogger(PartitionedDMLTransaction.class.getName());\n-\n-  private final SessionImpl session;\n-  private final SpannerRpc rpc;\n-  private volatile boolean isValid = true;\n-\n-  PartitionedDMLTransaction(SessionImpl session, SpannerRpc rpc) {\n-    this.session = session;\n-    this.rpc = rpc;\n-  }\n-\n-  /**\n-   * Executes the {@link Statement} using a partitioned dml transaction with automatic retry if the\n-   * transaction was aborted. The update method uses the ExecuteStreamingSql RPC to execute the\n-   * statement, and will retry the stream if an {@link UnavailableException} is thrown, using the\n-   * last seen resume token if the server returns any.\n-   */\n-  long executeStreamingPartitionedUpdate(final Statement statement, final Duration timeout) {\n-    checkState(isValid, \"Partitioned DML has been invalidated by a new operation on the session\");\n-    log.log(Level.FINER, \"Starting PartitionedUpdate statement\");\n-    boolean foundStats = false;\n-    long updateCount = 0L;\n-    Stopwatch stopWatch = createStopwatchStarted();\n-    try {\n-      // Loop to catch AbortedExceptions.\n-      while (true) {\n-        ByteString resumeToken = ByteString.EMPTY;\n-        try {\n-          ByteString transactionId = initTransaction();\n-          final ExecuteSqlRequest.Builder builder =\n-              ExecuteSqlRequest.newBuilder()\n-                  .setSql(statement.getSql())\n-                  .setQueryMode(QueryMode.NORMAL)\n-                  .setSession(session.getName())\n-                  .setTransaction(TransactionSelector.newBuilder().setId(transactionId).build());\n-          Map<String, Value> stmtParameters = statement.getParameters();\n-          if (!stmtParameters.isEmpty()) {\n-            com.google.protobuf.Struct.Builder paramsBuilder = builder.getParamsBuilder();\n-            for (Map.Entry<String, Value> param : stmtParameters.entrySet()) {\n-              paramsBuilder.putFields(param.getKey(), param.getValue().toProto());\n-              builder.putParamTypes(param.getKey(), param.getValue().getType().toProto());\n-            }\n-          }\n-          while (true) {\n-            Duration remainingTimeout =\n-                timeout.minus(stopWatch.elapsed(TimeUnit.MILLISECONDS), ChronoUnit.MILLIS);\n-            if (remainingTimeout.isNegative() || remainingTimeout.isZero()) {\n-              // The total deadline has been exceeded while retrying.\n-              throw new DeadlineExceededException(\n-                  null, GrpcStatusCode.of(Code.DEADLINE_EXCEEDED), false);\n-            }\n-            try {\n-              builder.setResumeToken(resumeToken);\n-              ServerStream<PartialResultSet> stream =\n-                  rpc.executeStreamingPartitionedDml(\n-                      builder.build(), session.getOptions(), remainingTimeout);\n-              for (PartialResultSet rs : stream) {\n-                if (rs.getResumeToken() != null && !ByteString.EMPTY.equals(rs.getResumeToken())) {\n-                  resumeToken = rs.getResumeToken();\n-                }\n-                if (rs.hasStats()) {\n-                  foundStats = true;\n-                  updateCount += rs.getStats().getRowCountLowerBound();\n-                }\n-              }\n-              break;\n-            } catch (UnavailableException | InternalException e) {\n-              // Retry the stream in the same transaction if the stream breaks with\n-              // UnavailableException and we have a resume token. Otherwise, we just retry the\n-              // entire transaction.\n-              if (shouldResumeOrRestartTransaction(e)) {\n-                if (!ByteString.EMPTY.equals(resumeToken)) {\n-                  log.log(\n-                      Level.FINER,\n-                      \"Retrying PartitionedDml stream using resume token '\"\n-                          + resumeToken.toStringUtf8()\n-                          + \"' because of broken stream\",\n-                      e);\n-                } else {\n-                  throw new com.google.api.gax.rpc.AbortedException(\n-                      e, GrpcStatusCode.of(Code.ABORTED), true);\n-                }\n-              } else {\n-                throw e;\n-              }\n-            }\n-          }\n-          break;\n-        } catch (com.google.api.gax.rpc.AbortedException e) {\n-          // Retry using a new transaction but with the same session if the transaction is aborted.\n-          log.log(Level.FINER, \"Retrying PartitionedDml transaction after AbortedException\", e);\n-        }\n-      }\n-      if (!foundStats) {\n-        throw SpannerExceptionFactory.newSpannerException(\n-            ErrorCode.INVALID_ARGUMENT,\n-            \"Partitioned DML response missing stats possibly due to non-DML statement as input\");\n-      }\n-      log.log(Level.FINER, \"Finished PartitionedUpdate statement\");\n-      return updateCount;\n-    } catch (Exception e) {\n-      throw SpannerExceptionFactory.newSpannerException(e);\n-    }\n-  }\n-\n-  Stopwatch createStopwatchStarted() {\n-    return Stopwatch.createStarted();\n-  }\n-\n-  @Override\n-  public void invalidate() {\n-    isValid = false;\n-  }\n-\n-  // No-op method needed to implement SessionTransaction interface.\n-  @Override\n-  public void setSpan(Span span) {}\n-\n-  private ByteString initTransaction() {\n-    final BeginTransactionRequest request =\n-        BeginTransactionRequest.newBuilder()\n-            .setSession(session.getName())\n-            .setOptions(\n-                TransactionOptions.newBuilder()\n-                    .setPartitionedDml(TransactionOptions.PartitionedDml.getDefaultInstance()))\n-            .build();\n-    Transaction txn = rpc.beginTransaction(request, session.getOptions());\n-    if (txn.getId().isEmpty()) {\n-      throw SpannerExceptionFactory.newSpannerException(\n-          ErrorCode.INTERNAL,\n-          \"Failed to init transaction, missing transaction id\\n\" + session.getName());\n-    }\n-    return txn.getId();\n-  }\n-\n-  private boolean shouldResumeOrRestartTransaction(Exception e) {\n-    return e instanceof UnavailableException\n-        || (e instanceof InternalException\n-            && e.getMessage().contains(\"Received unexpected EOS on DATA frame from server\"));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4MDYxNQ==", "url": "https://github.com/googleapis/java-spanner/pull/360#discussion_r457780615", "bodyText": "In this catch block we retry on EOS exception.", "author": "thiagotnunes", "createdAt": "2020-07-21T01:23:06Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java", "diffHunk": "@@ -127,20 +111,24 @@ long executeStreamingPartitionedUpdate(final Statement statement, final Duration\n                 }\n               }\n               break;\n-            } catch (UnavailableException e) {\n+            } catch (UnavailableException | InternalException e) {", "originalCommit": "8a1d6902c3ea7b2751d70b0c83e6d0f6793b5451", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3683b0890b0e7a016ba923d022287842bc21521", "chunk": "diff --git a/google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java b/google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java\ndeleted file mode 100644\nindex 1c4acbad..00000000\n--- a/google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java\n+++ /dev/null\n\n@@ -1,188 +0,0 @@\n-/*\n- * Copyright 2019 Google LLC\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.google.cloud.spanner;\n-\n-import static com.google.common.base.Preconditions.checkState;\n-\n-import com.google.api.gax.grpc.GrpcStatusCode;\n-import com.google.api.gax.rpc.DeadlineExceededException;\n-import com.google.api.gax.rpc.InternalException;\n-import com.google.api.gax.rpc.ServerStream;\n-import com.google.api.gax.rpc.UnavailableException;\n-import com.google.cloud.spanner.SessionImpl.SessionTransaction;\n-import com.google.cloud.spanner.spi.v1.SpannerRpc;\n-import com.google.common.base.Stopwatch;\n-import com.google.protobuf.ByteString;\n-import com.google.spanner.v1.BeginTransactionRequest;\n-import com.google.spanner.v1.ExecuteSqlRequest;\n-import com.google.spanner.v1.ExecuteSqlRequest.QueryMode;\n-import com.google.spanner.v1.PartialResultSet;\n-import com.google.spanner.v1.Transaction;\n-import com.google.spanner.v1.TransactionOptions;\n-import com.google.spanner.v1.TransactionSelector;\n-import io.grpc.Status.Code;\n-import io.opencensus.trace.Span;\n-import java.util.Map;\n-import java.util.concurrent.TimeUnit;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-import org.threeten.bp.Duration;\n-import org.threeten.bp.temporal.ChronoUnit;\n-\n-/** Partitioned DML transaction for bulk updates and deletes. */\n-class PartitionedDMLTransaction implements SessionTransaction {\n-  private static final Logger log = Logger.getLogger(PartitionedDMLTransaction.class.getName());\n-\n-  private final SessionImpl session;\n-  private final SpannerRpc rpc;\n-  private volatile boolean isValid = true;\n-\n-  PartitionedDMLTransaction(SessionImpl session, SpannerRpc rpc) {\n-    this.session = session;\n-    this.rpc = rpc;\n-  }\n-\n-  /**\n-   * Executes the {@link Statement} using a partitioned dml transaction with automatic retry if the\n-   * transaction was aborted. The update method uses the ExecuteStreamingSql RPC to execute the\n-   * statement, and will retry the stream if an {@link UnavailableException} is thrown, using the\n-   * last seen resume token if the server returns any.\n-   */\n-  long executeStreamingPartitionedUpdate(final Statement statement, final Duration timeout) {\n-    checkState(isValid, \"Partitioned DML has been invalidated by a new operation on the session\");\n-    log.log(Level.FINER, \"Starting PartitionedUpdate statement\");\n-    boolean foundStats = false;\n-    long updateCount = 0L;\n-    Stopwatch stopWatch = createStopwatchStarted();\n-    try {\n-      // Loop to catch AbortedExceptions.\n-      while (true) {\n-        ByteString resumeToken = ByteString.EMPTY;\n-        try {\n-          ByteString transactionId = initTransaction();\n-          final ExecuteSqlRequest.Builder builder =\n-              ExecuteSqlRequest.newBuilder()\n-                  .setSql(statement.getSql())\n-                  .setQueryMode(QueryMode.NORMAL)\n-                  .setSession(session.getName())\n-                  .setTransaction(TransactionSelector.newBuilder().setId(transactionId).build());\n-          Map<String, Value> stmtParameters = statement.getParameters();\n-          if (!stmtParameters.isEmpty()) {\n-            com.google.protobuf.Struct.Builder paramsBuilder = builder.getParamsBuilder();\n-            for (Map.Entry<String, Value> param : stmtParameters.entrySet()) {\n-              paramsBuilder.putFields(param.getKey(), param.getValue().toProto());\n-              builder.putParamTypes(param.getKey(), param.getValue().getType().toProto());\n-            }\n-          }\n-          while (true) {\n-            Duration remainingTimeout =\n-                timeout.minus(stopWatch.elapsed(TimeUnit.MILLISECONDS), ChronoUnit.MILLIS);\n-            if (remainingTimeout.isNegative() || remainingTimeout.isZero()) {\n-              // The total deadline has been exceeded while retrying.\n-              throw new DeadlineExceededException(\n-                  null, GrpcStatusCode.of(Code.DEADLINE_EXCEEDED), false);\n-            }\n-            try {\n-              builder.setResumeToken(resumeToken);\n-              ServerStream<PartialResultSet> stream =\n-                  rpc.executeStreamingPartitionedDml(\n-                      builder.build(), session.getOptions(), remainingTimeout);\n-              for (PartialResultSet rs : stream) {\n-                if (rs.getResumeToken() != null && !ByteString.EMPTY.equals(rs.getResumeToken())) {\n-                  resumeToken = rs.getResumeToken();\n-                }\n-                if (rs.hasStats()) {\n-                  foundStats = true;\n-                  updateCount += rs.getStats().getRowCountLowerBound();\n-                }\n-              }\n-              break;\n-            } catch (UnavailableException | InternalException e) {\n-              // Retry the stream in the same transaction if the stream breaks with\n-              // UnavailableException and we have a resume token. Otherwise, we just retry the\n-              // entire transaction.\n-              if (shouldResumeOrRestartTransaction(e)) {\n-                if (!ByteString.EMPTY.equals(resumeToken)) {\n-                  log.log(\n-                      Level.FINER,\n-                      \"Retrying PartitionedDml stream using resume token '\"\n-                          + resumeToken.toStringUtf8()\n-                          + \"' because of broken stream\",\n-                      e);\n-                } else {\n-                  throw new com.google.api.gax.rpc.AbortedException(\n-                      e, GrpcStatusCode.of(Code.ABORTED), true);\n-                }\n-              } else {\n-                throw e;\n-              }\n-            }\n-          }\n-          break;\n-        } catch (com.google.api.gax.rpc.AbortedException e) {\n-          // Retry using a new transaction but with the same session if the transaction is aborted.\n-          log.log(Level.FINER, \"Retrying PartitionedDml transaction after AbortedException\", e);\n-        }\n-      }\n-      if (!foundStats) {\n-        throw SpannerExceptionFactory.newSpannerException(\n-            ErrorCode.INVALID_ARGUMENT,\n-            \"Partitioned DML response missing stats possibly due to non-DML statement as input\");\n-      }\n-      log.log(Level.FINER, \"Finished PartitionedUpdate statement\");\n-      return updateCount;\n-    } catch (Exception e) {\n-      throw SpannerExceptionFactory.newSpannerException(e);\n-    }\n-  }\n-\n-  Stopwatch createStopwatchStarted() {\n-    return Stopwatch.createStarted();\n-  }\n-\n-  @Override\n-  public void invalidate() {\n-    isValid = false;\n-  }\n-\n-  // No-op method needed to implement SessionTransaction interface.\n-  @Override\n-  public void setSpan(Span span) {}\n-\n-  private ByteString initTransaction() {\n-    final BeginTransactionRequest request =\n-        BeginTransactionRequest.newBuilder()\n-            .setSession(session.getName())\n-            .setOptions(\n-                TransactionOptions.newBuilder()\n-                    .setPartitionedDml(TransactionOptions.PartitionedDml.getDefaultInstance()))\n-            .build();\n-    Transaction txn = rpc.beginTransaction(request, session.getOptions());\n-    if (txn.getId().isEmpty()) {\n-      throw SpannerExceptionFactory.newSpannerException(\n-          ErrorCode.INTERNAL,\n-          \"Failed to init transaction, missing transaction id\\n\" + session.getName());\n-    }\n-    return txn.getId();\n-  }\n-\n-  private boolean shouldResumeOrRestartTransaction(Exception e) {\n-    return e instanceof UnavailableException\n-        || (e instanceof InternalException\n-            && e.getMessage().contains(\"Received unexpected EOS on DATA frame from server\"));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4MDg5Mw==", "url": "https://github.com/googleapis/java-spanner/pull/360#discussion_r457780893", "bodyText": "This is hacky, but unfortunately we do not get a specific exception for this error, so we have to proxy through the exception message. This follows the approach taken in the bigquery client: https://github.com/googleapis/java-bigquerystorage/pull/263/files.", "author": "thiagotnunes", "createdAt": "2020-07-21T01:24:08Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java", "diffHunk": "@@ -174,4 +162,27 @@ public void invalidate() {\n   // No-op method needed to implement SessionTransaction interface.\n   @Override\n   public void setSpan(Span span) {}\n+\n+  private ByteString initTransaction() {\n+    final BeginTransactionRequest request =\n+        BeginTransactionRequest.newBuilder()\n+            .setSession(session.getName())\n+            .setOptions(\n+                TransactionOptions.newBuilder()\n+                    .setPartitionedDml(TransactionOptions.PartitionedDml.getDefaultInstance()))\n+            .build();\n+    Transaction txn = rpc.beginTransaction(request, session.getOptions());\n+    if (txn.getId().isEmpty()) {\n+      throw SpannerExceptionFactory.newSpannerException(\n+          ErrorCode.INTERNAL,\n+          \"Failed to init transaction, missing transaction id\\n\" + session.getName());\n+    }\n+    return txn.getId();\n+  }\n+\n+  private boolean shouldResumeOrRestartTransaction(Exception e) {\n+    return e instanceof UnavailableException\n+        || (e instanceof InternalException\n+            && e.getMessage().contains(\"Received unexpected EOS on DATA frame from server\"));", "originalCommit": "8a1d6902c3ea7b2751d70b0c83e6d0f6793b5451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNDU1Ng==", "url": "https://github.com/googleapis/java-spanner/pull/360#discussion_r458534556", "bodyText": "The same error is also retried for streaming queries, and this check could probably use the existing check in SpannerExceptionFactory: \n  \n    \n      java-spanner/google-cloud-spanner/src/main/java/com/google/cloud/spanner/SpannerExceptionFactory.java\n    \n    \n         Line 233\n      in\n      b264100\n    \n    \n    \n    \n\n        \n          \n           private static boolean isRetryable(ErrorCode code, @Nullable Throwable cause) { \n        \n    \n  \n\n. It's still just as hacky, but it would keep it confined to one method.", "author": "olavloite", "createdAt": "2020-07-22T04:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4MDg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d3683b0890b0e7a016ba923d022287842bc21521", "chunk": "diff --git a/google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java b/google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java\ndeleted file mode 100644\nindex 1c4acbad..00000000\n--- a/google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java\n+++ /dev/null\n\n@@ -1,188 +0,0 @@\n-/*\n- * Copyright 2019 Google LLC\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.google.cloud.spanner;\n-\n-import static com.google.common.base.Preconditions.checkState;\n-\n-import com.google.api.gax.grpc.GrpcStatusCode;\n-import com.google.api.gax.rpc.DeadlineExceededException;\n-import com.google.api.gax.rpc.InternalException;\n-import com.google.api.gax.rpc.ServerStream;\n-import com.google.api.gax.rpc.UnavailableException;\n-import com.google.cloud.spanner.SessionImpl.SessionTransaction;\n-import com.google.cloud.spanner.spi.v1.SpannerRpc;\n-import com.google.common.base.Stopwatch;\n-import com.google.protobuf.ByteString;\n-import com.google.spanner.v1.BeginTransactionRequest;\n-import com.google.spanner.v1.ExecuteSqlRequest;\n-import com.google.spanner.v1.ExecuteSqlRequest.QueryMode;\n-import com.google.spanner.v1.PartialResultSet;\n-import com.google.spanner.v1.Transaction;\n-import com.google.spanner.v1.TransactionOptions;\n-import com.google.spanner.v1.TransactionSelector;\n-import io.grpc.Status.Code;\n-import io.opencensus.trace.Span;\n-import java.util.Map;\n-import java.util.concurrent.TimeUnit;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-import org.threeten.bp.Duration;\n-import org.threeten.bp.temporal.ChronoUnit;\n-\n-/** Partitioned DML transaction for bulk updates and deletes. */\n-class PartitionedDMLTransaction implements SessionTransaction {\n-  private static final Logger log = Logger.getLogger(PartitionedDMLTransaction.class.getName());\n-\n-  private final SessionImpl session;\n-  private final SpannerRpc rpc;\n-  private volatile boolean isValid = true;\n-\n-  PartitionedDMLTransaction(SessionImpl session, SpannerRpc rpc) {\n-    this.session = session;\n-    this.rpc = rpc;\n-  }\n-\n-  /**\n-   * Executes the {@link Statement} using a partitioned dml transaction with automatic retry if the\n-   * transaction was aborted. The update method uses the ExecuteStreamingSql RPC to execute the\n-   * statement, and will retry the stream if an {@link UnavailableException} is thrown, using the\n-   * last seen resume token if the server returns any.\n-   */\n-  long executeStreamingPartitionedUpdate(final Statement statement, final Duration timeout) {\n-    checkState(isValid, \"Partitioned DML has been invalidated by a new operation on the session\");\n-    log.log(Level.FINER, \"Starting PartitionedUpdate statement\");\n-    boolean foundStats = false;\n-    long updateCount = 0L;\n-    Stopwatch stopWatch = createStopwatchStarted();\n-    try {\n-      // Loop to catch AbortedExceptions.\n-      while (true) {\n-        ByteString resumeToken = ByteString.EMPTY;\n-        try {\n-          ByteString transactionId = initTransaction();\n-          final ExecuteSqlRequest.Builder builder =\n-              ExecuteSqlRequest.newBuilder()\n-                  .setSql(statement.getSql())\n-                  .setQueryMode(QueryMode.NORMAL)\n-                  .setSession(session.getName())\n-                  .setTransaction(TransactionSelector.newBuilder().setId(transactionId).build());\n-          Map<String, Value> stmtParameters = statement.getParameters();\n-          if (!stmtParameters.isEmpty()) {\n-            com.google.protobuf.Struct.Builder paramsBuilder = builder.getParamsBuilder();\n-            for (Map.Entry<String, Value> param : stmtParameters.entrySet()) {\n-              paramsBuilder.putFields(param.getKey(), param.getValue().toProto());\n-              builder.putParamTypes(param.getKey(), param.getValue().getType().toProto());\n-            }\n-          }\n-          while (true) {\n-            Duration remainingTimeout =\n-                timeout.minus(stopWatch.elapsed(TimeUnit.MILLISECONDS), ChronoUnit.MILLIS);\n-            if (remainingTimeout.isNegative() || remainingTimeout.isZero()) {\n-              // The total deadline has been exceeded while retrying.\n-              throw new DeadlineExceededException(\n-                  null, GrpcStatusCode.of(Code.DEADLINE_EXCEEDED), false);\n-            }\n-            try {\n-              builder.setResumeToken(resumeToken);\n-              ServerStream<PartialResultSet> stream =\n-                  rpc.executeStreamingPartitionedDml(\n-                      builder.build(), session.getOptions(), remainingTimeout);\n-              for (PartialResultSet rs : stream) {\n-                if (rs.getResumeToken() != null && !ByteString.EMPTY.equals(rs.getResumeToken())) {\n-                  resumeToken = rs.getResumeToken();\n-                }\n-                if (rs.hasStats()) {\n-                  foundStats = true;\n-                  updateCount += rs.getStats().getRowCountLowerBound();\n-                }\n-              }\n-              break;\n-            } catch (UnavailableException | InternalException e) {\n-              // Retry the stream in the same transaction if the stream breaks with\n-              // UnavailableException and we have a resume token. Otherwise, we just retry the\n-              // entire transaction.\n-              if (shouldResumeOrRestartTransaction(e)) {\n-                if (!ByteString.EMPTY.equals(resumeToken)) {\n-                  log.log(\n-                      Level.FINER,\n-                      \"Retrying PartitionedDml stream using resume token '\"\n-                          + resumeToken.toStringUtf8()\n-                          + \"' because of broken stream\",\n-                      e);\n-                } else {\n-                  throw new com.google.api.gax.rpc.AbortedException(\n-                      e, GrpcStatusCode.of(Code.ABORTED), true);\n-                }\n-              } else {\n-                throw e;\n-              }\n-            }\n-          }\n-          break;\n-        } catch (com.google.api.gax.rpc.AbortedException e) {\n-          // Retry using a new transaction but with the same session if the transaction is aborted.\n-          log.log(Level.FINER, \"Retrying PartitionedDml transaction after AbortedException\", e);\n-        }\n-      }\n-      if (!foundStats) {\n-        throw SpannerExceptionFactory.newSpannerException(\n-            ErrorCode.INVALID_ARGUMENT,\n-            \"Partitioned DML response missing stats possibly due to non-DML statement as input\");\n-      }\n-      log.log(Level.FINER, \"Finished PartitionedUpdate statement\");\n-      return updateCount;\n-    } catch (Exception e) {\n-      throw SpannerExceptionFactory.newSpannerException(e);\n-    }\n-  }\n-\n-  Stopwatch createStopwatchStarted() {\n-    return Stopwatch.createStarted();\n-  }\n-\n-  @Override\n-  public void invalidate() {\n-    isValid = false;\n-  }\n-\n-  // No-op method needed to implement SessionTransaction interface.\n-  @Override\n-  public void setSpan(Span span) {}\n-\n-  private ByteString initTransaction() {\n-    final BeginTransactionRequest request =\n-        BeginTransactionRequest.newBuilder()\n-            .setSession(session.getName())\n-            .setOptions(\n-                TransactionOptions.newBuilder()\n-                    .setPartitionedDml(TransactionOptions.PartitionedDml.getDefaultInstance()))\n-            .build();\n-    Transaction txn = rpc.beginTransaction(request, session.getOptions());\n-    if (txn.getId().isEmpty()) {\n-      throw SpannerExceptionFactory.newSpannerException(\n-          ErrorCode.INTERNAL,\n-          \"Failed to init transaction, missing transaction id\\n\" + session.getName());\n-    }\n-    return txn.getId();\n-  }\n-\n-  private boolean shouldResumeOrRestartTransaction(Exception e) {\n-    return e instanceof UnavailableException\n-        || (e instanceof InternalException\n-            && e.getMessage().contains(\"Received unexpected EOS on DATA frame from server\"));\n-  }\n-}\n"}}, {"oid": "d3683b0890b0e7a016ba923d022287842bc21521", "url": "https://github.com/googleapis/java-spanner/commit/d3683b0890b0e7a016ba923d022287842bc21521", "message": "Merge branch 'master' of https://github.com/googleapis/java-spanner into retry-pdml-on-eos", "committedDate": "2020-07-23T02:00:01Z", "type": "commit"}, {"oid": "88f4bb59c750b2c9ce2da5f7e881a1c4efcb98cc", "url": "https://github.com/googleapis/java-spanner/commit/88f4bb59c750b2c9ce2da5f7e881a1c4efcb98cc", "message": "fix: retries InternalException on PDML transaction\n\nWhen the exception is an EOS, we should retry the exception.", "committedDate": "2020-07-23T02:03:20Z", "type": "commit"}, {"oid": "b1450589f590dff2511ebe0d309e142019443fdb", "url": "https://github.com/googleapis/java-spanner/commit/b1450589f590dff2511ebe0d309e142019443fdb", "message": "refactor: re-uses spanner exception retry logic\n\nRe-uses the retry logic applied by the spanner exception factory for\nretrying EOS internal exceptions in pdml transactions.", "committedDate": "2020-07-23T06:55:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0OTA2OA==", "url": "https://github.com/googleapis/java-spanner/pull/360#discussion_r459249068", "bodyText": "I extracted these predicates into their own classes that are now exposed to the PartitionedDmlTransaction. This was the cleanest / lowest impact way I could find to de-duplicate the EOS retryable logic.", "author": "thiagotnunes", "createdAt": "2020-07-23T06:58:22Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SpannerExceptionFactory.java", "diffHunk": "@@ -257,35 +256,8 @@ private static boolean hasCauseMatching(\n   }\n \n   private static class Matchers {\n-    static final Predicate<Throwable> isRetryableInternalError =", "originalCommit": "b1450589f590dff2511ebe0d309e142019443fdb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "b8da6c1d96b04815a97024bc82d324a1b8abe221", "url": "https://github.com/googleapis/java-spanner/commit/b8da6c1d96b04815a97024bc82d324a1b8abe221", "message": "fix: adds / changes headers in files", "committedDate": "2020-07-23T07:02:35Z", "type": "commit"}, {"oid": "3be1346fabeb75a83def2b23da95e8f4622bc0a6", "url": "https://github.com/googleapis/java-spanner/commit/3be1346fabeb75a83def2b23da95e8f4622bc0a6", "message": "fix: fixes formatting", "committedDate": "2020-07-23T07:30:59Z", "type": "commit"}, {"oid": "5edd3eb3b6f42bf8c7a895a031359520da16b22d", "url": "https://github.com/googleapis/java-spanner/commit/5edd3eb3b6f42bf8c7a895a031359520da16b22d", "message": "refactor: removes unused annotation", "committedDate": "2020-07-23T07:33:43Z", "type": "commit"}, {"oid": "1ff90921cfdffd2f59f6011deef97c60c23365a5", "url": "https://github.com/googleapis/java-spanner/commit/1ff90921cfdffd2f59f6011deef97c60c23365a5", "message": "dummy: to re-trigger tests", "committedDate": "2020-07-23T23:24:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjgwNA==", "url": "https://github.com/googleapis/java-spanner/pull/360#discussion_r459836804", "bodyText": "Here and below, if we could remove the references to internal issues that would be great. I don't know why they were there before. Folks working on this repo are unlikely to have access to those so no point exposing them.", "author": "skuruppu", "createdAt": "2020-07-24T03:33:50Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/IsRetryableInternalError.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.gax.rpc.InternalException;\n+import com.google.common.base.Predicate;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+\n+public class IsRetryableInternalError implements Predicate<Throwable> {\n+\n+  private static final String HTTP2_ERROR_MESSAGE = \"HTTP/2 error code: INTERNAL_ERROR\";\n+  private static final String CONNECTION_CLOSED_ERROR_MESSAGE =\n+      \"Connection closed with unknown cause\";\n+  private static final String EOS_ERROR_MESSAGE =\n+      \"Received unexpected EOS on DATA frame from server\";\n+\n+  @Override\n+  public boolean apply(Throwable cause) {\n+    if (isInternalError(cause)) {\n+      if (cause.getMessage().contains(HTTP2_ERROR_MESSAGE)) {\n+        // See b/25451313.", "originalCommit": "1ff90921cfdffd2f59f6011deef97c60c23365a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg0NzI1NA==", "url": "https://github.com/googleapis/java-spanner/pull/360#discussion_r459847254", "bodyText": "No worries, will tackle this in a following PR.", "author": "thiagotnunes", "createdAt": "2020-07-24T04:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjgwNA=="}], "type": "inlineReview", "revised_code": null}]}