{"pr_number": 1447, "pr_title": "Cancel long running or cancelled async queries", "pr_createdAt": "2020-07-17T19:50:43Z", "pr_url": "https://github.com/yahoo/elide/pull/1447", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MjkyMA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456672920", "bodyText": "we should expand this where clause to pull records based on create_time also as after sometime CANCELLED query list will expand. Something like create_time after current-date minus maxRunTimeSeconds;", "author": "moizarafat", "createdAt": "2020-07-17T21:02:24Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -195,4 +199,32 @@ protected Object executeInTransaction(DataStore dataStore, Transactional action)\n         }\n         return result;\n     }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection() {\n+        Collection<AsyncQuery> asyncQueryList = null;\n+\n+        log.debug(\"getActiveAsyncQueryCollection\");\n+        String filterExpression = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NTkyMw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456675923", "bodyText": "Also the FilterExpression should be the method argument as elide will be controlling the Filter, where as users can provide their implementation of getActiveAsyncQueryCollection method.", "author": "moizarafat", "createdAt": "2020-07-17T21:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MjkyMA=="}], "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c5cc21358..6cfe91e10 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n\n@@ -202,28 +175,22 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> getActiveAsyncQueryCollection() {\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n         Collection<AsyncQuery> asyncQueryList = null;\n-\n-        log.debug(\"getActiveAsyncQueryCollection\");\n-        String filterExpression = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n-                + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\";\n-\n+        log.debug(\"loadAsyncQueryCollection\");\n         try {\n-            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                     AsyncQuery.class, false);\n             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n \n                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n                         .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n+                        .filterExpression(filterExpression)\n                         .build();\n                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n                 return loaded;\n             });\n         } catch (Exception e) {\n             log.error(\"Exception: {}\", e);\n+            throw new IllegalStateException(e);\n         }\n         return asyncQueryList;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MzEwNw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456673107", "bodyText": "throw the exception as IllegalStateException.", "author": "moizarafat", "createdAt": "2020-07-17T21:02:55Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -195,4 +199,32 @@ protected Object executeInTransaction(DataStore dataStore, Transactional action)\n         }\n         return result;\n     }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection() {\n+        Collection<AsyncQuery> asyncQueryList = null;\n+\n+        log.debug(\"getActiveAsyncQueryCollection\");\n+        String filterExpression = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n+                + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\";\n+\n+        try {\n+            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                     AsyncQuery.class, false);\n+            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                return loaded;\n+            });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c5cc21358..6cfe91e10 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n\n@@ -202,28 +175,22 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> getActiveAsyncQueryCollection() {\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n         Collection<AsyncQuery> asyncQueryList = null;\n-\n-        log.debug(\"getActiveAsyncQueryCollection\");\n-        String filterExpression = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n-                + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\";\n-\n+        log.debug(\"loadAsyncQueryCollection\");\n         try {\n-            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                     AsyncQuery.class, false);\n             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n \n                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n                         .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n+                        .filterExpression(filterExpression)\n                         .build();\n                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n                 return loaded;\n             });\n         } catch (Exception e) {\n             log.error(\"Exception: {}\", e);\n+            throw new IllegalStateException(e);\n         }\n         return asyncQueryList;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MzgxNQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456673815", "bodyText": "we should update the getRunningTransactions method to get this and we can remove the getter method on TransactionMap as its not used anyplace else.", "author": "moizarafat", "createdAt": "2020-07-17T21:04:48Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.TransactionRegistry;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getTransactionMap();", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\nindex 717a4b9c3..e487327b1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n\n@@ -5,21 +5,38 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.Path.PathElement;\n+import com.yahoo.elide.core.RequestScope;\n import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.InPredicate;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+\n+import com.google.common.collect.Sets;\n \n import lombok.AllArgsConstructor;\n import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n \n /**\n  * Runnable thread for cancelling AsyncQuery transactions\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NzIyNg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456677226", "bodyText": "we can combine these two if statements with an OR", "author": "moizarafat", "createdAt": "2020-07-17T21:13:41Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.TransactionRegistry;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getTransactionMap();\n+            Collection<AsyncQuery> asyncQueryCollection = asyncQueryDao.getActiveAsyncQueryCollection();\n+\n+            for (Map.Entry<UUID, DataStoreTransaction> entry : runningTransactionMap.entrySet()) {\n+                for (AsyncQuery obj : asyncQueryCollection) {\n+                    if (obj.getRequestId().trim().equals(entry.getKey().toString().trim())) {\n+                        Date currentDate = new Date(System.currentTimeMillis());\n+                        long diffInMillies = Math.abs(obj.getUpdatedOn().getTime() - currentDate.getTime());\n+                        long diffInSecs = TimeUnit.SECONDS.convert(diffInMillies, TimeUnit.MILLISECONDS);\n+                        if (obj.getStatus().equals(QueryStatus.CANCELLED)) {\n+                            log.debug(\"Async Query Cancelled: \" + obj.getId());\n+                            entry.getValue().cancel();\n+                        } else if (diffInSecs > maxRunTimeSeconds) {", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\nindex 717a4b9c3..e487327b1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n\n@@ -5,21 +5,38 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.Path.PathElement;\n+import com.yahoo.elide.core.RequestScope;\n import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.InPredicate;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+\n+import com.google.common.collect.Sets;\n \n import lombok.AllArgsConstructor;\n import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n \n /**\n  * Runnable thread for cancelling AsyncQuery transactions\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4MTg2Mw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456681863", "bodyText": "a couple of things we can probably do to improve the performance here:\ni) When the match occurs in if clause, after processing the if block we should break the inner loop\nii) we should remove the object from asyncQueryCollection when a match happens so that the size keeps reducing as the transaction loop move on.", "author": "moizarafat", "createdAt": "2020-07-17T21:27:29Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.TransactionRegistry;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getTransactionMap();\n+            Collection<AsyncQuery> asyncQueryCollection = asyncQueryDao.getActiveAsyncQueryCollection();\n+\n+            for (Map.Entry<UUID, DataStoreTransaction> entry : runningTransactionMap.entrySet()) {\n+                for (AsyncQuery obj : asyncQueryCollection) {\n+                    if (obj.getRequestId().trim().equals(entry.getKey().toString().trim())) {\n+                        Date currentDate = new Date(System.currentTimeMillis());\n+                        long diffInMillies = Math.abs(obj.getUpdatedOn().getTime() - currentDate.getTime());\n+                        long diffInSecs = TimeUnit.SECONDS.convert(diffInMillies, TimeUnit.MILLISECONDS);\n+                        if (obj.getStatus().equals(QueryStatus.CANCELLED)) {\n+                            log.debug(\"Async Query Cancelled: \" + obj.getId());\n+                            entry.getValue().cancel();\n+                        } else if (diffInSecs > maxRunTimeSeconds) {\n+                            log.debug(\"Async Query Cancelled: \" + obj.getId());\n+                            entry.getValue().cancel();\n+                        }", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\nindex 717a4b9c3..e487327b1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n\n@@ -5,21 +5,38 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.Path.PathElement;\n+import com.yahoo.elide.core.RequestScope;\n import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.InPredicate;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+\n+import com.google.common.collect.Sets;\n \n import lombok.AllArgsConstructor;\n import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n \n /**\n  * Runnable thread for cancelling AsyncQuery transactions\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4Mjk2Ng==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456682966", "bodyText": "i think getAsyncQueryCancelIntervalSeconds sounds better as Delay could be taken as differently.", "author": "moizarafat", "createdAt": "2020-07-17T21:31:15Z", "path": "elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java", "diffHunk": "@@ -234,6 +234,15 @@ default Integer getAsyncQueryCleanupDays() {\n         return 7;\n     }\n \n+    /**\n+     * Number of seconds  between async query cancellation checks.\n+     *\n+     * @return Default: 300\n+     */\n+    default Integer getAsyncQueryCancelDelaySeconds() {", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\nindex 851b0dcfb..c527d814a 100644\n--- a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n+++ b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n\n@@ -234,15 +244,6 @@ public interface ElideStandaloneSettings {\n         return 7;\n     }\n \n-    /**\n-     * Number of seconds  between async query cancellation checks.\n-     *\n-     * @return Default: 300\n-     */\n-    default Integer getAsyncQueryCancelDelaySeconds() {\n-        return 300;\n-    }\n-\n     /**\n      * Implementation of AsyncQueryDAO to use.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4MzA2Mw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456683063", "bodyText": "queryCancellationIntervalSeconds", "author": "moizarafat", "createdAt": "2020-07-17T21:31:39Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java", "diffHunk": "@@ -33,6 +33,11 @@\n      */\n     private int queryCleanupDays = 7;\n \n+    /**\n+     * Default cancel interval of async query.\n+     */\n+    private int queryCancellationSeconds = 300;", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNDE0NA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r457514144", "bodyText": "I want to keep it similar to cleanup. cleanup  is called queryCleanupDays. So queryCancellationSeconds sounds correct to me.", "author": "ayeswarya", "createdAt": "2020-07-20T15:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4MzA2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java b/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\nindex 52c805c44..f95941ad2 100644\n--- a/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\n+++ b/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\n\n@@ -33,11 +33,6 @@ public class AsyncProperties extends ControllerProperties {\n      */\n     private int queryCleanupDays = 7;\n \n-    /**\n-     * Default cancel interval of async query.\n-     */\n-    private int queryCancellationSeconds = 300;\n-\n     /**\n      * Whether or not to use the default implementation of AsyncQueryDAO.\n      * If false, the user will provide custom implementation of AsyncQueryDAO.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4NTMyMA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456685320", "bodyText": "This is a bit of pseudocode, but I think the code is more readable with functional style and breaking this into sets:\nSet<UUID> runningQueries = runningTransctionMap.keySet();\n\nSet<UUID> cancellingQueries = asyncQueryCollection.stream()\n     .filter(query -> query.getStatus == QueryStatus.CANCELED)\n     .map (AsyncQuery::getRequestId)\n      .collect(Collectors.toSet());\n\nSet<UUID> queriesToKill = Sets.intersection(runningQueries, cancellingQueries);\n\nqueriesToKill.stream().\n   .map(transactionRegistry.getRunningTransaction)\n   .forEach((tx) -> {\n      tx.cancel();\n   });", "author": "aklish", "createdAt": "2020-07-17T21:38:50Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.TransactionRegistry;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getTransactionMap();\n+            Collection<AsyncQuery> asyncQueryCollection = asyncQueryDao.getActiveAsyncQueryCollection();\n+\n+            for (Map.Entry<UUID, DataStoreTransaction> entry : runningTransactionMap.entrySet()) {", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\nindex 717a4b9c3..e487327b1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n\n@@ -5,21 +5,38 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.Path.PathElement;\n+import com.yahoo.elide.core.RequestScope;\n import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.InPredicate;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+\n+import com.google.common.collect.Sets;\n \n import lombok.AllArgsConstructor;\n import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n \n /**\n  * Runnable thread for cancelling AsyncQuery transactions\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4NjI3Ng==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456686276", "bodyText": "plz remove commented code", "author": "moizarafat", "createdAt": "2020-07-17T21:41:33Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private TransactionRegistry transactionRegistry;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        transactionRegistry = mock(TransactionRegistry.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao);\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testCancelAsyncQuery() {\n+        cancelThread.cancelAsyncQuery();\n+        verify(asyncQueryDao, times(1)).getActiveAsyncQueryCollection();\n+        //verify(transactionRegistry, times(1)).getTransactionMap();", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\nindex 6d67885ac..31ed026d0 100644\n--- a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n+++ b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n\n@@ -6,24 +6,35 @@\n package com.yahoo.elide.async.service;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n import com.yahoo.elide.Elide;\n import com.yahoo.elide.ElideSettingsBuilder;\n import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n import com.yahoo.elide.core.EntityDictionary;\n import com.yahoo.elide.core.TransactionRegistry;\n import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n import com.yahoo.elide.security.checks.Check;\n \n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.TimeZone;\n+import java.util.UUID;\n \n public class AsyncQueryCancelThreadTest {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4NzYzMg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456687632", "bodyText": "please include a test case in DefaultAsyncQueryDAOTest.java for this method.", "author": "moizarafat", "createdAt": "2020-07-17T21:45:47Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -195,4 +199,32 @@ protected Object executeInTransaction(DataStore dataStore, Transactional action)\n         }\n         return result;\n     }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection() {", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c5cc21358..6cfe91e10 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n\n@@ -202,28 +175,22 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> getActiveAsyncQueryCollection() {\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n         Collection<AsyncQuery> asyncQueryList = null;\n-\n-        log.debug(\"getActiveAsyncQueryCollection\");\n-        String filterExpression = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n-                + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\";\n-\n+        log.debug(\"loadAsyncQueryCollection\");\n         try {\n-            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                     AsyncQuery.class, false);\n             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n \n                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n                         .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n+                        .filterExpression(filterExpression)\n                         .build();\n                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n                 return loaded;\n             });\n         } catch (Exception e) {\n             log.error(\"Exception: {}\", e);\n+            throw new IllegalStateException(e);\n         }\n         return asyncQueryList;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4NzYwNQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461787605", "bodyText": "I'm not sure this is correct.  This filter will look for any query that is canceled, queued, or processing that is more recent than now minus max runtime.  Later, we filter this collection by queries that are canceled or having ran longer than max runtime.\nI think there are two problems:\n\nI don't believe the second condition will ever evaluate.  Those queries have already been removed by the DAO filter.\nI think it is possible to miss queries that are canceled but have run longer (for whatever reason) than  the max runtime.", "author": "aklish", "createdAt": "2020-07-28T18:31:03Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.google.common.collect.Sets;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n+\n+            String filterDateFormatted = evaluateFormattedFilterDate(Calendar.SECOND, maxRunTimeSeconds);\n+            String filterExpression = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"", "originalCommit": "12ba32589643f99638e66024251451bb425e0056", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\nindex 2933934d4..e487327b1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n\n@@ -11,20 +11,24 @@ import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.Path.PathElement;\n import com.yahoo.elide.core.RequestScope;\n import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.InPredicate;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+\n import com.google.common.collect.Sets;\n \n import lombok.AllArgsConstructor;\n import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n-import java.text.Format;\n-import java.text.SimpleDateFormat;\n-import java.util.Calendar;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.UUID;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1MDE5OA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461850198", "bodyText": "The interface contract for the AsyncQueryDAO would be cleaner if the filterExpression for this method and others was an actual FilterExpression object instead of a String.", "author": "aklish", "createdAt": "2020-07-28T20:14:27Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -195,4 +199,30 @@ protected Object executeInTransaction(DataStore dataStore, Transactional action)\n         }\n         return result;\n     }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection(String filterExpression) {", "originalCommit": "12ba32589643f99638e66024251451bb425e0056", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex d70880b67..6cfe91e10 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n\n@@ -202,19 +175,15 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> getActiveAsyncQueryCollection(String filterExpression) {\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n         Collection<AsyncQuery> asyncQueryList = null;\n-\n-        log.debug(\"getActiveAsyncQueryCollection\");\n-\n+        log.debug(\"loadAsyncQueryCollection\");\n         try {\n-            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                     AsyncQuery.class, false);\n             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n \n                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n                         .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n+                        .filterExpression(filterExpression)\n                         .build();\n                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n                 return loaded;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1MDcwOQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461850709", "bodyText": "Should we change this to UUID.fromString(id)?", "author": "aklish", "createdAt": "2020-07-28T20:15:04Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncExecutorServiceTest.java", "diffHunk": "@@ -85,9 +86,10 @@ public void testExecuteQueryComplete() throws InterruptedException {\n         AsyncQuery queryObj = mock(AsyncQuery.class);\n         String query = \"/group?sort=commonName&fields%5Bgroup%5D=commonName,description\";\n         String id = \"edc4a871-dff2-4054-804e-d80075cf827d\";\n+        UUID uuid = UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf827d\");", "originalCommit": "12ba32589643f99638e66024251451bb425e0056", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncExecutorServiceTest.java b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncExecutorServiceTest.java\nindex a70c1273b..b663fa26f 100644\n--- a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncExecutorServiceTest.java\n+++ b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncExecutorServiceTest.java\n\n@@ -86,10 +85,9 @@ public class AsyncExecutorServiceTest {\n         AsyncQuery queryObj = mock(AsyncQuery.class);\n         String query = \"/group?sort=commonName&fields%5Bgroup%5D=commonName,description\";\n         String id = \"edc4a871-dff2-4054-804e-d80075cf827d\";\n-        UUID uuid = UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf827d\");\n         when(queryObj.getQuery()).thenReturn(query);\n         when(queryObj.getId()).thenReturn(id);\n-        when(queryObj.getRequestId()).thenReturn(uuid);\n+        when(queryObj.getRequestId()).thenReturn(id);\n         when(queryObj.getQueryType()).thenReturn(QueryType.JSONAPI_V1_0);\n         when(queryObj.getAsyncAfterSeconds()).thenReturn(10);\n         service.executeQuery(queryObj, testUser, NO_VERSION);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1MzExOQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461853119", "bodyText": "I wonder if this would read better with a more descriptive name (although longer):\ngetAsyncQueryCancelCheckIntervalSeconds", "author": "aklish", "createdAt": "2020-07-28T20:18:21Z", "path": "elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java", "diffHunk": "@@ -235,6 +235,15 @@ default Integer getAsyncQueryCleanupDays() {\n         return 7;\n     }\n \n+    /**\n+     * Number of seconds  between async query cancellation checks.\n+     *\n+     * @return Default: 300\n+     */\n+    default Integer getAsyncQueryCancelSeconds() {", "originalCommit": "12ba32589643f99638e66024251451bb425e0056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1Mzc3MA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461853770", "bodyText": "Maybe a better approach is to move all of the async query settings into a struct of some kind to namespace them (so they aren't so long)", "author": "aklish", "createdAt": "2020-07-28T20:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1MzExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NTU0Mw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r471055543", "bodyText": "we can take care of this in the download pr", "author": "moizarafat", "createdAt": "2020-08-16T02:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1MzExOQ=="}], "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\nindex dc245f72c..c527d814a 100644\n--- a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n+++ b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n\n@@ -235,15 +244,6 @@ public interface ElideStandaloneSettings {\n         return 7;\n     }\n \n-    /**\n-     * Number of seconds  between async query cancellation checks.\n-     *\n-     * @return Default: 300\n-     */\n-    default Integer getAsyncQueryCancelSeconds() {\n-        return 300;\n-    }\n-\n     /**\n      * Implementation of AsyncQueryDAO to use.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1NDM2NQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461854365", "bodyText": "I think the definition of this is vague.  What is this interval for?  Let's get a more descriptive name and a better description of its intended use.", "author": "aklish", "createdAt": "2020-07-28T20:20:35Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java", "diffHunk": "@@ -33,6 +33,11 @@\n      */\n     private int queryCleanupDays = 7;\n \n+    /**\n+     * Default cancel interval of async query.\n+     */\n+    private int queryCancellationSeconds = 300;", "originalCommit": "12ba32589643f99638e66024251451bb425e0056", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java b/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\nindex 52c805c44..f95941ad2 100644\n--- a/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\n+++ b/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\n\n@@ -33,11 +33,6 @@ public class AsyncProperties extends ControllerProperties {\n      */\n     private int queryCleanupDays = 7;\n \n-    /**\n-     * Default cancel interval of async query.\n-     */\n-    private int queryCancellationSeconds = 300;\n-\n     /**\n      * Whether or not to use the default implementation of AsyncQueryDAO.\n      * If false, the user will provide custom implementation of AsyncQueryDAO.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxODU4MQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r463818581", "bodyText": "This is too broad and is swallowing exceptions that need to be propagated.", "author": "aklish", "createdAt": "2020-07-31T20:24:38Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -114,27 +106,26 @@ public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n                  }\n                  return loaded;\n              });\n-        } catch (ParseException e) {\n+        } catch (Exception e) {", "originalCommit": "72fb16f0c8ef4a31cf175f1b9ff27321fb9aac32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 116e2f33b..6cfe91e10 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n\n@@ -86,29 +86,23 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         log.debug(\"updateAsyncQueryCollection\");\n \n         Collection<AsyncQuery> asyncQueryList = null;\n-\n-        try {\n-\n-             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                        (tx, scope) -> {\n-                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                         .type(AsyncQuery.class)\n-                         .filterExpression(filterExpression)\n-                         .build();\n-\n-                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                 Iterator<Object> itr = loaded.iterator();\n-\n-                 while (itr.hasNext()) {\n-                     AsyncQuery query = (AsyncQuery) itr.next();\n-                     updateFunction.update(query);\n-                     tx.save(query, scope);\n-                 }\n-                 return loaded;\n-             });\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-        }\n+         asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n+                    (tx, scope) -> {\n+             EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                     .type(AsyncQuery.class)\n+                     .filterExpression(filterExpression)\n+                     .build();\n+\n+             Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+             Iterator<Object> itr = loaded.iterator();\n+\n+             while (itr.hasNext()) {\n+                 AsyncQuery query = (AsyncQuery) itr.next();\n+                 updateFunction.update(query);\n+                 tx.save(query, scope);\n+             }\n+             return loaded;\n+         });\n         return asyncQueryList;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxOTI1Ng==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r463819256", "bodyText": "The DAO should not swallow exceptions.  Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).", "author": "aklish", "createdAt": "2020-07-31T20:26:09Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -148,7 +139,7 @@ public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n                 }\n                 return loaded;\n             });\n-        } catch (ParseException e) {\n+        } catch (Exception e) {", "originalCommit": "72fb16f0c8ef4a31cf175f1b9ff27321fb9aac32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 116e2f33b..6cfe91e10 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n\n@@ -116,32 +110,24 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     @SuppressWarnings(\"unchecked\")\n     public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-\n         Collection<AsyncQuery> asyncQueryList = null;\n+        asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filterExpression)\n+                    .build();\n \n-        try {\n-\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filterExpression)\n-                        .build();\n-\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                Iterator<Object> itr = loaded.iterator();\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n \n-                while (itr.hasNext()) {\n-                    AsyncQuery query = (AsyncQuery) itr.next();\n-                    if (query != null) {\n-                        tx.delete(query, scope);\n-                    }\n+            while (itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                if (query != null) {\n+                    tx.delete(query, scope);\n                 }\n-                return loaded;\n-            });\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-        }\n+            }\n+            return loaded;\n+        });\n         return asyncQueryList;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxOTgyNg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r463819826", "bodyText": "Relying on time to find the queries that need to be canceled has some race conditions and other issues with configuration that can cause problems.\nInstead of filtering on time, I think we need to introduce another state - CANCEL_COMPLETE or something along those lines that marks which queries have been successfully canceled.", "author": "aklish", "createdAt": "2020-07-31T20:27:37Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -61,13 +66,13 @@ protected void cancelAsyncQuery() {\n \n             TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n             Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n-\n-            String filterDateFormatted = evaluateFormattedFilterDate(Calendar.SECOND, maxRunTimeSeconds);\n-            String filterExpression = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n-                    + QueryStatus.PROCESSING.toString() + \",\"\n-                    + QueryStatus.QUEUED.toString() + \");createdOn=ge='\" + filterDateFormatted + \"'\";\n-\n-            Collection<AsyncQuery> asyncQueryCollection = asyncQueryDao.getActiveAsyncQueryCollection(filterExpression);\n+            String filterDateFormatted = evaluateFormattedFilterDate(Calendar.SECOND, 2 * maxRunTimeSeconds);\n+            String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"", "originalCommit": "72fb16f0c8ef4a31cf175f1b9ff27321fb9aac32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\nindex 5c99ba3ff..e487327b1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n\n@@ -63,57 +63,67 @@ public class AsyncQueryCancelThread implements Runnable {\n     protected void cancelAsyncQuery() {\n \n         try {\n-\n             TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+\n             Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n-            String filterDateFormatted = evaluateFormattedFilterDate(Calendar.SECOND, 2 * maxRunTimeSeconds);\n-            String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                    + QueryStatus.QUEUED.toString() + \"),status=in=(\" + QueryStatus.CANCELLED.toString()\n-                    + \");updatedOn=ge='\" + filterDateFormatted + \"'\";\n-            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                    AsyncQuery.class, false);\n-            Collection<AsyncQuery> asyncQueryCollection = asyncQueryDao.getActiveAsyncQueryCollection(filter);\n \n-            Set<UUID> runningTransactions = runningTransactionMap.keySet();\n+            //Running transaction UUIDs\n+            Set<UUID> runningTransactionUUIDs = runningTransactionMap.keySet();\n+\n+            //Construct filter expression\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, QueryStatus.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.CANCELLED);\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterExpression fltStatusExpression =\n+                    new InPredicate(statusPathElement, statusList);\n+\n+            Collection<AsyncQuery> asyncQueryCollection =\n+                    asyncQueryDao.loadAsyncQueryCollection(fltStatusExpression);\n \n-            Set<UUID> asyncTransactions = asyncQueryCollection.stream()\n+            //Active AsyncQuery UUIDs\n+            Set<UUID> asyncTransactionUUIDs = asyncQueryCollection.stream()\n                     .filter(query -> query.getStatus() == QueryStatus.CANCELLED\n-                    || TimeUnit.SECONDS.convert(Math.abs(query.getUpdatedOn().getTime()\n-                    - new Date(System.currentTimeMillis()).getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)\n-                    .map(AsyncQuery::getRequestId)\n+                    || TimeUnit.SECONDS.convert(Math.abs(new Date(System.currentTimeMillis()).getTime()\n+                            - query.getCreatedOn().getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)\n+                    .map(query -> UUID.fromString(query.getRequestId()))\n             .collect(Collectors.toSet());\n \n-            Set<UUID> queriesToCancel = Sets.intersection(runningTransactions, asyncTransactions);\n+            //AsyncQuery UUIDs that have active transactions\n+            Set<UUID> queryUUIDsToCancel = Sets.intersection(runningTransactionUUIDs, asyncTransactionUUIDs);\n+\n+            //AsyncQuery IDs that need to be cancelled\n+            Set<String> queryIDsToCancel = queryUUIDsToCancel.stream()\n+            .map(uuid -> {\n+                return asyncQueryCollection.stream()\n+                .filter(query -> query.getRequestId().equals(uuid.toString()))\n+                .map(AsyncQuery::getId)\n+                .findFirst().orElseThrow(IllegalStateException::new);\n+            })\n+            .collect(Collectors.toSet());\n \n-            queriesToCancel.stream()\n-               .forEach((tx) -> {\n+            //Cancel Transactions\n+            queryUUIDsToCancel.stream()\n+               .forEach((uuid) -> {\n                    JsonApiDocument jsonApiDoc = new JsonApiDocument();\n                    MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-                   RequestScope scope = new RequestScope(\"query\", NO_VERSION, jsonApiDoc,\n-                           transactionRegistry.getRunningTransaction(tx), null, queryParams,\n-                           tx, elide.getElideSettings());\n-                   transactionRegistry.getRunningTransaction(tx).cancel(scope);\n+                   RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n+                           transactionRegistry.getRunningTransaction(uuid), null, queryParams,\n+                           uuid, elide.getElideSettings());\n+                   transactionRegistry.getRunningTransaction(uuid).cancel(scope);\n                });\n \n+            //Change queryStatus for cancelled queries\n+            if (!queryIDsToCancel.isEmpty()) {\n+                PathElement idPathElement = new PathElement(AsyncQuery.class, String.class, \"id\");\n+                FilterExpression fltIdExpression =\n+                        new InPredicate(idPathElement, queryIDsToCancel);\n+                System.out.println(fltIdExpression.toString());\n+                asyncQueryDao.updateStatusAsyncQueryCollection(fltIdExpression, QueryStatus.CANCEL_COMPLETE);\n+            }\n         } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n+            log.error(\"Exception in scheduled cancellation: {}\", e);\n         }\n     }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.SECOND\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, - amount);\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMTIxMw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r465831213", "bodyText": "It will be more efficient to call asyncQueryDao.updateAsyncQueryCollection which can do a bulk update", "author": "aklish", "createdAt": "2020-08-05T15:56:18Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -87,33 +85,20 @@ protected void cancelAsyncQuery() {\n \n             queriesToCancel.stream()\n                .forEach((tx) -> {\n-                   JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-                   MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-                   RequestScope scope = new RequestScope(\"query\", NO_VERSION, jsonApiDoc,\n-                           transactionRegistry.getRunningTransaction(tx), null, queryParams,\n-                           tx, elide.getElideSettings());\n-                   transactionRegistry.getRunningTransaction(tx).cancel(scope);\n+                       JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+                       MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+                       RequestScope scope = new RequestScope(\"query\", NO_VERSION, jsonApiDoc,\n+                               transactionRegistry.getRunningTransaction(tx), null, queryParams,\n+                               tx, elide.getElideSettings());\n+                       transactionRegistry.getRunningTransaction(tx).cancel(scope);\n+                       List<AsyncQuery> asyncQueryList = asyncQueryCollection.stream()\n+                               .filter(query -> query.getRequestId().equals(tx)).collect(Collectors.toList());\n+                       asyncQueryList.forEach(asyncQuery -> asyncQueryDao.updateStatus(asyncQuery.getId(),", "originalCommit": "685573ccd9d97ee5c2d497004fcdb13eee2df915", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\nindex 81b7f61dc..e487327b1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n\n@@ -62,43 +63,67 @@ public class AsyncQueryCancelThread implements Runnable {\n     protected void cancelAsyncQuery() {\n \n         try {\n-\n             TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+\n             Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n-            String filterExpressionStr = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n-                    + QueryStatus.PROCESSING.toString() + \",\"\n-                    + QueryStatus.QUEUED.toString() + \")\";\n-            FilterExpression filterExpression = filterParser.parseFilterExpression(filterExpressionStr,\n-                    AsyncQuery.class, false);\n-            Collection<AsyncQuery> asyncQueryCollection = asyncQueryDao.getActiveAsyncQueryCollection(filterExpression);\n \n-            Set<UUID> runningTransactions = runningTransactionMap.keySet();\n+            //Running transaction UUIDs\n+            Set<UUID> runningTransactionUUIDs = runningTransactionMap.keySet();\n+\n+            //Construct filter expression\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, QueryStatus.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.CANCELLED);\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterExpression fltStatusExpression =\n+                    new InPredicate(statusPathElement, statusList);\n \n-            Set<UUID> asyncTransactions = asyncQueryCollection.stream()\n+            Collection<AsyncQuery> asyncQueryCollection =\n+                    asyncQueryDao.loadAsyncQueryCollection(fltStatusExpression);\n+\n+            //Active AsyncQuery UUIDs\n+            Set<UUID> asyncTransactionUUIDs = asyncQueryCollection.stream()\n                     .filter(query -> query.getStatus() == QueryStatus.CANCELLED\n-                    || TimeUnit.SECONDS.convert(Math.abs(query.getUpdatedOn().getTime()\n-                    - new Date(System.currentTimeMillis()).getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)\n-                    .map(AsyncQuery::getRequestId)\n+                    || TimeUnit.SECONDS.convert(Math.abs(new Date(System.currentTimeMillis()).getTime()\n+                            - query.getCreatedOn().getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)\n+                    .map(query -> UUID.fromString(query.getRequestId()))\n+            .collect(Collectors.toSet());\n+\n+            //AsyncQuery UUIDs that have active transactions\n+            Set<UUID> queryUUIDsToCancel = Sets.intersection(runningTransactionUUIDs, asyncTransactionUUIDs);\n+\n+            //AsyncQuery IDs that need to be cancelled\n+            Set<String> queryIDsToCancel = queryUUIDsToCancel.stream()\n+            .map(uuid -> {\n+                return asyncQueryCollection.stream()\n+                .filter(query -> query.getRequestId().equals(uuid.toString()))\n+                .map(AsyncQuery::getId)\n+                .findFirst().orElseThrow(IllegalStateException::new);\n+            })\n             .collect(Collectors.toSet());\n \n-            Set<UUID> queriesToCancel = Sets.intersection(runningTransactions, asyncTransactions);\n-\n-            queriesToCancel.stream()\n-               .forEach((tx) -> {\n-                       JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-                       MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-                       RequestScope scope = new RequestScope(\"query\", NO_VERSION, jsonApiDoc,\n-                               transactionRegistry.getRunningTransaction(tx), null, queryParams,\n-                               tx, elide.getElideSettings());\n-                       transactionRegistry.getRunningTransaction(tx).cancel(scope);\n-                       List<AsyncQuery> asyncQueryList = asyncQueryCollection.stream()\n-                               .filter(query -> query.getRequestId().equals(tx)).collect(Collectors.toList());\n-                       asyncQueryList.forEach(asyncQuery -> asyncQueryDao.updateStatus(asyncQuery.getId(),\n-                             QueryStatus.CANCEL_COMPLETE));\n+            //Cancel Transactions\n+            queryUUIDsToCancel.stream()\n+               .forEach((uuid) -> {\n+                   JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+                   MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+                   RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n+                           transactionRegistry.getRunningTransaction(uuid), null, queryParams,\n+                           uuid, elide.getElideSettings());\n+                   transactionRegistry.getRunningTransaction(uuid).cancel(scope);\n                });\n \n-        } catch (ParseException e) {\n-            log.error(\"ParseException: {}\", e);\n+            //Change queryStatus for cancelled queries\n+            if (!queryIDsToCancel.isEmpty()) {\n+                PathElement idPathElement = new PathElement(AsyncQuery.class, String.class, \"id\");\n+                FilterExpression fltIdExpression =\n+                        new InPredicate(idPathElement, queryIDsToCancel);\n+                System.out.println(fltIdExpression.toString());\n+                asyncQueryDao.updateStatusAsyncQueryCollection(fltIdExpression, QueryStatus.CANCEL_COMPLETE);\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cancellation: {}\", e);\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwODI3NQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467208275", "bodyText": "Shouldn't this calculation be:\nNOW - query.getCreatedOn().getTime() > maxRunTimeSeconds\nSo two changes - createdOn instead of updatedOn and invert the subtraction  operands (we can keep the absolute value though).", "author": "aklish", "createdAt": "2020-08-07T18:40:46Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.google.common.collect.Sets;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private EntityDictionary dictionary;\n+    private RSQLFilterDialect filterParser;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n+            String filterByStatus = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n+                    + QueryStatus.PROCESSING.toString() + \",\"\n+                    + QueryStatus.QUEUED.toString() + \")\";\n+            FilterExpression fltStatusExpression = filterParser.parseFilterExpression(filterByStatus,\n+                    AsyncQuery.class, false);\n+            Collection<AsyncQuery> asyncQueryCollection =\n+                    asyncQueryDao.getActiveAsyncQueryCollection(fltStatusExpression);\n+\n+            Set<UUID> runningTransactions = runningTransactionMap.keySet();\n+\n+            Set<UUID> asyncTransactions = asyncQueryCollection.stream()\n+                    .filter(query -> query.getStatus() == QueryStatus.CANCELLED\n+                    || TimeUnit.SECONDS.convert(Math.abs(query.getUpdatedOn().getTime()\n+                    - new Date(System.currentTimeMillis()).getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\nindex d49f84468..e487327b1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n\n@@ -11,13 +11,13 @@ import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path.PathElement;\n import com.yahoo.elide.core.RequestScope;\n import com.yahoo.elide.core.TransactionRegistry;\n-import com.yahoo.elide.core.filter.dialect.ParseException;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.InPredicate;\n import com.yahoo.elide.core.filter.expression.FilterExpression;\n import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+\n import com.google.common.collect.Sets;\n \n import lombok.AllArgsConstructor;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTk5Nw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467209997", "bodyText": "Another thing (I'm probably going back on prior comments here), but I think tx.cancel can throw an exception.  If this thread is terminated by an exception, will the executor schedule another?", "author": "aklish", "createdAt": "2020-08-07T18:44:37Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.google.common.collect.Sets;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private EntityDictionary dictionary;\n+    private RSQLFilterDialect filterParser;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n+            String filterByStatus = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n+                    + QueryStatus.PROCESSING.toString() + \",\"\n+                    + QueryStatus.QUEUED.toString() + \")\";\n+            FilterExpression fltStatusExpression = filterParser.parseFilterExpression(filterByStatus,\n+                    AsyncQuery.class, false);\n+            Collection<AsyncQuery> asyncQueryCollection =\n+                    asyncQueryDao.getActiveAsyncQueryCollection(fltStatusExpression);\n+\n+            Set<UUID> runningTransactions = runningTransactionMap.keySet();\n+\n+            Set<UUID> asyncTransactions = asyncQueryCollection.stream()\n+                    .filter(query -> query.getStatus() == QueryStatus.CANCELLED\n+                    || TimeUnit.SECONDS.convert(Math.abs(query.getUpdatedOn().getTime()\n+                    - new Date(System.currentTimeMillis()).getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)\n+                    .map(AsyncQuery::getRequestId)\n+            .collect(Collectors.toSet());\n+\n+            Set<UUID> queriesToCancel = Sets.intersection(runningTransactions, asyncTransactions);\n+\n+            List<String> asyncQueryList = new ArrayList<String>();\n+            queriesToCancel.stream()\n+               .forEach((tx) -> {\n+                   JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+                   MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+                   RequestScope scope = new RequestScope(\"query\", NO_VERSION, jsonApiDoc,\n+                           transactionRegistry.getRunningTransaction(tx), null, queryParams,\n+                           tx, elide.getElideSettings());\n+                   transactionRegistry.getRunningTransaction(tx).cancel(scope);\n+                   List<String> cancelledQuery = asyncQueryCollection.stream().filter(query\n+                           -> query.getRequestId().equals(tx)).map(AsyncQuery::getId).collect(Collectors.toList());\n+                   asyncQueryList.addAll(cancelledQuery);\n+               });\n+            if (!queriesToCancel.isEmpty()) {\n+                String cancelledQueryStr = String.join(\",\", asyncQueryList);\n+                String filterById = \"id=in=(\" + cancelledQueryStr + \")\";\n+                FilterExpression fltIdExpression = filterParser.parseFilterExpression\n+                        (filterById, AsyncQuery.class, false);\n+                asyncQueryDao.updateStatusAsyncQueryCollection(fltIdExpression, QueryStatus.CANCEL_COMPLETE);\n+            }\n+        } catch (ParseException e) {", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxNjc2Nw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467216767", "bodyText": "We probably want to invert the order of canceling the transaction and marking the status to complete.  If canceling throws an exception, it will leave a query in the canceling state with nothing to clean it up.", "author": "aklish", "createdAt": "2020-08-07T18:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3MjE2OQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467672169", "bodyText": "The way the code is now, cancellation happens before we mark the status of the query as CANCEL_COMPLETE. So if there were to be an exception, the query status will not change, so it can be picked up for cancellation in the next run of the cancel thread...", "author": "ayeswarya", "createdAt": "2020-08-10T03:21:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyNDUyOA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r470124528", "bodyText": "I was testing the code in example application and discovered that the executor does not schedule another thread if it encounters an exception. Can I catch exceptions, log them?", "author": "ayeswarya", "createdAt": "2020-08-13T17:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTk5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\nindex d49f84468..e487327b1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n\n@@ -11,13 +11,13 @@ import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path.PathElement;\n import com.yahoo.elide.core.RequestScope;\n import com.yahoo.elide.core.TransactionRegistry;\n-import com.yahoo.elide.core.filter.dialect.ParseException;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.InPredicate;\n import com.yahoo.elide.core.filter.expression.FilterExpression;\n import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+\n import com.google.common.collect.Sets;\n \n import lombok.AllArgsConstructor;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NzU3Ng==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467257576", "bodyText": "A couple of improvements on this code.  I think we should rename some of the local variables for clarity.  When dealing with ids, we shouldn't call them queries or transactions but rather identifiers - so we can distinguish the collections from each other.\nSecond, I'm not sure how much of an improvement this is, but I would probably have written the mapping from UUIDs to kill to queries to kill as follows:\nSet<Query> queriesToCancel = queryIdsToCancel.stream()\n        .map(uuid -> { \n            asyncQueryCollection.stream()\n               .filter(query -> query.getRequestId().equals(uuid))\n               .findFirst().orElseThrow(IllegalStateException::new)\n         })\n         .collect(Collectors.toSet());\nBecause naming is hard, it is sometimes more readable to collapse the mapping into a single logical block without intermediate state.  Alternatively, we could write a separate function to do the same thing.", "author": "aklish", "createdAt": "2020-08-07T20:37:20Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.google.common.collect.Sets;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private EntityDictionary dictionary;\n+    private RSQLFilterDialect filterParser;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n+            String filterByStatus = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n+                    + QueryStatus.PROCESSING.toString() + \",\"\n+                    + QueryStatus.QUEUED.toString() + \")\";\n+            FilterExpression fltStatusExpression = filterParser.parseFilterExpression(filterByStatus,\n+                    AsyncQuery.class, false);\n+            Collection<AsyncQuery> asyncQueryCollection =\n+                    asyncQueryDao.getActiveAsyncQueryCollection(fltStatusExpression);\n+\n+            Set<UUID> runningTransactions = runningTransactionMap.keySet();\n+\n+            Set<UUID> asyncTransactions = asyncQueryCollection.stream()\n+                    .filter(query -> query.getStatus() == QueryStatus.CANCELLED\n+                    || TimeUnit.SECONDS.convert(Math.abs(query.getUpdatedOn().getTime()\n+                    - new Date(System.currentTimeMillis()).getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)\n+                    .map(AsyncQuery::getRequestId)\n+            .collect(Collectors.toSet());\n+\n+            Set<UUID> queriesToCancel = Sets.intersection(runningTransactions, asyncTransactions);\n+\n+            List<String> asyncQueryList = new ArrayList<String>();\n+            queriesToCancel.stream()\n+               .forEach((tx) -> {\n+                   JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+                   MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+                   RequestScope scope = new RequestScope(\"query\", NO_VERSION, jsonApiDoc,\n+                           transactionRegistry.getRunningTransaction(tx), null, queryParams,\n+                           tx, elide.getElideSettings());\n+                   transactionRegistry.getRunningTransaction(tx).cancel(scope);\n+                   List<String> cancelledQuery = asyncQueryCollection.stream().filter(query", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\nindex d49f84468..e487327b1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n\n@@ -11,13 +11,13 @@ import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path.PathElement;\n import com.yahoo.elide.core.RequestScope;\n import com.yahoo.elide.core.TransactionRegistry;\n-import com.yahoo.elide.core.filter.dialect.ParseException;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.InPredicate;\n import com.yahoo.elide.core.filter.expression.FilterExpression;\n import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+\n import com.google.common.collect.Sets;\n \n import lombok.AllArgsConstructor;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1OTA3Nw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467259077", "bodyText": "The DAO will be more usable if we don't tie down the contract with constraints like limiting the status to QUEUED, PROCESSING, etc.\nThis can just be a load method that takes a filter expression.  Let the calling code determine what states or other bits to filter on.", "author": "aklish", "createdAt": "2020-08-07T20:41:03Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -48,7 +49,14 @@ public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status);\n+    /**\n+     * This method gets a collection of AsyncQuery and objects from database with status QUEUED/PROCESSING/CANCELLED and\n+     * returns the objects.\n+     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection(FilterExpression filterExpression);", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 92813bdfd..8a09538f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n\n@@ -52,11 +52,10 @@ public interface AsyncQueryDAO {\n     public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status);\n     /**\n-     * This method gets a collection of AsyncQuery and objects from database with status QUEUED/PROCESSING/CANCELLED and\n+     * This method gets a collection of AsyncQuery objects from database and\n      * returns the objects.\n      * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> getActiveAsyncQueryCollection(FilterExpression filterExpression);\n-\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1OTQ0Mw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467259443", "bodyText": "Change the name to reflect this is a simple loadQueries or something.", "author": "aklish", "createdAt": "2020-08-07T20:42:05Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -195,4 +183,29 @@ protected Object executeInTransaction(DataStore dataStore, Transactional action)\n         }\n         return result;\n     }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection(FilterExpression filterExpression) {", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 3cb6401b7..6cfe91e10 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n\n@@ -186,13 +175,10 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> getActiveAsyncQueryCollection(FilterExpression filterExpression) {\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n         Collection<AsyncQuery> asyncQueryList = null;\n-\n-        log.debug(\"getActiveAsyncQueryCollection\");\n-\n+        log.debug(\"loadAsyncQueryCollection\");\n         try {\n-\n             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n \n                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2MzExNA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467263114", "bodyText": "I feel like these tests don't test too much of the code that was added.\nWe have all this set interaction between running transactions and transactions that exist in the database.  We ought to be testing (with unit tests):\n\nAsync queries in the database that are COMPLETE, CANCEL_COMPLETE are skipped.\nOnly the async queries that reflect running queries in the transaction registry are canceled.\nQueries that exceed their runtime are canceled (but only if they are in the transaction registry).\nQueries that didn't exceed their runtime are not canceled.\n\nThat's not an exhaustive test - but that will verify the functionality works as we expect.", "author": "aklish", "createdAt": "2020-08-07T20:51:42Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        EntityDictionary dictionary = mock(EntityDictionary.class);\n+        RSQLFilterDialect filterParser = mock(RSQLFilterDialect.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao, dictionary, filterParser);\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testCancelAsyncQuery() {\n+        cancelThread.cancelAsyncQuery();\n+        verify(asyncQueryDao, times(1)).getActiveAsyncQueryCollection(any());", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\nindex 0a9822892..31ed026d0 100644\n--- a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n+++ b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n\n@@ -10,27 +10,38 @@ import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n import com.yahoo.elide.Elide;\n import com.yahoo.elide.ElideSettingsBuilder;\n import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.TransactionRegistry;\n import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n import com.yahoo.elide.security.checks.Check;\n \n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.TimeZone;\n+import java.util.UUID;\n \n public class AsyncQueryCancelThreadTest {\n \n     private AsyncQueryCancelThread cancelThread;\n     private Elide elide;\n     private AsyncQueryDAO asyncQueryDao;\n+    private TransactionRegistry transactionRegistry;\n \n     @BeforeEach\n     public void setupMocks() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2MzkxMw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467263913", "bodyText": "Similar to my above comment - stronger tests would have a list of mock queries with different conditions of staleness - and we verify that:\n\nthe ones we expect to be canceled are canceled\nthe ones that we expect to be deleted are deleted\nthe ones we expect to be ignored are ignored.", "author": "aklish", "createdAt": "2020-08-07T20:53:39Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java", "diffHunk": "@@ -59,14 +62,12 @@ public void testAsyncQueryCleanerThreadSet() {\n     @Test\n     public void testDeleteAsyncQuery() {\n         cleanerThread.deleteAsyncQuery();\n-\n-        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(anyString());\n+        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(any());", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "chunk": "diff --git a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java\nindex f985a1dda..b6d66f3dc 100644\n--- a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java\n+++ b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java\n\n@@ -61,13 +59,19 @@ public class AsyncQueryCleanerThreadTest {\n \n     @Test\n     public void testDeleteAsyncQuery() {\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.deleteAsyncQuery();\n-        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(any());\n+        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(filterCaptor.capture());\n+        Long date = System.currentTimeMillis() - (cleanerThread.getQueryCleanupDays() * 24 * 3600 * 1000);\n+        assertEquals(\"asyncQuery.createdOn LE [\" + new Date(date) + \"]\", filterCaptor.getValue().toString());\n     }\n \n     @Test\n-    public void timeoutAsyncQuery() {\n+    public void testTimeoutAsyncQuery() {\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.timeoutAsyncQuery();\n-        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(any(), any(QueryStatus.class));\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any(QueryStatus.class));\n+        Long date = System.currentTimeMillis() - (cleanerThread.getMaxRunTimeMinutes() * 60 * 1000);\n+        assertEquals(\"(asyncQuery.status IN [[PROCESSING, QUEUED]] AND asyncQuery.createdOn LE [\" + new Date(date) + \"])\", filterCaptor.getValue().toString());\n     }\n }\n"}}, {"oid": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "url": "https://github.com/yahoo/elide/commit/bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "message": "cherry pick from CARBON-100 branch", "committedDate": "2020-08-14T04:41:43Z", "type": "commit"}, {"oid": "97133d3528bd57fedab66cdccd54df59bcf805d3", "url": "https://github.com/yahoo/elide/commit/97133d3528bd57fedab66cdccd54df59bcf805d3", "message": "Merge branch 'elide-5.x' of github.com:yahoo/elide into cancel_async", "committedDate": "2020-08-14T15:33:16Z", "type": "commit"}, {"oid": "663dd9e68e2a935c53a30cf2118d0d44cef6ff0e", "url": "https://github.com/yahoo/elide/commit/663dd9e68e2a935c53a30cf2118d0d44cef6ff0e", "message": "tested in example app", "committedDate": "2020-08-14T18:15:34Z", "type": "commit"}, {"oid": "663dd9e68e2a935c53a30cf2118d0d44cef6ff0e", "url": "https://github.com/yahoo/elide/commit/663dd9e68e2a935c53a30cf2118d0d44cef6ff0e", "message": "tested in example app", "committedDate": "2020-08-14T18:15:34Z", "type": "forcePushed"}, {"oid": "f4a1928e0ab2efc46f327dd2c8b188c2959e0457", "url": "https://github.com/yahoo/elide/commit/f4a1928e0ab2efc46f327dd2c8b188c2959e0457", "message": "codacy", "committedDate": "2020-08-14T19:01:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NTQxNg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r471055416", "bodyText": "This variable is not used any more, can be removed.", "author": "moizarafat", "createdAt": "2020-08-16T02:25:16Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java", "diffHunk": "@@ -44,28 +43,38 @@ private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer quer\n         // Since there will be multiple hosts running the elide service,\n         // setting up random delays to avoid all of them trying to cleanup at the same time.\n         Random random = new Random();\n-        int initialDelayMinutes = random.ints(0, maxCleanupInitialDelayMinutes).limit(1).findFirst().getAsInt();\n+        int initialDelayMinutes = random.ints(0, maxInitialDelayMinutes).limit(1).findFirst().getAsInt();", "originalCommit": "f4a1928e0ab2efc46f327dd2c8b188c2959e0457", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "437643db56fb4437b39b2962f90f413f1a9a73df", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex d0561b3e4..3fbb8abf0 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n\n@@ -50,7 +50,7 @@ public class AsyncCleanerService {\n         //Or maxRunTimeMinutes * 2 so that this process does not coincides with query\n         //interrupt process.\n \n-        cleaner.scheduleWithFixedDelay(cleanUpTask, 0, Math.max(defaultCleanupDelayMinutes,\n+        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(defaultCleanupDelayMinutes,\n                 queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n \n         //Setting up query cancel service that cancels long running queries based on status or runtime\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NjI1Mg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r471056252", "bodyText": "may be we should store transactionRegistry.getRunningTransaction(uuid) in a variable and check for null before calling cancel.", "author": "moizarafat", "createdAt": "2020-08-16T02:37:35Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.Path.PathElement;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.InPredicate;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+\n+import com.google.common.collect.Sets;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n+\n+            //Running transaction UUIDs\n+            Set<UUID> runningTransactionUUIDs = runningTransactionMap.keySet();\n+\n+            //Construct filter expression\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, QueryStatus.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.CANCELLED);\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterExpression fltStatusExpression =\n+                    new InPredicate(statusPathElement, statusList);\n+\n+            Collection<AsyncQuery> asyncQueryCollection =\n+                    asyncQueryDao.loadAsyncQueryCollection(fltStatusExpression);\n+\n+            //Active AsyncQuery UUIDs\n+            Set<UUID> asyncTransactionUUIDs = asyncQueryCollection.stream()\n+                    .filter(query -> query.getStatus() == QueryStatus.CANCELLED\n+                    || TimeUnit.SECONDS.convert(Math.abs(new Date(System.currentTimeMillis()).getTime()\n+                            - query.getCreatedOn().getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)\n+                    .map(query -> UUID.fromString(query.getRequestId()))\n+            .collect(Collectors.toSet());\n+\n+            //AsyncQuery UUIDs that have active transactions\n+            Set<UUID> queryUUIDsToCancel = Sets.intersection(runningTransactionUUIDs, asyncTransactionUUIDs);\n+\n+            //AsyncQuery IDs that need to be cancelled\n+            Set<String> queryIDsToCancel = queryUUIDsToCancel.stream()\n+            .map(uuid -> {\n+                return asyncQueryCollection.stream()\n+                .filter(query -> query.getRequestId().equals(uuid.toString()))\n+                .map(AsyncQuery::getId)\n+                .findFirst().orElseThrow(IllegalStateException::new);\n+            })\n+            .collect(Collectors.toSet());\n+\n+            //Cancel Transactions\n+            queryUUIDsToCancel.stream()\n+               .forEach((uuid) -> {\n+                   JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+                   MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+                   RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n+                           transactionRegistry.getRunningTransaction(uuid), null, queryParams,\n+                           uuid, elide.getElideSettings());\n+                   transactionRegistry.getRunningTransaction(uuid).cancel(scope);", "originalCommit": "f4a1928e0ab2efc46f327dd2c8b188c2959e0457", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "437643db56fb4437b39b2962f90f413f1a9a73df", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\nindex 026329a6b..327d90a6b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java\n\n@@ -104,12 +104,15 @@ public class AsyncQueryCancelThread implements Runnable {\n             //Cancel Transactions\n             queryUUIDsToCancel.stream()\n                .forEach((uuid) -> {\n-                   JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-                   MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-                   RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n-                           transactionRegistry.getRunningTransaction(uuid), null, queryParams,\n-                           uuid, elide.getElideSettings());\n-                   transactionRegistry.getRunningTransaction(uuid).cancel(scope);\n+                   DataStoreTransaction runningTransaction = transactionRegistry.getRunningTransaction(uuid);\n+                   if (runningTransaction != null) {\n+                       JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+                       MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+                       RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n+                               runningTransaction, null, queryParams,\n+                               uuid, elide.getElideSettings());\n+                       runningTransaction.cancel(scope);\n+                   }\n                });\n \n             //Change queryStatus for cancelled queries\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIxMjc0NQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r471212745", "bodyText": "maxRunTimeMinutes is not needed any more", "author": "moizarafat", "createdAt": "2020-08-17T03:23:07Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java", "diffHunk": "@@ -18,6 +18,11 @@\n      */\n     private int threadPoolSize = 5;\n \n+    /**\n+     * Default max query run time.\n+     */\n+    private int maxRunTimeSeconds = 3600;\n+\n     /**\n      * Default max query run time.", "originalCommit": "f4a1928e0ab2efc46f327dd2c8b188c2959e0457", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "437643db56fb4437b39b2962f90f413f1a9a73df", "chunk": "diff --git a/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java b/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\nindex 1639c9bf2..bd17c84ad 100644\n--- a/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\n+++ b/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\n\n@@ -23,11 +23,6 @@ public class AsyncProperties extends ControllerProperties {\n      */\n     private int maxRunTimeSeconds = 3600;\n \n-    /**\n-     * Default max query run time.\n-     */\n-    private int maxRunTimeMinutes = 60;\n-\n     /**\n      * Whether or not the cleanup is enabled.\n      */\n"}}, {"oid": "437643db56fb4437b39b2962f90f413f1a9a73df", "url": "https://github.com/yahoo/elide/commit/437643db56fb4437b39b2962f90f413f1a9a73df", "message": "fixes", "committedDate": "2020-08-17T18:54:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MjUzOQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474172539", "bodyText": "Any reason not to make this public?", "author": "aklish", "createdAt": "2020-08-20T18:00:25Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DateUtil.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+\n+package com.yahoo.elide.async.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+/**\n+ * Utility class which implements a static method calculateFilterDate.\n+ */\n+@Slf4j\n+public class DateUtil {\n+\n+    /**\n+     * Calculated and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return filter date\n+     */\n+     protected static Date calculateFilterDate(int calendarUnit, int amount) {", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69559cc16e21e5695342be7f6660384aa5eeae9c", "chunk": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DateUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DateUtil.java\nindex c57e7d757..e98a05508 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DateUtil.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DateUtil.java\n\n@@ -23,7 +23,7 @@ public class DateUtil {\n      * @param amount Amount of days to be subtracted from current time\n      * @return filter date\n      */\n-     protected static Date calculateFilterDate(int calendarUnit, int amount) {\n+     public Date calculateFilterDate(int calendarUnit, int amount) {\n         Calendar cal = Calendar.getInstance();\n         cal.setTime(new Date());\n         cal.add(calendarUnit, -(amount));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4MTAxOA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474181018", "bodyText": "You could also verify the status argument here.", "author": "aklish", "createdAt": "2020-08-20T18:16:15Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private TransactionRegistry transactionRegistry;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao);\n+        transactionRegistry = elide.getTransactionRegistry();\n+\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testActiveTransactionCancellation() {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69559cc16e21e5695342be7f6660384aa5eeae9c", "chunk": "diff --git a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\nindex ba42adfab..6b16c42a4 100644\n--- a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n+++ b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n\n@@ -81,8 +81,11 @@ public class AsyncQueryCancelThreadTest {\n         when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n         cancelThread.cancelAsyncQuery();\n         ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n-        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());\n+        ArgumentCaptor<QueryStatus> statusCaptor = ArgumentCaptor.forClass(QueryStatus.class);\n+        verify(asyncQueryDao, times(1)).loadAsyncQueryCollection(any());\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), statusCaptor.capture());\n         assertEquals(\"asyncQuery.id IN [[edc4a871-dff2-4054-804e-d80075cf828d]]\", filterCaptor.getValue().toString());\n+        assertEquals(\"CANCEL_COMPLETE\", statusCaptor.getValue().toString());\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4MzY1Mg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474183652", "bodyText": "Can we verify the load statement as well?", "author": "aklish", "createdAt": "2020-08-20T18:21:08Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private TransactionRegistry transactionRegistry;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao);\n+        transactionRegistry = elide.getTransactionRegistry();\n+\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testActiveTransactionCancellation() {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69559cc16e21e5695342be7f6660384aa5eeae9c", "chunk": "diff --git a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\nindex ba42adfab..6b16c42a4 100644\n--- a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n+++ b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n\n@@ -81,8 +81,11 @@ public class AsyncQueryCancelThreadTest {\n         when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n         cancelThread.cancelAsyncQuery();\n         ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n-        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());\n+        ArgumentCaptor<QueryStatus> statusCaptor = ArgumentCaptor.forClass(QueryStatus.class);\n+        verify(asyncQueryDao, times(1)).loadAsyncQueryCollection(any());\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), statusCaptor.capture());\n         assertEquals(\"asyncQuery.id IN [[edc4a871-dff2-4054-804e-d80075cf828d]]\", filterCaptor.getValue().toString());\n+        assertEquals(\"CANCEL_COMPLETE\", statusCaptor.getValue().toString());\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4MzgxMQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474183811", "bodyText": "Can we verify the updateStatus statement as well?", "author": "aklish", "createdAt": "2020-08-20T18:21:28Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private TransactionRegistry transactionRegistry;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao);\n+        transactionRegistry = elide.getTransactionRegistry();\n+\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testActiveTransactionCancellation() {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());\n+        assertEquals(\"asyncQuery.id IN [[edc4a871-dff2-4054-804e-d80075cf828d]]\", filterCaptor.getValue().toString());\n+    }\n+\n+    @Test\n+    public void testStatusBasedFilter() throws ParseException {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf827d\"), dtx);\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf826d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.CANCEL_COMPLETE);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.CANCELLED);\n+        AsyncQuery asyncQuery3 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf826d\",\n+                1577883600000L, QueryStatus.PROCESSING);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        asyncCollection.add(asyncQuery3);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69559cc16e21e5695342be7f6660384aa5eeae9c", "chunk": "diff --git a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\nindex ba42adfab..6b16c42a4 100644\n--- a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n+++ b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n\n@@ -81,8 +81,11 @@ public class AsyncQueryCancelThreadTest {\n         when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n         cancelThread.cancelAsyncQuery();\n         ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n-        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());\n+        ArgumentCaptor<QueryStatus> statusCaptor = ArgumentCaptor.forClass(QueryStatus.class);\n+        verify(asyncQueryDao, times(1)).loadAsyncQueryCollection(any());\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), statusCaptor.capture());\n         assertEquals(\"asyncQuery.id IN [[edc4a871-dff2-4054-804e-d80075cf828d]]\", filterCaptor.getValue().toString());\n+        assertEquals(\"CANCEL_COMPLETE\", statusCaptor.getValue().toString());\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4NDE3MQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474184171", "bodyText": "Verify the status.", "author": "aklish", "createdAt": "2020-08-20T18:22:09Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private TransactionRegistry transactionRegistry;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao);\n+        transactionRegistry = elide.getTransactionRegistry();\n+\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testActiveTransactionCancellation() {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());\n+        assertEquals(\"asyncQuery.id IN [[edc4a871-dff2-4054-804e-d80075cf828d]]\", filterCaptor.getValue().toString());\n+    }\n+\n+    @Test\n+    public void testStatusBasedFilter() throws ParseException {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf827d\"), dtx);\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf826d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.CANCEL_COMPLETE);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.CANCELLED);\n+        AsyncQuery asyncQuery3 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf826d\",\n+                1577883600000L, QueryStatus.PROCESSING);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        asyncCollection.add(asyncQuery3);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> fltStatusCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).loadAsyncQueryCollection(fltStatusCaptor.capture());\n+        assertEquals(\"asyncQuery.status IN [[CANCELLED, PROCESSING, QUEUED]]\", fltStatusCaptor.getValue().toString());\n+\n+    }\n+\n+    @Test\n+    public void testTimeBasedCancellation() {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf827d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                System.currentTimeMillis(), QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery3 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf826d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        asyncCollection.add(asyncQuery3);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69559cc16e21e5695342be7f6660384aa5eeae9c", "chunk": "diff --git a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\nindex ba42adfab..6b16c42a4 100644\n--- a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n+++ b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java\n\n@@ -81,8 +81,11 @@ public class AsyncQueryCancelThreadTest {\n         when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n         cancelThread.cancelAsyncQuery();\n         ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n-        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());\n+        ArgumentCaptor<QueryStatus> statusCaptor = ArgumentCaptor.forClass(QueryStatus.class);\n+        verify(asyncQueryDao, times(1)).loadAsyncQueryCollection(any());\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), statusCaptor.capture());\n         assertEquals(\"asyncQuery.id IN [[edc4a871-dff2-4054-804e-d80075cf828d]]\", filterCaptor.getValue().toString());\n+        assertEquals(\"CANCEL_COMPLETE\", statusCaptor.getValue().toString());\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4NTUwNg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474185506", "bodyText": "It's possible for this test to fail because of a 1ms gap between when this date is calculated and when the delete filter is generated.   We'll need to find a less brittle approach.", "author": "aklish", "createdAt": "2020-08-20T18:24:38Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java", "diffHunk": "@@ -58,15 +59,19 @@ public void testAsyncQueryCleanerThreadSet() {\n \n     @Test\n     public void testDeleteAsyncQuery() {\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.deleteAsyncQuery();\n-\n-        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(anyString());\n+        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(filterCaptor.capture());\n+        Long date = System.currentTimeMillis() - (cleanerThread.getQueryCleanupDays() * 24 * 3600 * 1000);", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69559cc16e21e5695342be7f6660384aa5eeae9c", "chunk": "diff --git a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java\nindex b6d66f3dc..cf0908324 100644\n--- a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java\n+++ b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java\n\n@@ -59,19 +64,19 @@ public class AsyncQueryCleanerThreadTest {\n \n     @Test\n     public void testDeleteAsyncQuery() {\n+        when(dateUtil.calculateFilterDate(Calendar.DATE, cleanerThread.getQueryCleanupDays())).thenReturn(testDate);\n         ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.deleteAsyncQuery();\n         verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(filterCaptor.capture());\n-        Long date = System.currentTimeMillis() - (cleanerThread.getQueryCleanupDays() * 24 * 3600 * 1000);\n-        assertEquals(\"asyncQuery.createdOn LE [\" + new Date(date) + \"]\", filterCaptor.getValue().toString());\n+        assertEquals(\"asyncQuery.createdOn LE [\" + testDate + \"]\", filterCaptor.getValue().toString());\n     }\n \n     @Test\n     public void testTimeoutAsyncQuery() {\n+        when(dateUtil.calculateFilterDate(Calendar.MINUTE, cleanerThread.getMaxRunTimeMinutes())).thenReturn(testDate);\n         ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.timeoutAsyncQuery();\n         verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any(QueryStatus.class));\n-        Long date = System.currentTimeMillis() - (cleanerThread.getMaxRunTimeMinutes() * 60 * 1000);\n-        assertEquals(\"(asyncQuery.status IN [[PROCESSING, QUEUED]] AND asyncQuery.createdOn LE [\" + new Date(date) + \"])\", filterCaptor.getValue().toString());\n+        assertEquals(\"(asyncQuery.status IN [[PROCESSING, QUEUED]] AND asyncQuery.createdOn LE [\" + testDate + \"])\", filterCaptor.getValue().toString());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4NTcwNg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474185706", "bodyText": "Same comment on date.", "author": "aklish", "createdAt": "2020-08-20T18:25:00Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java", "diffHunk": "@@ -58,15 +59,19 @@ public void testAsyncQueryCleanerThreadSet() {\n \n     @Test\n     public void testDeleteAsyncQuery() {\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.deleteAsyncQuery();\n-\n-        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(anyString());\n+        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(filterCaptor.capture());\n+        Long date = System.currentTimeMillis() - (cleanerThread.getQueryCleanupDays() * 24 * 3600 * 1000);\n+        assertEquals(\"asyncQuery.createdOn LE [\" + new Date(date) + \"]\", filterCaptor.getValue().toString());\n     }\n \n     @Test\n-    public void timeoutAsyncQuery() {\n+    public void testTimeoutAsyncQuery() {\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.timeoutAsyncQuery();\n-\n-        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(anyString(), any(QueryStatus.class));\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any(QueryStatus.class));\n+        Long date = System.currentTimeMillis() - (cleanerThread.getMaxRunTimeMinutes() * 60 * 1000);", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69559cc16e21e5695342be7f6660384aa5eeae9c", "chunk": "diff --git a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java\nindex b6d66f3dc..cf0908324 100644\n--- a/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java\n+++ b/elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java\n\n@@ -59,19 +64,19 @@ public class AsyncQueryCleanerThreadTest {\n \n     @Test\n     public void testDeleteAsyncQuery() {\n+        when(dateUtil.calculateFilterDate(Calendar.DATE, cleanerThread.getQueryCleanupDays())).thenReturn(testDate);\n         ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.deleteAsyncQuery();\n         verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(filterCaptor.capture());\n-        Long date = System.currentTimeMillis() - (cleanerThread.getQueryCleanupDays() * 24 * 3600 * 1000);\n-        assertEquals(\"asyncQuery.createdOn LE [\" + new Date(date) + \"]\", filterCaptor.getValue().toString());\n+        assertEquals(\"asyncQuery.createdOn LE [\" + testDate + \"]\", filterCaptor.getValue().toString());\n     }\n \n     @Test\n     public void testTimeoutAsyncQuery() {\n+        when(dateUtil.calculateFilterDate(Calendar.MINUTE, cleanerThread.getMaxRunTimeMinutes())).thenReturn(testDate);\n         ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.timeoutAsyncQuery();\n         verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any(QueryStatus.class));\n-        Long date = System.currentTimeMillis() - (cleanerThread.getMaxRunTimeMinutes() * 60 * 1000);\n-        assertEquals(\"(asyncQuery.status IN [[PROCESSING, QUEUED]] AND asyncQuery.createdOn LE [\" + new Date(date) + \"])\", filterCaptor.getValue().toString());\n+        assertEquals(\"(asyncQuery.status IN [[PROCESSING, QUEUED]] AND asyncQuery.createdOn LE [\" + testDate + \"])\", filterCaptor.getValue().toString());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5MTc0Ng==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474191746", "bodyText": "The other comment for standalone was:\n\"Number of seconds between async query cancellation checks.\"\nLet's use the same comment for both standalone and spring and maybe change to:\n\"Polling interval to identify async queries that should be canceled.\"\nAlso, 300 seconds is way too long for this interval.  It should probably be somewhere in the 1-10 second range by default.", "author": "aklish", "createdAt": "2020-08-20T18:35:44Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java", "diffHunk": "@@ -33,6 +33,12 @@\n      */\n     private int queryCleanupDays = 7;\n \n+    /**\n+     * Default time interval for cancelling async query transactions", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69559cc16e21e5695342be7f6660384aa5eeae9c", "chunk": "diff --git a/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java b/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\nindex bd17c84ad..080b52ed9 100644\n--- a/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\n+++ b/elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java\n\n@@ -34,10 +34,9 @@ public class AsyncProperties extends ControllerProperties {\n     private int queryCleanupDays = 7;\n \n     /**\n-     * Default time interval for cancelling async query transactions\n-     * that are in cancelled status or running beyond max runtime.\n+     * Polling interval to identify async queries that should be canceled.\n      */\n-    private int queryCancellationIntervalSeconds = 300;\n+    private int queryCancellationIntervalSeconds = 10;\n \n     /**\n      * Whether or not to use the default implementation of AsyncQueryDAO.\n"}}, {"oid": "69559cc16e21e5695342be7f6660384aa5eeae9c", "url": "https://github.com/yahoo/elide/commit/69559cc16e21e5695342be7f6660384aa5eeae9c", "message": "mocking date util, and extra verifications for unit tests", "committedDate": "2020-08-20T20:46:07Z", "type": "commit"}]}