{"pr_number": 2155, "pr_title": "LUCENE-9641: Support for spatial relationships in LatLonPoint", "pr_createdAt": "2020-12-17T14:43:48Z", "pr_url": "https://github.com/apache/lucene-solr/pull/2155", "timeline": [{"oid": "829e94e7c2b97b2905e9d465d7d4f22a79570695", "url": "https://github.com/apache/lucene-solr/commit/829e94e7c2b97b2905e9d465d7d4f22a79570695", "message": "LUCENE-9641: Support for spatial relationships in LatLonPoint", "committedDate": "2020-12-17T14:31:54Z", "type": "commit"}, {"oid": "7e39b06b71c8bceb1656eb8c71addb6d8e060ac8", "url": "https://github.com/apache/lucene-solr/commit/7e39b06b71c8bceb1656eb8c71addb6d8e060ac8", "message": "tidy up LatLonDocValuesQuery", "committedDate": "2020-12-17T14:57:01Z", "type": "commit"}, {"oid": "21118cbc95b2e0541b5cb5315db0d9691a0d529f", "url": "https://github.com/apache/lucene-solr/commit/21118cbc95b2e0541b5cb5315db0d9691a0d529f", "message": "make points behave as rectangles", "committedDate": "2020-12-19T08:48:47Z", "type": "commit"}, {"oid": "a73e07da2dc4dfc5899ec8f2429310cc25e8ff5e", "url": "https://github.com/apache/lucene-solr/commit/a73e07da2dc4dfc5899ec8f2429310cc25e8ff5e", "message": "adjust test to new point behavior", "committedDate": "2020-12-20T11:55:31Z", "type": "commit"}, {"oid": "02ac575ead5a957554a258a645b1ec7d39673495", "url": "https://github.com/apache/lucene-solr/commit/02ac575ead5a957554a258a645b1ec7d39673495", "message": "simplify tests", "committedDate": "2020-12-21T06:33:52Z", "type": "commit"}, {"oid": "977e328c6bcd62d11b7811192dba694f373f3bf0", "url": "https://github.com/apache/lucene-solr/commit/977e328c6bcd62d11b7811192dba694f373f3bf0", "message": "more test simplification", "committedDate": "2020-12-21T06:53:35Z", "type": "commit"}, {"oid": "00526973714ba6cb09e8cb0788d175170d1f2090", "url": "https://github.com/apache/lucene-solr/commit/00526973714ba6cb09e8cb0788d175170d1f2090", "message": "better contains handling", "committedDate": "2020-12-21T13:30:52Z", "type": "commit"}, {"oid": "e1b1551e0bae0f70aaf95beae70a8d519d1180e2", "url": "https://github.com/apache/lucene-solr/commit/e1b1551e0bae0f70aaf95beae70a8d519d1180e2", "message": "precommit", "committedDate": "2020-12-21T13:39:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg1ODAxOQ==", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r546858019", "bodyText": "It doesn't make sense for LatLonPointQuery to search for Points that contain any geometry other than points. I'd throw an exception if the incoming geometry type is not a point or array of points.", "author": "nknize", "createdAt": "2020-12-21T18:19:47Z", "path": "lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.document;\n+\n+import org.apache.lucene.document.ShapeField.QueryRelation;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.geo.GeoEncodingUtils;\n+import org.apache.lucene.geo.LatLonGeometry;\n+import org.apache.lucene.geo.Line;\n+import org.apache.lucene.index.PointValues.Relation;\n+import org.apache.lucene.util.NumericUtils;\n+\n+import java.util.Arrays;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLongitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLongitude;\n+\n+/**\n+ * Finds all previously indexed geo points that comply the given {@link QueryRelation} with\n+ * the specified array of {@link LatLonGeometry}.\n+ *\n+ * <p>The field must be indexed using one or more {@link LatLonPoint} added per document.\n+ *\n+ **/\n+final class LatLonPointQuery extends SpatialQuery {\n+  final private LatLonGeometry[] geometries;\n+  final private Component2D component2D;\n+  \n+  /**\n+   * Creates a query that matches all indexed shapes to the provided array of {@link LatLonGeometry}\n+   */\n+  LatLonPointQuery(String field, QueryRelation queryRelation, LatLonGeometry... geometries) {\n+    super(field, queryRelation);\n+    if (queryRelation == QueryRelation.WITHIN) {\n+      for (LatLonGeometry geometry : geometries) {\n+        if (geometry instanceof Line) {\n+          // TODO: line queries do not support within relations\n+          throw new IllegalArgumentException(\"LatLonPointQuery does not support \" + QueryRelation.WITHIN + \" queries with line geometries\");\n+        }\n+      }\n+    }\n+    this.component2D = LatLonGeometry.create(geometries);\n+    this.geometries = geometries.clone();\n+  }\n+  \n+  @Override\n+  protected SpatialVisitor getSpatialVisitor() {\n+    if (component2D.getMinY() > component2D.getMaxY()) {\n+      // encodeLatitudeCeil may cause minY to be > maxY iff\n+      // the delta between the longitude < the encoding resolution\n+      return EMPTYVISITOR;\n+    }\n+    final GeoEncodingUtils.Component2DPredicate component2DPredicate = GeoEncodingUtils.createComponentPredicate(component2D);\n+    // bounding box over all geometries, this can speed up tree intersection/cheaply improve approximation for complex multi-geometries\n+    final byte[] minLat = new byte[Integer.BYTES];\n+    final byte[] maxLat = new byte[Integer.BYTES];\n+    final byte[] minLon = new byte[Integer.BYTES];\n+    final byte[] maxLon = new byte[Integer.BYTES];\n+    NumericUtils.intToSortableBytes(encodeLatitude(component2D.getMinY()), minLat, 0);\n+    NumericUtils.intToSortableBytes(encodeLatitude(component2D.getMaxY()), maxLat, 0);\n+    NumericUtils.intToSortableBytes(encodeLongitude(component2D.getMinX()), minLon, 0);\n+    NumericUtils.intToSortableBytes(encodeLongitude(component2D.getMaxX()), maxLon, 0);\n+    \n+    return new SpatialVisitor() {\n+      @Override\n+      protected Relation relate(byte[] minPackedValue, byte[] maxPackedValue) {\n+        if (Arrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n+                Arrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n+                Arrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n+                Arrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n+          // outside of global bounding box range\n+          return Relation.CELL_OUTSIDE_QUERY;\n+        }\n+\n+        double cellMinLat = decodeLatitude(minPackedValue, 0);\n+        double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n+        double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n+        double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n+\n+        return component2D.relate(cellMinLon, cellMaxLon, cellMinLat, cellMaxLat);\n+      }\n+\n+      @Override\n+      protected Predicate<byte[]> intersects() {\n+        return packedValue -> component2DPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n+                NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES));\n+      }\n+\n+      @Override\n+      protected Predicate<byte[]> within() {\n+        return packedValue -> component2DPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n+                NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES));\n+      }\n+\n+      @Override\n+      protected Function<byte[], Component2D.WithinRelation> contains() {\n+        return packedValue -> component2D.withinPoint(", "originalCommit": "e1b1551e0bae0f70aaf95beae70a8d519d1180e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2NjU2NA==", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r547166564", "bodyText": "Make sense and makes implementation cleaner. Still I return a MatchNoDocs query for the Query builders. Change is in 3e97bb8.", "author": "iverase", "createdAt": "2020-12-22T09:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg1ODAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg3MTc2Ng==", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r552871766", "bodyText": "This looks good!", "author": "nknize", "createdAt": "2021-01-06T18:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg1ODAxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "1cebeff82bb126911663000c525d19fcc6693be5", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java b/lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java\nindex 07b638d9eec..e25ffadc8b4 100644\n--- a/lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java\n+++ b/lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java\n\n@@ -63,11 +63,6 @@ final class LatLonPointQuery extends SpatialQuery {\n   \n   @Override\n   protected SpatialVisitor getSpatialVisitor() {\n-    if (component2D.getMinY() > component2D.getMaxY()) {\n-      // encodeLatitudeCeil may cause minY to be > maxY iff\n-      // the delta between the longitude < the encoding resolution\n-      return EMPTYVISITOR;\n-    }\n     final GeoEncodingUtils.Component2DPredicate component2DPredicate = GeoEncodingUtils.createComponentPredicate(component2D);\n     // bounding box over all geometries, this can speed up tree intersection/cheaply improve approximation for complex multi-geometries\n     final byte[] minLat = new byte[Integer.BYTES];\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2NTI0Mw==", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r546865243", "bodyText": "I feel like there should be a better way of handling this. This has the look and feel of silent ignorance; that the encoding allowed something that doesn't make sense. I think we should do a better job handling this upstream instead of creating a visitor that looks the other way on such oddities.", "author": "nknize", "createdAt": "2020-12-21T18:35:58Z", "path": "lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.document;\n+\n+import org.apache.lucene.document.ShapeField.QueryRelation;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.geo.GeoEncodingUtils;\n+import org.apache.lucene.geo.LatLonGeometry;\n+import org.apache.lucene.geo.Line;\n+import org.apache.lucene.index.PointValues.Relation;\n+import org.apache.lucene.util.NumericUtils;\n+\n+import java.util.Arrays;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLongitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLongitude;\n+\n+/**\n+ * Finds all previously indexed geo points that comply the given {@link QueryRelation} with\n+ * the specified array of {@link LatLonGeometry}.\n+ *\n+ * <p>The field must be indexed using one or more {@link LatLonPoint} added per document.\n+ *\n+ **/\n+final class LatLonPointQuery extends SpatialQuery {\n+  final private LatLonGeometry[] geometries;\n+  final private Component2D component2D;\n+  \n+  /**\n+   * Creates a query that matches all indexed shapes to the provided array of {@link LatLonGeometry}\n+   */\n+  LatLonPointQuery(String field, QueryRelation queryRelation, LatLonGeometry... geometries) {\n+    super(field, queryRelation);\n+    if (queryRelation == QueryRelation.WITHIN) {\n+      for (LatLonGeometry geometry : geometries) {\n+        if (geometry instanceof Line) {\n+          // TODO: line queries do not support within relations\n+          throw new IllegalArgumentException(\"LatLonPointQuery does not support \" + QueryRelation.WITHIN + \" queries with line geometries\");\n+        }\n+      }\n+    }\n+    this.component2D = LatLonGeometry.create(geometries);\n+    this.geometries = geometries.clone();\n+  }\n+  \n+  @Override\n+  protected SpatialVisitor getSpatialVisitor() {\n+    if (component2D.getMinY() > component2D.getMaxY()) {\n+      // encodeLatitudeCeil may cause minY to be > maxY iff\n+      // the delta between the longitude < the encoding resolution\n+      return EMPTYVISITOR;", "originalCommit": "e1b1551e0bae0f70aaf95beae70a8d519d1180e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2NTgxOA==", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r547165818", "bodyText": "The problem was in the way the component predicate is built. I have another thought and I think I push a better solution in 1cebeff", "author": "iverase", "createdAt": "2020-12-22T09:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2NTI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg3MTU3NQ==", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r552871575", "bodyText": "\ud83d\udc4d  Much cleaner.", "author": "nknize", "createdAt": "2021-01-06T18:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2NTI0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "1cebeff82bb126911663000c525d19fcc6693be5", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java b/lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java\nindex 07b638d9eec..e25ffadc8b4 100644\n--- a/lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java\n+++ b/lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java\n\n@@ -63,11 +63,6 @@ final class LatLonPointQuery extends SpatialQuery {\n   \n   @Override\n   protected SpatialVisitor getSpatialVisitor() {\n-    if (component2D.getMinY() > component2D.getMaxY()) {\n-      // encodeLatitudeCeil may cause minY to be > maxY iff\n-      // the delta between the longitude < the encoding resolution\n-      return EMPTYVISITOR;\n-    }\n     final GeoEncodingUtils.Component2DPredicate component2DPredicate = GeoEncodingUtils.createComponentPredicate(component2D);\n     // bounding box over all geometries, this can speed up tree intersection/cheaply improve approximation for complex multi-geometries\n     final byte[] minLat = new byte[Integer.BYTES];\n"}}, {"oid": "1cebeff82bb126911663000c525d19fcc6693be5", "url": "https://github.com/apache/lucene-solr/commit/1cebeff82bb126911663000c525d19fcc6693be5", "message": "Make componentPredicate safer to encodingCeil", "committedDate": "2020-12-22T07:16:22Z", "type": "commit"}, {"oid": "3e97bb8d6b31c197869586b4b1d1272c776b32f5", "url": "https://github.com/apache/lucene-solr/commit/3e97bb8d6b31c197869586b4b1d1272c776b32f5", "message": "Better handling of contain queries for non-point geometries", "committedDate": "2020-12-22T09:09:55Z", "type": "commit"}, {"oid": "d8da62eb8227552c70f809bcf3fabc36abb9bb93", "url": "https://github.com/apache/lucene-solr/commit/d8da62eb8227552c70f809bcf3fabc36abb9bb93", "message": "Merge branch 'master' into pointSpatialRel", "committedDate": "2020-12-24T08:18:44Z", "type": "commit"}, {"oid": "1ed504bf8f21705b4ad5e7d708aa853621f10d49", "url": "https://github.com/apache/lucene-solr/commit/1ed504bf8f21705b4ad5e7d708aa853621f10d49", "message": "SpotLess formatting", "committedDate": "2020-12-24T08:20:31Z", "type": "commit"}, {"oid": "860a53da1b9dac463796061b118ee0f96b0ed24c", "url": "https://github.com/apache/lucene-solr/commit/860a53da1b9dac463796061b118ee0f96b0ed24c", "message": "Merge branch 'master' into pointSpatialRel", "committedDate": "2021-01-07T06:52:16Z", "type": "commit"}, {"oid": "8bb93109e27c41947706be41a99619881648f952", "url": "https://github.com/apache/lucene-solr/commit/8bb93109e27c41947706be41a99619881648f952", "message": "Add entry in CHANGES.txt", "committedDate": "2021-01-07T06:58:37Z", "type": "commit"}]}