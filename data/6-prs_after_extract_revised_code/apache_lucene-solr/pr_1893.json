{"pr_number": 1893, "pr_title": "LUCENE-9444 Utility class to get facet labels from taxonomy for a fac\u2026", "pr_createdAt": "2020-09-19T01:31:15Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1893", "timeline": [{"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a", "url": "https://github.com/apache/lucene-solr/commit/bf8eaf98901cbe83f23067bea90dfb2f3102603a", "message": "LUCENE-9444 Utility class to get facet labels from taxonomy for a facet field. This is useful if a facet field is requested in the list of return fields for each hit.", "committedDate": "2020-09-19T01:17:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MTg4Ng==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493041886", "bodyText": "Hmm let's upgrade this to a real if not an assert (that requires that assertions are enabled), and change to throw IllegalArgumentException?  In general if it is a problem that a user could legitimately trip up on, it should be a real if, as long as performance impact of such micro-policing is acceptable (which should be the case here).", "author": "mikemccand", "createdAt": "2020-09-22T21:23:10Z", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;", "originalCommit": "bf8eaf98901cbe83f23067bea90dfb2f3102603a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExMjk4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493112985", "bodyText": "Changed in the next revision.", "author": "goankur", "createdAt": "2020-09-23T00:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MTg4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "chunk": "diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\nindex 3f4be448c3e..5f031e32ac5 100644\n--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n\n@@ -107,13 +107,19 @@ public class TaxonomyFacetLabels {\n      * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n      * new {@code docId} must be in strictly monotonic (increasing) order.\n      *\n+     * <p><b>NOTE</b>: The returned FacetLabels may not be in the same order in which they were indexed</p>\n+     *\n      * @param docId input docId provided in monotonic (non-decreasing) order\n      * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n      * @throws IOException when a low-level IO issue occurs\n+     * @throws IllegalArgumentException if docId provided is less than docId supplied in an earlier invocation\n      */\n     public FacetLabel nextFacetLabel(int docId) throws IOException {\n       if (currentDocId != docId) {\n-        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        if (docId < currentDocId) {\n+          throw new IllegalArgumentException(\"docs out of order: previous docId=\" + currentDocId\n+              + \" current docId=\" + docId);\n+        }\n         ordinalsSegmentReader.get(docId, decodedOrds);\n         currentDocId = docId;\n         currentPos = decodedOrds.offset;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MjI1MQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493042251", "bodyText": "This one is a good usage of assert because this should only be violated if there is a bug in this code or our default Codec, etc.  No accidental abuse by users could cause this.", "author": "mikemccand", "createdAt": "2020-09-22T21:23:59Z", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;", "originalCommit": "bf8eaf98901cbe83f23067bea90dfb2f3102603a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExMzUxMg==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493113512", "bodyText": "Got it thanks for explaining appropriate usage of assert and IlegalArgumentException", "author": "goankur", "createdAt": "2020-09-23T00:55:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MjI1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "chunk": "diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\nindex 3f4be448c3e..5f031e32ac5 100644\n--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n\n@@ -107,13 +107,19 @@ public class TaxonomyFacetLabels {\n      * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n      * new {@code docId} must be in strictly monotonic (increasing) order.\n      *\n+     * <p><b>NOTE</b>: The returned FacetLabels may not be in the same order in which they were indexed</p>\n+     *\n      * @param docId input docId provided in monotonic (non-decreasing) order\n      * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n      * @throws IOException when a low-level IO issue occurs\n+     * @throws IllegalArgumentException if docId provided is less than docId supplied in an earlier invocation\n      */\n     public FacetLabel nextFacetLabel(int docId) throws IOException {\n       if (currentDocId != docId) {\n-        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        if (docId < currentDocId) {\n+          throw new IllegalArgumentException(\"docs out of order: previous docId=\" + currentDocId\n+              + \" current docId=\" + docId);\n+        }\n         ordinalsSegmentReader.get(docId, decodedOrds);\n         currentDocId = docId;\n         currentPos = decodedOrds.offset;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0Mjg2MQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493042861", "bodyText": "Can we add a Note here, that the returned FacetLabel are not necessarily in the same order in which they were indexed?", "author": "mikemccand", "createdAt": "2020-09-22T21:25:23Z", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order", "originalCommit": "bf8eaf98901cbe83f23067bea90dfb2f3102603a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNDEzOQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493114139", "bodyText": "done in next revision", "author": "goankur", "createdAt": "2020-09-23T00:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0Mjg2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "chunk": "diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\nindex 3f4be448c3e..5f031e32ac5 100644\n--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n\n@@ -107,13 +107,19 @@ public class TaxonomyFacetLabels {\n      * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n      * new {@code docId} must be in strictly monotonic (increasing) order.\n      *\n+     * <p><b>NOTE</b>: The returned FacetLabels may not be in the same order in which they were indexed</p>\n+     *\n      * @param docId input docId provided in monotonic (non-decreasing) order\n      * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n      * @throws IOException when a low-level IO issue occurs\n+     * @throws IllegalArgumentException if docId provided is less than docId supplied in an earlier invocation\n      */\n     public FacetLabel nextFacetLabel(int docId) throws IOException {\n       if (currentDocId != docId) {\n-        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        if (docId < currentDocId) {\n+          throw new IllegalArgumentException(\"docs out of order: previous docId=\" + currentDocId\n+              + \" current docId=\" + docId);\n+        }\n         ordinalsSegmentReader.get(docId, decodedOrds);\n         currentDocId = docId;\n         currentPos = decodedOrds.offset;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MzAxNw==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493043017", "bodyText": "Add same Note here as above comment?", "author": "mikemccand", "createdAt": "2020-09-22T21:25:44Z", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>", "originalCommit": "bf8eaf98901cbe83f23067bea90dfb2f3102603a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNDIwOA==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493114208", "bodyText": "done in next revision", "author": "goankur", "createdAt": "2020-09-23T00:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MzAxNw=="}], "type": "inlineReview", "revised_code": {"commit": "75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "chunk": "diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\nindex 3f4be448c3e..5f031e32ac5 100644\n--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n\n@@ -107,13 +107,19 @@ public class TaxonomyFacetLabels {\n      * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n      * new {@code docId} must be in strictly monotonic (increasing) order.\n      *\n+     * <p><b>NOTE</b>: The returned FacetLabels may not be in the same order in which they were indexed</p>\n+     *\n      * @param docId input docId provided in monotonic (non-decreasing) order\n      * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n      * @throws IOException when a low-level IO issue occurs\n+     * @throws IllegalArgumentException if docId provided is less than docId supplied in an earlier invocation\n      */\n     public FacetLabel nextFacetLabel(int docId) throws IOException {\n       if (currentDocId != docId) {\n-        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        if (docId < currentDocId) {\n+          throw new IllegalArgumentException(\"docs out of order: previous docId=\" + currentDocId\n+              + \" current docId=\" + docId);\n+        }\n         ordinalsSegmentReader.get(docId, decodedOrds);\n         currentDocId = docId;\n         currentPos = decodedOrds.offset;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MzI4MA==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493043280", "bodyText": "Can we upgrade this to a real if?  Caller might legitimately pass in a non-existing facetDimension?", "author": "mikemccand", "createdAt": "2020-09-22T21:26:21Z", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;", "originalCommit": "bf8eaf98901cbe83f23067bea90dfb2f3102603a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNzUyMg==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493117522", "bodyText": "done in next revision.", "author": "goankur", "createdAt": "2020-09-23T01:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MzI4MA=="}], "type": "inlineReview", "revised_code": {"commit": "75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "chunk": "diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\nindex 3f4be448c3e..5f031e32ac5 100644\n--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n\n@@ -107,13 +107,19 @@ public class TaxonomyFacetLabels {\n      * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n      * new {@code docId} must be in strictly monotonic (increasing) order.\n      *\n+     * <p><b>NOTE</b>: The returned FacetLabels may not be in the same order in which they were indexed</p>\n+     *\n      * @param docId input docId provided in monotonic (non-decreasing) order\n      * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n      * @throws IOException when a low-level IO issue occurs\n+     * @throws IllegalArgumentException if docId provided is less than docId supplied in an earlier invocation\n      */\n     public FacetLabel nextFacetLabel(int docId) throws IOException {\n       if (currentDocId != docId) {\n-        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        if (docId < currentDocId) {\n+          throw new IllegalArgumentException(\"docs out of order: previous docId=\" + currentDocId\n+              + \" current docId=\" + docId);\n+        }\n         ordinalsSegmentReader.get(docId, decodedOrds);\n         currentDocId = docId;\n         currentPos = decodedOrds.offset;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NTk1MA==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493045950", "bodyText": "Ahh, be careful here!  Lucene's test-framework sometimes randomly runs without assertions enabled, to help us catch bugs where we accidentally create code relying on assertions (it has happened, do not ask who).\nSo when tests run with assertions disabled then this test would false-fail?  But, if we upgrade to real if that would also fix this.", "author": "mikemccand", "createdAt": "2020-09-22T21:32:13Z", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.facet.FacetField;\n+import org.apache.lucene.facet.FacetTestCase;\n+import org.apache.lucene.facet.FacetsCollector;\n+import org.apache.lucene.facet.FacetsCollector.MatchingDocs;\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.IOUtils;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class TestTaxonomyLabels extends FacetTestCase {\n+\n+  private List<Document> prepareDocuments() {\n+    List<Document> docs = new ArrayList<>();\n+\n+    Document doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Bob\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"15\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Lisa\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"20\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Tom\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"1\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Susan\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"7\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Frank\"));\n+    doc.add(new FacetField(\"Publish Date\", \"1999\", \"5\", \"5\"));\n+    docs.add(doc);\n+\n+    return docs;\n+  }\n+\n+  private List<Integer> allDocIds(MatchingDocs m, boolean decreasingDocIds) throws IOException {\n+    DocIdSetIterator disi = m.bits.iterator();\n+    List<Integer> docIds = new ArrayList<>();\n+    while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n+      docIds.add(disi.docID());\n+    }\n+\n+    if (decreasingDocIds == true) {\n+      Collections.reverse(docIds);\n+    }\n+    return docIds;\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, null, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs,\n+                                             String dimension) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, dimension, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels, List<MatchingDocs> matchingDocs, String dimension,\n+                                             boolean decreasingDocIds) throws IOException {\n+    List<FacetLabel> facetLabels = new ArrayList<>();\n+\n+    for (MatchingDocs m : matchingDocs) {\n+      TaxonomyFacetLabels.FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n+      List<Integer> docIds = allDocIds(m, decreasingDocIds);\n+      FacetLabel facetLabel;\n+      for (Integer docId : docIds) {\n+        while (true) {\n+          if (dimension != null) {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId, dimension);\n+          } else {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId);\n+          }\n+\n+          if (facetLabel == null) {\n+            break;\n+          }\n+          facetLabels.add(facetLabel);\n+        }\n+      }\n+    }\n+\n+    return facetLabels;\n+  }\n+\n+\n+  public void testBasic() throws Exception {\n+    Directory dir = newDirectory();\n+    Directory taxoDir = newDirectory();\n+\n+    // Writes facet ords to a separate directory from the main index:\n+    DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir, IndexWriterConfig.OpenMode.CREATE);\n+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n+\n+    FacetsConfig config = new FacetsConfig();\n+    config.setHierarchical(\"Publish Date\", true);\n+\n+    for (Document doc : prepareDocuments()) {\n+      writer.addDocument(config.build(taxoWriter, doc));\n+    }\n+\n+    // NRT open\n+    IndexSearcher searcher = newSearcher(writer.getReader());\n+    // NRT open\n+    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoWriter);\n+\n+    FacetsCollector fc = new FacetsCollector();\n+    searcher.search(new MatchAllDocsQuery(), fc);\n+\n+    TaxonomyFacetLabels taxoLabels = new TaxonomyFacetLabels(taxoReader, config, FacetsConfig.DEFAULT_INDEX_FIELD_NAME);\n+\n+    // Check labels for all dimensions\n+    List<FacetLabel> facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs());\n+    assertTrue(facetLabels.size() == 10);\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Author\".equals(l.components[0]))\n+        .map(l -> l.components[1]).collect(Collectors.toSet())\n+        .equals(Set.of(\"Bob\", \"Lisa\", \"Susan\", \"Frank\", \"Tom\")));\n+\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Publish Date\".equals(l.components[0]))\n+        .map(l -> String.join(\"/\", l.components[1], l.components[2], l.components[3]))\n+        .collect(Collectors.toSet())\n+        .equals(Set.of(\"2010/10/15\", \"2010/10/20\", \"2012/1/1\", \"2012/1/7\", \"1999/5/5\")));\n+\n+    // Check labels for specific dimension\n+    facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs(), \"Publish Date\");\n+    assertTrue(facetLabels.size() == 5);\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Publish Date\".equals(l.components[0]))\n+        .map(l -> String.join(\"/\", l.components[1], l.components[2], l.components[3]))\n+        .collect(Collectors.toSet())\n+        .equals(Set.of(\"2010/10/15\", \"2010/10/20\", \"2012/1/1\", \"2012/1/7\", \"1999/5/5\")));\n+\n+    try {\n+      facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs(), null, true);\n+      fail(\"Assertion error was not thrown for using docIds supplied in decreasing order\");\n+    } catch (AssertionError ae) {", "originalCommit": "bf8eaf98901cbe83f23067bea90dfb2f3102603a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEzNzA1OA==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493137058", "bodyText": "Nice catch, I changed the implementation of nextFacetLabel(...) methods to throw IllegalArgumentException should docIds be supplied in decreasing order and updated this test to expect an IllegalArgumentException when docIds are supplied in decreasing order.", "author": "goankur", "createdAt": "2020-09-23T01:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NTk1MA=="}], "type": "inlineReview", "revised_code": {"commit": "75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "chunk": "diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java\nindex e5759c88005..3cae7a218e9 100644\n--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java\n+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java\n\n@@ -151,7 +151,9 @@ public class TestTaxonomyLabels extends FacetTestCase {\n \n     // Check labels for all dimensions\n     List<FacetLabel> facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs());\n-    assertTrue(facetLabels.size() == 10);\n+    assertEquals(\"Incorrect number of facet labels received\", 10, facetLabels.size());\n+\n+    // Check labels for all dimensions\n     assertTrue(facetLabels.stream()\n         .filter(l -> \"Author\".equals(l.components[0]))\n         .map(l -> l.components[1]).collect(Collectors.toSet())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493047095", "bodyText": "Hmm when we switch to BinaryDocValues for this lookup, we could fix this class to persistently hold a single BinaryDocValues, and improve performance for caller that need to look up multiple ordinals, which is the common case.", "author": "mikemccand", "createdAt": "2020-09-22T21:34:48Z", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;\n+\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentPos = decodedOrds.offset;\n+        currentDocId = docId;\n+      }\n+\n+      if (parents == null) {\n+        parents = taxoReader.getParallelTaxonomyArrays().parents();\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      for (; currentPos < endPos; ) {\n+        int ord = decodedOrds.ints[currentPos++];\n+        if (isDescendant(ord, parentOrd) == true) {\n+          return taxoReader.getPath(ord);", "originalCommit": "bf8eaf98901cbe83f23067bea90dfb2f3102603a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0ODI5Mw==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493148293", "bodyText": "By this class you mean TaxonomyReader because that is where BinaryDocValues will be cached as part of LUCENE-9476 improving performance for callers that need to lookup multiple ordinals ?", "author": "goankur", "createdAt": "2020-09-23T02:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5NTYxMA==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494395610", "bodyText": "Hmm, I was thinking this new per-segment class (FacetLabelReader) would hold onto a single BinaryDocValues instance, but you're right, that won't work.\nThe facet ordinals are stored / compacted in sorted order in a single BinaryDocValues field which we decode here into decodedOrds.  Resolving those ordinals to FacetLabel is costly, currently retrieving one stored document per ord.  After LUCENE-9450 (switching from stored fields to BDV), we could pull a new BDV for each unique docId passed to nextFacetLabel, and then bulk resolve all the ordinals?\nAnyway, we can pursue all of this later -- this PR already looks awesome -- progress not perfection!", "author": "mikemccand", "createdAt": "2020-09-24T15:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NTAwMA==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494675000", "bodyText": "The new per-segment class (FacetLabelReader) holds an instance of DocValuesOrdinalsReader which internally holds a reusable instance of BinaryDocValues.\nIn the nextFacetLabel() method ordinalsSegmentReader.get(docId, decodedOrds) that does the actual decoding of the ordinals is only called once if the input docId is the same as the one supplied in prior invocation of nextFacetLabel().\nSubsequent invocations fetch the ordinals from FacetLabelReader.decodedOrds and use the ordinal to lookup FacetLabels using taxoReader.getPath(ord).\nYes, after LUCENE-9450, we can bulk resolve all the ordinals using a different API, something like -> List<FacetLabels> taxoReader.getPaths(IntRef decodedOrds) and add a new API - FacetLabelReader.allFacetLabels(int docId)", "author": "goankur", "createdAt": "2020-09-25T00:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0MDEyNw==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r495240127", "bodyText": "Yeah, or we could bulk map all ord -> FacetLabel as soon as caller goes to the next docId, and then iterate them one by one with this API.\nAnyway, we don't need to solve that here.", "author": "mikemccand", "createdAt": "2020-09-25T21:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "chunk": "diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\nindex 3f4be448c3e..5f031e32ac5 100644\n--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java\n\n@@ -107,13 +107,19 @@ public class TaxonomyFacetLabels {\n      * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n      * new {@code docId} must be in strictly monotonic (increasing) order.\n      *\n+     * <p><b>NOTE</b>: The returned FacetLabels may not be in the same order in which they were indexed</p>\n+     *\n      * @param docId input docId provided in monotonic (non-decreasing) order\n      * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n      * @throws IOException when a low-level IO issue occurs\n+     * @throws IllegalArgumentException if docId provided is less than docId supplied in an earlier invocation\n      */\n     public FacetLabel nextFacetLabel(int docId) throws IOException {\n       if (currentDocId != docId) {\n-        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        if (docId < currentDocId) {\n+          throw new IllegalArgumentException(\"docs out of order: previous docId=\" + currentDocId\n+              + \" current docId=\" + docId);\n+        }\n         ordinalsSegmentReader.get(docId, decodedOrds);\n         currentDocId = docId;\n         currentPos = decodedOrds.offset;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzQ4MA==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493047480", "bodyText": "Could we make a small change to an existing randomized test, maybe TestTaxonomyFacetCounts.testRandom, to use this API to randomly retrieve N facet labels?  (So we exercise the class beyond the simplish testBasic ... maybe we uncover a rare bug, somewhere).", "author": "mikemccand", "createdAt": "2020-09-22T21:35:34Z", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.facet.FacetField;\n+import org.apache.lucene.facet.FacetTestCase;\n+import org.apache.lucene.facet.FacetsCollector;\n+import org.apache.lucene.facet.FacetsCollector.MatchingDocs;\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.IOUtils;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class TestTaxonomyLabels extends FacetTestCase {\n+\n+  private List<Document> prepareDocuments() {\n+    List<Document> docs = new ArrayList<>();\n+\n+    Document doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Bob\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"15\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Lisa\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"20\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Tom\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"1\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Susan\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"7\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Frank\"));\n+    doc.add(new FacetField(\"Publish Date\", \"1999\", \"5\", \"5\"));\n+    docs.add(doc);\n+\n+    return docs;\n+  }\n+\n+  private List<Integer> allDocIds(MatchingDocs m, boolean decreasingDocIds) throws IOException {\n+    DocIdSetIterator disi = m.bits.iterator();\n+    List<Integer> docIds = new ArrayList<>();\n+    while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n+      docIds.add(disi.docID());\n+    }\n+\n+    if (decreasingDocIds == true) {\n+      Collections.reverse(docIds);\n+    }\n+    return docIds;\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, null, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs,\n+                                             String dimension) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, dimension, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels, List<MatchingDocs> matchingDocs, String dimension,\n+                                             boolean decreasingDocIds) throws IOException {\n+    List<FacetLabel> facetLabels = new ArrayList<>();\n+\n+    for (MatchingDocs m : matchingDocs) {\n+      TaxonomyFacetLabels.FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n+      List<Integer> docIds = allDocIds(m, decreasingDocIds);\n+      FacetLabel facetLabel;\n+      for (Integer docId : docIds) {\n+        while (true) {\n+          if (dimension != null) {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId, dimension);\n+          } else {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId);\n+          }\n+\n+          if (facetLabel == null) {\n+            break;\n+          }\n+          facetLabels.add(facetLabel);\n+        }\n+      }\n+    }\n+\n+    return facetLabels;\n+  }\n+\n+\n+  public void testBasic() throws Exception {", "originalCommit": "bf8eaf98901cbe83f23067bea90dfb2f3102603a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxOTMyOQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493919329", "bodyText": "Done in this revision", "author": "goankur", "createdAt": "2020-09-23T21:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzQ4MA=="}], "type": "inlineReview", "revised_code": {"commit": "75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "chunk": "diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java\nindex e5759c88005..3cae7a218e9 100644\n--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java\n+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java\n\n@@ -151,7 +151,9 @@ public class TestTaxonomyLabels extends FacetTestCase {\n \n     // Check labels for all dimensions\n     List<FacetLabel> facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs());\n-    assertTrue(facetLabels.size() == 10);\n+    assertEquals(\"Incorrect number of facet labels received\", 10, facetLabels.size());\n+\n+    // Check labels for all dimensions\n     assertTrue(facetLabels.stream()\n         .filter(l -> \"Author\".equals(l.components[0]))\n         .map(l -> l.components[1]).collect(Collectors.toSet())\n"}}, {"oid": "75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "url": "https://github.com/apache/lucene-solr/commit/75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "message": "LUCENE-9444 Utility class to get facet labels from taxonomy for a facet field. This is useful if a facet field is requested in the list of return fields for each hit.", "committedDate": "2020-09-23T04:23:23Z", "type": "commit"}, {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d", "url": "https://github.com/apache/lucene-solr/commit/71222c288a83e4a05d0be6020f6903ad340d959d", "message": "LUCENE-9444 Utility class to get facet labels from taxonomy for a facet field. This is useful if a facet field is requested in the list of return fields for each hit.", "committedDate": "2020-09-23T17:19:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5ODU2MA==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494398560", "bodyText": "Thank you for adding this utility method so tests can easily use the new utility class!\nCan we rename this to getAllTaxonomyFacetLabels, and add javadoc explaining that the outer list is one entry per matched hit, and the inner list is one entry per FacetLabel belonging to that hit?", "author": "mikemccand", "createdAt": "2020-09-24T15:11:04Z", "path": "lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java", "diffHunk": "@@ -56,6 +60,28 @@ public Facets getTaxonomyFacetCounts(TaxonomyReader taxoReader, FacetsConfig con\n     return facets;\n   }\n \n+  public List<List<FacetLabel>> getTaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, FacetsCollector fc) throws IOException {", "originalCommit": "71222c288a83e4a05d0be6020f6903ad340d959d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY1NDU1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494654559", "bodyText": "done in the next revision.", "author": "goankur", "createdAt": "2020-09-24T22:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5ODU2MA=="}], "type": "inlineReview", "revised_code": {"commit": "2600be2694de92f7eb881a7f4e65de77f2175e8d", "chunk": "diff --git a/lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java b/lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java\nindex 1b9239dde7d..bcc3b1c407a 100644\n--- a/lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java\n+++ b/lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java\n\n@@ -60,12 +61,27 @@ public abstract class FacetTestCase extends LuceneTestCase {\n     return facets;\n   }\n \n-  public List<List<FacetLabel>> getTaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, FacetsCollector fc) throws IOException {\n+  /**\n+   * Utility method that uses {@link FacetLabelReader} to get facet labels\n+   * for each hit in {@link MatchingDocs}. The method returns {@code List<List<FacetLabel>>}\n+   * where outer list has at most one entry per document and inner list has all {@link FacetLabel}\n+   * entries that belong to a document.\n+   *\n+   * <p><b>NOTE</b>: A hit that has no facet labels will not have an entry in the outer list.\n+   * The outer list, however is always non-null</p>\n+   *\n+   * @param taxoReader {@link TaxonomyReader} used to read taxonomy during search. This instance is expected to be open for reading.\n+   * @param fc         {@link FacetsCollector} A collector with matching hits.\n+   * @return {@code List<List<FacetLabel>} where outer list has at most one entry per document\n+   * and inner list contain all {@link FacetLabel} entries that belong to a document.\n+   * @throws IOException when a low-level IO issue occurs.\n+   */\n+  public List<List<FacetLabel>> getAllTaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsCollector fc) throws IOException {\n     List<List<FacetLabel>> actualLabels = new ArrayList<>();\n-    TaxonomyFacetLabels taxoLabels = new TaxonomyFacetLabels(taxoReader, config, FacetsConfig.DEFAULT_INDEX_FIELD_NAME);\n+    TaxonomyFacetLabels taxoLabels = new TaxonomyFacetLabels(taxoReader, FacetsConfig.DEFAULT_INDEX_FIELD_NAME);\n \n     for (MatchingDocs m : fc.getMatchingDocs()) {\n-      TaxonomyFacetLabels.FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n+      FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n \n       DocIdSetIterator disi = m.bits.iterator();\n       while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMDUxNQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494400515", "bodyText": "Hmm why are these null checks necessary?  Are we really seeing null in the argument?  Oh, I guess this legitimately happens when the hit had no facets?  Maybe add a comment?  Hmm, actually, looking at how actual and expected are populated, neither of them seems to add null?  One of them filters out empty list but the other does not?", "author": "mikemccand", "createdAt": "2020-09-24T15:13:48Z", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -726,6 +743,39 @@ public void testRandom() throws Exception {\n     IOUtils.close(tw, searcher.getIndexReader(), tr, indexDir, taxoDir);\n   }\n \n+  private static List<List<FacetLabel>> sortedFacetLabels(List<List<FacetLabel>> allfacetLabels) {\n+    for (List<FacetLabel> facetLabels : allfacetLabels) {\n+      Collections.sort(facetLabels);\n+    }\n+\n+    Collections.sort(allfacetLabels, (o1, o2) -> {\n+      if (o1 == null) {", "originalCommit": "71222c288a83e4a05d0be6020f6903ad340d959d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY1NTU0OQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494655549", "bodyText": "Thanks for catching this @mikemccand. I fixed the actualLabels to exclude empty lists. The null checks were just me being extra cautious. I realized they were unnecessary and removed them :-)", "author": "goankur", "createdAt": "2020-09-24T22:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMDUxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "2600be2694de92f7eb881a7f4e65de77f2175e8d", "chunk": "diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java\nindex 0f77f36cb84..70c0bf4ff5f 100644\n--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java\n+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java\n\n@@ -744,19 +744,13 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {\n   }\n \n   private static List<List<FacetLabel>> sortedFacetLabels(List<List<FacetLabel>> allfacetLabels) {\n+    // sort each inner list since there is no guaranteed order in which FacetLabels\n+    // are expected to be retrieved for each document\n     for (List<FacetLabel> facetLabels : allfacetLabels) {\n       Collections.sort(facetLabels);\n     }\n \n     Collections.sort(allfacetLabels, (o1, o2) -> {\n-      if (o1 == null) {\n-        return -1;\n-      }\n-\n-      if (o2 == null) {\n-        return 1;\n-      }\n-\n       int diff = o1.size() - o2.size();\n       if (diff != 0) {\n         return diff;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMjUwMQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494402501", "bodyText": "I'm confused why we are sorting the top list?  Isn't the top list in order of the hits?  And we want to confirm, for a given docId hit, that expected and actual labels match?\nOK, I think I understand: this test does not index anything allowing you to track which original doc mapped to which FacetLabel, so then you cannot know, per segment, which docs ended up where :)\nGiven that, I think it's OK to do the top-level sort of all List<FacetLabel> across all hits.", "author": "mikemccand", "createdAt": "2020-09-24T15:16:24Z", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -726,6 +743,39 @@ public void testRandom() throws Exception {\n     IOUtils.close(tw, searcher.getIndexReader(), tr, indexDir, taxoDir);\n   }\n \n+  private static List<List<FacetLabel>> sortedFacetLabels(List<List<FacetLabel>> allfacetLabels) {\n+    for (List<FacetLabel> facetLabels : allfacetLabels) {\n+      Collections.sort(facetLabels);\n+    }\n+\n+    Collections.sort(allfacetLabels, (o1, o2) -> {", "originalCommit": "71222c288a83e4a05d0be6020f6903ad340d959d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2NTE4OA==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494665188", "bodyText": "Yes, a document with Nth position in the input sequence might end up with Kth docId in a random segment making it harder to compare actual and expected labels.\nThanks for confirming that the approach is acceptable.", "author": "goankur", "createdAt": "2020-09-24T23:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMjUwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "2600be2694de92f7eb881a7f4e65de77f2175e8d", "chunk": "diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java\nindex 0f77f36cb84..70c0bf4ff5f 100644\n--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java\n+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java\n\n@@ -744,19 +744,13 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {\n   }\n \n   private static List<List<FacetLabel>> sortedFacetLabels(List<List<FacetLabel>> allfacetLabels) {\n+    // sort each inner list since there is no guaranteed order in which FacetLabels\n+    // are expected to be retrieved for each document\n     for (List<FacetLabel> facetLabels : allfacetLabels) {\n       Collections.sort(facetLabels);\n     }\n \n     Collections.sort(allfacetLabels, (o1, o2) -> {\n-      if (o1 == null) {\n-        return -1;\n-      }\n-\n-      if (o2 == null) {\n-        return 1;\n-      }\n-\n       int diff = o1.size() - o2.size();\n       if (diff != 0) {\n         return diff;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODIzOA==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494408238", "bodyText": "Hmm I think expectedLabels filters out empty List<FacetLabel> but actualLabels does not, so this might false trip?", "author": "mikemccand", "createdAt": "2020-09-24T15:24:12Z", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -711,6 +723,11 @@ public void testRandom() throws Exception {\n         }\n       }\n \n+      // Test facet labels for each matching test doc\n+      List<List<FacetLabel>> actualLabels = getTaxonomyFacetLabels(tr, config, fc);\n+      assertEquals(expectedLabels.size(), actualLabels.size());", "originalCommit": "71222c288a83e4a05d0be6020f6903ad340d959d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzNzI2OQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494637269", "bodyText": "Nice catch, thanks.  I fixed actualLabels generation in FacetTestCase.getAllTaxonomyFacetLabels() method to filter out empty List<facetLabels>.", "author": "goankur", "createdAt": "2020-09-24T22:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0MDY2MQ==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r495240661", "bodyText": "Hmm I don't like filtering out \"no facet fields\" case from FacetTestCase.getAllTaxonomyFacetLabels() -- that means callers cannot safely map hits to the List<FacetLabel>?\nCould we instead keep the empty lists in both expected and actual?", "author": "mikemccand", "createdAt": "2020-09-25T21:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM0MjIyOA==", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r495342228", "bodyText": "Done. I made changes to keep empty lists in both expectedLabels and actualLabels and also updated javadoc for FacetTestCase.getAllTaxonomyFacetLabels() to reflect this for actualLabels", "author": "goankur", "createdAt": "2020-09-26T00:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODIzOA=="}], "type": "inlineReview", "revised_code": {"commit": "2600be2694de92f7eb881a7f4e65de77f2175e8d", "chunk": "diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java\nindex 0f77f36cb84..70c0bf4ff5f 100644\n--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java\n+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java\n\n@@ -724,7 +724,7 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {\n       }\n \n       // Test facet labels for each matching test doc\n-      List<List<FacetLabel>> actualLabels = getTaxonomyFacetLabels(tr, config, fc);\n+      List<List<FacetLabel>> actualLabels = getAllTaxonomyFacetLabels(tr, fc);\n       assertEquals(expectedLabels.size(), actualLabels.size());\n       assertTrue(sortedFacetLabels(expectedLabels).equals(sortedFacetLabels(actualLabels)));\n \n"}}, {"oid": "2600be2694de92f7eb881a7f4e65de77f2175e8d", "url": "https://github.com/apache/lucene-solr/commit/2600be2694de92f7eb881a7f4e65de77f2175e8d", "message": "LUCENE-9444 Utility class to get facet labels from taxonomy for a facet field. This is useful if a facet field is requested in the list of return fields for each hit.", "committedDate": "2020-09-25T00:21:04Z", "type": "commit"}, {"oid": "e3c992c4bae6f98d65d8f42ef752a583bd1e8f4d", "url": "https://github.com/apache/lucene-solr/commit/e3c992c4bae6f98d65d8f42ef752a583bd1e8f4d", "message": "LUCENE-9444 Utility class to get facet labels from taxonomy for a facet field. This is useful if a facet field is requested in the list of return fields for each hit.", "committedDate": "2020-09-26T00:22:33Z", "type": "commit"}]}