{"pr_number": 1626, "pr_title": "SOLR-14588: Implement Circuit Breakers", "pr_createdAt": "2020-06-28T18:02:48Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1626", "timeline": [{"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "url": "https://github.com/apache/lucene-solr/commit/b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-06-28T18:08:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTExNg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446685116", "bodyText": "I always like to put in default values where the Java defaults wouldn't work, just in case \"somehow\" this isn't set in future. memoryCircuitBreakerThreshold defaults to 0 in this case, is that OK?\nAnd maybe name this memoryCircuitBreakerThresholdPct?", "author": "ErickErickson", "createdAt": "2020-06-28T18:54:50Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -522,6 +527,10 @@ public SolrRequestParsers getRequestParsers() {\n   public final int queryResultWindowSize;\n   public final int queryResultMaxDocsCached;\n   public final boolean enableLazyFieldLoading;\n+\n+  // Circuit Breaker Configuration\n+  public final boolean useCircuitBreakers;\n+  public final int memoryCircuitBreakerThreshold;", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/core/SolrConfig.java b/solr/core/src/java/org/apache/solr/core/SolrConfig.java\nindex e3158633ae3..eea234b4546 100644\n--- a/solr/core/src/java/org/apache/solr/core/SolrConfig.java\n+++ b/solr/core/src/java/org/apache/solr/core/SolrConfig.java\n\n@@ -530,7 +530,7 @@ public class SolrConfig extends XmlConfigFile implements MapSerializable {\n \n   // Circuit Breaker Configuration\n   public final boolean useCircuitBreakers;\n-  public final int memoryCircuitBreakerThreshold;\n+  public final int memoryCircuitBreakerThresholdPct;\n   \n   public final boolean useRangeVersionsForPeerSync;\n   \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTU4OA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446685588", "bodyText": "Does it really make sense to allow either of these values? 0 seems like it'd cause everything to break (haven't seen the rest of the code yet, maybe 0 is a special case). 100% seems too late. Do we have any good information about what reasonable upper and lower bounds are? And should we enforce them? Say 50%/90% as a straw-man proposal for discussion...", "author": "ErickErickson", "createdAt": "2020-06-28T18:59:11Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -804,6 +813,14 @@ private void initLibs(SolrResourceLoader loader, boolean isConfigsetTrusted) {\n     loader.reloadLuceneSPI();\n   }\n \n+  private void validateMemoryBreakerThreshold() {\n+    if (useCircuitBreakers) {\n+      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0ODQ1Ng==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447048456", "bodyText": "This is more of a sanity test to ensure that the incoming values lie in the range of percentage. If we wish to restrain the actual domain of values that memoryCircuitBreakerThreshold can take, I can add another check and add the same in the documentation.", "author": "atris", "createdAt": "2020-06-29T15:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTU4OA=="}], "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/core/SolrConfig.java b/solr/core/src/java/org/apache/solr/core/SolrConfig.java\nindex e3158633ae3..eea234b4546 100644\n--- a/solr/core/src/java/org/apache/solr/core/SolrConfig.java\n+++ b/solr/core/src/java/org/apache/solr/core/SolrConfig.java\n\n@@ -815,7 +815,7 @@ public class SolrConfig extends XmlConfigFile implements MapSerializable {\n \n   private void validateMemoryBreakerThreshold() {\n     if (useCircuitBreakers) {\n-      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {\n+      if (memoryCircuitBreakerThresholdPct > 100 || memoryCircuitBreakerThresholdPct <= 0) {\n         throw new IllegalArgumentException(\"memoryCircuitBreakerThreshold is not a valid percentage\");\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTg4Ng==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446685886", "bodyText": "Add what valid percentages are here, especially if we decide to enforce as above..\nThis should also echo the number entered and what the valid limits are, something like:\nmemoryCircuitBreakerThreshold was set to\" + memoryCircuitBreakerThreshold + \". Valid percentages must be between X% and Y%\"", "author": "ErickErickson", "createdAt": "2020-06-28T19:02:03Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -804,6 +813,14 @@ private void initLibs(SolrResourceLoader loader, boolean isConfigsetTrusted) {\n     loader.reloadLuceneSPI();\n   }\n \n+  private void validateMemoryBreakerThreshold() {\n+    if (useCircuitBreakers) {\n+      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {\n+        throw new IllegalArgumentException(\"memoryCircuitBreakerThreshold is not a valid percentage\");\n+      }", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5MzQ0Mg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447093442", "bodyText": "Same as above. If we wish to enforce a smaller domain of values, we should discuss the range and I will add extra checks.", "author": "atris", "createdAt": "2020-06-29T16:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NzU4Mw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447597583", "bodyText": "Added the same, thanks", "author": "atris", "createdAt": "2020-06-30T11:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTg4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/core/SolrConfig.java b/solr/core/src/java/org/apache/solr/core/SolrConfig.java\nindex e3158633ae3..eea234b4546 100644\n--- a/solr/core/src/java/org/apache/solr/core/SolrConfig.java\n+++ b/solr/core/src/java/org/apache/solr/core/SolrConfig.java\n\n@@ -815,7 +815,7 @@ public class SolrConfig extends XmlConfigFile implements MapSerializable {\n \n   private void validateMemoryBreakerThreshold() {\n     if (useCircuitBreakers) {\n-      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {\n+      if (memoryCircuitBreakerThresholdPct > 100 || memoryCircuitBreakerThresholdPct <= 0) {\n         throw new IllegalArgumentException(\"memoryCircuitBreakerThreshold is not a valid percentage\");\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4Nzg0OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446687849", "bodyText": "Why not just allocate a new HashMap here and avoid the null check below?\nHmmm, I suppose if there aren't any circuit breakers one could return null, NM.", "author": "ErickErickson", "createdAt": "2020-06-28T19:20:39Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNTgyOA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446935828", "bodyText": "If this is called on every query request then it makes sense to avoid allocations until they are needed.", "author": "sigram", "createdAt": "2020-06-29T12:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4Nzg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NjE0Nw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447586147", "bodyText": "There's a typo in this method name - \"checked\" -> \"check\".\nIn general, could we use shorter method names rather than these very long ones? We already know what the component does, we know that it manages CircuitBreakers - IMHO there's no need whatsoever to remind users in every method name that they deal with CircuitBreakers. :)\nI propose getTripped, checkAnyTripped, toErrorMessage and so on, avoiding repetition where it's obvious what we're dealing with.", "author": "sigram", "createdAt": "2020-06-30T10:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4Nzg0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex 69eaba8d30c..cd84e096638 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -20,7 +20,7 @@ package org.apache.solr.util.circuitbreaker;\n import java.util.HashMap;\n import java.util.Map;\n \n-import org.apache.solr.core.SolrCore;\n+import org.apache.solr.core.SolrConfig;\n \n /**\n  * Manages all registered circuit breaker instances. Responsible for a holistic view\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODg3OA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446688878", "bodyText": "This seems like an awfully small file, perhaps put this in the abstract CircuitBreaker class? No big deal either way.", "author": "ErickErickson", "createdAt": "2020-06-28T19:31:18Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+/**\n+ * Types of circuit breakers\n+ */", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5NDQ3Ng==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447094476", "bodyText": "I prefer cleaner abstractions -- helps avoid compiler errors ;)", "author": "atris", "createdAt": "2020-06-29T16:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MDIxMA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447590210", "bodyText": "I think Erick suggested (and I agree) that this enum should be simply declared in CircuitBreaker class, as CircuitBreaker.CircuitBreakerType or just CircuitBreaker.Type. This doesn't affect compilation but helps to reduce the number of trivial class files. This is also a pattern that is used frequently in Solr in other places.", "author": "sigram", "createdAt": "2020-06-30T10:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODg3OA=="}], "type": "inlineReview", "revised_code": {"commit": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerType.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerType.java\ndeleted file mode 100644\nindex 63db048a3f5..00000000000\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerType.java\n+++ /dev/null\n\n@@ -1,26 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.util.circuitbreaker;\n-\n-/**\n- * Types of circuit breakers\n- */\n-public enum CircuitBreakerType {\n-  MEMORY,\n-  CPU\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMDk1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446910959", "bodyText": "I think 0 also doesn't make much sense.", "author": "sigram", "createdAt": "2020-06-29T11:52:12Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -804,6 +813,14 @@ private void initLibs(SolrResourceLoader loader, boolean isConfigsetTrusted) {\n     loader.reloadLuceneSPI();\n   }\n \n+  private void validateMemoryBreakerThreshold() {\n+    if (useCircuitBreakers) {\n+      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {\n+        throw new IllegalArgumentException(\"memoryCircuitBreakerThreshold is not a valid percentage\");", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/core/SolrConfig.java b/solr/core/src/java/org/apache/solr/core/SolrConfig.java\nindex e3158633ae3..eea234b4546 100644\n--- a/solr/core/src/java/org/apache/solr/core/SolrConfig.java\n+++ b/solr/core/src/java/org/apache/solr/core/SolrConfig.java\n\n@@ -815,7 +815,7 @@ public class SolrConfig extends XmlConfigFile implements MapSerializable {\n \n   private void validateMemoryBreakerThreshold() {\n     if (useCircuitBreakers) {\n-      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {\n+      if (memoryCircuitBreakerThresholdPct > 100 || memoryCircuitBreakerThresholdPct <= 0) {\n         throw new IllegalArgumentException(\"memoryCircuitBreakerThreshold is not a valid percentage\");\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNDcxNA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446914714", "bodyText": "The following probably belongs to the SIP ... but the way I think about the common usage of this class for different code-paths is if breaker configs are labeled and correspond to different code-paths, eg.:\n\n\"query\" -> one config\n\"index\" -> another config\n\"foobar\" -> yet another config, used perhaps in my custom component\n\nCurrent implementation limits us to use the same config for potentially very different code paths.", "author": "sigram", "createdAt": "2020-06-29T11:59:07Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyMzY4MA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447123680", "bodyText": "Agreed. I added the single configuration since there is only one code path. I have a SIP upcoming to add an API for controlling these configs, will add this to the same. Thanks for bringing the same up.", "author": "atris", "createdAt": "2020-06-29T17:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNDcxNA=="}], "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex 69eaba8d30c..cd84e096638 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -20,7 +20,7 @@ package org.apache.solr.util.circuitbreaker;\n import java.util.HashMap;\n import java.util.Map;\n \n-import org.apache.solr.core.SolrCore;\n+import org.apache.solr.core.SolrConfig;\n \n /**\n  * Manages all registered circuit breaker instances. Responsible for a holistic view\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNTYzNw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446915637", "bodyText": "OMG, what a name :) Maybe just checkTrippedBreakers ?", "author": "sigram", "createdAt": "2020-06-29T12:00:43Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex 69eaba8d30c..cd84e096638 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -20,7 +20,7 @@ package org.apache.solr.util.circuitbreaker;\n import java.util.HashMap;\n import java.util.Map;\n \n-import org.apache.solr.core.SolrCore;\n+import org.apache.solr.core.SolrConfig;\n \n /**\n  * Manages all registered circuit breaker instances. Responsible for a holistic view\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNjQ3MA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446916470", "bodyText": "Maybe checkAnyBreakerTripped ? Because we don't actually check all breakers here.", "author": "sigram", "createdAt": "2020-06-29T12:02:11Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isCircuitBreakerEnabled() &&\n+          circuitBreaker.isCircuitBreakerGauntletTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAllCircuitBreakers() {", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex 69eaba8d30c..cd84e096638 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -20,7 +20,7 @@ package org.apache.solr.util.circuitbreaker;\n import java.util.HashMap;\n import java.util.Map;\n \n-import org.apache.solr.core.SolrCore;\n+import org.apache.solr.core.SolrConfig;\n \n /**\n  * Manages all registered circuit breaker instances. Responsible for a holistic view\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNzcwOA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446917708", "bodyText": "Do we actually need SolrCore here, or just the breakers' config (currently in SolrConfig)?", "author": "sigram", "createdAt": "2020-06-29T12:04:17Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isCircuitBreakerEnabled() &&\n+          circuitBreaker.isCircuitBreakerGauntletTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAllCircuitBreakers() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isCircuitBreakerEnabled() &&\n+          circuitBreaker.isCircuitBreakerGauntletTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).printDebugInfo());\n+    }\n+\n+    return sb.toString();\n+  }\n+\n+  /**\n+   * Register default circuit breakers and return a constructed CircuitBreakerManager\n+   * instance which serves the given circuit breakers.\n+   *\n+   * Any default circuit breakers should be registered here\n+   */\n+  public static CircuitBreakerManager buildDefaultCircuitBreakerManager(SolrCore solrCore) {", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex 69eaba8d30c..cd84e096638 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -20,7 +20,7 @@ package org.apache.solr.util.circuitbreaker;\n import java.util.HashMap;\n import java.util.Map;\n \n-import org.apache.solr.core.SolrCore;\n+import org.apache.solr.core.SolrConfig;\n \n /**\n  * Manages all registered circuit breaker instances. Responsible for a holistic view\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxODc5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446918796", "bodyText": "It needs  tags to actually make a new paragraph.", "author": "sigram", "createdAt": "2020-06-29T12:06:18Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ *\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\nindex bfc294c75e6..2a6c50f1db3 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n\n@@ -20,41 +20,55 @@ package org.apache.solr.util.circuitbreaker;\n import java.lang.management.ManagementFactory;\n import java.lang.management.MemoryMXBean;\n \n-import org.apache.solr.core.SolrCore;\n+import org.apache.solr.core.SolrConfig;\n \n /**\n+ * <p>\n  * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n  * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n  * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n  * it will start allowing queries again.\n+ * </p>\n  *\n+ * <p>\n  * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n  * in solrconfig.xml\n+ * </p>\n  */\n \n public class MemoryCircuitBreaker extends CircuitBreaker {\n   private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n \n-  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+  private final long heapMemoryThreshold;\n \n   // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n   private ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n   private ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n \n-  public MemoryCircuitBreaker(SolrCore solrCore) {\n-    super(solrCore);\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n \n     if (currentMaxHeap <= 0) {\n       throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n     }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n   }\n \n   // TODO: An optimization can be to trip the circuit breaker for a duration of time\n   // after the circuit breaker condition is matched. This will optimize for per call\n   // overhead of calculating the condition parameters but can result in false positives.\n   @Override\n-  public boolean isCircuitBreakerGauntletTripped() {\n-    if (!isCircuitBreakerEnabled()) {\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n       return false;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxOTgxOQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446919819", "bodyText": "This can be calculated once in the constructor - IIRC if SolrConfig is updated the core is reloaded anyway, which will construct the breaker once again.", "author": "sigram", "createdAt": "2020-06-29T12:08:00Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ *\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n+ * in solrconfig.xml\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seenMemory=\" + seenMemory.get() + \" allowedMemory=\" + allowedMemory.get();\n+  }\n+\n+  private long getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\nindex bfc294c75e6..2a6c50f1db3 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n\n@@ -20,41 +20,55 @@ package org.apache.solr.util.circuitbreaker;\n import java.lang.management.ManagementFactory;\n import java.lang.management.MemoryMXBean;\n \n-import org.apache.solr.core.SolrCore;\n+import org.apache.solr.core.SolrConfig;\n \n /**\n+ * <p>\n  * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n  * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n  * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n  * it will start allowing queries again.\n+ * </p>\n  *\n+ * <p>\n  * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n  * in solrconfig.xml\n+ * </p>\n  */\n \n public class MemoryCircuitBreaker extends CircuitBreaker {\n   private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n \n-  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+  private final long heapMemoryThreshold;\n \n   // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n   private ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n   private ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n \n-  public MemoryCircuitBreaker(SolrCore solrCore) {\n-    super(solrCore);\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n \n     if (currentMaxHeap <= 0) {\n       throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n     }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n   }\n \n   // TODO: An optimization can be to trip the circuit breaker for a duration of time\n   // after the circuit breaker condition is matched. This will optimize for per call\n   // overhead of calculating the condition parameters but can result in false positives.\n   @Override\n-  public boolean isCircuitBreakerGauntletTripped() {\n-    if (!isCircuitBreakerEnabled()) {\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n       return false;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyMjEzOA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446922138", "bodyText": "This comment is somewhat misleading ... if I correctly understand the intent :) MemoryUsageGaugeSet does provide the heap and the non-heap usages separately, so it's possible to get the value we want from it - but it incurs unnecessary cost and additional allocations, so we can do it cheaper by using MemoryMXBean directly.", "author": "sigram", "createdAt": "2020-06-29T12:12:08Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ *\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n+ * in solrconfig.xml\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seenMemory=\" + seenMemory.get() + \" allowedMemory=\" + allowedMemory.get();\n+  }\n+\n+  private long getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    long actualLimit = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (actualLimit <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+\n+    return actualLimit;\n+  }\n+\n+  /**\n+   * Calculate the live memory usage for the system. This method has package visibility\n+   * to allow using for testing\n+   * @return Memory usage in bytes\n+   */\n+  protected long calculateLiveMemoryUsage() {\n+    // NOTE: MemoryUsageGaugeSet provides memory usage statistics but we do not use them\n+    // here since MemoryUsageGaugeSet provides combination of heap and non heap usage and", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4NTM4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447185389", "bodyText": "Better wording, thanks!", "author": "atris", "createdAt": "2020-06-29T18:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyMjEzOA=="}], "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\nindex bfc294c75e6..2a6c50f1db3 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n\n@@ -20,41 +20,55 @@ package org.apache.solr.util.circuitbreaker;\n import java.lang.management.ManagementFactory;\n import java.lang.management.MemoryMXBean;\n \n-import org.apache.solr.core.SolrCore;\n+import org.apache.solr.core.SolrConfig;\n \n /**\n+ * <p>\n  * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n  * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n  * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n  * it will start allowing queries again.\n+ * </p>\n  *\n+ * <p>\n  * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n  * in solrconfig.xml\n+ * </p>\n  */\n \n public class MemoryCircuitBreaker extends CircuitBreaker {\n   private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n \n-  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+  private final long heapMemoryThreshold;\n \n   // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n   private ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n   private ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n \n-  public MemoryCircuitBreaker(SolrCore solrCore) {\n-    super(solrCore);\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n \n     if (currentMaxHeap <= 0) {\n       throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n     }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n   }\n \n   // TODO: An optimization can be to trip the circuit breaker for a duration of time\n   // after the circuit breaker condition is matched. This will optimize for per call\n   // overhead of calculating the condition parameters but can result in false positives.\n   @Override\n-  public boolean isCircuitBreakerGauntletTripped() {\n-    if (!isCircuitBreakerEnabled()) {\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n       return false;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNTg2OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446925869", "bodyText": "Maybe isEnabled ?", "author": "sigram", "createdAt": "2020-06-29T12:18:39Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrCore solrCore;\n+\n+  public CircuitBreaker(SolrCore solrCore) {\n+    this.solrCore = solrCore;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isCircuitBreakerEnabled() {", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\nindex 55cfb5d2279..42bc36129bf 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n\n@@ -17,7 +17,7 @@\n \n package org.apache.solr.util.circuitbreaker;\n \n-import org.apache.solr.core.SolrCore;\n+import org.apache.solr.core.SolrConfig;\n \n /**\n  * Default class to define circuit breakers for Solr.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNjA0Nw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446926047", "bodyText": "Maybe isTripped ?", "author": "sigram", "createdAt": "2020-06-29T12:18:57Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrCore solrCore;\n+\n+  public CircuitBreaker(SolrCore solrCore) {\n+    this.solrCore = solrCore;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isCircuitBreakerEnabled() {\n+    return solrCore.getSolrConfig().useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this allocation will trigger circuit breaker.\n+   */\n+  public abstract boolean isCircuitBreakerGauntletTripped();", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\nindex 55cfb5d2279..42bc36129bf 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n\n@@ -17,7 +17,7 @@\n \n package org.apache.solr.util.circuitbreaker;\n \n-import org.apache.solr.core.SolrCore;\n+import org.apache.solr.core.SolrConfig;\n \n /**\n  * Default class to define circuit breakers for Solr.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNjcxNw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446926717", "bodyText": "This doesn't actually print anything, maybe name it getDebugInfo ?", "author": "sigram", "createdAt": "2020-06-29T12:20:08Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrCore solrCore;\n+\n+  public CircuitBreaker(SolrCore solrCore) {\n+    this.solrCore = solrCore;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isCircuitBreakerEnabled() {\n+    return solrCore.getSolrConfig().useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this allocation will trigger circuit breaker.\n+   */\n+  public abstract boolean isCircuitBreakerGauntletTripped();\n+\n+  /**\n+   * Print debug useful info\n+   */\n+  public abstract String printDebugInfo();", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\nindex 55cfb5d2279..42bc36129bf 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n\n@@ -17,7 +17,7 @@\n \n package org.apache.solr.util.circuitbreaker;\n \n-import org.apache.solr.core.SolrCore;\n+import org.apache.solr.core.SolrConfig;\n \n /**\n  * Default class to define circuit breakers for Solr.\n"}}, {"oid": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "url": "https://github.com/apache/lucene-solr/commit/f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-06-29T19:06:28Z", "type": "forcePushed"}, {"oid": "d9f7624131475761b466c92603abcd9846e62bad", "url": "https://github.com/apache/lucene-solr/commit/d9f7624131475761b466c92603abcd9846e62bad", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-06-29T19:11:17Z", "type": "forcePushed"}, {"oid": "61ca4c0bd71f5cc35b515308e1757292965f90ff", "url": "https://github.com/apache/lucene-solr/commit/61ca4c0bd71f5cc35b515308e1757292965f90ff", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-06-29T19:19:03Z", "type": "forcePushed"}, {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940", "url": "https://github.com/apache/lucene-solr/commit/b5582fa759c575623b37c911d7f4485bef7ac940", "message": "Update test parameter", "committedDate": "2020-06-30T07:57:03Z", "type": "forcePushed"}, {"oid": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "url": "https://github.com/apache/lucene-solr/commit/e8c53bd42247904060bb5ee4903ccf46c4057c49", "message": "More Updates", "committedDate": "2020-06-30T11:11:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NjM1NA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447586354", "bodyText": "checkAnyTripped ?", "author": "sigram", "createdAt": "2020-06-30T10:39:39Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex cd84e096638..2db52921891 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,15 +37,14 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-\n-  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NzMyMw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447587323", "bodyText": "This is an awkward name - maybe toErrorString or toErrorMessage ?", "author": "sigram", "createdAt": "2020-06-30T10:41:26Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex cd84e096638..2db52921891 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,15 +37,14 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-\n-  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4ODAwNg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447588006", "bodyText": "New-lines or other separator characters would make this message more readable, now we're getting a single very long line.", "author": "sigram", "createdAt": "2020-06-30T10:42:48Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).getDebugInfo());", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex cd84e096638..2db52921891 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,15 +37,14 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-\n-  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4ODUzNg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447588536", "bodyText": "If circuit breakers are not enabled in SolrConfig is there still any point to register any of them?\nAlso, I propose to rename this method to just build - we don't have any way yet to build a non-default manager anyway. The javadoc already says it builds a default configuration.", "author": "sigram", "createdAt": "2020-06-30T10:43:45Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).getDebugInfo());\n+    }\n+\n+    return sb.toString();\n+  }\n+\n+  /**\n+   * Register default circuit breakers and return a constructed CircuitBreakerManager\n+   * instance which serves the given circuit breakers.\n+   *\n+   * Any default circuit breakers should be registered here\n+   */\n+  public static CircuitBreakerManager buildDefaultCircuitBreakerManager(SolrConfig solrConfig) {", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczODY3MQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447738671", "bodyText": "Fixed, thanks.", "author": "atris", "createdAt": "2020-06-30T14:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4ODUzNg=="}], "type": "inlineReview", "revised_code": {"commit": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex cd84e096638..2db52921891 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,15 +37,14 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-\n-  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NzY3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447597673", "bodyText": "These can be final too (it doesn't matter at runtime but it makes the intent clear).", "author": "sigram", "createdAt": "2020-06-30T11:01:06Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n+ * in solrconfig.xml\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private ThreadLocal<Long> seenMemory = new ThreadLocal<>();", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\nindex 2a6c50f1db3..2f064538ce2 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n\n@@ -17,10 +17,13 @@\n \n package org.apache.solr.util.circuitbreaker;\n \n+import java.lang.invoke.MethodHandles;\n import java.lang.management.ManagementFactory;\n import java.lang.management.MemoryMXBean;\n \n import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5OTc0MQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447599741", "bodyText": "This javadoc is confusing - why not simply say \"Check if this breaker is tripped\"? It's not the request that trips the breaker, it's the underlying condition that does this.", "author": "sigram", "createdAt": "2020-06-30T11:05:23Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this request will trigger circuit breaker.", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\nindex 42bc36129bf..801bb308da4 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n\n@@ -52,4 +52,12 @@ public abstract class CircuitBreaker {\n    * Print debug useful info\n    */\n   public abstract String getDebugInfo();\n-}\n+\n+  /**\n+   * Types of circuit breakers\n+   */\n+  public enum CircuitBreakerType {\n+    MEMORY,\n+    CPU\n+  }\n+}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5OTkxMA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447599910", "bodyText": "Get useful debug info.", "author": "sigram", "createdAt": "2020-06-30T11:05:46Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this request will trigger circuit breaker.\n+   */\n+  public abstract boolean isTripped();\n+\n+  /**\n+   * Print debug useful info", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\nindex 42bc36129bf..801bb308da4 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n\n@@ -52,4 +52,12 @@ public abstract class CircuitBreaker {\n    * Print debug useful info\n    */\n   public abstract String getDebugInfo();\n-}\n+\n+  /**\n+   * Types of circuit breakers\n+   */\n+  public enum CircuitBreakerType {\n+    MEMORY,\n+    CPU\n+  }\n+}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDQ4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447600489", "bodyText": "We can drop CircuitBreaker from the method name - we already know what we're going to register.", "author": "sigram", "createdAt": "2020-06-30T11:07:01Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex cd84e096638..2db52921891 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,15 +37,14 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-\n-  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDc4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447600789", "bodyText": "Drop CircuitBreakers?", "author": "sigram", "createdAt": "2020-06-30T11:07:41Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex cd84e096638..2db52921891 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,15 +37,14 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-\n-  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n"}}, {"oid": "80b5ce7495c720c927c883411b76326cf009409d", "url": "https://github.com/apache/lucene-solr/commit/80b5ce7495c720c927c883411b76326cf009409d", "message": "Renamings", "committedDate": "2020-06-30T15:27:33Z", "type": "forcePushed"}, {"oid": "4225317e4da65a5f6ae49d5f6ecac47db274444f", "url": "https://github.com/apache/lucene-solr/commit/4225317e4da65a5f6ae49d5f6ecac47db274444f", "message": "Renamings", "committedDate": "2020-06-30T15:35:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MjgyMg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447792822", "bodyText": "Add full-stops at the end of sentences and a <p> between paragraphs, otherwise the lines will run into each other.", "author": "sigram", "createdAt": "2020-06-30T15:53:28Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkedTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.putIfAbsent(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered", "originalCommit": "4225317e4da65a5f6ae49d5f6ecac47db274444f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bc42f0ddbdf25b721fb806b34dc380e52a241f5", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex 49a5ce0976d..eb1e02e325d 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -51,10 +51,10 @@ public class CircuitBreakerManager {\n   }\n \n   /**\n-   * Check if any circuit breaker has triggered.\n-   * @return CircuitBreakers which have triggered, null otherwise\n+   * Check and return circuit breakers that have triggered\n+   * @return CircuitBreakers which have triggered, null otherwise.\n    */\n-  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkedTripped() {\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n     Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n \n     for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MzI0NA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447793244", "bodyText": "Full-stop? ;)", "author": "sigram", "createdAt": "2020-06-30T15:54:04Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkedTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.putIfAbsent(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyTripped() {\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip", "originalCommit": "4225317e4da65a5f6ae49d5f6ecac47db274444f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bc42f0ddbdf25b721fb806b34dc380e52a241f5", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex 49a5ce0976d..eb1e02e325d 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -51,10 +51,10 @@ public class CircuitBreakerManager {\n   }\n \n   /**\n-   * Check if any circuit breaker has triggered.\n-   * @return CircuitBreakers which have triggered, null otherwise\n+   * Check and return circuit breakers that have triggered\n+   * @return CircuitBreakers which have triggered, null otherwise.\n    */\n-  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkedTripped() {\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n     Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n \n     for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NDczMA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447794730", "bodyText": "Hmm, if we're warning about this then maybe we should give some details about what's wrong, i.e. which value was unexpected.", "author": "sigram", "createdAt": "2020-06-30T15:56:04Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThresholdPct\n+ * in solrconfig.xml\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String getDebugInfo() {\n+    if (seenMemory.get() == 0.0 || allowedMemory.get() == 0.0) {\n+      log.warn(\"MemoryCircuitBreaker's monitored values not set correctly\");", "originalCommit": "4225317e4da65a5f6ae49d5f6ecac47db274444f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxMzYwOA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447813608", "bodyText": "Added a message stating the variables not set", "author": "atris", "createdAt": "2020-06-30T16:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NDczMA=="}], "type": "inlineReview", "revised_code": {"commit": "5bc42f0ddbdf25b721fb806b34dc380e52a241f5", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\nindex 9265afc9046..8a1e79e834e 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n\n@@ -35,7 +35,7 @@ import org.slf4j.LoggerFactory;\n  *\n  * <p>\n  * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThresholdPct\n- * in solrconfig.xml\n+ * in solrconfig.xml.\n  * </p>\n  */\n \n"}}, {"oid": "5bc42f0ddbdf25b721fb806b34dc380e52a241f5", "url": "https://github.com/apache/lucene-solr/commit/5bc42f0ddbdf25b721fb806b34dc380e52a241f5", "message": "Moar Stuff", "committedDate": "2020-06-30T17:31:08Z", "type": "forcePushed"}, {"oid": "69594b7c28658a702b5bf2462e568290bec05e61", "url": "https://github.com/apache/lucene-solr/commit/69594b7c28658a702b5bf2462e568290bec05e61", "message": "Moar Stuff", "committedDate": "2020-06-30T17:45:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MzM4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448453381", "bodyText": "I don't think 100 is a safe default here, since later we check that the value is between 50-95.", "author": "madrob", "createdAt": "2020-07-01T15:43:21Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -224,6 +224,11 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n     queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n+\n+    useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n+    memoryCircuitBreakerThresholdPct = getInt(\"circuitBreaker/memoryCircuitBreakerThresholdPct\", 100);", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5Mzk2Mg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448493962", "bodyText": "Changed to 95.", "author": "atris", "createdAt": "2020-07-01T16:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MzM4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "64722f96b1ba5890763a467eacb6acb1ffd94328", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/core/SolrConfig.java b/solr/core/src/java/org/apache/solr/core/SolrConfig.java\nindex 6c334896c71..2daaa95ebeb 100644\n--- a/solr/core/src/java/org/apache/solr/core/SolrConfig.java\n+++ b/solr/core/src/java/org/apache/solr/core/SolrConfig.java\n\n@@ -226,7 +226,7 @@ public class SolrConfig extends XmlConfigFile implements MapSerializable {\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n \n     useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n-    memoryCircuitBreakerThresholdPct = getInt(\"circuitBreaker/memoryCircuitBreakerThresholdPct\", 100);\n+    memoryCircuitBreakerThresholdPct = getInt(\"circuitBreaker/memoryCircuitBreakerThresholdPct\", 95);\n \n     validateMemoryBreakerThreshold();\n     \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1NTU3Nw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448455577", "bodyText": "This is a little scary that we sometimes return null here? I think I would prefer an implementation of CBM that knows it is turned off so we don't accidentally get an NPE somewhere else.", "author": "madrob", "createdAt": "2020-07-01T15:46:44Z", "path": "solr/core/src/java/org/apache/solr/core/SolrCore.java", "diffHunk": "@@ -1164,6 +1168,16 @@ private SolrCoreMetricManager initCoreMetricManager(SolrConfig config) {\n     return coreMetricManager;\n   }\n \n+  private CircuitBreakerManager initCircuitBreakerManager() {\n+    if (solrConfig.useCircuitBreakers) {\n+      CircuitBreakerManager circuitBreakerManager = CircuitBreakerManager.build(solrConfig);\n+\n+      return circuitBreakerManager;\n+    }\n+\n+    return null;", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/core/SolrCore.java b/solr/core/src/java/org/apache/solr/core/SolrCore.java\nindex b9350bd328d..8826ca36421 100644\n--- a/solr/core/src/java/org/apache/solr/core/SolrCore.java\n+++ b/solr/core/src/java/org/apache/solr/core/SolrCore.java\n\n@@ -1169,13 +1169,9 @@ public final class SolrCore implements SolrInfoBean, Closeable {\n   }\n \n   private CircuitBreakerManager initCircuitBreakerManager() {\n-    if (solrConfig.useCircuitBreakers) {\n-      CircuitBreakerManager circuitBreakerManager = CircuitBreakerManager.build(solrConfig);\n+    CircuitBreakerManager circuitBreakerManager = CircuitBreakerManager.buildDefaultCircuitBreakerManager(solrConfig);\n \n-      return circuitBreakerManager;\n-    }\n-\n-    return null;\n+    return circuitBreakerManager;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1Nzg5MA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448457890", "bodyText": "This is unused? Maybe delete it for now and add it back when somebody comes up with an implementation?", "author": "madrob", "createdAt": "2020-07-01T15:50:27Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ * <p>\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same).\n+ *  2. Use the circuit breaker in a specific code path(s).\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ * </p>\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config.\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if circuit breaker is tripped.\n+   */\n+  public abstract boolean isTripped();\n+\n+  /**\n+   * Get debug useful info.\n+   */\n+  public abstract String getDebugInfo();\n+\n+  /**\n+   * Types of circuit breakers.\n+   */\n+  public enum CircuitBreakerType {\n+    MEMORY,\n+    CPU", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\nindex b0112647a87..42bc36129bf 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n\n@@ -21,13 +21,12 @@ import org.apache.solr.core.SolrConfig;\n \n /**\n  * Default class to define circuit breakers for Solr.\n- * <p>\n+ *\n  *  There are two (typical) ways to use circuit breakers:\n- *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same).\n- *  2. Use the circuit breaker in a specific code path(s).\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n  *\n  * TODO: This class should be grown as the scope of circuit breakers grow.\n- * </p>\n  */\n public abstract class CircuitBreaker {\n   public static final String NAME = \"circuitbreaker\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1ODM4MA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448458380", "bodyText": "Does this need a \"CUSTOM\" type or something else for folks who will be implementing their own?", "author": "madrob", "createdAt": "2020-07-01T15:51:14Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ * <p>\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same).\n+ *  2. Use the circuit breaker in a specific code path(s).\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ * </p>\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config.\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if circuit breaker is tripped.\n+   */\n+  public abstract boolean isTripped();\n+\n+  /**\n+   * Get debug useful info.\n+   */\n+  public abstract String getDebugInfo();\n+\n+  /**\n+   * Types of circuit breakers.\n+   */\n+  public enum CircuitBreakerType {", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NDQ2Mg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448494462", "bodyText": "Preferably, they can add their own type when implementing a new one?", "author": "atris", "createdAt": "2020-07-01T16:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1ODM4MA=="}], "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\nindex b0112647a87..42bc36129bf 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java\n\n@@ -21,13 +21,12 @@ import org.apache.solr.core.SolrConfig;\n \n /**\n  * Default class to define circuit breakers for Solr.\n- * <p>\n+ *\n  *  There are two (typical) ways to use circuit breakers:\n- *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same).\n- *  2. Use the circuit breaker in a specific code path(s).\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n  *\n  * TODO: This class should be grown as the scope of circuit breakers grow.\n- * </p>\n  */\n public abstract class CircuitBreaker {\n   public static final String NAME = \"circuitbreaker\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTAzNw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448459037", "bodyText": "circuitBreakerMap.values()", "author": "madrob", "createdAt": "2020-07-01T15:52:22Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check and return circuit breakers that have triggered\n+   * @return CircuitBreakers which have triggered, null otherwise.\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered.\n+   *\n+   * <p>\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered.\n+   * </p>\n+   */\n+  public boolean checkAnyTripped() {\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NTM0Nw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448495347", "bodyText": "Need both the key and the value in this loop, so values() wont work?", "author": "atris", "createdAt": "2020-07-01T16:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTAzNw=="}], "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex eb1e02e325d..cd84e096638 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,27 +37,28 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n   }\n \n   /**\n-   * Check and return circuit breakers that have triggered\n-   * @return CircuitBreakers which have triggered, null otherwise.\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n    */\n-  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n-    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n \n-    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n       CircuitBreaker circuitBreaker = entry.getValue();\n \n       if (circuitBreaker.isEnabled() &&\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTcwNg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448459706", "bodyText": "This doesn't seem right... I can only have one circuit breaker of each type? I can imagine having multiple breakers that all work in conjunction - limit QPS to X, and limit QPM to Y, for example.", "author": "madrob", "createdAt": "2020-07-01T15:53:30Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex eb1e02e325d..cd84e096638 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,27 +37,28 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n   }\n \n   /**\n-   * Check and return circuit breakers that have triggered\n-   * @return CircuitBreakers which have triggered, null otherwise.\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n    */\n-  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n-    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n \n-    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n       CircuitBreaker circuitBreaker = entry.getValue();\n \n       if (circuitBreaker.isEnabled() &&\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTg2MA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448459860", "bodyText": "Is this needed?", "author": "madrob", "createdAt": "2020-07-01T15:53:46Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex eb1e02e325d..cd84e096638 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,27 +37,28 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n   }\n \n   /**\n-   * Check and return circuit breakers that have triggered\n-   * @return CircuitBreakers which have triggered, null otherwise.\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n    */\n-  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n-    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n \n-    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n       CircuitBreaker circuitBreaker = entry.getValue();\n \n       if (circuitBreaker.isEnabled() &&\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MDI3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448460273", "bodyText": "do multiple append calls instead of string concat.", "author": "madrob", "createdAt": "2020-07-01T15:54:24Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check and return circuit breakers that have triggered\n+   * @return CircuitBreakers which have triggered, null otherwise.\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered.\n+   *\n+   * <p>\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered.\n+   * </p>\n+   */\n+  public boolean checkAnyTripped() {\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip.\n+   *\n+   * @param circuitBreakerMap Input list for circuit breakers.\n+   * @return Constructed error message.\n+   */\n+  public static String toErrorMessage(Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreaker.CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).getDebugInfo() + \"\\n\");", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex eb1e02e325d..cd84e096638 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,27 +37,28 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n   }\n \n   /**\n-   * Check and return circuit breakers that have triggered\n-   * @return CircuitBreakers which have triggered, null otherwise.\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n    */\n-  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n-    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n \n-    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n       CircuitBreaker circuitBreaker = entry.getValue();\n \n       if (circuitBreaker.isEnabled() &&\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MDY1MQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448460651", "bodyText": "This method is never used?", "author": "madrob", "createdAt": "2020-07-01T15:54:58Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NTU2NQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448495565", "bodyText": "Added for sanity.", "author": "atris", "createdAt": "2020-07-01T16:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MDY1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex eb1e02e325d..cd84e096638 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,27 +37,28 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n   }\n \n   /**\n-   * Check and return circuit breakers that have triggered\n-   * @return CircuitBreakers which have triggered, null otherwise.\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n    */\n-  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n-    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n \n-    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n       CircuitBreaker circuitBreaker = entry.getValue();\n \n       if (circuitBreaker.isEnabled() &&\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MTE4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448461185", "bodyText": "This is unused?", "author": "madrob", "createdAt": "2020-07-01T15:55:48Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check and return circuit breakers that have triggered\n+   * @return CircuitBreakers which have triggered, null otherwise.\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered.\n+   *\n+   * <p>\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered.\n+   * </p>\n+   */\n+  public boolean checkAnyTripped() {", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NTYyOA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448495628", "bodyText": "Added for sanity", "author": "atris", "createdAt": "2020-07-01T16:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MTE4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\nindex eb1e02e325d..cd84e096638 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java\n\n@@ -37,27 +37,28 @@ import org.apache.solr.core.SolrConfig;\n  * solution. There will be a follow up with a SIP for a schema API design.\n  */\n public class CircuitBreakerManager {\n-  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n \n   // Allows replacing of existing circuit breaker\n-  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n     circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n   }\n \n-  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n     assert circuitBreakerType != null;\n \n     return circuitBreakerMap.get(circuitBreakerType);\n   }\n \n   /**\n-   * Check and return circuit breakers that have triggered\n-   * @return CircuitBreakers which have triggered, null otherwise.\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n    */\n-  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n-    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n \n-    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n       CircuitBreaker circuitBreaker = entry.getValue();\n \n       if (circuitBreaker.isEnabled() &&\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MjAwOQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448462009", "bodyText": "Should we store these to local values so that we don't have to call an extra .get() on the concurrent structure? Probably doesn't make a difference.", "author": "madrob", "createdAt": "2020-07-01T15:57:09Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThresholdPct\n+ * in solrconfig.xml.\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NjkwMg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448496902", "bodyText": "It would be a two step process -- setting local value and then setting the thread local. Seems cleaner this way? I doubt if it will really cause a performance issue -- the variables are thread local", "author": "atris", "createdAt": "2020-07-01T16:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MjAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1MDQ4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448550485", "bodyText": "this solution has an extra unboxing.", "author": "madrob", "createdAt": "2020-07-01T18:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MjAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\nindex 8a1e79e834e..2a6c50f1db3 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n\n@@ -17,13 +17,10 @@\n \n package org.apache.solr.util.circuitbreaker;\n \n-import java.lang.invoke.MethodHandles;\n import java.lang.management.ManagementFactory;\n import java.lang.management.MemoryMXBean;\n \n import org.apache.solr.core.SolrConfig;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n  * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MjMxNA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448462314", "bodyText": "Why are we comparing a long to a floating point?", "author": "madrob", "createdAt": "2020-07-01T15:57:38Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThresholdPct\n+ * in solrconfig.xml.\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String getDebugInfo() {\n+    if (seenMemory.get() == 0.0 || allowedMemory.get() == 0.0) {", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\nindex 8a1e79e834e..2a6c50f1db3 100644\n--- a/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n+++ b/solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java\n\n@@ -17,13 +17,10 @@\n \n package org.apache.solr.util.circuitbreaker;\n \n-import java.lang.invoke.MethodHandles;\n import java.lang.management.ManagementFactory;\n import java.lang.management.MemoryMXBean;\n \n import org.apache.solr.core.SolrConfig;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n  * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ4MzEwNg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448483106", "bodyText": "What is this testing? Is this just resetting the circuitbreakermanager? Should be in a Before/After blocks?", "author": "madrob", "createdAt": "2020-07-01T16:32:47Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrConfig;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+\n+  @Rule\n+  public TestRule solrTestRules = RuleChain.outerRule(new SystemPropertiesRestoreRule());\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(adoc(\"id\", \"1\", \"title\", \"this is a title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"2\", \"title\", \"this is another title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"3\", \"title\", \"Mary had a little lamb.\", \"inStock_b1\", \"false\"));\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    super.tearDown();\n+  }\n+\n+  public void testCBAlwaysTrips() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new MockCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+\n+    circuitBreaker = new MemoryCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);\n+  }\n+\n+  public void testCBFakeMemoryPressure() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new FakeMemoryPressureCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+\n+    circuitBreaker = new MemoryCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java b/solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java\nindex 13333ad0fac..8b67a4c00aa 100644\n--- a/solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java\n+++ b/solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java\n\n@@ -23,27 +23,23 @@ import java.util.concurrent.ExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;\n import org.apache.solr.SolrTestCaseJ4;\n import org.apache.solr.common.SolrException;\n import org.apache.solr.common.params.CommonParams;\n import org.apache.solr.common.util.ExecutorUtil;\n import org.apache.solr.common.util.SolrNamedThreadFactory;\n import org.apache.solr.core.SolrConfig;\n+import org.apache.solr.core.SolrCore;\n import org.apache.solr.search.QueryParsing;\n import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.AfterClass;\n import org.junit.BeforeClass;\n-import org.junit.Rule;\n-import org.junit.rules.RuleChain;\n-import org.junit.rules.TestRule;\n \n public class TestCircuitBreaker extends SolrTestCaseJ4 {\n   private final static int NUM_DOCS = 20;\n \n-  @Rule\n-  public TestRule solrTestRules = RuleChain.outerRule(new SystemPropertiesRestoreRule());\n-\n   @BeforeClass\n   public static void setUpClass() throws Exception {\n     System.setProperty(\"filterCache.enabled\", \"false\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1MTQwMg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448551402", "bodyText": "This appends to the list, doesn't do any clearing. By the last test you'll have three of the same circuit breakers running.", "author": "madrob", "createdAt": "2020-07-01T18:44:33Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrConfig;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.After;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+\n+  @Rule\n+  public TestRule solrTestRules = RuleChain.outerRule(new SystemPropertiesRestoreRule());\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(adoc(\"id\", \"1\", \"title\", \"this is a title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"2\", \"title\", \"this is another title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"3\", \"title\", \"Mary had a little lamb.\", \"inStock_b1\", \"false\"));\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    super.tearDown();\n+  }\n+\n+  @After\n+  public void after() {\n+    CircuitBreaker circuitBreaker = new MemoryCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(circuitBreaker);", "originalCommit": "3dbfc0b02afb925d7abd3da00a309cf8c723a1e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "413b4b98172d453cfc9bdc78c2802d7879031983", "chunk": "diff --git a/solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java b/solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java\nindex d12049f7235..8b67a4c00aa 100644\n--- a/solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java\n+++ b/solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java\n\n@@ -17,33 +17,29 @@\n \n package org.apache.solr.util;\n \n+import java.io.IOException;\n import java.util.HashMap;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;\n import org.apache.solr.SolrTestCaseJ4;\n import org.apache.solr.common.SolrException;\n import org.apache.solr.common.params.CommonParams;\n import org.apache.solr.common.util.ExecutorUtil;\n import org.apache.solr.common.util.SolrNamedThreadFactory;\n import org.apache.solr.core.SolrConfig;\n+import org.apache.solr.core.SolrCore;\n import org.apache.solr.search.QueryParsing;\n import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n-import org.junit.After;\n+import org.junit.AfterClass;\n import org.junit.BeforeClass;\n-import org.junit.Rule;\n-import org.junit.rules.RuleChain;\n-import org.junit.rules.TestRule;\n \n public class TestCircuitBreaker extends SolrTestCaseJ4 {\n   private final static int NUM_DOCS = 20;\n \n-  @Rule\n-  public TestRule solrTestRules = RuleChain.outerRule(new SystemPropertiesRestoreRule());\n-\n   @BeforeClass\n   public static void setUpClass() throws Exception {\n     System.setProperty(\"filterCache.enabled\", \"false\");\n"}}, {"oid": "413b4b98172d453cfc9bdc78c2802d7879031983", "url": "https://github.com/apache/lucene-solr/commit/413b4b98172d453cfc9bdc78c2802d7879031983", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "d02a6e2f7f87757c2e6016fa97c0b2544e6facb4", "url": "https://github.com/apache/lucene-solr/commit/d02a6e2f7f87757c2e6016fa97c0b2544e6facb4", "message": "Update test parameter", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "64448f0a8b068712e584d898073e3d912dcfe1ec", "url": "https://github.com/apache/lucene-solr/commit/64448f0a8b068712e584d898073e3d912dcfe1ec", "message": "More Updates", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "65751ee38aa0da73bc99b697500b31bbc3e5b6e8", "url": "https://github.com/apache/lucene-solr/commit/65751ee38aa0da73bc99b697500b31bbc3e5b6e8", "message": "Renamings", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "e2a19278643409558709d582638e20c4832d78e1", "url": "https://github.com/apache/lucene-solr/commit/e2a19278643409558709d582638e20c4832d78e1", "message": "Updated per comments", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "3fa18af58be636fce922a68c9de0ea2cbfe198b9", "url": "https://github.com/apache/lucene-solr/commit/3fa18af58be636fce922a68c9de0ea2cbfe198b9", "message": "Add remaining formatting", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "de529ed55a44941f5448fd5c30733645add0acd7", "url": "https://github.com/apache/lucene-solr/commit/de529ed55a44941f5448fd5c30733645add0acd7", "message": "Moar Stuff", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "64722f96b1ba5890763a467eacb6acb1ffd94328", "url": "https://github.com/apache/lucene-solr/commit/64722f96b1ba5890763a467eacb6acb1ffd94328", "message": "More comments", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "1045e161ae9e2d0aeb68aea517cce883dbaf231a", "url": "https://github.com/apache/lucene-solr/commit/1045e161ae9e2d0aeb68aea517cce883dbaf231a", "message": "Brain Fart", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "5099095fe532ad46db8c01029ef42fb8d6113010", "url": "https://github.com/apache/lucene-solr/commit/5099095fe532ad46db8c01029ef42fb8d6113010", "message": "Fix precommit", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "url": "https://github.com/apache/lucene-solr/commit/8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "message": "Updating per comments", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "url": "https://github.com/apache/lucene-solr/commit/8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "message": "Updating per comments", "committedDate": "2020-07-02T06:54:50Z", "type": "forcePushed"}]}