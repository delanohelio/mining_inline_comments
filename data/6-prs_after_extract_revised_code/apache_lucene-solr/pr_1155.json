{"pr_number": 1155, "pr_title": "LUCENE-8962: Add ability to selectively merge on commit", "pr_createdAt": "2020-01-07T23:55:58Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1155", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNzMzNA==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365837334", "bodyText": "This relies on some peculiar semantics of SegmentInfos, namely that it manages Segment internally as a List. I guess that's true now, but I wonder if we shouldn't make SegmentInfos actually implement List, have asList return a modifiable List, or at least document and/or add a unit test to TestSegmentInfos enforcing that you can remove while iterating and expect a certain ordering of the elements? It seems to be implicit in the contract given that segments are ordered, but it's not explicitly stated in the javadocs at least.", "author": "msokolov", "createdAt": "2020-01-13T14:37:09Z", "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3147,6 +3149,38 @@ public final boolean flushNextBuffer() throws IOException {\n     }\n   }\n \n+  private MergePolicy waitForMergeOnCommitPolicy(MergePolicy source, final SegmentInfos toCommit,\n+                                                 AtomicReference<CountDownLatch> mergeLatchRef) {\n+    return new OneMergeWrappingMergePolicy(source, (toWrap) -> new MergePolicy.OneMerge(toWrap.segments) {\n+      @Override\n+      public void mergeFinished() throws IOException {\n+        super.mergeFinished();\n+        CountDownLatch mergeAwaitLatch = mergeLatchRef.get();\n+        if (mergeAwaitLatch == null) {\n+          // Commit thread timed out waiting for this merge and moved on. No need to manipulate toCommit.\n+          return;\n+        }\n+        if (isAborted() == false) {\n+          deleter.incRef(this.info.files());\n+          toCommit.add(this.info.clone());\n+          long segmentCounter = Long.parseLong(this.info.info.name.substring(1), Character.MAX_RADIX);\n+          toCommit.counter = Math.max(toCommit.counter, segmentCounter + 1);\n+          Set<String> segmentNamesToRemove = new HashSet<>();\n+          for (SegmentCommitInfo sci : this.segments) {\n+            deleter.decRef(sci.files());\n+            segmentNamesToRemove.add(sci.info.name);\n+          }\n+          for (int i = toCommit.size() - 1; i >= 0; i--) {\n+            if (segmentNamesToRemove.contains(toCommit.info(i).info.name)) {\n+              toCommit.remove(i);", "originalCommit": "f5bf1b6577ed866ec01486bcb928bdf8302d643d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MDYwMQ==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r368260601", "bodyText": "I've now forgotten my motivation for traversing the list backwards. I think it was just to avoid needing to do some potentially messy/error-prone index manipulation.\nIn my latest commit, I realized that I could leverage SegmentInfos.applyMergeChanges if I replace the merged segments with their toCommit doppelg\u00e4ngers. I think that provides better encapsulation and lets SegmentInfos manage its own internal state better. (Also applyMergeChanges does some weird and wonderful list manipulation of its own that I definitely didn't want to replicate into IndexWriter.)", "author": "msfroh", "createdAt": "2020-01-19T02:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNzMzNA=="}], "type": "inlineReview", "revised_code": {"commit": "0907f65a1e59647690d3a2c4d6964ff85ef80d44", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\nindex 9bdd672968f..7b47c887ecc 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n\n@@ -3149,10 +3149,9 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable,\n     }\n   }\n \n-  private MergePolicy waitForMergeOnCommitPolicy(MergePolicy source, final SegmentInfos toCommit,\n-                                                 AtomicReference<CountDownLatch> mergeLatchRef) {\n-    return new OneMergeWrappingMergePolicy(source, (toWrap) -> new MergePolicy.OneMerge(toWrap.segments) {\n-      @Override\n+  private MergePolicy.OneMerge updateSegmentInfosOnMergeFinish(MergePolicy.OneMerge merge, final SegmentInfos toCommit,\n+                                                                AtomicReference<CountDownLatch> mergeLatchRef) {\n+    return new MergePolicy.OneMerge(merge.segments) {\n       public void mergeFinished() throws IOException {\n         super.mergeFinished();\n         CountDownLatch mergeAwaitLatch = mergeLatchRef.get();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNzc2Nw==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365837767", "bodyText": "Would we sometimes get !=null and == 0??", "author": "msokolov", "createdAt": "2020-01-13T14:37:56Z", "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3223,15 +3259,44 @@ private long prepareCommitInternal() throws IOException {\n               // sneak into the commit point:\n               toCommit = segmentInfos.clone();\n \n+              if (anyChanges) {\n+                mergeAwaitLatchRef = new AtomicReference<>();\n+                MergePolicy mergeOnCommitPolicy = waitForMergeOnCommitPolicy(config.getMergePolicy(), toCommit, mergeAwaitLatchRef);\n+\n+                // Find any merges that can execute on commit (per MergePolicy).\n+                commitMerges = mergeOnCommitPolicy.findCommitMerges(segmentInfos, this);\n+                if (commitMerges != null && commitMerges.merges.size() > 0) {", "originalCommit": "f5bf1b6577ed866ec01486bcb928bdf8302d643d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE4NDA1Mg==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r368184052", "bodyText": "Based on e.g. NoMergePolicy, it looks like the convention to say \"I found no merges\" is to return null, but I can't see anything preventing a MergePolicy from returning an empty MergeSpecification.", "author": "msfroh", "createdAt": "2020-01-18T00:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNzc2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0907f65a1e59647690d3a2c4d6964ff85ef80d44", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\nindex 9bdd672968f..7b47c887ecc 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n\n@@ -3260,31 +3264,25 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable,\n               toCommit = segmentInfos.clone();\n \n               if (anyChanges) {\n-                mergeAwaitLatchRef = new AtomicReference<>();\n-                MergePolicy mergeOnCommitPolicy = waitForMergeOnCommitPolicy(config.getMergePolicy(), toCommit, mergeAwaitLatchRef);\n-\n                 // Find any merges that can execute on commit (per MergePolicy).\n-                commitMerges = mergeOnCommitPolicy.findCommitMerges(segmentInfos, this);\n-                if (commitMerges != null && commitMerges.merges.size() > 0) {\n-                  int mergeCount = 0;\n-                  for (MergePolicy.OneMerge oneMerge : commitMerges.merges) {\n-                    if (registerMerge(oneMerge)) {\n-                      mergeCount++;\n-                    } else {\n+                MergePolicy.MergeSpecification mergeSpec =\n+                    config.getMergePolicy().findCommitMerges(segmentInfos, this);\n+                if (mergeSpec != null && mergeSpec.merges.size() > 0) {\n+                  int mergeCount = mergeSpec.merges.size();\n+                  commitMerges = new ArrayList<>(mergeCount);\n+                  mergeAwaitLatchRef = new AtomicReference<>(new CountDownLatch(mergeCount));\n+                  for (MergePolicy.OneMerge oneMerge : mergeSpec.merges) {\n+                    MergePolicy.OneMerge trackedMerge =\n+                        updateSegmentInfosOnMergeFinish(oneMerge, toCommit, mergeAwaitLatchRef);\n+                    if (registerMerge(trackedMerge) == false) {\n                       throw new IllegalStateException(\"MergePolicy \" + config.getMergePolicy().getClass() +\n                           \" returned merging segments from findCommitMerges\");\n                     }\n+                    commitMerges.add(trackedMerge);\n                   }\n-                  if (mergeCount > 0) {\n-                    if (infoStream.isEnabled(\"IW\")) {\n-                      infoStream.message(\"IW\", \"Registered \" + mergeCount + \" commit merges\");\n-                      infoStream.message(\"IW\", \"Before executing commit merges, had \" + toCommit.size() + \" segments\");\n-                    }\n-                    mergeAwaitLatchRef.set(new CountDownLatch(mergeCount));\n-                  } else {\n-                    if (infoStream.isEnabled(\"IW\")) {\n-                      infoStream.message(\"IW\", \"Registered no commit merges\");\n-                    }\n+                  if (infoStream.isEnabled(\"IW\")) {\n+                    infoStream.message(\"IW\", \"Registered \" + mergeCount + \" commit merges\");\n+                    infoStream.message(\"IW\", \"Before executing commit merges, had \" + toCommit.size() + \" segments\");\n                   }\n                 }\n               }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzODQzNA==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365838434", "bodyText": "I If we fail to registerMerge does it necessarily mean the segment was already being merged?", "author": "msokolov", "createdAt": "2020-01-13T14:39:14Z", "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3223,15 +3259,44 @@ private long prepareCommitInternal() throws IOException {\n               // sneak into the commit point:\n               toCommit = segmentInfos.clone();\n \n+              if (anyChanges) {\n+                mergeAwaitLatchRef = new AtomicReference<>();\n+                MergePolicy mergeOnCommitPolicy = waitForMergeOnCommitPolicy(config.getMergePolicy(), toCommit, mergeAwaitLatchRef);\n+\n+                // Find any merges that can execute on commit (per MergePolicy).\n+                commitMerges = mergeOnCommitPolicy.findCommitMerges(segmentInfos, this);\n+                if (commitMerges != null && commitMerges.merges.size() > 0) {\n+                  int mergeCount = 0;\n+                  for (MergePolicy.OneMerge oneMerge : commitMerges.merges) {\n+                    if (registerMerge(oneMerge)) {\n+                      mergeCount++;\n+                    } else {\n+                      throw new IllegalStateException(\"MergePolicy \" + config.getMergePolicy().getClass() +", "originalCommit": "f5bf1b6577ed866ec01486bcb928bdf8302d643d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MDQzNA==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r368260434", "bodyText": "Yes -- or it means that the OneMerge contains a segment that doesn't exist (anymore?).\nSince we execute this while holding IndexWriter lock, it should not be the case that the merge policy could have returned a OneMerge that contains a segment that no longer exists (because updating the live SegmentInfos should only occur within the IW lock).", "author": "msfroh", "createdAt": "2020-01-19T02:22:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzODQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1MzIzNg==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r371953236", "bodyText": "I see, thanks for explaining!", "author": "msokolov", "createdAt": "2020-01-28T17:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzODQzNA=="}], "type": "inlineReview", "revised_code": {"commit": "0907f65a1e59647690d3a2c4d6964ff85ef80d44", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\nindex 9bdd672968f..7b47c887ecc 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n\n@@ -3260,31 +3264,25 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable,\n               toCommit = segmentInfos.clone();\n \n               if (anyChanges) {\n-                mergeAwaitLatchRef = new AtomicReference<>();\n-                MergePolicy mergeOnCommitPolicy = waitForMergeOnCommitPolicy(config.getMergePolicy(), toCommit, mergeAwaitLatchRef);\n-\n                 // Find any merges that can execute on commit (per MergePolicy).\n-                commitMerges = mergeOnCommitPolicy.findCommitMerges(segmentInfos, this);\n-                if (commitMerges != null && commitMerges.merges.size() > 0) {\n-                  int mergeCount = 0;\n-                  for (MergePolicy.OneMerge oneMerge : commitMerges.merges) {\n-                    if (registerMerge(oneMerge)) {\n-                      mergeCount++;\n-                    } else {\n+                MergePolicy.MergeSpecification mergeSpec =\n+                    config.getMergePolicy().findCommitMerges(segmentInfos, this);\n+                if (mergeSpec != null && mergeSpec.merges.size() > 0) {\n+                  int mergeCount = mergeSpec.merges.size();\n+                  commitMerges = new ArrayList<>(mergeCount);\n+                  mergeAwaitLatchRef = new AtomicReference<>(new CountDownLatch(mergeCount));\n+                  for (MergePolicy.OneMerge oneMerge : mergeSpec.merges) {\n+                    MergePolicy.OneMerge trackedMerge =\n+                        updateSegmentInfosOnMergeFinish(oneMerge, toCommit, mergeAwaitLatchRef);\n+                    if (registerMerge(trackedMerge) == false) {\n                       throw new IllegalStateException(\"MergePolicy \" + config.getMergePolicy().getClass() +\n                           \" returned merging segments from findCommitMerges\");\n                     }\n+                    commitMerges.add(trackedMerge);\n                   }\n-                  if (mergeCount > 0) {\n-                    if (infoStream.isEnabled(\"IW\")) {\n-                      infoStream.message(\"IW\", \"Registered \" + mergeCount + \" commit merges\");\n-                      infoStream.message(\"IW\", \"Before executing commit merges, had \" + toCommit.size() + \" segments\");\n-                    }\n-                    mergeAwaitLatchRef.set(new CountDownLatch(mergeCount));\n-                  } else {\n-                    if (infoStream.isEnabled(\"IW\")) {\n-                      infoStream.message(\"IW\", \"Registered no commit merges\");\n-                    }\n+                  if (infoStream.isEnabled(\"IW\")) {\n+                    infoStream.message(\"IW\", \"Registered \" + mergeCount + \" commit merges\");\n+                    infoStream.message(\"IW\", \"Before executing commit merges, had \" + toCommit.size() + \" segments\");\n                   }\n                 }\n               }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTQ4Mw==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365839483", "bodyText": "could we wait to create this until we create its CountdownLatch and simplify the null checks below?", "author": "msokolov", "createdAt": "2020-01-13T14:41:10Z", "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3223,15 +3259,44 @@ private long prepareCommitInternal() throws IOException {\n               // sneak into the commit point:\n               toCommit = segmentInfos.clone();\n \n+              if (anyChanges) {\n+                mergeAwaitLatchRef = new AtomicReference<>();", "originalCommit": "f5bf1b6577ed866ec01486bcb928bdf8302d643d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE4NzEzNQ==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r368187135", "bodyText": "This is a little bit of hackery to share state between this thread and the threads that do the merges.\nWe initialize the ref here, pass it to waitForMergeOnCommitPolicy on the next line to make sure it gets shared with any computed OneMerges. Then, before we release the IW lock (so we're guaranteed that those OneMerges haven't run yet), we populate the ref with the CountdownLatch (once we know what we're counting down).\nThat said, I think I could simplify things a lot by not using OneMergeWrappingMergePolicy, but rather decorating the returned OneMerges (if applicable) directly. I'm going to take a stab at that approach in my next commit.", "author": "msfroh", "createdAt": "2020-01-18T00:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTQ4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0907f65a1e59647690d3a2c4d6964ff85ef80d44", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\nindex 9bdd672968f..7b47c887ecc 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n\n@@ -3260,31 +3264,25 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable,\n               toCommit = segmentInfos.clone();\n \n               if (anyChanges) {\n-                mergeAwaitLatchRef = new AtomicReference<>();\n-                MergePolicy mergeOnCommitPolicy = waitForMergeOnCommitPolicy(config.getMergePolicy(), toCommit, mergeAwaitLatchRef);\n-\n                 // Find any merges that can execute on commit (per MergePolicy).\n-                commitMerges = mergeOnCommitPolicy.findCommitMerges(segmentInfos, this);\n-                if (commitMerges != null && commitMerges.merges.size() > 0) {\n-                  int mergeCount = 0;\n-                  for (MergePolicy.OneMerge oneMerge : commitMerges.merges) {\n-                    if (registerMerge(oneMerge)) {\n-                      mergeCount++;\n-                    } else {\n+                MergePolicy.MergeSpecification mergeSpec =\n+                    config.getMergePolicy().findCommitMerges(segmentInfos, this);\n+                if (mergeSpec != null && mergeSpec.merges.size() > 0) {\n+                  int mergeCount = mergeSpec.merges.size();\n+                  commitMerges = new ArrayList<>(mergeCount);\n+                  mergeAwaitLatchRef = new AtomicReference<>(new CountDownLatch(mergeCount));\n+                  for (MergePolicy.OneMerge oneMerge : mergeSpec.merges) {\n+                    MergePolicy.OneMerge trackedMerge =\n+                        updateSegmentInfosOnMergeFinish(oneMerge, toCommit, mergeAwaitLatchRef);\n+                    if (registerMerge(trackedMerge) == false) {\n                       throw new IllegalStateException(\"MergePolicy \" + config.getMergePolicy().getClass() +\n                           \" returned merging segments from findCommitMerges\");\n                     }\n+                    commitMerges.add(trackedMerge);\n                   }\n-                  if (mergeCount > 0) {\n-                    if (infoStream.isEnabled(\"IW\")) {\n-                      infoStream.message(\"IW\", \"Registered \" + mergeCount + \" commit merges\");\n-                      infoStream.message(\"IW\", \"Before executing commit merges, had \" + toCommit.size() + \" segments\");\n-                    }\n-                    mergeAwaitLatchRef.set(new CountDownLatch(mergeCount));\n-                  } else {\n-                    if (infoStream.isEnabled(\"IW\")) {\n-                      infoStream.message(\"IW\", \"Registered no commit merges\");\n-                    }\n+                  if (infoStream.isEnabled(\"IW\")) {\n+                    infoStream.message(\"IW\", \"Registered \" + mergeCount + \" commit merges\");\n+                    infoStream.message(\"IW\", \"Before executing commit merges, had \" + toCommit.size() + \" segments\");\n                   }\n                 }\n               }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MDc2MQ==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365840761", "bodyText": "\"... from within ...\"", "author": "msokolov", "createdAt": "2020-01-13T14:43:29Z", "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3252,6 +3317,53 @@ private long prepareCommitInternal() throws IOException {\n       } finally {\n         maybeCloseOnTragicEvent();\n       }\n+\n+      if (mergeAwaitLatchRef != null && mergeAwaitLatchRef.get() != null) {\n+        CountDownLatch mergeAwaitLatch = mergeAwaitLatchRef.get();\n+        // If we found and registered any merges above, within the flushLock, then we want to ensure that they\n+        // complete execution. Note that since we released the lock, other merges may have been scheduled. We will\n+        // block until  the merges that we registered complete. As they complete, they will update toCommit to\n+        // replace merged segments with the result of each merge.\n+        mergeScheduler.merge(this, MergeTrigger.FULL_FLUSH, true);\n+        long mergeWaitStart = System.nanoTime();\n+        int abandonedCount = 0;\n+        long waitTimeMillis = (long) (config.getMaxCommitMergeWaitSeconds() * 1000.0);\n+        try {\n+          config.getIndexWriterEvents().beginMergeOnCommit();\n+          if (mergeAwaitLatch.await(waitTimeMillis, TimeUnit.MILLISECONDS) == false) {\n+            synchronized (this) {\n+              // Need to do this in a synchronized block, to make sure none of our commit merges are currently\n+              // executing mergeFinished (since mergeFinished itself is called from with the IndexWriter lock).", "originalCommit": "f5bf1b6577ed866ec01486bcb928bdf8302d643d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MDYxMw==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r368260613", "bodyText": "D'oh! Fixed, thanks!", "author": "msfroh", "createdAt": "2020-01-19T02:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MDc2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0907f65a1e59647690d3a2c4d6964ff85ef80d44", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\nindex 9bdd672968f..7b47c887ecc 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n\n@@ -3318,18 +3316,18 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable,\n         maybeCloseOnTragicEvent();\n       }\n \n-      if (mergeAwaitLatchRef != null && mergeAwaitLatchRef.get() != null) {\n+      if (mergeAwaitLatchRef != null) {\n         CountDownLatch mergeAwaitLatch = mergeAwaitLatchRef.get();\n         // If we found and registered any merges above, within the flushLock, then we want to ensure that they\n         // complete execution. Note that since we released the lock, other merges may have been scheduled. We will\n         // block until  the merges that we registered complete. As they complete, they will update toCommit to\n         // replace merged segments with the result of each merge.\n+        config.getIndexWriterEvents().beginMergeOnCommit();\n         mergeScheduler.merge(this, MergeTrigger.FULL_FLUSH, true);\n         long mergeWaitStart = System.nanoTime();\n         int abandonedCount = 0;\n         long waitTimeMillis = (long) (config.getMaxCommitMergeWaitSeconds() * 1000.0);\n         try {\n-          config.getIndexWriterEvents().beginMergeOnCommit();\n           if (mergeAwaitLatch.await(waitTimeMillis, TimeUnit.MILLISECONDS) == false) {\n             synchronized (this) {\n               // Need to do this in a synchronized block, to make sure none of our commit merges are currently\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MjA3Ng==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365842076", "bodyText": "Typically why would it happen that we abandon some merges? timeout? Would there be any sense in trying to interrupt them?", "author": "msokolov", "createdAt": "2020-01-13T14:45:58Z", "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3252,6 +3317,53 @@ private long prepareCommitInternal() throws IOException {\n       } finally {\n         maybeCloseOnTragicEvent();\n       }\n+\n+      if (mergeAwaitLatchRef != null && mergeAwaitLatchRef.get() != null) {\n+        CountDownLatch mergeAwaitLatch = mergeAwaitLatchRef.get();\n+        // If we found and registered any merges above, within the flushLock, then we want to ensure that they\n+        // complete execution. Note that since we released the lock, other merges may have been scheduled. We will\n+        // block until  the merges that we registered complete. As they complete, they will update toCommit to\n+        // replace merged segments with the result of each merge.\n+        mergeScheduler.merge(this, MergeTrigger.FULL_FLUSH, true);\n+        long mergeWaitStart = System.nanoTime();\n+        int abandonedCount = 0;\n+        long waitTimeMillis = (long) (config.getMaxCommitMergeWaitSeconds() * 1000.0);\n+        try {\n+          config.getIndexWriterEvents().beginMergeOnCommit();\n+          if (mergeAwaitLatch.await(waitTimeMillis, TimeUnit.MILLISECONDS) == false) {\n+            synchronized (this) {\n+              // Need to do this in a synchronized block, to make sure none of our commit merges are currently\n+              // executing mergeFinished (since mergeFinished itself is called from with the IndexWriter lock).\n+              // After we clear the value from mergeAwaitLatchRef, the merges we schedule will still execute as\n+              // usual, but when they finish, they won't attempt to update toCommit or modify segment reference\n+              // counts.", "originalCommit": "f5bf1b6577ed866ec01486bcb928bdf8302d643d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MDI1Mg==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r368260252", "bodyText": "Yeah -- maybe we only want to wait a short time for these merges to complete. If a merge doesn't complete, we should move forward with the commit. Since these merges will still update the \"real\" SegmentInfos, any progress they've made is arguably still useful. That's why I didn't want to interrupt them.", "author": "msfroh", "createdAt": "2020-01-19T02:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MjA3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0907f65a1e59647690d3a2c4d6964ff85ef80d44", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\nindex 9bdd672968f..7b47c887ecc 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java\n\n@@ -3318,18 +3316,18 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable,\n         maybeCloseOnTragicEvent();\n       }\n \n-      if (mergeAwaitLatchRef != null && mergeAwaitLatchRef.get() != null) {\n+      if (mergeAwaitLatchRef != null) {\n         CountDownLatch mergeAwaitLatch = mergeAwaitLatchRef.get();\n         // If we found and registered any merges above, within the flushLock, then we want to ensure that they\n         // complete execution. Note that since we released the lock, other merges may have been scheduled. We will\n         // block until  the merges that we registered complete. As they complete, they will update toCommit to\n         // replace merged segments with the result of each merge.\n+        config.getIndexWriterEvents().beginMergeOnCommit();\n         mergeScheduler.merge(this, MergeTrigger.FULL_FLUSH, true);\n         long mergeWaitStart = System.nanoTime();\n         int abandonedCount = 0;\n         long waitTimeMillis = (long) (config.getMaxCommitMergeWaitSeconds() * 1000.0);\n         try {\n-          config.getIndexWriterEvents().beginMergeOnCommit();\n           if (mergeAwaitLatch.await(waitTimeMillis, TimeUnit.MILLISECONDS) == false) {\n             synchronized (this) {\n               // Need to do this in a synchronized block, to make sure none of our commit merges are currently\n"}}, {"oid": "d8af5ff0d00de33734b7ac03866fae3a2439d807", "url": "https://github.com/apache/lucene-solr/commit/d8af5ff0d00de33734b7ac03866fae3a2439d807", "message": "LUCENE-8962: Add ability to selectively merge on commit\n\nThis adds a new \"findCommitMerges\" method to MergePolicy, which can\nspecify merges to be executed before the\nIndexWriter.prepareCommitInternal method returns.\n\nIf we have many index writer threads, they will flush their DWPT buffers\non commit, resulting in many small segments, which can be merged before\nthe commit returns.", "committedDate": "2020-01-17T23:14:42Z", "type": "commit"}, {"oid": "a04f5f2fb83708fecdb8959588d314ff95124839", "url": "https://github.com/apache/lucene-solr/commit/a04f5f2fb83708fecdb8959588d314ff95124839", "message": "Add missing Javadoc", "committedDate": "2020-01-17T23:14:42Z", "type": "commit"}, {"oid": "376ba0964b4a5428846addee53609bf268456237", "url": "https://github.com/apache/lucene-solr/commit/376ba0964b4a5428846addee53609bf268456237", "message": "Fix incorrect comment", "committedDate": "2020-01-17T23:14:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE4MjE2OA==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r368182168", "bodyText": "I just found that this assertion sometimes fails. If there are some pending/running merges left over from the indexing threads, the segments associated with those merges will be excluded from merging on commit. I'll update this test to wait for pending merges to finish before committing.", "author": "msfroh", "createdAt": "2020-01-17T23:55:14Z", "path": "lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy.java", "diffHunk": "@@ -277,6 +285,92 @@ public void testSetters() {\n     assertSetters(new LogDocMergePolicy());\n   }\n \n+  public void testMergeOnCommit() throws IOException, InterruptedException {\n+    Directory dir = newDirectory();\n+    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n+        .setMergePolicy(NoMergePolicy.INSTANCE));\n+    for (int i = 0; i < 5; i++) {\n+      TestIndexWriter.addDoc(firstWriter);\n+      firstWriter.flush();\n+    }\n+    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n+    assertEquals(5, firstReader.leaves().size());\n+    firstReader.close();\n+    firstWriter.close();\n+\n+    MergePolicy mergeOnCommitPolicy = new LogDocMergePolicy() {\n+      @Override\n+      public MergeSpecification findCommitMerges(SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException {\n+        // Optimize down to a single segment on commit\n+        MergeSpecification mergeSpecification = new MergeSpecification();\n+        List<SegmentCommitInfo> nonMergingSegments = new ArrayList<>();\n+        for (SegmentCommitInfo sci : segmentInfos) {\n+          if (mergeContext.getMergingSegments().contains(sci) == false) {\n+            nonMergingSegments.add(sci);\n+          }\n+        }\n+        mergeSpecification.add(new OneMerge(nonMergingSegments));\n+        return mergeSpecification;\n+      }\n+    };\n+\n+    IndexWriter writerWithMergePolicy = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n+        .setMergePolicy(mergeOnCommitPolicy));\n+\n+    writerWithMergePolicy.commit();\n+\n+    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n+    assertEquals(5, unmergedReader.leaves().size()); // Don't merge unless there's a change\n+    unmergedReader.close();\n+\n+    TestIndexWriter.addDoc(writerWithMergePolicy);\n+    writerWithMergePolicy.commit();\n+\n+    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n+    assertEquals(1, mergedReader.leaves().size()); // Now we merge on commit\n+    mergedReader.close();\n+\n+    LineFileDocs lineFileDocs = new LineFileDocs(random());\n+    int docCount = atLeast(1000);\n+    AtomicInteger indexedDocs = new AtomicInteger(0);\n+    int numIndexingThreads = atLeast(2);\n+    CountDownLatch startingGun = new CountDownLatch(1);\n+    Collection<Thread> indexingThreads = new ArrayList<>();\n+    for (int i = 0; i < numIndexingThreads; i++) {\n+      Thread t = new Thread(() -> {\n+        try {\n+          while (indexedDocs.getAndIncrement() < docCount) {\n+            writerWithMergePolicy.addDocument(lineFileDocs.nextDoc());\n+            if (rarely()) {\n+              writerWithMergePolicy.commit();\n+            }\n+          }\n+        } catch (IOException e) {\n+          e.printStackTrace();\n+          fail();\n+        }\n+      });\n+      t.start();\n+      indexingThreads.add(t);\n+    }\n+    startingGun.countDown();\n+    for (Thread t : indexingThreads) {\n+      t.join();\n+    }\n+    writerWithMergePolicy.commit();\n+    assertEquals(1, writerWithMergePolicy.listOfSegmentCommitInfos().size());", "originalCommit": "f5bf1b6577ed866ec01486bcb928bdf8302d643d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0907f65a1e59647690d3a2c4d6964ff85ef80d44", "chunk": "diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy.java\nindex f085b4e0bc9..16549da273b 100644\n--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy.java\n+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy.java\n\n@@ -287,6 +287,7 @@ public class TestIndexWriterMergePolicy extends LuceneTestCase {\n \n   public void testMergeOnCommit() throws IOException, InterruptedException {\n     Directory dir = newDirectory();\n+\n     IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n         .setMergePolicy(NoMergePolicy.INSTANCE));\n     for (int i = 0; i < 5; i++) {\n"}}, {"oid": "0907f65a1e59647690d3a2c4d6964ff85ef80d44", "url": "https://github.com/apache/lucene-solr/commit/0907f65a1e59647690d3a2c4d6964ff85ef80d44", "message": "Refactoring and fix intermittent test failure\n\n1. Made some changes to the callback to update toCommit, leveraging\nSegmentInfos.applyMergeChanges.\n2. I realized that we'll never end up with 0 registered merges, because\nwe throw an exception if we fail to register a merge.\n3. Moved the IndexWriterEvents.beginMergeOnCommit notification to before\nwe call MergeScheduler.merge, since we may not be merging on another\nthread.\n4. There was an intermittent test failure due to randomness in the time\nit takes for merges to complete. Before doing the final commit, we wait\nfor pending merges to finish. We may still end up abandoning the final\nmerge, but we can detect that and assert that either the merge was\nabandoned (and we have > 1 segment) or we did merge down to 1 segment.", "committedDate": "2020-01-19T02:11:50Z", "type": "commit"}, {"oid": "bdbf425d561e7905f3f273b6558c2f9bae6cf8a5", "url": "https://github.com/apache/lucene-solr/commit/bdbf425d561e7905f3f273b6558c2f9bae6cf8a5", "message": "Fix typo", "committedDate": "2020-01-19T02:18:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAwODAwMg==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373008002", "bodyText": "Maybe also say that any merges still running after this time will still run to completion, so they are not wasted.", "author": "mikemccand", "createdAt": "2020-01-30T15:13:55Z", "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java", "diffHunk": "@@ -484,6 +487,23 @@ public IndexWriterConfig setCommitOnClose(boolean commitOnClose) {\n     return this;\n   }\n \n+  /**\n+   * Expert: sets the amount of time to wait for merges returned by MergePolicy.findCommitMerges(...).\n+   * If this time is reached, we proceed with the commit based on segments merged up to that point.", "originalCommit": "bdbf425d561e7905f3f273b6558c2f9bae6cf8a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyMDYzMg==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373720632", "bodyText": "Done", "author": "msfroh", "createdAt": "2020-01-31T22:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAwODAwMg=="}], "type": "inlineReview", "revised_code": {"commit": "4ae6df3b19999e012fcb72460bf12edc23a10427", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java\nindex ff2e489c445..80a63ea9933 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java\n\n@@ -490,6 +490,7 @@ public final class IndexWriterConfig extends LiveIndexWriterConfig {\n   /**\n    * Expert: sets the amount of time to wait for merges returned by MergePolicy.findCommitMerges(...).\n    * If this time is reached, we proceed with the commit based on segments merged up to that point.\n+   * The merges are not cancelled, and may still run to completion independent of the commit.\n    */\n   public IndexWriterConfig setMaxCommitMergeWaitSeconds(double maxCommitMergeWaitSeconds) {\n     this.maxCommitMergeWaitSeconds = maxCommitMergeWaitSeconds;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAwODkzNQ==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373008935", "bodyText": "This is no longer true?  We will just wrap up the commit w/ those merges that did finish, and let the still running merges finish to completion?", "author": "mikemccand", "createdAt": "2020-01-30T15:15:20Z", "path": "lucene/core/src/java/org/apache/lucene/index/LiveIndexWriterConfig.java", "diffHunk": "@@ -480,6 +488,22 @@ public String getSoftDeletesField() {\n     return softDeletesField;\n   }\n \n+  /**\n+   * Expert: return the amount of time to wait for merges returned by by MergePolicy.findCommitMerges(...).\n+   * If this time is reached, those merges will be aborted and we will wait again. If this time limit is reached again,", "originalCommit": "bdbf425d561e7905f3f273b6558c2f9bae6cf8a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyMDU5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373720599", "bodyText": "Fixed!", "author": "msfroh", "createdAt": "2020-01-31T22:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAwODkzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "4ae6df3b19999e012fcb72460bf12edc23a10427", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/LiveIndexWriterConfig.java b/lucene/core/src/java/org/apache/lucene/index/LiveIndexWriterConfig.java\nindex 5d611a2f51b..e8735af7745 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/LiveIndexWriterConfig.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/LiveIndexWriterConfig.java\n\n@@ -490,8 +490,8 @@ public class LiveIndexWriterConfig {\n \n   /**\n    * Expert: return the amount of time to wait for merges returned by by MergePolicy.findCommitMerges(...).\n-   * If this time is reached, those merges will be aborted and we will wait again. If this time limit is reached again,\n-   * we will abort the commit.\n+   * If this time is reached, we proceed with the commit based on segments merged up to that point.\n+   * The merges are not cancelled, and may still run to completion independent of the commit.\n    */\n   public double getMaxCommitMergeWaitSeconds() {\n     return maxCommitMergeWaitSeconds;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAwOTM5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373009396", "bodyText": "What is isMergingSegment here?", "author": "mikemccand", "createdAt": "2020-01-30T15:16:02Z", "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -526,6 +526,19 @@ public abstract MergeSpecification findForcedMerges(\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n \n+  /**\n+   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n+   *\n+   * Implementers of this method should use isMergingSegment to exclude any already-merging segments from the returned", "originalCommit": "bdbf425d561e7905f3f273b6558c2f9bae6cf8a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxODUzMw==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373718533", "bodyText": "Oops... that's from an earlier implementation, before I realized that MergeContext provides information on merging segments.", "author": "msfroh", "createdAt": "2020-01-31T22:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAwOTM5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4ae6df3b19999e012fcb72460bf12edc23a10427", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\nindex 355d4d4a4ce..daa5de625df 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\n\n@@ -529,8 +529,8 @@ public abstract class MergePolicy {\n   /**\n    * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n    *\n-   * Implementers of this method should use isMergingSegment to exclude any already-merging segments from the returned\n-   * {@link MergeSpecification}. If a segment already registered in a merge is returned, then the commit will fail.\n+   * If a returned {@link OneMerge} includes a segment already included in a registered merge, then the commit will fail.\n+   * Use {@link MergeContext#getMergingSegments()} to determine which segments are currently registered to merge.\n    *\n    * @param segmentInfos the total set of segments in the index (while preparing the commit)\n    * @param mergeContext the IndexWriter to find the merges on\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAxMDkxNA==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373010914", "bodyText": "Is this true?  Or will IW (silently) disregard that requested merge?", "author": "mikemccand", "createdAt": "2020-01-30T15:18:20Z", "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -526,6 +526,19 @@ public abstract MergeSpecification findForcedMerges(\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n \n+  /**\n+   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n+   *\n+   * Implementers of this method should use isMergingSegment to exclude any already-merging segments from the returned\n+   * {@link MergeSpecification}. If a segment already registered in a merge is returned, then the commit will fail.", "originalCommit": "bdbf425d561e7905f3f273b6558c2f9bae6cf8a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxODEwMQ==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373718101", "bodyText": "The code in this PR throws an exception if IW fails to register the merge:\nif (registerMerge(trackedMerge) == false) {\n  throw new IllegalStateException(\"MergePolicy \" + config.getMergePolicy().getClass() +\n      \" returned merging segments from findCommitMerges\");\n}\n\nI suppose we could silently disregard the merge if we remember to count down the latch for the merge that fails to register.\nWhat would be less surprising to users? Explosive failure if an invalid MergeSpecification is returned or letting the commit happen without trying to merge? I lean slightly toward explosive failure (with what I hope is a clear explanation), but I'm happy to write it either way.", "author": "msfroh", "createdAt": "2020-01-31T22:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAxMDkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczODQyNQ==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373738425", "bodyText": "OK I agree to explosive failure!  Less trappy.", "author": "mikemccand", "createdAt": "2020-02-01T00:19:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAxMDkxNA=="}], "type": "inlineReview", "revised_code": {"commit": "4ae6df3b19999e012fcb72460bf12edc23a10427", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\nindex 355d4d4a4ce..daa5de625df 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\n\n@@ -529,8 +529,8 @@ public abstract class MergePolicy {\n   /**\n    * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n    *\n-   * Implementers of this method should use isMergingSegment to exclude any already-merging segments from the returned\n-   * {@link MergeSpecification}. If a segment already registered in a merge is returned, then the commit will fail.\n+   * If a returned {@link OneMerge} includes a segment already included in a registered merge, then the commit will fail.\n+   * Use {@link MergeContext#getMergingSegments()} to determine which segments are currently registered to merge.\n    *\n    * @param segmentInfos the total set of segments in the index (while preparing the commit)\n    * @param mergeContext the IndexWriter to find the merges on\n"}}, {"oid": "4ae6df3b19999e012fcb72460bf12edc23a10427", "url": "https://github.com/apache/lucene-solr/commit/4ae6df3b19999e012fcb72460bf12edc23a10427", "message": "Fix/improve comments based on PR feedback", "committedDate": "2020-01-31T22:50:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczODc0NA==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373738744", "bodyText": "Can you add @lucene.experimental here?  That reserves the right to make breaking changes even on feature releases ...", "author": "mikemccand", "createdAt": "2020-02-01T00:21:44Z", "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterEvents.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+\n+package org.apache.lucene.index;\n+\n+/**\n+ * Callback interface to signal various actions taken by IndexWriter.\n+ */\n+public interface IndexWriterEvents {", "originalCommit": "4ae6df3b19999e012fcb72460bf12edc23a10427", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d149f0e75103160e16d6f98d052150024594d1ba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriterEvents.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriterEvents.java\nindex 02fd9761130..863939ef13e 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriterEvents.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriterEvents.java\n\n@@ -21,6 +21,8 @@ package org.apache.lucene.index;\n \n /**\n  * Callback interface to signal various actions taken by IndexWriter.\n+ *\n+ * @lucene.experimental\n  */\n public interface IndexWriterEvents {\n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczODgzOA==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373738838", "bodyText": "Can you say what exception will be thrown in that case (or add an @throws, below)?", "author": "mikemccand", "createdAt": "2020-02-01T00:22:28Z", "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -526,6 +526,19 @@ public abstract MergeSpecification findForcedMerges(\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n \n+  /**\n+   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n+   *\n+   * If a returned {@link OneMerge} includes a segment already included in a registered merge, then the commit will fail.", "originalCommit": "4ae6df3b19999e012fcb72460bf12edc23a10427", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d149f0e75103160e16d6f98d052150024594d1ba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\nindex daa5de625df..0bef6736941 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\n\n@@ -521,7 +521,7 @@ public abstract class MergePolicy {\n    * deletes from the index.\n    *  @param segmentInfos\n    *          the total set of segments in the index\n-   * @param mergeContext the IndexWriter to find the merges on\n+   * @param mergeContext the MergeContext to find the merges on\n    */\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczODk0NA==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373738944", "bodyText": "Hmm, maybe improve this (it's not an IndexWriter) to say the merge policy may use this to find already merging segments?", "author": "mikemccand", "createdAt": "2020-02-01T00:23:05Z", "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -526,6 +526,19 @@ public abstract MergeSpecification findForcedMerges(\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n \n+  /**\n+   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n+   *\n+   * If a returned {@link OneMerge} includes a segment already included in a registered merge, then the commit will fail.\n+   * Use {@link MergeContext#getMergingSegments()} to determine which segments are currently registered to merge.\n+   *\n+   * @param segmentInfos the total set of segments in the index (while preparing the commit)\n+   * @param mergeContext the IndexWriter to find the merges on", "originalCommit": "4ae6df3b19999e012fcb72460bf12edc23a10427", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d149f0e75103160e16d6f98d052150024594d1ba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\nindex daa5de625df..0bef6736941 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\n\n@@ -521,7 +521,7 @@ public abstract class MergePolicy {\n    * deletes from the index.\n    *  @param segmentInfos\n    *          the total set of segments in the index\n-   * @param mergeContext the IndexWriter to find the merges on\n+   * @param mergeContext the MergeContext to find the merges on\n    */\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczOTA4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373739081", "bodyText": "Can you describe a bit more?  E.g. explain that any merges returned here which then finish within the allotted time will be reflected in the commit, so that the number of segments in the commit point may be decreased?", "author": "mikemccand", "createdAt": "2020-02-01T00:23:57Z", "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -526,6 +526,19 @@ public abstract MergeSpecification findForcedMerges(\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n \n+  /**\n+   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.", "originalCommit": "4ae6df3b19999e012fcb72460bf12edc23a10427", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NTI4NA==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r374445284", "bodyText": "While updating the comments here, it occurred to me that if we want to leverage this same method in future to trigger a merge on NRT refresh, would it make sense to call it e.g. findFlushMerges or findFullFlushMerges instead?", "author": "msfroh", "createdAt": "2020-02-04T02:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczOTA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY5NzU0NA==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r374697544", "bodyText": "Good thinking!  +1 for findFullFlushMerges, to make it clear it's a FULL flush (commit or refresh) and not an ordinary flush e.g. when the in-memory segments are taking too much memory and some are flushed.\nAnd then I guess the method could look at MergeTrigger to differentiate whether it's a commit or a refresh?", "author": "mikemccand", "createdAt": "2020-02-04T14:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczOTA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAwOTc4Nw==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r375009787", "bodyText": "Renamed in latest commit and added a new MergeTrigger.\nPassing the MergeTrigger to the MergeScheduler got me thinking that it might be possible to raise the priority of these full-flush merges, though it would be easier to manage that in the call to registerMerge, which could insert them at the front of the pending merge queue. I think that's beyond the scope of this change, but it could make for an interesting follow-up.", "author": "msfroh", "createdAt": "2020-02-05T01:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczOTA4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d149f0e75103160e16d6f98d052150024594d1ba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\nindex daa5de625df..0bef6736941 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/MergePolicy.java\n\n@@ -521,7 +521,7 @@ public abstract class MergePolicy {\n    * deletes from the index.\n    *  @param segmentInfos\n    *          the total set of segments in the index\n-   * @param mergeContext the IndexWriter to find the merges on\n+   * @param mergeContext the MergeContext to find the merges on\n    */\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n"}}, {"oid": "d149f0e75103160e16d6f98d052150024594d1ba", "url": "https://github.com/apache/lucene-solr/commit/d149f0e75103160e16d6f98d052150024594d1ba", "message": "More comment improvements from PR feedback", "committedDate": "2020-02-04T02:23:09Z", "type": "commit"}, {"oid": "7b3c2c7203beed824cbdf111affe06cf3522bdeb", "url": "https://github.com/apache/lucene-solr/commit/7b3c2c7203beed824cbdf111affe06cf3522bdeb", "message": "Rename method and add new MergeTrigger\n\n1. Renamed findCommitMerges -> findFullFlushMerges.\n2. Added MergeTrigger.COMMIT, passed to findFullFlushMerges and to\n   MergeScheduler when merging on commit.", "committedDate": "2020-02-05T00:45:31Z", "type": "commit"}, {"oid": "c04cfa875be6cd91fe0af69168a23fd459831ed6", "url": "https://github.com/apache/lucene-solr/commit/c04cfa875be6cd91fe0af69168a23fd459831ed6", "message": "Update renamed method name in strings and comments", "committedDate": "2020-02-05T00:54:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc4NjgwNQ==", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r388786805", "bodyText": "I am not really happy with this interface. First and foremost it's only partially used in this PR. I also think it doesn't belong here but rather into a merge policy? I think IW and merge lifecycle should not be tightly coupled. Can we achieve the same with an interface a MP can provide to the IW rather than setting it on the IW config. A pull model should be used here instead IMO.", "author": "s1monw", "createdAt": "2020-03-06T09:10:03Z", "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterEvents.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+\n+package org.apache.lucene.index;\n+\n+/**\n+ * Callback interface to signal various actions taken by IndexWriter.\n+ *\n+ * @lucene.experimental\n+ */\n+public interface IndexWriterEvents {\n+  /**\n+   * A default implementation that ignores all events.\n+   */\n+  IndexWriterEvents NULL_EVENTS = new IndexWriterEvents() {\n+    @Override\n+    public void beginMergeOnCommit() { }\n+\n+    @Override\n+    public void finishMergeOnCommit() { }\n+\n+    @Override\n+    public void abandonedMergesOnCommit(int abandonedCount) { }\n+  };\n+\n+  /**\n+   * Signals the start of waiting for a merge on commit, returned from\n+   * {@link MergePolicy#findFullFlushMerges(MergeTrigger, SegmentInfos, MergePolicy.MergeContext)}.\n+   */\n+  void beginMergeOnCommit();", "originalCommit": "c04cfa875be6cd91fe0af69168a23fd459831ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}