{"pr_number": 1169, "pr_title": "LUCENE-9004: A minor feature and patch -- support deleting vector values and fix segments merging", "pr_createdAt": "2020-01-14T17:03:23Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1169", "timeline": [{"oid": "004136b0912c97027d52f645406c13cd4b0ce5bc", "url": "https://github.com/apache/lucene-solr/commit/004136b0912c97027d52f645406c13cd4b0ce5bc", "message": "add deletion and fix merge for hnsw", "committedDate": "2020-01-14T14:09:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkxNDMxNw==", "url": "https://github.com/apache/lucene-solr/pull/1169#discussion_r366914317", "bodyText": "You're right, this is needed for document deletion. A small correction: the condition should be mappedDocId == -1. (According to the Javadoc of the DocMap#get() method.)", "author": "mocobeta", "createdAt": "2020-01-15T14:46:01Z", "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene90/Lucene90KnnGraphWriter.java", "diffHunk": "@@ -216,8 +216,11 @@ private void mergeKnnGraph(FieldInfo mergeFieldInfo, final MergeState mergeState\n       int docid;\n       while ((docid = sub.nextDoc()) != NO_MORE_DOCS) {\n         int mappedDocId = docMap.get(docid);\n+        /// deleted document (not alive)\n+        if (mappedDocId < 0) {", "originalCommit": "004136b0912c97027d52f645406c13cd4b0ce5bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwNTY0Mg==", "url": "https://github.com/apache/lucene-solr/pull/1169#discussion_r367305642", "bodyText": "Thanks @mocobeta , I have corrected the condition for deleted docIds.", "author": "irvingzhang", "createdAt": "2020-01-16T09:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkxNDMxNw=="}], "type": "inlineReview", "revised_code": {"commit": "d5b7e05db7ab433149d76d60a15356bbad1a8c23", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene90/Lucene90KnnGraphWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene90/Lucene90KnnGraphWriter.java\nindex 841c18d234e..aa2a4fd7c42 100644\n--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene90/Lucene90KnnGraphWriter.java\n+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene90/Lucene90KnnGraphWriter.java\n\n@@ -217,7 +217,7 @@ public final class Lucene90KnnGraphWriter extends KnnGraphWriter {\n       while ((docid = sub.nextDoc()) != NO_MORE_DOCS) {\n         int mappedDocId = docMap.get(docid);\n         /// deleted document (not alive)\n-        if (mappedDocId < 0) {\n+        if (mappedDocId == -1) {\n           continue;\n         }\n         assert sub.values.docID() == docid;\n"}}, {"oid": "4d26e57944791ff2c1d42a8f712682418a90a53a", "url": "https://github.com/apache/lucene-solr/commit/4d26e57944791ff2c1d42a8f712682418a90a53a", "message": "migrate kmeans clustering", "committedDate": "2020-01-16T08:34:08Z", "type": "commit"}, {"oid": "87d18f4c882d5823d3de4f5b74c0a2cd2d2bd17a", "url": "https://github.com/apache/lucene-solr/commit/87d18f4c882d5823d3de4f5b74c0a2cd2d2bd17a", "message": "rollback - previous commits to the wrong branch", "committedDate": "2020-01-16T09:07:15Z", "type": "commit"}, {"oid": "d5b7e05db7ab433149d76d60a15356bbad1a8c23", "url": "https://github.com/apache/lucene-solr/commit/d5b7e05db7ab433149d76d60a15356bbad1a8c23", "message": "correct the if condition for deleted docs when merging", "committedDate": "2020-01-16T09:11:03Z", "type": "commit"}, {"oid": "1574d91c74241e853ad7af987ab161e6c1b7025d", "url": "https://github.com/apache/lucene-solr/commit/1574d91c74241e853ad7af987ab161e6c1b7025d", "message": "rename class names for deletion query and weight", "committedDate": "2020-01-16T09:53:28Z", "type": "commit"}, {"oid": "77b1b81b3cc6597b6d66cbcc5c781b2886f12584", "url": "https://github.com/apache/lucene-solr/commit/77b1b81b3cc6597b6d66cbcc5c781b2886f12584", "message": "minor refactoring for KnnExactDeletionFilter", "committedDate": "2020-01-16T09:58:19Z", "type": "commit"}, {"oid": "2a4e8217ac73118e983dc0f0e8f6c604226e9479", "url": "https://github.com/apache/lucene-solr/commit/2a4e8217ac73118e983dc0f0e8f6c604226e9479", "message": "fix typo", "committedDate": "2020-01-17T06:06:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyNDQ3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1169#discussion_r368224473", "bodyText": "Why do we need to include the word \"deletion\" in the Query name? If my understanding is correct this finds a set of documents that have exact values to the query vector, and does not concern what the user do with the query results. Additionally it seems slightly odd to me that the (public) Query subclass does not obey the naming convention (XXXQuery). I would prefer the name \"KnnExactVectorValueQuery\" or something like that here...\nIf you intend to use this Query class for special purpose (\"for deleting documents\"), I'd suggest you don't expose it as a public class but firstly keep it as a dedicated inner class within another class. Would it be possible?", "author": "mocobeta", "createdAt": "2020-01-18T12:30:13Z", "path": "lucene/core/src/java/org/apache/lucene/search/KnnExactDeletionCondition.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.io.IOException;\n+\n+/**\n+ * A query for deleting the exact values of the specified querying vector, used for\n+ * {@link org.apache.lucene.index.IndexWriter#deleteDocuments(Query...)}.\n+ */\n+public class KnnExactDeletionCondition extends KnnGraphQuery {", "originalCommit": "2a4e8217ac73118e983dc0f0e8f6c604226e9479", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzNTg5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1169#discussion_r368235896", "bodyText": "Yes, your understanding is correct and highly appreciated.\n\nThe class KnnExactVectorValueQuery (revised name) is originally designed for deleting/updating vectors by query. When we are going to delete some vector by its exact values, Lucene seems to retrieve the similar vectors and then delete all of them, which may not be the behavior we expect. The class KnnExactVectorValueWeight is the corresponding weight for KnnExactVectorValueQuery to filter the vectors that not exactly equal to the query vector in value. Therefore, the two classes are specially designed for deletion and updating. The results that KnnGraphQuery retrieved contains that retrieved by KnnExactVectorValueWeight, so there's any necessary to establish a new query (e.g. KnnExactVectorValueQuery) for ordinary query.\nI'm not pretty sure if there is any situation that we need to delete by query. So I moved both classes into my test case.\n\nNow, there isn't any new feature, just some minor bug fix.", "author": "irvingzhang", "createdAt": "2020-01-18T16:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyNDQ3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e7a4938ffb54e81bac805f3e0c57af5912d5eb07", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/search/KnnExactDeletionCondition.java b/lucene/core/src/java/org/apache/lucene/search/KnnExactDeletionCondition.java\ndeleted file mode 100644\nindex 2b22b724835..00000000000\n--- a/lucene/core/src/java/org/apache/lucene/search/KnnExactDeletionCondition.java\n+++ /dev/null\n\n@@ -1,45 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.lucene.search;\n-\n-import java.io.IOException;\n-\n-/**\n- * A query for deleting the exact values of the specified querying vector, used for\n- * {@link org.apache.lucene.index.IndexWriter#deleteDocuments(Query...)}.\n- */\n-public class KnnExactDeletionCondition extends KnnGraphQuery {\n-  /**\n-   * Creates a delete query for knn graph.\n-   * Note: only one in-set vector could be deleted.\n-   *\n-   * @param field            field name\n-   * @param queryVector      query vector. must has same number of dimensions to the indexed vectors\n-   * @param maxDelNumPerSeg  at most maxDelNumPerSeg docs will be deleted from each segment.\n-   */\n-  public KnnExactDeletionCondition(String field, float[] queryVector, int maxDelNumPerSeg) {\n-    super(field, queryVector, maxDelNumPerSeg);\n-  }\n-\n-  @Override\n-  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n-    KnnScoreWeight weight = new KnnExactDeletionFilter(this, boost, scoreMode, field, queryVector, ef);\n-    weight.setVisitedCounter(visitedCounter);\n-    return weight;\n-  }\n-}\n"}}, {"oid": "e7a4938ffb54e81bac805f3e0c57af5912d5eb07", "url": "https://github.com/apache/lucene-solr/commit/e7a4938ffb54e81bac805f3e0c57af5912d5eb07", "message": "move dedicated classes to test cases", "committedDate": "2020-01-18T16:32:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI4OTI0NA==", "url": "https://github.com/apache/lucene-solr/pull/1169#discussion_r368289244", "bodyText": "Thanks, it looks almost okay to me but the Weight and Query classes can be (and should be) static classes.\nIt would look like this:\npublic class TestKnnGraph extends LuceneTestCase {\n    ....\n    private static final class KnnExactVectorValueWeight extends ConstantScoreWeight {\n        ....\n    }\n\n    private static final class KnnExactVectorValueQuery extends Query {\n        ....\n    }\n\n    public void testDocsDeletionAndRecall() throws  Exception {\n        ....\n        Query query = new KnnExactVectorValueQuery(...);\n        ....\n    }\n    ....\n}\n\nPlease avoid non-static inner classes whenever you can do so, because they consume extra memory and object references ;)", "author": "mocobeta", "createdAt": "2020-01-19T12:15:18Z", "path": "lucene/core/src/test/org/apache/lucene/index/TestKnnGraph.java", "diffHunk": "@@ -92,7 +108,277 @@ public void testSingleDocRecall() throws  Exception {\n       iw.commit();\n       assertConsistentGraph(iw, values);\n \n-      assertRecall(dir, 0, values[0]);\n+      assertRecall(dir, 1, values[0]);\n+    }\n+  }\n+\n+  public void testDocsDeletionAndRecall() throws  Exception {\n+    /**\n+     * {@code KnnExactVectorValueWeight} applies in-set (i.e. the query vector is exactly in the index)\n+     * deletion strategy to filter all unmatched results searched by {@link org.apache.lucene.search.KnnGraphQuery.KnnExactVectorValueQuery},\n+     * and deletes at most ef*segmentCnt vectors that are the same to the specified queryVector.\n+     */\n+    final class KnnExactVectorValueWeight extends ConstantScoreWeight {", "originalCommit": "e7a4938ffb54e81bac805f3e0c57af5912d5eb07", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "87cf6a4f8b26e9845166e55748e8df63bf276400", "chunk": "diff --git a/lucene/core/src/test/org/apache/lucene/index/TestKnnGraph.java b/lucene/core/src/test/org/apache/lucene/index/TestKnnGraph.java\nindex 01d6ed67b66..e6d7e88163b 100644\n--- a/lucene/core/src/test/org/apache/lucene/index/TestKnnGraph.java\n+++ b/lucene/core/src/test/org/apache/lucene/index/TestKnnGraph.java\n\n@@ -113,238 +113,6 @@ public class TestKnnGraph extends LuceneTestCase {\n   }\n \n   public void testDocsDeletionAndRecall() throws  Exception {\n-    /**\n-     * {@code KnnExactVectorValueWeight} applies in-set (i.e. the query vector is exactly in the index)\n-     * deletion strategy to filter all unmatched results searched by {@link org.apache.lucene.search.KnnGraphQuery.KnnExactVectorValueQuery},\n-     * and deletes at most ef*segmentCnt vectors that are the same to the specified queryVector.\n-     */\n-    final class KnnExactVectorValueWeight extends ConstantScoreWeight {\n-      private final String field;\n-      private final ScoreMode scoreMode;\n-      private final float[] queryVector;\n-      private final int ef;\n-\n-      KnnExactVectorValueWeight(Query query, float score, ScoreMode scoreMode, String field, float[] queryVector, int ef) {\n-        super(query, score);\n-        this.field = field;\n-        this.scoreMode = scoreMode;\n-        this.queryVector = queryVector;\n-        this.ef = ef;\n-      }\n-\n-      /**\n-       * Returns a {@link Scorer} which can iterate in order over all matching\n-       * documents and assign them a score.\n-       * <p>\n-       * <b>NOTE:</b> null can be returned if no documents will be scored by this\n-       * query.\n-       * <p>\n-       * <b>NOTE</b>: The returned {@link Scorer} does not have\n-       * {@link LeafReader#getLiveDocs()} applied, they need to be checked on top.\n-       *\n-       * @param context the {@link LeafReaderContext} for which to return the {@link Scorer}.\n-       * @return a {@link Scorer} which scores documents in/out-of order.\n-       * @throws IOException if there is a low-level I/O error\n-       */\n-      @Override\n-      public Scorer scorer(LeafReaderContext context) throws IOException {\n-        ScorerSupplier supplier = scorerSupplier(context);\n-        if (supplier == null) {\n-          return null;\n-        }\n-        return supplier.get(Long.MAX_VALUE);\n-      }\n-\n-      @Override\n-      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n-        FieldInfo fi = context.reader().getFieldInfos().fieldInfo(field);\n-        int numDimensions = fi.getVectorNumDimensions();\n-        if (numDimensions != queryVector.length) {\n-          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with dimensions=\" + numDimensions +\n-              \"; this is incompatible with query dimensions=\" + queryVector.length);\n-        }\n-\n-        final HNSWGraphReader hnswReader = new HNSWGraphReader(field, context);\n-        final VectorValues vectorValues = context.reader().getVectorValues(field);\n-        if (vectorValues == null) {\n-          // No docs in this segment/field indexed any vector values\n-          return null;\n-        }\n-\n-        final Weight weight = this;\n-        return new ScorerSupplier() {\n-          @Override\n-          public Scorer get(long leadCost) throws IOException {\n-            final Neighbors neighbors = hnswReader.searchNeighbors(queryVector, ef, vectorValues);\n-\n-            if (neighbors.size() > 0) {\n-              Neighbor top = neighbors.top();\n-              if (top.distance() > 0) {\n-                neighbors.clear();\n-              } else {\n-                final List<Neighbor> toDeleteNeighbors = new ArrayList<>(neighbors.size());\n-                for (Neighbor neighbor : neighbors) {\n-                  if (neighbor.distance() == 0) {\n-                    toDeleteNeighbors.add(neighbor);\n-                  } else {\n-                    break;\n-                  }\n-                }\n-\n-                neighbors.clear();\n-\n-                toDeleteNeighbors.forEach(neighbors::add);\n-              }\n-            }\n-\n-            return new Scorer(weight) {\n-\n-              int doc = -1;\n-              int size = neighbors.size();\n-              int offset = 0;\n-\n-              @Override\n-              public DocIdSetIterator iterator() {\n-                return new DocIdSetIterator() {\n-                  @Override\n-                  public int docID() {\n-                    return doc;\n-                  }\n-\n-                  @Override\n-                  public int nextDoc() {\n-                    return advance(offset);\n-                  }\n-\n-                  @Override\n-                  public int advance(int target) {\n-                    if (target > size || neighbors.size() == 0) {\n-                      doc = NO_MORE_DOCS;\n-                    } else {\n-                      while (offset < target) {\n-                        neighbors.pop();\n-                        offset++;\n-                      }\n-                      Neighbor next = neighbors.pop();\n-                      offset++;\n-                      if (next == null) {\n-                        doc = NO_MORE_DOCS;\n-                      } else {\n-                        doc = next.docId();\n-                      }\n-                    }\n-                    return doc;\n-                  }\n-\n-                  @Override\n-                  public long cost() {\n-                    return size;\n-                  }\n-                };\n-              }\n-\n-              @Override\n-              public float getMaxScore(int upTo) {\n-                return Float.POSITIVE_INFINITY;\n-              }\n-\n-              @Override\n-              public float score() {\n-                return 0.0f;\n-              }\n-\n-              @Override\n-              public int docID() {\n-                return doc;\n-              }\n-            };\n-          }\n-\n-          @Override\n-          public long cost() {\n-            return ef;\n-          }\n-        };\n-      }\n-\n-      /**\n-       * @param ctx\n-       * @return {@code true} if the object can be cached against a given leaf\n-       */\n-      @Override\n-      public boolean isCacheable(LeafReaderContext ctx) {\n-        return false;\n-      }\n-    }\n-\n-    final class KnnExactVectorValueQuery extends Query {\n-      protected final String field;\n-      protected final float[] queryVector;\n-      protected final int ef;\n-\n-      public KnnExactVectorValueQuery(String field, float[] queryVector, int maxDelNumPerSeg) {\n-        this.field = field;\n-        this.queryVector = queryVector;\n-        this.ef = maxDelNumPerSeg;\n-      }\n-\n-      /**\n-       * Prints a query to a string, with <code>field</code> assumed to be the\n-       * default field and omitted.\n-       *\n-       * @param field\n-       */\n-      @Override\n-      public String toString(String field) {\n-        return null;\n-      }\n-\n-      @Override\n-      public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) {\n-        Weight weight = new KnnExactVectorValueWeight(this, boost, scoreMode, field, queryVector, ef);\n-        return weight;\n-      }\n-\n-      /**\n-       * Recurse through the query tree, visiting any child queries\n-       *\n-       * @param visitor a QueryVisitor to be called by each query in the tree\n-       */\n-      @Override\n-      public void visit(QueryVisitor visitor) {\n-\n-      }\n-\n-      /**\n-       * Override and implement query instance equivalence properly in a subclass.\n-       * This is required so that {@link QueryCache} works properly.\n-       * <p>\n-       * Typically a query will be equal to another only if it's an instance of\n-       * the same class and its document-filtering properties are identical that other\n-       * instance. Utility methods are provided for certain repetitive code.\n-       *\n-       * @param obj\n-       * @see #sameClassAs(Object)\n-       * @see #classHash()\n-       */\n-      @Override\n-      public boolean equals(Object obj) {\n-        /// TODO\n-        return false;\n-      }\n-\n-      /**\n-       * Override and implement query hash code properly in a subclass.\n-       * This is required so that {@link QueryCache} works properly.\n-       *\n-       * @see #equals(Object)\n-       */\n-      @Override\n-      public int hashCode() {\n-        return 0;\n-      }\n-    }\n-\n     try (Directory dir = newDirectory();\n          IndexWriter iw = new IndexWriter(dir, newIndexWriterConfig(null)\n              .setMaxBufferedDocs(2).setCodec(Codec.forName(\"Lucene90\")))) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI4OTMyNQ==", "url": "https://github.com/apache/lucene-solr/pull/1169#discussion_r368289325", "bodyText": "Can you please remove those unused imports?", "author": "mocobeta", "createdAt": "2020-01-19T12:16:37Z", "path": "lucene/core/src/java/org/apache/lucene/search/KnnScoreWeight.java", "diffHunk": "@@ -18,6 +18,8 @@\n package org.apache.lucene.search;\n \n import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;", "originalCommit": "e7a4938ffb54e81bac805f3e0c57af5912d5eb07", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4a26a9cee6be11cd56a10b9c2f4e0c9d56a34f27", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/search/KnnScoreWeight.java b/lucene/core/src/java/org/apache/lucene/search/KnnScoreWeight.java\nindex c4dd1e5d81b..a3847adae35 100644\n--- a/lucene/core/src/java/org/apache/lucene/search/KnnScoreWeight.java\n+++ b/lucene/core/src/java/org/apache/lucene/search/KnnScoreWeight.java\n\n@@ -18,8 +18,6 @@\n package org.apache.lucene.search;\n \n import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n \n import org.apache.lucene.index.FieldInfo;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMDg1NQ==", "url": "https://github.com/apache/lucene-solr/pull/1169#discussion_r368330855", "bodyText": "You are -- finding exact matches to the input vector, right? I don't understand what this has to do with deletion. I'm also unclear why we want to have an exact match query in the first place. What problem is it solving that we could not solve with a hashmap lookup?  And ... it is implemented here in a test file. Is this supporting testing in some way? Thanks, I feel I must be missing some essential thing here...", "author": "msokolov", "createdAt": "2020-01-19T23:05:45Z", "path": "lucene/core/src/test/org/apache/lucene/index/TestKnnGraph.java", "diffHunk": "@@ -92,7 +108,277 @@ public void testSingleDocRecall() throws  Exception {\n       iw.commit();\n       assertConsistentGraph(iw, values);\n \n-      assertRecall(dir, 0, values[0]);\n+      assertRecall(dir, 1, values[0]);\n+    }\n+  }\n+\n+  public void testDocsDeletionAndRecall() throws  Exception {\n+    /**\n+     * {@code KnnExactVectorValueWeight} applies in-set (i.e. the query vector is exactly in the index)\n+     * deletion strategy to filter all unmatched results searched by {@link org.apache.lucene.search.KnnGraphQuery.KnnExactVectorValueQuery},\n+     * and deletes at most ef*segmentCnt vectors that are the same to the specified queryVector.\n+     */\n+    final class KnnExactVectorValueWeight extends ConstantScoreWeight {\n+      private final String field;\n+      private final ScoreMode scoreMode;\n+      private final float[] queryVector;\n+      private final int ef;\n+\n+      KnnExactVectorValueWeight(Query query, float score, ScoreMode scoreMode, String field, float[] queryVector, int ef) {\n+        super(query, score);\n+        this.field = field;\n+        this.scoreMode = scoreMode;\n+        this.queryVector = queryVector;\n+        this.ef = ef;\n+      }\n+\n+      /**\n+       * Returns a {@link Scorer} which can iterate in order over all matching\n+       * documents and assign them a score.\n+       * <p>\n+       * <b>NOTE:</b> null can be returned if no documents will be scored by this\n+       * query.\n+       * <p>\n+       * <b>NOTE</b>: The returned {@link Scorer} does not have\n+       * {@link LeafReader#getLiveDocs()} applied, they need to be checked on top.\n+       *\n+       * @param context the {@link LeafReaderContext} for which to return the {@link Scorer}.\n+       * @return a {@link Scorer} which scores documents in/out-of order.\n+       * @throws IOException if there is a low-level I/O error\n+       */\n+      @Override\n+      public Scorer scorer(LeafReaderContext context) throws IOException {\n+        ScorerSupplier supplier = scorerSupplier(context);\n+        if (supplier == null) {\n+          return null;\n+        }\n+        return supplier.get(Long.MAX_VALUE);\n+      }\n+\n+      @Override\n+      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n+        FieldInfo fi = context.reader().getFieldInfos().fieldInfo(field);\n+        int numDimensions = fi.getVectorNumDimensions();\n+        if (numDimensions != queryVector.length) {\n+          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with dimensions=\" + numDimensions +\n+              \"; this is incompatible with query dimensions=\" + queryVector.length);\n+        }\n+\n+        final HNSWGraphReader hnswReader = new HNSWGraphReader(field, context);\n+        final VectorValues vectorValues = context.reader().getVectorValues(field);\n+        if (vectorValues == null) {\n+          // No docs in this segment/field indexed any vector values\n+          return null;\n+        }\n+\n+        final Weight weight = this;\n+        return new ScorerSupplier() {\n+          @Override\n+          public Scorer get(long leadCost) throws IOException {\n+            final Neighbors neighbors = hnswReader.searchNeighbors(queryVector, ef, vectorValues);\n+\n+            if (neighbors.size() > 0) {\n+              Neighbor top = neighbors.top();\n+              if (top.distance() > 0) {\n+                neighbors.clear();\n+              } else {\n+                final List<Neighbor> toDeleteNeighbors = new ArrayList<>(neighbors.size());", "originalCommit": "e7a4938ffb54e81bac805f3e0c57af5912d5eb07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM0OTA0NA==", "url": "https://github.com/apache/lucene-solr/pull/1169#discussion_r368349044", "bodyText": "Yes, and thanks.\nI hope to test some cases where segments contain deleted vectors. The classes KnnExactVectorValueQuery and KnnExactVectorValueWeight are added because I expect the deleted vector values are deterministic, making the assertions meet in any execution.\nThe two classes are just used for my test case, so I put them in the test file.", "author": "irvingzhang", "createdAt": "2020-01-20T02:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMDg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwOTAzNg==", "url": "https://github.com/apache/lucene-solr/pull/1169#discussion_r370709036", "bodyText": "I think I'm having trouble seeing where this is being used: maybe I just don't understand how to do PRs on github and I'm missing it, but have you posted a test that uses this query?", "author": "msokolov", "createdAt": "2020-01-24T15:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMDg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "87cf6a4f8b26e9845166e55748e8df63bf276400", "chunk": "diff --git a/lucene/core/src/test/org/apache/lucene/index/TestKnnGraph.java b/lucene/core/src/test/org/apache/lucene/index/TestKnnGraph.java\nindex 01d6ed67b66..e6d7e88163b 100644\n--- a/lucene/core/src/test/org/apache/lucene/index/TestKnnGraph.java\n+++ b/lucene/core/src/test/org/apache/lucene/index/TestKnnGraph.java\n\n@@ -113,238 +113,6 @@ public class TestKnnGraph extends LuceneTestCase {\n   }\n \n   public void testDocsDeletionAndRecall() throws  Exception {\n-    /**\n-     * {@code KnnExactVectorValueWeight} applies in-set (i.e. the query vector is exactly in the index)\n-     * deletion strategy to filter all unmatched results searched by {@link org.apache.lucene.search.KnnGraphQuery.KnnExactVectorValueQuery},\n-     * and deletes at most ef*segmentCnt vectors that are the same to the specified queryVector.\n-     */\n-    final class KnnExactVectorValueWeight extends ConstantScoreWeight {\n-      private final String field;\n-      private final ScoreMode scoreMode;\n-      private final float[] queryVector;\n-      private final int ef;\n-\n-      KnnExactVectorValueWeight(Query query, float score, ScoreMode scoreMode, String field, float[] queryVector, int ef) {\n-        super(query, score);\n-        this.field = field;\n-        this.scoreMode = scoreMode;\n-        this.queryVector = queryVector;\n-        this.ef = ef;\n-      }\n-\n-      /**\n-       * Returns a {@link Scorer} which can iterate in order over all matching\n-       * documents and assign them a score.\n-       * <p>\n-       * <b>NOTE:</b> null can be returned if no documents will be scored by this\n-       * query.\n-       * <p>\n-       * <b>NOTE</b>: The returned {@link Scorer} does not have\n-       * {@link LeafReader#getLiveDocs()} applied, they need to be checked on top.\n-       *\n-       * @param context the {@link LeafReaderContext} for which to return the {@link Scorer}.\n-       * @return a {@link Scorer} which scores documents in/out-of order.\n-       * @throws IOException if there is a low-level I/O error\n-       */\n-      @Override\n-      public Scorer scorer(LeafReaderContext context) throws IOException {\n-        ScorerSupplier supplier = scorerSupplier(context);\n-        if (supplier == null) {\n-          return null;\n-        }\n-        return supplier.get(Long.MAX_VALUE);\n-      }\n-\n-      @Override\n-      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n-        FieldInfo fi = context.reader().getFieldInfos().fieldInfo(field);\n-        int numDimensions = fi.getVectorNumDimensions();\n-        if (numDimensions != queryVector.length) {\n-          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with dimensions=\" + numDimensions +\n-              \"; this is incompatible with query dimensions=\" + queryVector.length);\n-        }\n-\n-        final HNSWGraphReader hnswReader = new HNSWGraphReader(field, context);\n-        final VectorValues vectorValues = context.reader().getVectorValues(field);\n-        if (vectorValues == null) {\n-          // No docs in this segment/field indexed any vector values\n-          return null;\n-        }\n-\n-        final Weight weight = this;\n-        return new ScorerSupplier() {\n-          @Override\n-          public Scorer get(long leadCost) throws IOException {\n-            final Neighbors neighbors = hnswReader.searchNeighbors(queryVector, ef, vectorValues);\n-\n-            if (neighbors.size() > 0) {\n-              Neighbor top = neighbors.top();\n-              if (top.distance() > 0) {\n-                neighbors.clear();\n-              } else {\n-                final List<Neighbor> toDeleteNeighbors = new ArrayList<>(neighbors.size());\n-                for (Neighbor neighbor : neighbors) {\n-                  if (neighbor.distance() == 0) {\n-                    toDeleteNeighbors.add(neighbor);\n-                  } else {\n-                    break;\n-                  }\n-                }\n-\n-                neighbors.clear();\n-\n-                toDeleteNeighbors.forEach(neighbors::add);\n-              }\n-            }\n-\n-            return new Scorer(weight) {\n-\n-              int doc = -1;\n-              int size = neighbors.size();\n-              int offset = 0;\n-\n-              @Override\n-              public DocIdSetIterator iterator() {\n-                return new DocIdSetIterator() {\n-                  @Override\n-                  public int docID() {\n-                    return doc;\n-                  }\n-\n-                  @Override\n-                  public int nextDoc() {\n-                    return advance(offset);\n-                  }\n-\n-                  @Override\n-                  public int advance(int target) {\n-                    if (target > size || neighbors.size() == 0) {\n-                      doc = NO_MORE_DOCS;\n-                    } else {\n-                      while (offset < target) {\n-                        neighbors.pop();\n-                        offset++;\n-                      }\n-                      Neighbor next = neighbors.pop();\n-                      offset++;\n-                      if (next == null) {\n-                        doc = NO_MORE_DOCS;\n-                      } else {\n-                        doc = next.docId();\n-                      }\n-                    }\n-                    return doc;\n-                  }\n-\n-                  @Override\n-                  public long cost() {\n-                    return size;\n-                  }\n-                };\n-              }\n-\n-              @Override\n-              public float getMaxScore(int upTo) {\n-                return Float.POSITIVE_INFINITY;\n-              }\n-\n-              @Override\n-              public float score() {\n-                return 0.0f;\n-              }\n-\n-              @Override\n-              public int docID() {\n-                return doc;\n-              }\n-            };\n-          }\n-\n-          @Override\n-          public long cost() {\n-            return ef;\n-          }\n-        };\n-      }\n-\n-      /**\n-       * @param ctx\n-       * @return {@code true} if the object can be cached against a given leaf\n-       */\n-      @Override\n-      public boolean isCacheable(LeafReaderContext ctx) {\n-        return false;\n-      }\n-    }\n-\n-    final class KnnExactVectorValueQuery extends Query {\n-      protected final String field;\n-      protected final float[] queryVector;\n-      protected final int ef;\n-\n-      public KnnExactVectorValueQuery(String field, float[] queryVector, int maxDelNumPerSeg) {\n-        this.field = field;\n-        this.queryVector = queryVector;\n-        this.ef = maxDelNumPerSeg;\n-      }\n-\n-      /**\n-       * Prints a query to a string, with <code>field</code> assumed to be the\n-       * default field and omitted.\n-       *\n-       * @param field\n-       */\n-      @Override\n-      public String toString(String field) {\n-        return null;\n-      }\n-\n-      @Override\n-      public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) {\n-        Weight weight = new KnnExactVectorValueWeight(this, boost, scoreMode, field, queryVector, ef);\n-        return weight;\n-      }\n-\n-      /**\n-       * Recurse through the query tree, visiting any child queries\n-       *\n-       * @param visitor a QueryVisitor to be called by each query in the tree\n-       */\n-      @Override\n-      public void visit(QueryVisitor visitor) {\n-\n-      }\n-\n-      /**\n-       * Override and implement query instance equivalence properly in a subclass.\n-       * This is required so that {@link QueryCache} works properly.\n-       * <p>\n-       * Typically a query will be equal to another only if it's an instance of\n-       * the same class and its document-filtering properties are identical that other\n-       * instance. Utility methods are provided for certain repetitive code.\n-       *\n-       * @param obj\n-       * @see #sameClassAs(Object)\n-       * @see #classHash()\n-       */\n-      @Override\n-      public boolean equals(Object obj) {\n-        /// TODO\n-        return false;\n-      }\n-\n-      /**\n-       * Override and implement query hash code properly in a subclass.\n-       * This is required so that {@link QueryCache} works properly.\n-       *\n-       * @see #equals(Object)\n-       */\n-      @Override\n-      public int hashCode() {\n-        return 0;\n-      }\n-    }\n-\n     try (Directory dir = newDirectory();\n          IndexWriter iw = new IndexWriter(dir, newIndexWriterConfig(null)\n              .setMaxBufferedDocs(2).setCodec(Codec.forName(\"Lucene90\")))) {\n"}}, {"oid": "87cf6a4f8b26e9845166e55748e8df63bf276400", "url": "https://github.com/apache/lucene-solr/commit/87cf6a4f8b26e9845166e55748e8df63bf276400", "message": "move KnnExactVectorValueQuery and KnnExactVectorValueWeight from method nested classes to inner classes", "committedDate": "2020-01-20T02:07:52Z", "type": "commit"}, {"oid": "4a26a9cee6be11cd56a10b9c2f4e0c9d56a34f27", "url": "https://github.com/apache/lucene-solr/commit/4a26a9cee6be11cd56a10b9c2f4e0c9d56a34f27", "message": "remove unused imports", "committedDate": "2020-01-20T02:10:01Z", "type": "commit"}]}