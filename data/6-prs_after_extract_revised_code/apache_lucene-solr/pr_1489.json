{"pr_number": 1489, "pr_title": "Lucene-9336: RegEx querying - add support for Java\u2019s predefined character classes like \\d for digits", "pr_createdAt": "2020-05-06T10:38:38Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1489", "timeline": [{"oid": "161affefb79c96fa87aa337a06826490e9462e49", "url": "https://github.com/apache/lucene-solr/commit/161affefb79c96fa87aa337a06826490e9462e49", "message": "Add support for Java\u2019s predefined character classes like \\d for digits", "committedDate": "2020-05-06T11:14:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYzMzI0OA==", "url": "https://github.com/apache/lucene-solr/pull/1489#discussion_r422633248", "bodyText": "I think these tests should be in TestRegExp rather than in TestRegexpQuery?", "author": "romseygeek", "createdAt": "2020-05-10T11:45:24Z", "path": "lucene/core/src/test/org/apache/lucene/search/TestRegexpQuery.java", "diffHunk": "@@ -115,6 +145,128 @@ public Automaton getAutomaton(String name) {\n     assertEquals(1, searcher.search(query, 5).totalHits.value);\n   }\n   \n+  public void testCoreJavaParity() {", "originalCommit": "f7bacdad4b204d393eba15525897cb40be0836d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97618754e50e2deacfd88cc25a1de3a0d152a1a9", "chunk": "diff --git a/lucene/core/src/test/org/apache/lucene/search/TestRegexpQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestRegexpQuery.java\nindex bb8cc813e9a..d760a4a1680 100644\n--- a/lucene/core/src/test/org/apache/lucene/search/TestRegexpQuery.java\n+++ b/lucene/core/src/test/org/apache/lucene/search/TestRegexpQuery.java\n\n@@ -145,128 +141,6 @@ public class TestRegexpQuery extends LuceneTestCase {\n     assertEquals(1, searcher.search(query, 5).totalHits.value);\n   }\n   \n-  public void testCoreJavaParity() {\n-    // Generate random doc values and random regular expressions\n-    // and check for same matching behaviour as Java's Pattern class.\n-    for (int i = 0; i < 1000; i++) {\n-      checkRandomExpression(randomDocValue(1 + random().nextInt(30)));\n-    }        \n-  }\n-\n-  static String randomDocValue(int minLength) {\n-    String charPalette = \"AAAaaaBbbCccc123456 \\t\";\n-    StringBuilder sb = new StringBuilder();\n-    for (int i = 0; i < minLength; i++) {\n-      sb.append(charPalette.charAt(randomInt(charPalette.length() - 1)));\n-    }\n-    return sb.toString();\n-  }\n-\n-  private static int randomInt(int bound) {\n-    return bound == 0 ? 0 : random().nextInt(bound);\n-  }\n-\n-  protected String checkRandomExpression(String docValue) {\n-    // Generate and test a random regular expression which should match the given docValue\n-    StringBuilder result = new StringBuilder();\n-    // Pick a part of the string to change\n-    int substitutionPoint = randomInt(docValue.length() - 1);\n-    int substitutionLength = 1 + randomInt(Math.min(10, docValue.length() - substitutionPoint));\n-\n-    // Add any head to the result, unchanged\n-    if (substitutionPoint > 0) {\n-      result.append(docValue.substring(0, substitutionPoint));\n-    }\n-\n-    // Modify the middle...\n-    String replacementPart = docValue.substring(substitutionPoint, substitutionPoint + substitutionLength);\n-    int mutation = random().nextInt(13);\n-    switch (mutation) {\n-      case 0:\n-        // OR with random alpha of same length\n-        result.append(\"(\" + replacementPart + \"|d\" + randomDocValue(replacementPart.length()) + \")\");\n-        break;\n-      case 1:\n-        // OR with non-existant value\n-        result.append(\"(\" + replacementPart + \"|doesnotexist)\");\n-        break;\n-      case 2:\n-        // OR with another randomised regex (used to create nested levels of expression).\n-        result.append(\"(\" + checkRandomExpression(replacementPart) + \"|doesnotexist)\");\n-        break;\n-      case 3:\n-        // Star-replace all ab sequences.\n-        result.append(replacementPart.replaceAll(\"ab\", \".*\"));\n-        break;\n-      case 4:\n-        // .-replace all b chars\n-        result.append(replacementPart.replaceAll(\"b\", \".\"));\n-        break;\n-      case 5:\n-        // length-limited stars {1,2}\n-        result.append(\".{1,\" + replacementPart.length() + \"}\");\n-        break;\n-      case 6:\n-        // replace all chars with .\n-        result.append(replacementPart.replaceAll(\".\", \".\"));\n-        break;\n-      case 7:\n-        // OR with uppercase chars eg [aA] (many of these sorts of expression in the wild..\n-        char[] chars = replacementPart.toCharArray();\n-        for (char c : chars) {\n-          result.append(\"[\" + c + Character.toUpperCase(c) + \"]\");\n-        }\n-        break;\n-      case 8:\n-        // NOT a character - replace all b's with \"not a\"\n-        result.append(replacementPart.replaceAll(\"b\", \"[^a]\"));\n-        break;\n-      case 9:\n-        // Make whole part repeatable 1 or more times\n-        result.append(\"(\" + replacementPart + \")+\");\n-        break;\n-      case 10:\n-        // Make whole part repeatable 0 or more times\n-        result.append(\"(\" + replacementPart + \")?\");\n-        break;\n-      case 11:\n-        // Make any digits replaced by character class\n-        result.append(replacementPart.replaceAll(\"\\\\d\", \"\\\\\\\\d\"));\n-        break;\n-      case 12:\n-        // Make any whitespace chars replaced by not word class\n-        result.append(replacementPart.replaceAll(\"\\\\s\", \"\\\\\\\\W\"));\n-        break;\n-      case 13:\n-        // Make any whitespace chars replace by whitespace class\n-        result.append(replacementPart.replaceAll(\"\\\\s\", \"\\\\\\\\s\"));\n-        break;\n-      default:\n-        break;\n-    }\n-    // add any remaining tail, unchanged\n-    if (substitutionPoint + substitutionLength <= docValue.length() - 1) {\n-      result.append(docValue.substring(substitutionPoint + substitutionLength));\n-    }\n-\n-    String regexPattern = result.toString();\n-    // Assert our randomly generated regex actually matches the provided raw input using java's expression matcher\n-    Pattern pattern = Pattern.compile(regexPattern);\n-    Matcher matcher = pattern.matcher(docValue);\n-    assertTrue(\"Java regex \" + regexPattern + \" did not match doc value \" + docValue, matcher.matches());\n-\n-    RegExp regex = new RegExp(regexPattern);\n-    Automaton automaton = regex.toAutomaton();\n-    ByteRunAutomaton bytesMatcher = new ByteRunAutomaton(automaton);\n-    BytesRef br = new BytesRef(docValue);\n-    assertTrue(\n-        \"[\" + regexPattern + \"]should match [\" + docValue + \"]\" + substitutionPoint + \"-\" + substitutionLength + \"/\"\n-            + docValue.length(),\n-        bytesMatcher.run(br.bytes, br.offset, br.length)\n-    );\n-    return regexPattern;\n-  }\n-  \n   /**\n    * Test a corner case for backtracking: In this case the term dictionary has\n    * 493432 followed by 49344. When backtracking from 49343... to 4934, it's\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5OTU2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1489#discussion_r423999563", "bodyText": "Can you add the javadocs for this in the class definition ?", "author": "jimczi", "createdAt": "2020-05-12T20:03:00Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java", "diffHunk": "@@ -1101,10 +1116,51 @@ final RegExp parseCharClasses() throws IllegalArgumentException {\n   }\n   \n   final RegExp parseCharClass() throws IllegalArgumentException {\n+    RegExp predefinedExp = matchPredefinedCharacterClass();\n+    if (predefinedExp != null) {\n+      return predefinedExp;\n+    }\n+        \n     int c = parseCharExp();\n     if (match('-')) return makeCharRange(c, parseCharExp());\n     else return makeChar(c);\n   }\n+\n+  RegExp expandPredefined() {\n+    //See https://docs.oracle.com/javase/tutorial/essential/regex/pre_char_classes.html", "originalCommit": "693ae6ce762877f28097e5c2cc89fcb4053a5ba4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97618754e50e2deacfd88cc25a1de3a0d152a1a9", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java b/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java\nindex 3f5624a1875..d0445026e9c 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java\n\n@@ -1153,7 +1202,7 @@ public class RegExp {\n     if (match('\\\\')) {\n       if (peek(\"dDwWsS\")) {\n         RegExp re =new RegExp();\n-        re.kind = Kind.REGEXP_SHORTHAND;\n+        re.kind = Kind.REGEXP_PRE_CLASS;\n         re.from = next();\n         return re;\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwMDA5Nw==", "url": "https://github.com/apache/lucene-solr/pull/1489#discussion_r424000097", "bodyText": "Maybe rename to REGEXP_PRE_CLASS ?", "author": "jimczi", "createdAt": "2020-05-12T20:04:00Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java", "diffHunk": "@@ -317,7 +317,8 @@\n public class RegExp {\n   \n   enum Kind {\n-    REGEXP_UNION, REGEXP_CONCATENATION, REGEXP_INTERSECTION, REGEXP_OPTIONAL, REGEXP_REPEAT, REGEXP_REPEAT_MIN, REGEXP_REPEAT_MINMAX, REGEXP_COMPLEMENT, REGEXP_CHAR, REGEXP_CHAR_RANGE, REGEXP_ANYCHAR, REGEXP_EMPTY, REGEXP_STRING, REGEXP_ANYSTRING, REGEXP_AUTOMATON, REGEXP_INTERVAL\n+    REGEXP_UNION, REGEXP_CONCATENATION, REGEXP_INTERSECTION, REGEXP_OPTIONAL, REGEXP_REPEAT, REGEXP_REPEAT_MIN, REGEXP_REPEAT_MINMAX, REGEXP_COMPLEMENT, REGEXP_CHAR, REGEXP_CHAR_RANGE, REGEXP_ANYCHAR, REGEXP_EMPTY, REGEXP_STRING, REGEXP_ANYSTRING, REGEXP_AUTOMATON, REGEXP_INTERVAL,\n+    REGEXP_SHORTHAND", "originalCommit": "693ae6ce762877f28097e5c2cc89fcb4053a5ba4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97618754e50e2deacfd88cc25a1de3a0d152a1a9", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java b/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java\nindex 3f5624a1875..d0445026e9c 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/RegExp.java\n\n@@ -318,7 +367,7 @@ public class RegExp {\n   \n   enum Kind {\n     REGEXP_UNION, REGEXP_CONCATENATION, REGEXP_INTERSECTION, REGEXP_OPTIONAL, REGEXP_REPEAT, REGEXP_REPEAT_MIN, REGEXP_REPEAT_MINMAX, REGEXP_COMPLEMENT, REGEXP_CHAR, REGEXP_CHAR_RANGE, REGEXP_ANYCHAR, REGEXP_EMPTY, REGEXP_STRING, REGEXP_ANYSTRING, REGEXP_AUTOMATON, REGEXP_INTERVAL,\n-    REGEXP_SHORTHAND\n+    REGEXP_PRE_CLASS\n   }\n   \n   /**\n"}}, {"oid": "97618754e50e2deacfd88cc25a1de3a0d152a1a9", "url": "https://github.com/apache/lucene-solr/commit/97618754e50e2deacfd88cc25a1de3a0d152a1a9", "message": "Added javadocs, renamed Kind type", "committedDate": "2020-05-13T15:10:04Z", "type": "forcePushed"}, {"oid": "4064c0987eb1bf34a89fb5a16d7e824f3d432cdc", "url": "https://github.com/apache/lucene-solr/commit/4064c0987eb1bf34a89fb5a16d7e824f3d432cdc", "message": "Add support for Java\u2019s predefined character classes like \\d for digits", "committedDate": "2020-05-14T08:45:18Z", "type": "commit"}, {"oid": "3e9206f09a5d9d52cf31428dbf44a6d1f78b4d4e", "url": "https://github.com/apache/lucene-solr/commit/3e9206f09a5d9d52cf31428dbf44a6d1f78b4d4e", "message": "Added randomised test for parity with Java\u2019s Pattern class.", "committedDate": "2020-05-14T08:45:18Z", "type": "commit"}, {"oid": "78db0e6e22cf51b7364bfb8922cf959220e5a252", "url": "https://github.com/apache/lucene-solr/commit/78db0e6e22cf51b7364bfb8922cf959220e5a252", "message": "Moved testCoreJavaParity from TestRegExpQuery to TestRegExp", "committedDate": "2020-05-14T08:45:18Z", "type": "commit"}, {"oid": "2145755870663667ae95e51f2eade5cea1994fd5", "url": "https://github.com/apache/lucene-solr/commit/2145755870663667ae95e51f2eade5cea1994fd5", "message": "Added javadocs, renamed Kind type", "committedDate": "2020-05-14T08:45:18Z", "type": "commit"}, {"oid": "2145755870663667ae95e51f2eade5cea1994fd5", "url": "https://github.com/apache/lucene-solr/commit/2145755870663667ae95e51f2eade5cea1994fd5", "message": "Added javadocs, renamed Kind type", "committedDate": "2020-05-14T08:45:18Z", "type": "forcePushed"}]}