{"pr_number": 1253, "pr_title": "LUCENE-9150: Restore support for dynamic PlanetModel in spatial3d", "pr_createdAt": "2020-02-12T18:04:54Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1253", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkwOTM1MA==", "url": "https://github.com/apache/lucene-solr/pull/1253#discussion_r378909350", "bodyText": "I think this class should be inside PlanetModel. We should not create any dependency in the geom package and if we keep this class here, then planet model has a decency outside.", "author": "iverase", "createdAt": "2020-02-13T14:52:54Z", "path": "lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DDocValuesField.java", "diffHunk": "@@ -478,9 +303,211 @@ public static SortField newOutsideLargePolygonSort(final String field, final Pol\n    * @return SortField ordering documents by distance\n    * @throws IllegalArgumentException if {@code field} is null or path has invalid coordinates.\n    */\n-  public static SortField newOutsidePathSort(final String field, final double[] pathLatitudes, final double[] pathLongitudes, final double pathWidthMeters) {\n-    final GeoOutsideDistance shape = Geo3DUtil.fromPath(pathLatitudes, pathLongitudes, pathWidthMeters);\n-    return new Geo3DPointOutsideSortField(field, shape);\n+  public static SortField newOutsidePathSort(final String field, final double[] pathLatitudes, final double[] pathLongitudes, final double pathWidthMeters, final PlanetModel planetModel) {\n+    final GeoOutsideDistance shape = Geo3DUtil.fromPath(planetModel, pathLatitudes, pathLongitudes, pathWidthMeters);\n+    return new Geo3DPointOutsideSortField(field, planetModel, shape);\n   }\n \n+  /** Utility class for encoding / decoding from lat/lon (decimal degrees) into sortable doc value numerics (integers) */\n+  public static class DocValueEncoder {", "originalCommit": "e8ea14d4e1b0f21fdcd91fe9caeeaab11cc18c08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA0NjI0Mg==", "url": "https://github.com/apache/lucene-solr/pull/1253#discussion_r386046242", "bodyText": "+1", "author": "nknize", "createdAt": "2020-02-29T18:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkwOTM1MA=="}], "type": "inlineReview", "revised_code": {"commit": "a53425abae93cea83030d2563fa72f282e35f3e5", "chunk": "diff --git a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DDocValuesField.java b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DDocValuesField.java\nindex 2985e3dbdf3..e2d27330ebc 100644\n--- a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DDocValuesField.java\n+++ b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DDocValuesField.java\n\n@@ -307,207 +307,4 @@ public class Geo3DDocValuesField extends Field {\n     final GeoOutsideDistance shape = Geo3DUtil.fromPath(planetModel, pathLatitudes, pathLongitudes, pathWidthMeters);\n     return new Geo3DPointOutsideSortField(field, planetModel, shape);\n   }\n-\n-  /** Utility class for encoding / decoding from lat/lon (decimal degrees) into sortable doc value numerics (integers) */\n-  public static class DocValueEncoder {\n-    private final PlanetModel planetModel;\n-\n-    // These are the multiplicative constants we need to use to arrive at values that fit in 21 bits.\n-    // The formula we use to go from double to encoded value is:  Math.floor((value - minimum) * factor + 0.5)\n-    // If we plug in maximum for value, we should get 0x1FFFFF.\n-    // So, 0x1FFFFF = Math.floor((maximum - minimum) * factor + 0.5)\n-    // We factor out the 0.5 and Math.floor by stating instead:\n-    // 0x1FFFFF = (maximum - minimum) * factor\n-    // So, factor = 0x1FFFFF / (maximum - minimum)\n-\n-    private final static double inverseMaximumValue = 1.0 / (double)(0x1FFFFF);\n-\n-    private final double inverseXFactor;\n-    private final double inverseYFactor;\n-    private final double inverseZFactor;\n-\n-    private final double xFactor;\n-    private final double yFactor;\n-    private final double zFactor;\n-\n-    // Fudge factor for step adjustments.  This is here solely to handle inaccuracies in bounding boxes\n-    // that occur because of quantization.  For unknown reasons, the fudge factor needs to be\n-    // 10.0 rather than 1.0.  See LUCENE-7430.\n-\n-    private final static double STEP_FUDGE = 10.0;\n-\n-    // These values are the delta between a value and the next value in each specific dimension\n-\n-    private final double xStep;\n-    private final double yStep;\n-    private final double zStep;\n-\n-    /** construct an encoder/decoder instance from the provided PlanetModel definition */\n-    public DocValueEncoder(final PlanetModel planetModel) {\n-      this.planetModel = planetModel;\n-\n-      this.inverseXFactor = (planetModel.getMaximumXValue() - planetModel.getMinimumXValue()) * inverseMaximumValue;\n-      this.inverseYFactor = (planetModel.getMaximumYValue() - planetModel.getMinimumYValue()) * inverseMaximumValue;\n-      this.inverseZFactor = (planetModel.getMaximumZValue() - planetModel.getMinimumZValue()) * inverseMaximumValue;\n-\n-      this.xFactor = 1.0 / inverseXFactor;\n-      this.yFactor = 1.0 / inverseYFactor;\n-      this.zFactor = 1.0 / inverseZFactor;\n-\n-      this.xStep = inverseXFactor * STEP_FUDGE;\n-      this.yStep = inverseYFactor * STEP_FUDGE;\n-      this.zStep = inverseZFactor * STEP_FUDGE;\n-    }\n-\n-    /** Encode a point.\n-     * @param point is the point\n-     * @return the encoded long\n-     */\n-    public long encodePoint(final GeoPoint point) {\n-      return encodePoint(point.x, point.y, point.z);\n-    }\n-\n-    /** Encode a point.\n-     * @param x is the x value\n-     * @param y is the y value\n-     * @param z is the z value\n-     * @return the encoded long\n-     */\n-    public long encodePoint(final double x, final double y, final double z) {\n-      int XEncoded = encodeX(x);\n-      int YEncoded = encodeY(y);\n-      int ZEncoded = encodeZ(z);\n-      return\n-          (((long)(XEncoded & 0x1FFFFF)) << 42) |\n-              (((long)(YEncoded & 0x1FFFFF)) << 21) |\n-              ((long)(ZEncoded & 0x1FFFFF));\n-    }\n-\n-    /** Decode GeoPoint value from long docvalues value.\n-     * @param docValue is the doc values value.\n-     * @return the GeoPoint.\n-     */\n-    public GeoPoint decodePoint(final long docValue) {\n-      return new GeoPoint(decodeX(((int)(docValue >> 42)) & 0x1FFFFF),\n-          decodeY(((int)(docValue >> 21)) & 0x1FFFFF),\n-          decodeZ(((int)(docValue)) & 0x1FFFFF));\n-    }\n-\n-    /** Decode X value from long docvalues value.\n-     * @param docValue is the doc values value.\n-     * @return the x value.\n-     */\n-    public double decodeXValue(final long docValue) {\n-      return decodeX(((int)(docValue >> 42)) & 0x1FFFFF);\n-    }\n-\n-    /** Decode Y value from long docvalues value.\n-     * @param docValue is the doc values value.\n-     * @return the y value.\n-     */\n-    public double decodeYValue(final long docValue) {\n-      return decodeY(((int)(docValue >> 21)) & 0x1FFFFF);\n-    }\n-\n-    /** Decode Z value from long docvalues value.\n-     * @param docValue is the doc values value.\n-     * @return the z value.\n-     */\n-    public double decodeZValue(final long docValue) {\n-      return decodeZ(((int)(docValue)) & 0x1FFFFF);\n-    }\n-\n-    /** Round the provided X value down, by encoding it, decrementing it, and unencoding it.\n-     * @param startValue is the starting value.\n-     * @return the rounded value.\n-     */\n-    public double roundDownX(final double startValue) {\n-      return startValue - xStep;\n-    }\n-\n-    /** Round the provided X value up, by encoding it, incrementing it, and unencoding it.\n-     * @param startValue is the starting value.\n-     * @return the rounded value.\n-     */\n-    public double roundUpX(final double startValue) {\n-      return startValue + xStep;\n-    }\n-\n-    /** Round the provided Y value down, by encoding it, decrementing it, and unencoding it.\n-     * @param startValue is the starting value.\n-     * @return the rounded value.\n-     */\n-    public double roundDownY(final double startValue) {\n-      return startValue - yStep;\n-    }\n-\n-    /** Round the provided Y value up, by encoding it, incrementing it, and unencoding it.\n-     * @param startValue is the starting value.\n-     * @return the rounded value.\n-     */\n-    public double roundUpY(final double startValue) {\n-      return startValue + yStep;\n-    }\n-\n-    /** Round the provided Z value down, by encoding it, decrementing it, and unencoding it.\n-     * @param startValue is the starting value.\n-     * @return the rounded value.\n-     */\n-    public double roundDownZ(final double startValue) {\n-      return startValue - zStep;\n-    }\n-\n-    /** Round the provided Z value up, by encoding it, incrementing it, and unencoding it.\n-     * @param startValue is the starting value.\n-     * @return the rounded value.\n-     */\n-    public double roundUpZ(final double startValue) {\n-      return startValue + zStep;\n-    }\n-\n-    // For encoding/decoding, we generally want the following behavior:\n-    // (1) If you encode the maximum value or the minimum value, the resulting int fits in 21 bits.\n-    // (2) If you decode an encoded value, you get back the original value for both the minimum and maximum planet model values.\n-    // (3) Rounding occurs such that a small delta from the minimum and maximum planet model values still returns the same\n-    // values -- that is, these are in the center of the range of input values that should return the minimum or maximum when decoded\n-\n-    private int encodeX(final double x) {\n-      if (x > planetModel.getMaximumXValue()) {\n-        throw new IllegalArgumentException(\"x value exceeds planet model maximum\");\n-      } else if (x < planetModel.getMinimumXValue()) {\n-        throw new IllegalArgumentException(\"x value less than planet model minimum\");\n-      }\n-      return (int)Math.floor((x - planetModel.getMinimumXValue()) * xFactor + 0.5);\n-    }\n-\n-    private double decodeX(final int x) {\n-      return x * inverseXFactor + planetModel.getMinimumXValue();\n-    }\n-\n-    private int encodeY(final double y) {\n-      if (y > planetModel.getMaximumYValue()) {\n-        throw new IllegalArgumentException(\"y value exceeds planet model maximum\");\n-      } else if (y < planetModel.getMinimumYValue()) {\n-        throw new IllegalArgumentException(\"y value less than planet model minimum\");\n-      }\n-      return (int)Math.floor((y - planetModel.getMinimumYValue()) * yFactor + 0.5);\n-    }\n-\n-    private double decodeY(final int y) {\n-      return y * inverseYFactor + planetModel.getMinimumYValue();\n-    }\n-\n-    private int encodeZ(final double z) {\n-      if (z > planetModel.getMaximumZValue()) {\n-        throw new IllegalArgumentException(\"z value exceeds planet model maximum\");\n-      } else if (z < planetModel.getMinimumZValue()) {\n-        throw new IllegalArgumentException(\"z value less than planet model minimum\");\n-      }\n-      return (int)Math.floor((z - planetModel.getMinimumZValue()) * zFactor + 0.5);\n-    }\n-\n-    private double decodeZ(final int z) {\n-      return z * inverseZFactor + planetModel.getMinimumZValue();\n-    }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxMzUzOQ==", "url": "https://github.com/apache/lucene-solr/pull/1253#discussion_r378913539", "bodyText": "As I said before, we should not have a dependency outside of this package.", "author": "iverase", "createdAt": "2020-02-13T14:59:18Z", "path": "lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java", "diffHunk": "@@ -20,6 +20,8 @@\n import java.io.OutputStream;\n import java.io.IOException;\n \n+import org.apache.lucene.spatial3d.Geo3DDocValuesField.DocValueEncoder;\n+", "originalCommit": "e8ea14d4e1b0f21fdcd91fe9caeeaab11cc18c08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA0NjI0NA==", "url": "https://github.com/apache/lucene-solr/pull/1253#discussion_r386046244", "bodyText": "+1", "author": "nknize", "createdAt": "2020-02-29T18:28:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxMzUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "a53425abae93cea83030d2563fa72f282e35f3e5", "chunk": "diff --git a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java\nindex 08bc7380015..07164422c0d 100644\n--- a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java\n+++ b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java\n\n@@ -20,8 +20,6 @@ import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.IOException;\n \n-import org.apache.lucene.spatial3d.Geo3DDocValuesField.DocValueEncoder;\n-\n /**\n  * Holds mathematical constants associated with the model of a planet.\n  * @lucene.experimental\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNDQ0Mg==", "url": "https://github.com/apache/lucene-solr/pull/1253#discussion_r378914442", "bodyText": "I wonder if instead of adding all those methods, the planet model should just return the docValueEncoder?", "author": "iverase", "createdAt": "2020-02-13T15:00:41Z", "path": "lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java", "diffHunk": "@@ -118,71 +176,191 @@ public PlanetModel(final InputStream inputStream) throws IOException {\n   \n   @Override\n   public void write(final OutputStream outputStream) throws IOException {\n-    SerializableObject.writeDouble(outputStream, ab);\n-    SerializableObject.writeDouble(outputStream, c);\n+    SerializableObject.writeDouble(outputStream, xyScaling);\n+    SerializableObject.writeDouble(outputStream, zScaling);\n   }\n   \n   /** Does this planet model describe a sphere?\n    *@return true if so.\n    */\n   public boolean isSphere() {\n-    return this.ab == this.c;\n+    return this.xyScaling == this.zScaling;\n   }\n   \n   /** Find the minimum magnitude of all points on the ellipsoid.\n    * @return the minimum magnitude for the planet.\n    */\n   public double getMinimumMagnitude() {\n-    return Math.min(this.ab, this.c);\n+    return Math.min(this.xyScaling, this.zScaling);\n   }\n \n   /** Find the maximum magnitude of all points on the ellipsoid.\n    * @return the maximum magnitude for the planet.\n    */\n   public double getMaximumMagnitude() {\n-    return Math.max(this.ab, this.c);\n+    return Math.max(this.xyScaling, this.zScaling);\n   }\n   \n   /** Find the minimum x value.\n    *@return the minimum X value.\n    */\n   public double getMinimumXValue() {\n-    return -this.ab;\n+    return -this.xyScaling;\n   }\n   \n   /** Find the maximum x value.\n    *@return the maximum X value.\n    */\n   public double getMaximumXValue() {\n-    return this.ab;\n+    return this.xyScaling;\n   }\n \n   /** Find the minimum y value.\n    *@return the minimum Y value.\n    */\n   public double getMinimumYValue() {\n-    return -this.ab;\n+    return -this.xyScaling;\n   }\n   \n   /** Find the maximum y value.\n    *@return the maximum Y value.\n    */\n   public double getMaximumYValue() {\n-    return this.ab;\n+    return this.xyScaling;\n   }\n   \n   /** Find the minimum z value.\n    *@return the minimum Z value.\n    */\n   public double getMinimumZValue() {\n-    return -this.c;\n+    return -this.zScaling;\n   }\n   \n   /** Find the maximum z value.\n    *@return the maximum Z value.\n    */\n   public double getMaximumZValue() {\n-    return this.c;\n+    return this.zScaling;\n+  }\n+\n+  /** return the calculated mean radius (in meters) */\n+  public double getMeanRadiusMeters() {\n+    return this.r1;\n+  }\n+\n+  /** encode the provided value from double to integer space */\n+  public int encodeValue(double x) {\n+    if (x > getMaximumMagnitude()) {\n+      throw new IllegalArgumentException(\"value=\" + x + \" is out-of-bounds (greater than planetMax=\" + getMaximumMagnitude() + \")\");\n+    }\n+    if (x == getMaximumMagnitude()) {\n+      x = Math.nextDown(x);\n+    }\n+    if (x < -getMaximumMagnitude()) {\n+      throw new IllegalArgumentException(\"value=\" + x + \" is out-of-bounds (less than than -planetMax=\" + -getMaximumMagnitude() + \")\");\n+    }\n+    long result = (long) Math.floor(x / DECODE);\n+    assert result >= Integer.MIN_VALUE;\n+    assert result <= Integer.MAX_VALUE;\n+    return (int) result;\n+  }\n+\n+  /**\n+   * Decodes a given integer back into the radian value according to the defined planet model\n+   */\n+  public double decodeValue(int x) {\n+    double result;\n+    if (x == MIN_ENCODED_VALUE) {\n+      // We must special case this, because -MAX_VALUE is not guaranteed to land precisely at a floor value, and we don't ever want to\n+      // return a value outside of the planet's range (I think?).  The max value is \"safe\" because we floor during encode:\n+      result = -MAX_VALUE;\n+    } else if (x == MAX_ENCODED_VALUE) {\n+      result = MAX_VALUE;\n+    } else {\n+      // We decode to the center value; this keeps the encoding stable\n+      result = (x+0.5) * DECODE;\n+    }\n+    assert result >= -MAX_VALUE && result <= MAX_VALUE;\n+    return result;\n+  }\n+\n+  /** Encode a provided GeoPoint into DocValue sortable integer space */", "originalCommit": "e8ea14d4e1b0f21fdcd91fe9caeeaab11cc18c08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA0NjI3NA==", "url": "https://github.com/apache/lucene-solr/pull/1253#discussion_r386046274", "bodyText": "I added a getter for the docValueEncoder in PlanetModel", "author": "nknize", "createdAt": "2020-02-29T18:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNDQ0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a53425abae93cea83030d2563fa72f282e35f3e5", "chunk": "diff --git a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java\nindex 08bc7380015..07164422c0d 100644\n--- a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java\n+++ b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java\n\n@@ -284,59 +282,9 @@ public class PlanetModel implements SerializableObject {\n     return result;\n   }\n \n-  /** Encode a provided GeoPoint into DocValue sortable integer space */\n-  public long encodeDocValuePoint(final GeoPoint point) {\n-    return docValueEncoder.encodePoint(point);\n-  }\n-\n-  /** Encode a provided 3D projected point into DocValue sortable integer space */\n-  public long encodeDocValuePoint(final double x, final double y, final double z) {\n-    return docValueEncoder.encodePoint(x, y, z);\n-  }\n-\n-  /** Decode the projected X value from DocValue integer space */\n-  public double decodeXDocValue(long encoded) {\n-    return this.docValueEncoder.decodeXValue(encoded);\n-  }\n-\n-  /** Decode the projected Y value from DocValue integer space */\n-  public double decodeYDocValue(long encoded) {\n-    return this.docValueEncoder.decodeYValue(encoded);\n-  }\n-\n-  /** Decode the projected Z value from DocValue integer space */\n-  public double decodeZDocValue(long encoded) {\n-    return this.docValueEncoder.decodeZValue(encoded);\n-  }\n-\n-  /** Round the projected X value to the next lower double value */\n-  public double roundDownXDocValue(double x) {\n-    return this.docValueEncoder.roundDownX(x);\n-  }\n-\n-  /** Round the projected X value to the next higher double value */\n-  public double roundUpXDocValue(double x) {\n-    return this.docValueEncoder.roundUpX(x);\n-  }\n-\n-  /** Round the projected Y value to the next lower double value */\n-  public double roundDownYDocValue(double y) {\n-    return this.docValueEncoder.roundDownY(y);\n-  }\n-\n-  /** Round the projected Y value to the next higher double value */\n-  public double roundUpYDocValue(double y) {\n-    return this.docValueEncoder.roundUpY(y);\n-  }\n-\n-  /** Round the projected Z value to the next lower double value */\n-  public double roundDownZDocValue(double z) {\n-    return this.docValueEncoder.roundDownZ(z);\n-  }\n-\n-  /** Round the projected Z value to the next higher double value */\n-  public double roundUpZDocValue(double z) {\n-    return this.docValueEncoder.roundUpZ(z);\n+  /** return reference to the DocValueEncoder used to encode/decode Geo3DDocValues */\n+  public DocValueEncoder getDocValueEncoder() {\n+    return this.docValueEncoder;\n   }\n \n   /** Returns a double value >= x such that if you multiply that value by an int, and then\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNDk3NQ==", "url": "https://github.com/apache/lucene-solr/pull/1253#discussion_r378914975", "bodyText": "Can we add the three planet models in the random?", "author": "iverase", "createdAt": "2020-02-13T15:01:27Z", "path": "lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java", "diffHunk": "@@ -84,6 +85,10 @@\n \n public class TestGeo3DPoint extends LuceneTestCase {\n \n+  protected PlanetModel randomPlanetModel() {\n+    return RandomPicks.randomFrom(random(), new PlanetModel[] {/*PlanetModel.WGS84,*/ PlanetModel.CLARKE_1866});\n+  }", "originalCommit": "e8ea14d4e1b0f21fdcd91fe9caeeaab11cc18c08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA0NjQ2NA==", "url": "https://github.com/apache/lucene-solr/pull/1253#discussion_r386046464", "bodyText": "+1", "author": "nknize", "createdAt": "2020-02-29T18:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNDk3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "a53425abae93cea83030d2563fa72f282e35f3e5", "chunk": "diff --git a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java\nindex 855291c3760..b633913c23c 100644\n--- a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java\n+++ b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java\n\n@@ -86,7 +86,7 @@ import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n public class TestGeo3DPoint extends LuceneTestCase {\n \n   protected PlanetModel randomPlanetModel() {\n-    return RandomPicks.randomFrom(random(), new PlanetModel[] {/*PlanetModel.WGS84,*/ PlanetModel.CLARKE_1866});\n+    return RandomPicks.randomFrom(random(), new PlanetModel[] {PlanetModel.WGS84, PlanetModel.CLARKE_1866});\n   }\n \n   private static Codec getCodec() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNzc1Ng==", "url": "https://github.com/apache/lucene-solr/pull/1253#discussion_r378917756", "bodyText": "This was added because Math#toDegrees and Math#toRadians were in the forbidden APIs. I believe in master the van has been lifted (java 11) so this is not needed anymore. Not for this PR but good to have it in mind.", "author": "iverase", "createdAt": "2020-02-13T15:05:47Z", "path": "lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/Geo3DUtil.java", "diffHunk": "@@ -16,89 +16,13 @@\n  */\n package org.apache.lucene.spatial3d.geom;\n \n-import org.apache.lucene.geo.Polygon;\n-import org.apache.lucene.geo.GeoUtils;\n-\n-import java.util.List;\n-import java.util.ArrayList;\n-\n class Geo3DUtil {\n \n-  /** How many radians are in one earth surface meter */\n-  final static double RADIANS_PER_METER = 1.0 / PlanetModel.WGS84_MEAN;\n   /** How many radians are in one degree */\n   final static double RADIANS_PER_DEGREE = Math.PI / 180.0;\n   /** How many degrees in a radian */\n   final static double DEGREES_PER_RADIAN = 180.0 / Math.PI;", "originalCommit": "e8ea14d4e1b0f21fdcd91fe9caeeaab11cc18c08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "a53425abae93cea83030d2563fa72f282e35f3e5", "url": "https://github.com/apache/lucene-solr/commit/a53425abae93cea83030d2563fa72f282e35f3e5", "message": "LUCENE-9150: Restore support for dynamic PlanetModel in spatial3d", "committedDate": "2020-02-29T18:02:51Z", "type": "forcePushed"}, {"oid": "c7e4a0e85940e6633db28b7d16f87006f17e0482", "url": "https://github.com/apache/lucene-solr/commit/c7e4a0e85940e6633db28b7d16f87006f17e0482", "message": "LUCENE-9150: Restore support for dynamic PlanetModel in spatial3d", "committedDate": "2020-02-29T18:30:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5MjI3NA==", "url": "https://github.com/apache/lucene-solr/pull/1253#discussion_r386092274", "bodyText": "make constructor private?", "author": "iverase", "createdAt": "2020-03-01T09:34:22Z", "path": "lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java", "diffHunk": "@@ -383,30 +509,233 @@ public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, fi\n       \u0394\u03c3 = B * sin\u03c3 * (cos2\u03c3M + B / 4.0 * (cos\u03c3 * (-1.0 + 2.0 * cos2\u03c3M * cos2\u03c3M) -\n           B / 6.0 * cos2\u03c3M * (-3.0 + 4.0 * sin\u03c3 * sin\u03c3) * (-3.0 + 4.0 * cos2\u03c3M * cos2\u03c3M)));\n       \u03c3\u02b9 = \u03c3;\n-      \u03c3 = dist / (c * inverseScale * A) + \u0394\u03c3;\n+      \u03c3 = dist / (zScaling * inverseScale * A) + \u0394\u03c3;\n     } while (Math.abs(\u03c3 - \u03c3\u02b9) >= Vector.MINIMUM_RESOLUTION && ++iterations < 100);\n     double x = sinU1 * sin\u03c3 - cosU1 * cos\u03c3 * cos\u03b11;\n-    double \u03c62 = Math.atan2(sinU1 * cos\u03c3 + cosU1 * sin\u03c3 * cos\u03b11, (1.0 - flattening) * Math.sqrt(sin\u03b1 * sin\u03b1 + x * x));\n+    double \u03c62 = Math.atan2(sinU1 * cos\u03c3 + cosU1 * sin\u03c3 * cos\u03b11, (1.0 - scaledFlattening) * Math.sqrt(sin\u03b1 * sin\u03b1 + x * x));\n     double \u03bb = Math.atan2(sin\u03c3 * sin\u03b11, cosU1 * cos\u03c3 - sinU1 * sin\u03c3 * cos\u03b11);\n-    double C = flattening / 16.0 * cosSq\u03b1 * (4.0 + flattening * (4.0 - 3.0 * cosSq\u03b1));\n-    double L = \u03bb - (1.0 - C) * flattening * sin\u03b1 *\n+    double C = scaledFlattening / 16.0 * cosSq\u03b1 * (4.0 + scaledFlattening * (4.0 - 3.0 * cosSq\u03b1));\n+    double L = \u03bb - (1.0 - C) * scaledFlattening * sin\u03b1 *\n         (\u03c3 + C * sin\u03c3 * (cos2\u03c3M + C * cos\u03c3 * (-1.0 + 2.0 * cos2\u03c3M * cos2\u03c3M)));\n     double \u03bb2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  // normalise to -180..+180\n \n     return new GeoPoint(this, \u03c62, \u03bb2);\n   }\n \n+  /** Utility class for encoding / decoding from lat/lon (decimal degrees) into sortable doc value numerics (integers) */\n+  public static class DocValueEncoder {\n+    private final PlanetModel planetModel;\n+\n+    // These are the multiplicative constants we need to use to arrive at values that fit in 21 bits.\n+    // The formula we use to go from double to encoded value is:  Math.floor((value - minimum) * factor + 0.5)\n+    // If we plug in maximum for value, we should get 0x1FFFFF.\n+    // So, 0x1FFFFF = Math.floor((maximum - minimum) * factor + 0.5)\n+    // We factor out the 0.5 and Math.floor by stating instead:\n+    // 0x1FFFFF = (maximum - minimum) * factor\n+    // So, factor = 0x1FFFFF / (maximum - minimum)\n+\n+    private final static double inverseMaximumValue = 1.0 / (double)(0x1FFFFF);\n+\n+    private final double inverseXFactor;\n+    private final double inverseYFactor;\n+    private final double inverseZFactor;\n+\n+    private final double xFactor;\n+    private final double yFactor;\n+    private final double zFactor;\n+\n+    // Fudge factor for step adjustments.  This is here solely to handle inaccuracies in bounding boxes\n+    // that occur because of quantization.  For unknown reasons, the fudge factor needs to be\n+    // 10.0 rather than 1.0.  See LUCENE-7430.\n+\n+    private final static double STEP_FUDGE = 10.0;\n+\n+    // These values are the delta between a value and the next value in each specific dimension\n+\n+    private final double xStep;\n+    private final double yStep;\n+    private final double zStep;\n+\n+    /** construct an encoder/decoder instance from the provided PlanetModel definition */\n+    public DocValueEncoder(final PlanetModel planetModel) {", "originalCommit": "c7e4a0e85940e6633db28b7d16f87006f17e0482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3NjIzMg==", "url": "https://github.com/apache/lucene-solr/pull/1253#discussion_r386676232", "bodyText": "\ud83d\udc4d good call!", "author": "nknize", "createdAt": "2020-03-02T21:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5MjI3NA=="}], "type": "inlineReview", "revised_code": {"commit": "c90da86c146261df12008b3eb8d32b7fd1619d40", "chunk": "diff --git a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java\nindex 07164422c0d..9e19b3f335d 100644\n--- a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java\n+++ b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java\n\n@@ -557,7 +557,7 @@ public class PlanetModel implements SerializableObject {\n     private final double zStep;\n \n     /** construct an encoder/decoder instance from the provided PlanetModel definition */\n-    public DocValueEncoder(final PlanetModel planetModel) {\n+    private DocValueEncoder(final PlanetModel planetModel) {\n       this.planetModel = planetModel;\n \n       this.inverseXFactor = (planetModel.getMaximumXValue() - planetModel.getMinimumXValue()) * inverseMaximumValue;\n"}}, {"oid": "c90da86c146261df12008b3eb8d32b7fd1619d40", "url": "https://github.com/apache/lucene-solr/commit/c90da86c146261df12008b3eb8d32b7fd1619d40", "message": "LUCENE-9150: Restore support for dynamic PlanetModel in spatial3d", "committedDate": "2020-03-02T21:59:58Z", "type": "forcePushed"}, {"oid": "75fb2d2f24a2351e54819bb499f788c8a42d942e", "url": "https://github.com/apache/lucene-solr/commit/75fb2d2f24a2351e54819bb499f788c8a42d942e", "message": "LUCENE-9150: Restore support for dynamic PlanetModel in spatial3d", "committedDate": "2020-03-02T22:01:53Z", "type": "forcePushed"}, {"oid": "a6e80d004d84213886a5ce52fd220d2e5112e43e", "url": "https://github.com/apache/lucene-solr/commit/a6e80d004d84213886a5ce52fd220d2e5112e43e", "message": "LUCENE-9150: Restore support for dynamic PlanetModel in spatial3d", "committedDate": "2020-03-02T22:06:17Z", "type": "commit"}, {"oid": "a6e80d004d84213886a5ce52fd220d2e5112e43e", "url": "https://github.com/apache/lucene-solr/commit/a6e80d004d84213886a5ce52fd220d2e5112e43e", "message": "LUCENE-9150: Restore support for dynamic PlanetModel in spatial3d", "committedDate": "2020-03-02T22:06:17Z", "type": "forcePushed"}]}