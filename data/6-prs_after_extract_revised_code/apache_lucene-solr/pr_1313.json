{"pr_number": 1313, "pr_title": "LUCENE-8962: Split test case", "pr_createdAt": "2020-03-03T22:16:42Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1313", "timeline": [{"oid": "0973c6fabf7ffb3433b63e9de951f512dc4da205", "url": "https://github.com/apache/lucene-solr/commit/0973c6fabf7ffb3433b63e9de951f512dc4da205", "message": "LUCENE-8962: Split test case\n\nThe testMergeOnCommit test case was trying to verify too many things\nat once: basic semantics of merge on commit and proper behavior when\na bunch of indexing threads are writing and committing all at once.\n\nSplitting the test into two should make the tests more robust - one\nwill verify basic behavior, with strict assertions on invariants, while\nthe other just verifies that everything gets indexed and we don't throw\nan exception when multiple threads are indexing and merging on commit.\n\nAlso, the part of the test that is now testMultithreadedMergeOnCommit\ncan take several seconds to run, so moving it to the @Nightly set.", "committedDate": "2020-03-03T22:11:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4MjM0NQ==", "url": "https://github.com/apache/lucene-solr/pull/1313#discussion_r387682345", "bodyText": "I ran this test a few times, and noticed it takes 2-3 minutes to complete. Was it this slow before? I don't remember it taking so long in the previous version. Perhaps it's because it's Nightly now so the constants are made larger?", "author": "msokolov", "createdAt": "2020-03-04T13:58:40Z", "path": "lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy.java", "diffHunk": "@@ -298,63 +320,44 @@ public void testMergeOnCommit() throws IOException, InterruptedException {\n     DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n     assertEquals(5, firstReader.leaves().size());\n     firstReader.close();\n-    firstWriter.close();\n-\n-    MergePolicy mergeOnCommitPolicy = new LogDocMergePolicy() {\n-      @Override\n-      public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) {\n-        // Optimize down to a single segment on commit\n-        if (mergeTrigger == MergeTrigger.COMMIT && segmentInfos.size() > 1) {\n-          List<SegmentCommitInfo> nonMergingSegments = new ArrayList<>();\n-          for (SegmentCommitInfo sci : segmentInfos) {\n-            if (mergeContext.getMergingSegments().contains(sci) == false) {\n-              nonMergingSegments.add(sci);\n-            }\n-          }\n-          if (nonMergingSegments.size() > 1) {\n-            MergeSpecification mergeSpecification = new MergeSpecification();\n-            mergeSpecification.add(new OneMerge(nonMergingSegments));\n-            return mergeSpecification;\n-          }\n-        }\n-        return null;\n-      }\n-    };\n+    firstWriter.close(); // When this writer closes, it does not merge on commit.\n \n-    AtomicInteger abandonedMerges = new AtomicInteger(0);\n     IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n-        .setMergePolicy(mergeOnCommitPolicy)\n-        .setIndexWriterEvents(new IndexWriterEvents() {\n-          @Override\n-          public void beginMergeOnCommit() {\n-\n-          }\n-\n-          @Override\n-          public void finishMergeOnCommit() {\n+        .setMergePolicy(MERGE_ON_COMMIT_POLICY);\n \n-          }\n-\n-          @Override\n-          public void abandonedMergesOnCommit(int abandonedCount) {\n-            abandonedMerges.incrementAndGet();\n-          }\n-        });\n     IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n-\n-    writerWithMergePolicy.commit();\n+    writerWithMergePolicy.commit(); // No changes. Commit doesn't trigger a merge.\n \n     DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n-    assertEquals(5, unmergedReader.leaves().size()); // Don't merge unless there's a change\n+    assertEquals(5, unmergedReader.leaves().size());\n     unmergedReader.close();\n \n     TestIndexWriter.addDoc(writerWithMergePolicy);\n-    writerWithMergePolicy.commit();\n+    writerWithMergePolicy.commit(); // Doc added, do merge on commit.\n+    assertEquals(1, writerWithMergePolicy.getSegmentCount()); //\n \n     DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n-    assertEquals(1, mergedReader.leaves().size()); // Now we merge on commit\n+    assertEquals(1, mergedReader.leaves().size());\n     mergedReader.close();\n \n+    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n+      IndexSearcher searcher = new IndexSearcher(reader);\n+      assertEquals(6, reader.numDocs());\n+      assertEquals(6, searcher.count(new MatchAllDocsQuery()));\n+    }\n+\n+    writerWithMergePolicy.close();\n+    dir.close();\n+  }\n+\n+   // Test that when we have multiple indexing threads merging on commit, we never throw an exception.\n+  @Nightly", "originalCommit": "0973c6fabf7ffb3433b63e9de951f512dc4da205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5NDIzNw==", "url": "https://github.com/apache/lucene-solr/pull/1313#discussion_r387894237", "bodyText": "Oh, that's probably the case.\nGiven that there are other tests that flex indexing across multiple threads and MockRandomMergePolicy will occasionally merge on commit, maybe this test doesn't add any value?", "author": "msfroh", "createdAt": "2020-03-04T19:45:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4MjM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI2NDcxNg==", "url": "https://github.com/apache/lucene-solr/pull/1313#discussion_r388264716", "bodyText": "Yes, I think given it does not assert anything -- just makes sure no exceptions occur -- we should already be well-covered.", "author": "msokolov", "createdAt": "2020-03-05T12:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4MjM0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "204dc023e69c225251170623a0c655526485a98f", "chunk": "diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy.java\nindex 2d443dd74be..8a463efd835 100644\n--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy.java\n+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy.java\n\n@@ -350,51 +346,6 @@ public class TestIndexWriterMergePolicy extends LuceneTestCase {\n     dir.close();\n   }\n \n-   // Test that when we have multiple indexing threads merging on commit, we never throw an exception.\n-  @Nightly\n-  public void testMultithreadedMergeOnCommit() throws IOException, InterruptedException {\n-    Directory dir = newDirectory();\n-    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n-        .setMergePolicy(MERGE_ON_COMMIT_POLICY);\n-\n-    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n-    LineFileDocs lineFileDocs = new LineFileDocs(random());\n-    int docCount = atLeast(1000);\n-    AtomicInteger indexedDocs = new AtomicInteger(0);\n-    int numIndexingThreads = atLeast(2);\n-    CountDownLatch startingGun = new CountDownLatch(1);\n-    Collection<Thread> indexingThreads = new ArrayList<>();\n-    for (int i = 0; i < numIndexingThreads; i++) {\n-      Thread t = new Thread(() -> {\n-        try {\n-          startingGun.await();\n-          while (indexedDocs.getAndIncrement() < docCount) {\n-            writerWithMergePolicy.addDocument(lineFileDocs.nextDoc());\n-            if (rarely()) {\n-              writerWithMergePolicy.commit();\n-            }\n-          }\n-        } catch (IOException | InterruptedException e) {\n-          e.printStackTrace();\n-          fail();\n-        }\n-      });\n-      t.start();\n-      indexingThreads.add(t);\n-    }\n-    startingGun.countDown();\n-    for (Thread t : indexingThreads) {\n-      t.join();\n-    }\n-    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n-      IndexSearcher searcher = new IndexSearcher(reader);\n-      assertEquals(docCount, reader.numDocs());\n-      assertEquals(docCount, searcher.count(new MatchAllDocsQuery()));\n-    }\n-    writerWithMergePolicy.close();\n-    dir.close();\n-  }\n-\n   private void assertSetters(MergePolicy lmp) {\n     lmp.setMaxCFSSegmentSizeMB(2.0);\n     assertEquals(2.0, lmp.getMaxCFSSegmentSizeMB(), EPSILON);\n"}}, {"oid": "37c018bc3e9f8492cbe28a187b9edf3bf33fe3d8", "url": "https://github.com/apache/lucene-solr/commit/37c018bc3e9f8492cbe28a187b9edf3bf33fe3d8", "message": "LUCENE-8962: Only update toCommit if merge was committed\n\nThe code was previously assuming that if mergeFinished() was called and\nisAborted() was false, then the merge must have completed successfully.\nInstead, we should know for sure if a given merge was committed, and\nonly then update our pending commit SegmentInfos.", "committedDate": "2020-03-04T19:50:11Z", "type": "commit"}, {"oid": "204dc023e69c225251170623a0c655526485a98f", "url": "https://github.com/apache/lucene-solr/commit/204dc023e69c225251170623a0c655526485a98f", "message": "LUCENE-8962: Remove slow, low-value test case\n\nWe weren't asserting anything in testMultithreadedMergeOnCommit, but\nrather were just checking that a bunch of indexing threads occasionally\nmerging on commit wouldn't trigger an exception.\n\nGiven that MockRandomMergePolicy already triggers random merges on\ncommit and there are other unit tests that spawn many indexing threads\nthat sometimes commit, this test was redundant.", "committedDate": "2020-03-05T18:50:27Z", "type": "commit"}]}