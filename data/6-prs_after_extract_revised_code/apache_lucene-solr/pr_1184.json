{"pr_number": 1184, "pr_title": "LUCENE-9142 Refactor IntSet operations for determinize", "pr_createdAt": "2020-01-18T00:21:59Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1184", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzODc3MQ==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r368238771", "bodyText": "This is a really bad hash, to be honest.... What is this constructor even used for? It's really sneaky as it allows changes to the content of a \"frozen\" set of values?", "author": "dweiss", "createdAt": "2020-01-18T17:40:39Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.util.automaton;\n+\n+public final class FrozenIntSet extends IntSet {\n+  final int state;\n+\n+  public FrozenIntSet(int[] values, int hashCode, int state) {\n+    this.values = values;\n+    this.hashCode = hashCode;\n+    this.state = state;\n+  }\n+\n+  public FrozenIntSet(int num, int state) {\n+    this.values = new int[] { num };\n+    this.state = state;\n+    this.hashCode = 683 + num;", "originalCommit": "139040496952f487eaedf9acd6e7d0c27ada1135", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM0ODMxMg==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r368348312", "bodyText": "It's a shortcut for the other constructor, uses the same calculation for hash that is in SortedIntSet.calculateHash, but specialized down to a single value. I'll see if we can easily drop this code since I agree that it adds complexity for maintaners.", "author": "madrob", "createdAt": "2020-01-20T02:21:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzODc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4ODY1Ng==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r368388656", "bodyText": "oh, ok. drop it; the less code to understand the better. I don't think it'll be a particular gain here.", "author": "dweiss", "createdAt": "2020-01-20T06:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzODc3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e9d83138bafb6425778dcf61be483192804ee8c8", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java\nindex cf3d45f03cf..35392f99f6e 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java\n\n@@ -16,23 +16,36 @@\n  */\n package org.apache.lucene.util.automaton;\n \n-public final class FrozenIntSet extends IntSet {\n+import java.util.Arrays;\n+\n+final class FrozenIntSet extends IntSet {\n+  final int[] values;\n+  final int hashCode;\n   final int state;\n \n-  public FrozenIntSet(int[] values, int hashCode, int state) {\n+  FrozenIntSet(int[] values, int hashCode, int state) {\n     this.values = values;\n     this.hashCode = hashCode;\n     this.state = state;\n   }\n \n-  public FrozenIntSet(int num, int state) {\n-    this.values = new int[] { num };\n-    this.state = state;\n-    this.hashCode = 683 + num;\n+  @Override\n+  int[] asArray() {\n+    return values;\n   }\n \n   @Override\n-  public int size() {\n+  int size() {\n     return values.length;\n   }\n+\n+  @Override\n+  public int hashCode() {\n+    return hashCode;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return Arrays.toString(values);\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzODg1MA==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r368238850", "bodyText": "I think the hashCode should be private to the abstract class and anything else should call hashCode() (including equals method). Then subclasses that are mutable could return true hashCode of their content (cached or computed).", "author": "dweiss", "createdAt": "2020-01-18T17:41:58Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.util.automaton;\n+\n+import java.util.Arrays;\n+\n+public abstract class IntSet {\n+    int[] values;\n+\n+    int hashCode;", "originalCommit": "139040496952f487eaedf9acd6e7d0c27ada1135", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0NTg1MA==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r368245850", "bodyText": "In addition, fields that are initialized in constructors and never changed should always be declared final.", "author": "uschindler", "createdAt": "2020-01-18T20:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzODg1MA=="}], "type": "inlineReview", "revised_code": {"commit": "e9d83138bafb6425778dcf61be483192804ee8c8", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java\nindex cec97b83ff1..ad58ed9b767 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java\n\n@@ -18,46 +18,29 @@ package org.apache.lucene.util.automaton;\n \n import java.util.Arrays;\n \n-public abstract class IntSet {\n-    int[] values;\n-\n-    int hashCode;\n+abstract class IntSet {\n+    /**\n+     * Return an array representation of this int set's values. Values are valid for indices [0, {@link #size()}).\n+     * If this is a mutable int set, then changes to the set are not guaranteed to be visible in this array.\n+     * @return an array containing the values for this set, guaranteed to be at least {@link #size()} elements\n+     */\n+    abstract int[] asArray();\n \n     /**\n-     * @return the number of values contained within this set\n+     * Guaranteed to be less than or equal to the length of the array returned by {@link #asArray()}.\n+     * @return The number of values in this set.\n      */\n     abstract int size();\n \n     @Override\n-    public int hashCode() {\n-        return hashCode;\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        if (other == null) {\n-            return false;\n-        }\n-        if (!(other instanceof IntSet)) {\n-            return false;\n-        }\n-        IntSet intSet = (IntSet) other;\n-        if (hashCode != intSet.hashCode) {\n-            return false;\n-        }\n-        return Arrays.equals(values, 0, size(), intSet.values, 0, intSet.size());\n-    }\n+    public abstract int hashCode();\n \n     @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for(int i = 0; i < size(); i++) {\n-            if (i > 0) {\n-                sb.append(' ');\n-            }\n-            sb.append(values[i]);\n-        }\n-        sb.append(']');\n-        return sb.toString();\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof IntSet)) return false;\n+        IntSet that = (IntSet) o;\n+        return hashCode() == that.hashCode()\n+            && Arrays.equals(asArray(), 0, size(), that.asArray(), 0, that.size());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzODg3Ng==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r368238876", "bodyText": "If it's just for debugging then I'd just use a stream and join the values there, it's a one-liner. Space after for(", "author": "dweiss", "createdAt": "2020-01-18T17:43:00Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.util.automaton;\n+\n+import java.util.Arrays;\n+\n+public abstract class IntSet {\n+    int[] values;\n+\n+    int hashCode;\n+\n+    /**\n+     * @return the number of values contained within this set\n+     */\n+    abstract int size();\n+\n+    @Override\n+    public int hashCode() {\n+        return hashCode;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (other == null) {\n+            return false;\n+        }\n+        if (!(other instanceof IntSet)) {\n+            return false;\n+        }\n+        IntSet intSet = (IntSet) other;\n+        if (hashCode != intSet.hashCode) {\n+            return false;\n+        }\n+        return Arrays.equals(values, 0, size(), intSet.values, 0, intSet.size());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder().append('[');", "originalCommit": "139040496952f487eaedf9acd6e7d0c27ada1135", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9d83138bafb6425778dcf61be483192804ee8c8", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java\nindex cec97b83ff1..ad58ed9b767 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java\n\n@@ -18,46 +18,29 @@ package org.apache.lucene.util.automaton;\n \n import java.util.Arrays;\n \n-public abstract class IntSet {\n-    int[] values;\n-\n-    int hashCode;\n+abstract class IntSet {\n+    /**\n+     * Return an array representation of this int set's values. Values are valid for indices [0, {@link #size()}).\n+     * If this is a mutable int set, then changes to the set are not guaranteed to be visible in this array.\n+     * @return an array containing the values for this set, guaranteed to be at least {@link #size()} elements\n+     */\n+    abstract int[] asArray();\n \n     /**\n-     * @return the number of values contained within this set\n+     * Guaranteed to be less than or equal to the length of the array returned by {@link #asArray()}.\n+     * @return The number of values in this set.\n      */\n     abstract int size();\n \n     @Override\n-    public int hashCode() {\n-        return hashCode;\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        if (other == null) {\n-            return false;\n-        }\n-        if (!(other instanceof IntSet)) {\n-            return false;\n-        }\n-        IntSet intSet = (IntSet) other;\n-        if (hashCode != intSet.hashCode) {\n-            return false;\n-        }\n-        return Arrays.equals(values, 0, size(), intSet.values, 0, intSet.size());\n-    }\n+    public abstract int hashCode();\n \n     @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for(int i = 0; i < size(); i++) {\n-            if (i > 0) {\n-                sb.append(' ');\n-            }\n-            sb.append(values[i]);\n-        }\n-        sb.append(']');\n-        return sb.toString();\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof IntSet)) return false;\n+        IntSet that = (IntSet) o;\n+        return hashCode() == that.hashCode()\n+            && Arrays.equals(asArray(), 0, size(), that.asArray(), 0, that.size());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzODk0NA==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r368238944", "bodyText": "isn't there a futurearrays method that does this in a single step (without intermediate zeroed int[])?", "author": "dweiss", "createdAt": "2020-01-18T17:44:25Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java", "diffHunk": "@@ -151,126 +141,23 @@ public void computeHash() {\n     }\n   }\n \n+  /**\n+   * Create a FrozenIntSet from the current values in this IntSet.\n+   *\n+   * Note: Must call computeHash() before calling this method\n+   *\n+   * @param state the state to save\n+   * @return a FrozenIntSet that has the same values and hashCode as this set\n+   */\n   public FrozenIntSet freeze(int state) {\n     final int[] c = new int[upto];\n     System.arraycopy(values, 0, c, 0, upto);", "originalCommit": "139040496952f487eaedf9acd6e7d0c27ada1135", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM0OTQ4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r368349481", "bodyText": "Arrays.copyOf does it in two steps, same as here. FutureArrays has compare, equals, and mismatch that I see?", "author": "madrob", "createdAt": "2020-01-20T02:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzODk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4ODM1NA==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r368388354", "bodyText": "You look at Java code but the difference is that Array.copyOf is (I believe) an jvm intrinsic so it should be replaced with a more optimized code. The pair of allocation+arraycopy should as well be optimized for that matter but it requires execution graph analysis and copyOf is straightforward.", "author": "dweiss", "createdAt": "2020-01-20T06:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzODk0NA=="}], "type": "inlineReview", "revised_code": {"commit": "e9d83138bafb6425778dcf61be483192804ee8c8", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\nindex 9712577f526..37e1fe12e8d 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\n\n@@ -142,22 +143,45 @@ final class SortedIntSet extends IntSet {\n   }\n \n   /**\n-   * Create a FrozenIntSet from the current values in this IntSet.\n-   *\n-   * Note: Must call computeHash() before calling this method\n-   *\n-   * @param state the state to save\n-   * @return a FrozenIntSet that has the same values and hashCode as this set\n+   * Create a snapshot of this int set associated with a given state. The snapshot will not retain any frequency\n+   * information about the elements of this set, only existence.\n+   * <p>\n+   * It is the caller's responsibility to ensure that the hashCode and data are up to date via the {@link #computeHash()} method before calling this method.\n+   * @param state the state to associate with the frozen set.\n+   * @return A new FrozenIntSet with the same values as this set.\n    */\n-  public FrozenIntSet freeze(int state) {\n-    final int[] c = new int[upto];\n-    System.arraycopy(values, 0, c, 0, upto);\n+  FrozenIntSet freeze(int state) {\n+    final int[] c = ArrayUtil.copyOfSubArray(values, 0, upto);\n     return new FrozenIntSet(c, hashCode, state);\n   }\n \n   @Override\n-  public int size() {\n+  int[] asArray() {\n+      return values;\n+  }\n+\n+  @Override\n+  int size() {\n     return upto;\n   }\n+\n+  @Override\n+  public int hashCode() {\n+    return hashCode;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder().append('[');\n+    for(int i=0;i<upto;i++) {\n+      if (i > 0) {\n+        sb.append(' ');\n+      }\n+      sb.append(values[i]).append(':').append(counts[i]);\n+    }\n+    sb.append(']');\n+    return sb.toString();\n+  }\n+\n }\n   \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwMzgwNQ==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r369103805", "bodyText": "Hmm does it really need to be public?  I thought it's only the java sources in this package that use it?", "author": "mikemccand", "createdAt": "2020-01-21T16:24:33Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.util.automaton;\n+\n+public final class FrozenIntSet extends IntSet {", "originalCommit": "3997ea0d84bc26f2bfd86c5620e289af8638b32e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9d83138bafb6425778dcf61be483192804ee8c8", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java\nindex 1c81eb3fde0..35392f99f6e 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java\n\n@@ -16,9 +16,12 @@\n  */\n package org.apache.lucene.util.automaton;\n \n-public final class FrozenIntSet extends IntSet {\n-  final int state;\n+import java.util.Arrays;\n+\n+final class FrozenIntSet extends IntSet {\n+  final int[] values;\n   final int hashCode;\n+  final int state;\n \n   FrozenIntSet(int[] values, int hashCode, int state) {\n     this.values = values;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNDEyNQ==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r369104125", "bodyText": "protected?", "author": "mikemccand", "createdAt": "2020-01-21T16:25:05Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.util.automaton;\n+\n+import org.apache.lucene.util.ArrayUtil;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * An int set backed by an array.\n+ */\n+public abstract class IntSet {\n+    int[] values;", "originalCommit": "3997ea0d84bc26f2bfd86c5620e289af8638b32e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9d83138bafb6425778dcf61be483192804ee8c8", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java\nindex 5257230f910..ad58ed9b767 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/IntSet.java\n\n@@ -16,38 +16,31 @@\n  */\n package org.apache.lucene.util.automaton;\n \n-import org.apache.lucene.util.ArrayUtil;\n-\n import java.util.Arrays;\n \n-/**\n- * An int set backed by an array.\n- */\n-public abstract class IntSet {\n-    int[] values;\n+abstract class IntSet {\n+    /**\n+     * Return an array representation of this int set's values. Values are valid for indices [0, {@link #size()}).\n+     * If this is a mutable int set, then changes to the set are not guaranteed to be visible in this array.\n+     * @return an array containing the values for this set, guaranteed to be at least {@link #size()} elements\n+     */\n+    abstract int[] asArray();\n \n     /**\n-     * @return the number of values contained within this set\n+     * Guaranteed to be less than or equal to the length of the array returned by {@link #asArray()}.\n+     * @return The number of values in this set.\n      */\n     abstract int size();\n \n     @Override\n-    public boolean equals(Object other) {\n-        if (other == null) {\n-            return false;\n-        }\n-        if (!(other instanceof IntSet)) {\n-            return false;\n-        }\n-        IntSet intSet = (IntSet) other;\n-        if (hashCode() != intSet.hashCode()) {\n-            return false;\n-        }\n-        return Arrays.equals(values, 0, size(), intSet.values, 0, intSet.size());\n-    }\n+    public abstract int hashCode();\n \n     @Override\n-    public String toString() {\n-        return Arrays.toString(ArrayUtil.copyOfSubArray(values, 0, size()));\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof IntSet)) return false;\n+        IntSet that = (IntSet) o;\n+        return hashCode() == that.hashCode()\n+            && Arrays.equals(asArray(), 0, size(), that.asArray(), 0, that.size());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNjk0Ng==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r369106946", "bodyText": "How come the code didn't need/use stale before?", "author": "mikemccand", "createdAt": "2020-01-21T16:29:25Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java", "diffHunk": "@@ -77,6 +88,7 @@ public void incr(int num) {\n         values[i] = num;\n         counts[i] = 1;\n         upto++;\n+        stale = true;", "originalCommit": "3997ea0d84bc26f2bfd86c5620e289af8638b32e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2OTc3OQ==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r369169779", "bodyText": "Because it didn't track whether the cached hash code was stale and relied on the caller to do it. I feel like it is more clear to manage it internally.", "author": "madrob", "createdAt": "2020-01-21T18:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNjk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1NDMyNQ==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r369454325", "bodyText": "oh, found the replacement we should use: ArrayUtil.copyOfSubArray", "author": "dweiss", "createdAt": "2020-01-22T09:39:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNjk0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e9d83138bafb6425778dcf61be483192804ee8c8", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\nindex efaaea2853b..37e1fe12e8d 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\n\n@@ -88,7 +68,6 @@ final class SortedIntSet extends IntSet {\n         values[i] = num;\n         counts[i] = 1;\n         upto++;\n-        stale = true;\n         return;\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNzIxNg==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r369107216", "bodyText": "Isn't the array discarded as soon as we switch over to the map (so how could it be out of sync)?", "author": "mikemccand", "createdAt": "2020-01-21T16:29:52Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java", "diffHunk": "@@ -16,59 +16,70 @@\n  */\n package org.apache.lucene.util.automaton;\n \n+import java.util.Arrays;\n import java.util.TreeMap;\n import java.util.Map;\n import org.apache.lucene.util.ArrayUtil;\n+import org.apache.lucene.util.SuppressForbidden;\n \n // Just holds a set of int[] states, plus a corresponding\n-// int[] count per state.  Used by\n-// BasicOperations.determinize\n-final class SortedIntSet {\n-  int[] values;\n+// int[] count per state.  Used by Operations.determinize()\n+final class SortedIntSet extends IntSet {\n   int[] counts;\n   int upto;\n-  private int hashCode;\n+\n+  // Tracks if the hashCode computation is out of date and also if the array is out of sync with the map", "originalCommit": "3997ea0d84bc26f2bfd86c5620e289af8638b32e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2OTk4Mg==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r369169982", "bodyText": "The array is used for equality comparison.", "author": "madrob", "createdAt": "2020-01-21T18:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNzIxNg=="}], "type": "inlineReview", "revised_code": {"commit": "e9d83138bafb6425778dcf61be483192804ee8c8", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\nindex efaaea2853b..37e1fe12e8d 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\n\n@@ -16,70 +16,50 @@\n  */\n package org.apache.lucene.util.automaton;\n \n-import java.util.Arrays;\n import java.util.TreeMap;\n import java.util.Map;\n import org.apache.lucene.util.ArrayUtil;\n-import org.apache.lucene.util.SuppressForbidden;\n \n // Just holds a set of int[] states, plus a corresponding\n-// int[] count per state.  Used by Operations.determinize()\n+// int[] count per state.  Used by Operations.determinize\n final class SortedIntSet extends IntSet {\n+  int[] values;\n   int[] counts;\n   int upto;\n-\n-  // Tracks if the hashCode computation is out of date and also if the array is out of sync with the map\n-  boolean stale = true;\n-\n-  int hashCode;\n+  private int hashCode;\n \n   // If we hold more than this many states, we switch from\n   // O(N^2) linear ops to O(N log(N)) TreeMap\n-  private final static int TREE_MAP_CUTOVER = 32;\n+  private final static int TREE_MAP_CUTOVER = 30;\n \n   private final Map<Integer,Integer> map = new TreeMap<>();\n \n   private boolean useTreeMap;\n \n-  public SortedIntSet() {\n-    values = new int[TREE_MAP_CUTOVER];\n-    counts = new int[TREE_MAP_CUTOVER];\n+  SortedIntSet(int capacity) {\n+    values = new int[capacity];\n+    counts = new int[capacity];\n   }\n \n   // Adds this state to the set\n   public void incr(int num) {\n     if (useTreeMap) {\n-      incrMap(num);\n-    } else {\n-      incrArray(num);\n-      if (size() == TREE_MAP_CUTOVER) {\n-        useTreeMap = true;\n-        for(int i = 0; i < upto; i++) {\n-          map.put(values[i], counts[i]);\n-        }\n-      }\n+      map.merge(num, 1, Integer::sum);\n+      return;\n     }\n-  }\n \n-  private void incrMap(int num) {\n-    Integer old;\n-    if ((old = map.get(num)) != null) {\n-      map.put(num, old + 1);\n-    } else {\n-      map.put(num, 1);\n-      stale = true;\n+    if (upto == values.length) {\n+      values = ArrayUtil.grow(values, 1+upto);\n+      counts = ArrayUtil.grow(counts, 1+upto);\n     }\n-  }\n \n-  private void incrArray(int num) {\n-    for(int i=0; i < upto; i++) {\n+    for(int i=0;i<upto;i++) {\n       if (values[i] == num) {\n-        // found value; increment count\n         counts[i]++;\n         return;\n       } else if (num < values[i]) {\n-        // passed sorted value; insert here and shift everything else up\n-        int j = upto - 1;\n+        // insert here\n+        int j = upto-1;\n         while (j >= i) {\n           values[1+j] = values[j];\n           counts[1+j] = counts[j];\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNzgxNw==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r369107817", "bodyText": "Hmm why did we mark this API forbidden again?", "author": "mikemccand", "createdAt": "2020-01-21T16:30:54Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java", "diffHunk": "@@ -149,128 +156,32 @@ public void computeHash() {\n         hashCode = 683*hashCode + values[i];\n       }\n     }\n+    stale = false;\n   }\n \n+  /**\n+   * Create a FrozenIntSet from the current values in this IntSet.\n+   *\n+   * @return a FrozenIntSet that has the same values and hashCode as this set\n+   */\n+  @SuppressForbidden(reason = \"Arrays.copyOf is a candidate for JVM intrinsic and we know our bounds are good\")", "originalCommit": "3997ea0d84bc26f2bfd86c5620e289af8638b32e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI0OTU1Ng==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r369249556", "bodyText": "Because copyOf was considered trappy -- the new length can be larger than original size of the input array (and is then null or zero padded)... I'm not sure it's worth having System.arraycopy instead... Maybe we could have a utility method that assert-verifies newLength <= length and uses Arrays.copyOf. Not sure.", "author": "dweiss", "createdAt": "2020-01-21T21:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNzgxNw=="}], "type": "inlineReview", "revised_code": {"commit": "e9d83138bafb6425778dcf61be483192804ee8c8", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\nindex efaaea2853b..37e1fe12e8d 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\n\n@@ -156,32 +140,48 @@ final class SortedIntSet extends IntSet {\n         hashCode = 683*hashCode + values[i];\n       }\n     }\n-    stale = false;\n   }\n \n   /**\n-   * Create a FrozenIntSet from the current values in this IntSet.\n-   *\n-   * @return a FrozenIntSet that has the same values and hashCode as this set\n+   * Create a snapshot of this int set associated with a given state. The snapshot will not retain any frequency\n+   * information about the elements of this set, only existence.\n+   * <p>\n+   * It is the caller's responsibility to ensure that the hashCode and data are up to date via the {@link #computeHash()} method before calling this method.\n+   * @param state the state to associate with the frozen set.\n+   * @return A new FrozenIntSet with the same values as this set.\n    */\n-  @SuppressForbidden(reason = \"Arrays.copyOf is a candidate for JVM intrinsic and we know our bounds are good\")\n-  public FrozenIntSet freeze(int state) {\n-    int hashCode = hashCode(); // Make sure that we are not stale\n-    final int[] c = Arrays.copyOf(values, upto);\n+  FrozenIntSet freeze(int state) {\n+    final int[] c = ArrayUtil.copyOfSubArray(values, 0, upto);\n     return new FrozenIntSet(c, hashCode, state);\n   }\n \n   @Override\n-  public int size() {\n-    return useTreeMap ? map.size() : upto;\n+  int[] asArray() {\n+      return values;\n+  }\n+\n+  @Override\n+  int size() {\n+    return upto;\n   }\n \n   @Override\n   public int hashCode() {\n-    if (stale) {\n-      computeHash();\n-    }\n     return hashCode;\n   }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder().append('[');\n+    for(int i=0;i<upto;i++) {\n+      if (i > 0) {\n+        sb.append(' ');\n+      }\n+      sb.append(values[i]).append(':').append(counts[i]);\n+    }\n+    sb.append(']');\n+    return sb.toString();\n+  }\n+\n }\n   \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwODMwMQ==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r369108301", "bodyText": "We don't need @Test annotations -- LuceneTestCase runner knows test* methods are tests.", "author": "mikemccand", "createdAt": "2020-01-21T16:31:41Z", "path": "lucene/core/src/test/org/apache/lucene/util/automaton/TestIntSet.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.util.automaton;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import static org.apache.lucene.util.LuceneTestCase.random;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(com.carrotsearch.randomizedtesting.RandomizedRunner.class)\n+public class TestIntSet {\n+    @Test", "originalCommit": "3997ea0d84bc26f2bfd86c5620e289af8638b32e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY5MTA4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r374691089", "bodyText": "I think you can remove these @Test annotations?", "author": "mikemccand", "createdAt": "2020-02-04T14:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwODMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e9d83138bafb6425778dcf61be483192804ee8c8", "chunk": "diff --git a/lucene/core/src/test/org/apache/lucene/util/automaton/TestIntSet.java b/lucene/core/src/test/org/apache/lucene/util/automaton/TestIntSet.java\ndeleted file mode 100644\nindex d96880181a5..00000000000\n--- a/lucene/core/src/test/org/apache/lucene/util/automaton/TestIntSet.java\n+++ /dev/null\n\n@@ -1,86 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.lucene.util.automaton;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-\n-import static org.apache.lucene.util.LuceneTestCase.random;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotEquals;\n-import static org.junit.Assert.assertTrue;\n-\n-@RunWith(com.carrotsearch.randomizedtesting.RandomizedRunner.class)\n-public class TestIntSet {\n-    @Test\n-    public void testFreezeEqualitySmallSet() {\n-        testFreezeEquality(10);\n-    }\n-\n-    @Test\n-    public void testFreezeEqualityLargeSet() {\n-        testFreezeEquality(100);\n-    }\n-\n-    private void testFreezeEquality(int size) {\n-        SortedIntSet sortedSet = new SortedIntSet();\n-\n-        for (int i = 0; i < size; i++) {\n-            // Some duplicates is nice but not critical\n-            sortedSet.incr(random().nextInt(i + 1));\n-        }\n-\n-        IntSet frozen0 = sortedSet.freeze(0);\n-\n-        assertEquals(\"Frozen set not equal to origin sorted set.\", sortedSet, frozen0);\n-        assertEquals(\"Symmetry: Sorted set not equal to frozen set.\", frozen0, sortedSet);\n-\n-        IntSet frozen1 = sortedSet.freeze(random().nextInt());\n-        assertEquals(\"Sorted set modified while freezing?\", sortedSet, frozen1);\n-        assertEquals(\"Frozen sets were not equal\", frozen0, frozen1);\n-    }\n-\n-    @Test\n-    public void testMapCutover() {\n-        SortedIntSet set = new SortedIntSet();\n-        for (int i = 0; i < 35; i++) {\n-            // No duplicates so there are enough elements to trigger impl cutover\n-            set.incr(i);\n-        }\n-\n-        assertTrue(set.size() > 32);\n-    }\n-\n-    @Test\n-    public void testModify() {\n-        SortedIntSet set = new SortedIntSet();\n-        set.incr(1);\n-        set.incr(2);\n-\n-        FrozenIntSet set2 = set.freeze(0);\n-        assertEquals(set, set2);\n-\n-        set.incr(1);\n-        assertEquals(set, set2);\n-\n-        set.decr(1);\n-        assertEquals(set, set2);\n-\n-        set.decr(1);\n-        assertNotEquals(set, set2);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTExMDc1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r369110759", "bodyText": "Would be nice to use a native map from HPPC instead -- does HPPC have a sorted map?  Hmm, but this is core, and we don't have any dependencies in Lucene's core :)", "author": "mikemccand", "createdAt": "2020-01-21T16:35:48Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java", "diffHunk": "@@ -16,59 +16,70 @@\n  */\n package org.apache.lucene.util.automaton;\n \n+import java.util.Arrays;\n import java.util.TreeMap;\n import java.util.Map;\n import org.apache.lucene.util.ArrayUtil;\n+import org.apache.lucene.util.SuppressForbidden;\n \n // Just holds a set of int[] states, plus a corresponding\n-// int[] count per state.  Used by\n-// BasicOperations.determinize\n-final class SortedIntSet {\n-  int[] values;\n+// int[] count per state.  Used by Operations.determinize()\n+final class SortedIntSet extends IntSet {\n   int[] counts;\n   int upto;\n-  private int hashCode;\n+\n+  // Tracks if the hashCode computation is out of date and also if the array is out of sync with the map\n+  boolean stale = true;\n+\n+  int hashCode;\n \n   // If we hold more than this many states, we switch from\n   // O(N^2) linear ops to O(N log(N)) TreeMap\n-  private final static int TREE_MAP_CUTOVER = 30;\n+  private final static int TREE_MAP_CUTOVER = 32;\n \n   private final Map<Integer,Integer> map = new TreeMap<>();", "originalCommit": "3997ea0d84bc26f2bfd86c5620e289af8638b32e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9d83138bafb6425778dcf61be483192804ee8c8", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\nindex efaaea2853b..37e1fe12e8d 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/SortedIntSet.java\n\n@@ -16,70 +16,50 @@\n  */\n package org.apache.lucene.util.automaton;\n \n-import java.util.Arrays;\n import java.util.TreeMap;\n import java.util.Map;\n import org.apache.lucene.util.ArrayUtil;\n-import org.apache.lucene.util.SuppressForbidden;\n \n // Just holds a set of int[] states, plus a corresponding\n-// int[] count per state.  Used by Operations.determinize()\n+// int[] count per state.  Used by Operations.determinize\n final class SortedIntSet extends IntSet {\n+  int[] values;\n   int[] counts;\n   int upto;\n-\n-  // Tracks if the hashCode computation is out of date and also if the array is out of sync with the map\n-  boolean stale = true;\n-\n-  int hashCode;\n+  private int hashCode;\n \n   // If we hold more than this many states, we switch from\n   // O(N^2) linear ops to O(N log(N)) TreeMap\n-  private final static int TREE_MAP_CUTOVER = 32;\n+  private final static int TREE_MAP_CUTOVER = 30;\n \n   private final Map<Integer,Integer> map = new TreeMap<>();\n \n   private boolean useTreeMap;\n \n-  public SortedIntSet() {\n-    values = new int[TREE_MAP_CUTOVER];\n-    counts = new int[TREE_MAP_CUTOVER];\n+  SortedIntSet(int capacity) {\n+    values = new int[capacity];\n+    counts = new int[capacity];\n   }\n \n   // Adds this state to the set\n   public void incr(int num) {\n     if (useTreeMap) {\n-      incrMap(num);\n-    } else {\n-      incrArray(num);\n-      if (size() == TREE_MAP_CUTOVER) {\n-        useTreeMap = true;\n-        for(int i = 0; i < upto; i++) {\n-          map.put(values[i], counts[i]);\n-        }\n-      }\n+      map.merge(num, 1, Integer::sum);\n+      return;\n     }\n-  }\n \n-  private void incrMap(int num) {\n-    Integer old;\n-    if ((old = map.get(num)) != null) {\n-      map.put(num, old + 1);\n-    } else {\n-      map.put(num, 1);\n-      stale = true;\n+    if (upto == values.length) {\n+      values = ArrayUtil.grow(values, 1+upto);\n+      counts = ArrayUtil.grow(counts, 1+upto);\n     }\n-  }\n \n-  private void incrArray(int num) {\n-    for(int i=0; i < upto; i++) {\n+    for(int i=0;i<upto;i++) {\n       if (values[i] == num) {\n-        // found value; increment count\n         counts[i]++;\n         return;\n       } else if (num < values[i]) {\n-        // passed sorted value; insert here and shift everything else up\n-        int j = upto - 1;\n+        // insert here\n+        int j = upto-1;\n         while (j >= i) {\n           values[1+j] = values[j];\n           counts[1+j] = counts[j];\n"}}, {"oid": "e9d83138bafb6425778dcf61be483192804ee8c8", "url": "https://github.com/apache/lucene-solr/commit/e9d83138bafb6425778dcf61be483192804ee8c8", "message": "LUCENE-9142 Refactor SortedIntSet for equality\n\nSplit SortedIntSet into a class heirarchy to make comparisons to\nFrozenIntSet more meaningful. Use Arrays.equals for more efficient\ncomparison.", "committedDate": "2020-01-23T16:17:58Z", "type": "commit"}, {"oid": "e9d83138bafb6425778dcf61be483192804ee8c8", "url": "https://github.com/apache/lucene-solr/commit/e9d83138bafb6425778dcf61be483192804ee8c8", "message": "LUCENE-9142 Refactor SortedIntSet for equality\n\nSplit SortedIntSet into a class heirarchy to make comparisons to\nFrozenIntSet more meaningful. Use Arrays.equals for more efficient\ncomparison.", "committedDate": "2020-01-23T16:17:58Z", "type": "forcePushed"}, {"oid": "0fea83e7c0cbb0eacd08f964335442106ce31bab", "url": "https://github.com/apache/lucene-solr/commit/0fea83e7c0cbb0eacd08f964335442106ce31bab", "message": "LUCENE-9142 Add tests for IntSet", "committedDate": "2020-01-23T18:08:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY4OTI2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r374689263", "bodyText": "Could we rename to getArray?  asArray makes me think it might make a copy ...", "author": "mikemccand", "createdAt": "2020-02-04T14:07:21Z", "path": "lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.util.automaton;\n+\n+import java.util.Arrays;\n+\n+final class FrozenIntSet extends IntSet {\n+  final int[] values;\n+  final int hashCode;\n+  final int state;\n+\n+  FrozenIntSet(int[] values, int hashCode, int state) {\n+    this.values = values;\n+    this.hashCode = hashCode;\n+    this.state = state;\n+  }\n+\n+  @Override\n+  int[] asArray() {", "originalCommit": "0fea83e7c0cbb0eacd08f964335442106ce31bab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMjc5Mw==", "url": "https://github.com/apache/lucene-solr/pull/1184#discussion_r374902793", "bodyText": "In the case of SortedIntSet, it might make a copy, I wanted to leave it flexible for the underlying implementation on how to handles this. Renaming to getArray makes sense though.", "author": "madrob", "createdAt": "2020-02-04T20:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY4OTI2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "1675ea7324b3856c92218ba6c2bbc249f9c172d1", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java b/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java\nindex 35392f99f6e..02da6647a75 100644\n--- a/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java\n+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/FrozenIntSet.java\n\n@@ -30,7 +30,7 @@ final class FrozenIntSet extends IntSet {\n   }\n \n   @Override\n-  int[] asArray() {\n+  int[] getArray() {\n     return values;\n   }\n \n"}}, {"oid": "1675ea7324b3856c92218ba6c2bbc249f9c172d1", "url": "https://github.com/apache/lucene-solr/commit/1675ea7324b3856c92218ba6c2bbc249f9c172d1", "message": "LUCENE-9142 Review feedback", "committedDate": "2020-02-04T20:32:50Z", "type": "commit"}]}