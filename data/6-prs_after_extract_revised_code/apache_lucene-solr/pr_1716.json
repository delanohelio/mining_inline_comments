{"pr_number": 1716, "pr_title": "SOLR-14706: Fix support for default autoscaling policy", "pr_createdAt": "2020-08-04T15:41:07Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1716", "timeline": [{"oid": "cf2b30bcb19e6b97310af76cf6d48488d52f2122", "url": "https://github.com/apache/lucene-solr/commit/cf2b30bcb19e6b97310af76cf6d48488d52f2122", "message": "SOLR-14706: Fix support for default autoscaling policy", "committedDate": "2020-08-04T15:31:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NjU5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1716#discussion_r465146599", "bodyText": "I brought this back in from the revert because it looks like an improvement that was unrelated to the default policy.\nI'm happy to remove it if y'all think I should.", "author": "HoustonPutman", "createdAt": "2020-08-04T15:42:17Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause.java", "diffHunk": "@@ -686,7 +686,7 @@ boolean isShardAbsent() {\n       for (Row r : session.matrix) {\n         computedValueEvaluator.node = r.node;\n         SealedClause sealedClause = getSealedClause(computedValueEvaluator);\n-        if (!sealedClause.getGlobalTag().isPass(r)) {\n+        if (r.isLive() && !sealedClause.getGlobalTag().isPass(r)) {", "originalCommit": "cf2b30bcb19e6b97310af76cf6d48488d52f2122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "af7c31321199ef583601836fdcd0b149425d8eb2", "url": "https://github.com/apache/lucene-solr/commit/af7c31321199ef583601836fdcd0b149425d8eb2", "message": "Adding info to upgrade notes.", "committedDate": "2020-08-04T19:32:54Z", "type": "commit"}, {"oid": "e1606b63a17d7de4b7c838a7bb2b3446c05ded51", "url": "https://github.com/apache/lucene-solr/commit/e1606b63a17d7de4b7c838a7bb2b3446c05ded51", "message": "Updating wording of upgrade notes.", "committedDate": "2020-08-05T14:23:17Z", "type": "commit"}, {"oid": "effbbcac0fbae034e25fd8c1a6047f98f349a27d", "url": "https://github.com/apache/lucene-solr/commit/effbbcac0fbae034e25fd8c1a6047f98f349a27d", "message": "Adding back in old functionality and making error message better.", "committedDate": "2020-08-05T16:10:07Z", "type": "commit"}, {"oid": "9b7a3884ffb9ce3f244c1a08e9b5681f7e440705", "url": "https://github.com/apache/lucene-solr/commit/9b7a3884ffb9ce3f244c1a08e9b5681f7e440705", "message": "Adding missing import.", "committedDate": "2020-08-05T16:29:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MTEwOQ==", "url": "https://github.com/apache/lucene-solr/pull/1716#discussion_r465871109", "bodyText": "from my very limited understanding of this code it appears that something like\n    if (globalTagName.isPresent()) {\n      validateGlobalTag(m, globalTagName.get());\n      globalTag = parse(globalTagName.get(), m);\n ...\nand \n...\n  private void validateGlobalTag(Map<String, Object> m, String tagName) {\n    if (m.size() > 2) {\n      if (!m.containsKey(\"strict\") || m.size() > 3) {\n        throw new RuntimeException(\"Only, 'strict' and one extra tag supported for the tag \" + tagName + \" in \" + toJSONString(m));\n      }\n    }\n  }\n\nwould be the real intention here... but it would be great if @sigram could confirm that.", "author": "gus-asf", "createdAt": "2020-08-05T16:58:53Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause.java", "diffHunk": "@@ -117,10 +117,10 @@ private Clause(Map<String, Object> m) {\n     strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n     Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n     if (globalTagName.isPresent()) {\n-      globalTag = parse(globalTagName.get(), m);\n-      if (m.size() > 2) {\n-        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n+      if (m.size() > 3) {", "originalCommit": "9b7a3884ffb9ce3f244c1a08e9b5681f7e440705", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwNTM0OQ==", "url": "https://github.com/apache/lucene-solr/pull/1716#discussion_r466605349", "bodyText": "@gus-asf yes, that's the intent, though your pseudo-code is still incorrect - if there's no strict tag then m.size() > 2 is already an error. In other words, for global tags we expect exactly 2 keys (tag and operand), with optional third key strict.", "author": "sigram", "createdAt": "2020-08-06T18:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MTEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1NzM0OA==", "url": "https://github.com/apache/lucene-solr/pull/1716#discussion_r466657348", "bodyText": "I think that's the logic Gus used. It's equivalent to:\nprivate void validateGlobalTag(Map<String, Object> m, String tagName) {\n    if (m.size() > 2) {\n      if (!(m.containsKey(\"strict\") && m.size() == 3)) {\n        throw new RuntimeException(\"Only, 'strict' and one extra tag supported for the tag \" + tagName + \" in \" + toJSONString(m));\n      }\n    }\n  }\nThis will error unless there are exactly 3 keys and once of them is strict.", "author": "HoustonPutman", "createdAt": "2020-08-06T20:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MTEwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "a63aec648a9a0fbc2aa5df64df19cefa8593a577", "chunk": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause.java b/solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause.java\nindex e87af5afccc..4109eeaa3fb 100644\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause.java\n+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause.java\n\n@@ -117,8 +117,11 @@ public class Clause implements MapWriter, Comparable<Clause> {\n     strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n     Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n     if (globalTagName.isPresent()) {\n-      if (m.size() > 3) {\n-        throw new RuntimeException(\"Only two extra tags supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n+      if (m.size() > 2) {\n+        // 3 keys are allowed only if one of them is 'strict'\n+        if (!m.containsKey(\"strict\") || m.size() > 3) {\n+          throw new RuntimeException(\"Only, 'strict' and one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n+        }\n       }\n       globalTag = parse(globalTagName.get(), m);\n       tag = parse(m.keySet().stream()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwNTc3MA==", "url": "https://github.com/apache/lucene-solr/pull/1716#discussion_r466605770", "bodyText": "+1, this was a genuine bug in 8.5.", "author": "sigram", "createdAt": "2020-08-06T18:28:10Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause.java", "diffHunk": "@@ -686,7 +686,7 @@ boolean isShardAbsent() {\n       for (Row r : session.matrix) {\n         computedValueEvaluator.node = r.node;\n         SealedClause sealedClause = getSealedClause(computedValueEvaluator);\n-        if (!sealedClause.getGlobalTag().isPass(r)) {\n+        if (r.isLive() && !sealedClause.getGlobalTag().isPass(r)) {", "originalCommit": "9b7a3884ffb9ce3f244c1a08e9b5681f7e440705", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwNjI1Ng==", "url": "https://github.com/apache/lucene-solr/pull/1716#discussion_r466606256", "bodyText": "+1, this fixed a genuine bug in < 8.6.0", "author": "sigram", "createdAt": "2020-08-06T18:29:04Z", "path": "solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimScenario.java", "diffHunk": "@@ -814,7 +814,9 @@ public void execute(SimScenario scenario) throws Exception {\n         values.put(key, val);\n       }\n       for (String node : nodes) {\n-        scenario.cluster.getSimNodeStateProvider().simSetNodeValues(node, values);\n+        Map<String, Object> newValues = new HashMap<>(scenario.cluster.getSimNodeStateProvider().simGetNodeValues(node));", "originalCommit": "9b7a3884ffb9ce3f244c1a08e9b5681f7e440705", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "a63aec648a9a0fbc2aa5df64df19cefa8593a577", "url": "https://github.com/apache/lucene-solr/commit/a63aec648a9a0fbc2aa5df64df19cefa8593a577", "message": "Using Gus' logic.", "committedDate": "2020-08-07T16:07:53Z", "type": "commit"}, {"oid": "cb079fa90ecc04b980e0de245ffb4ca759d2be1b", "url": "https://github.com/apache/lucene-solr/commit/cb079fa90ecc04b980e0de245ffb4ca759d2be1b", "message": "Updating changes.txt", "committedDate": "2020-08-07T16:17:04Z", "type": "commit"}]}