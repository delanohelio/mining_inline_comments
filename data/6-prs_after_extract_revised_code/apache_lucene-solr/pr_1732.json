{"pr_number": 1732, "pr_title": "Clean up many small fixes", "pr_createdAt": "2020-08-10T18:42:20Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1732", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjI0Ng==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468106246", "bodyText": "Can you not change those scopes in public API classes? This applies here and in other places -- protected changed to package-scope for source is not really an API-compatible change.", "author": "dweiss", "createdAt": "2020-08-10T18:46:05Z", "path": "lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java", "diffHunk": "@@ -94,7 +94,7 @@\n    * Create a new Analyzer, reusing the same set of components per-thread\n    * across calls to {@link #tokenStream(String, Reader)}. \n    */\n-  public Analyzer() {", "originalCommit": "fc43993f1962dcf4e907c85f5a2b85b239b8fad2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMDUzNQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468220535", "bodyText": "I understand that it's notionally an API change, but abstract classes have no reason for public constructors. We can make everything protected and the subclasses that people use will be able to pick it up. I was over-zealous in a couple places going to package instead of protected, I'll fix that up.", "author": "madrob", "createdAt": "2020-08-10T22:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2NjgwOQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468366809", "bodyText": "The constructors I understand, fine (although it's really a no-op change, as you indicated).", "author": "dweiss", "createdAt": "2020-08-11T06:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjI0Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjY0Mw==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468106643", "bodyText": "This is wrong, uses default locale.", "author": "dweiss", "createdAt": "2020-08-10T18:46:51Z", "path": "lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java", "diffHunk": "@@ -709,7 +709,7 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n \n           PendingTerm term = (PendingTerm) ent;\n \n-          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;\n+          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + new String(term.termBytes) + \" prefix=\" + prefix;", "originalCommit": "fc43993f1962dcf4e907c85f5a2b85b239b8fad2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMDY4NA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468220684", "bodyText": "Are these UTF-8? I wasn't sure, and hoped somebody would let me know during review.", "author": "madrob", "createdAt": "2020-08-10T22:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2NzE0OA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468367148", "bodyText": "They should be. You can also dump it as a byte array for consistency with other changes you made.", "author": "dweiss", "createdAt": "2020-08-11T07:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java\nindex d6bc28b514b..c05daeb296c 100644\n--- a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java\n+++ b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java\n\n@@ -709,7 +709,7 @@ public final class BlockTreeTermsWriter extends FieldsConsumer {\n \n           PendingTerm term = (PendingTerm) ent;\n \n-          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + new String(term.termBytes) + \" prefix=\" + prefix;\n+          assert StringHelper.startsWith(term.termBytes, prefix): term + \" prefix=\" + prefix;\n           BlockTermState state = term.state;\n           final int suffix = term.termBytes.length - prefixLength;\n           //if (DEBUG2) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNzM2OA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468107368", "bodyText": "previous version was correct camel case (upTo).", "author": "dweiss", "createdAt": "2020-08-10T18:48:22Z", "path": "lucene/core/src/java/org/apache/lucene/index/DocValuesUpdate.java", "diffHunk": "@@ -152,12 +152,12 @@ static BytesRef readFrom(DataInput in, BytesRef scratch) throws IOException {\n     }\n \n     NumericDocValuesUpdate(Term term, String field, Long value) {\n-      this(term, field, value != null ? value.longValue() : -1, BufferedUpdates.MAX_INT, value != null);\n+      this(term, field, value != null ? value : -1, BufferedUpdates.MAX_INT, value != null);\n     }\n \n \n-    private NumericDocValuesUpdate(Term term, String field, long value, int docIDUpTo, boolean hasValue) {", "originalCommit": "fc43993f1962dcf4e907c85f5a2b85b239b8fad2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMTYzMA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468221630", "bodyText": "There were 16 instances of Upto and 4 of UpTo so I went with the more common one for consistency. Happy to switch the other way if it's more correct according to English. Looking it up now and looks like \"upto\" isn't a word?", "author": "madrob", "createdAt": "2020-08-10T22:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNzM2OA=="}], "type": "inlineReview", "revised_code": {"commit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/DocValuesUpdate.java b/lucene/core/src/java/org/apache/lucene/index/DocValuesUpdate.java\nindex b4bfc87393d..f140a5febb6 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/DocValuesUpdate.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/DocValuesUpdate.java\n\n@@ -156,16 +156,16 @@ abstract class DocValuesUpdate {\n     }\n \n \n-    private NumericDocValuesUpdate(Term term, String field, long value, int docIDUpto, boolean hasValue) {\n-      super(DocValuesType.NUMERIC, term, field, docIDUpto, hasValue);\n+    private NumericDocValuesUpdate(Term term, String field, long value, int docIDUpTo, boolean hasValue) {\n+      super(DocValuesType.NUMERIC, term, field, docIDUpTo, hasValue);\n       this.value = value;\n     }\n \n-    NumericDocValuesUpdate prepareForApply(int docIDUpto) {\n-      if (docIDUpto == this.docIDUpto) {\n+    NumericDocValuesUpdate prepareForApply(int docIDUpTo) {\n+      if (docIDUpTo == this.docIDUpTo) {\n         return this;\n       }\n-      return new NumericDocValuesUpdate(term, field, value, docIDUpto, hasValue);\n+      return new NumericDocValuesUpdate(term, field, value, docIDUpTo, hasValue);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwODI0MQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468108241", "bodyText": "These are serious changes... you're adding synchronization on core classes. I don't think they should be piggybacked on top of trivial ones - I'm sure @s1monw would chip in whether this synchronization here makes sense but he'll probably overlook if it's a bulk of trivial changes on top.", "author": "dweiss", "createdAt": "2020-08-10T18:49:59Z", "path": "lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java", "diffHunk": "@@ -324,12 +324,12 @@ synchronized void doOnAbort(DocumentsWriterPerThread perThread) {\n     }\n   }\n \n-  private void checkoutAndBlock(DocumentsWriterPerThread perThread) {\n+  private synchronized void checkoutAndBlock(DocumentsWriterPerThread perThread) {", "originalCommit": "fc43993f1962dcf4e907c85f5a2b85b239b8fad2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMTY5MQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468221691", "bodyText": "I'll split this out.", "author": "madrob", "createdAt": "2020-08-10T22:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwODI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNzA5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468227099", "bodyText": "https://issues.apache.org/jira/browse/LUCENE-9453 I explain in that issue why I believe it is minor, but it will help to get more eyes on it", "author": "madrob", "createdAt": "2020-08-10T22:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwODI0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java\nindex 56187090968..5684bf42b0f 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java\n\n@@ -324,7 +324,11 @@ final class DocumentsWriterFlushControl implements Accountable, Closeable {\n     }\n   }\n \n-  private synchronized void checkoutAndBlock(DocumentsWriterPerThread perThread) {\n+  /**\n+   * To be called only by the owner of this object's monitor lock\n+   */\n+  private void checkoutAndBlock(DocumentsWriterPerThread perThread) {\n+    assert Thread.holdsLock(this);\n     assert perThreadPool.isRegistered(perThread);\n     assert perThread.isHeldByCurrentThread();\n     assert perThread.isFlushPending() : \"can not block non-pending threadstate\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2OTQwMA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468369400", "bodyText": "Leave this as it was (with throw ...) - don't know whether IntelliJ is smart enough to detect this method always throws an exception but other compilers are not (and this ensures the compiler sees it as a the only codepath leaving the clause).", "author": "dweiss", "createdAt": "2020-08-11T07:05:48Z", "path": "lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java", "diffHunk": "@@ -440,7 +440,7 @@ public static final SegmentInfos readCommit(Directory directory, ChecksumIndexIn\n       if (format >= VERSION_70) { // oldest supported version\n         CodecUtil.checkFooter(input, priorE);\n       } else {\n-        throw IOUtils.rethrowAlways(priorE);", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYzMTM5NA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468631394", "bodyText": "The original compiler complaint was that the throw is inside the finally block. Could I replace the \"Unreachable code\" at the end with this rethrow? I believe the logic will be the same.", "author": "madrob", "createdAt": "2020-08-11T14:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2OTQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMTU5MA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r469031590", "bodyText": "And what's wrong about a throw from within finally? A finally block is technically just a block of code, like any other. The compiler very likely assumes you're suppressing an exception if you throw from within finally but it's not the case here.\nI don't know if moving that throw will change the logic. Maybe not. Maybe yes. Given the two options, I wouldn't touch it. My concern was that you slipped such things as part of an otherwise \"trivial\" set of patches.", "author": "dweiss", "createdAt": "2020-08-12T06:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2OTQwMA=="}], "type": "inlineReview", "revised_code": {"commit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java b/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java\nindex af4a87cd0a8..d97748131b4 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java\n\n@@ -440,7 +440,7 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentCommitInfo\n       if (format >= VERSION_70) { // oldest supported version\n         CodecUtil.checkFooter(input, priorE);\n       } else {\n-        IOUtils.rethrowAlways(priorE);\n+        throw IOUtils.rethrowAlways(priorE);\n       }\n     }\n     throw new Error(\"Unreachable code\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MDc1Mg==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468370752", "bodyText": "that 'term' class (PendingTerm) actually has a perfectly fine toString method... why not just remove termBytes and let it do its job?", "author": "dweiss", "createdAt": "2020-08-11T07:08:50Z", "path": "lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java", "diffHunk": "@@ -709,7 +710,8 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n \n           PendingTerm term = (PendingTerm) ent;\n \n-          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java\nindex 5e1c3074484..c05daeb296c 100644\n--- a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java\n+++ b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java\n\n@@ -710,8 +709,7 @@ public final class BlockTreeTermsWriter extends FieldsConsumer {\n \n           PendingTerm term = (PendingTerm) ent;\n \n-          assert StringHelper.startsWith(term.termBytes, prefix):\n-                  \"term.term=\" + new String(term.termBytes, StandardCharsets.UTF_8) + \" prefix=\" + prefix;\n+          assert StringHelper.startsWith(term.termBytes, prefix): term + \" prefix=\" + prefix;\n           BlockTermState state = term.state;\n           final int suffix = term.termBytes.length - prefixLength;\n           //if (DEBUG2) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MDgxNQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468370815", "bodyText": "Same here.", "author": "dweiss", "createdAt": "2020-08-11T07:08:59Z", "path": "lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java", "diffHunk": "@@ -741,7 +743,8 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n           if (ent.isTerm) {\n             PendingTerm term = (PendingTerm) ent;\n \n-            assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java\nindex 5e1c3074484..c05daeb296c 100644\n--- a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java\n+++ b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java\n\n@@ -743,8 +741,7 @@ public final class BlockTreeTermsWriter extends FieldsConsumer {\n           if (ent.isTerm) {\n             PendingTerm term = (PendingTerm) ent;\n \n-            assert StringHelper.startsWith(term.termBytes, prefix):\n-                    \"term.term=\" + new String(term.termBytes, StandardCharsets.UTF_8) + \" prefix=\" + prefix;\n+            assert StringHelper.startsWith(term.termBytes, prefix): term + \" prefix=\" + prefix;\n             BlockTermState state = term.state;\n             final int suffix = term.termBytes.length - prefixLength;\n             //if (DEBUG2) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTE2Mg==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468371162", "bodyText": "Don't change to package private scope here. It will prevent subclasses from outside of the package from accessing those fields (and there may be classes outside of Lucene code doing that).", "author": "dweiss", "createdAt": "2020-08-11T07:09:47Z", "path": "lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java", "diffHunk": "@@ -367,12 +367,12 @@ public void close() {\n     /**\n      * Original source of the tokens.\n      */\n-    protected final Consumer<Reader> source;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3NDc3OQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468374779", "bodyText": "Removing this would break many outside analyzers. I know it's seldom that analyzers access these fields, but this is a real backward breaking change. Don't do this.\nI have no problem with the ctors, but here it's serious! Why did Intellij suggest a change like that? Looks like it was not so intelligent. \ud83e\udd28", "author": "uschindler", "createdAt": "2020-08-11T07:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3NjA2OA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468376068", "bodyText": "There's also no risk somebody could do anything wrong. It's both (also next one) final field and the it's for consuming only.", "author": "uschindler", "createdAt": "2020-08-11T07:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYyMjg3Nw==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468622877", "bodyText": "I think it's because the field is final and there is a getter for it, so the code analyzer prefers encapsulation?", "author": "madrob", "createdAt": "2020-08-11T14:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNzkzOA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r469027938", "bodyText": "Maybe. It doesn't matter though - this changes the API of a class that's been there for ages. I bet there is a class out there somewhere (let's say A extends Analyzer) and another one (B extends A) where A overrides the getter but B reaches out for the original field. Do we want this to break just to hide a field that can be useful for subclasses just to silence an automatic code inspection? I don't think we should.", "author": "dweiss", "createdAt": "2020-08-12T06:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTE2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java b/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java\nindex eec8fbafc40..53a305c3748 100644\n--- a/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java\n+++ b/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java\n\n@@ -367,12 +367,12 @@ public abstract class Analyzer implements Closeable {\n     /**\n      * Original source of the tokens.\n      */\n-    final Consumer<Reader> source;\n+    protected final Consumer<Reader> source;\n     /**\n      * Sink tokenstream, such as the outer tokenfilter decorating\n      * the chain. This can be the source if there are no filters.\n      */\n-    final TokenStream sink;\n+    protected final TokenStream sink;\n     \n     /** Internal cache only used by {@link Analyzer#tokenStream(String, String)}. */\n     transient ReusableStringReader reusableStringReader;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTIyNA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468371224", "bodyText": "Same here.", "author": "dweiss", "createdAt": "2020-08-11T07:09:55Z", "path": "lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java", "diffHunk": "@@ -367,12 +367,12 @@ public void close() {\n     /**\n      * Original source of the tokens.\n      */\n-    protected final Consumer<Reader> source;\n+    final Consumer<Reader> source;\n     /**\n      * Sink tokenstream, such as the outer tokenfilter decorating\n      * the chain. This can be the source if there are no filters.\n      */\n-    protected final TokenStream sink;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java b/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java\nindex eec8fbafc40..53a305c3748 100644\n--- a/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java\n+++ b/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java\n\n@@ -367,12 +367,12 @@ public abstract class Analyzer implements Closeable {\n     /**\n      * Original source of the tokens.\n      */\n-    final Consumer<Reader> source;\n+    protected final Consumer<Reader> source;\n     /**\n      * Sink tokenstream, such as the outer tokenfilter decorating\n      * the chain. This can be the source if there are no filters.\n      */\n-    final TokenStream sink;\n+    protected final TokenStream sink;\n     \n     /** Internal cache only used by {@link Analyzer#tokenStream(String, String)}. */\n     transient ReusableStringReader reusableStringReader;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTQ1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468371459", "bodyText": "term has a toString method - use it.", "author": "dweiss", "createdAt": "2020-08-11T07:10:22Z", "path": "lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java", "diffHunk": "@@ -604,7 +605,7 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n           assert ent.isTerm: \"i=\" + i;\n \n           PendingTerm term = (PendingTerm) ent;\n-          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "chunk": "diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java b/lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java\nindex c84fe90a5ed..6ce567b3d8e 100644\n--- a/lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java\n+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java\n\n@@ -605,7 +604,7 @@ public final class OrdsBlockTreeTermsWriter extends FieldsConsumer {\n           assert ent.isTerm: \"i=\" + i;\n \n           PendingTerm term = (PendingTerm) ent;\n-          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + Arrays.toString(term.termBytes) + \" prefix=\" + prefix;\n+          assert StringHelper.startsWith(term.termBytes, prefix): term + \" prefix=\" + prefix;\n           BlockTermState state = term.state;\n           final int suffix = term.termBytes.length - prefixLength;\n           /*\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTQ5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468371496", "bodyText": "term has a toString method - use it.", "author": "dweiss", "createdAt": "2020-08-11T07:10:26Z", "path": "lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java", "diffHunk": "@@ -640,7 +641,7 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n           PendingEntry ent = pending.get(i);\n           if (ent.isTerm) {\n             PendingTerm term = (PendingTerm) ent;\n-            assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "chunk": "diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java b/lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java\nindex c84fe90a5ed..6ce567b3d8e 100644\n--- a/lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java\n+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java\n\n@@ -641,7 +640,7 @@ public final class OrdsBlockTreeTermsWriter extends FieldsConsumer {\n           PendingEntry ent = pending.get(i);\n           if (ent.isTerm) {\n             PendingTerm term = (PendingTerm) ent;\n-            assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + Arrays.toString(term.termBytes) + \" prefix=\" + prefix;\n+            assert StringHelper.startsWith(term.termBytes, prefix): term + \" prefix=\" + prefix;\n             BlockTermState state = term.state;\n             final int suffix = term.termBytes.length - prefixLength;\n             /*\n"}}, {"oid": "f1bc86221bcab1095b29128cf99307e83e60eaba", "url": "https://github.com/apache/lucene-solr/commit/f1bc86221bcab1095b29128cf99307e83e60eaba", "message": "Clean up many small fixes\n\n* Abstract classes don't need public constructors since they can only be\n  called by subclasses\n* Don't escape html characters in @code tags in javadoc\n* Fixed a few int/long arithmetic\n* Use explicit Term.toString instead of implicit byte[].toString\n* Javadoc typos\n* Consistent capitalization for field and parameter names", "committedDate": "2020-08-16T02:25:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTEwNw==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r471075107", "bodyText": "I didn't look at the code but this looks suspicious. The reordering here changes happens-before relationship between these statements. Please leave the order of assignment of tail as it was (inside the locked block).", "author": "dweiss", "createdAt": "2020-08-16T06:59:19Z", "path": "lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue.java", "diffHunk": "@@ -510,8 +510,8 @@ public String toString() {\n   }\n   \n   private boolean forceApplyGlobalSlice() {", "originalCommit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea68d599aa5ad0705228365af0592d5cc861a84d", "chunk": "diff --git a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue.java b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue.java\nindex fa36bb00d35..cb3db7a0ff7 100644\n--- a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue.java\n+++ b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue.java\n\n@@ -510,8 +510,8 @@ final class DocumentsWriterDeleteQueue implements Accountable, Closeable {\n   }\n   \n   private boolean forceApplyGlobalSlice() {\n-    final Node<?> currentTail = tail;\n     globalBufferLock.lock();\n+    final Node<?> currentTail = tail;\n     try {\n       if (globalSlice.sliceTail != currentTail) {\n         globalSlice.sliceTail = currentTail;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTUwNg==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r471075506", "bodyText": "inconsistent with other calls (should use term.toString())?", "author": "dweiss", "createdAt": "2020-08-16T07:03:34Z", "path": "lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java", "diffHunk": "@@ -582,7 +583,7 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n           assert ent.isTerm: \"i=\" + i;\n \n           PendingTerm term = (PendingTerm) ent;\n-          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;\n+          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + Arrays.toString(term.termBytes) + \" prefix=\" + prefix;", "originalCommit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2MDcyOA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r473360728", "bodyText": "yikes, thank you.", "author": "madrob", "createdAt": "2020-08-19T21:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTUwNg=="}], "type": "inlineReview", "revised_code": {"commit": "ea68d599aa5ad0705228365af0592d5cc861a84d", "chunk": "diff --git a/lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java b/lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java\nindex ad93a826666..19e30a9b7c0 100644\n--- a/lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java\n+++ b/lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java\n\n@@ -583,7 +582,7 @@ public final class VersionBlockTreeTermsWriter extends FieldsConsumer {\n           assert ent.isTerm: \"i=\" + i;\n \n           PendingTerm term = (PendingTerm) ent;\n-          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + Arrays.toString(term.termBytes) + \" prefix=\" + prefix;\n+          assert StringHelper.startsWith(term.termBytes, prefix): term + \" prefix=\" + prefix;\n           BlockTermState state = term.state;\n           maxVersionInBlock = Math.max(maxVersionInBlock, ((IDVersionTermState) state).idVersion);\n           final int suffix = term.termBytes.length - prefixLength;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTUzMg==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r471075532", "bodyText": "term.toString() again?", "author": "dweiss", "createdAt": "2020-08-16T07:03:53Z", "path": "lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java", "diffHunk": "@@ -610,7 +611,7 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n           PendingEntry ent = pending.get(i);\n           if (ent.isTerm) {\n             PendingTerm term = (PendingTerm) ent;\n-            assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;\n+            assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + Arrays.toString(term.termBytes) + \" prefix=\" + prefix;", "originalCommit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea68d599aa5ad0705228365af0592d5cc861a84d", "chunk": "diff --git a/lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java b/lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java\nindex ad93a826666..19e30a9b7c0 100644\n--- a/lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java\n+++ b/lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java\n\n@@ -611,7 +610,7 @@ public final class VersionBlockTreeTermsWriter extends FieldsConsumer {\n           PendingEntry ent = pending.get(i);\n           if (ent.isTerm) {\n             PendingTerm term = (PendingTerm) ent;\n-            assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + Arrays.toString(term.termBytes) + \" prefix=\" + prefix;\n+            assert StringHelper.startsWith(term.termBytes, prefix): term + \" prefix=\" + prefix;\n             BlockTermState state = term.state;\n             maxVersionInBlock = Math.max(maxVersionInBlock, ((IDVersionTermState) state).idVersion);\n             final int suffix = term.termBytes.length - prefixLength;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTY3NA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r471075674", "bodyText": "Since you're cleaning up I think it'd be better to use assertThrows() with lambda...", "author": "dweiss", "createdAt": "2020-08-16T07:05:26Z", "path": "lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase.java", "diffHunk": "@@ -504,8 +504,8 @@ protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) thr\n           }\n           try {", "originalCommit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM5NDEzNw==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r473394137", "bodyText": "So it turns out be be less clean, since two of the implementations throw IllegalStateException and two throw AssertionError.", "author": "madrob", "createdAt": "2020-08-19T22:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxMzczOQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r473913739", "bodyText": "@jpountz  may be interested in why this is inconsistent between implementations?", "author": "dweiss", "createdAt": "2020-08-20T11:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTY3NA=="}], "type": "inlineReview", "revised_code": {"commit": "ea68d599aa5ad0705228365af0592d5cc861a84d", "chunk": "diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase.java\nindex 17d03afa149..4de16b6a9bd 100644\n--- a/lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase.java\n+++ b/lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase.java\n\n@@ -460,55 +462,48 @@ public abstract class BaseTermVectorsFormatTestCase extends BaseIndexFileFormatT\n         assertEquals(0, docsAndPositionsEnum.nextDoc());\n         final int freq = docsAndPositionsEnum.freq();\n         assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n-        if (docsAndPositionsEnum != null) {\n-          for (int k = 0; k < freq; ++k) {\n-            final int position = docsAndPositionsEnum.nextPosition();\n-            final Set<Integer> indexes;\n-            if (terms.hasPositions()) {\n-              indexes = tk.positionToTerms.get(position);\n-              assertNotNull(indexes);\n-            } else {\n-              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n-              assertNotNull(indexes);\n-            }\n-            if (terms.hasPositions()) {\n-              boolean foundPosition = false;\n-              for (int index : indexes) {\n-                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n-                  foundPosition = true;\n-                  break;\n-                }\n+        for (int k = 0; k < freq; ++k) {\n+          final int position = docsAndPositionsEnum.nextPosition();\n+          final Set<Integer> indexes;\n+          if (terms.hasPositions()) {\n+            indexes = tk.positionToTerms.get(position);\n+            assertNotNull(indexes);\n+          } else {\n+            indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n+            assertNotNull(indexes);\n+          }\n+          if (terms.hasPositions()) {\n+            boolean foundPosition = false;\n+            for (int index : indexes) {\n+              if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n+                foundPosition = true;\n+                break;\n               }\n-              assertTrue(foundPosition);\n             }\n-            if (terms.hasOffsets()) {\n-              boolean foundOffset = false;\n-              for (int index : indexes) {\n-                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n-                  foundOffset = true;\n-                  break;\n-                }\n+            assertTrue(foundPosition);\n+          }\n+          if (terms.hasOffsets()) {\n+            boolean foundOffset = false;\n+            for (int index : indexes) {\n+              if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n+                foundOffset = true;\n+                break;\n               }\n-              assertTrue(foundOffset);\n             }\n-            if (terms.hasPayloads()) {\n-              boolean foundPayload = false;\n-              for (int index : indexes) {\n-                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n-                  foundPayload = true;\n-                  break;\n-                }\n+            assertTrue(foundOffset);\n+          }\n+          if (terms.hasPayloads()) {\n+            boolean foundPayload = false;\n+            for (int index : indexes) {\n+              if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n+                foundPayload = true;\n+                break;\n               }\n-              assertTrue(foundPayload);\n             }\n-          }\n-          try {\n-            docsAndPositionsEnum.nextPosition();\n-            fail(\"Should have thrown when there is no next position\");\n-          } catch (Exception e) {\n-            // ok\n+            assertTrue(foundPayload);\n           }\n         }\n+        expectThrows(getReadPastLastPositionExceptionClass(), docsAndPositionsEnum::nextPosition);\n         assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n       }\n       this.docsEnum.set(docsAndPositionsEnum);\n"}}, {"oid": "ea68d599aa5ad0705228365af0592d5cc861a84d", "url": "https://github.com/apache/lucene-solr/commit/ea68d599aa5ad0705228365af0592d5cc861a84d", "message": "Clean up many small fixes\n\n* Abstract classes don't need public constructors since they can only be\n  called by subclasses\n* Don't escape html characters in @code tags in javadoc\n* Fixed a few int/long arithmetic\n* Use explicit Term.toString instead of implicit byte[].toString\n* Javadoc typos\n* Consistent capitalization for field and parameter names", "committedDate": "2020-09-04T15:34:57Z", "type": "commit"}, {"oid": "ea68d599aa5ad0705228365af0592d5cc861a84d", "url": "https://github.com/apache/lucene-solr/commit/ea68d599aa5ad0705228365af0592d5cc861a84d", "message": "Clean up many small fixes\n\n* Abstract classes don't need public constructors since they can only be\n  called by subclasses\n* Don't escape html characters in @code tags in javadoc\n* Fixed a few int/long arithmetic\n* Use explicit Term.toString instead of implicit byte[].toString\n* Javadoc typos\n* Consistent capitalization for field and parameter names", "committedDate": "2020-09-04T15:34:57Z", "type": "forcePushed"}]}