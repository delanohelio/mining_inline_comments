{"pr_number": 9944, "pr_title": "Session based optimizer configuration", "pr_createdAt": "2020-05-13T10:03:59Z", "pr_url": "https://github.com/crate/crate/pull/9944", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwMzQ5MQ==", "url": "https://github.com/crate/crate/pull/9944#discussion_r424403491", "bodyText": "A volatile would also work - no CAS operation are used.", "author": "mfussenegger", "createdAt": "2020-05-13T12:39:08Z", "path": "sql/src/main/java/io/crate/planner/operators/RewriteInsertFromSubQueryToInsertFromValues.java", "diffHunk": "@@ -23,22 +23,26 @@\n package io.crate.planner.operators;\n \n import io.crate.expression.tablefunctions.ValuesFunction;\n+import io.crate.metadata.Functions;\n import io.crate.metadata.TransactionContext;\n import io.crate.planner.optimizer.Rule;\n import io.crate.planner.optimizer.matcher.Capture;\n import io.crate.planner.optimizer.matcher.Captures;\n import io.crate.planner.optimizer.matcher.Pattern;\n import io.crate.statistics.TableStats;\n \n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import static io.crate.planner.optimizer.matcher.Pattern.typeOf;\n import static io.crate.planner.optimizer.matcher.Patterns.source;\n \n public class RewriteInsertFromSubQueryToInsertFromValues implements Rule<Insert> {\n \n     private final Capture<TableFunction> capture;\n     private final Pattern<Insert> pattern;\n+    private final AtomicBoolean enabled = new AtomicBoolean(true);", "originalCommit": "121dd8cb86c8271a7c3e1a9521020a818b979164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/operators/RewriteInsertFromSubQueryToInsertFromValues.java b/sql/src/main/java/io/crate/planner/operators/RewriteInsertFromSubQueryToInsertFromValues.java\ndeleted file mode 100644\nindex 0f6f12b1b8..0000000000\n--- a/sql/src/main/java/io/crate/planner/operators/RewriteInsertFromSubQueryToInsertFromValues.java\n+++ /dev/null\n\n@@ -1,80 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.planner.operators;\n-\n-import io.crate.expression.tablefunctions.ValuesFunction;\n-import io.crate.metadata.Functions;\n-import io.crate.metadata.TransactionContext;\n-import io.crate.planner.optimizer.Rule;\n-import io.crate.planner.optimizer.matcher.Capture;\n-import io.crate.planner.optimizer.matcher.Captures;\n-import io.crate.planner.optimizer.matcher.Pattern;\n-import io.crate.statistics.TableStats;\n-\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import static io.crate.planner.optimizer.matcher.Pattern.typeOf;\n-import static io.crate.planner.optimizer.matcher.Patterns.source;\n-\n-public class RewriteInsertFromSubQueryToInsertFromValues implements Rule<Insert> {\n-\n-    private final Capture<TableFunction> capture;\n-    private final Pattern<Insert> pattern;\n-    private final AtomicBoolean enabled = new AtomicBoolean(true);\n-\n-    public RewriteInsertFromSubQueryToInsertFromValues() {\n-        this.capture = new Capture<>();\n-        this.pattern = typeOf(Insert.class)\n-            .with(source(), typeOf(TableFunction.class).capturedAs(capture));\n-    }\n-\n-    @Override\n-    public Pattern<Insert> pattern() {\n-        return pattern;\n-    }\n-\n-    @Override\n-    public boolean isEnabled() {\n-        return enabled.get();\n-    }\n-\n-    @Override\n-    public void setEnabled(boolean enabled) {\n-        this.enabled.set(enabled);\n-    }\n-\n-    @Override\n-    public LogicalPlan apply(Insert plan,\n-                             Captures captures,\n-                             TableStats tableStats,\n-                             TransactionContext txnCtx,\n-                             Functions functions) {\n-        TableFunction tableFunction = captures.get(this.capture);\n-        var relation = tableFunction.relation();\n-        if (relation.function().info().ident().name().equals(ValuesFunction.NAME)) {\n-            return new InsertFromValues(tableFunction.relation(), plan.columnIndexWriterProjection());\n-        } else {\n-            return null;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwMzc4MQ==", "url": "https://github.com/crate/crate/pull/9944#discussion_r424403781", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String OPTIMIZER_RULE = \"optimizer_\";\n          \n          \n            \n                private static final String OPTIMIZER_SETTING_PREFIX = \"optimizer_\";", "author": "mfussenegger", "createdAt": "2020-05-13T12:39:38Z", "path": "sql/src/main/java/io/crate/planner/optimizer/LoadedRules.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.CaseFormat;\n+import io.crate.common.collections.Lists2;\n+import io.crate.metadata.settings.session.SessionSetting;\n+import io.crate.metadata.settings.session.SessionSettingProvider;\n+import io.crate.planner.operators.RewriteInsertFromSubQueryToInsertFromValues;\n+import io.crate.planner.optimizer.rule.DeduplicateOrder;\n+import io.crate.planner.optimizer.rule.MergeAggregateAndCollectToCount;\n+import io.crate.planner.optimizer.rule.MergeFilterAndCollect;\n+import io.crate.planner.optimizer.rule.MergeFilters;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathFetchOrEval;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathGroupBy;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathHashJoin;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathNestedLoop;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathOrder;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathProjectSet;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathRename;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathUnion;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathWindowAgg;\n+import io.crate.planner.optimizer.rule.MoveOrderBeneathFetchOrEval;\n+import io.crate.planner.optimizer.rule.MoveOrderBeneathNestedLoop;\n+import io.crate.planner.optimizer.rule.MoveOrderBeneathRename;\n+import io.crate.planner.optimizer.rule.MoveOrderBeneathUnion;\n+import io.crate.planner.optimizer.rule.RemoveRedundantFetchOrEval;\n+import io.crate.planner.optimizer.rule.RewriteCollectToGet;\n+import io.crate.planner.optimizer.rule.RewriteFilterOnOuterJoinToInnerJoin;\n+import io.crate.planner.optimizer.rule.RewriteGroupByKeysLimitToTopNDistinct;\n+import io.crate.planner.optimizer.rule.RewriteToQueryThenFetch;\n+import io.crate.types.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+public class LoadedRules implements SessionSettingProvider {\n+\n+    private static final String OPTIMIZER_RULE = \"optimizer_\";", "originalCommit": "121dd8cb86c8271a7c3e1a9521020a818b979164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/optimizer/LoadedRules.java b/sql/src/main/java/io/crate/planner/optimizer/LoadedRules.java\ndeleted file mode 100644\nindex 0fe542c510..0000000000\n--- a/sql/src/main/java/io/crate/planner/optimizer/LoadedRules.java\n+++ /dev/null\n\n@@ -1,126 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.planner.optimizer;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.CaseFormat;\n-import io.crate.common.collections.Lists2;\n-import io.crate.metadata.settings.session.SessionSetting;\n-import io.crate.metadata.settings.session.SessionSettingProvider;\n-import io.crate.planner.operators.RewriteInsertFromSubQueryToInsertFromValues;\n-import io.crate.planner.optimizer.rule.DeduplicateOrder;\n-import io.crate.planner.optimizer.rule.MergeAggregateAndCollectToCount;\n-import io.crate.planner.optimizer.rule.MergeFilterAndCollect;\n-import io.crate.planner.optimizer.rule.MergeFilters;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathFetchOrEval;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathGroupBy;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathHashJoin;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathNestedLoop;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathOrder;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathProjectSet;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathRename;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathUnion;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathWindowAgg;\n-import io.crate.planner.optimizer.rule.MoveOrderBeneathFetchOrEval;\n-import io.crate.planner.optimizer.rule.MoveOrderBeneathNestedLoop;\n-import io.crate.planner.optimizer.rule.MoveOrderBeneathRename;\n-import io.crate.planner.optimizer.rule.MoveOrderBeneathUnion;\n-import io.crate.planner.optimizer.rule.RemoveRedundantFetchOrEval;\n-import io.crate.planner.optimizer.rule.RewriteCollectToGet;\n-import io.crate.planner.optimizer.rule.RewriteFilterOnOuterJoinToInnerJoin;\n-import io.crate.planner.optimizer.rule.RewriteGroupByKeysLimitToTopNDistinct;\n-import io.crate.planner.optimizer.rule.RewriteToQueryThenFetch;\n-import io.crate.types.DataTypes;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-public class LoadedRules implements SessionSettingProvider {\n-\n-    private static final String OPTIMIZER_RULE = \"optimizer_\";\n-\n-    private static final List<Rule<?>> RULES = List.of(\n-        new RemoveRedundantFetchOrEval(),\n-        new MergeAggregateAndCollectToCount(),\n-        new MergeFilters(),\n-        new MoveFilterBeneathRename(),\n-        new MoveFilterBeneathFetchOrEval(),\n-        new MoveFilterBeneathOrder(),\n-        new MoveFilterBeneathProjectSet(),\n-        new MoveFilterBeneathHashJoin(),\n-        new MoveFilterBeneathNestedLoop(),\n-        new MoveFilterBeneathUnion(),\n-        new MoveFilterBeneathGroupBy(),\n-        new MoveFilterBeneathWindowAgg(),\n-        new MergeFilterAndCollect(),\n-        new RewriteFilterOnOuterJoinToInnerJoin(),\n-        new MoveOrderBeneathUnion(),\n-        new MoveOrderBeneathNestedLoop(),\n-        new MoveOrderBeneathFetchOrEval(),\n-        new MoveOrderBeneathRename(),\n-        new DeduplicateOrder(),\n-        new RewriteCollectToGet(),\n-        new RewriteGroupByKeysLimitToTopNDistinct(),\n-        new RewriteInsertFromSubQueryToInsertFromValues(),\n-        new RewriteToQueryThenFetch()\n-    );\n-\n-    @Override\n-    public List<SessionSetting<?>> sessionSettings() {\n-        return Lists2.map(RULES, this::buildRuleSessionSetting);\n-    }\n-\n-    @VisibleForTesting\n-    SessionSetting<?> buildRuleSessionSetting(Rule<?> rule) {\n-        Class<? extends Rule> clazz = rule.getClass();\n-        var simpleName = clazz.getSimpleName();\n-        var optimizerRuleName = OPTIMIZER_RULE + CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, simpleName);\n-        return new SessionSetting<>(\n-            optimizerRuleName,\n-            objects -> {\n-            },\n-            objects -> DataTypes.BOOLEAN.value(objects[0]),\n-            (sessionContext, activateRule) -> rule.setEnabled(activateRule),\n-            s -> String.valueOf(rule.isEnabled()),\n-            () -> String.valueOf(true),\n-            String.format(Locale.ENGLISH, \"Indicates if the optimizer rule %s is activated.\", simpleName),\n-            DataTypes.BOOLEAN.getName()\n-        );\n-    }\n-\n-    public final List<Rule<?>> getRules(List<Class<? extends Rule<?>>> includedRules) {\n-        if (includedRules.isEmpty()) {\n-            return RULES;\n-        }\n-        var includes = Set.of(includedRules);\n-        var result = new ArrayList<Rule<?>>(includes.size());\n-        for (var rule : RULES) {\n-            if (includes.contains(rule.getClass())) {\n-                result.add(rule);\n-            }\n-        }\n-        return result;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwNDc3NQ==", "url": "https://github.com/crate/crate/pull/9944#discussion_r424404775", "bodyText": "Maybe would be worth adding some docs to explain what this is for", "author": "mfussenegger", "createdAt": "2020-05-13T12:41:08Z", "path": "sql/src/main/java/io/crate/metadata/settings/session/SessionSettingProvider.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.settings.session;\n+\n+import io.crate.planner.optimizer.Rule;\n+\n+import java.util.List;\n+\n+public interface SessionSettingProvider {", "originalCommit": "121dd8cb86c8271a7c3e1a9521020a818b979164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/metadata/settings/session/SessionSettingProvider.java b/sql/src/main/java/io/crate/metadata/settings/session/SessionSettingProvider.java\ndeleted file mode 100644\nindex fa10a28e13..0000000000\n--- a/sql/src/main/java/io/crate/metadata/settings/session/SessionSettingProvider.java\n+++ /dev/null\n\n@@ -1,33 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.metadata.settings.session;\n-\n-import io.crate.planner.optimizer.Rule;\n-\n-import java.util.List;\n-\n-public interface SessionSettingProvider {\n-\n-    List<SessionSetting<?>> sessionSettings();\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwNTI5OQ==", "url": "https://github.com/crate/crate/pull/9944#discussion_r424405299", "bodyText": "Would a HashMap also do? Or where is the stable ordering requirement coming from?", "author": "mfussenegger", "createdAt": "2020-05-13T12:41:52Z", "path": "sql/src/main/java/io/crate/metadata/settings/session/SessionSettingRegistry.java", "diffHunk": "@@ -104,7 +111,18 @@\n                     DataTypes.STRING.getName()\n                 )\n             )\n-            .build();\n+        .putAll(getSessionSettings())\n+        .build();\n+\n+    private static Map<String, SessionSetting<?>> getSessionSettings() {\n+        var result = new LinkedHashMap<String, SessionSetting<?>>();", "originalCommit": "121dd8cb86c8271a7c3e1a9521020a818b979164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/metadata/settings/session/SessionSettingRegistry.java b/sql/src/main/java/io/crate/metadata/settings/session/SessionSettingRegistry.java\ndeleted file mode 100644\nindex d2c2b4db33..0000000000\n--- a/sql/src/main/java/io/crate/metadata/settings/session/SessionSettingRegistry.java\n+++ /dev/null\n\n@@ -1,146 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.metadata.settings.session;\n-\n-import com.google.common.collect.ImmutableMap;\n-import io.crate.action.sql.SessionContext;\n-import io.crate.metadata.SearchPath;\n-import io.crate.protocols.postgres.PostgresWireProtocol;\n-import io.crate.types.DataTypes;\n-\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.ServiceLoader;\n-import java.util.function.Function;\n-\n-import static io.crate.metadata.SearchPath.createSearchPathFrom;\n-\n-public class SessionSettingRegistry {\n-\n-    private static final String SEARCH_PATH_KEY = \"search_path\";\n-    public static final String HASH_JOIN_KEY = \"enable_hashjoin\";\n-    static final String MAX_INDEX_KEYS = \"max_index_keys\";\n-    private static final String SERVER_VERSION_NUM = \"server_version_num\";\n-    private static final String SERVER_VERSION = \"server_version\";\n-\n-    public static final Map<String, SessionSetting<?>> SETTINGS = ImmutableMap.<String, SessionSetting<?>>builder()\n-            .put(SEARCH_PATH_KEY,\n-                new SessionSetting<>(\n-                    SEARCH_PATH_KEY,\n-                    objects -> {}, // everything allowed, empty list (resulting by ``SET .. TO DEFAULT`` results in defaults\n-                    objects -> createSearchPathFrom(objectsToStringArray(objects)),\n-                    SessionContext::setSearchPath,\n-                    s -> iterableToString(s.searchPath()),\n-                    () -> iterableToString(SearchPath.pathWithPGCatalogAndDoc()),\n-                    \"Sets the schema search order.\",\n-                    DataTypes.STRING.getName()))\n-            .put(HASH_JOIN_KEY,\n-                new SessionSetting<>(\n-                    HASH_JOIN_KEY,\n-                    objects -> {\n-                        if (objects.length != 1) {\n-                            throw new IllegalArgumentException(HASH_JOIN_KEY + \" should have only one argument.\");\n-                        }\n-                    },\n-                    objects -> DataTypes.BOOLEAN.value(objects[0]),\n-                    SessionContext::setHashJoinEnabled,\n-                    s -> Boolean.toString(s.hashJoinsEnabled()),\n-                    () -> String.valueOf(true),\n-                    \"Considers using the Hash Join instead of the Nested Loop Join implementation.\",\n-                    DataTypes.BOOLEAN.getName()))\n-            .put(MAX_INDEX_KEYS,\n-                new SessionSetting<>(\n-                    MAX_INDEX_KEYS,\n-                    objects -> {},\n-                    Function.identity(),\n-                    (s, v) -> {\n-                        throw new UnsupportedOperationException(\"\\\"\" + MAX_INDEX_KEYS + \"\\\" cannot be changed.\");\n-                    },\n-                    s -> String.valueOf(32),\n-                    () -> String.valueOf(32),\n-                    \"Shows the maximum number of index keys.\",\n-                    DataTypes.INTEGER.getName()))\n-            .put(\n-                SERVER_VERSION_NUM,\n-                new SessionSetting<>(\n-                    SERVER_VERSION_NUM,\n-                    objects -> {},\n-                    Function.identity(),\n-                    (s, v) -> {\n-                        throw new UnsupportedOperationException(\"\\\"\" + SERVER_VERSION_NUM + \"\\\" cannot be changed.\");\n-                    },\n-                    s -> String.valueOf(PostgresWireProtocol.SERVER_VERSION_NUM),\n-                    () -> String.valueOf(PostgresWireProtocol.SERVER_VERSION_NUM),\n-                    \"Reports the emulated PostgreSQL version number\",\n-                    DataTypes.INTEGER.getName()\n-                )\n-            )\n-            .put(\n-                SERVER_VERSION,\n-                new SessionSetting<>(\n-                    SERVER_VERSION,\n-                    objects -> {},\n-                    Function.identity(),\n-                    (s, v) -> {\n-                        throw new UnsupportedOperationException(\"\\\"\" + SERVER_VERSION + \"\\\" cannot be changed.\");\n-                    },\n-                    s -> String.valueOf(PostgresWireProtocol.PG_SERVER_VERSION),\n-                    () -> String.valueOf(PostgresWireProtocol.PG_SERVER_VERSION),\n-                    \"Reports the emulated PostgreSQL version number\",\n-                    DataTypes.STRING.getName()\n-                )\n-            )\n-        .putAll(getSessionSettings())\n-        .build();\n-\n-    private static Map<String, SessionSetting<?>> getSessionSettings() {\n-        var result = new LinkedHashMap<String, SessionSetting<?>>();\n-        for (var sessionSettingProvider : ServiceLoader.load(SessionSettingProvider.class)) {\n-            for (var sessionSetting : sessionSettingProvider.sessionSettings()) {\n-                result.put(sessionSetting.name(), sessionSetting);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    private static String[] objectsToStringArray(Object[] objects) {\n-        String[] strings = new String[objects.length];\n-        for (int i = 0; i < objects.length; i++) {\n-            strings[i] = DataTypes.STRING.value(objects[i]);\n-        }\n-        return strings;\n-    }\n-\n-    private static String iterableToString(Iterable<String> iterable) {\n-        Iterator<String> it = iterable.iterator();\n-        StringBuilder sb = new StringBuilder();\n-        while (it.hasNext()) {\n-            sb.append(it.next());\n-            if (it.hasNext()) {\n-                sb.append(\", \");\n-            }\n-        }\n-        return sb.toString();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwNzgyOA==", "url": "https://github.com/crate/crate/pull/9944#discussion_r424407828", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.rules = loadRules(rulesToInclude);\n          \n          \n            \n                this.rules = new LoadedRules().getRules(rulesToInclude);\n          \n      \n    \n    \n  \n\nloadRules is a shallow method. I don't think there is a benefit in having a separate method?", "author": "mfussenegger", "createdAt": "2020-05-13T12:46:00Z", "path": "sql/src/main/java/io/crate/planner/optimizer/Optimizer.java", "diffHunk": "@@ -41,22 +42,25 @@\n \n     private final List<Rule<?>> rules;\n     private final Supplier<Version> minNodeVersionInCluster;\n+    private final Functions functions;\n \n-    public Optimizer(List<Rule<?>> rules, Supplier<Version> minNodeVersionInCluster) {\n-        this.rules = rules;\n+    public Optimizer(Functions functions, Supplier<Version> minNodeVersionInCluster, List<Class<? extends Rule<?>>> rulesToInclude) {\n+        this.rules = loadRules(rulesToInclude);", "originalCommit": "121dd8cb86c8271a7c3e1a9521020a818b979164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java b/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\ndeleted file mode 100644\nindex db5dfdfd5d..0000000000\n--- a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\n+++ /dev/null\n\n@@ -1,109 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.planner.optimizer;\n-\n-import io.crate.common.collections.Lists2;\n-import io.crate.metadata.Functions;\n-import io.crate.metadata.TransactionContext;\n-import io.crate.planner.operators.LogicalPlan;\n-import io.crate.planner.optimizer.matcher.Captures;\n-import io.crate.planner.optimizer.matcher.Match;\n-import io.crate.statistics.TableStats;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.Version;\n-\n-import java.util.List;\n-import java.util.function.Supplier;\n-\n-public class Optimizer {\n-\n-    private static final Logger LOGGER = LogManager.getLogger(Optimizer.class);\n-\n-    private final List<Rule<?>> rules;\n-    private final Supplier<Version> minNodeVersionInCluster;\n-    private final Functions functions;\n-\n-    public Optimizer(Functions functions, Supplier<Version> minNodeVersionInCluster, List<Class<? extends Rule<?>>> rulesToInclude) {\n-        this.rules = loadRules(rulesToInclude);\n-        this.minNodeVersionInCluster = minNodeVersionInCluster;\n-        this.functions = functions;\n-    }\n-\n-    public LogicalPlan optimize(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        LogicalPlan optimizedRoot = tryApplyRules(rules, plan, tableStats, txnCtx);\n-        return tryApplyRules(\n-            rules,\n-            optimizedRoot.replaceSources(Lists2.map(optimizedRoot.sources(), x -> optimize(x, tableStats, txnCtx))),\n-            tableStats,\n-            txnCtx\n-        );\n-    }\n-\n-    private LogicalPlan tryApplyRules(List<Rule<?>> rules, LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        final boolean isTraceEnabled = LOGGER.isTraceEnabled();\n-        LogicalPlan node = plan;\n-        // Some rules may only become applicable after another rule triggered, so we keep\n-        // trying to re-apply the rules as long as at least one plan was transformed.\n-        boolean done = false;\n-        int numIterations = 0;\n-        while (!done && numIterations < 10_000) {\n-            done = true;\n-            Version minVersion = minNodeVersionInCluster.get();\n-            for (Rule rule : rules) {\n-                if (!rule.isEnabled()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' excluded from execution\");\n-                    }\n-                    continue;\n-                }\n-                if (minVersion.before(rule.requiredVersion())) {\n-                    continue;\n-                }\n-                Match<?> match = rule.pattern().accept(node, Captures.empty());\n-                if (match.isPresent()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' matched\");\n-                    }\n-                    @SuppressWarnings(\"unchecked\")\n-                    LogicalPlan transformedPlan = rule.apply(match.value(), match.captures(), tableStats, txnCtx, functions);\n-                    if (transformedPlan != null) {\n-                        if (isTraceEnabled) {\n-                            LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' transformed the logical plan\");\n-                        }\n-                        node = transformedPlan;\n-                        done = false;\n-                    }\n-                }\n-            }\n-            numIterations++;\n-        }\n-        assert numIterations < 10_000\n-            : \"Optimizer reached 10_000 iterations safety guard. This is an indication of a broken rule that matches again and again\";\n-        return node;\n-    }\n-\n-    private List<Rule<?>> loadRules(List<Class<? extends Rule<?>>> rulesToInclude) {\n-        return new LoadedRules().getRules(rulesToInclude);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwODUwMA==", "url": "https://github.com/crate/crate/pull/9944#discussion_r424408500", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LogicalPlan optimizedRoot = tryApplyRules(rules, plan, tableStats, txnCtx);\n          \n          \n            \n                    LogicalPlan optimizedRoot = tryApplyRules(plan, tableStats, txnCtx);\n          \n      \n    \n    \n  \n\nThere is still a rules attribute.", "author": "mfussenegger", "createdAt": "2020-05-13T12:47:08Z", "path": "sql/src/main/java/io/crate/planner/optimizer/Optimizer.java", "diffHunk": "@@ -41,22 +42,25 @@\n \n     private final List<Rule<?>> rules;\n     private final Supplier<Version> minNodeVersionInCluster;\n+    private final Functions functions;\n \n-    public Optimizer(List<Rule<?>> rules, Supplier<Version> minNodeVersionInCluster) {\n-        this.rules = rules;\n+    public Optimizer(Functions functions, Supplier<Version> minNodeVersionInCluster, List<Class<? extends Rule<?>>> rulesToInclude) {\n+        this.rules = loadRules(rulesToInclude);\n         this.minNodeVersionInCluster = minNodeVersionInCluster;\n+        this.functions = functions;\n     }\n \n     public LogicalPlan optimize(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        LogicalPlan optimizedRoot = tryApplyRules(plan, tableStats, txnCtx);\n+        LogicalPlan optimizedRoot = tryApplyRules(rules, plan, tableStats, txnCtx);", "originalCommit": "121dd8cb86c8271a7c3e1a9521020a818b979164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java b/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\ndeleted file mode 100644\nindex db5dfdfd5d..0000000000\n--- a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\n+++ /dev/null\n\n@@ -1,109 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.planner.optimizer;\n-\n-import io.crate.common.collections.Lists2;\n-import io.crate.metadata.Functions;\n-import io.crate.metadata.TransactionContext;\n-import io.crate.planner.operators.LogicalPlan;\n-import io.crate.planner.optimizer.matcher.Captures;\n-import io.crate.planner.optimizer.matcher.Match;\n-import io.crate.statistics.TableStats;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.Version;\n-\n-import java.util.List;\n-import java.util.function.Supplier;\n-\n-public class Optimizer {\n-\n-    private static final Logger LOGGER = LogManager.getLogger(Optimizer.class);\n-\n-    private final List<Rule<?>> rules;\n-    private final Supplier<Version> minNodeVersionInCluster;\n-    private final Functions functions;\n-\n-    public Optimizer(Functions functions, Supplier<Version> minNodeVersionInCluster, List<Class<? extends Rule<?>>> rulesToInclude) {\n-        this.rules = loadRules(rulesToInclude);\n-        this.minNodeVersionInCluster = minNodeVersionInCluster;\n-        this.functions = functions;\n-    }\n-\n-    public LogicalPlan optimize(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        LogicalPlan optimizedRoot = tryApplyRules(rules, plan, tableStats, txnCtx);\n-        return tryApplyRules(\n-            rules,\n-            optimizedRoot.replaceSources(Lists2.map(optimizedRoot.sources(), x -> optimize(x, tableStats, txnCtx))),\n-            tableStats,\n-            txnCtx\n-        );\n-    }\n-\n-    private LogicalPlan tryApplyRules(List<Rule<?>> rules, LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        final boolean isTraceEnabled = LOGGER.isTraceEnabled();\n-        LogicalPlan node = plan;\n-        // Some rules may only become applicable after another rule triggered, so we keep\n-        // trying to re-apply the rules as long as at least one plan was transformed.\n-        boolean done = false;\n-        int numIterations = 0;\n-        while (!done && numIterations < 10_000) {\n-            done = true;\n-            Version minVersion = minNodeVersionInCluster.get();\n-            for (Rule rule : rules) {\n-                if (!rule.isEnabled()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' excluded from execution\");\n-                    }\n-                    continue;\n-                }\n-                if (minVersion.before(rule.requiredVersion())) {\n-                    continue;\n-                }\n-                Match<?> match = rule.pattern().accept(node, Captures.empty());\n-                if (match.isPresent()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' matched\");\n-                    }\n-                    @SuppressWarnings(\"unchecked\")\n-                    LogicalPlan transformedPlan = rule.apply(match.value(), match.captures(), tableStats, txnCtx, functions);\n-                    if (transformedPlan != null) {\n-                        if (isTraceEnabled) {\n-                            LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' transformed the logical plan\");\n-                        }\n-                        node = transformedPlan;\n-                        done = false;\n-                    }\n-                }\n-            }\n-            numIterations++;\n-        }\n-        assert numIterations < 10_000\n-            : \"Optimizer reached 10_000 iterations safety guard. This is an indication of a broken rule that matches again and again\";\n-        return node;\n-    }\n-\n-    private List<Rule<?>> loadRules(List<Class<? extends Rule<?>>> rulesToInclude) {\n-        return new LoadedRules().getRules(rulesToInclude);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwODU4OA==", "url": "https://github.com/crate/crate/pull/9944#discussion_r424408588", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        rules,", "author": "mfussenegger", "createdAt": "2020-05-13T12:47:16Z", "path": "sql/src/main/java/io/crate/planner/optimizer/Optimizer.java", "diffHunk": "@@ -41,22 +42,25 @@\n \n     private final List<Rule<?>> rules;\n     private final Supplier<Version> minNodeVersionInCluster;\n+    private final Functions functions;\n \n-    public Optimizer(List<Rule<?>> rules, Supplier<Version> minNodeVersionInCluster) {\n-        this.rules = rules;\n+    public Optimizer(Functions functions, Supplier<Version> minNodeVersionInCluster, List<Class<? extends Rule<?>>> rulesToInclude) {\n+        this.rules = loadRules(rulesToInclude);\n         this.minNodeVersionInCluster = minNodeVersionInCluster;\n+        this.functions = functions;\n     }\n \n     public LogicalPlan optimize(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        LogicalPlan optimizedRoot = tryApplyRules(plan, tableStats, txnCtx);\n+        LogicalPlan optimizedRoot = tryApplyRules(rules, plan, tableStats, txnCtx);\n         return tryApplyRules(\n+            rules,", "originalCommit": "121dd8cb86c8271a7c3e1a9521020a818b979164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java b/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\ndeleted file mode 100644\nindex db5dfdfd5d..0000000000\n--- a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\n+++ /dev/null\n\n@@ -1,109 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.planner.optimizer;\n-\n-import io.crate.common.collections.Lists2;\n-import io.crate.metadata.Functions;\n-import io.crate.metadata.TransactionContext;\n-import io.crate.planner.operators.LogicalPlan;\n-import io.crate.planner.optimizer.matcher.Captures;\n-import io.crate.planner.optimizer.matcher.Match;\n-import io.crate.statistics.TableStats;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.Version;\n-\n-import java.util.List;\n-import java.util.function.Supplier;\n-\n-public class Optimizer {\n-\n-    private static final Logger LOGGER = LogManager.getLogger(Optimizer.class);\n-\n-    private final List<Rule<?>> rules;\n-    private final Supplier<Version> minNodeVersionInCluster;\n-    private final Functions functions;\n-\n-    public Optimizer(Functions functions, Supplier<Version> minNodeVersionInCluster, List<Class<? extends Rule<?>>> rulesToInclude) {\n-        this.rules = loadRules(rulesToInclude);\n-        this.minNodeVersionInCluster = minNodeVersionInCluster;\n-        this.functions = functions;\n-    }\n-\n-    public LogicalPlan optimize(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        LogicalPlan optimizedRoot = tryApplyRules(rules, plan, tableStats, txnCtx);\n-        return tryApplyRules(\n-            rules,\n-            optimizedRoot.replaceSources(Lists2.map(optimizedRoot.sources(), x -> optimize(x, tableStats, txnCtx))),\n-            tableStats,\n-            txnCtx\n-        );\n-    }\n-\n-    private LogicalPlan tryApplyRules(List<Rule<?>> rules, LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        final boolean isTraceEnabled = LOGGER.isTraceEnabled();\n-        LogicalPlan node = plan;\n-        // Some rules may only become applicable after another rule triggered, so we keep\n-        // trying to re-apply the rules as long as at least one plan was transformed.\n-        boolean done = false;\n-        int numIterations = 0;\n-        while (!done && numIterations < 10_000) {\n-            done = true;\n-            Version minVersion = minNodeVersionInCluster.get();\n-            for (Rule rule : rules) {\n-                if (!rule.isEnabled()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' excluded from execution\");\n-                    }\n-                    continue;\n-                }\n-                if (minVersion.before(rule.requiredVersion())) {\n-                    continue;\n-                }\n-                Match<?> match = rule.pattern().accept(node, Captures.empty());\n-                if (match.isPresent()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' matched\");\n-                    }\n-                    @SuppressWarnings(\"unchecked\")\n-                    LogicalPlan transformedPlan = rule.apply(match.value(), match.captures(), tableStats, txnCtx, functions);\n-                    if (transformedPlan != null) {\n-                        if (isTraceEnabled) {\n-                            LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' transformed the logical plan\");\n-                        }\n-                        node = transformedPlan;\n-                        done = false;\n-                    }\n-                }\n-            }\n-            numIterations++;\n-        }\n-        assert numIterations < 10_000\n-            : \"Optimizer reached 10_000 iterations safety guard. This is an indication of a broken rule that matches again and again\";\n-        return node;\n-    }\n-\n-    private List<Rule<?>> loadRules(List<Class<? extends Rule<?>>> rulesToInclude) {\n-        return new LoadedRules().getRules(rulesToInclude);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwODcwMg==", "url": "https://github.com/crate/crate/pull/9944#discussion_r424408702", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private LogicalPlan tryApplyRules(List<Rule<?>> rules, LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n          \n          \n            \n                private LogicalPlan tryApplyRules(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {", "author": "mfussenegger", "createdAt": "2020-05-13T12:47:27Z", "path": "sql/src/main/java/io/crate/planner/optimizer/Optimizer.java", "diffHunk": "@@ -41,22 +42,25 @@\n \n     private final List<Rule<?>> rules;\n     private final Supplier<Version> minNodeVersionInCluster;\n+    private final Functions functions;\n \n-    public Optimizer(List<Rule<?>> rules, Supplier<Version> minNodeVersionInCluster) {\n-        this.rules = rules;\n+    public Optimizer(Functions functions, Supplier<Version> minNodeVersionInCluster, List<Class<? extends Rule<?>>> rulesToInclude) {\n+        this.rules = loadRules(rulesToInclude);\n         this.minNodeVersionInCluster = minNodeVersionInCluster;\n+        this.functions = functions;\n     }\n \n     public LogicalPlan optimize(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        LogicalPlan optimizedRoot = tryApplyRules(plan, tableStats, txnCtx);\n+        LogicalPlan optimizedRoot = tryApplyRules(rules, plan, tableStats, txnCtx);\n         return tryApplyRules(\n+            rules,\n             optimizedRoot.replaceSources(Lists2.map(optimizedRoot.sources(), x -> optimize(x, tableStats, txnCtx))),\n             tableStats,\n             txnCtx\n         );\n     }\n \n-    private LogicalPlan tryApplyRules(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n+    private LogicalPlan tryApplyRules(List<Rule<?>> rules, LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {", "originalCommit": "121dd8cb86c8271a7c3e1a9521020a818b979164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java b/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\ndeleted file mode 100644\nindex db5dfdfd5d..0000000000\n--- a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\n+++ /dev/null\n\n@@ -1,109 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.planner.optimizer;\n-\n-import io.crate.common.collections.Lists2;\n-import io.crate.metadata.Functions;\n-import io.crate.metadata.TransactionContext;\n-import io.crate.planner.operators.LogicalPlan;\n-import io.crate.planner.optimizer.matcher.Captures;\n-import io.crate.planner.optimizer.matcher.Match;\n-import io.crate.statistics.TableStats;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.Version;\n-\n-import java.util.List;\n-import java.util.function.Supplier;\n-\n-public class Optimizer {\n-\n-    private static final Logger LOGGER = LogManager.getLogger(Optimizer.class);\n-\n-    private final List<Rule<?>> rules;\n-    private final Supplier<Version> minNodeVersionInCluster;\n-    private final Functions functions;\n-\n-    public Optimizer(Functions functions, Supplier<Version> minNodeVersionInCluster, List<Class<? extends Rule<?>>> rulesToInclude) {\n-        this.rules = loadRules(rulesToInclude);\n-        this.minNodeVersionInCluster = minNodeVersionInCluster;\n-        this.functions = functions;\n-    }\n-\n-    public LogicalPlan optimize(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        LogicalPlan optimizedRoot = tryApplyRules(rules, plan, tableStats, txnCtx);\n-        return tryApplyRules(\n-            rules,\n-            optimizedRoot.replaceSources(Lists2.map(optimizedRoot.sources(), x -> optimize(x, tableStats, txnCtx))),\n-            tableStats,\n-            txnCtx\n-        );\n-    }\n-\n-    private LogicalPlan tryApplyRules(List<Rule<?>> rules, LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        final boolean isTraceEnabled = LOGGER.isTraceEnabled();\n-        LogicalPlan node = plan;\n-        // Some rules may only become applicable after another rule triggered, so we keep\n-        // trying to re-apply the rules as long as at least one plan was transformed.\n-        boolean done = false;\n-        int numIterations = 0;\n-        while (!done && numIterations < 10_000) {\n-            done = true;\n-            Version minVersion = minNodeVersionInCluster.get();\n-            for (Rule rule : rules) {\n-                if (!rule.isEnabled()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' excluded from execution\");\n-                    }\n-                    continue;\n-                }\n-                if (minVersion.before(rule.requiredVersion())) {\n-                    continue;\n-                }\n-                Match<?> match = rule.pattern().accept(node, Captures.empty());\n-                if (match.isPresent()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' matched\");\n-                    }\n-                    @SuppressWarnings(\"unchecked\")\n-                    LogicalPlan transformedPlan = rule.apply(match.value(), match.captures(), tableStats, txnCtx, functions);\n-                    if (transformedPlan != null) {\n-                        if (isTraceEnabled) {\n-                            LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' transformed the logical plan\");\n-                        }\n-                        node = transformedPlan;\n-                        done = false;\n-                    }\n-                }\n-            }\n-            numIterations++;\n-        }\n-        assert numIterations < 10_000\n-            : \"Optimizer reached 10_000 iterations safety guard. This is an indication of a broken rule that matches again and again\";\n-        return node;\n-    }\n-\n-    private List<Rule<?>> loadRules(List<Class<? extends Rule<?>>> rulesToInclude) {\n-        return new LoadedRules().getRules(rulesToInclude);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwOTYzNw==", "url": "https://github.com/crate/crate/pull/9944#discussion_r424409637", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                private List<Rule<?>> loadRules(List<Class<? extends Rule<?>>> rulesToInclude) {\n          \n          \n            \n                    return new LoadedRules().getRules(rulesToInclude);\n          \n          \n            \n                }", "author": "mfussenegger", "createdAt": "2020-05-13T12:48:54Z", "path": "sql/src/main/java/io/crate/planner/optimizer/Optimizer.java", "diffHunk": "@@ -92,4 +102,8 @@ private LogicalPlan tryApplyRules(LogicalPlan plan, TableStats tableStats, Trans\n             : \"Optimizer reached 10_000 iterations safety guard. This is an indication of a broken rule that matches again and again\";\n         return node;\n     }\n+\n+    private List<Rule<?>> loadRules(List<Class<? extends Rule<?>>> rulesToInclude) {\n+        return new LoadedRules().getRules(rulesToInclude);\n+    }", "originalCommit": "121dd8cb86c8271a7c3e1a9521020a818b979164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java b/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\ndeleted file mode 100644\nindex db5dfdfd5d..0000000000\n--- a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\n+++ /dev/null\n\n@@ -1,109 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.planner.optimizer;\n-\n-import io.crate.common.collections.Lists2;\n-import io.crate.metadata.Functions;\n-import io.crate.metadata.TransactionContext;\n-import io.crate.planner.operators.LogicalPlan;\n-import io.crate.planner.optimizer.matcher.Captures;\n-import io.crate.planner.optimizer.matcher.Match;\n-import io.crate.statistics.TableStats;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.Version;\n-\n-import java.util.List;\n-import java.util.function.Supplier;\n-\n-public class Optimizer {\n-\n-    private static final Logger LOGGER = LogManager.getLogger(Optimizer.class);\n-\n-    private final List<Rule<?>> rules;\n-    private final Supplier<Version> minNodeVersionInCluster;\n-    private final Functions functions;\n-\n-    public Optimizer(Functions functions, Supplier<Version> minNodeVersionInCluster, List<Class<? extends Rule<?>>> rulesToInclude) {\n-        this.rules = loadRules(rulesToInclude);\n-        this.minNodeVersionInCluster = minNodeVersionInCluster;\n-        this.functions = functions;\n-    }\n-\n-    public LogicalPlan optimize(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        LogicalPlan optimizedRoot = tryApplyRules(rules, plan, tableStats, txnCtx);\n-        return tryApplyRules(\n-            rules,\n-            optimizedRoot.replaceSources(Lists2.map(optimizedRoot.sources(), x -> optimize(x, tableStats, txnCtx))),\n-            tableStats,\n-            txnCtx\n-        );\n-    }\n-\n-    private LogicalPlan tryApplyRules(List<Rule<?>> rules, LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        final boolean isTraceEnabled = LOGGER.isTraceEnabled();\n-        LogicalPlan node = plan;\n-        // Some rules may only become applicable after another rule triggered, so we keep\n-        // trying to re-apply the rules as long as at least one plan was transformed.\n-        boolean done = false;\n-        int numIterations = 0;\n-        while (!done && numIterations < 10_000) {\n-            done = true;\n-            Version minVersion = minNodeVersionInCluster.get();\n-            for (Rule rule : rules) {\n-                if (!rule.isEnabled()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' excluded from execution\");\n-                    }\n-                    continue;\n-                }\n-                if (minVersion.before(rule.requiredVersion())) {\n-                    continue;\n-                }\n-                Match<?> match = rule.pattern().accept(node, Captures.empty());\n-                if (match.isPresent()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' matched\");\n-                    }\n-                    @SuppressWarnings(\"unchecked\")\n-                    LogicalPlan transformedPlan = rule.apply(match.value(), match.captures(), tableStats, txnCtx, functions);\n-                    if (transformedPlan != null) {\n-                        if (isTraceEnabled) {\n-                            LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' transformed the logical plan\");\n-                        }\n-                        node = transformedPlan;\n-                        done = false;\n-                    }\n-                }\n-            }\n-            numIterations++;\n-        }\n-        assert numIterations < 10_000\n-            : \"Optimizer reached 10_000 iterations safety guard. This is an indication of a broken rule that matches again and again\";\n-        return node;\n-    }\n-\n-    private List<Rule<?>> loadRules(List<Class<? extends Rule<?>>> rulesToInclude) {\n-        return new LoadedRules().getRules(rulesToInclude);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMDU0NQ==", "url": "https://github.com/crate/crate/pull/9944#discussion_r424410545", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean couldMatchOnNull(@Nullable Symbol query, EvaluatingNormalizer normalizer) {\n          \n          \n            \n                private static boolean couldMatchOnNull(@Nullable Symbol query, EvaluatingNormalizer normalizer) {", "author": "mfussenegger", "createdAt": "2020-05-13T12:50:19Z", "path": "sql/src/main/java/io/crate/planner/optimizer/rule/RewriteFilterOnOuterJoinToInnerJoin.java", "diffHunk": "@@ -264,7 +276,7 @@ public LogicalPlan apply(Filter filter,\n         return splitQueries.isEmpty() ? newJoin : new Filter(newJoin, AndOperator.join(splitQueries.values()));\n     }\n \n-    private boolean couldMatchOnNull(@Nullable Symbol query) {\n+    private boolean couldMatchOnNull(@Nullable Symbol query, EvaluatingNormalizer normalizer) {", "originalCommit": "121dd8cb86c8271a7c3e1a9521020a818b979164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/optimizer/rule/RewriteFilterOnOuterJoinToInnerJoin.java b/sql/src/main/java/io/crate/planner/optimizer/rule/RewriteFilterOnOuterJoinToInnerJoin.java\ndeleted file mode 100644\nindex b94d2f9fae..0000000000\n--- a/sql/src/main/java/io/crate/planner/optimizer/rule/RewriteFilterOnOuterJoinToInnerJoin.java\n+++ /dev/null\n\n@@ -1,292 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.planner.optimizer.rule;\n-\n-import io.crate.analyze.WhereClause;\n-import io.crate.analyze.relations.QuerySplitter;\n-import io.crate.expression.eval.EvaluatingNormalizer;\n-import io.crate.expression.operator.AndOperator;\n-import io.crate.expression.symbol.FieldReplacer;\n-import io.crate.expression.symbol.Literal;\n-import io.crate.expression.symbol.RefReplacer;\n-import io.crate.expression.symbol.Symbol;\n-import io.crate.metadata.Functions;\n-import io.crate.metadata.RelationName;\n-import io.crate.metadata.TransactionContext;\n-import io.crate.planner.node.dql.join.JoinType;\n-import io.crate.planner.operators.Filter;\n-import io.crate.planner.operators.LogicalPlan;\n-import io.crate.planner.operators.NestedLoopJoin;\n-import io.crate.planner.optimizer.Rule;\n-import io.crate.planner.optimizer.matcher.Capture;\n-import io.crate.planner.optimizer.matcher.Captures;\n-import io.crate.planner.optimizer.matcher.Pattern;\n-import io.crate.statistics.TableStats;\n-\n-import javax.annotation.Nullable;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import static io.crate.planner.optimizer.matcher.Pattern.typeOf;\n-import static io.crate.planner.optimizer.matcher.Patterns.source;\n-import static io.crate.planner.optimizer.rule.FilterOnJoinsUtil.getNewSource;\n-\n-/**\n- * If we can determine that a filter on an OUTER JOIN turns all NULL rows that the join could generate into a NO-MATCH\n- * we can push down the filter and turn the OUTER JOIN into an inner join.\n- *\n- * <p>\n- * So this tries to transform\n- * </p>\n- *\n- * <pre>\n- *     Filter (lhs.x = 1 AND rhs.x = 2)\n- *       |\n- *     NestedLoop (outerJoin)\n- *       /  \\\n- *     LHS  RHS\n- * </pre>\n- *\n- * into\n- *\n- * <pre>\n- *     Filter\n- *       |\n- *     NestedLoop (innerJoin)\n- *       /      \\\n- *   Filter      Filter\n- * (lhs.x = 1)    (rhs.x = 2)\n- *     |              |\n- *    LHS            RHS\n- * </pre>\n- *\n- * A case where this is *NOT* safe is for example:\n- *\n- * <pre>\n- * SELECT * FROM t1\n- *     LEFT JOIN t2 ON t1.t2_id = t2.id\n- * WHERE\n- *     coalesce(t2.x, 20) > 10   # becomes TRUE for null rows\n- * </pre>\n- *\n- *\n- * A case where the FILTER turns all null rows into no-matches:\n- *\n- * <pre>\n- * SELECT * FROM t1\n- *      LEFT JOIN t2 ON t1.t2_id = t2.id\n- * WHERE\n- *      t2.x = 10           # null = 10 -> null -> no match\n- * </pre>\n- */\n-public final class RewriteFilterOnOuterJoinToInnerJoin implements Rule<Filter> {\n-\n-    private final Capture<NestedLoopJoin> nlCapture;\n-    private final Pattern<Filter> pattern;\n-    private final AtomicBoolean enabled = new AtomicBoolean(true);\n-\n-    public RewriteFilterOnOuterJoinToInnerJoin() {\n-        this.nlCapture = new Capture<>();\n-        this.pattern = typeOf(Filter.class)\n-                .with(source(), typeOf(NestedLoopJoin.class).capturedAs(nlCapture)\n-                    .with(nl -> nl.joinType().isOuter() && !nl.isRewriteFilterOnOuterJoinToInnerJoinDone())\n-                );\n-    }\n-\n-    @Override\n-    public Pattern<Filter> pattern() {\n-        return pattern;\n-    }\n-\n-    @Override\n-    public boolean isEnabled() {\n-        return enabled.get();\n-    }\n-\n-    @Override\n-    public void setEnabled(boolean enabled) {\n-        this.enabled.set(enabled);\n-    }\n-\n-    @Override\n-    public LogicalPlan apply(Filter filter,\n-                             Captures captures,\n-                             TableStats tableStats,\n-                             TransactionContext txnCtx,\n-                             Functions functions) {\n-        EvaluatingNormalizer normalizer = EvaluatingNormalizer.functionOnlyNormalizer(functions);\n-        NestedLoopJoin nl = captures.get(nlCapture);\n-        Symbol query = filter.query();\n-        Map<Set<RelationName>, Symbol> splitQueries = QuerySplitter.split(query);\n-        if (splitQueries.size() == 1 && splitQueries.keySet().iterator().next().size() > 1) {\n-            return null;\n-        }\n-        LogicalPlan lhs = nl.sources().get(0);\n-        LogicalPlan rhs = nl.sources().get(1);\n-        Set<RelationName> leftName = lhs.getRelationNames();\n-        Set<RelationName> rightName = rhs.getRelationNames();\n-\n-        Symbol leftQuery = splitQueries.remove(leftName);\n-        Symbol rightQuery = splitQueries.remove(rightName);\n-\n-        final LogicalPlan newLhs;\n-        final LogicalPlan newRhs;\n-        final boolean newJoinIsInnerJoin;\n-        switch (nl.joinType()) {\n-            case LEFT:\n-                /* LEFT OUTER JOIN -> NULL rows are generated for the RHS if the join-condition doesn't match\n-                 *\n-                 * cr> select t1.x as t1x, t2.x as t2x from t1 left join t2 on t1.x = t2.x;\n-                 * +-----+------+\n-                 * | t1x |  t2x |\n-                 * +-----+------+\n-                 * |   3 |    3 |\n-                 * |   2 |    2 |\n-                 * |   1 | NULL |\n-                 * +-----+------+\n-                 */\n-                newLhs = getNewSource(leftQuery, lhs);\n-                if (rightQuery == null) {\n-                    newRhs = rhs;\n-                    newJoinIsInnerJoin = false;\n-                } else if (couldMatchOnNull(rightQuery, normalizer)) {\n-                    newRhs = rhs;\n-                    newJoinIsInnerJoin = false;\n-                    splitQueries.put(rightName, rightQuery);\n-                } else {\n-                    newRhs = getNewSource(rightQuery, rhs);\n-                    newJoinIsInnerJoin = true;\n-                }\n-                break;\n-            case RIGHT:\n-                /* RIGHT OUTER JOIN -> NULL rows are generated for the LHS if the join-condition doesn't match\n-\n-                 * cr> select t1.x as t1x, t2.x as t2x from t1 right join t2 on t1.x = t2.x;\n-                 * +------+-----+\n-                 * |  t1x | t2x |\n-                 * +------+-----+\n-                 * |    3 |   3 |\n-                 * |    2 |   2 |\n-                 * | NULL |   4 |\n-                 * +------+-----+\n-                 */\n-                if (leftQuery == null) {\n-                    newLhs = lhs;\n-                    newJoinIsInnerJoin = false;\n-                } else if (couldMatchOnNull(leftQuery, normalizer)) {\n-                    newLhs = lhs;\n-                    newJoinIsInnerJoin = false;\n-                    splitQueries.put(leftName, leftQuery);\n-                } else {\n-                    newLhs = getNewSource(leftQuery, lhs);\n-                    newJoinIsInnerJoin = true;\n-                }\n-                newRhs = getNewSource(rightQuery, rhs);\n-                break;\n-            case FULL:\n-                /*\n-                 * cr> select t1.x as t1x, t2.x as t2x from t1 full outer join t2 on t1.x = t2.x;\n-                 * +------+------+\n-                 * |  t1x |  t2x |\n-                 * +------+------+\n-                 * |    3 |    3 |\n-                 * |    2 |    2 |\n-                 * |    1 | NULL |\n-                 * | NULL |    4 |\n-                 * +------+------+\n-                 */\n-\n-                if (couldMatchOnNull(leftQuery, normalizer)) {\n-                    newLhs = lhs;\n-                } else {\n-                    newLhs = getNewSource(leftQuery, lhs);\n-                    if (leftQuery != null) {\n-                        splitQueries.put(leftName, leftQuery);\n-                    }\n-                }\n-                if (couldMatchOnNull(rightQuery, normalizer)) {\n-                    newRhs = rhs;\n-                } else {\n-                    newRhs = getNewSource(rightQuery, rhs);\n-                }\n-\n-                /*\n-                 * Filters on each side must be put back into the Filter as each side can generate NULL's on outer joins\n-                 * which must be filtered out AFTER the join operation.\n-                 * In case the filter is only on one side, the join could be rewritten to a LEFT/RIGHT OUTER.\n-                 * TODO: Create a dedicated rule RewriteFilterOnOuterJoinToLeftOrRight\n-                 *\n-                 * cr> select t1.x as t1x, t2.x as t2x, t2.y as t2y from t1 full outer join t2 on t1.x = t2.x where t2y = 1;\n-                 * +------+------+------+\n-                 * |  t1x |  t2x |  t2y |\n-                 * +------+------+------+\n-                 * |    3 |    3 |    1 |\n-                 * |    2 |    2 |    1 |\n-                 * | NULL |    4 |    1 |\n-                 * +------+------+------+\n-                 */\n-                if (leftQuery != null) {\n-                    splitQueries.put(leftName, leftQuery);\n-                }\n-                if (rightQuery != null) {\n-                    splitQueries.put(rightName, rightQuery);\n-                }\n-\n-                newJoinIsInnerJoin = newLhs != lhs && newRhs != rhs;\n-                break;\n-            default:\n-                throw new UnsupportedOperationException(\n-                    \"The Rule to rewrite filter+outer-joins to inner joins must not be run on joins of type=\" + nl.joinType());\n-        }\n-        if (newLhs == lhs && newRhs == rhs) {\n-            return null;\n-        }\n-        NestedLoopJoin newJoin = new NestedLoopJoin(\n-            newLhs,\n-            newRhs,\n-            newJoinIsInnerJoin ? JoinType.INNER : nl.joinType(),\n-            nl.joinCondition(),\n-            nl.isFiltered(),\n-            nl.topMostLeftRelation(),\n-            nl.orderByWasPushedDown(),\n-            true\n-        );\n-        assert newJoin.outputs().equals(nl.outputs()) : \"Outputs after rewrite must be the same as before\";\n-        return splitQueries.isEmpty() ? newJoin : new Filter(newJoin, AndOperator.join(splitQueries.values()));\n-    }\n-\n-    private boolean couldMatchOnNull(@Nullable Symbol query, EvaluatingNormalizer normalizer) {\n-        if (query == null) {\n-            return false;\n-        }\n-        return WhereClause.canMatch(\n-            normalizer.normalize(\n-                RefReplacer.replaceRefs(\n-                    FieldReplacer.replaceFields(query, ignored -> Literal.NULL),\n-                    ignored -> Literal.NULL\n-                ),\n-                null)\n-        );\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMjY5OA==", "url": "https://github.com/crate/crate/pull/9944#discussion_r424412698", "bodyText": "I wonder if these should actually be instance local, and if we should have the Optimizer and SessionRegistry use the same instance. Otherwise in our tests where we simulate multiple nodes  within the same JVM we will have session settings shared across nodes. So our tests won't reflect real-world scenarios.", "author": "mfussenegger", "createdAt": "2020-05-13T12:53:37Z", "path": "sql/src/main/java/io/crate/planner/optimizer/LoadedRules.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.CaseFormat;\n+import io.crate.common.collections.Lists2;\n+import io.crate.metadata.settings.session.SessionSetting;\n+import io.crate.metadata.settings.session.SessionSettingProvider;\n+import io.crate.planner.operators.RewriteInsertFromSubQueryToInsertFromValues;\n+import io.crate.planner.optimizer.rule.DeduplicateOrder;\n+import io.crate.planner.optimizer.rule.MergeAggregateAndCollectToCount;\n+import io.crate.planner.optimizer.rule.MergeFilterAndCollect;\n+import io.crate.planner.optimizer.rule.MergeFilters;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathFetchOrEval;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathGroupBy;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathHashJoin;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathNestedLoop;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathOrder;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathProjectSet;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathRename;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathUnion;\n+import io.crate.planner.optimizer.rule.MoveFilterBeneathWindowAgg;\n+import io.crate.planner.optimizer.rule.MoveOrderBeneathFetchOrEval;\n+import io.crate.planner.optimizer.rule.MoveOrderBeneathNestedLoop;\n+import io.crate.planner.optimizer.rule.MoveOrderBeneathRename;\n+import io.crate.planner.optimizer.rule.MoveOrderBeneathUnion;\n+import io.crate.planner.optimizer.rule.RemoveRedundantFetchOrEval;\n+import io.crate.planner.optimizer.rule.RewriteCollectToGet;\n+import io.crate.planner.optimizer.rule.RewriteFilterOnOuterJoinToInnerJoin;\n+import io.crate.planner.optimizer.rule.RewriteGroupByKeysLimitToTopNDistinct;\n+import io.crate.planner.optimizer.rule.RewriteToQueryThenFetch;\n+import io.crate.types.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+public class LoadedRules implements SessionSettingProvider {\n+\n+    private static final String OPTIMIZER_RULE = \"optimizer_\";\n+\n+    private static final List<Rule<?>> RULES = List.of(", "originalCommit": "121dd8cb86c8271a7c3e1a9521020a818b979164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/optimizer/LoadedRules.java b/sql/src/main/java/io/crate/planner/optimizer/LoadedRules.java\ndeleted file mode 100644\nindex 0fe542c510..0000000000\n--- a/sql/src/main/java/io/crate/planner/optimizer/LoadedRules.java\n+++ /dev/null\n\n@@ -1,126 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.planner.optimizer;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.CaseFormat;\n-import io.crate.common.collections.Lists2;\n-import io.crate.metadata.settings.session.SessionSetting;\n-import io.crate.metadata.settings.session.SessionSettingProvider;\n-import io.crate.planner.operators.RewriteInsertFromSubQueryToInsertFromValues;\n-import io.crate.planner.optimizer.rule.DeduplicateOrder;\n-import io.crate.planner.optimizer.rule.MergeAggregateAndCollectToCount;\n-import io.crate.planner.optimizer.rule.MergeFilterAndCollect;\n-import io.crate.planner.optimizer.rule.MergeFilters;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathFetchOrEval;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathGroupBy;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathHashJoin;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathNestedLoop;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathOrder;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathProjectSet;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathRename;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathUnion;\n-import io.crate.planner.optimizer.rule.MoveFilterBeneathWindowAgg;\n-import io.crate.planner.optimizer.rule.MoveOrderBeneathFetchOrEval;\n-import io.crate.planner.optimizer.rule.MoveOrderBeneathNestedLoop;\n-import io.crate.planner.optimizer.rule.MoveOrderBeneathRename;\n-import io.crate.planner.optimizer.rule.MoveOrderBeneathUnion;\n-import io.crate.planner.optimizer.rule.RemoveRedundantFetchOrEval;\n-import io.crate.planner.optimizer.rule.RewriteCollectToGet;\n-import io.crate.planner.optimizer.rule.RewriteFilterOnOuterJoinToInnerJoin;\n-import io.crate.planner.optimizer.rule.RewriteGroupByKeysLimitToTopNDistinct;\n-import io.crate.planner.optimizer.rule.RewriteToQueryThenFetch;\n-import io.crate.types.DataTypes;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-public class LoadedRules implements SessionSettingProvider {\n-\n-    private static final String OPTIMIZER_RULE = \"optimizer_\";\n-\n-    private static final List<Rule<?>> RULES = List.of(\n-        new RemoveRedundantFetchOrEval(),\n-        new MergeAggregateAndCollectToCount(),\n-        new MergeFilters(),\n-        new MoveFilterBeneathRename(),\n-        new MoveFilterBeneathFetchOrEval(),\n-        new MoveFilterBeneathOrder(),\n-        new MoveFilterBeneathProjectSet(),\n-        new MoveFilterBeneathHashJoin(),\n-        new MoveFilterBeneathNestedLoop(),\n-        new MoveFilterBeneathUnion(),\n-        new MoveFilterBeneathGroupBy(),\n-        new MoveFilterBeneathWindowAgg(),\n-        new MergeFilterAndCollect(),\n-        new RewriteFilterOnOuterJoinToInnerJoin(),\n-        new MoveOrderBeneathUnion(),\n-        new MoveOrderBeneathNestedLoop(),\n-        new MoveOrderBeneathFetchOrEval(),\n-        new MoveOrderBeneathRename(),\n-        new DeduplicateOrder(),\n-        new RewriteCollectToGet(),\n-        new RewriteGroupByKeysLimitToTopNDistinct(),\n-        new RewriteInsertFromSubQueryToInsertFromValues(),\n-        new RewriteToQueryThenFetch()\n-    );\n-\n-    @Override\n-    public List<SessionSetting<?>> sessionSettings() {\n-        return Lists2.map(RULES, this::buildRuleSessionSetting);\n-    }\n-\n-    @VisibleForTesting\n-    SessionSetting<?> buildRuleSessionSetting(Rule<?> rule) {\n-        Class<? extends Rule> clazz = rule.getClass();\n-        var simpleName = clazz.getSimpleName();\n-        var optimizerRuleName = OPTIMIZER_RULE + CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, simpleName);\n-        return new SessionSetting<>(\n-            optimizerRuleName,\n-            objects -> {\n-            },\n-            objects -> DataTypes.BOOLEAN.value(objects[0]),\n-            (sessionContext, activateRule) -> rule.setEnabled(activateRule),\n-            s -> String.valueOf(rule.isEnabled()),\n-            () -> String.valueOf(true),\n-            String.format(Locale.ENGLISH, \"Indicates if the optimizer rule %s is activated.\", simpleName),\n-            DataTypes.BOOLEAN.getName()\n-        );\n-    }\n-\n-    public final List<Rule<?>> getRules(List<Class<? extends Rule<?>>> includedRules) {\n-        if (includedRules.isEmpty()) {\n-            return RULES;\n-        }\n-        var includes = Set.of(includedRules);\n-        var result = new ArrayList<Rule<?>>(includes.size());\n-        for (var rule : RULES) {\n-            if (includes.contains(rule.getClass())) {\n-                result.add(rule);\n-            }\n-        }\n-        return result;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMjkyOA==", "url": "https://github.com/crate/crate/pull/9944#discussion_r426432928", "bodyText": "The idea behind this is, to add more providers for other session settings.", "author": "mkleen", "createdAt": "2020-05-18T07:53:45Z", "path": "sql/src/main/java/io/crate/metadata/settings/session/SessionSettingModule.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.settings.session;\n+\n+import io.crate.planner.optimizer.LoadedRules;\n+import org.elasticsearch.common.inject.AbstractModule;\n+import org.elasticsearch.common.inject.multibindings.Multibinder;\n+\n+public class SessionSettingModule extends AbstractModule {\n+\n+    @Override\n+    protected void configure() {\n+        bind(SessionSettingRegistry.class).asEagerSingleton();", "originalCommit": "4937d31b34e5dd5572ed6f48302993cae7a4e27b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1MTUxNg==", "url": "https://github.com/crate/crate/pull/9944#discussion_r426451516", "bodyText": "Could the loadedrules.rules(rulesToInclude) call be done on the call-site? The call-site already has both components available. It would have the advantage that the Optimizer could be more easily unit-tested as the dependencies stay smaller.", "author": "mfussenegger", "createdAt": "2020-05-18T08:25:23Z", "path": "sql/src/main/java/io/crate/planner/optimizer/Optimizer.java", "diffHunk": "@@ -41,10 +42,15 @@\n \n     private final List<Rule<?>> rules;\n     private final Supplier<Version> minNodeVersionInCluster;\n+    private final Functions functions;\n \n-    public Optimizer(List<Rule<?>> rules, Supplier<Version> minNodeVersionInCluster) {\n-        this.rules = rules;\n+    public Optimizer(Functions functions,\n+                     Supplier<Version> minNodeVersionInCluster,\n+                     LoadedRules loadedRules,\n+                     List<Class<? extends Rule<?>>> rulesToInclude) {", "originalCommit": "4937d31b34e5dd5572ed6f48302993cae7a4e27b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java b/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\ndeleted file mode 100644\nindex 8521fa48ed..0000000000\n--- a/sql/src/main/java/io/crate/planner/optimizer/Optimizer.java\n+++ /dev/null\n\n@@ -1,108 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.planner.optimizer;\n-\n-import io.crate.common.collections.Lists2;\n-import io.crate.metadata.Functions;\n-import io.crate.metadata.TransactionContext;\n-import io.crate.planner.operators.LogicalPlan;\n-import io.crate.planner.optimizer.matcher.Captures;\n-import io.crate.planner.optimizer.matcher.Match;\n-import io.crate.statistics.TableStats;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.Version;\n-\n-import java.util.List;\n-import java.util.function.Supplier;\n-\n-public class Optimizer {\n-\n-    private static final Logger LOGGER = LogManager.getLogger(Optimizer.class);\n-\n-    private final List<Rule<?>> rules;\n-    private final Supplier<Version> minNodeVersionInCluster;\n-    private final Functions functions;\n-\n-    public Optimizer(Functions functions,\n-                     Supplier<Version> minNodeVersionInCluster,\n-                     LoadedRules loadedRules,\n-                     List<Class<? extends Rule<?>>> rulesToInclude) {\n-        this.rules = loadedRules.rules(rulesToInclude);\n-        this.minNodeVersionInCluster = minNodeVersionInCluster;\n-        this.functions = functions;\n-    }\n-\n-    public LogicalPlan optimize(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        LogicalPlan optimizedRoot = tryApplyRules(plan, tableStats, txnCtx);\n-        return tryApplyRules(\n-            optimizedRoot.replaceSources(Lists2.map(optimizedRoot.sources(), x -> optimize(x, tableStats, txnCtx))),\n-            tableStats,\n-            txnCtx\n-        );\n-    }\n-\n-    private LogicalPlan tryApplyRules(LogicalPlan plan, TableStats tableStats, TransactionContext txnCtx) {\n-        final boolean isTraceEnabled = LOGGER.isTraceEnabled();\n-        LogicalPlan node = plan;\n-        // Some rules may only become applicable after another rule triggered, so we keep\n-        // trying to re-apply the rules as long as at least one plan was transformed.\n-        boolean done = false;\n-        int numIterations = 0;\n-        while (!done && numIterations < 10_000) {\n-            done = true;\n-            Version minVersion = minNodeVersionInCluster.get();\n-            for (Rule rule : rules) {\n-                if (!rule.isEnabled()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' excluded from execution\");\n-                    }\n-                    continue;\n-                }\n-                if (minVersion.before(rule.requiredVersion())) {\n-                    continue;\n-                }\n-                Match<?> match = rule.pattern().accept(node, Captures.empty());\n-                if (match.isPresent()) {\n-                    if (isTraceEnabled) {\n-                        LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' matched\");\n-                    }\n-                    @SuppressWarnings(\"unchecked\")\n-                    LogicalPlan transformedPlan = rule.apply(match.value(), match.captures(), tableStats, txnCtx, functions);\n-                    if (transformedPlan != null) {\n-                        if (isTraceEnabled) {\n-                            LOGGER.trace(\"Rule '\" + rule.getClass().getSimpleName() + \"' transformed the logical plan\");\n-                        }\n-                        node = transformedPlan;\n-                        done = false;\n-                    }\n-                }\n-            }\n-            numIterations++;\n-        }\n-        assert numIterations < 10_000\n-            : \"Optimizer reached 10_000 iterations safety guard. This is an indication of a broken rule that matches again and again\";\n-        return node;\n-    }\n-\n-}\n"}}, {"oid": "d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "url": "https://github.com/crate/crate/commit/d9ab82f3feb9b247387bb9868c84dfdfd2f0b5ac", "message": "Add documentation for optimizer session setting", "committedDate": "2020-05-18T12:48:09Z", "type": "forcePushed"}, {"oid": "3b82acf290bb78f2f4cc39773a7006f75a1cb632", "url": "https://github.com/crate/crate/commit/3b82acf290bb78f2f4cc39773a7006f75a1cb632", "message": "Add documentation for optimizer session setting", "committedDate": "2020-05-18T13:52:28Z", "type": "forcePushed"}, {"oid": "effbe61dbe3eae6d7251b9aca17d62e010dc4261", "url": "https://github.com/crate/crate/commit/effbe61dbe3eae6d7251b9aca17d62e010dc4261", "message": "Add session basesd optimizer configuration", "committedDate": "2020-05-18T14:18:44Z", "type": "forcePushed"}, {"oid": "d1bcead77a816697d24b31a8d2ba4f0e6a74c8c6", "url": "https://github.com/crate/crate/commit/d1bcead77a816697d24b31a8d2ba4f0e6a74c8c6", "message": "Add session basesd optimizer configuration", "committedDate": "2020-05-18T14:46:17Z", "type": "forcePushed"}, {"oid": "3f8fddfed7ecbb586b5f16a1beb625b94c9977c2", "url": "https://github.com/crate/crate/commit/3f8fddfed7ecbb586b5f16a1beb625b94c9977c2", "message": "Add session setting to configure optimizer rules.", "committedDate": "2020-05-18T14:47:56Z", "type": "forcePushed"}, {"oid": "d90676b5fe341b05dce6592fff841101e6752cb5", "url": "https://github.com/crate/crate/commit/d90676b5fe341b05dce6592fff841101e6752cb5", "message": "Add session setting to configure optimizer rules.", "committedDate": "2020-05-18T14:49:16Z", "type": "forcePushed"}, {"oid": "b7f55cc88f828c23097e4b63df7049a775c24227", "url": "https://github.com/crate/crate/commit/b7f55cc88f828c23097e4b63df7049a775c24227", "message": "Add `optimizer` session setting to configure optimizer rules.", "committedDate": "2020-05-18T14:50:53Z", "type": "forcePushed"}, {"oid": "c3ca28e5f3a9e99dbaf4324990f3a01039394f71", "url": "https://github.com/crate/crate/commit/c3ca28e5f3a9e99dbaf4324990f3a01039394f71", "message": "Add `optimizer` session setting to configure query optimizer rules.", "committedDate": "2020-05-18T14:55:40Z", "type": "forcePushed"}, {"oid": "cd0446915a55f7b39df46ed5c163d42df3e13a21", "url": "https://github.com/crate/crate/commit/cd0446915a55f7b39df46ed5c163d42df3e13a21", "message": "Add `optimizer` session setting to configure query optimizer rules.", "committedDate": "2020-05-18T14:58:14Z", "type": "forcePushed"}, {"oid": "fa2297c8c13625516287aa580930d3f3581dc54b", "url": "https://github.com/crate/crate/commit/fa2297c8c13625516287aa580930d3f3581dc54b", "message": "Add `optimizer` session setting to configure query optimizer rules.", "committedDate": "2020-05-18T17:48:40Z", "type": "forcePushed"}, {"oid": "532018f44973db74c06c4d297eaa297c02e0c161", "url": "https://github.com/crate/crate/commit/532018f44973db74c06c4d297eaa297c02e0c161", "message": "Add `optimizer` session setting to configure query optimizer rules.", "committedDate": "2020-05-19T09:29:16Z", "type": "forcePushed"}, {"oid": "878c458b66950beb8df690a9679d8f29db823758", "url": "https://github.com/crate/crate/commit/878c458b66950beb8df690a9679d8f29db823758", "message": "Add `optimizer` session setting to configure query optimizer rules.", "committedDate": "2020-05-19T09:36:45Z", "type": "commit"}, {"oid": "878c458b66950beb8df690a9679d8f29db823758", "url": "https://github.com/crate/crate/commit/878c458b66950beb8df690a9679d8f29db823758", "message": "Add `optimizer` session setting to configure query optimizer rules.", "committedDate": "2020-05-19T09:36:45Z", "type": "forcePushed"}, {"oid": "60cde423517eecfd2a75c0e58c256b48372c3d33", "url": "https://github.com/crate/crate/commit/60cde423517eecfd2a75c0e58c256b48372c3d33", "message": "Merge branch 'master' into mkleen/optimizer_rules_v2", "committedDate": "2020-05-19T10:10:45Z", "type": "commit"}, {"oid": "19b7ebbbd94cec554534bbd4d7fab8a5038aaf3c", "url": "https://github.com/crate/crate/commit/19b7ebbbd94cec554534bbd4d7fab8a5038aaf3c", "message": "Merge branch 'master' into mkleen/optimizer_rules_v2", "committedDate": "2020-05-19T10:44:31Z", "type": "commit"}]}