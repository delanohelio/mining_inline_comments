{"pr_number": 9528, "pr_title": "Allow more lenient column type validation in VALUES.", "pr_createdAt": "2020-01-17T10:31:04Z", "pr_url": "https://github.com/crate/crate/pull/9528", "timeline": [{"oid": "48ee733cc38614e1707bdf371b642231f38ce5d5", "url": "https://github.com/crate/crate/commit/48ee733cc38614e1707bdf371b642231f38ce5d5", "message": "Allow more lenient column type validation in VALUES.\n\nCurrently, the column types in VALUES have to be an exact\nmatch which prevents using expressions that can be implicitly\ncasted and `null` literals.", "committedDate": "2020-01-17T10:41:34Z", "type": "forcePushed"}, {"oid": "c9727b9a2a1bc69b1fd426bd42b204bb8b535315", "url": "https://github.com/crate/crate/commit/c9727b9a2a1bc69b1fd426bd42b204bb8b535315", "message": "Allow more lenient column type validation in VALUES.\n\nCurrently, the column types in VALUES have to be an exact\nmatch which prevents using expressions that can be implicitly\ncasted and `null` literals.", "committedDate": "2020-01-17T11:10:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzNDczMA==", "url": "https://github.com/crate/crate/pull/9528#discussion_r367934730", "bodyText": "Which type will this end up using? Couldn't this lead to ClassCastExceptions due to a mixture of types?\nIn the other branch we've type precedence logic integrated. See https://github.com/crate/crate/pull/9465/files#diff-bf12c5e61f9b0fe950aa518b1ed601abR807", "author": "mfussenegger", "createdAt": "2020-01-17T13:29:24Z", "path": "sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java", "diffHunk": "@@ -750,7 +750,8 @@ public AnalyzedRelation visitValues(Values values, StatementAnalysisContext cont\n                 for (int i = 0; i < firstRow.size(); i++) {\n                     var typeOfFirstRowAtPos = firstRow.get(i).valueType();\n                     var typeOfCurrentRowAtPos = columns.get(i).valueType();\n-                    if (!typeOfCurrentRowAtPos.equals(typeOfFirstRowAtPos)) {\n+                    if (!typeOfFirstRowAtPos.isConvertableTo(typeOfCurrentRowAtPos)", "originalCommit": "c9727b9a2a1bc69b1fd426bd42b204bb8b535315", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2081f3adc017284649c96693a648d048c50d089", "chunk": "diff --git a/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java b/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\nindex 152835b4e6..18d8828c95 100644\n--- a/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\n+++ b/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\n\n@@ -732,43 +733,55 @@ public class RelationAnalyzer extends DefaultTraversalVisitor<AnalyzedRelation,\n             new SubqueryAnalyzer(this, context)\n         );\n         var expressionAnalysisContext = new ExpressionAnalysisContext();\n-        java.util.function.Function<Expression, Symbol> expressionToSymbol = e -> expressionAnalyzer.convert(e, expressionAnalysisContext);\n-\n-        ArrayList<List<Symbol>> rows = new ArrayList<>(values.rows().size());\n-        List<Symbol> firstRow = null;\n-        for (ValuesList row : values.rows()) {\n-            List<Symbol> columns = Lists2.map(row.values(), expressionToSymbol);\n-            rows.add(columns);\n-            if (firstRow == null) {\n-                firstRow = columns;\n-            } else {\n-                if (firstRow.size() != columns.size()) {\n+        java.util.function.Function<Expression, Symbol> expressionToSymbol =\n+            e -> expressionAnalyzer.convert(e, expressionAnalysisContext);\n+\n+        // There is a first pass to convert expressions from row oriented format:\n+        // `[[1, a], [2, b]]` to columns `[[1, 2], [a, b]]`\n+        //\n+        // At the same time we determine the column type with the highest precedence,\n+        // so that we don't fail with slight type miss-matches (long vs. int)\n+        List<ValuesList> rows = values.rows();\n+        assert rows.size() > 0 : \"Parser grammar enforces at least 1 row\";\n+        ValuesList firstRow = rows.get(0);\n+        int numColumns = firstRow.values().size();\n+\n+        ArrayList<List<Symbol>> columns = new ArrayList<>();\n+        ArrayList<DataType<?>> targetTypes = new ArrayList<>(numColumns);\n+        for (int c = 0; c < numColumns; c++) {\n+            ArrayList<Symbol> columnValues = new ArrayList<>();\n+            DataType<?> targetType = DataTypes.UNDEFINED;\n+            for (int r = 0; r < rows.size(); r++) {\n+                List<Expression> row = rows.get(r).values();\n+                if (row.size() != numColumns) {\n                     throw new IllegalArgumentException(\n                         \"VALUES lists must all be the same length. \" +\n-                        \"Found row with \" + firstRow.size() + \" items and another with \" + columns.size() + \" items\");\n+                        \"Found row with \" + numColumns + \" items and another with \" + columns.size() + \" items\");\n                 }\n-                for (int i = 0; i < firstRow.size(); i++) {\n-                    var typeOfFirstRowAtPos = firstRow.get(i).valueType();\n-                    var typeOfCurrentRowAtPos = columns.get(i).valueType();\n-                    if (!typeOfFirstRowAtPos.isConvertableTo(typeOfCurrentRowAtPos)\n-                        && typeOfCurrentRowAtPos.id() != DataTypes.UNDEFINED.id()) {\n-                        throw new IllegalArgumentException(\n-                            \"The types of the columns within VALUES lists must match. \" +\n-                            \"Found `\" + typeOfFirstRowAtPos + \"` and `\" + typeOfCurrentRowAtPos + \"` at position: \" + i);\n-                    }\n+                Symbol cell = expressionToSymbol.apply(row.get(c));\n+                columnValues.add(cell);\n+\n+                var cellType = cell.valueType();\n+                if (r > 0 // skip first cell, we don't have to check for self-conversion\n+                    && !cellType.isConvertableTo(targetType)\n+                    && targetType.id() != DataTypes.UNDEFINED.id()) {\n+                    throw new IllegalArgumentException(\n+                        \"The types of the columns within VALUES lists must match. \" +\n+                        \"Found `\" + targetType + \"` and `\" + cellType + \"` at position: \" + c);\n+                }\n+                if (cellType.precedes(targetType)) {\n+                    targetType = cellType;\n                 }\n             }\n+            targetTypes.add(targetType);\n+            columns.add(columnValues);\n         }\n-        assert firstRow != null : \"Parser grammar enforces at least 1 row, so firstRow can't be null\";\n-\n-        // We re-write VALUES to a UNNEST table function, so that we can re-use the execution layer logic\n \n-        List<List<Symbol>> columns = Lists2.toColumnOrientation(rows);\n         ArrayList<Symbol> arrays = new ArrayList<>(columns.size());\n-        for (int i = 0; i < firstRow.size(); i++) {\n-            Symbol column = firstRow.get(i);\n-            ArrayType<?> arrayType = new ArrayType<>(column.valueType());\n-            List<Symbol> columnValues = columns.get(i);\n+        for (int c = 0; c < numColumns; c++) {\n+            DataType<?> targetType = targetTypes.get(c);\n+            ArrayType<?> arrayType = new ArrayType<>(targetType);\n+            List<Symbol> columnValues = Lists2.map(columns.get(c), s -> s.cast(targetType));\n             arrays.add(new Function(\n                 new FunctionInfo(new FunctionIdent(ArrayFunction.NAME, Symbols.typeView(columnValues)), arrayType),\n                 columnValues\n"}}, {"oid": "a2081f3adc017284649c96693a648d048c50d089", "url": "https://github.com/crate/crate/commit/a2081f3adc017284649c96693a648d048c50d089", "message": "fixup! Allow more lenient column type validation in VALUES.", "committedDate": "2020-01-20T08:44:25Z", "type": "forcePushed"}, {"oid": "78325ee267569db1369c501794588828b936876a", "url": "https://github.com/crate/crate/commit/78325ee267569db1369c501794588828b936876a", "message": "Allow more lenient column type validation in VALUES.\n\nCurrently, the column types in VALUES have to be an exact\nmatch which prevents using expressions that can be implicitly\ncasted and `null` literals.", "committedDate": "2020-01-20T09:15:13Z", "type": "commit"}, {"oid": "78325ee267569db1369c501794588828b936876a", "url": "https://github.com/crate/crate/commit/78325ee267569db1369c501794588828b936876a", "message": "Allow more lenient column type validation in VALUES.\n\nCurrently, the column types in VALUES have to be an exact\nmatch which prevents using expressions that can be implicitly\ncasted and `null` literals.", "committedDate": "2020-01-20T09:15:13Z", "type": "forcePushed"}]}