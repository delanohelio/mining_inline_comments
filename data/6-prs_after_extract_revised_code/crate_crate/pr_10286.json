{"pr_number": 10286, "pr_title": "Add pg_function_is_visible scalar required to run conn.getMetaData().getFunctions", "pr_createdAt": "2020-07-28T14:22:07Z", "pr_url": "https://github.com/crate/crate/pull/10286", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE0NjMyMA==", "url": "https://github.com/crate/crate/pull/10286#discussion_r462146320", "bodyText": "why you fetch only one signature, a function can be overloaded and can have more than one signature.", "author": "kovrus", "createdAt": "2020-07-29T08:57:22Z", "path": "server/src/main/java/io/crate/expression/AbstractFunctionModule.java", "diffHunk": "@@ -50,9 +59,41 @@ public void register(Signature signature, BiFunction<Signature, Signature, Funct\n             throw new IllegalStateException(\n                 \"A function already exists for signature = \" + signature);\n         }\n+        signatureByOid.put(signature.getOid(), signature);\n+        signatureByName.put(signature.getName(), signature);\n+        schemas.add(signature.getName().schema());\n         functions.add(new FunctionProvider(signature, factory));\n     }\n \n+    public Signature getFunctionSignatureByOid(Integer funcOid) {\n+        if (funcOid == null) {\n+            new IllegalArgumentException(\"function oid cannot be null\");\n+        }\n+        return signatureByOid.get(funcOid);\n+    }\n+\n+    public Signature getFunctionSignaturesByName(String funcName) {\n+        if (funcName == null) {\n+            new IllegalArgumentException(\"function name cannot be null\");\n+        }\n+        int dot = funcName.indexOf(\".\");\n+        if (dot != -1) {\n+            String [] parts = funcName.split(\"\\\\.\");\n+            if (parts.length != 2) {\n+                new IllegalArgumentException(String.format(\n+                    Locale.ENGLISH, \"unrecognised function name format\", funcName));\n+            }\n+            return signatureByName.get(new FunctionName(parts[0], parts[1]));\n+        }\n+        Optional<Signature> maybeSignature = schemas // [null, pg_catalog ...]\n+            .stream()\n+            .map(sch -> new FunctionName(sch, funcName))\n+            .map(signatureByName::get)\n+            .filter(Objects::nonNull)\n+            .findFirst();", "originalCommit": "c1272c8fa94a898bba39447fae15ff1e0905351d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c3cff9cb74eb7c151fb7328a14f4380d8a410bde", "chunk": "diff --git a/server/src/main/java/io/crate/expression/AbstractFunctionModule.java b/server/src/main/java/io/crate/expression/AbstractFunctionModule.java\nindex 8fb63dc7a7..58be855f60 100644\n--- a/server/src/main/java/io/crate/expression/AbstractFunctionModule.java\n+++ b/server/src/main/java/io/crate/expression/AbstractFunctionModule.java\n\n@@ -60,15 +61,27 @@ public abstract class AbstractFunctionModule<T extends FunctionImplementation> e\n                 \"A function already exists for signature = \" + signature);\n         }\n         signatureByOid.put(signature.getOid(), signature);\n+        for (Map.Entry<Integer, Signature> e : signatureByOid.entrySet()) {\n+            System.out.printf(Locale.ENGLISH,\"REGISTER %d -> %s\\n\", e.getKey(), e.getValue().getName());\n+        }\n         signatureByName.put(signature.getName(), signature);\n         schemas.add(signature.getName().schema());\n         functions.add(new FunctionProvider(signature, factory));\n     }\n \n+    public Map<Integer, Signature> getFunctionOidToSignatureMap() {\n+        return Collections.unmodifiableMap(signatureByOid);\n+    }\n+\n+\n     public Signature getFunctionSignatureByOid(Integer funcOid) {\n         if (funcOid == null) {\n             new IllegalArgumentException(\"function oid cannot be null\");\n         }\n+        for (Map.Entry<Integer, Signature> e : signatureByOid.entrySet()) {\n+            System.out.printf(Locale.ENGLISH,\"LOOKUP %d -> %s\\n\", e.getKey(), e.getValue().getName());\n+        }\n+\n         return signatureByOid.get(funcOid);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE0NzM5Nw==", "url": "https://github.com/crate/crate/pull/10286#discussion_r462147397", "bodyText": "would this still work fine with UDF functions that can be added and removed?", "author": "kovrus", "createdAt": "2020-07-29T08:58:55Z", "path": "server/src/main/java/io/crate/expression/AbstractFunctionModule.java", "diffHunk": "@@ -32,14 +32,23 @@\n \n import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.function.BiFunction;\n \n public abstract class AbstractFunctionModule<T extends FunctionImplementation> extends AbstractModule {\n \n     private HashMap<FunctionName, List<FunctionProvider>> functionImplementations = new HashMap<>();\n     private MapBinder<FunctionName, List<FunctionProvider>> implementationsBinder;\n+    private Map<Integer, Signature> signatureByOid = new HashMap<>();\n+    private Map<FunctionName, Signature> signatureByName = new HashMap<>();\n+    private Set<String> schemas = new HashSet<>();", "originalCommit": "c1272c8fa94a898bba39447fae15ff1e0905351d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c3cff9cb74eb7c151fb7328a14f4380d8a410bde", "chunk": "diff --git a/server/src/main/java/io/crate/expression/AbstractFunctionModule.java b/server/src/main/java/io/crate/expression/AbstractFunctionModule.java\nindex 8fb63dc7a7..58be855f60 100644\n--- a/server/src/main/java/io/crate/expression/AbstractFunctionModule.java\n+++ b/server/src/main/java/io/crate/expression/AbstractFunctionModule.java\n\n@@ -31,6 +31,7 @@ import org.elasticsearch.common.inject.TypeLiteral;\n import org.elasticsearch.common.inject.multibindings.MapBinder;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n"}}, {"oid": "c3cff9cb74eb7c151fb7328a14f4380d8a410bde", "url": "https://github.com/crate/crate/commit/c3cff9cb74eb7c151fb7328a14f4380d8a410bde", "message": "Save state, but this will not build", "committedDate": "2020-07-31T08:14:28Z", "type": "forcePushed"}, {"oid": "bcfffe24d92322e19efc0aeb1ef53dd00a242503", "url": "https://github.com/crate/crate/commit/bcfffe24d92322e19efc0aeb1ef53dd00a242503", "message": "Reduce to function PgFunctionIsVisible which is a simpler case", "committedDate": "2020-07-31T08:35:11Z", "type": "forcePushed"}, {"oid": "eb0388366c3afdb423593a293dba0526cef7239c", "url": "https://github.com/crate/crate/commit/eb0388366c3afdb423593a293dba0526cef7239c", "message": "Regproc represents many OIDs, for functions these are built based on signature", "committedDate": "2020-08-03T11:37:33Z", "type": "forcePushed"}, {"oid": "330b405039dcfa03fd175e16d521a63d209c91b1", "url": "https://github.com/crate/crate/commit/330b405039dcfa03fd175e16d521a63d209c91b1", "message": "Add support for user defined functions", "committedDate": "2020-08-03T14:48:22Z", "type": "forcePushed"}, {"oid": "ce45641a129936eea96fea373ce3034d0ed90ab8", "url": "https://github.com/crate/crate/commit/ce45641a129936eea96fea373ce3034d0ed90ab8", "message": "Add support for user defined functions", "committedDate": "2020-08-03T16:56:37Z", "type": "forcePushed"}, {"oid": "4e0398ccdc1076080abbf8ee82040d348a336826", "url": "https://github.com/crate/crate/commit/4e0398ccdc1076080abbf8ee82040d348a336826", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash on its schema, name, arg types list.\nSystem functions are declared on startup, as the various modules are registered,\nregistering in turn the system functions.\nUser defined functions, UDF, are registered/deregistered dinamically with SQL\nstatements CREATE/DROP FUNCTION.\nUsers can 'select function pg_function_is_visible(<oid>)' to check that the\nfunction with <oid> OID is visible.\nAll system and UDF functions are visible.", "committedDate": "2020-08-04T08:47:09Z", "type": "forcePushed"}, {"oid": "2d9c070ccbd5555183f3e5441c35998470ad53bd", "url": "https://github.com/crate/crate/commit/2d9c070ccbd5555183f3e5441c35998470ad53bd", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-04T09:28:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5OTk0Mg==", "url": "https://github.com/crate/crate/pull/10286#discussion_r465499942", "bodyText": "Having this as global static kinda defeats the purpose of using guice/injection for the functions.\nI think this should move into Functions. Then the evaluate of a Scalar somehow needs to get access to it, or to a subset / narrower interface.\nI'm also not sure if it is worth to pre-populate a full map given the use case. I suppose pg_function_is_visible won't be called too often, so we could consider doing the lookup and oid calculation on the fly and trade increased memory footprint with a higher compute demand when it is actually used.", "author": "mfussenegger", "createdAt": "2020-08-05T06:24:21Z", "path": "server/src/main/java/io/crate/expression/AbstractFunctionModule.java", "diffHunk": "@@ -34,10 +38,16 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n \n public abstract class AbstractFunctionModule<T extends FunctionImplementation> extends AbstractModule {\n \n+    private static ConcurrentMap<Integer, Signature> SYSTEM_FUNCTION_SIGNATURES_BY_OID = new ConcurrentHashMap<>();", "originalCommit": "2d9c070ccbd5555183f3e5441c35998470ad53bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8fb82117f064893388812d2388fc86e25e918b4b", "chunk": "diff --git a/server/src/main/java/io/crate/expression/AbstractFunctionModule.java b/server/src/main/java/io/crate/expression/AbstractFunctionModule.java\nindex 438ddd98d7..f77ef63ee0 100644\n--- a/server/src/main/java/io/crate/expression/AbstractFunctionModule.java\n+++ b/server/src/main/java/io/crate/expression/AbstractFunctionModule.java\n\n@@ -38,16 +34,10 @@ import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n import java.util.function.BiFunction;\n-import java.util.stream.Collectors;\n \n public abstract class AbstractFunctionModule<T extends FunctionImplementation> extends AbstractModule {\n \n-    private static ConcurrentMap<Integer, Signature> SYSTEM_FUNCTION_SIGNATURES_BY_OID = new ConcurrentHashMap<>();\n-    private static ConcurrentMap<Integer, Signature> UDF_FUNCTION_SIGNATURES_BY_OID = new ConcurrentHashMap<>();\n-\n     private HashMap<FunctionName, List<FunctionProvider>> functionImplementations = new HashMap<>();\n     private MapBinder<FunctionName, List<FunctionProvider>> implementationsBinder;\n \n"}}, {"oid": "57c2ed241cad660186794c6ffc5c3cc14f89f8b4", "url": "https://github.com/crate/crate/commit/57c2ed241cad660186794c6ffc5c3cc14f89f8b4", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-05T20:32:06Z", "type": "forcePushed"}, {"oid": "60ccfdb01e7a5531eaffc0b26d6aa5ba747e201a", "url": "https://github.com/crate/crate/commit/60ccfdb01e7a5531eaffc0b26d6aa5ba747e201a", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-05T20:34:30Z", "type": "forcePushed"}, {"oid": "8fb82117f064893388812d2388fc86e25e918b4b", "url": "https://github.com/crate/crate/commit/8fb82117f064893388812d2388fc86e25e918b4b", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-05T20:41:18Z", "type": "forcePushed"}, {"oid": "62fd3105496cf13c6e4a658c61bad6e0e57e2894", "url": "https://github.com/crate/crate/commit/62fd3105496cf13c6e4a658c61bad6e0e57e2894", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-05T20:47:04Z", "type": "forcePushed"}, {"oid": "7ca5e6b70a9e355d3e474d63b8347909beff3053", "url": "https://github.com/crate/crate/commit/7ca5e6b70a9e355d3e474d63b8347909beff3053", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-05T20:52:45Z", "type": "forcePushed"}, {"oid": "ad8fd54149d28df29568e9353572c871186560d9", "url": "https://github.com/crate/crate/commit/ad8fd54149d28df29568e9353572c871186560d9", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-05T21:58:08Z", "type": "forcePushed"}, {"oid": "53db3ee2a26c8ce76bc8e1ef7460b92906dad881", "url": "https://github.com/crate/crate/commit/53db3ee2a26c8ce76bc8e1ef7460b92906dad881", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-06T10:41:07Z", "type": "forcePushed"}, {"oid": "31670a248bf48bf0f64e84ae47b391580ba0bbd9", "url": "https://github.com/crate/crate/commit/31670a248bf48bf0f64e84ae47b391580ba0bbd9", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-06T10:49:46Z", "type": "forcePushed"}, {"oid": "6fccbab92f50ba0f1100069988615bdd87c86490", "url": "https://github.com/crate/crate/commit/6fccbab92f50ba0f1100069988615bdd87c86490", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-06T11:20:46Z", "type": "forcePushed"}, {"oid": "d81dfd547e0a68f0a3042e9b920537d280edb640", "url": "https://github.com/crate/crate/commit/d81dfd547e0a68f0a3042e9b920537d280edb640", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-06T11:28:51Z", "type": "forcePushed"}, {"oid": "5bd712847ac4cd243fe69a206c1f715742fa80cd", "url": "https://github.com/crate/crate/commit/5bd712847ac4cd243fe69a206c1f715742fa80cd", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-06T11:42:11Z", "type": "forcePushed"}, {"oid": "31a96487c4e7cf21aea12429b69aa170fe6da5d9", "url": "https://github.com/crate/crate/commit/31a96487c4e7cf21aea12429b69aa170fe6da5d9", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-06T11:48:20Z", "type": "forcePushed"}, {"oid": "c868b1aed114a8e2a425b02427caa1b84bb8d9bf", "url": "https://github.com/crate/crate/commit/c868b1aed114a8e2a425b02427caa1b84bb8d9bf", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-06T11:53:50Z", "type": "forcePushed"}, {"oid": "dc688cac79890aa42e2e3364bf47c1e384a207d1", "url": "https://github.com/crate/crate/commit/dc688cac79890aa42e2e3364bf47c1e384a207d1", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-06T12:11:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM5Njg3Nw==", "url": "https://github.com/crate/crate/pull/10286#discussion_r466396877", "bodyText": "The BytesRef creation could be avoided I think. This is probably only doing a utf-16 to utf-8 conversion? Could likely call .getBytes(...) on the String directly to get the bytes.", "author": "mfussenegger", "createdAt": "2020-08-06T13:05:29Z", "path": "server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java", "diffHunk": "@@ -63,12 +67,37 @@ static int constraintOid(String relationName, String constraintName, String cons\n         return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n     }\n \n-    public static int functionOid(FunctionName functionName) {\n-        BytesRef b = new BytesRef(Type.PROC.toString() + functionName.schema() + functionName.name());\n+    public static int regprocOid(FunctionName name) {\n+        BytesRef b = new BytesRef(Type.PROC.toString() + name.schema() + name.name());", "originalCommit": "dc688cac79890aa42e2e3364bf47c1e384a207d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQxMzExNA==", "url": "https://github.com/crate/crate/pull/10286#discussion_r466413114", "bodyText": "does this extend to all the methods in OidHash? I mimicked the code.", "author": "marregui", "createdAt": "2020-08-06T13:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM5Njg3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "04adcad744952dfcf0d5e74e9d5aecdeb4bf0aa9", "chunk": "diff --git a/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java b/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java\nindex d21ba84867..62bc953190 100644\n--- a/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java\n+++ b/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java\n\n@@ -45,58 +47,52 @@ public final class OidHash {\n         PROC\n     }\n \n+    private static int oid(String... keys) {\n+        byte [] b = Lists2.joinOn(\"\", Arrays.asList(keys), Function.identity()).getBytes();\n+        return murmurhash3_x86_32(b, 0, b.length, 0);\n+    }\n+\n     public static int relationOid(RelationInfo relationInfo) {\n         Type t = relationInfo.relationType() == RelationInfo.RelationType.VIEW ? Type.VIEW : Type.TABLE;\n-        BytesRef b = new BytesRef(t.toString() + relationInfo.ident().fqn());\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+        return oid(t.toString(), relationInfo.ident().fqn());\n     }\n \n     public static int schemaOid(String name) {\n-        BytesRef b = new BytesRef(Type.SCHEMA.toString() + name);\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+        return oid(Type.SCHEMA.toString(), name);\n     }\n \n     public static int primaryKeyOid(RelationInfo relationInfo) {\n         var primaryKey = Lists2.joinOn(\" \", relationInfo.primaryKey(), ColumnIdent::name);\n-        var b = new BytesRef(Type.PRIMARY_KEY.toString() + relationInfo.ident().fqn() + primaryKey);\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+        return oid(Type.PRIMARY_KEY.toString(), relationInfo.ident().fqn(), primaryKey);\n     }\n \n-    static int constraintOid(String relationName, String constraintName, String constraintType) {\n-        BytesRef b = new BytesRef(Type.CONSTRAINT.toString() + relationName + constraintName + constraintType);\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+    public static int constraintOid(String relationName, String constraintName, String constraintType) {\n+        return oid(Type.CONSTRAINT.toString(), relationName, constraintName, constraintType);\n     }\n \n     public static int regprocOid(FunctionName name) {\n-        BytesRef b = new BytesRef(Type.PROC.toString() + name.schema() + name.name());\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+        return oid(Type.PROC.toString(), name.schema(), name.name());\n     }\n \n     public static int regprocOid(String name) {\n-        return regprocOid(new FunctionName(null, name));\n+        return oid(Type.PROC.toString(), null, name);\n     }\n \n     public static int functionOid(Signature sig) {\n         FunctionName name = sig.getName();\n-        BytesRef b = new BytesRef(\n-            new StringBuilder(Type.PROC.toString())\n-                .append(name.schema() == null ? \"\" : name.schema())\n-                .append(name.name())\n-                .append(argTypesToStr(sig.getArgumentTypes()))\n-                .toString());\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+        return oid(Type.PROC.toString(), name.schema(), name.name(), argTypesToStr(sig.getArgumentTypes()));\n     }\n \n-    private static String argTypesToStr(List<TypeSignature> typeSignatures) {\n-        return Lists2.joinOn(\" \", typeSignatures, typeSignature -> {\n+    @VisibleForTesting\n+    static String argTypesToStr(List<TypeSignature> typeSignatures) {\n+        return Lists2.joinOn(\" \", typeSignatures, ts -> {\n             try {\n-                return typeSignature.createType().getName();\n+                return ts.createType().getName();\n             } catch (IllegalArgumentException i) {\n-                // generic signatures, e.g. E, array[E]\n-                String baseName = typeSignature.getBaseTypeName();\n-                List<TypeSignature> innerTypeSignatures = typeSignature.getParameters();\n-                return innerTypeSignatures.isEmpty() ?\n-                    \"[\" + baseName + \"]\" : baseName + argTypesToStr(innerTypeSignatures);\n+                // generic signatures, e.g. E, array(E)\n+                String baseName = ts.getBaseTypeName();\n+                List<TypeSignature> innerTs = ts.getParameters();\n+                return baseName + (innerTs.isEmpty() ? \"\" : \"_\" + argTypesToStr(innerTs));\n             }\n         });\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM5NzAxOQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r466397019", "bodyText": "Same here", "author": "mfussenegger", "createdAt": "2020-08-06T13:05:40Z", "path": "server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java", "diffHunk": "@@ -63,12 +67,37 @@ static int constraintOid(String relationName, String constraintName, String cons\n         return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n     }\n \n-    public static int functionOid(FunctionName functionName) {\n-        BytesRef b = new BytesRef(Type.PROC.toString() + functionName.schema() + functionName.name());\n+    public static int regprocOid(FunctionName name) {\n+        BytesRef b = new BytesRef(Type.PROC.toString() + name.schema() + name.name());\n+        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+    }\n+\n+    public static int regprocOid(String name) {\n+        return regprocOid(new FunctionName(null, name));\n+    }\n+\n+    public static int functionOid(Signature sig) {\n+        FunctionName name = sig.getName();\n+        BytesRef b = new BytesRef(", "originalCommit": "dc688cac79890aa42e2e3364bf47c1e384a207d1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04adcad744952dfcf0d5e74e9d5aecdeb4bf0aa9", "chunk": "diff --git a/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java b/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java\nindex d21ba84867..62bc953190 100644\n--- a/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java\n+++ b/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java\n\n@@ -45,58 +47,52 @@ public final class OidHash {\n         PROC\n     }\n \n+    private static int oid(String... keys) {\n+        byte [] b = Lists2.joinOn(\"\", Arrays.asList(keys), Function.identity()).getBytes();\n+        return murmurhash3_x86_32(b, 0, b.length, 0);\n+    }\n+\n     public static int relationOid(RelationInfo relationInfo) {\n         Type t = relationInfo.relationType() == RelationInfo.RelationType.VIEW ? Type.VIEW : Type.TABLE;\n-        BytesRef b = new BytesRef(t.toString() + relationInfo.ident().fqn());\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+        return oid(t.toString(), relationInfo.ident().fqn());\n     }\n \n     public static int schemaOid(String name) {\n-        BytesRef b = new BytesRef(Type.SCHEMA.toString() + name);\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+        return oid(Type.SCHEMA.toString(), name);\n     }\n \n     public static int primaryKeyOid(RelationInfo relationInfo) {\n         var primaryKey = Lists2.joinOn(\" \", relationInfo.primaryKey(), ColumnIdent::name);\n-        var b = new BytesRef(Type.PRIMARY_KEY.toString() + relationInfo.ident().fqn() + primaryKey);\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+        return oid(Type.PRIMARY_KEY.toString(), relationInfo.ident().fqn(), primaryKey);\n     }\n \n-    static int constraintOid(String relationName, String constraintName, String constraintType) {\n-        BytesRef b = new BytesRef(Type.CONSTRAINT.toString() + relationName + constraintName + constraintType);\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+    public static int constraintOid(String relationName, String constraintName, String constraintType) {\n+        return oid(Type.CONSTRAINT.toString(), relationName, constraintName, constraintType);\n     }\n \n     public static int regprocOid(FunctionName name) {\n-        BytesRef b = new BytesRef(Type.PROC.toString() + name.schema() + name.name());\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+        return oid(Type.PROC.toString(), name.schema(), name.name());\n     }\n \n     public static int regprocOid(String name) {\n-        return regprocOid(new FunctionName(null, name));\n+        return oid(Type.PROC.toString(), null, name);\n     }\n \n     public static int functionOid(Signature sig) {\n         FunctionName name = sig.getName();\n-        BytesRef b = new BytesRef(\n-            new StringBuilder(Type.PROC.toString())\n-                .append(name.schema() == null ? \"\" : name.schema())\n-                .append(name.name())\n-                .append(argTypesToStr(sig.getArgumentTypes()))\n-                .toString());\n-        return murmurhash3_x86_32(b.bytes, b.offset, b.length, 0);\n+        return oid(Type.PROC.toString(), name.schema(), name.name(), argTypesToStr(sig.getArgumentTypes()));\n     }\n \n-    private static String argTypesToStr(List<TypeSignature> typeSignatures) {\n-        return Lists2.joinOn(\" \", typeSignatures, typeSignature -> {\n+    @VisibleForTesting\n+    static String argTypesToStr(List<TypeSignature> typeSignatures) {\n+        return Lists2.joinOn(\" \", typeSignatures, ts -> {\n             try {\n-                return typeSignature.createType().getName();\n+                return ts.createType().getName();\n             } catch (IllegalArgumentException i) {\n-                // generic signatures, e.g. E, array[E]\n-                String baseName = typeSignature.getBaseTypeName();\n-                List<TypeSignature> innerTypeSignatures = typeSignature.getParameters();\n-                return innerTypeSignatures.isEmpty() ?\n-                    \"[\" + baseName + \"]\" : baseName + argTypesToStr(innerTypeSignatures);\n+                // generic signatures, e.g. E, array(E)\n+                String baseName = ts.getBaseTypeName();\n+                List<TypeSignature> innerTs = ts.getParameters();\n+                return baseName + (innerTs.isEmpty() ? \"\" : \"_\" + argTypesToStr(innerTs));\n             }\n         });\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM5ODU3MQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r466398571", "bodyText": "I'm not sure if the functions fit into the TransactionContext - as the name implies it should contain state that is bound to the lifecycle of a transaction.\nThe Functions have a different lifecycle or scope. Maybe we should instead extend the evaluate method to take the Functions directly - or introduce some kind of NodeContext. Afaik we'll have other functions later that require access to the Schemas\n@kovrus @seut what your take here?", "author": "mfussenegger", "createdAt": "2020-08-06T13:08:21Z", "path": "server/src/main/java/io/crate/metadata/TransactionContext.java", "diffHunk": "@@ -29,20 +29,28 @@\n public interface TransactionContext {\n \n     static TransactionContext of(SessionSettings sessionSettings) {\n-        return new StaticTransactionContext(sessionSettings);\n+        return of(sessionSettings, null);\n+    }\n+\n+    static TransactionContext of(SessionSettings sessionSettings, Functions functions) {\n+        return new StaticTransactionContext(sessionSettings, functions);\n     }\n \n     Instant currentInstant();\n \n     SessionSettings sessionSettings();\n \n+    Functions functions();", "originalCommit": "dc688cac79890aa42e2e3364bf47c1e384a207d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQxMDczNQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r466410735", "bodyText": "I am not sure about extending the Scalar#evaluate method with the Functions argument, that would result in something like: Register a function -> AbstractFunctionModule -> inject into Functions -> function evaluate(..., Functions) which seems kind of cyclic and also, as you mention, won't be helpful when implementing the functions that need access to Schemas. I'd probably prefer some NodeContext that would have Functions injected and later Schemas.", "author": "kovrus", "createdAt": "2020-08-06T13:27:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM5ODU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAzODE0OQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r472038149", "bodyText": "I would need some feedback to continue.\n\nNodeContext contains a reference to Functions and is passed to Scalar.(evaluate, evaluateIfLiterals) and FunctionImplementation.normalizeSymbol (because of Scalar.evaluateIfLiterals' signature).\nFrom there, I notise Analyzer's constructor creates all analyzers, and these could take NodeContext as a parameter, to have access to Functions. I could add Schemas to NodeContext, now or at a later PR.", "author": "marregui", "createdAt": "2020-08-18T09:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM5ODU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA0NTkyNA==", "url": "https://github.com/crate/crate/pull/10286#discussion_r472045924", "bodyText": "left some comments. I think it would be good to also get the input from @seut because the interface change touches a lot of components", "author": "mfussenegger", "createdAt": "2020-08-18T09:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM5ODU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIyODU1Mw==", "url": "https://github.com/crate/crate/pull/10286#discussion_r472228553", "bodyText": "As I understand this proposal, NodeContext will superseed the usage of Functions as it will hold a reference to it. So I think, NodeContext should be used in a same ways than Functions.\nIn detail:\n\nNodeContext should be a singleton\nmost (if not any) usages of Functions should be replaced by NodeContext.getFunctions()\nI'd prefer to wrapSchemas into NodeContext later on when required to lower the scope of this PR\n\nOther than that, this looks good to me.", "author": "seut", "createdAt": "2020-08-18T14:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM5ODU3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3d228aa4123a83aeafe9f3d2b47e85e570cb9880", "chunk": "diff --git a/server/src/main/java/io/crate/metadata/TransactionContext.java b/server/src/main/java/io/crate/metadata/TransactionContext.java\nindex 8c4bc64296..1e6a3b742d 100644\n--- a/server/src/main/java/io/crate/metadata/TransactionContext.java\n+++ b/server/src/main/java/io/crate/metadata/TransactionContext.java\n\n@@ -29,28 +29,20 @@ import java.time.Instant;\n public interface TransactionContext {\n \n     static TransactionContext of(SessionSettings sessionSettings) {\n-        return of(sessionSettings, null);\n-    }\n-\n-    static TransactionContext of(SessionSettings sessionSettings, Functions functions) {\n-        return new StaticTransactionContext(sessionSettings, functions);\n+        return new StaticTransactionContext(sessionSettings);\n     }\n \n     Instant currentInstant();\n \n     SessionSettings sessionSettings();\n \n-    Functions functions();\n-\n     class StaticTransactionContext implements TransactionContext {\n \n         private final SessionSettings sessionSettings;\n         private Instant currentInstant;\n-        private Functions functions;\n \n-        StaticTransactionContext(SessionSettings sessionSettings, Functions functions) {\n+        StaticTransactionContext(SessionSettings sessionSettings) {\n             this.sessionSettings = sessionSettings;\n-            this.functions = functions;\n         }\n \n         @Override\n"}}, {"oid": "04adcad744952dfcf0d5e74e9d5aecdeb4bf0aa9", "url": "https://github.com/crate/crate/commit/04adcad744952dfcf0d5e74e9d5aecdeb4bf0aa9", "message": "Remove use of BytesRef and improve the code", "committedDate": "2020-08-06T17:54:27Z", "type": "forcePushed"}, {"oid": "ec03b81092717adf088a81c3b7b72658938c4087", "url": "https://github.com/crate/crate/commit/ec03b81092717adf088a81c3b7b72658938c4087", "message": "Remove use of BytesRef and improve the code", "committedDate": "2020-08-06T18:47:07Z", "type": "forcePushed"}, {"oid": "3d228aa4123a83aeafe9f3d2b47e85e570cb9880", "url": "https://github.com/crate/crate/commit/3d228aa4123a83aeafe9f3d2b47e85e570cb9880", "message": "WIP: Following backwards from adding NodeContext to Scalar evaluate,evaluateIfLiterals, and FunctionImplementation normalizeSymbol", "committedDate": "2020-08-17T20:28:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA0MTMyMQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r472041321", "bodyText": "I think the NodeContext could be created eagerly in the constructor - it should be valid over the life-time of a node.\nWe could even consider making it a (injected?) singleton.\nThis likely affects a lot of the other choices in the diff as well.", "author": "mfussenegger", "createdAt": "2020-08-18T09:23:53Z", "path": "server/src/main/java/io/crate/action/sql/Session.java", "diffHunk": "@@ -170,6 +171,7 @@ public void quickExec(String statement, ResultReceiver<?> resultReceiver, Row pa\n      */\n     public void quickExec(String statement, Function<String, Statement> parse, ResultReceiver<?> resultReceiver, Row params) {\n         CoordinatorTxnCtx txnCtx = new CoordinatorTxnCtx(sessionContext);\n+        NodeContext nodeCtx = new NodeContext(planner.functions());", "originalCommit": "3d228aa4123a83aeafe9f3d2b47e85e570cb9880", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NzUwNQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r472077505", "bodyText": "In the MetadataModule class we bind functions/schemas as eager singletons, can I make NodeContext encapsulate both?", "author": "marregui", "createdAt": "2020-08-18T10:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA0MTMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "80d56b3d2eac592670fc098d85401a379f395735", "chunk": "diff --git a/server/src/main/java/io/crate/action/sql/Session.java b/server/src/main/java/io/crate/action/sql/Session.java\nindex 3a52cfa1f7..4b174c6806 100644\n--- a/server/src/main/java/io/crate/action/sql/Session.java\n+++ b/server/src/main/java/io/crate/action/sql/Session.java\n\n@@ -171,7 +174,6 @@ public class Session implements AutoCloseable {\n      */\n     public void quickExec(String statement, Function<String, Statement> parse, ResultReceiver<?> resultReceiver, Row params) {\n         CoordinatorTxnCtx txnCtx = new CoordinatorTxnCtx(sessionContext);\n-        NodeContext nodeCtx = new NodeContext(planner.functions());\n         Statement parsedStmt = parse.apply(statement);\n         AnalyzedStatement analyzedStatement = analyzer.analyze(parsedStmt, sessionContext, ParamTypeHints.EMPTY);\n         RoutingProvider routingProvider = new RoutingProvider(Randomness.get().nextInt(), planner.getAwarenessAttributes());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA0MzkxNQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r472043915", "bodyText": "Would be cool if we could avoid this. Using a class as both (not encapsulated) data carrier and as a component that provides some other fucntionality is a sign that it breaks separation of concerns.\nI get that this may be convenient and \"easier\" - as less changes necessary and less to type, but it may make changes more difficult down the road.", "author": "mfussenegger", "createdAt": "2020-08-18T09:28:15Z", "path": "server/src/main/java/io/crate/analyze/Analyzer.java", "diffHunk": "@@ -188,6 +191,10 @@ public Analyzer(Schemas schemas,\n         this.resetStatementAnalyzer = new ResetStatementAnalyzer(functions);\n     }\n \n+    public NodeContext nodeContext() {", "originalCommit": "3d228aa4123a83aeafe9f3d2b47e85e570cb9880", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80d56b3d2eac592670fc098d85401a379f395735", "chunk": "diff --git a/server/src/main/java/io/crate/analyze/Analyzer.java b/server/src/main/java/io/crate/analyze/Analyzer.java\nindex eab73587f8..1b2c987982 100644\n--- a/server/src/main/java/io/crate/analyze/Analyzer.java\n+++ b/server/src/main/java/io/crate/analyze/Analyzer.java\n\n@@ -152,47 +151,43 @@ public class Analyzer {\n                     UserManager userManager,\n                     SessionSettingRegistry sessionSettingRegistry\n     ) {\n-        this.nodeCtx = new NodeContext(functions);\n+        this.nodeCtx = nodeCtx;\n         this.relationAnalyzer = relationAnalyzer;\n         this.dropTableAnalyzer = new DropTableAnalyzer(schemas);\n         this.dropCheckConstraintAnalyzer = new DropCheckConstraintAnalyzer(schemas);\n         this.userManager = userManager;\n-        this.createTableStatementAnalyzer = new CreateTableStatementAnalyzer(functions);\n-        this.alterTableAnalyzer = new AlterTableAnalyzer(schemas, functions);\n-        this.alterTableAddColumnAnalyzer = new AlterTableAddColumnAnalyzer(schemas, functions);\n-        this.swapTableAnalyzer = new SwapTableAnalyzer(functions, schemas);\n+        this.createTableStatementAnalyzer = new CreateTableStatementAnalyzer(nodeCtx);\n+        this.alterTableAnalyzer = new AlterTableAnalyzer(schemas, nodeCtx);\n+        this.alterTableAddColumnAnalyzer = new AlterTableAddColumnAnalyzer(schemas, nodeCtx);\n+        this.swapTableAnalyzer = new SwapTableAnalyzer(nodeCtx, schemas);\n         this.viewAnalyzer = new ViewAnalyzer(relationAnalyzer, schemas);\n         this.explainStatementAnalyzer = new ExplainStatementAnalyzer(this);\n         this.showStatementAnalyzer = new ShowStatementAnalyzer(this, schemas, sessionSettingRegistry);\n-        this.updateAnalyzer = new UpdateAnalyzer(functions, relationAnalyzer);\n-        this.deleteAnalyzer = new DeleteAnalyzer(functions, relationAnalyzer);\n-        this.insertAnalyzer = new InsertAnalyzer(functions, schemas, relationAnalyzer);\n-        this.optimizeTableAnalyzer = new OptimizeTableAnalyzer(schemas, functions);\n-        this.createRepositoryAnalyzer = new CreateRepositoryAnalyzer(repositoryService, functions);\n+        this.updateAnalyzer = new UpdateAnalyzer(nodeCtx, relationAnalyzer);\n+        this.deleteAnalyzer = new DeleteAnalyzer(nodeCtx, relationAnalyzer);\n+        this.insertAnalyzer = new InsertAnalyzer(nodeCtx, schemas, relationAnalyzer);\n+        this.optimizeTableAnalyzer = new OptimizeTableAnalyzer(schemas, nodeCtx);\n+        this.createRepositoryAnalyzer = new CreateRepositoryAnalyzer(repositoryService, nodeCtx);\n         this.dropRepositoryAnalyzer = new DropRepositoryAnalyzer(repositoryService);\n-        this.createSnapshotAnalyzer = new CreateSnapshotAnalyzer(repositoryService, functions);\n+        this.createSnapshotAnalyzer = new CreateSnapshotAnalyzer(repositoryService, nodeCtx);\n         this.dropSnapshotAnalyzer = new DropSnapshotAnalyzer(repositoryService);\n-        this.userAnalyzer = new UserAnalyzer(functions);\n-        this.createBlobTableAnalyzer = new CreateBlobTableAnalyzer(schemas, functions);\n-        this.createFunctionAnalyzer = new CreateFunctionAnalyzer(functions);\n+        this.userAnalyzer = new UserAnalyzer(nodeCtx);\n+        this.createBlobTableAnalyzer = new CreateBlobTableAnalyzer(schemas, nodeCtx);\n+        this.createFunctionAnalyzer = new CreateFunctionAnalyzer(nodeCtx);\n         this.dropFunctionAnalyzer = new DropFunctionAnalyzer();\n-        this.refreshTableAnalyzer = new RefreshTableAnalyzer(functions, schemas);\n-        this.restoreSnapshotAnalyzer = new RestoreSnapshotAnalyzer(repositoryService, functions);\n+        this.refreshTableAnalyzer = new RefreshTableAnalyzer(nodeCtx, schemas);\n+        this.restoreSnapshotAnalyzer = new RestoreSnapshotAnalyzer(repositoryService, nodeCtx);\n         FulltextAnalyzerResolver fulltextAnalyzerResolver =\n             new FulltextAnalyzerResolver(clusterService, analysisRegistry);\n-        this.createAnalyzerStatementAnalyzer = new CreateAnalyzerStatementAnalyzer(fulltextAnalyzerResolver, functions);\n+        this.createAnalyzerStatementAnalyzer = new CreateAnalyzerStatementAnalyzer(fulltextAnalyzerResolver, nodeCtx);\n         this.dropAnalyzerStatementAnalyzer = new DropAnalyzerStatementAnalyzer(fulltextAnalyzerResolver);\n-        this.decommissionNodeAnalyzer = new DecommissionNodeAnalyzer(functions);\n-        this.killAnalyzer = new KillAnalyzer(functions);\n-        this.alterTableRerouteAnalyzer = new AlterTableRerouteAnalyzer(functions, schemas);\n+        this.decommissionNodeAnalyzer = new DecommissionNodeAnalyzer(nodeCtx);\n+        this.killAnalyzer = new KillAnalyzer(nodeCtx);\n+        this.alterTableRerouteAnalyzer = new AlterTableRerouteAnalyzer(nodeCtx, schemas);\n         this.privilegesAnalyzer = new PrivilegesAnalyzer(userManager.isEnabled(), schemas);\n-        this.copyAnalyzer = new CopyAnalyzer(schemas, functions);\n-        this.setStatementAnalyzer = new SetStatementAnalyzer(functions);\n-        this.resetStatementAnalyzer = new ResetStatementAnalyzer(functions);\n-    }\n-\n-    public NodeContext nodeContext() {\n-        return nodeCtx;\n+        this.copyAnalyzer = new CopyAnalyzer(schemas, nodeCtx);\n+        this.setStatementAnalyzer = new SetStatementAnalyzer(nodeCtx);\n+        this.resetStatementAnalyzer = new ResetStatementAnalyzer(nodeCtx);\n     }\n \n     public AnalyzedStatement analyze(Statement statement,\n"}}, {"oid": "80d56b3d2eac592670fc098d85401a379f395735", "url": "https://github.com/crate/crate/commit/80d56b3d2eac592670fc098d85401a379f395735", "message": "Make NodeContext an injected singleton and replace uses of Function with it", "committedDate": "2020-08-19T10:32:03Z", "type": "forcePushed"}, {"oid": "88b6d40cc196e9ae4f317df8efb569b83cbb3234", "url": "https://github.com/crate/crate/commit/88b6d40cc196e9ae4f317df8efb569b83cbb3234", "message": "Nomi's suggestion", "committedDate": "2020-08-19T12:04:31Z", "type": "forcePushed"}, {"oid": "63642e17e6d59b049f433ac2fb7fa0fdf3f6d4fa", "url": "https://github.com/crate/crate/commit/63642e17e6d59b049f433ac2fb7fa0fdf3f6d4fa", "message": "Nomi's suggestion", "committedDate": "2020-08-19T14:47:27Z", "type": "forcePushed"}, {"oid": "a1f85c308870e4c21219e80ca981d578b721a1fe", "url": "https://github.com/crate/crate/commit/a1f85c308870e4c21219e80ca981d578b721a1fe", "message": "Nomi's suggestion", "committedDate": "2020-08-19T15:07:20Z", "type": "forcePushed"}, {"oid": "36ee8c88a949accbbd4cd352376474268c7716e3", "url": "https://github.com/crate/crate/commit/36ee8c88a949accbbd4cd352376474268c7716e3", "message": "Nomi's suggestion", "committedDate": "2020-08-19T15:54:23Z", "type": "forcePushed"}, {"oid": "3abebcb8e13fa1b0ba3acc2e770927b08cd3408a", "url": "https://github.com/crate/crate/commit/3abebcb8e13fa1b0ba3acc2e770927b08cd3408a", "message": "Nomi's suggestion", "committedDate": "2020-08-19T17:50:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyMTg1MQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r474521851", "bodyText": "Couldn't the builder construct the NodeContext itself, similar how it created the Functions itself before?\nWould simplify all the call-sites which use it.", "author": "mfussenegger", "createdAt": "2020-08-21T08:30:44Z", "path": "server/src/test/java/io/crate/testing/SQLExecutor.java", "diffHunk": "@@ -228,6 +227,7 @@ public PlannerContext getPlannerContext(ClusterState clusterState, Random random\n         private SessionSettingRegistry sessionSettingRegistry = new SessionSettingRegistry(Set.of(loadedRules));\n \n         private Builder(ClusterService clusterService,\n+                        NodeContext nodeCtx,", "originalCommit": "3abebcb8e13fa1b0ba3acc2e770927b08cd3408a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYwODA4MA==", "url": "https://github.com/crate/crate/pull/10286#discussion_r474608080", "bodyText": "I found that both SqlExpressions and SqlExecutor do require access to  NodeContext. Some tests make use of SqlExpressions, other use SqlExecutor, others both, as for instance ExpressionAnalyzerTest. In the later cases, I was faced with a chicken and egg problem https://github.com/crate/crate/blob/master/server/src/test/java/io/crate/analyze/expressions/ExpressionAnalyzerTest.java#L98 . Given than NodeContext is a unique instance, I went for injecting it for tests as well.", "author": "marregui", "createdAt": "2020-08-21T10:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyMTg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYyNzYxMA==", "url": "https://github.com/crate/crate/pull/10286#discussion_r474627610", "bodyText": "Yes they require it, but it can construct it by itself - given that it's a test utility the requirement to have a single instance doesn't apply. Think of SQLExecutor as a kind of \"mini\" Node - it already sets up most of the component it requires for the analyzer and planner by itself.", "author": "mfussenegger", "createdAt": "2020-08-21T11:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyMTg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY0NzUwMQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r474647501", "bodyText": "Ok, I will! thank you", "author": "marregui", "createdAt": "2020-08-21T11:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyMTg1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ae364aba6c5021f0ee5f2b8d75c0f5f10931f49c", "chunk": "diff --git a/server/src/test/java/io/crate/testing/SQLExecutor.java b/server/src/test/java/io/crate/testing/SQLExecutor.java\nindex 9cbf052655..4aac294aa9 100644\n--- a/server/src/test/java/io/crate/testing/SQLExecutor.java\n+++ b/server/src/test/java/io/crate/testing/SQLExecutor.java\n\n@@ -227,17 +229,17 @@ public class SQLExecutor {\n         private SessionSettingRegistry sessionSettingRegistry = new SessionSettingRegistry(Set.of(loadedRules));\n \n         private Builder(ClusterService clusterService,\n-                        NodeContext nodeCtx,\n                         int numNodes,\n                         Random random,\n-                        List<AnalysisPlugin> analysisPlugins) {\n+                        List<AnalysisPlugin> analysisPlugins,\n+                        AbstractModule... additionalModules) {\n             if (numNodes < 1) {\n                 throw new IllegalArgumentException(\"Must have at least 1 node\");\n             }\n             this.random = random;\n             this.clusterService = clusterService;\n             addNodesToClusterState(numNodes);\n-            this.nodeCtx = nodeCtx;\n+            nodeCtx = createNodeContext(additionalModules);\n             UserDefinedFunctionService udfService = new UserDefinedFunctionService(clusterService, nodeCtx);\n             Map<String, SchemaInfo> schemaInfoByName = new HashMap<>();\n             CrateSettings crateSettings = new CrateSettings(clusterService, clusterService.getSettings());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyMjY1OA==", "url": "https://github.com/crate/crate/pull/10286#discussion_r474522658", "bodyText": "Same here", "author": "mfussenegger", "createdAt": "2020-08-21T08:31:41Z", "path": "server/src/test/java/io/crate/testing/SqlExpressions.java", "diffHunk": "@@ -64,54 +54,40 @@\n \n     private final ExpressionAnalyzer expressionAnalyzer;\n     private final ExpressionAnalysisContext expressionAnalysisCtx;\n-    private final Injector injector;\n     private final CoordinatorTxnCtx coordinatorTxnCtx;\n     private final EvaluatingNormalizer normalizer;\n-    private final Functions functions;\n+    public final NodeContext nodeCtx;\n \n-    public SqlExpressions(Map<RelationName, AnalyzedRelation> sources) {\n-        this(sources, null, User.CRATE_USER);\n+    public SqlExpressions(Map<RelationName, AnalyzedRelation> sources, NodeContext nodeCtx) {", "originalCommit": "3abebcb8e13fa1b0ba3acc2e770927b08cd3408a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae364aba6c5021f0ee5f2b8d75c0f5f10931f49c", "chunk": "diff --git a/server/src/test/java/io/crate/testing/SqlExpressions.java b/server/src/test/java/io/crate/testing/SqlExpressions.java\nindex d3e09aa3b4..07b56bd51a 100644\n--- a/server/src/test/java/io/crate/testing/SqlExpressions.java\n+++ b/server/src/test/java/io/crate/testing/SqlExpressions.java\n\n@@ -44,10 +44,13 @@ import io.crate.metadata.RowGranularity;\n import io.crate.metadata.Schemas;\n import io.crate.metadata.table.Operation;\n import io.crate.sql.parser.SqlParser;\n+import org.elasticsearch.common.inject.AbstractModule;\n \n import javax.annotation.Nullable;\n import java.util.Map;\n \n+import static io.crate.testing.TestingHelpers.createNodeContext;\n+\n import static org.mockito.Mockito.mock;\n \n public class SqlExpressions {\n"}}, {"oid": "ae364aba6c5021f0ee5f2b8d75c0f5f10931f49c", "url": "https://github.com/crate/crate/commit/ae364aba6c5021f0ee5f2b8d75c0f5f10931f49c", "message": "Make QueryTester, SqlExecutor and SqlExpressions produce their own NodeContext", "committedDate": "2020-08-21T13:39:53Z", "type": "forcePushed"}, {"oid": "28cb2daf36de0717f293f7930da9aa747685d55d", "url": "https://github.com/crate/crate/commit/28cb2daf36de0717f293f7930da9aa747685d55d", "message": "Make QueryTester, SqlExecutor and SqlExpressions produce their own NodeContext", "committedDate": "2020-08-21T13:55:48Z", "type": "forcePushed"}, {"oid": "50faf851f11e9876d9f8dd57be51872502b49dd2", "url": "https://github.com/crate/crate/commit/50faf851f11e9876d9f8dd57be51872502b49dd2", "message": "Make QueryTester, SqlExecutor and SqlExpressions produce their own NodeContext", "committedDate": "2020-08-22T18:57:04Z", "type": "forcePushed"}, {"oid": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "url": "https://github.com/crate/crate/commit/fb34f88cb7221130cbd44299e9e755bba7047fc4", "message": "Make QueryTester, SqlExecutor and SqlExpressions produce their own NodeContext", "committedDate": "2020-08-25T08:36:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI5NzExNA==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476297114", "bodyText": "The nodeCtx should be used here instead of passing null", "author": "mfussenegger", "createdAt": "2020-08-25T09:05:51Z", "path": "server/src/main/java/io/crate/execution/engine/collect/sources/TableFunctionCollectSource.java", "diffHunk": "@@ -87,7 +87,7 @@ public TableFunctionCollectSource(Functions functions) {\n             topLevelInputs.add(ctx.add(symbol));\n         }\n \n-        Iterable<Row> result = functionImplementation.evaluate(txnCtx, inputs.toArray(new Input[0]));\n+        Iterable<Row> result = functionImplementation.evaluate(txnCtx, null, inputs.toArray(new Input[0]));", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMDc3Mw==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476310773", "bodyText": "well spotted! thank you very much.", "author": "marregui", "createdAt": "2020-08-25T09:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI5NzExNA=="}], "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/main/java/io/crate/execution/engine/collect/sources/TableFunctionCollectSource.java b/server/src/main/java/io/crate/execution/engine/collect/sources/TableFunctionCollectSource.java\nindex a3e2941e22..573bd23f4f 100644\n--- a/server/src/main/java/io/crate/execution/engine/collect/sources/TableFunctionCollectSource.java\n+++ b/server/src/main/java/io/crate/execution/engine/collect/sources/TableFunctionCollectSource.java\n\n@@ -87,7 +89,7 @@ public class TableFunctionCollectSource implements CollectSource {\n             topLevelInputs.add(ctx.add(symbol));\n         }\n \n-        Iterable<Row> result = functionImplementation.evaluate(txnCtx, null, inputs.toArray(new Input[0]));\n+        Iterable<Row> result = functionImplementation.evaluate(txnCtx, nodeCtx, inputs.toArray(new Input[0]));\n         Iterable<Row> rows = Iterables.transform(\n             result,\n             new ValueAndInputRow<>(topLevelInputs, ctx.expressions()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI5Nzg3Ng==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476297876", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return Literal.of(evaluate(txnCtx, null, (Input) left, (Input) right));\n          \n          \n            \n                        return Literal.of(evaluate(txnCtx, nodeCtx, (Input) left, (Input) right));", "author": "mfussenegger", "createdAt": "2020-08-25T09:07:08Z", "path": "server/src/main/java/io/crate/expression/operator/AndOperator.java", "diffHunk": "@@ -70,15 +71,15 @@ public Signature boundSignature() {\n     }\n \n     @Override\n-    public Symbol normalizeSymbol(Function function, TransactionContext txnCtx) {\n+    public Symbol normalizeSymbol(Function function, TransactionContext txnCtx, NodeContext nodeCtx) {\n         assert function != null : \"function must not be null\";\n         assert function.arguments().size() == 2 : \"number of args must be 2\";\n \n         Symbol left = function.arguments().get(0);\n         Symbol right = function.arguments().get(1);\n \n         if (left instanceof Input && right instanceof Input) {\n-            return Literal.of(evaluate(txnCtx, (Input) left, (Input) right));\n+            return Literal.of(evaluate(txnCtx, null, (Input) left, (Input) right));", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/main/java/io/crate/expression/operator/AndOperator.java b/server/src/main/java/io/crate/expression/operator/AndOperator.java\nindex f4ed6c2723..57e2a0ca15 100644\n--- a/server/src/main/java/io/crate/expression/operator/AndOperator.java\n+++ b/server/src/main/java/io/crate/expression/operator/AndOperator.java\n\n@@ -79,7 +79,7 @@ public class AndOperator extends Operator<Boolean> {\n         Symbol right = function.arguments().get(1);\n \n         if (left instanceof Input && right instanceof Input) {\n-            return Literal.of(evaluate(txnCtx, null, (Input) left, (Input) right));\n+            return Literal.of(evaluate(txnCtx, nodeCtx, (Input) left, (Input) right));\n         }\n \n         /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMTA3NA==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476301074", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                @Nullable", "author": "mfussenegger", "createdAt": "2020-08-25T09:12:29Z", "path": "server/src/main/java/io/crate/metadata/Functions.java", "diffHunk": "@@ -87,6 +88,22 @@ public void deregisterUdfResolversForSchema(String schema) {\n             .removeIf(function -> schema.equals(function.schema()));\n     }\n ", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/main/java/io/crate/metadata/Functions.java b/server/src/main/java/io/crate/metadata/Functions.java\nindex cbeb137b92..76c6f92283 100644\n--- a/server/src/main/java/io/crate/metadata/Functions.java\n+++ b/server/src/main/java/io/crate/metadata/Functions.java\n\n@@ -88,7 +88,8 @@ public class Functions {\n             .removeIf(function -> schema.equals(function.schema()));\n     }\n \n-    private static Signature findSignatureByOid(Map<FunctionName, List<FunctionProvider>> functions, Integer oid) {\n+    @Nullable\n+    private static Signature findSignatureByOid(Map<FunctionName, List<FunctionProvider>> functions, int oid) {\n         for (Map.Entry<FunctionName, List<FunctionProvider>> func : functions.entrySet()) {\n             for (FunctionProvider sig : func.getValue()) {\n                 if (Objects.equals(oid, OidHash.functionOid(sig.getSignature()))) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMTE4OQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476301189", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static Signature findSignatureByOid(Map<FunctionName, List<FunctionProvider>> functions, Integer oid) {\n          \n          \n            \n                private static Signature findSignatureByOid(Map<FunctionName, List<FunctionProvider>> functions, int oid) {", "author": "mfussenegger", "createdAt": "2020-08-25T09:12:41Z", "path": "server/src/main/java/io/crate/metadata/Functions.java", "diffHunk": "@@ -87,6 +88,22 @@ public void deregisterUdfResolversForSchema(String schema) {\n             .removeIf(function -> schema.equals(function.schema()));\n     }\n \n+    private static Signature findSignatureByOid(Map<FunctionName, List<FunctionProvider>> functions, Integer oid) {", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/main/java/io/crate/metadata/Functions.java b/server/src/main/java/io/crate/metadata/Functions.java\nindex cbeb137b92..76c6f92283 100644\n--- a/server/src/main/java/io/crate/metadata/Functions.java\n+++ b/server/src/main/java/io/crate/metadata/Functions.java\n\n@@ -88,7 +88,8 @@ public class Functions {\n             .removeIf(function -> schema.equals(function.schema()));\n     }\n \n-    private static Signature findSignatureByOid(Map<FunctionName, List<FunctionProvider>> functions, Integer oid) {\n+    @Nullable\n+    private static Signature findSignatureByOid(Map<FunctionName, List<FunctionProvider>> functions, int oid) {\n         for (Map.Entry<FunctionName, List<FunctionProvider>> func : functions.entrySet()) {\n             for (FunctionProvider sig : func.getValue()) {\n                 if (Objects.equals(oid, OidHash.functionOid(sig.getSignature()))) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMTQ5OA==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476301498", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Signature findFunctionSignatureByOid(Integer oid) {\n          \n          \n            \n                @Nullable\n          \n          \n            \n                public Signature findFunctionByOid(int oid) {", "author": "mfussenegger", "createdAt": "2020-08-25T09:13:12Z", "path": "server/src/main/java/io/crate/metadata/Functions.java", "diffHunk": "@@ -87,6 +88,22 @@ public void deregisterUdfResolversForSchema(String schema) {\n             .removeIf(function -> schema.equals(function.schema()));\n     }\n \n+    private static Signature findSignatureByOid(Map<FunctionName, List<FunctionProvider>> functions, Integer oid) {\n+        for (Map.Entry<FunctionName, List<FunctionProvider>> func : functions.entrySet()) {\n+            for (FunctionProvider sig : func.getValue()) {\n+                if (Objects.equals(oid, OidHash.functionOid(sig.getSignature()))) {\n+                    return sig.getSignature();\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public Signature findFunctionSignatureByOid(Integer oid) {", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/main/java/io/crate/metadata/Functions.java b/server/src/main/java/io/crate/metadata/Functions.java\nindex cbeb137b92..76c6f92283 100644\n--- a/server/src/main/java/io/crate/metadata/Functions.java\n+++ b/server/src/main/java/io/crate/metadata/Functions.java\n\n@@ -88,7 +88,8 @@ public class Functions {\n             .removeIf(function -> schema.equals(function.schema()));\n     }\n \n-    private static Signature findSignatureByOid(Map<FunctionName, List<FunctionProvider>> functions, Integer oid) {\n+    @Nullable\n+    private static Signature findSignatureByOid(Map<FunctionName, List<FunctionProvider>> functions, int oid) {\n         for (Map.Entry<FunctionName, List<FunctionProvider>> func : functions.entrySet()) {\n             for (FunctionProvider sig : func.getValue()) {\n                 if (Objects.equals(oid, OidHash.functionOid(sig.getSignature()))) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMzQ1Mw==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476303453", "bodyText": "Due to the varargs this results in an array allocation. I think in most call-sites we could just go for string concat using  + and then do the .getBytes call to avoid some overhead.", "author": "mfussenegger", "createdAt": "2020-08-25T09:16:37Z", "path": "server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java", "diffHunk": "@@ -41,34 +48,55 @@\n         PROC\n     }\n \n+    private static int oid(String... keys) {", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java b/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java\nindex ea450e7f7a..3899d97e9e 100644\n--- a/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java\n+++ b/server/src/main/java/io/crate/metadata/pgcatalog/OidHash.java\n\n@@ -48,42 +46,40 @@ public final class OidHash {\n         PROC\n     }\n \n-    private static int oid(String... keys) {\n-        byte [] b = Lists2\n-            .joinOn(\"\", Arrays.asList(keys), Function.identity())\n-            .getBytes(StandardCharsets.UTF_8);\n+    private static int oid(String key) {\n+        byte [] b = key.getBytes(StandardCharsets.UTF_8);\n         return murmurhash3_x86_32(b, 0, b.length, 0);\n     }\n \n     public static int relationOid(RelationInfo relationInfo) {\n         Type t = relationInfo.relationType() == RelationInfo.RelationType.VIEW ? Type.VIEW : Type.TABLE;\n-        return oid(t.toString(), relationInfo.ident().fqn());\n+        return oid(t.toString() + relationInfo.ident().fqn());\n     }\n \n     public static int schemaOid(String name) {\n-        return oid(Type.SCHEMA.toString(), name);\n+        return oid(Type.SCHEMA.toString() + name);\n     }\n \n     public static int primaryKeyOid(RelationInfo relationInfo) {\n         var primaryKey = Lists2.joinOn(\" \", relationInfo.primaryKey(), ColumnIdent::name);\n-        return oid(Type.PRIMARY_KEY.toString(), relationInfo.ident().fqn(), primaryKey);\n+        return oid(Type.PRIMARY_KEY.toString() + relationInfo.ident().fqn() + primaryKey);\n     }\n \n     public static int constraintOid(String relationName, String constraintName, String constraintType) {\n-        return oid(Type.CONSTRAINT.toString(), relationName, constraintName, constraintType);\n+        return oid(Type.CONSTRAINT.toString() + relationName + constraintName + constraintType);\n     }\n \n     public static int regprocOid(FunctionName name) {\n-        return oid(Type.PROC.toString(), name.schema(), name.name());\n+        return oid(Type.PROC.toString() + name.schema() + name.name());\n     }\n \n     public static int regprocOid(String name) {\n-        return oid(Type.PROC.toString(), null, name);\n+        return oid(Type.PROC.toString() + \"null\" + name);\n     }\n \n     public static int functionOid(Signature sig) {\n         FunctionName name = sig.getName();\n-        return oid(Type.PROC.toString(), name.schema(), name.name(), argTypesToStr(sig.getArgumentTypes()));\n+        return oid(Type.PROC.toString() + name.schema() + name.name() + argTypesToStr(sig.getArgumentTypes()));\n     }\n \n     @VisibleForTesting\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwODUwMg==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476308502", "bodyText": "Why all the formatting changes in this file?\nCould you revert them to keep the scope of the PR narrower?", "author": "mfussenegger", "createdAt": "2020-08-25T09:24:40Z", "path": "server/src/test/java/io/crate/analyze/SelectStatementAnalyzerTest.java", "diffHunk": "@@ -789,7 +791,7 @@ public void testInnerJoinSyntaxDoesNotExtendsWhereClause() throws Exception {\n             \"select * from users inner join users_multi_pk on users.id = users_multi_pk.id\");\n         assertThat(mss.where(), isLiteral(true));\n         assertThat(mss.joinPairs().get(0).condition(),\n-            isSQL(\"(doc.users.id = doc.users_multi_pk.id)\"));\n+                   isSQL(\"(doc.users.id = doc.users_multi_pk.id)\"));", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/test/java/io/crate/analyze/SelectStatementAnalyzerTest.java b/server/src/test/java/io/crate/analyze/SelectStatementAnalyzerTest.java\nindex b2a56f50d6..fbd283eac4 100644\n--- a/server/src/test/java/io/crate/analyze/SelectStatementAnalyzerTest.java\n+++ b/server/src/test/java/io/crate/analyze/SelectStatementAnalyzerTest.java\n\n@@ -791,7 +788,7 @@ public class SelectStatementAnalyzerTest extends CrateDummyClusterServiceUnitTes\n             \"select * from users inner join users_multi_pk on users.id = users_multi_pk.id\");\n         assertThat(mss.where(), isLiteral(true));\n         assertThat(mss.joinPairs().get(0).condition(),\n-                   isSQL(\"(doc.users.id = doc.users_multi_pk.id)\"));\n+            isSQL(\"(doc.users.id = doc.users_multi_pk.id)\"));\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwOTQ4Mw==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476309483", "bodyText": "Please revert indentation change", "author": "mfussenegger", "createdAt": "2020-08-25T09:26:15Z", "path": "server/src/test/java/io/crate/execution/dml/upsert/TransportShardUpsertActionTest.java", "diffHunk": "@@ -156,16 +155,16 @@ public void prepare() throws Exception {\n         when(schemas.getTableInfo(any(RelationName.class), eq(Operation.INSERT))).thenReturn(tableInfo);\n \n         transportShardUpsertAction = new TestingTransportShardUpsertAction(\n-            mock(ThreadPool.class),\n-            clusterService,\n-            MockTransportService.createNewService(Settings.EMPTY, Version.ES_V_6_5_1, THREAD_POOL, clusterService.getClusterSettings()),\n-            mock(SchemaUpdateClient.class),\n-            mock(TasksService.class),\n-            indicesService,\n-            mock(ShardStateAction.class),\n-            functions,\n-            schemas,\n-            mock(IndexNameExpressionResolver.class)\n+                mock(ThreadPool.class),", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/test/java/io/crate/execution/dml/upsert/TransportShardUpsertActionTest.java b/server/src/test/java/io/crate/execution/dml/upsert/TransportShardUpsertActionTest.java\nindex b88ad01328..d4b0df26cc 100644\n--- a/server/src/test/java/io/crate/execution/dml/upsert/TransportShardUpsertActionTest.java\n+++ b/server/src/test/java/io/crate/execution/dml/upsert/TransportShardUpsertActionTest.java\n\n@@ -155,16 +155,16 @@ public class TransportShardUpsertActionTest extends CrateDummyClusterServiceUnit\n         when(schemas.getTableInfo(any(RelationName.class), eq(Operation.INSERT))).thenReturn(tableInfo);\n \n         transportShardUpsertAction = new TestingTransportShardUpsertAction(\n-                mock(ThreadPool.class),\n-                clusterService,\n-                MockTransportService.createNewService(Settings.EMPTY, Version.ES_V_6_5_1, THREAD_POOL, clusterService.getClusterSettings()),\n-                mock(SchemaUpdateClient.class),\n-                mock(TasksService.class),\n-                indicesService,\n-                mock(ShardStateAction.class),\n-                createNodeContext(),\n-                schemas,\n-                mock(IndexNameExpressionResolver.class)\n+            mock(ThreadPool.class),\n+            clusterService,\n+            MockTransportService.createNewService(Settings.EMPTY, Version.ES_V_6_5_1, THREAD_POOL, clusterService.getClusterSettings()),\n+            mock(SchemaUpdateClient.class),\n+            mock(TasksService.class),\n+            indicesService,\n+            mock(ShardStateAction.class),\n+            createNodeContext(),\n+            schemas,\n+            mock(IndexNameExpressionResolver.class)\n         );\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMDI2Mg==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476310262", "bodyText": "Could use a local variable, the class attribute is not used as far as I can tell", "author": "mfussenegger", "createdAt": "2020-08-25T09:27:32Z", "path": "server/src/test/java/io/crate/execution/engine/collect/GroupByOptimizedIteratorTest.java", "diffHunk": "@@ -73,9 +74,11 @@\n     private String columnName;\n     private InputCollectExpression inExpr;\n     private List<AggregationContext> aggregationContexts;\n+    private NodeContext nodeCtx;\n \n     @Before\n     public void prepare() throws Exception {\n+        nodeCtx = createNodeContext();", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/test/java/io/crate/execution/engine/collect/GroupByOptimizedIteratorTest.java b/server/src/test/java/io/crate/execution/engine/collect/GroupByOptimizedIteratorTest.java\nindex dc611d7c6a..d29e144c33 100644\n--- a/server/src/test/java/io/crate/execution/engine/collect/GroupByOptimizedIteratorTest.java\n+++ b/server/src/test/java/io/crate/execution/engine/collect/GroupByOptimizedIteratorTest.java\n\n@@ -74,11 +74,10 @@ public class GroupByOptimizedIteratorTest extends CrateDummyClusterServiceUnitTe\n     private String columnName;\n     private InputCollectExpression inExpr;\n     private List<AggregationContext> aggregationContexts;\n-    private NodeContext nodeCtx;\n \n     @Before\n     public void prepare() throws Exception {\n-        nodeCtx = createNodeContext();\n+        NodeContext nodeCtx = createNodeContext();\n         IndexWriter iw = new IndexWriter(new ByteBuffersDirectory(), new IndexWriterConfig(new StandardAnalyzer()));\n         columnName = \"x\";\n         expectedResult = new ArrayList<>(20);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMDc0NA==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476310744", "bodyText": "Please revert indentation change", "author": "mfussenegger", "createdAt": "2020-08-25T09:28:22Z", "path": "server/src/test/java/io/crate/execution/engine/fetch/FetchRowsTest.java", "diffHunk": "@@ -67,10 +68,10 @@ public void test_fetch_rows_can_map_inputs_and_buckets_to_outputs() throws Excep\n             t2.ident(), fetchSource2\n         );\n         var fetchRows = FetchRows.create(\n-            CoordinatorTxnCtx.systemTransactionContext(),\n-            e.functions(),\n-            fetchSources,\n-            List.of(\n+                CoordinatorTxnCtx.systemTransactionContext(),\n+                createNodeContext(),", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/test/java/io/crate/execution/engine/fetch/FetchRowsTest.java b/server/src/test/java/io/crate/execution/engine/fetch/FetchRowsTest.java\nindex 72b5a23ade..3ff90e3a79 100644\n--- a/server/src/test/java/io/crate/execution/engine/fetch/FetchRowsTest.java\n+++ b/server/src/test/java/io/crate/execution/engine/fetch/FetchRowsTest.java\n\n@@ -68,10 +68,10 @@ public class FetchRowsTest extends CrateDummyClusterServiceUnitTest {\n             t2.ident(), fetchSource2\n         );\n         var fetchRows = FetchRows.create(\n-                CoordinatorTxnCtx.systemTransactionContext(),\n-                createNodeContext(),\n-                fetchSources,\n-                List.of(\n+            CoordinatorTxnCtx.systemTransactionContext(),\n+            createNodeContext(),\n+            fetchSources,\n+            List.of(\n                 new FetchReference(new InputColumn(0, DataTypes.LONG), x),\n                 new FetchReference(new InputColumn(1, DataTypes.LONG), y),\n                 new InputColumn(2, DataTypes.INTEGER)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMDkyMA==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476310920", "bodyText": "please revert indentation change", "author": "mfussenegger", "createdAt": "2020-08-25T09:28:38Z", "path": "server/src/test/java/io/crate/execution/engine/indexing/IndexWriterProjectorUnitTest.java", "diffHunk": "@@ -96,32 +96,32 @@ public void testNullPKValue() throws Throwable {\n \n         TransportCreatePartitionsAction transportCreatePartitionsAction = mock(TransportCreatePartitionsAction.class);\n         IndexWriterProjector indexWriter = new IndexWriterProjector(\n-            clusterService,\n-            new NodeJobsCounter(),\n-            scheduler,\n-            executor,\n-            CoordinatorTxnCtx.systemTransactionContext(),\n-            TestingHelpers.getFunctions(),\n-            Settings.EMPTY,\n-            5,\n-            1,\n-            transportCreatePartitionsAction,\n-            (request, listener) -> {},\n-            IndexNameResolver.forTable(BULK_IMPORT_IDENT),\n-            RAW_SOURCE_REFERENCE,\n-            Collections.singletonList(ID_IDENT),\n-            Collections.<Symbol>singletonList(new InputColumn(1)),\n-            null,\n-            null,\n-            sourceInput,\n-            collectExpressions,\n-            20,\n-            null,\n-            null,\n-            false,\n-            false,\n-            UUID.randomUUID(),\n-            UpsertResultContext.forRowCount());\n+                clusterService,\n+                new NodeJobsCounter(),\n+                scheduler,\n+                executor,", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/test/java/io/crate/execution/engine/indexing/IndexWriterProjectorUnitTest.java b/server/src/test/java/io/crate/execution/engine/indexing/IndexWriterProjectorUnitTest.java\nindex 3bc3e32506..25af65a528 100644\n--- a/server/src/test/java/io/crate/execution/engine/indexing/IndexWriterProjectorUnitTest.java\n+++ b/server/src/test/java/io/crate/execution/engine/indexing/IndexWriterProjectorUnitTest.java\n\n@@ -96,32 +96,32 @@ public class IndexWriterProjectorUnitTest extends CrateDummyClusterServiceUnitTe\n \n         TransportCreatePartitionsAction transportCreatePartitionsAction = mock(TransportCreatePartitionsAction.class);\n         IndexWriterProjector indexWriter = new IndexWriterProjector(\n-                clusterService,\n-                new NodeJobsCounter(),\n-                scheduler,\n-                executor,\n-                CoordinatorTxnCtx.systemTransactionContext(),\n-                createNodeContext(),\n-                Settings.EMPTY,\n-                5,\n-                1,\n-                transportCreatePartitionsAction,\n-                (request, listener) -> {},\n-                IndexNameResolver.forTable(BULK_IMPORT_IDENT),\n-                RAW_SOURCE_REFERENCE,\n-                Collections.singletonList(ID_IDENT),\n-                Collections.<Symbol>singletonList(new InputColumn(1)),\n-                null,\n-                null,\n-                sourceInput,\n-                collectExpressions,\n-                20,\n-                null,\n-                null,\n-                false,\n-                false,\n-                UUID.randomUUID(),\n-                UpsertResultContext.forRowCount());\n+            clusterService,\n+            new NodeJobsCounter(),\n+            scheduler,\n+            executor,\n+            CoordinatorTxnCtx.systemTransactionContext(),\n+            createNodeContext(),\n+            Settings.EMPTY,\n+            5,\n+            1,\n+            transportCreatePartitionsAction,\n+            (request, listener) -> {},\n+            IndexNameResolver.forTable(BULK_IMPORT_IDENT),\n+            RAW_SOURCE_REFERENCE,\n+            Collections.singletonList(ID_IDENT),\n+            Collections.<Symbol>singletonList(new InputColumn(1)),\n+            null,\n+            null,\n+            sourceInput,\n+            collectExpressions,\n+            20,\n+            null,\n+            null,\n+            false,\n+            false,\n+            UUID.randomUUID(),\n+            UpsertResultContext.forRowCount());\n \n         RowN rowN = new RowN(new Object[]{new BytesRef(\"{\\\"y\\\": \\\"x\\\"}\"), null});\n         BatchIterator<Row> batchIterator = InMemoryBatchIterator.of(Collections.singletonList(rowN), SENTINEL, true);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMTQ1Mw==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476311453", "bodyText": "please use the nodeCtx instead of passing in null", "author": "mfussenegger", "createdAt": "2020-08-25T09:29:31Z", "path": "server/src/test/java/io/crate/expression/scalar/AbstractScalarFunctionsTest.java", "diffHunk": "@@ -200,15 +196,15 @@ public void assertNormalize(String functionExpression, Matcher<? super Symbol> e\n             Input<?> input = ctx.add(arg);\n             arguments[i] = new AssertMax1ValueCallInput(input);\n         }\n-        Object actualValue = scalar.compile(function.arguments()).evaluate(txnCtx, (Input[]) arguments);\n+        Object actualValue = scalar.compile(function.arguments()).evaluate(txnCtx, null, (Input[]) arguments);", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/test/java/io/crate/expression/scalar/AbstractScalarFunctionsTest.java b/server/src/test/java/io/crate/expression/scalar/AbstractScalarFunctionsTest.java\nindex 48f79734ff..b28c907544 100644\n--- a/server/src/test/java/io/crate/expression/scalar/AbstractScalarFunctionsTest.java\n+++ b/server/src/test/java/io/crate/expression/scalar/AbstractScalarFunctionsTest.java\n\n@@ -196,7 +196,7 @@ public abstract class AbstractScalarFunctionsTest extends CrateDummyClusterServi\n             Input<?> input = ctx.add(arg);\n             arguments[i] = new AssertMax1ValueCallInput(input);\n         }\n-        Object actualValue = scalar.compile(function.arguments()).evaluate(txnCtx, null, (Input[]) arguments);\n+        Object actualValue = scalar.compile(function.arguments()).evaluate(txnCtx, sqlExpressions.nodeCtx, (Input[]) arguments);\n         assertThat((T) actualValue, expectedValue);\n \n         // Reset calls\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMTUyOQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476311529", "bodyText": "Same here", "author": "mfussenegger", "createdAt": "2020-08-25T09:29:38Z", "path": "server/src/test/java/io/crate/expression/scalar/AbstractScalarFunctionsTest.java", "diffHunk": "@@ -200,15 +196,15 @@ public void assertNormalize(String functionExpression, Matcher<? super Symbol> e\n             Input<?> input = ctx.add(arg);\n             arguments[i] = new AssertMax1ValueCallInput(input);\n         }\n-        Object actualValue = scalar.compile(function.arguments()).evaluate(txnCtx, (Input[]) arguments);\n+        Object actualValue = scalar.compile(function.arguments()).evaluate(txnCtx, null, (Input[]) arguments);\n         assertThat((T) actualValue, expectedValue);\n \n         // Reset calls\n         for (AssertMax1ValueCallInput argument : arguments) {\n             argument.calls = 0;\n         }\n \n-        actualValue = scalar.evaluate(txnCtx, arguments);\n+        actualValue = scalar.evaluate(txnCtx, null, arguments);", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/test/java/io/crate/expression/scalar/AbstractScalarFunctionsTest.java b/server/src/test/java/io/crate/expression/scalar/AbstractScalarFunctionsTest.java\nindex 48f79734ff..b28c907544 100644\n--- a/server/src/test/java/io/crate/expression/scalar/AbstractScalarFunctionsTest.java\n+++ b/server/src/test/java/io/crate/expression/scalar/AbstractScalarFunctionsTest.java\n\n@@ -196,7 +196,7 @@ public abstract class AbstractScalarFunctionsTest extends CrateDummyClusterServi\n             Input<?> input = ctx.add(arg);\n             arguments[i] = new AssertMax1ValueCallInput(input);\n         }\n-        Object actualValue = scalar.compile(function.arguments()).evaluate(txnCtx, null, (Input[]) arguments);\n+        Object actualValue = scalar.compile(function.arguments()).evaluate(txnCtx, sqlExpressions.nodeCtx, (Input[]) arguments);\n         assertThat((T) actualValue, expectedValue);\n \n         // Reset calls\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMzg1MQ==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476313851", "bodyText": "Please revert indentation changes", "author": "mfussenegger", "createdAt": "2020-08-25T09:33:27Z", "path": "server/src/test/java/io/crate/planner/node/ddl/UpdateSettingsPlanTest.java", "diffHunk": "@@ -45,19 +45,19 @@\n import java.util.function.Function;\n \n import static io.crate.planner.node.ddl.UpdateSettingsPlan.buildSettingsFrom;\n-import static io.crate.testing.TestingHelpers.getFunctions;\n+import static io.crate.testing.TestingHelpers.createNodeContext;\n import static org.hamcrest.Matchers.contains;\n import static org.hamcrest.Matchers.is;\n \n public class UpdateSettingsPlanTest extends ESTestCase {\n \n     private Function<Symbol, Object> symbolEvaluator(Row row) {\n         return x -> SymbolEvaluator.evaluate(\n-            TransactionContext.of(new SessionSettings(\"\", SearchPath.createSearchPathFrom(\"\"))),\n-            getFunctions(),\n-            x,\n-            row,\n-            SubQueryResults.EMPTY);\n+                TransactionContext.of(new SessionSettings(\"\", SearchPath.createSearchPathFrom(\"\"))),\n+                createNodeContext(),\n+                x,\n+                row,", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/test/java/io/crate/planner/node/ddl/UpdateSettingsPlanTest.java b/server/src/test/java/io/crate/planner/node/ddl/UpdateSettingsPlanTest.java\nindex ea90c7fc79..513ae3afc2 100644\n--- a/server/src/test/java/io/crate/planner/node/ddl/UpdateSettingsPlanTest.java\n+++ b/server/src/test/java/io/crate/planner/node/ddl/UpdateSettingsPlanTest.java\n\n@@ -53,11 +53,11 @@ public class UpdateSettingsPlanTest extends ESTestCase {\n \n     private Function<Symbol, Object> symbolEvaluator(Row row) {\n         return x -> SymbolEvaluator.evaluate(\n-                TransactionContext.of(new SessionSettings(\"\", SearchPath.createSearchPathFrom(\"\"))),\n-                createNodeContext(),\n-                x,\n-                row,\n-                SubQueryResults.EMPTY);\n+            TransactionContext.of(new SessionSettings(\"\", SearchPath.createSearchPathFrom(\"\"))),\n+            createNodeContext(),\n+            x,\n+            row,\n+            SubQueryResults.EMPTY);\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNDMyMg==", "url": "https://github.com/crate/crate/pull/10286#discussion_r476314322", "bodyText": "please revert indentation change", "author": "mfussenegger", "createdAt": "2020-08-25T09:34:15Z", "path": "server/src/test/java/io/crate/protocols/postgres/PostgresWireProtocolTest.java", "diffHunk": "@@ -88,13 +88,14 @@\n     public void prepare() {\n         SQLExecutor e = SQLExecutor.builder(clusterService).build();\n         sqlOperations = new SQLOperations(\n-            e.analyzer,\n-            e.planner,\n-            () -> mock(DependencyCarrier.class),\n-            new JobsLogs(() -> true),\n-            Settings.EMPTY,\n-            clusterService,\n-            USER_MANAGER_PROVIDER\n+                e.nodeCtx,\n+                e.analyzer,", "originalCommit": "fb34f88cb7221130cbd44299e9e755bba7047fc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f5632d18968562cbbbaf5ebca586926444304d9c", "chunk": "diff --git a/server/src/test/java/io/crate/protocols/postgres/PostgresWireProtocolTest.java b/server/src/test/java/io/crate/protocols/postgres/PostgresWireProtocolTest.java\nindex 4cc3fcc588..5863845dd2 100644\n--- a/server/src/test/java/io/crate/protocols/postgres/PostgresWireProtocolTest.java\n+++ b/server/src/test/java/io/crate/protocols/postgres/PostgresWireProtocolTest.java\n\n@@ -88,14 +88,14 @@ public class PostgresWireProtocolTest extends CrateDummyClusterServiceUnitTest {\n     public void prepare() {\n         SQLExecutor e = SQLExecutor.builder(clusterService).build();\n         sqlOperations = new SQLOperations(\n-                e.nodeCtx,\n-                e.analyzer,\n-                e.planner,\n-                () -> mock(DependencyCarrier.class),\n-                new JobsLogs(() -> true),\n-                Settings.EMPTY,\n-                clusterService,\n-                USER_MANAGER_PROVIDER\n+            e.nodeCtx,\n+            e.analyzer,\n+            e.planner,\n+            () -> mock(DependencyCarrier.class),\n+            new JobsLogs(() -> true),\n+            Settings.EMPTY,\n+            clusterService,\n+            USER_MANAGER_PROVIDER\n         ) {\n             @Override\n             public Session createSession(@Nullable String defaultSchema, @Nullable User user) {\n"}}, {"oid": "f5632d18968562cbbbaf5ebca586926444304d9c", "url": "https://github.com/crate/crate/commit/f5632d18968562cbbbaf5ebca586926444304d9c", "message": "Jordi's review", "committedDate": "2020-08-25T10:34:04Z", "type": "forcePushed"}, {"oid": "c5a3eca4ad03899ba07726bf503c8ed793323921", "url": "https://github.com/crate/crate/commit/c5a3eca4ad03899ba07726bf503c8ed793323921", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-25T12:53:31Z", "type": "forcePushed"}, {"oid": "8d963df4d62a007a3e8764c902d5ba8822d4c75d", "url": "https://github.com/crate/crate/commit/8d963df4d62a007a3e8764c902d5ba8822d4c75d", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n.\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-25T14:34:17Z", "type": "forcePushed"}, {"oid": "dceb388a74e5d68319873a0d440e5e8f1bcfac07", "url": "https://github.com/crate/crate/commit/dceb388a74e5d68319873a0d440e5e8f1bcfac07", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-25T14:36:55Z", "type": "forcePushed"}, {"oid": "789ffa3b6610e1242d924d018b9ed116a7b898c7", "url": "https://github.com/crate/crate/commit/789ffa3b6610e1242d924d018b9ed116a7b898c7", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-25T15:41:06Z", "type": "forcePushed"}, {"oid": "d499b87928d3b9f7eb986a334ee91c5fb54b1dbc", "url": "https://github.com/crate/crate/commit/d499b87928d3b9f7eb986a334ee91c5fb54b1dbc", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-25T15:57:01Z", "type": "commit"}, {"oid": "d499b87928d3b9f7eb986a334ee91c5fb54b1dbc", "url": "https://github.com/crate/crate/commit/d499b87928d3b9f7eb986a334ee91c5fb54b1dbc", "message": "Add scalar function pg_function_is_visible(OID)\n\nA function's OID is calculated as a hash over its schema, name, and argument type\nlist. System functions are declared on startup, as the various modules are registered.\nUser defined functions, UDF, are registered/deregistered dynamically CREATE/DROP FUNCTION\nstatements respectively.\n\nUsers can 'select function pg_function_is_visible(OID)' to check that the function\nrefered to by the OID is visible. All system and UDF functions are visible.", "committedDate": "2020-08-25T15:57:01Z", "type": "forcePushed"}]}