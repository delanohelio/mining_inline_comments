{"pr_number": 9684, "pr_title": "Deduplicate fields and outputs", "pr_createdAt": "2020-02-17T14:10:44Z", "pr_url": "https://github.com/crate/crate/pull/9684", "timeline": [{"oid": "6ae22582cd75d4e6c84fbfbda31abdc255cd3603", "url": "https://github.com/crate/crate/commit/6ae22582cd75d4e6c84fbfbda31abdc255cd3603", "message": "WIP: R.I.P RelationBoundary", "committedDate": "2020-02-17T15:46:55Z", "type": "forcePushed"}, {"oid": "fe940e2560d16682ec9821c4a2c6926eb8f0a1b2", "url": "https://github.com/crate/crate/commit/fe940e2560d16682ec9821c4a2c6926eb8f0a1b2", "message": "fixup! fixup! WIP: Deduplicate fields and outputs", "committedDate": "2020-02-18T18:32:25Z", "type": "forcePushed"}, {"oid": "4cd0a7d7c931930913835fe87dd39e9a6a3a3965", "url": "https://github.com/crate/crate/commit/4cd0a7d7c931930913835fe87dd39e9a6a3a3965", "message": "160 - LogicalPlanner new plan building", "committedDate": "2020-02-20T16:06:59Z", "type": "forcePushed"}, {"oid": "870db421754f70de71c045e4e21c0f433604d83c", "url": "https://github.com/crate/crate/commit/870db421754f70de71c045e4e21c0f433604d83c", "message": "139", "committedDate": "2020-02-21T23:00:25Z", "type": "forcePushed"}, {"oid": "bae95c0a8769a4bdd3180dd768b0ebf3b03ca433", "url": "https://github.com/crate/crate/commit/bae95c0a8769a4bdd3180dd768b0ebf3b03ca433", "message": "17", "committedDate": "2020-02-24T16:19:58Z", "type": "forcePushed"}, {"oid": "8ad0cf4b74cb0890e2765a6b3990b8c2ec0083d0", "url": "https://github.com/crate/crate/commit/8ad0cf4b74cb0890e2765a6b3990b8c2ec0083d0", "message": "Deduplicate fields and outputs\n\nRough outline:\n\n- Removes `fields` from `AnalyzedRelation`. There are only `outputs`\n\n- Changes `Field` to `ScopedSymbol`, which is only added when a relation\n  introduces a new scope. (E.g. in SELECT t1.x, t2.x FROM t AS t1, t AS\n  t2, it is necessary to distinguish between t1.x and t2.x, so `AS t1`\n  needs to introduce a scope)\n\n- Adds `AliasSymbol` to preserve the `AS <xy>` information\n\n- Merges `QueriedSelectRelation` and `MultiSourceSelect`. Also changes\n  `QualifiedName` usages to `RelationName` - so that everything is unified to\n  `RelationName` after the Analyzer.\n\n- Changes the `LogicalPlanner` to only process the clauses of a relation that\n  are really there. (Only `QueriedSelectRelation` can contain WHERE, GROUP BY,\n  HAVING, etc...)", "committedDate": "2020-02-26T10:29:49Z", "type": "forcePushed"}, {"oid": "d38b0dfc147be13b9d8421166b22a8c8d50ea666", "url": "https://github.com/crate/crate/commit/d38b0dfc147be13b9d8421166b22a8c8d50ea666", "message": "fixup! Deduplicate fields and outputs", "committedDate": "2020-02-26T11:59:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNDczOQ==", "url": "https://github.com/crate/crate/pull/9684#discussion_r384514739", "bodyText": "isn't this comment in general still valid/interesting?", "author": "seut", "createdAt": "2020-02-26T14:10:43Z", "path": "sql/src/main/java/io/crate/analyze/relations/UnionSelect.java", "diffHunk": "@@ -22,46 +22,36 @@\n \n package io.crate.analyze.relations;\n \n-import io.crate.analyze.Fields;\n-import io.crate.analyze.HavingClause;\n-import io.crate.analyze.OrderBy;\n-import io.crate.analyze.Relations;\n-import io.crate.analyze.WhereClause;\n import io.crate.exceptions.ColumnUnknownException;\n-import io.crate.expression.symbol.Field;\n+import io.crate.expression.symbol.ScopedSymbol;\n import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n import io.crate.metadata.ColumnIdent;\n+import io.crate.metadata.RelationName;\n import io.crate.metadata.table.Operation;\n-import io.crate.sql.tree.QualifiedName;\n+import org.elasticsearch.common.UUIDs;\n \n import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n+import java.util.ArrayList;\n import java.util.List;\n \n public class UnionSelect implements AnalyzedRelation {\n \n-    private final Fields fields;\n     private final AnalyzedRelation left;\n     private final AnalyzedRelation right;\n-    private final List<Symbol> outputs;\n-    private final QualifiedName name;\n+    private final List<ScopedSymbol> outputs;\n+    private final RelationName name;\n \n     public UnionSelect(AnalyzedRelation left, AnalyzedRelation right) {\n         this.left = left;\n         this.right = right;\n-        this.name = left.getQualifiedName();\n-\n-        List<Field> fieldsFromLeft = left.fields();\n-        fields = new Fields(fieldsFromLeft.size());\n-        for (Field field : fieldsFromLeft) {\n-            // Creating a field that points to the field of the left relation isn't 100% accurate.\n-            // We're pointing to *two* symbols (both left AND right).\n-            // We could either use a `InputColumn` to do that (by pointing to a position) - (but might be confusing to have InputColumns in the analysis already)\n-            // Or introduce a `UnionSymbol` or `UnionField` which would take two symbols it is pointing to\n-            // Since this currently has no effect we go with the left symbol until there is a good reason to change it.", "originalCommit": "d38b0dfc147be13b9d8421166b22a8c8d50ea666", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjEwMw==", "url": "https://github.com/crate/crate/pull/9684#discussion_r384556103", "bodyText": "Not sure - the pointer stuff is gone. I could add a comment that due to SQL semantics it uses the name of the left relation or so?", "author": "mfussenegger", "createdAt": "2020-02-26T15:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNDczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NzU3MQ==", "url": "https://github.com/crate/crate/pull/9684#discussion_r384557571", "bodyText": "Hm right, fine for me without a comment as well.", "author": "seut", "createdAt": "2020-02-26T15:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNDczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2NDQ3NA==", "url": "https://github.com/crate/crate/pull/9684#discussion_r384564474", "bodyText": "Added a comment anyways", "author": "mfussenegger", "createdAt": "2020-02-26T15:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNDczOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c82af92faea7a5609de787095bf29630344dc6e0", "chunk": "diff --git a/sql/src/main/java/io/crate/analyze/relations/UnionSelect.java b/sql/src/main/java/io/crate/analyze/relations/UnionSelect.java\nindex e5a5ca8a09..7b51882858 100644\n--- a/sql/src/main/java/io/crate/analyze/relations/UnionSelect.java\n+++ b/sql/src/main/java/io/crate/analyze/relations/UnionSelect.java\n\n@@ -43,9 +43,12 @@ public class UnionSelect implements AnalyzedRelation {\n     private final RelationName name;\n \n     public UnionSelect(AnalyzedRelation left, AnalyzedRelation right) {\n+        assert left.outputs().size() == right.outputs().size()\n+            : \"Both the left side and the right side of UNION must have the same number of outputs\";\n         this.left = left;\n         this.right = right;\n         this.name = new RelationName(null, UUIDs.randomBase64UUID());\n+        // SQL semantics dictate that UNION uses the column names from the first relation (top or left side)\n         List<Symbol> fieldsFromLeft = left.outputs();\n         ArrayList<ScopedSymbol> outputs = new ArrayList<>(fieldsFromLeft.size());\n         for (Symbol field : fieldsFromLeft) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyMDM0MA==", "url": "https://github.com/crate/crate/pull/9684#discussion_r384520340", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assert newArg1 != null : arg1 + \" became NULL, symbols must never conver to NULL\";\n          \n          \n            \n                    assert newArg1 != null : arg1 + \" became NULL, symbols must never convert to NULL\";", "author": "seut", "createdAt": "2020-02-26T14:19:30Z", "path": "sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java", "diffHunk": "@@ -84,10 +86,12 @@ private Function manyArgs(Function func, C context) {\n     private Function twoArgs(Function func, C context) {\n         assert func.arguments().size() == 2 : \"size of arguments must be two\";\n         Symbol arg1 = func.arguments().get(0);\n-        Symbol newArg1 = requireNonNull(arg1.accept(this, context), \"function arguments must never be NULL\");\n+        Symbol newArg1 = arg1.accept(this, context);\n+        assert newArg1 != null : arg1 + \" became NULL, symbols must never conver to NULL\";", "originalCommit": "d38b0dfc147be13b9d8421166b22a8c8d50ea666", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c82af92faea7a5609de787095bf29630344dc6e0", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java b/sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java\nindex 87be4cac58..bb441f2414 100644\n--- a/sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java\n+++ b/sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java\n\n@@ -87,11 +87,11 @@ public abstract class FunctionCopyVisitor<C> extends SymbolVisitor<C, Symbol> {\n         assert func.arguments().size() == 2 : \"size of arguments must be two\";\n         Symbol arg1 = func.arguments().get(0);\n         Symbol newArg1 = arg1.accept(this, context);\n-        assert newArg1 != null : arg1 + \" became NULL, symbols must never conver to NULL\";\n+        assert newArg1 != null : arg1 + \" became NULL, symbols must never convert to NULL\";\n \n         Symbol arg2 = func.arguments().get(1);\n         Symbol newArg2 = arg2.accept(this, context);\n-        assert newArg2 != null : arg2 + \" became NULL, symbols must never conver to NULL\";\n+        assert newArg2 != null : arg2 + \" became NULL, symbols must never convert to NULL\";\n \n         Symbol filter = func.filter();\n         Symbol newFilter = processNullable(filter, context);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyMDQ2OQ==", "url": "https://github.com/crate/crate/pull/9684#discussion_r384520469", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assert newArg2 != null : arg2 + \" became NULL, symbols must never conver to NULL\";\n          \n          \n            \n                    assert newArg2 != null : arg2 + \" became NULL, symbols must never convert to NULL\";", "author": "seut", "createdAt": "2020-02-26T14:19:42Z", "path": "sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java", "diffHunk": "@@ -84,10 +86,12 @@ private Function manyArgs(Function func, C context) {\n     private Function twoArgs(Function func, C context) {\n         assert func.arguments().size() == 2 : \"size of arguments must be two\";\n         Symbol arg1 = func.arguments().get(0);\n-        Symbol newArg1 = requireNonNull(arg1.accept(this, context), \"function arguments must never be NULL\");\n+        Symbol newArg1 = arg1.accept(this, context);\n+        assert newArg1 != null : arg1 + \" became NULL, symbols must never conver to NULL\";\n \n         Symbol arg2 = func.arguments().get(1);\n-        Symbol newArg2 = requireNonNull(arg2.accept(this, context), \"function arguments must never be NULL\");\n+        Symbol newArg2 = arg2.accept(this, context);\n+        assert newArg2 != null : arg2 + \" became NULL, symbols must never conver to NULL\";", "originalCommit": "d38b0dfc147be13b9d8421166b22a8c8d50ea666", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c82af92faea7a5609de787095bf29630344dc6e0", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java b/sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java\nindex 87be4cac58..bb441f2414 100644\n--- a/sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java\n+++ b/sql/src/main/java/io/crate/expression/symbol/FunctionCopyVisitor.java\n\n@@ -87,11 +87,11 @@ public abstract class FunctionCopyVisitor<C> extends SymbolVisitor<C, Symbol> {\n         assert func.arguments().size() == 2 : \"size of arguments must be two\";\n         Symbol arg1 = func.arguments().get(0);\n         Symbol newArg1 = arg1.accept(this, context);\n-        assert newArg1 != null : arg1 + \" became NULL, symbols must never conver to NULL\";\n+        assert newArg1 != null : arg1 + \" became NULL, symbols must never convert to NULL\";\n \n         Symbol arg2 = func.arguments().get(1);\n         Symbol newArg2 = arg2.accept(this, context);\n-        assert newArg2 != null : arg2 + \" became NULL, symbols must never conver to NULL\";\n+        assert newArg2 != null : arg2 + \" became NULL, symbols must never convert to NULL\";\n \n         Symbol filter = func.filter();\n         Symbol newFilter = processNullable(filter, context);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTQ4Mg==", "url": "https://github.com/crate/crate/pull/9684#discussion_r384541482", "bodyText": "looks like renamed by mistake?", "author": "seut", "createdAt": "2020-02-26T14:51:24Z", "path": "sql/src/test/java/io/crate/expression/reference/sys/node/NodeStatsContextScopedSymbolResolverTest.java", "diffHunk": "@@ -55,7 +55,7 @@\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-public class NodeStatsContextFieldResolverTest {\n+public class NodeStatsContextScopedSymbolResolverTest {", "originalCommit": "d38b0dfc147be13b9d8421166b22a8c8d50ea666", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c82af92faea7a5609de787095bf29630344dc6e0", "chunk": "diff --git a/sql/src/test/java/io/crate/expression/reference/sys/node/NodeStatsContextScopedSymbolResolverTest.java b/sql/src/test/java/io/crate/expression/reference/sys/node/NodeStatsContextFieldResolverTest.java\nsimilarity index 99%\nrename from sql/src/test/java/io/crate/expression/reference/sys/node/NodeStatsContextScopedSymbolResolverTest.java\nrename to sql/src/test/java/io/crate/expression/reference/sys/node/NodeStatsContextFieldResolverTest.java\nindex 1385854d8f..5bc96aa76f 100644\n--- a/sql/src/test/java/io/crate/expression/reference/sys/node/NodeStatsContextScopedSymbolResolverTest.java\n+++ b/sql/src/test/java/io/crate/expression/reference/sys/node/NodeStatsContextFieldResolverTest.java\n\n@@ -55,7 +55,7 @@ import static org.junit.Assert.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-public class NodeStatsContextScopedSymbolResolverTest {\n+public class NodeStatsContextFieldResolverTest {\n \n     private NodeStatsContextFieldResolver resolver;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTkzNg==", "url": "https://github.com/crate/crate/pull/9684#discussion_r384541936", "bodyText": "Renamed by mistake?", "author": "seut", "createdAt": "2020-02-26T14:52:04Z", "path": "sql/src/test/java/io/crate/analyze/relations/ExcludedScopedSymbolProviderTest.java", "diffHunk": "@@ -23,36 +23,34 @@\n package io.crate.analyze.relations;\n \n import io.crate.analyze.ValuesResolver;\n-import io.crate.expression.symbol.Field;\n-import io.crate.expression.symbol.InputColumn;\n import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.ScopedSymbol;\n import io.crate.metadata.ColumnIdent;\n+import io.crate.metadata.RelationName;\n import io.crate.metadata.table.Operation;\n import io.crate.sql.tree.QualifiedName;\n import io.crate.types.DataTypes;\n import org.junit.Test;\n-import org.mockito.Mockito;\n \n import static io.crate.testing.SymbolMatchers.isField;\n import static io.crate.testing.SymbolMatchers.isLiteral;\n-import static org.hamcrest.Matchers.is;\n import static org.junit.Assert.assertThat;\n \n-public class ExcludedFieldProviderTest {\n+public class ExcludedScopedSymbolProviderTest {", "originalCommit": "d38b0dfc147be13b9d8421166b22a8c8d50ea666", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NTA4Mg==", "url": "https://github.com/crate/crate/pull/9684#discussion_r384555082", "bodyText": "Yep, Intellij rename refactoring was too aggressive :(", "author": "mfussenegger", "createdAt": "2020-02-26T15:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTkzNg=="}], "type": "inlineReview", "revised_code": {"commit": "c82af92faea7a5609de787095bf29630344dc6e0", "chunk": "diff --git a/sql/src/test/java/io/crate/analyze/relations/ExcludedScopedSymbolProviderTest.java b/sql/src/test/java/io/crate/analyze/relations/ExcludedFieldProviderTest.java\nsimilarity index 98%\nrename from sql/src/test/java/io/crate/analyze/relations/ExcludedScopedSymbolProviderTest.java\nrename to sql/src/test/java/io/crate/analyze/relations/ExcludedFieldProviderTest.java\nindex 48abbe748e..cbd3d8c5b1 100644\n--- a/sql/src/test/java/io/crate/analyze/relations/ExcludedScopedSymbolProviderTest.java\n+++ b/sql/src/test/java/io/crate/analyze/relations/ExcludedFieldProviderTest.java\n\n@@ -36,7 +36,7 @@ import static io.crate.testing.SymbolMatchers.isField;\n import static io.crate.testing.SymbolMatchers.isLiteral;\n import static org.junit.Assert.assertThat;\n \n-public class ExcludedScopedSymbolProviderTest {\n+public class ExcludedFieldProviderTest {\n \n     @Test\n     public void testResolveFieldsAndValues() {\n"}}, {"oid": "c82af92faea7a5609de787095bf29630344dc6e0", "url": "https://github.com/crate/crate/commit/c82af92faea7a5609de787095bf29630344dc6e0", "message": "Deduplicate fields and outputs\n\nRough outline:\n\n- Removes `fields` from `AnalyzedRelation`. There are only `outputs`\n\n- Changes `Field` to `ScopedSymbol`, which is only added when a relation\n  introduces a new scope. (E.g. in SELECT t1.x, t2.x FROM t AS t1, t AS\n  t2, it is necessary to distinguish between t1.x and t2.x, so `AS t1`\n  needs to introduce a scope)\n\n- Adds `AliasSymbol` to preserve the `AS <xy>` information\n\n- Merges `QueriedSelectRelation` and `MultiSourceSelect`. Also changes\n  `QualifiedName` usages to `RelationName` - so that everything is unified to\n  `RelationName` after the Analyzer.\n\n- Changes the `LogicalPlanner` to only process the clauses of a relation that\n  are really there. (Only `QueriedSelectRelation` can contain WHERE, GROUP BY,\n  HAVING, etc...)", "committedDate": "2020-02-26T15:19:14Z", "type": "commit"}, {"oid": "c82af92faea7a5609de787095bf29630344dc6e0", "url": "https://github.com/crate/crate/commit/c82af92faea7a5609de787095bf29630344dc6e0", "message": "Deduplicate fields and outputs\n\nRough outline:\n\n- Removes `fields` from `AnalyzedRelation`. There are only `outputs`\n\n- Changes `Field` to `ScopedSymbol`, which is only added when a relation\n  introduces a new scope. (E.g. in SELECT t1.x, t2.x FROM t AS t1, t AS\n  t2, it is necessary to distinguish between t1.x and t2.x, so `AS t1`\n  needs to introduce a scope)\n\n- Adds `AliasSymbol` to preserve the `AS <xy>` information\n\n- Merges `QueriedSelectRelation` and `MultiSourceSelect`. Also changes\n  `QualifiedName` usages to `RelationName` - so that everything is unified to\n  `RelationName` after the Analyzer.\n\n- Changes the `LogicalPlanner` to only process the clauses of a relation that\n  are really there. (Only `QueriedSelectRelation` can contain WHERE, GROUP BY,\n  HAVING, etc...)", "committedDate": "2020-02-26T15:19:14Z", "type": "forcePushed"}]}