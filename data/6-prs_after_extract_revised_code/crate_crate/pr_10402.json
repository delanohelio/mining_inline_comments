{"pr_number": 10402, "pr_title": "Account for memory usage in doc values aggregators.", "pr_createdAt": "2020-08-19T13:15:43Z", "pr_url": "https://github.com/crate/crate/pull/10402", "timeline": [{"oid": "3508e2ae1d1d64b7d7d67db27b74903700eb1aad", "url": "https://github.com/crate/crate/commit/3508e2ae1d1d64b7d7d67db27b74903700eb1aad", "message": "Extend DocValueAggregator methods with the RamAccounting parameter.\n\nSome aggregation functions, e.g. array_agg or collect_set,\nmay require a significant amount of memory, therefore, we have to\naccount it.", "committedDate": "2020-08-19T13:56:45Z", "type": "commit"}, {"oid": "97e90192158ffa5f0c5021487e8113c470f61503", "url": "https://github.com/crate/crate/commit/97e90192158ffa5f0c5021487e8113c470f61503", "message": "Account for memory usage in doc values aggregator implementations.", "committedDate": "2020-08-19T13:56:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NTI1NA==", "url": "https://github.com/crate/crate/pull/10402#discussion_r473065254", "bodyText": "Shouldn't we do this in apply instead, to account the used bytes earlier? Or does that make the abstractions more complex?", "author": "mfussenegger", "createdAt": "2020-08-19T14:18:50Z", "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/ArbitraryAggregation.java", "diffHunk": "@@ -198,21 +203,26 @@ public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n     private static class ArbitraryNumericDocValueAggregator extends SortedNumericDocValueAggregator<MutableObject> {\n \n         private final DataType<?> columnDataType;\n+        private final SizeEstimator<Object> sizeEstimator;\n \n         public ArbitraryNumericDocValueAggregator(\n             String columnName,\n             DataType<?> columnDataType,\n+            SizeEstimator<Object> sizeEstimator,\n             CheckedBiConsumer<SortedNumericDocValues, MutableObject, IOException> docValuesConsumer\n         ) {\n-            super(columnName, MutableObject::new, docValuesConsumer);\n+            super(columnName, (ramAccounting) -> new MutableObject(), docValuesConsumer);\n             this.columnDataType = columnDataType;\n+            this.sizeEstimator = sizeEstimator;\n         }\n \n         @Nullable\n         @Override\n         public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n             if (state.hasValue()) {\n-                return columnDataType.sanitizeValue(state.value());\n+                var partialResult = columnDataType.sanitizeValue(state.value());\n+                ramAccounting.addBytes(sizeEstimator.estimateSize(partialResult));", "originalCommit": "97e90192158ffa5f0c5021487e8113c470f61503", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3MDgyNA==", "url": "https://github.com/crate/crate/pull/10402#discussion_r473070824", "bodyText": "Yes, forgot that it is called only once. I will just override the apply then and account for memory there.", "author": "kovrus", "createdAt": "2020-08-19T14:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NTI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA4NzUxOA==", "url": "https://github.com/crate/crate/pull/10402#discussion_r473087518", "bodyText": "Hm it makes it a bit hard, it is not possible to reuse the abstraction, and extending it does not make sense. We need to have 4 different separate implementations for this case :/", "author": "kovrus", "createdAt": "2020-08-19T14:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NTI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5MDQxNA==", "url": "https://github.com/crate/crate/pull/10402#discussion_r473090414", "bodyText": "I'm a bit worried for the GROUP BY cases if we delay the accounting to partialResult. For aggregations it doesn't matter as it is only 1 row anyways. But afaik in the GROUP BY case the partial calls would happen at the very end, so we could have unique_key_values * num_arbitrary_aggregation aggregation states un-accounted for in-memory during the initial grouping phase, before any arbitrary state is accounted for.", "author": "mfussenegger", "createdAt": "2020-08-19T14:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NTI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNDM0MQ==", "url": "https://github.com/crate/crate/pull/10402#discussion_r473104341", "bodyText": "I see, let me look a bit more at it, but think for the arbitrary that's only the way to go with separate implementations or have smth like ThreeConsumer :)", "author": "kovrus", "createdAt": "2020-08-19T15:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NTI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "dca36317852bfdde29150acb23d19068916f961b", "chunk": "diff --git a/server/src/main/java/io/crate/execution/engine/aggregation/impl/ArbitraryAggregation.java b/server/src/main/java/io/crate/execution/engine/aggregation/impl/ArbitraryAggregation.java\nindex f64258443b..5cc8f1aa46 100644\n--- a/server/src/main/java/io/crate/execution/engine/aggregation/impl/ArbitraryAggregation.java\n+++ b/server/src/main/java/io/crate/execution/engine/aggregation/impl/ArbitraryAggregation.java\n\n@@ -138,91 +141,175 @@ public class ArbitraryAggregation extends AggregationFunction<Object, Object> {\n             case LongType.ID:\n             case TimestampType.ID_WITH_TZ:\n             case TimestampType.ID_WITHOUT_TZ:\n-                return new ArbitraryNumericDocValueAggregator(\n+                return new LongArbitraryDocValueAggregator(\n                     fieldTypes.get(0).name(),\n                     dataType,\n-                    partialEstimator,\n-                    (values, state) -> {\n-                        if (!state.hasValue()) {\n-                            state.setValue(values.nextValue());\n-                        }\n-                    }\n+                    partialEstimator\n                 );\n             case FloatType.ID:\n-                return new ArbitraryNumericDocValueAggregator(\n+                return new FloatArbitraryDocValueAggregator(\n                     fieldTypes.get(0).name(),\n-                    dataType,\n-                    partialEstimator,\n-                    (values, state) -> {\n-                        if (!state.hasValue()) {\n-                            var value = NumericUtils.sortableIntToFloat((int) values.nextValue());\n-                            state.setValue(value);\n-                        }\n-                    }\n+                    partialEstimator\n                 );\n             case DoubleType.ID:\n-                return new ArbitraryNumericDocValueAggregator(\n+                return new DoubleArbitraryDocValueAggregator(\n                     fieldTypes.get(0).name(),\n-                    dataType,\n-                    partialEstimator,\n-                    (values, state) -> {\n-                        if (!state.hasValue()) {\n-                            var value = NumericUtils.sortableLongToDouble(values.nextValue());\n-                            state.setValue(value);\n-                        }\n-                    }\n+                    partialEstimator\n                 );\n             case IpType.ID:\n             case StringType.ID:\n-                return new BinaryDocValueAggregator<>(\n+                return new ArbitraryBinaryDocValueAggregator(\n                     fieldTypes.get(0).name(),\n-                    (ramAccounting) -> new MutableObject(),\n-                    (values, state) -> {\n-                        if (!state.hasValue()) {\n-                            state.setValue(values.nextValue().utf8ToString());\n-                        }\n-                    }\n-                ) {\n-                    @Nullable\n-                    @Override\n-                    public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n-                        if (state.hasValue()) {\n-                            var partialResult = dataType.sanitizeValue(state.value());\n-                            ramAccounting.addBytes(partialEstimator.estimateSize(partialResult));\n-                            return partialResult;\n-                        } else {\n-                            return null;\n-                        }\n-                    }\n-                };\n+                    dataType,\n+                    partialEstimator\n+                );\n             default:\n                 return null;\n         }\n     }\n \n-    private static class ArbitraryNumericDocValueAggregator extends SortedNumericDocValueAggregator<MutableObject> {\n+    private static class LongArbitraryDocValueAggregator extends ArbitraryNumericDocValueAggregator {\n+\n+        private final DataType<?> dataType;\n+        private final SizeEstimator<Object> sizeEstimator;\n+\n+        public LongArbitraryDocValueAggregator(String columnName,\n+                                               DataType<?> dataType,\n+                                               SizeEstimator<Object> sizeEstimator) {\n+            super(columnName);\n+            this.dataType = dataType;\n+            this.sizeEstimator = sizeEstimator;\n+        }\n+\n+        @Override\n+        public void apply(RamAccounting ramAccounting, int doc, MutableObject state) throws IOException {\n+            if (values.advanceExact(doc) && values.docValueCount() == 1) {\n+                if (!state.hasValue()) {\n+                    var value = dataType.sanitizeValue(values.nextValue());\n+                    ramAccounting.addBytes(sizeEstimator.estimateSize(value));\n+                    state.setValue(value);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class FloatArbitraryDocValueAggregator extends ArbitraryNumericDocValueAggregator {\n \n-        private final DataType<?> columnDataType;\n         private final SizeEstimator<Object> sizeEstimator;\n \n-        public ArbitraryNumericDocValueAggregator(\n-            String columnName,\n-            DataType<?> columnDataType,\n-            SizeEstimator<Object> sizeEstimator,\n-            CheckedBiConsumer<SortedNumericDocValues, MutableObject, IOException> docValuesConsumer\n-        ) {\n-            super(columnName, (ramAccounting) -> new MutableObject(), docValuesConsumer);\n-            this.columnDataType = columnDataType;\n+        public FloatArbitraryDocValueAggregator(String columnName,\n+                                                SizeEstimator<Object> sizeEstimator) {\n+            super(columnName);\n             this.sizeEstimator = sizeEstimator;\n         }\n \n+        @Override\n+        public void apply(RamAccounting ramAccounting, int doc, MutableObject state) throws IOException {\n+            if (values.advanceExact(doc) && values.docValueCount() == 1) {\n+                if (!state.hasValue()) {\n+                    var value = NumericUtils.sortableIntToFloat((int) values.nextValue());\n+                    ramAccounting.addBytes(sizeEstimator.estimateSize(value));\n+                    state.setValue(value);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class DoubleArbitraryDocValueAggregator extends ArbitraryNumericDocValueAggregator {\n+\n+        private final SizeEstimator<Object> sizeEstimator;\n+\n+        public DoubleArbitraryDocValueAggregator(String columnName,\n+                                                 SizeEstimator<Object> sizeEstimator) {\n+            super(columnName);\n+            this.sizeEstimator = sizeEstimator;\n+        }\n+\n+        @Override\n+        public void apply(RamAccounting ramAccounting, int doc, MutableObject state) throws IOException {\n+            if (values.advanceExact(doc) && values.docValueCount() == 1) {\n+                if (!state.hasValue()) {\n+                    var value = NumericUtils.sortableLongToDouble(values.nextValue());\n+                    ramAccounting.addBytes(sizeEstimator.estimateSize(value));\n+                    state.setValue(value);\n+                }\n+            }\n+        }\n+    }\n+\n+    private abstract static class ArbitraryNumericDocValueAggregator implements DocValueAggregator<MutableObject> {\n+\n+        private final String columnName;\n+\n+        protected SortedNumericDocValues values;\n+\n+        public ArbitraryNumericDocValueAggregator(String columnName) {\n+            this.columnName = columnName;\n+        }\n+\n+        @Override\n+        public MutableObject initialState(RamAccounting ramAccounting) {\n+            return new MutableObject();\n+        }\n+\n+        @Override\n+        public void loadDocValues(LeafReader reader) throws IOException {\n+            values = DocValues.getSortedNumeric(reader, columnName);\n+        }\n+\n+        @Nullable\n+        @Override\n+        public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n+            if (state.hasValue()) {\n+                return state.value();\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private static class ArbitraryBinaryDocValueAggregator implements DocValueAggregator<MutableObject> {\n+\n+        private final String columnName;\n+        private final DataType<?> dataType;\n+        private final SizeEstimator<Object> sizeEstimator;\n+\n+        private SortedBinaryDocValues values;\n+\n+        public ArbitraryBinaryDocValueAggregator(String columnName,\n+                                                 DataType<?> dataType,\n+                                                 SizeEstimator<Object> sizeEstimator) {\n+            this.columnName = columnName;\n+            this.dataType = dataType;\n+            this.sizeEstimator = sizeEstimator;\n+        }\n+\n+        @Override\n+        public MutableObject initialState(RamAccounting ramAccounting) {\n+            return new MutableObject();\n+        }\n+\n+        @Override\n+        public void loadDocValues(LeafReader reader) throws IOException {\n+            values = FieldData.toString(DocValues.getSortedSet(reader, columnName));\n+        }\n+\n+        @Override\n+        public void apply(RamAccounting ramAccounting, int doc, MutableObject state) throws IOException {\n+            if (values.advanceExact(doc) && values.docValueCount() == 1) {\n+                if (!state.hasValue()) {\n+                    var value = dataType.sanitizeValue(values.nextValue().utf8ToString());\n+                    ramAccounting.addBytes(sizeEstimator.estimateSize(value));\n+                    state.setValue(value);\n+                }\n+            }\n+        }\n+\n         @Nullable\n         @Override\n         public Object partialResult(RamAccounting ramAccounting, MutableObject state) {\n             if (state.hasValue()) {\n-                var partialResult = columnDataType.sanitizeValue(state.value());\n-                ramAccounting.addBytes(sizeEstimator.estimateSize(partialResult));\n-                return partialResult;\n+                return state.value();\n             } else {\n                 return null;\n             }\n"}}, {"oid": "dca36317852bfdde29150acb23d19068916f961b", "url": "https://github.com/crate/crate/commit/dca36317852bfdde29150acb23d19068916f961b", "message": "fixup! Account for memory usage in doc values aggregator implementations.", "committedDate": "2020-08-20T09:04:21Z", "type": "forcePushed"}, {"oid": "140418053d1659865ffe0b7ca0de8ea24a1e7c04", "url": "https://github.com/crate/crate/commit/140418053d1659865ffe0b7ca0de8ea24a1e7c04", "message": "Account for memory usage in doc values aggregator implementations.", "committedDate": "2020-08-20T09:55:49Z", "type": "forcePushed"}, {"oid": "bab45a2fb96767c0e3e026557d7820ba38300227", "url": "https://github.com/crate/crate/commit/bab45a2fb96767c0e3e026557d7820ba38300227", "message": "Account for memory usage in doc values aggregator implementations.", "committedDate": "2020-08-20T12:04:30Z", "type": "commit"}, {"oid": "bab45a2fb96767c0e3e026557d7820ba38300227", "url": "https://github.com/crate/crate/commit/bab45a2fb96767c0e3e026557d7820ba38300227", "message": "Account for memory usage in doc values aggregator implementations.", "committedDate": "2020-08-20T12:04:30Z", "type": "forcePushed"}]}