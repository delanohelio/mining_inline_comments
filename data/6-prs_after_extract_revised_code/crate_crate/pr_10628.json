{"pr_number": 10628, "pr_title": "Backport of IndexServiceTest", "pr_createdAt": "2020-10-07T14:15:32Z", "pr_url": "https://github.com/crate/crate/pull/10628", "timeline": [{"oid": "e708052d437125359f454586ff71c6ad042ca4d4", "url": "https://github.com/crate/crate/commit/e708052d437125359f454586ff71c6ad042ca4d4", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-08T09:53:14Z", "type": "forcePushed"}, {"oid": "896a0ed779d2b46dcdf54f8c151a07036d3fd90b", "url": "https://github.com/crate/crate/commit/896a0ed779d2b46dcdf54f8c151a07036d3fd90b", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-08T14:40:51Z", "type": "forcePushed"}, {"oid": "8adc61231bb65ddf630b747dd1e6b9f0d7d50caf", "url": "https://github.com/crate/crate/commit/8adc61231bb65ddf630b747dd1e6b9f0d7d50caf", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-08T15:15:38Z", "type": "forcePushed"}, {"oid": "05d1126f86ca0204b0a6bc1b7be80e3bc2564f39", "url": "https://github.com/crate/crate/commit/05d1126f86ca0204b0a6bc1b7be80e3bc2564f39", "message": "Remove last flaky tests", "committedDate": "2020-10-09T09:57:04Z", "type": "forcePushed"}, {"oid": "5a46d6679568c23bf1a7becd3e414183e86fe74d", "url": "https://github.com/crate/crate/commit/5a46d6679568c23bf1a7becd3e414183e86fe74d", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-09T10:01:18Z", "type": "forcePushed"}, {"oid": "8b28695dd039c739c63ca398d46bffe9a394cbfe", "url": "https://github.com/crate/crate/commit/8b28695dd039c739c63ca398d46bffe9a394cbfe", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-09T10:15:11Z", "type": "forcePushed"}, {"oid": "af97277ec2b7a6e712dcdf0f5dbb8ef8fa953e35", "url": "https://github.com/crate/crate/commit/af97277ec2b7a6e712dcdf0f5dbb8ef8fa953e35", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-09T10:25:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzNzc0Nw==", "url": "https://github.com/crate/crate/pull/10628#discussion_r502337747", "bodyText": "Since translog.sync_interval is dynamic now we need to test against a different non dynamic setting.", "author": "mkleen", "createdAt": "2020-10-09T10:32:49Z", "path": "server/src/test/java/io/crate/integrationtests/TableSettingsTest.java", "diffHunk": "@@ -88,8 +88,8 @@ public void testSelectSettingsColumn() throws Exception {\n \n     @Test\n     public void testSetNonDynamicTableSetting() {\n-        assertThrows(() -> execute(\"alter table settings_table set (\\\"translog.sync_interval\\\"='10s')\"),\n-                     isSQLError(containsString(\"Can't update non dynamic settings [[index.translog.sync_interval]] for open indices\"),\n+        assertThrows(() -> execute(\"alter table settings_table set (\\\"soft_deletes.enabled\\\"='true')\"),", "originalCommit": "af97277ec2b7a6e712dcdf0f5dbb8ef8fa953e35", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "e5e974e06661649d3017ffe3cb8440a717c17f10", "url": "https://github.com/crate/crate/commit/e5e974e06661649d3017ffe3cb8440a717c17f10", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-09T10:39:14Z", "type": "forcePushed"}, {"oid": "55e6dea3402aa38096e77fb597f3ecd0010d4bdb", "url": "https://github.com/crate/crate/commit/55e6dea3402aa38096e77fb597f3ecd0010d4bdb", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-09T10:40:43Z", "type": "forcePushed"}, {"oid": "3f4b73e7fdddec5930a981448a05269551d12759", "url": "https://github.com/crate/crate/commit/3f4b73e7fdddec5930a981448a05269551d12759", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-09T12:55:16Z", "type": "forcePushed"}, {"oid": "1eaad56ac78b9482ff6ed770a55371b02f1c24de", "url": "https://github.com/crate/crate/commit/1eaad56ac78b9482ff6ed770a55371b02f1c24de", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-09T15:09:41Z", "type": "forcePushed"}, {"oid": "305d61096e4fca7ea770832f08302c508f1a20d8", "url": "https://github.com/crate/crate/commit/305d61096e4fca7ea770832f08302c508f1a20d8", "message": "fix testRefreshActuallyWorks", "committedDate": "2020-10-12T12:59:09Z", "type": "forcePushed"}, {"oid": "a12d98c9e96e979726ac11560691037087938cf3", "url": "https://github.com/crate/crate/commit/a12d98c9e96e979726ac11560691037087938cf3", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-12T14:02:49Z", "type": "forcePushed"}, {"oid": "8322e52ac7a26bdbe90e5c9bee9a3428c6c86794", "url": "https://github.com/crate/crate/commit/8322e52ac7a26bdbe90e5c9bee9a3428c6c86794", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-12T14:17:23Z", "type": "forcePushed"}, {"oid": "13ca785d4e7114b7f93573a95b53f1e2dc48cb66", "url": "https://github.com/crate/crate/commit/13ca785d4e7114b7f93573a95b53f1e2dc48cb66", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-12T15:07:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM2MzYwMw==", "url": "https://github.com/crate/crate/pull/10628#discussion_r503363603", "bodyText": "Last remaining flaky test. The flush operation does not always trigger the translog to be trimmed because the generation is not increased. I hope this is a test setup problem and not a issue in the engine. I was thinking to fix that in a follow up.", "author": "mkleen", "createdAt": "2020-10-12T15:13:50Z", "path": "server/src/test/java/org/elasticsearch/index/IndexServiceTests.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index;\n+\n+import io.crate.common.unit.TimeValue;\n+import io.crate.integrationtests.SQLHttpIntegrationTest;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.search.TopDocs;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.engine.Engine;\n+import org.elasticsearch.index.engine.EngineTestCase;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.IndexShardTestCase;\n+import org.elasticsearch.index.translog.Translog;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Ignore;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.crate.protocols.postgres.PGErrorStatus.INTERNAL_ERROR;\n+import static io.crate.testing.Asserts.assertThrows;\n+import static io.crate.testing.SQLErrorMatcher.isSQLError;\n+import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;\n+import static org.elasticsearch.index.shard.IndexShardTestCase.flushShard;\n+import static org.elasticsearch.index.shard.IndexShardTestCase.getEngine;\n+import static org.elasticsearch.test.InternalSettingsPlugin.TRANSLOG_RETENTION_CHECK_INTERVAL_SETTING;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(numDataNodes = 1, supportsDedicatedMasters = false)\n+public class IndexServiceTests extends SQLHttpIntegrationTest {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        var plugins = new ArrayList<>(super.nodePlugins());\n+        plugins.add(InternalSettingsPlugin.class);\n+        return plugins;\n+    }\n+\n+    public void testBaseAsyncTask() throws Exception {\n+        execute(\"create table test (x int) clustered into 1 shards\");\n+        IndexService indexService = getIndexService(\"test\");\n+\n+        AtomicReference<CountDownLatch> latch = new AtomicReference<>(new CountDownLatch(1));\n+        AtomicReference<CountDownLatch> latch2 = new AtomicReference<>(new CountDownLatch(1));\n+        final AtomicInteger count = new AtomicInteger();\n+        IndexService.BaseAsyncTask task = new IndexService.BaseAsyncTask(indexService, TimeValue.timeValueMillis(1)) {\n+            @Override\n+            protected void runInternal() {\n+                final CountDownLatch l1 = latch.get();\n+                final CountDownLatch l2 = latch2.get();\n+                count.incrementAndGet();\n+                assertTrue(\"generic threadpool is configured\", Thread.currentThread().getName().contains(\"[generic]\"));\n+                l1.countDown();\n+                try {\n+                    l2.await();\n+                } catch (InterruptedException e) {\n+                    fail(\"interrupted\");\n+                }\n+                if (randomBoolean()) { // task can throw exceptions!!\n+                    if (randomBoolean()) {\n+                        throw new RuntimeException(\"foo\");\n+                    } else {\n+                        throw new RuntimeException(\"bar\");\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            protected String getThreadPool() {\n+                return ThreadPool.Names.GENERIC;\n+            }\n+        };\n+\n+        latch.get().await();\n+        latch.set(new CountDownLatch(1));\n+        assertEquals(1, count.get());\n+        // here we need to swap first before we let it go otherwise threads might be very fast and run that task twice due to\n+        // random exception and the schedule interval is 1ms\n+        latch2.getAndSet(new CountDownLatch(1)).countDown();\n+        latch.get().await();\n+        assertEquals(2, count.get());\n+        task.close();\n+        latch2.get().countDown();\n+        assertEquals(2, count.get());\n+\n+        task = new IndexService.BaseAsyncTask(indexService, TimeValue.timeValueMillis(1000000)) {\n+            @Override\n+            protected void runInternal() {\n+\n+            }\n+        };\n+        assertTrue(task.mustReschedule());\n+\n+        // now close the index\n+        execute(\"alter table test close\");\n+        final Index index = indexService.index();\n+        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n+        final IndexService closedIndexService = getIndicesService().indexServiceSafe(index);\n+        assertNotSame(indexService, closedIndexService);\n+        assertFalse(task.mustReschedule());\n+        assertFalse(task.isClosed());\n+        assertEquals(1000000, task.getInterval().millis());\n+\n+        assertNotSame(indexService, closedIndexService);\n+        assertFalse(task.mustReschedule());\n+        assertFalse(task.isClosed());\n+        assertEquals(1000000, task.getInterval().millis());\n+\n+        // now reopen the index\n+        execute(\"alter table test open\");\n+        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n+        indexService = getIndicesService().indexServiceSafe(index);\n+        assertNotSame(closedIndexService, indexService);\n+\n+        task = new IndexService.BaseAsyncTask(indexService, TimeValue.timeValueMillis(100000)) {\n+            @Override\n+            protected void runInternal() {\n+\n+            }\n+        };\n+        assertTrue(task.mustReschedule());\n+        assertFalse(task.isClosed());\n+        assertTrue(task.isScheduled());\n+\n+        indexService.close(\"simon says\", false);\n+        assertFalse(\"no shards left\", task.mustReschedule());\n+        assertTrue(task.isScheduled());\n+        task.close();\n+        assertFalse(task.isScheduled());\n+    }\n+\n+    public void testRefreshTaskIsUpdated() throws Exception {\n+        execute(\"create table test (x int) clustered into 1 shards\");\n+        IndexService indexService = getIndexService(\"test\");\n+        var indexName = indexService.index().getName();\n+        IndexService.AsyncRefreshTask refreshTask = indexService.getRefreshTask();\n+        assertEquals(1000, refreshTask.getInterval().millis());\n+        assertTrue(indexService.getRefreshTask().mustReschedule());\n+\n+        // now disable\n+        client().admin().indices().prepareUpdateSettings(indexName)\n+            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), -1)).get();\n+        assertNotSame(refreshTask, indexService.getRefreshTask());\n+        assertTrue(refreshTask.isClosed());\n+        assertFalse(refreshTask.isScheduled());\n+\n+        // set it to 100ms\n+        client().admin().indices().prepareUpdateSettings(indexName)\n+            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(),  \"100ms\")).get();\n+        assertNotSame(refreshTask, indexService.getRefreshTask());\n+        assertTrue(refreshTask.isClosed());\n+\n+        refreshTask = indexService.getRefreshTask();\n+        assertTrue(refreshTask.mustReschedule());\n+        assertTrue(refreshTask.isScheduled());\n+        assertEquals(100, refreshTask.getInterval().millis());\n+\n+        // set it to 200ms\n+        client().admin().indices().prepareUpdateSettings(indexName)\n+            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), \"200ms\")).get();\n+        assertNotSame(refreshTask, indexService.getRefreshTask());\n+        assertTrue(refreshTask.isClosed());\n+\n+        refreshTask = indexService.getRefreshTask();\n+        assertTrue(refreshTask.mustReschedule());\n+        assertTrue(refreshTask.isScheduled());\n+        assertEquals(200, refreshTask.getInterval().millis());\n+\n+        // set it to 200ms again\n+        client().admin().indices().prepareUpdateSettings(indexName)\n+            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), \"200ms\")).get();\n+        assertSame(refreshTask, indexService.getRefreshTask());\n+        assertTrue(indexService.getRefreshTask().mustReschedule());\n+        assertTrue(refreshTask.isScheduled());\n+        assertFalse(refreshTask.isClosed());\n+        assertEquals(200, refreshTask.getInterval().millis());\n+\n+        // now close the index\n+        execute(\"alter table test close\");\n+        final Index index = indexService.index();\n+        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n+\n+        final IndexService closedIndexService = getIndicesService().indexServiceSafe(index);\n+        assertNotSame(indexService, closedIndexService);\n+        assertNotSame(refreshTask, closedIndexService.getRefreshTask());\n+        assertFalse(closedIndexService.getRefreshTask().mustReschedule());\n+        assertFalse(closedIndexService.getRefreshTask().isClosed());\n+        assertEquals(200, closedIndexService.getRefreshTask().getInterval().millis());\n+\n+        // now reopen the index\n+        execute(\"alter table test open\");\n+        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n+        indexService = getIndicesService().indexServiceSafe(index);\n+        assertNotSame(closedIndexService, indexService);\n+        refreshTask = indexService.getRefreshTask();\n+        assertTrue(indexService.getRefreshTask().mustReschedule());\n+        assertTrue(refreshTask.isScheduled());\n+        assertFalse(refreshTask.isClosed());\n+\n+        indexService.close(\"simon says\", false);\n+        assertFalse(refreshTask.isScheduled());\n+        assertTrue(refreshTask.isClosed());\n+    }\n+\n+    public void testFsyncTaskIsRunning() throws Exception {\n+        execute(\"create table test(x int) clustered into 1 shards with (\\\"translog.durability\\\" = 'ASYNC')\");\n+        IndexService indexService = getIndexService(\"test\");\n+        IndexService.AsyncTranslogFSync fsyncTask = indexService.getFsyncTask();\n+        assertNotNull(fsyncTask);\n+        assertEquals(5000, fsyncTask.getInterval().millis());\n+        assertTrue(fsyncTask.mustReschedule());\n+        assertTrue(fsyncTask.isScheduled());\n+\n+        // now close the index\n+        execute(\"alter table test close\");\n+        final Index index = indexService.index();\n+        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n+\n+        final IndexService closedIndexService = getIndicesService().indexServiceSafe(index);\n+        assertNotSame(indexService, closedIndexService);\n+        assertNotSame(fsyncTask, closedIndexService.getFsyncTask());\n+        assertFalse(closedIndexService.getFsyncTask().mustReschedule());\n+        assertFalse(closedIndexService.getFsyncTask().isClosed());\n+        assertEquals(5000, closedIndexService.getFsyncTask().getInterval().millis());\n+\n+        // now reopen the index\n+        execute(\"alter table test open\");\n+        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n+        indexService = getIndicesService().indexServiceSafe(index);\n+        assertNotSame(closedIndexService, indexService);\n+        fsyncTask = indexService.getFsyncTask();\n+        assertTrue(indexService.getRefreshTask().mustReschedule());\n+        assertTrue(fsyncTask.isScheduled());\n+        assertFalse(fsyncTask.isClosed());\n+\n+        indexService.close(\"simon says\", false);\n+        assertFalse(fsyncTask.isScheduled());\n+        assertTrue(fsyncTask.isClosed());\n+\n+        execute(\"create table test1 (x int, data text)\");\n+        indexService = getIndexService(\"test1\");\n+        assertNull(indexService.getFsyncTask());\n+    }\n+\n+    public void testRefreshActuallyWorks() throws Exception {\n+        execute(\"create table test (x int, data text) clustered into 1 shards\");\n+        var indexService = getIndexService(\"test\");\n+        var indexName = indexService.index().getName();\n+        ensureGreen(indexName);\n+        IndexService.AsyncRefreshTask refreshTask = indexService.getRefreshTask();\n+        assertEquals(1000, refreshTask.getInterval().millis());\n+        assertTrue(indexService.getRefreshTask().mustReschedule());\n+        IndexShard shard = indexService.getShard(0);\n+        execute(\"insert into test (x, data) values (1, 'foo')\");\n+        // now disable the refresh\n+        client().admin().indices().prepareUpdateSettings(indexName)\n+            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), -1)).get();\n+        // when we update we reschedule the existing task AND fire off an async refresh to make sure we make everything visible\n+        // before that this is why we need to wait for the refresh task to be unscheduled and the first doc to be visible\n+        assertTrue(refreshTask.isClosed());\n+        refreshTask = indexService.getRefreshTask();\n+        assertBusy(() -> {\n+            // this one either becomes visible due to a concurrently running scheduled refresh OR due to the force refresh\n+            // we are running on updateMetadata if the interval changes\n+            try (Engine.Searcher searcher = shard.acquireSearcher(indexName)) {\n+                TopDocs search = searcher.search(new MatchAllDocsQuery(), 10);\n+                assertEquals(1, search.totalHits.value);\n+            }\n+        });\n+        assertFalse(refreshTask.isClosed());\n+        // refresh every millisecond\n+        execute(\"insert into test (x, data) values (2, 'foo')\");\n+        client().admin().indices().prepareUpdateSettings(indexName)\n+            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), \"1ms\")).get();\n+        assertTrue(refreshTask.isClosed());\n+\n+        assertBusy(() -> {\n+            // this one becomes visible due to the force refresh we are running on updateMetadata if the interval changes\n+            try (Engine.Searcher searcher = shard.acquireSearcher(indexName)) {\n+                TopDocs search = searcher.search(new MatchAllDocsQuery(), 10);\n+                assertEquals(2, search.totalHits.value);\n+            }\n+        });\n+        execute(\"insert into test (x, data) values (3, 'foo')\");\n+\n+        assertBusy(() -> {\n+            // this one becomes visible due to the scheduled refresh\n+            try (Engine.Searcher searcher = shard.acquireSearcher(\"test\")) {\n+                TopDocs search = searcher.search(new MatchAllDocsQuery(), 10);\n+                assertEquals(3, search.totalHits.value);\n+            }\n+        });\n+    }\n+\n+    public void testAsyncFsyncActuallyWorks() throws Exception {\n+        execute(\"create table test(x int, data string) clustered into 1 shards with (\\\"translog.sync_interval\\\" = '100ms', \" +\n+                \"\\\"translog.durability\\\" = 'ASYNC')\");\n+        IndexService indexService = getIndexService(\"test\");\n+        var indexName = indexService.index().getName();\n+        ensureGreen(indexName);\n+        assertTrue(indexService.getRefreshTask().mustReschedule());\n+        execute(\"insert into test (x, data) values (1, 'foo')\");\n+        IndexShard shard = indexService.getShard(0);\n+        assertBusy(() -> assertFalse(shard.isSyncNeeded()));\n+    }\n+\n+    public void testRescheduleAsyncFsync() throws Exception {\n+        execute(\"create table test(x int, data string) clustered into 1 shards with (\\\"translog.sync_interval\\\" = '100ms', \\\"translog.durability\\\" = 'REQUEST')\");\n+        IndexService indexService = getIndexService(\"test\");\n+        var indexName = indexService.index().getName();\n+\n+        ensureGreen(indexName);\n+        assertNull(indexService.getFsyncTask());\n+\n+        execute(\"alter table test set (\\\"translog.durability\\\" = 'ASYNC')\");\n+\n+        assertNotNull(indexService.getFsyncTask());\n+        assertTrue(indexService.getFsyncTask().mustReschedule());\n+        execute(\"insert into test (x, data) values (1, 'foo')\");\n+        assertNotNull(indexService.getFsyncTask());\n+        final IndexShard shard = indexService.getShard(0);\n+        assertBusy(() -> assertFalse(shard.isSyncNeeded()));\n+\n+        execute(\"alter table test set (\\\"translog.durability\\\" = 'REQUEST')\");\n+        assertNull(indexService.getFsyncTask());\n+\n+        execute(\"alter table test set (\\\"translog.durability\\\" = 'ASYNC')\");\n+        assertNotNull(indexService.getFsyncTask());\n+    }\n+\n+    @Ignore(\"Flaky\")", "originalCommit": "13ca785d4e7114b7f93573a95b53f1e2dc48cb66", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58373616fea60faa546a1331fc4bc791e13cedac", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/index/IndexServiceTests.java b/server/src/test/java/org/elasticsearch/index/IndexServiceTests.java\nindex 7fecef3c60..6c7f1a57a8 100644\n--- a/server/src/test/java/org/elasticsearch/index/IndexServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/index/IndexServiceTests.java\n\n@@ -35,8 +35,6 @@ import org.elasticsearch.plugins.Plugin;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.InternalSettingsPlugin;\n import org.elasticsearch.threadpool.ThreadPool;\n-import org.junit.Ignore;\n-\n import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Collection;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyNjIyMg==", "url": "https://github.com/crate/crate/pull/10628#discussion_r503726222", "bodyText": "Isn't the rescheduleFsyncTask method now unused?", "author": "mfussenegger", "createdAt": "2020-10-13T07:29:17Z", "path": "server/src/main/java/org/elasticsearch/index/IndexService.java", "diffHunk": "@@ -566,10 +564,23 @@ public boolean isForceExecution() {\n                 });\n                 rescheduleRefreshTasks();\n             }\n-            final Translog.Durability durability = indexSettings.getTranslogDurability();\n-            if (durability != oldTranslogDurability) {\n-                rescheduleFsyncTask(durability);", "originalCommit": "13ca785d4e7114b7f93573a95b53f1e2dc48cb66", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab40c91fdeb7116cf586d845c0fb05d01c90c345", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/IndexService.java b/server/src/main/java/org/elasticsearch/index/IndexService.java\nindex 68076adb85..e1170ac2a1 100644\n--- a/server/src/main/java/org/elasticsearch/index/IndexService.java\n+++ b/server/src/main/java/org/elasticsearch/index/IndexService.java\n\n@@ -584,16 +584,6 @@ public class IndexService extends AbstractIndexComponent implements IndicesClust\n         }\n     }\n \n-    private void rescheduleFsyncTask(Translog.Durability durability) {\n-        try {\n-            if (fsyncTask != null) {\n-                fsyncTask.close();\n-            }\n-        } finally {\n-            fsyncTask = durability == Translog.Durability.REQUEST ? null : new AsyncTranslogFSync(this);\n-        }\n-    }\n-\n     private void rescheduleRefreshTasks() {\n         try {\n             refreshTask.close();\n"}}, {"oid": "ab40c91fdeb7116cf586d845c0fb05d01c90c345", "url": "https://github.com/crate/crate/commit/ab40c91fdeb7116cf586d845c0fb05d01c90c345", "message": "Remove uneeded rescheduleFsyncTask", "committedDate": "2020-10-13T08:41:48Z", "type": "forcePushed"}, {"oid": "58373616fea60faa546a1331fc4bc791e13cedac", "url": "https://github.com/crate/crate/commit/58373616fea60faa546a1331fc4bc791e13cedac", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-13T11:51:31Z", "type": "forcePushed"}, {"oid": "ffb7da1ef3dbf84b7183570c255decdc325d7c0b", "url": "https://github.com/crate/crate/commit/ffb7da1ef3dbf84b7183570c255decdc325d7c0b", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-13T13:38:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyMzMyOA==", "url": "https://github.com/crate/crate/pull/10628#discussion_r504023328", "bodyText": "Any reason to use the SQLHttpIntegrationTest base class instead of SQLTransportIntegrationTest ?", "author": "mfussenegger", "createdAt": "2020-10-13T14:58:56Z", "path": "server/src/test/java/org/elasticsearch/index/IndexServiceTests.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index;\n+\n+import io.crate.common.unit.TimeValue;\n+import io.crate.integrationtests.SQLHttpIntegrationTest;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.search.TopDocs;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.engine.Engine;\n+import org.elasticsearch.index.engine.EngineTestCase;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.IndexShardTestCase;\n+import org.elasticsearch.index.translog.Translog;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.crate.protocols.postgres.PGErrorStatus.INTERNAL_ERROR;\n+import static io.crate.testing.Asserts.assertThrows;\n+import static io.crate.testing.SQLErrorMatcher.isSQLError;\n+import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;\n+import static org.elasticsearch.index.shard.IndexShardTestCase.flushShard;\n+import static org.elasticsearch.index.shard.IndexShardTestCase.getEngine;\n+import static org.elasticsearch.test.InternalSettingsPlugin.TRANSLOG_RETENTION_CHECK_INTERVAL_SETTING;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(numDataNodes = 1, supportsDedicatedMasters = false)\n+public class IndexServiceTests extends SQLHttpIntegrationTest {", "originalCommit": "ffb7da1ef3dbf84b7183570c255decdc325d7c0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAzNTYxNg==", "url": "https://github.com/crate/crate/pull/10628#discussion_r504035616", "bodyText": "The original idea was to not have mixed api half http half psql to be as close possible to the original test when everything was quite unstable. But you are right. Lets go with SQLTransportIntegrationTest.", "author": "mkleen", "createdAt": "2020-10-13T15:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyMzMyOA=="}], "type": "inlineReview", "revised_code": {"commit": "ea425734ff87c9b4430812ef130cac61b94aba1f", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/index/IndexServiceTests.java b/server/src/test/java/org/elasticsearch/index/IndexServiceTests.java\ndeleted file mode 100644\nindex 6c7f1a57a8..0000000000\n--- a/server/src/test/java/org/elasticsearch/index/IndexServiceTests.java\n+++ /dev/null\n\n@@ -1,477 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.index;\n-\n-import io.crate.common.unit.TimeValue;\n-import io.crate.integrationtests.SQLHttpIntegrationTest;\n-import org.apache.lucene.search.MatchAllDocsQuery;\n-import org.apache.lucene.search.TopDocs;\n-import org.elasticsearch.cluster.metadata.IndexMetadata;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.index.engine.Engine;\n-import org.elasticsearch.index.engine.EngineTestCase;\n-import org.elasticsearch.index.shard.IndexShard;\n-import org.elasticsearch.index.shard.IndexShardTestCase;\n-import org.elasticsearch.index.translog.Translog;\n-import org.elasticsearch.indices.IndicesService;\n-import org.elasticsearch.plugins.Plugin;\n-import org.elasticsearch.test.ESIntegTestCase;\n-import org.elasticsearch.test.InternalSettingsPlugin;\n-import org.elasticsearch.threadpool.ThreadPool;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Map;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import static io.crate.protocols.postgres.PGErrorStatus.INTERNAL_ERROR;\n-import static io.crate.testing.Asserts.assertThrows;\n-import static io.crate.testing.SQLErrorMatcher.isSQLError;\n-import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;\n-import static org.elasticsearch.index.shard.IndexShardTestCase.flushShard;\n-import static org.elasticsearch.index.shard.IndexShardTestCase.getEngine;\n-import static org.elasticsearch.test.InternalSettingsPlugin.TRANSLOG_RETENTION_CHECK_INTERVAL_SETTING;\n-import static org.hamcrest.Matchers.equalTo;\n-import static org.hamcrest.Matchers.is;\n-\n-@ESIntegTestCase.ClusterScope(numDataNodes = 1, supportsDedicatedMasters = false)\n-public class IndexServiceTests extends SQLHttpIntegrationTest {\n-\n-    @Override\n-    protected Collection<Class<? extends Plugin>> nodePlugins() {\n-        var plugins = new ArrayList<>(super.nodePlugins());\n-        plugins.add(InternalSettingsPlugin.class);\n-        return plugins;\n-    }\n-\n-    public void testBaseAsyncTask() throws Exception {\n-        execute(\"create table test (x int) clustered into 1 shards\");\n-        IndexService indexService = getIndexService(\"test\");\n-\n-        AtomicReference<CountDownLatch> latch = new AtomicReference<>(new CountDownLatch(1));\n-        AtomicReference<CountDownLatch> latch2 = new AtomicReference<>(new CountDownLatch(1));\n-        final AtomicInteger count = new AtomicInteger();\n-        IndexService.BaseAsyncTask task = new IndexService.BaseAsyncTask(indexService, TimeValue.timeValueMillis(1)) {\n-            @Override\n-            protected void runInternal() {\n-                final CountDownLatch l1 = latch.get();\n-                final CountDownLatch l2 = latch2.get();\n-                count.incrementAndGet();\n-                assertTrue(\"generic threadpool is configured\", Thread.currentThread().getName().contains(\"[generic]\"));\n-                l1.countDown();\n-                try {\n-                    l2.await();\n-                } catch (InterruptedException e) {\n-                    fail(\"interrupted\");\n-                }\n-                if (randomBoolean()) { // task can throw exceptions!!\n-                    if (randomBoolean()) {\n-                        throw new RuntimeException(\"foo\");\n-                    } else {\n-                        throw new RuntimeException(\"bar\");\n-                    }\n-                }\n-            }\n-\n-            @Override\n-            protected String getThreadPool() {\n-                return ThreadPool.Names.GENERIC;\n-            }\n-        };\n-\n-        latch.get().await();\n-        latch.set(new CountDownLatch(1));\n-        assertEquals(1, count.get());\n-        // here we need to swap first before we let it go otherwise threads might be very fast and run that task twice due to\n-        // random exception and the schedule interval is 1ms\n-        latch2.getAndSet(new CountDownLatch(1)).countDown();\n-        latch.get().await();\n-        assertEquals(2, count.get());\n-        task.close();\n-        latch2.get().countDown();\n-        assertEquals(2, count.get());\n-\n-        task = new IndexService.BaseAsyncTask(indexService, TimeValue.timeValueMillis(1000000)) {\n-            @Override\n-            protected void runInternal() {\n-\n-            }\n-        };\n-        assertTrue(task.mustReschedule());\n-\n-        // now close the index\n-        execute(\"alter table test close\");\n-        final Index index = indexService.index();\n-        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n-        final IndexService closedIndexService = getIndicesService().indexServiceSafe(index);\n-        assertNotSame(indexService, closedIndexService);\n-        assertFalse(task.mustReschedule());\n-        assertFalse(task.isClosed());\n-        assertEquals(1000000, task.getInterval().millis());\n-\n-        assertNotSame(indexService, closedIndexService);\n-        assertFalse(task.mustReschedule());\n-        assertFalse(task.isClosed());\n-        assertEquals(1000000, task.getInterval().millis());\n-\n-        // now reopen the index\n-        execute(\"alter table test open\");\n-        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n-        indexService = getIndicesService().indexServiceSafe(index);\n-        assertNotSame(closedIndexService, indexService);\n-\n-        task = new IndexService.BaseAsyncTask(indexService, TimeValue.timeValueMillis(100000)) {\n-            @Override\n-            protected void runInternal() {\n-\n-            }\n-        };\n-        assertTrue(task.mustReschedule());\n-        assertFalse(task.isClosed());\n-        assertTrue(task.isScheduled());\n-\n-        indexService.close(\"simon says\", false);\n-        assertFalse(\"no shards left\", task.mustReschedule());\n-        assertTrue(task.isScheduled());\n-        task.close();\n-        assertFalse(task.isScheduled());\n-    }\n-\n-    public void testRefreshTaskIsUpdated() throws Exception {\n-        execute(\"create table test (x int) clustered into 1 shards\");\n-        IndexService indexService = getIndexService(\"test\");\n-        var indexName = indexService.index().getName();\n-        IndexService.AsyncRefreshTask refreshTask = indexService.getRefreshTask();\n-        assertEquals(1000, refreshTask.getInterval().millis());\n-        assertTrue(indexService.getRefreshTask().mustReschedule());\n-\n-        // now disable\n-        client().admin().indices().prepareUpdateSettings(indexName)\n-            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), -1)).get();\n-        assertNotSame(refreshTask, indexService.getRefreshTask());\n-        assertTrue(refreshTask.isClosed());\n-        assertFalse(refreshTask.isScheduled());\n-\n-        // set it to 100ms\n-        client().admin().indices().prepareUpdateSettings(indexName)\n-            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(),  \"100ms\")).get();\n-        assertNotSame(refreshTask, indexService.getRefreshTask());\n-        assertTrue(refreshTask.isClosed());\n-\n-        refreshTask = indexService.getRefreshTask();\n-        assertTrue(refreshTask.mustReschedule());\n-        assertTrue(refreshTask.isScheduled());\n-        assertEquals(100, refreshTask.getInterval().millis());\n-\n-        // set it to 200ms\n-        client().admin().indices().prepareUpdateSettings(indexName)\n-            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), \"200ms\")).get();\n-        assertNotSame(refreshTask, indexService.getRefreshTask());\n-        assertTrue(refreshTask.isClosed());\n-\n-        refreshTask = indexService.getRefreshTask();\n-        assertTrue(refreshTask.mustReschedule());\n-        assertTrue(refreshTask.isScheduled());\n-        assertEquals(200, refreshTask.getInterval().millis());\n-\n-        // set it to 200ms again\n-        client().admin().indices().prepareUpdateSettings(indexName)\n-            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), \"200ms\")).get();\n-        assertSame(refreshTask, indexService.getRefreshTask());\n-        assertTrue(indexService.getRefreshTask().mustReschedule());\n-        assertTrue(refreshTask.isScheduled());\n-        assertFalse(refreshTask.isClosed());\n-        assertEquals(200, refreshTask.getInterval().millis());\n-\n-        // now close the index\n-        execute(\"alter table test close\");\n-        final Index index = indexService.index();\n-        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n-\n-        final IndexService closedIndexService = getIndicesService().indexServiceSafe(index);\n-        assertNotSame(indexService, closedIndexService);\n-        assertNotSame(refreshTask, closedIndexService.getRefreshTask());\n-        assertFalse(closedIndexService.getRefreshTask().mustReschedule());\n-        assertFalse(closedIndexService.getRefreshTask().isClosed());\n-        assertEquals(200, closedIndexService.getRefreshTask().getInterval().millis());\n-\n-        // now reopen the index\n-        execute(\"alter table test open\");\n-        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n-        indexService = getIndicesService().indexServiceSafe(index);\n-        assertNotSame(closedIndexService, indexService);\n-        refreshTask = indexService.getRefreshTask();\n-        assertTrue(indexService.getRefreshTask().mustReschedule());\n-        assertTrue(refreshTask.isScheduled());\n-        assertFalse(refreshTask.isClosed());\n-\n-        indexService.close(\"simon says\", false);\n-        assertFalse(refreshTask.isScheduled());\n-        assertTrue(refreshTask.isClosed());\n-    }\n-\n-    public void testFsyncTaskIsRunning() throws Exception {\n-        execute(\"create table test(x int) clustered into 1 shards with (\\\"translog.durability\\\" = 'ASYNC')\");\n-        IndexService indexService = getIndexService(\"test\");\n-        IndexService.AsyncTranslogFSync fsyncTask = indexService.getFsyncTask();\n-        assertNotNull(fsyncTask);\n-        assertEquals(5000, fsyncTask.getInterval().millis());\n-        assertTrue(fsyncTask.mustReschedule());\n-        assertTrue(fsyncTask.isScheduled());\n-\n-        // now close the index\n-        execute(\"alter table test close\");\n-        final Index index = indexService.index();\n-        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n-\n-        final IndexService closedIndexService = getIndicesService().indexServiceSafe(index);\n-        assertNotSame(indexService, closedIndexService);\n-        assertNotSame(fsyncTask, closedIndexService.getFsyncTask());\n-        assertFalse(closedIndexService.getFsyncTask().mustReschedule());\n-        assertFalse(closedIndexService.getFsyncTask().isClosed());\n-        assertEquals(5000, closedIndexService.getFsyncTask().getInterval().millis());\n-\n-        // now reopen the index\n-        execute(\"alter table test open\");\n-        assertBusy(() -> assertTrue(\"Index not found: \" + index.getName(), getIndicesService().hasIndex(index)));\n-        indexService = getIndicesService().indexServiceSafe(index);\n-        assertNotSame(closedIndexService, indexService);\n-        fsyncTask = indexService.getFsyncTask();\n-        assertTrue(indexService.getRefreshTask().mustReschedule());\n-        assertTrue(fsyncTask.isScheduled());\n-        assertFalse(fsyncTask.isClosed());\n-\n-        indexService.close(\"simon says\", false);\n-        assertFalse(fsyncTask.isScheduled());\n-        assertTrue(fsyncTask.isClosed());\n-\n-        execute(\"create table test1 (x int, data text)\");\n-        indexService = getIndexService(\"test1\");\n-        assertNull(indexService.getFsyncTask());\n-    }\n-\n-    public void testRefreshActuallyWorks() throws Exception {\n-        execute(\"create table test (x int, data text) clustered into 1 shards\");\n-        var indexService = getIndexService(\"test\");\n-        var indexName = indexService.index().getName();\n-        ensureGreen(indexName);\n-        IndexService.AsyncRefreshTask refreshTask = indexService.getRefreshTask();\n-        assertEquals(1000, refreshTask.getInterval().millis());\n-        assertTrue(indexService.getRefreshTask().mustReschedule());\n-        IndexShard shard = indexService.getShard(0);\n-        execute(\"insert into test (x, data) values (1, 'foo')\");\n-        // now disable the refresh\n-        client().admin().indices().prepareUpdateSettings(indexName)\n-            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), -1)).get();\n-        // when we update we reschedule the existing task AND fire off an async refresh to make sure we make everything visible\n-        // before that this is why we need to wait for the refresh task to be unscheduled and the first doc to be visible\n-        assertTrue(refreshTask.isClosed());\n-        refreshTask = indexService.getRefreshTask();\n-        assertBusy(() -> {\n-            // this one either becomes visible due to a concurrently running scheduled refresh OR due to the force refresh\n-            // we are running on updateMetadata if the interval changes\n-            try (Engine.Searcher searcher = shard.acquireSearcher(indexName)) {\n-                TopDocs search = searcher.search(new MatchAllDocsQuery(), 10);\n-                assertEquals(1, search.totalHits.value);\n-            }\n-        });\n-        assertFalse(refreshTask.isClosed());\n-        // refresh every millisecond\n-        execute(\"insert into test (x, data) values (2, 'foo')\");\n-        client().admin().indices().prepareUpdateSettings(indexName)\n-            .setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), \"1ms\")).get();\n-        assertTrue(refreshTask.isClosed());\n-\n-        assertBusy(() -> {\n-            // this one becomes visible due to the force refresh we are running on updateMetadata if the interval changes\n-            try (Engine.Searcher searcher = shard.acquireSearcher(indexName)) {\n-                TopDocs search = searcher.search(new MatchAllDocsQuery(), 10);\n-                assertEquals(2, search.totalHits.value);\n-            }\n-        });\n-        execute(\"insert into test (x, data) values (3, 'foo')\");\n-\n-        assertBusy(() -> {\n-            // this one becomes visible due to the scheduled refresh\n-            try (Engine.Searcher searcher = shard.acquireSearcher(\"test\")) {\n-                TopDocs search = searcher.search(new MatchAllDocsQuery(), 10);\n-                assertEquals(3, search.totalHits.value);\n-            }\n-        });\n-    }\n-\n-    public void testAsyncFsyncActuallyWorks() throws Exception {\n-        execute(\"create table test(x int, data string) clustered into 1 shards with (\\\"translog.sync_interval\\\" = '100ms', \" +\n-                \"\\\"translog.durability\\\" = 'ASYNC')\");\n-        IndexService indexService = getIndexService(\"test\");\n-        var indexName = indexService.index().getName();\n-        ensureGreen(indexName);\n-        assertTrue(indexService.getRefreshTask().mustReschedule());\n-        execute(\"insert into test (x, data) values (1, 'foo')\");\n-        IndexShard shard = indexService.getShard(0);\n-        assertBusy(() -> assertFalse(shard.isSyncNeeded()));\n-    }\n-\n-    public void testRescheduleAsyncFsync() throws Exception {\n-        execute(\"create table test(x int, data string) clustered into 1 shards with (\\\"translog.sync_interval\\\" = '100ms', \\\"translog.durability\\\" = 'REQUEST')\");\n-        IndexService indexService = getIndexService(\"test\");\n-        var indexName = indexService.index().getName();\n-\n-        ensureGreen(indexName);\n-        assertNull(indexService.getFsyncTask());\n-\n-        execute(\"alter table test set (\\\"translog.durability\\\" = 'ASYNC')\");\n-\n-        assertNotNull(indexService.getFsyncTask());\n-        assertTrue(indexService.getFsyncTask().mustReschedule());\n-        execute(\"insert into test (x, data) values (1, 'foo')\");\n-        assertNotNull(indexService.getFsyncTask());\n-        final IndexShard shard = indexService.getShard(0);\n-        assertBusy(() -> assertFalse(shard.isSyncNeeded()));\n-\n-        execute(\"alter table test set (\\\"translog.durability\\\" = 'REQUEST')\");\n-        assertNull(indexService.getFsyncTask());\n-\n-        execute(\"alter table test set (\\\"translog.durability\\\" = 'ASYNC')\");\n-        assertNotNull(indexService.getFsyncTask());\n-    }\n-\n-    public void testAsyncTranslogTrimActuallyWorks() throws Exception {\n-        execute(\"create table test(x int, data string) clustered into 1 shards with (\\\"translog.sync_interval\\\" = '100ms')\");\n-        IndexService indexService = getIndexService(\"test\");\n-\n-        ensureGreen(indexService.index().getName());\n-        assertTrue(indexService.getTrimTranslogTask().mustReschedule());\n-        execute(\"insert into test (x, data) values (1, 'foo')\");\n-        IndexShard shard = indexService.getShard(0);\n-        flushShard(shard, true);\n-        assertBusy(() -> assertThat(EngineTestCase.getTranslog(getEngine(shard)).totalOperations(), equalTo(0)));\n-    }\n-\n-    public void testAsyncTranslogTrimTaskOnClosedIndex() throws Exception {\n-        execute (\"create table test(x int) clustered into 1 shards\");\n-        var indexService = getIndexService(\"test\");\n-        var indexName = indexService.index().getName();\n-\n-        client()\n-            .admin()\n-            .indices()\n-            .prepareUpdateSettings(indexName)\n-            .setSettings(Settings.builder().put(TRANSLOG_RETENTION_CHECK_INTERVAL_SETTING.getKey(), \"100ms\"))\n-            .get();\n-\n-        Translog translog = EngineTestCase.getTranslog(getEngine(indexService.getShard(0)));\n-        final Path translogPath = translog.getConfig().getTranslogPath();\n-        final String translogUuid = translog.getTranslogUUID();\n-\n-        int translogOps = 0;\n-        final int numDocs = scaledRandomIntBetween(10, 100);\n-        for (int i = 0; i < numDocs; i++) {\n-            execute(\"insert into test (x) values (?)\", new Object[]{i});\n-            translogOps++;\n-            if(randomBoolean()) {\n-                for (IndexShard indexShard : indexService) {\n-                    flushShard(indexShard, true);\n-                }\n-                if (indexService.getIndexSettings().isSoftDeleteEnabled()) {\n-                    translogOps = 0;\n-                }\n-            }\n-        }\n-        assertThat(translog.totalOperations(), equalTo(translogOps));\n-        assertThat(translog.stats().estimatedNumberOfOperations(), equalTo(translogOps));\n-\n-        execute(\"alter table test close\");\n-\n-        indexService =  getIndicesService().indexServiceSafe(indexService.index());\n-        assertTrue(indexService.getTrimTranslogTask().mustReschedule());\n-\n-        final long lastCommitedTranslogGeneration;\n-        try (Engine.IndexCommitRef indexCommitRef = getEngine(indexService.getShard(0)).acquireLastIndexCommit(false)) {\n-            Map<String, String> lastCommittedUserData = indexCommitRef.getIndexCommit().getUserData();\n-            lastCommitedTranslogGeneration = Long.parseLong(lastCommittedUserData.get(Translog.TRANSLOG_GENERATION_KEY));\n-        }\n-        assertBusy(() -> {\n-            long minTranslogGen = Translog.readMinTranslogGeneration(translogPath, translogUuid);\n-            assertThat(minTranslogGen, equalTo(lastCommitedTranslogGeneration));\n-        });\n-\n-        execute(\"alter table test open\");\n-        ensureGreen(indexName);\n-\n-        indexService = getIndexService(\"test\");\n-        translog = IndexShardTestCase.getTranslog(indexService.getShard(0));\n-        assertThat(translog.totalOperations(), equalTo(0));\n-        assertThat(translog.stats().estimatedNumberOfOperations(), equalTo(0));\n-    }\n-\n-    public void testIllegalFsyncInterval() {\n-        assertThrows(() -> execute(\"create table test(x int, data string) clustered into 1 shards with (\\\"translog.sync_interval\\\" = '0ms')\"),\n-                     isSQLError(is(\"failed to parse value [0ms] for setting [index.translog.sync_interval], must be >= [100ms]\"),\n-                                INTERNAL_ERROR,\n-                                BAD_REQUEST,\n-                                4000));\n-    }\n-\n-    public void testUpdateSyncIntervalDynamically() {\n-        execute(\"create table test(x int) clustered into 1 shards with(\\\"translog.sync_interval\\\" = '10s')\");\n-        IndexService indexService = getIndexService(\"test\");\n-        var indexName = indexService.index().getName();\n-\n-        ensureGreen(indexName);\n-        assertNull(indexService.getFsyncTask());\n-\n-        Settings.Builder builder = Settings.builder().put(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey(), \"5s\")\n-            .put(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey(), Translog.Durability.ASYNC.name());\n-\n-        client()\n-            .admin()\n-            .indices()\n-            .prepareUpdateSettings(indexName)\n-            .setSettings(builder)\n-            .get();\n-\n-        assertNotNull(indexService.getFsyncTask());\n-        assertTrue(indexService.getFsyncTask().mustReschedule());\n-\n-        IndexMetadata indexMetadata = client().admin().cluster().prepareState().execute().actionGet().getState().metadata().index(indexName);\n-        assertEquals(\"5s\", indexMetadata.getSettings().get(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey()));\n-\n-        execute(\"alter table test close\");\n-        client()\n-            .admin()\n-            .indices()\n-            .prepareUpdateSettings(indexName)\n-            .setSettings(Settings.builder().put(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey(), \"20s\"))\n-            .get();\n-        indexMetadata = client().admin().cluster().prepareState().execute().actionGet().getState().metadata().index(indexName);\n-        assertEquals(\"20s\", indexMetadata.getSettings().get(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey()));\n-    }\n-\n-    private IndexService getIndexService(String index) {\n-        return getIndicesService().indexServiceSafe(resolveIndex(getFqn(index)));\n-    }\n-\n-    private IndicesService getIndicesService() {\n-        return internalCluster().getInstances(IndicesService.class).iterator().next();\n-    }\n-}\n"}}, {"oid": "ea425734ff87c9b4430812ef130cac61b94aba1f", "url": "https://github.com/crate/crate/commit/ea425734ff87c9b4430812ef130cac61b94aba1f", "message": "bp: Make setting index.translog.sync_interval be dynamic\n\nhttps://github.com/elastic/elasticsearch/commit/3c352a85963f47a8272025e1969982bbe64c6a87", "committedDate": "2020-10-13T15:16:18Z", "type": "commit"}, {"oid": "4bace5917dc413b70550fecb009098d00cab74a9", "url": "https://github.com/crate/crate/commit/4bace5917dc413b70550fecb009098d00cab74a9", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-13T15:16:18Z", "type": "forcePushed"}, {"oid": "fd7cd252a6a306fcfa85f333b812d91287b32d99", "url": "https://github.com/crate/crate/commit/fd7cd252a6a306fcfa85f333b812d91287b32d99", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-13T15:17:54Z", "type": "forcePushed"}, {"oid": "edae9805a636e72c8774542e82d760db1704bbaa", "url": "https://github.com/crate/crate/commit/edae9805a636e72c8774542e82d760db1704bbaa", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-13T15:30:23Z", "type": "commit"}, {"oid": "edae9805a636e72c8774542e82d760db1704bbaa", "url": "https://github.com/crate/crate/commit/edae9805a636e72c8774542e82d760db1704bbaa", "message": "Add IndexServiceTest back to es test suite", "committedDate": "2020-10-13T15:30:23Z", "type": "forcePushed"}]}