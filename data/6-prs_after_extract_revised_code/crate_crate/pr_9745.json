{"pr_number": 9745, "pr_title": "Add column pruning", "pr_createdAt": "2020-03-06T10:16:39Z", "pr_url": "https://github.com/crate/crate/pull/9745", "timeline": [{"oid": "9e18b0037f0eddc9253879238ca7998f027ecbc3", "url": "https://github.com/crate/crate/commit/9e18b0037f0eddc9253879238ca7998f027ecbc3", "message": "WIP: Add column pruning\n\nFor cases like\n\n```\nSELECT x FROM my_view\n```\n\nWhere `my_view` resolves to `SELECT x, y, z FROM tbl`\nWe don't need to collect `y` and `z`.\n\nThis was previously done implicitly to some degree with the fetch\noptimization, but it didn't work in all cases.\n\nThis adds a new `pruneOutputsExcept` that can be triggered on a root\nnode and propagates through the whole tree to remove any unused outputs.\n\nThis is not done as an optimization rule. Optimizations rule are ideal\nwhen an optimization decisicion can be done in isolation looking at a\nsmall sub-tree. But in the case of column pruning it is necessary to\nbuild a lot of context.\n\nFor example in:\n\n```\n  Limit\n    \u2514 Collect\n```\n\nThe `Limit` operator itself doesn't know which outputs are needed\nwithout involving its parent.", "committedDate": "2020-03-06T11:00:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcxNTc5Mw==", "url": "https://github.com/crate/crate/pull/9745#discussion_r389715793", "bodyText": "Would it be possible to define a class that extends DefaultTraversalSymbolVisitor in oder to visit all symbols from window function, such as we have exactly the same login in visitWindowFunction?", "author": "kovrus", "createdAt": "2020-03-09T14:15:02Z", "path": "sql/src/main/java/io/crate/planner/operators/WindowAgg.java", "diffHunk": "@@ -102,6 +104,43 @@ private WindowAgg(LogicalPlan source, WindowDefinition windowDefinition, List<Wi\n         this.standalone = standalone;\n     }\n \n+    @Override\n+    public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n+        HashSet<Symbol> toKeep = new HashSet<>(outputsToKeep);\n+        toKeep.removeAll(windowFunctions);\n+        List<Symbol> newStandalone = List.copyOf(toKeep);\n+        for (WindowFunction windowFunction : windowFunctions) {\n+            toKeep.addAll(windowFunction.arguments());", "originalCommit": "9558237c41bf80cc8a57c360715cd8c8bf7c8b5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc1NzI4MQ==", "url": "https://github.com/crate/crate/pull/9745#discussion_r389757281", "bodyText": "I think I now see a common pattern between the different operators.  Will try to extract some common logic to contain most of the complexity", "author": "mfussenegger", "createdAt": "2020-03-09T15:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcxNTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxMjc3NA==", "url": "https://github.com/crate/crate/pull/9745#discussion_r389812774", "bodyText": "@kovrus pushed a fixup. Please let me know what you think.", "author": "mfussenegger", "createdAt": "2020-03-09T16:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcxNTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE3MTI0MA==", "url": "https://github.com/crate/crate/pull/9745#discussion_r390171240", "bodyText": "looks good \ud83d\udc4d", "author": "kovrus", "createdAt": "2020-03-10T09:01:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcxNTc5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f3cfbe376c03b8fad513da9fad51bf76b7ac01a6", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/operators/WindowAgg.java b/sql/src/main/java/io/crate/planner/operators/WindowAgg.java\nindex 4956bf7c51..406aea3741 100644\n--- a/sql/src/main/java/io/crate/planner/operators/WindowAgg.java\n+++ b/sql/src/main/java/io/crate/planner/operators/WindowAgg.java\n\n@@ -106,39 +107,22 @@ public class WindowAgg extends ForwardingLogicalPlan {\n \n     @Override\n     public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n-        HashSet<Symbol> toKeep = new HashSet<>(outputsToKeep);\n-        toKeep.removeAll(windowFunctions);\n-        List<Symbol> newStandalone = List.copyOf(toKeep);\n-        for (WindowFunction windowFunction : windowFunctions) {\n-            toKeep.addAll(windowFunction.arguments());\n-            Symbol filter = windowFunction.filter();\n-            if (filter != null) {\n-                toKeep.add(filter);\n-            }\n-            toKeep.addAll(windowFunction.windowDefinition().partitions());\n-            OrderBy orderBy = windowFunction.windowDefinition().orderBy();\n-            if (orderBy != null) {\n-                toKeep.addAll(orderBy.orderBySymbols());\n-            }\n-            Symbol startOffsetValue = windowFunction.windowDefinition().windowFrameDefinition().start().value();\n-            if (startOffsetValue != null) {\n-                toKeep.add(startOffsetValue);\n-            }\n-            Symbol endOffsetValue = windowFunction.windowDefinition().windowFrameDefinition().end().value();\n-            if (endOffsetValue != null) {\n-                toKeep.add(endOffsetValue);\n-            }\n+        HashSet<Symbol> toKeep = new HashSet<>();\n+        ArrayList<Symbol> newStandalone = new ArrayList<>();\n+        ArrayList<WindowFunction> newWindowFunctions = new ArrayList<>();\n+        for (Symbol outputToKeep : outputsToKeep) {\n+            SymbolVisitors.intersection(outputToKeep, windowFunctions, newWindowFunctions::add);\n+            SymbolVisitors.intersection(outputToKeep, standalone, newStandalone::add);\n         }\n+        for (WindowFunction newWindowFunction : newWindowFunctions) {\n+            SymbolVisitors.intersection(newWindowFunction, source.outputs(), toKeep::add);\n+        }\n+        toKeep.addAll(newStandalone);\n         LogicalPlan newSource = source.pruneOutputsExcept(toKeep);\n         if (newSource == source) {\n             return this;\n         }\n-        return new WindowAgg(\n-            newSource,\n-            windowDefinition,\n-            windowFunctions,\n-            newStandalone\n-        );\n+        return new WindowAgg(newSource, windowDefinition, List.copyOf(newWindowFunctions), List.copyOf(newStandalone));\n     }\n \n     List<WindowFunction> windowFunctions() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczNjkzMg==", "url": "https://github.com/crate/crate/pull/9745#discussion_r389736932", "bodyText": "can you elaborate a bit here? if we use a ScopedSymbol instead of a subscript function, we basically do not need the logic in the loop bellow? how can a subscript function be mapped to scoped symbol?", "author": "kovrus", "createdAt": "2020-03-09T14:45:36Z", "path": "sql/src/main/java/io/crate/planner/operators/Rename.java", "diffHunk": "@@ -80,6 +84,58 @@ public RelationName name() {\n         return outputs;\n     }\n \n+    @Override\n+    public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n+        ArrayList<Symbol> mappedToKeep = new ArrayList<>();\n+        /* outputsToKeep may be scalars on top of the Rename result or subscripts\n+         * Eval: x > 1, obj['x']\n+         *  \u2514 Rename[x, obj]\n+         *      \u2514 Collect [x, obj]\n+         *\n+         * TODO: `obj['x']` can be a ScopedSymbol instead of a subscript function. Can we change that?", "originalCommit": "9558237c41bf80cc8a57c360715cd8c8bf7c8b5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4MDYzMw==", "url": "https://github.com/crate/crate/pull/9745#discussion_r389780633", "bodyText": "Yeah the comment is a bit vague because even if it is a subscript function it will be wrapped in a ScopedSymbol. The point is more about whether the path component of the ColumnIdent is used vs. having a real Function. In the latter case the FieldsVisitor approach would be enough and the getRoot() part further below wouldn't be necessary.\nI'll adapt the comment or figure out a better solution.", "author": "mfussenegger", "createdAt": "2020-03-09T15:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczNjkzMg=="}], "type": "inlineReview", "revised_code": {"commit": "465b1929ec29732f94450be53b7f0dd7cd55c1f0", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/operators/Rename.java b/sql/src/main/java/io/crate/planner/operators/Rename.java\nindex c869a66c29..0bbd65dfe9 100644\n--- a/sql/src/main/java/io/crate/planner/operators/Rename.java\n+++ b/sql/src/main/java/io/crate/planner/operators/Rename.java\n\n@@ -86,7 +86,6 @@ public final class Rename extends ForwardingLogicalPlan implements FieldResolver\n \n     @Override\n     public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n-        ArrayList<Symbol> mappedToKeep = new ArrayList<>();\n         /* outputsToKeep may be scalars on top of the Rename result or subscripts\n          * Eval: x > 1, obj['x']\n          *  \u2514 Rename[x, obj]\n"}}, {"oid": "465b1929ec29732f94450be53b7f0dd7cd55c1f0", "url": "https://github.com/crate/crate/commit/465b1929ec29732f94450be53b7f0dd7cd55c1f0", "message": "fixup! WIP: Add column pruning", "committedDate": "2020-03-09T14:58:30Z", "type": "forcePushed"}, {"oid": "f3cfbe376c03b8fad513da9fad51bf76b7ac01a6", "url": "https://github.com/crate/crate/commit/f3cfbe376c03b8fad513da9fad51bf76b7ac01a6", "message": "fixup! fixup! WIP: Add column pruning", "committedDate": "2020-03-09T16:35:25Z", "type": "forcePushed"}, {"oid": "78f449e71a831239f027f4dc1dda4e12f488fc60", "url": "https://github.com/crate/crate/commit/78f449e71a831239f027f4dc1dda4e12f488fc60", "message": "Add column pruning for NestedLoopJoin", "committedDate": "2020-03-10T10:50:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIzNDg3Ng==", "url": "https://github.com/crate/crate/pull/9745#discussion_r390234876", "bodyText": "I'm not too happy about having to resort to identity here, but I don't really have a better idea.", "author": "mfussenegger", "createdAt": "2020-03-10T10:56:36Z", "path": "sql/src/main/java/io/crate/planner/operators/Rename.java", "diffHunk": "@@ -80,6 +84,41 @@ public RelationName name() {\n         return outputs;\n     }\n \n+    @Override\n+    public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n+        /* In `SELECT * FROM (SELECT t1.*, t2.* FROM tbl AS t1, tbl AS t2) AS tjoin`\n+         * The `ScopedSymbol`s are ambiguous; To map them correctly this uses a IdentityHashMap\n+         */\n+        IdentityHashMap<Symbol, Symbol> parentToChildMap = new IdentityHashMap<>(outputs.size());", "originalCommit": "78f449e71a831239f027f4dc1dda4e12f488fc60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5MjcwMw==", "url": "https://github.com/crate/crate/pull/9745#discussion_r390392703", "bodyText": "minor: was wondering whether it is really necessary to create an instance of IntersectionVisitor on each intersection method invocation and whether it makes sense to reuse a visitor context to pass haystack and needle (but it is probably the same coz the context has to be created..)?", "author": "kovrus", "createdAt": "2020-03-10T15:17:22Z", "path": "sql/src/main/java/io/crate/expression/symbol/SymbolVisitors.java", "diffHunk": "@@ -42,6 +48,127 @@ public static boolean any(Predicate<? super Symbol> symbolPredicate, Symbol symb\n         return symbol.accept(ANY_VISITOR, symbolPredicate);\n     }\n \n+    /**\n+     * Calls the given `consumer` for all intersection points between `needle` and `haystack`.\n+     * For example, in:\n+     * <pre>\n+     *     needle: x > 20 AND y = 2\n+     *     haystack: [x, y = 2]\n+     * </pre>\n+     *\n+     * The `consumer` would be called for `x` and for `y = 2`\n+     */\n+    public static <T> void intersection(Symbol needle, Collection<T> haystack, Consumer<T> consumer) {\n+        needle.accept(new IntersectionVisitor<>(haystack, consumer), null);", "originalCommit": "78f449e71a831239f027f4dc1dda4e12f488fc60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NDI1MQ==", "url": "https://github.com/crate/crate/pull/9745#discussion_r390394251", "bodyText": "but it is probably the same coz the context has to be created..\n\nYes, that was my reason for going for a visitor instance directly - to avoid having to introduce a context class.", "author": "mfussenegger", "createdAt": "2020-03-10T15:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5MjcwMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQxODIyMw==", "url": "https://github.com/crate/crate/pull/9745#discussion_r390418223", "bodyText": "Why is this required? Or why not at AnalyzedView?", "author": "seut", "createdAt": "2020-03-10T15:50:47Z", "path": "sql/src/main/java/io/crate/analyze/relations/AliasedAnalyzedRelation.java", "diffHunk": "@@ -101,7 +108,7 @@ public RelationName relationName() {\n     @Nonnull\n     @Override\n     public List<Symbol> outputs() {\n-        return outputs;\n+        return List.copyOf(outputs);", "originalCommit": "78f449e71a831239f027f4dc1dda4e12f488fc60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0NjA3OQ==", "url": "https://github.com/crate/crate/pull/9745#discussion_r390446079", "bodyText": "It was required for an intermediate version I had. Reverted it now.", "author": "mfussenegger", "createdAt": "2020-03-10T16:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQxODIyMw=="}], "type": "inlineReview", "revised_code": {"commit": "5a5be5d4c91a201160b15d356917af62830dd2d4", "chunk": "diff --git a/sql/src/main/java/io/crate/analyze/relations/AliasedAnalyzedRelation.java b/sql/src/main/java/io/crate/analyze/relations/AliasedAnalyzedRelation.java\nindex 687a0b395c..56d54baa51 100644\n--- a/sql/src/main/java/io/crate/analyze/relations/AliasedAnalyzedRelation.java\n+++ b/sql/src/main/java/io/crate/analyze/relations/AliasedAnalyzedRelation.java\n\n@@ -108,7 +108,7 @@ public class AliasedAnalyzedRelation implements AnalyzedRelation, FieldResolver\n     @Nonnull\n     @Override\n     public List<Symbol> outputs() {\n-        return List.copyOf(outputs);\n+        return outputs;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQyNDA5NQ==", "url": "https://github.com/crate/crate/pull/9745#discussion_r390424095", "bodyText": "maybe worth adding the \"why\"", "author": "seut", "createdAt": "2020-03-10T15:58:30Z", "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlan.java", "diffHunk": "@@ -112,6 +114,39 @@ default boolean preferShardProjections() {\n \n     LogicalPlan replaceSources(List<LogicalPlan> sources);\n \n+    /**\n+     * Request an operator to return a new version of itself with all outputs removed except the ones contained in `outputsToKeep`.\n+     * <p>\n+     *  Note that `outputsToKeep` can contain scalars on top of the outputs that the \"current\" operator outputs.\n+     *  This doesn't mean that the operator has to pull-down the scalar as well, but it means it has to provide all outputs\n+     *  that are required by the parent.\n+     *  Using {@link io.crate.expression.symbol.SymbolVisitors#intersection(Symbol, Collection, Consumer)} is an option\n+     *  To find the outputs required by the parent.\n+     * </p>\n+     *\n+     * Example:\n+     *\n+     * <pre>\n+     *     A: [substr(x, 0, 3), y]\n+     *     \u2514 B [x, y, z]              // Should provide `x` and `y` after the prune call.\n+     * </pre>\n+     *\n+     * <p>\n+     *   This must propagate down the tree:\n+     * </p>\n+     * <pre>\n+     *      root       A call to `root.pruneOutputsExcept(..)` must result in calls on all: A, B and C\n+     *       / \\\n+     *     A   C\n+     *     |\n+     *     B\n+     * </pre>\n+     * <p>\n+     *  If there are no outputs to prune and if the source also didn't change, `this` must be returned.", "originalCommit": "78f449e71a831239f027f4dc1dda4e12f488fc60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0NTgwMw==", "url": "https://github.com/crate/crate/pull/9745#discussion_r390445803", "bodyText": "Extended it to explain why", "author": "mfussenegger", "createdAt": "2020-03-10T16:28:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQyNDA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a5be5d4c91a201160b15d356917af62830dd2d4", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/operators/LogicalPlan.java b/sql/src/main/java/io/crate/planner/operators/LogicalPlan.java\nindex b757865db1..fd7c7bc410 100644\n--- a/sql/src/main/java/io/crate/planner/operators/LogicalPlan.java\n+++ b/sql/src/main/java/io/crate/planner/operators/LogicalPlan.java\n\n@@ -143,6 +143,7 @@ public interface LogicalPlan extends Plan {\n      * </pre>\n      * <p>\n      *  If there are no outputs to prune and if the source also didn't change, `this` must be returned.\n+     *  That allows implementations to do a cheap identity check to avoid LogicalPlan re-creations themselves.\n      * </p>\n      */\n     LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep);\n"}}, {"oid": "5a5be5d4c91a201160b15d356917af62830dd2d4", "url": "https://github.com/crate/crate/commit/5a5be5d4c91a201160b15d356917af62830dd2d4", "message": "Add column pruning\n\nFor cases like\n\n```\nSELECT x FROM my_view\n```\n\nWhere `my_view` resolves to `SELECT x, y, z FROM tbl`\nWe don't need to collect `y` and `z`.\n\nThis was previously done implicitly to some degree with the fetch\noptimization, but it didn't work in all cases.\n\nThis adds a new `pruneOutputsExcept` that can be triggered on a root\nnode and propagates through the whole tree to remove any unused outputs.\n\nThis is not done as an optimization rule. Optimizations rule are ideal\nwhen an optimization decisicion can be done in isolation looking at a\nsmall sub-tree. But in the case of column pruning it is necessary to\nbuild a lot of context.\n\nFor example in:\n\n```\n  Limit\n    \u2514 Collect\n```\n\nThe `Limit` operator itself doesn't know which outputs are needed\nwithout involving its parent.", "committedDate": "2020-03-10T16:28:06Z", "type": "forcePushed"}, {"oid": "4565e95084540314c2bc8f9fe3f17685882147a5", "url": "https://github.com/crate/crate/commit/4565e95084540314c2bc8f9fe3f17685882147a5", "message": "Add column pruning\n\nFor cases like\n\n```\nSELECT x FROM my_view\n```\n\nWhere `my_view` resolves to `SELECT x, y, z FROM tbl`\nWe don't need to collect `y` and `z`.\n\nThis was previously done implicitly to some degree with the fetch\noptimization, but it didn't work in all cases.\n\nThis adds a new `pruneOutputsExcept` that can be triggered on a root\nnode and propagates through the whole tree to remove any unused outputs.\n\nThis is not done as an optimization rule. Optimizations rule are ideal\nwhen an optimization decisicion can be done in isolation looking at a\nsmall sub-tree. But in the case of column pruning it is necessary to\nbuild a lot of context.\n\nFor example in:\n\n```\n  Limit\n    \u2514 Collect\n```\n\nThe `Limit` operator itself doesn't know which outputs are needed\nwithout involving its parent.", "committedDate": "2020-03-10T16:32:30Z", "type": "commit"}, {"oid": "4565e95084540314c2bc8f9fe3f17685882147a5", "url": "https://github.com/crate/crate/commit/4565e95084540314c2bc8f9fe3f17685882147a5", "message": "Add column pruning\n\nFor cases like\n\n```\nSELECT x FROM my_view\n```\n\nWhere `my_view` resolves to `SELECT x, y, z FROM tbl`\nWe don't need to collect `y` and `z`.\n\nThis was previously done implicitly to some degree with the fetch\noptimization, but it didn't work in all cases.\n\nThis adds a new `pruneOutputsExcept` that can be triggered on a root\nnode and propagates through the whole tree to remove any unused outputs.\n\nThis is not done as an optimization rule. Optimizations rule are ideal\nwhen an optimization decisicion can be done in isolation looking at a\nsmall sub-tree. But in the case of column pruning it is necessary to\nbuild a lot of context.\n\nFor example in:\n\n```\n  Limit\n    \u2514 Collect\n```\n\nThe `Limit` operator itself doesn't know which outputs are needed\nwithout involving its parent.", "committedDate": "2020-03-10T16:32:30Z", "type": "forcePushed"}]}