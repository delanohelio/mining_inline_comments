{"pr_number": 9646, "pr_title": "Add the ``trunc`` scalar function", "pr_createdAt": "2020-02-11T10:40:17Z", "pr_url": "https://github.com/crate/crate/pull/9646", "timeline": [{"oid": "fdb5dba316ecbaa6fe93fed45a1ed0048423175d", "url": "https://github.com/crate/crate/commit/fdb5dba316ecbaa6fe93fed45a1ed0048423175d", "message": "Fixup", "committedDate": "2020-02-11T10:56:41Z", "type": "forcePushed"}, {"oid": "a781eeac7100685a108f3f57d4fc129f7b35d9c9", "url": "https://github.com/crate/crate/commit/a781eeac7100685a108f3f57d4fc129f7b35d9c9", "message": "Fixup", "committedDate": "2020-02-11T14:35:11Z", "type": "forcePushed"}, {"oid": "925f98aa1922d23808c2166294ab8945ea0ea786", "url": "https://github.com/crate/crate/commit/925f98aa1922d23808c2166294ab8945ea0ea786", "message": "Fixup", "committedDate": "2020-02-11T14:35:57Z", "type": "forcePushed"}, {"oid": "6a99db2a2567d0b0cd3367a81118e5bf139b8d40", "url": "https://github.com/crate/crate/commit/6a99db2a2567d0b0cd3367a81118e5bf139b8d40", "message": "Fix tests now that the return type is not directly BigDecimal", "committedDate": "2020-02-11T15:33:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExNDUzMQ==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378114531", "bodyText": "Using floor like that wouldn't return the correct values for negative numbers:\nselect trunc(-29.99);\n\nexpected:  -29\ngot:       -30", "author": "seut", "createdAt": "2020-02-12T08:59:15Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.UnaryScalar;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";\n+                DataType argType = types.get(0);\n+                DataType returnType = DataTypes.getIntegralReturnType(argType);\n+                return 1 == argsLen ?\n+                    new OneParamTrunc(argType, returnType) : new TwoParamTrunc(argType, returnType);\n+            }\n+        });\n+    }\n+\n+\n+    private static class OneParamTrunc extends UnaryScalar<Number, Number> {\n+\n+        OneParamTrunc(DataType argType, DataType returnType) {\n+            super(NAME, argType, returnType, n -> evaluate(n, returnType));\n+        }\n+\n+        static Number evaluate(Object n, DataType returnType) {\n+            return (Number) returnType.value(Math.floor(((Number) n).doubleValue()));", "originalCommit": "96c058f04bfd449a02c326bf3db9f51a07692c26", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e23661f58619ab3133c8d709ee19d908af18533d", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\nindex 9a9dd5a999..b4a7dfe2db 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n\n@@ -23,7 +23,6 @@ package io.crate.expression.scalar.arithmetic;\n \n import io.crate.data.Input;\n import io.crate.expression.scalar.ScalarFunctionModule;\n-import io.crate.expression.scalar.UnaryScalar;\n import io.crate.expression.symbol.FuncArg;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionImplementation;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExNTA5NQ==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378115095", "bodyText": "Same floor issue with negative numbers as described before.", "author": "seut", "createdAt": "2020-02-12T09:00:22Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.UnaryScalar;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";\n+                DataType argType = types.get(0);\n+                DataType returnType = DataTypes.getIntegralReturnType(argType);\n+                return 1 == argsLen ?\n+                    new OneParamTrunc(argType, returnType) : new TwoParamTrunc(argType, returnType);\n+            }\n+        });\n+    }\n+\n+\n+    private static class OneParamTrunc extends UnaryScalar<Number, Number> {\n+\n+        OneParamTrunc(DataType argType, DataType returnType) {\n+            super(NAME, argType, returnType, n -> evaluate(n, returnType));\n+        }\n+\n+        static Number evaluate(Object n, DataType returnType) {\n+            return (Number) returnType.value(Math.floor(((Number) n).doubleValue()));\n+        }\n+    }\n+\n+    private static class TwoParamTrunc extends Scalar<Number, Number> {\n+\n+        private final FunctionInfo info;\n+        private final DataType returnType;\n+\n+        TwoParamTrunc(DataType argType, DataType returnType) {\n+            info = new FunctionInfo(new FunctionIdent(\n+                NAME, List.of(argType, DataTypes.INTEGER)), DataTypes.DOUBLE);\n+            this.returnType = returnType;\n+        }\n+\n+        @Override\n+        public FunctionInfo info() {\n+            return info;\n+        }\n+\n+        @Override\n+        public Number evaluate(TransactionContext txnCtx, Input<Number>... args) {\n+            Number n = args[0].value();\n+            int numDecimals = args[1].value().intValue();\n+            if (0 == numDecimals) {\n+                return OneParamTrunc.evaluate(n, returnType);\n+            } else {\n+                return BigDecimal.valueOf(n.doubleValue()).setScale(numDecimals, RoundingMode.FLOOR).doubleValue();", "originalCommit": "96c058f04bfd449a02c326bf3db9f51a07692c26", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e23661f58619ab3133c8d709ee19d908af18533d", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\nindex 9a9dd5a999..b4a7dfe2db 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n\n@@ -23,7 +23,6 @@ package io.crate.expression.scalar.arithmetic;\n \n import io.crate.data.Input;\n import io.crate.expression.scalar.ScalarFunctionModule;\n-import io.crate.expression.scalar.UnaryScalar;\n import io.crate.expression.symbol.FuncArg;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionImplementation;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExNjA4Ng==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378116086", "bodyText": "not sure if we really need this additional integration tests, I think the scalar unit tests are enough. Or do I miss some by unit tests not covered scenarios?", "author": "seut", "createdAt": "2020-02-12T09:02:11Z", "path": "sql/src/test/java/io/crate/integrationtests/ArithmeticIntegrationTest.java", "diffHunk": "@@ -70,6 +72,14 @@ public void testSelectWhereArithmeticScalar() throws Exception {\n         assertThat(response.rowCount(), is(1L));\n         assertThat((Long) response.rows()[0][0], is(2L));\n \n+        execute(\"select trunc(d) from t where trunc(d, 1) = 2.2\");\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat((Long) response.rows()[0][0], is(2L));\n+\n+        execute(\"select trunc(d) from t where trunc(d, 2) = 29.19\");", "originalCommit": "96c058f04bfd449a02c326bf3db9f51a07692c26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExOTE4Mw==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378119183", "bodyText": "I agree, the unit tests should cover all scenarios.", "author": "marregui", "createdAt": "2020-02-12T09:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExNjA4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e23661f58619ab3133c8d709ee19d908af18533d", "chunk": "diff --git a/sql/src/test/java/io/crate/integrationtests/ArithmeticIntegrationTest.java b/sql/src/test/java/io/crate/integrationtests/ArithmeticIntegrationTest.java\nindex 8983ef2b59..ff5064f92e 100644\n--- a/sql/src/test/java/io/crate/integrationtests/ArithmeticIntegrationTest.java\n+++ b/sql/src/test/java/io/crate/integrationtests/ArithmeticIntegrationTest.java\n\n@@ -72,14 +70,6 @@ public class ArithmeticIntegrationTest extends SQLTransportIntegrationTest {\n         assertThat(response.rowCount(), is(1L));\n         assertThat((Long) response.rows()[0][0], is(2L));\n \n-        execute(\"select trunc(d) from t where trunc(d, 1) = 2.2\");\n-        assertThat(response.rowCount(), is(1L));\n-        assertThat((Long) response.rows()[0][0], is(2L));\n-\n-        execute(\"select trunc(d) from t where trunc(d, 2) = 29.19\");\n-        assertThat(response.rowCount(), is(1L));\n-        assertThat((Long) response.rows()[0][0], is(29L));\n-\n         execute(\"insert into t (d, i) values (?, ?)\", new Object[]{-0.2, 10});\n         execute(\"refresh table t\");\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExNjk0OA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378116948", "bodyText": "Is this worth having 2 implementations? Maybe we can just use 1 with a default val of 0.", "author": "seut", "createdAt": "2020-02-12T09:03:47Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.UnaryScalar;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";\n+                DataType argType = types.get(0);\n+                DataType returnType = DataTypes.getIntegralReturnType(argType);\n+                return 1 == argsLen ?\n+                    new OneParamTrunc(argType, returnType) : new TwoParamTrunc(argType, returnType);", "originalCommit": "96c058f04bfd449a02c326bf3db9f51a07692c26", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e23661f58619ab3133c8d709ee19d908af18533d", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\nindex 9a9dd5a999..b4a7dfe2db 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n\n@@ -23,7 +23,6 @@ package io.crate.expression.scalar.arithmetic;\n \n import io.crate.data.Input;\n import io.crate.expression.scalar.ScalarFunctionModule;\n-import io.crate.expression.scalar.UnaryScalar;\n import io.crate.expression.symbol.FuncArg;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionImplementation;\n"}}, {"oid": "e23661f58619ab3133c8d709ee19d908af18533d", "url": "https://github.com/crate/crate/commit/e23661f58619ab3133c8d709ee19d908af18533d", "message": "Add test for trunc'ing negatives", "committedDate": "2020-02-12T09:54:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE3OTEzMA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378179130", "bodyText": "all input args must be checked for NULL values, otherwise this results in an NPE.", "author": "seut", "createdAt": "2020-02-12T10:58:22Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";\n+                DataType argType = types.get(0);\n+                DataType returnTypeSingleArg = DataTypes.getIntegralReturnType(argType);\n+                FunctionInfo info;\n+                if (1 == argsLen) {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType)),\n+                        returnTypeSingleArg);\n+                } else {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType, DataTypes.INTEGER)),\n+                        DataTypes.DOUBLE);\n+                }\n+                return new Scalar<Number, Number>() {\n+\n+                    @Override\n+                    public FunctionInfo info() {\n+                        return info;\n+                    }\n+\n+                    @Override\n+                    public Number evaluate(TransactionContext txnCtx, Input<Number>... args) {\n+                        Number n = args[0].value();\n+                        int numDecimals = args.length > 1 ? args[1].value().intValue() : 0;\n+                        double val = n.doubleValue();", "originalCommit": "e23661f58619ab3133c8d709ee19d908af18533d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a39228042bcfd455e54cb294c91895a1b850804", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\nindex b4a7dfe2db..c6320c35bc 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n\n@@ -84,11 +84,22 @@ public final class TruncFunction {\n                     @Override\n                     public Number evaluate(TransactionContext txnCtx, Input<Number>... args) {\n                         Number n = args[0].value();\n-                        int numDecimals = args.length > 1 ? args[1].value().intValue() : 0;\n+                        if (null == n) {\n+                            return null;\n+                        }\n+                        int numDecimals = 0;\n+                        if (args.length > 1) {\n+                            Number nd = args[1].value();\n+                            if (null == nd) {\n+                                return null;\n+                            }\n+                            numDecimals = nd.intValue();\n+                        }\n                         double val = n.doubleValue();\n                         if (0 == numDecimals) {\n                             Function<Double, Double> f = val >= 0 ? Math::floor : Math::ceil;\n-                            return (Number) returnTypeSingleArg.value(f.apply(val));\n+                            Number result = ((Number) returnTypeSingleArg.value(f.apply(val)));\n+                            return args.length > 1 ? result.doubleValue() : result;\n                         } else {\n                             RoundingMode mode = val >= 0 ? RoundingMode.FLOOR : RoundingMode.CEILING;\n                             return BigDecimal.valueOf(val).setScale(numDecimals, mode).doubleValue();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE3OTQ4MQ==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378179481", "bodyText": "this should result in  isLiteral(29L).\nin general, normalizing using literals should always result in a literal, pls fix all normalize tests here please.", "author": "seut", "createdAt": "2020-02-12T10:58:59Z", "path": "sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+import static io.crate.testing.SymbolMatchers.isFunction;\n+import static io.crate.testing.SymbolMatchers.isLiteral;\n+\n+public class TruncFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test\n+    public void testNormalizeOnDouble() throws Exception {\n+        assertNormalize(\"trunc(29.1947)\", isLiteral(29L));\n+        assertNormalize(\"trunc(-29.1947)\", isLiteral(-29L));\n+        assertNormalize(\"trunc(29.1947, 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.DOUBLE, DataTypes.INTEGER)));", "originalCommit": "e23661f58619ab3133c8d709ee19d908af18533d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a39228042bcfd455e54cb294c91895a1b850804", "chunk": "diff --git a/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java b/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java\nindex fab77b5e72..a230636836 100644\n--- a/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java\n+++ b/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java\n\n@@ -39,26 +39,31 @@ public class TruncFunctionTest extends AbstractScalarFunctionsTest {\n     public void testNormalizeOnDouble() throws Exception {\n         assertNormalize(\"trunc(29.1947)\", isLiteral(29L));\n         assertNormalize(\"trunc(-29.1947)\", isLiteral(-29L));\n-        assertNormalize(\"trunc(29.1947, 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.DOUBLE, DataTypes.INTEGER)));\n-        assertNormalize(\"trunc(cast(null as double))\", isFunction(TruncFunction.NAME, List.of(DataTypes.DOUBLE)));\n+        assertNormalize(\"trunc(29.1947, 0)\", isLiteral(29.0d));\n+        assertNormalize(\"trunc(-29.1947, 0)\", isLiteral(-29.0d));\n+        assertNormalize(\"trunc(29.1947, 1)\", isLiteral(29.1d));\n+        assertNormalize(\"trunc(cast(null as double))\", isLiteral(null,  DataTypes.LONG));\n     }\n \n     @Test\n     public void testNormalizeOnFloat() throws Exception {\n         assertNormalize(\"trunc(cast(29.1947 as float))\", isLiteral(29));\n-        assertNormalize(\"trunc(cast(29.1947 as float), 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.FLOAT, DataTypes.INTEGER)));\n-        assertNormalize(\"trunc(cast(null as float))\", isFunction(TruncFunction.NAME, List.of(DataTypes.FLOAT)));\n+        assertNormalize(\"trunc(cast(29.1947 as float), 0)\", isLiteral(29.0d));\n+        assertNormalize(\"trunc(cast(29.1947 as float), 1)\", isLiteral(29.1d));\n+        assertNormalize(\"trunc(cast(null as float))\", isLiteral(null));\n     }\n \n     @Test\n     public void testNormalizeOnIntAndLong() throws Exception {\n         assertNormalize(\"trunc(cast(20 as integer))\", isLiteral(20));\n-        assertNormalize(\"trunc(cast(20 as integer), 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.INTEGER, DataTypes.INTEGER)));\n-        assertNormalize(\"trunc(cast(null as integer))\", isFunction(TruncFunction.NAME, List.of(DataTypes.INTEGER)));\n+        assertNormalize(\"trunc(cast(20 as integer), 0)\", isLiteral(20.0d));\n+        assertNormalize(\"trunc(cast(20 as integer), 1)\", isLiteral(20.0d));\n+        assertNormalize(\"trunc(cast(null as integer))\", isLiteral(null));\n \n         assertNormalize(\"trunc(cast(20 as bigint))\", isLiteral(20L));\n-        assertNormalize(\"trunc(cast(20 as bigint), 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.LONG, DataTypes.INTEGER)));\n-        assertNormalize(\"trunc(cast(null as bigint))\", isFunction(TruncFunction.NAME, List.of(DataTypes.LONG)));\n+        assertNormalize(\"trunc(cast(20 as bigint), 0)\", isLiteral(20.0d));\n+        assertNormalize(\"trunc(cast(20 as bigint), 1)\", isLiteral(20.0d));\n+        assertNormalize(\"trunc(cast(null as bigint))\", isLiteral(null));\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE3OTY4Ng==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378179686", "bodyText": "should result in isLiteral(null, DataTypes.LONG)", "author": "seut", "createdAt": "2020-02-12T10:59:24Z", "path": "sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+import static io.crate.testing.SymbolMatchers.isFunction;\n+import static io.crate.testing.SymbolMatchers.isLiteral;\n+\n+public class TruncFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test\n+    public void testNormalizeOnDouble() throws Exception {\n+        assertNormalize(\"trunc(29.1947)\", isLiteral(29L));\n+        assertNormalize(\"trunc(-29.1947)\", isLiteral(-29L));\n+        assertNormalize(\"trunc(29.1947, 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.DOUBLE, DataTypes.INTEGER)));\n+        assertNormalize(\"trunc(cast(null as double))\", isFunction(TruncFunction.NAME, List.of(DataTypes.DOUBLE)));", "originalCommit": "e23661f58619ab3133c8d709ee19d908af18533d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a39228042bcfd455e54cb294c91895a1b850804", "chunk": "diff --git a/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java b/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java\nindex fab77b5e72..a230636836 100644\n--- a/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java\n+++ b/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java\n\n@@ -39,26 +39,31 @@ public class TruncFunctionTest extends AbstractScalarFunctionsTest {\n     public void testNormalizeOnDouble() throws Exception {\n         assertNormalize(\"trunc(29.1947)\", isLiteral(29L));\n         assertNormalize(\"trunc(-29.1947)\", isLiteral(-29L));\n-        assertNormalize(\"trunc(29.1947, 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.DOUBLE, DataTypes.INTEGER)));\n-        assertNormalize(\"trunc(cast(null as double))\", isFunction(TruncFunction.NAME, List.of(DataTypes.DOUBLE)));\n+        assertNormalize(\"trunc(29.1947, 0)\", isLiteral(29.0d));\n+        assertNormalize(\"trunc(-29.1947, 0)\", isLiteral(-29.0d));\n+        assertNormalize(\"trunc(29.1947, 1)\", isLiteral(29.1d));\n+        assertNormalize(\"trunc(cast(null as double))\", isLiteral(null,  DataTypes.LONG));\n     }\n \n     @Test\n     public void testNormalizeOnFloat() throws Exception {\n         assertNormalize(\"trunc(cast(29.1947 as float))\", isLiteral(29));\n-        assertNormalize(\"trunc(cast(29.1947 as float), 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.FLOAT, DataTypes.INTEGER)));\n-        assertNormalize(\"trunc(cast(null as float))\", isFunction(TruncFunction.NAME, List.of(DataTypes.FLOAT)));\n+        assertNormalize(\"trunc(cast(29.1947 as float), 0)\", isLiteral(29.0d));\n+        assertNormalize(\"trunc(cast(29.1947 as float), 1)\", isLiteral(29.1d));\n+        assertNormalize(\"trunc(cast(null as float))\", isLiteral(null));\n     }\n \n     @Test\n     public void testNormalizeOnIntAndLong() throws Exception {\n         assertNormalize(\"trunc(cast(20 as integer))\", isLiteral(20));\n-        assertNormalize(\"trunc(cast(20 as integer), 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.INTEGER, DataTypes.INTEGER)));\n-        assertNormalize(\"trunc(cast(null as integer))\", isFunction(TruncFunction.NAME, List.of(DataTypes.INTEGER)));\n+        assertNormalize(\"trunc(cast(20 as integer), 0)\", isLiteral(20.0d));\n+        assertNormalize(\"trunc(cast(20 as integer), 1)\", isLiteral(20.0d));\n+        assertNormalize(\"trunc(cast(null as integer))\", isLiteral(null));\n \n         assertNormalize(\"trunc(cast(20 as bigint))\", isLiteral(20L));\n-        assertNormalize(\"trunc(cast(20 as bigint), 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.LONG, DataTypes.INTEGER)));\n-        assertNormalize(\"trunc(cast(null as bigint))\", isFunction(TruncFunction.NAME, List.of(DataTypes.LONG)));\n+        assertNormalize(\"trunc(cast(20 as bigint), 0)\", isLiteral(20.0d));\n+        assertNormalize(\"trunc(cast(20 as bigint), 1)\", isLiteral(20.0d));\n+        assertNormalize(\"trunc(cast(null as bigint))\", isLiteral(null));\n     }\n \n     @Test\n"}}, {"oid": "5a39228042bcfd455e54cb294c91895a1b850804", "url": "https://github.com/crate/crate/commit/5a39228042bcfd455e54cb294c91895a1b850804", "message": "Result should be literal", "committedDate": "2020-02-12T13:01:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNDYyMg==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378334622", "bodyText": "don't we want to treat trunc(number, 0) the same as trunc(number)?  At least pgsql behaves like this..", "author": "seut", "createdAt": "2020-02-12T15:43:37Z", "path": "sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+import static io.crate.testing.SymbolMatchers.isFunction;\n+import static io.crate.testing.SymbolMatchers.isLiteral;\n+\n+public class TruncFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test\n+    public void testNormalizeOnDouble() throws Exception {\n+        assertNormalize(\"trunc(29.1947)\", isLiteral(29L));\n+        assertNormalize(\"trunc(-29.1947)\", isLiteral(-29L));\n+        assertNormalize(\"trunc(29.1947, 0)\", isLiteral(29.0d));", "originalCommit": "5a39228042bcfd455e54cb294c91895a1b850804", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "057d3da6b0de3c51de6cec9fce2f9766c73601ee", "chunk": "diff --git a/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java b/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java\nindex a230636836..3500d40e51 100644\n--- a/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java\n+++ b/sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java\n\n@@ -23,11 +23,9 @@ package io.crate.expression.scalar.arithmetic;\n \n import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n import io.crate.expression.symbol.Literal;\n-import io.crate.types.DataType;\n import io.crate.types.DataTypes;\n import org.junit.Test;\n \n-import java.math.BigDecimal;\n import java.util.List;\n \n import static io.crate.testing.SymbolMatchers.isFunction;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0MzAxOQ==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378343019", "bodyText": "You can use BaseFunctionResolver.", "author": "kovrus", "createdAt": "2020-02-12T15:55:58Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {", "originalCommit": "5a39228042bcfd455e54cb294c91895a1b850804", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0OTUzOA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378349538", "bodyText": "thank you for that", "author": "marregui", "createdAt": "2020-02-12T16:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0MzAxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "a909d1f123d83dfd3b3631d2bf5e63e95a2da263", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\nindex c6320c35bc..f296a0f820 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n\n@@ -23,11 +23,10 @@ package io.crate.expression.scalar.arithmetic;\n \n import io.crate.data.Input;\n import io.crate.expression.scalar.ScalarFunctionModule;\n-import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.BaseFunctionResolver;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionImplementation;\n import io.crate.metadata.FunctionInfo;\n-import io.crate.metadata.FunctionResolver;\n import io.crate.metadata.Scalar;\n import io.crate.metadata.TransactionContext;\n import io.crate.metadata.functions.params.FuncParams;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0NDE5NA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378344194", "bodyText": "why do we need to assert it here, FunctionResolver#getSignature does it already.", "author": "kovrus", "createdAt": "2020-02-12T15:57:33Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";", "originalCommit": "5a39228042bcfd455e54cb294c91895a1b850804", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a909d1f123d83dfd3b3631d2bf5e63e95a2da263", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\nindex c6320c35bc..f296a0f820 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n\n@@ -23,11 +23,10 @@ package io.crate.expression.scalar.arithmetic;\n \n import io.crate.data.Input;\n import io.crate.expression.scalar.ScalarFunctionModule;\n-import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.BaseFunctionResolver;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionImplementation;\n import io.crate.metadata.FunctionInfo;\n-import io.crate.metadata.FunctionResolver;\n import io.crate.metadata.Scalar;\n import io.crate.metadata.TransactionContext;\n import io.crate.metadata.functions.params.FuncParams;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0Njk5NA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378346994", "bodyText": "would it be simpler to replace it with UnaryScalar and BinaryScalar, so we can delegate null checks and inputs materialization to those classes.", "author": "kovrus", "createdAt": "2020-02-12T16:01:32Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";\n+                DataType argType = types.get(0);\n+                DataType returnTypeSingleArg = DataTypes.getIntegralReturnType(argType);\n+                FunctionInfo info;\n+                if (1 == argsLen) {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType)),\n+                        returnTypeSingleArg);\n+                } else {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType, DataTypes.INTEGER)),\n+                        DataTypes.DOUBLE);\n+                }\n+                return new Scalar<Number, Number>() {", "originalCommit": "5a39228042bcfd455e54cb294c91895a1b850804", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM1MzkxNA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378353914", "bodyText": "thought of that, but then\npublic BinaryScalar(BinaryOperator<T> func, String name, DataType<T> type, Set<FunctionInfo.Feature> feature) {\n        this.func = func;\n        this.info = new FunctionInfo(new FunctionIdent(name, Arrays.asList(type, type)), type, FunctionInfo.Type.SCALAR, feature);\n        this.type = type;\n    }\n\nI need to fine tune the info.", "author": "marregui", "createdAt": "2020-02-12T16:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0Njk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM1ODI4OA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378358288", "bodyText": "we can add a new ctor like:\nBinaryScalar(BinaryOperator<T> func, String name, List<DataType<T>> argTypes, DataType<T> returnType)\n\nbut maybe too much for this PR", "author": "kovrus", "createdAt": "2020-02-12T16:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0Njk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM3NDk0MQ==", "url": "https://github.com/crate/crate/pull/9646#discussion_r379374941", "bodyText": "I think, I'd prefer to use a dedicated UnaryScalar for the 1 argument case, with 2 args we could always use the BigDecimal.valueOf(val).setScale(numDecimals, mode).doubleValue() logic, even with precision 0 it should work as defined.\nI'd use the concrete scalar impl only for the 2 args case. Adjusting the BinaryScalar to support different argtypes and return types violates a bit its semantic imho.", "author": "seut", "createdAt": "2020-02-14T11:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0Njk5NA=="}], "type": "inlineReview", "revised_code": {"commit": "a909d1f123d83dfd3b3631d2bf5e63e95a2da263", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\nindex c6320c35bc..f296a0f820 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n\n@@ -23,11 +23,10 @@ package io.crate.expression.scalar.arithmetic;\n \n import io.crate.data.Input;\n import io.crate.expression.scalar.ScalarFunctionModule;\n-import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.BaseFunctionResolver;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionImplementation;\n import io.crate.metadata.FunctionInfo;\n-import io.crate.metadata.FunctionResolver;\n import io.crate.metadata.Scalar;\n import io.crate.metadata.TransactionContext;\n import io.crate.metadata.functions.params.FuncParams;\n"}}, {"oid": "a909d1f123d83dfd3b3631d2bf5e63e95a2da263", "url": "https://github.com/crate/crate/commit/a909d1f123d83dfd3b3631d2bf5e63e95a2da263", "message": "Reference simplification/improvements", "committedDate": "2020-02-14T10:46:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM3MjYyNg==", "url": "https://github.com/crate/crate/pull/9646#discussion_r379372626", "bodyText": "This could be a bit simplified (2nd arg is already ensured to be an INTEGER by the SIGNATURE):\nDataType returnType = types.size() == 1 ? DataTypes.getIntegralReturnType(argType) : DataTypes.DOUBLE;\nFunctionInfo info = new FunctionInfo(new FunctionIdent(NAME, types), returnType);", "author": "seut", "createdAt": "2020-02-14T11:03:20Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.metadata.BaseFunctionResolver;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new BaseFunctionResolver(SIGNATURE) {\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                DataType argType = types.get(0);\n+                DataType returnTypeSingleArg = DataTypes.getIntegralReturnType(argType);\n+                FunctionInfo info;\n+                if (1 == argsLen) {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType)),\n+                        returnTypeSingleArg);\n+                } else {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType, DataTypes.INTEGER)),\n+                        DataTypes.DOUBLE);\n+                }", "originalCommit": "a909d1f123d83dfd3b3631d2bf5e63e95a2da263", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a29b75425577b37252f8a3a203cfadc941f5a760", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\nindex f296a0f820..1ce27d0629 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n\n@@ -54,19 +54,10 @@ public final class TruncFunction {\n \n             @Override\n             public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n-                int argsLen = types.size();\n                 DataType argType = types.get(0);\n                 DataType returnTypeSingleArg = DataTypes.getIntegralReturnType(argType);\n-                FunctionInfo info;\n-                if (1 == argsLen) {\n-                    info = new FunctionInfo(\n-                        new FunctionIdent(NAME, List.of(argType)),\n-                        returnTypeSingleArg);\n-                } else {\n-                    info = new FunctionInfo(\n-                        new FunctionIdent(NAME, List.of(argType, DataTypes.INTEGER)),\n-                        DataTypes.DOUBLE);\n-                }\n+                DataType returnType = 1 == types.size() ? returnTypeSingleArg : DataTypes.DOUBLE;\n+                FunctionInfo info = new FunctionInfo(new FunctionIdent(NAME, types), returnType);\n                 return new Scalar<Number, Number>() {\n \n                     @Override\n"}}, {"oid": "a29b75425577b37252f8a3a203cfadc941f5a760", "url": "https://github.com/crate/crate/commit/a29b75425577b37252f8a3a203cfadc941f5a760", "message": "Simplify info construction", "committedDate": "2020-02-14T14:54:14Z", "type": "forcePushed"}, {"oid": "057d3da6b0de3c51de6cec9fce2f9766c73601ee", "url": "https://github.com/crate/crate/commit/057d3da6b0de3c51de6cec9fce2f9766c73601ee", "message": "Add Basti's suggestion of having a UnaryScalar and a Scalar\n\nfor the two different implementations.", "committedDate": "2020-02-17T10:03:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEyMjY3Mw==", "url": "https://github.com/crate/crate/pull/9646#discussion_r380122673", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        NAME, List.of(argType, DataTypes.INTEGER)), DataTypes.DOUBLE);\n          \n          \n            \n                                        NAME, types), DataTypes.DOUBLE);", "author": "seut", "createdAt": "2020-02-17T11:14:39Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.UnaryScalar;\n+import io.crate.metadata.BaseFunctionResolver;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new BaseFunctionResolver(SIGNATURE) {\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                DataType argType = types.get(0);\n+                DataType returnType = DataTypes.getIntegralReturnType(argType);\n+                return 1 == types.size() ?\n+                    new UnaryScalar<Number, Number>(NAME, argType, returnType, n -> {\n+                        double val = n.doubleValue();\n+                        Function<Double, Double> f = val >= 0 ? Math::floor : Math::ceil;\n+                        return (Number) returnType.value(f.apply(val));\n+                    })\n+                    :\n+                    new Scalar<Number, Number>() {\n+\n+                        FunctionInfo info = new FunctionInfo(new FunctionIdent(\n+                            NAME, List.of(argType, DataTypes.INTEGER)), DataTypes.DOUBLE);", "originalCommit": "057d3da6b0de3c51de6cec9fce2f9766c73601ee", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1500b2a40db5f18b0632c48eb2deb23fdb330307", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\nindex 2f39fafff9..1e01b2a1d6 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n\n@@ -67,7 +67,7 @@ public final class TruncFunction {\n                     new Scalar<Number, Number>() {\n \n                         FunctionInfo info = new FunctionInfo(new FunctionIdent(\n-                            NAME, List.of(argType, DataTypes.INTEGER)), DataTypes.DOUBLE);\n+                            NAME, types), DataTypes.DOUBLE);\n \n                         @Override\n                         public FunctionInfo info() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEyMjk2MA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r380122960", "bodyText": "I'd prefer if/else for readability.", "author": "seut", "createdAt": "2020-02-17T11:15:17Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.UnaryScalar;\n+import io.crate.metadata.BaseFunctionResolver;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new BaseFunctionResolver(SIGNATURE) {\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                DataType argType = types.get(0);\n+                DataType returnType = DataTypes.getIntegralReturnType(argType);\n+                return 1 == types.size() ?\n+                    new UnaryScalar<Number, Number>(NAME, argType, returnType, n -> {\n+                        double val = n.doubleValue();\n+                        Function<Double, Double> f = val >= 0 ? Math::floor : Math::ceil;\n+                        return (Number) returnType.value(f.apply(val));\n+                    })\n+                    :", "originalCommit": "057d3da6b0de3c51de6cec9fce2f9766c73601ee", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1500b2a40db5f18b0632c48eb2deb23fdb330307", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\nindex 2f39fafff9..1e01b2a1d6 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java\n\n@@ -67,7 +67,7 @@ public final class TruncFunction {\n                     new Scalar<Number, Number>() {\n \n                         FunctionInfo info = new FunctionInfo(new FunctionIdent(\n-                            NAME, List.of(argType, DataTypes.INTEGER)), DataTypes.DOUBLE);\n+                            NAME, types), DataTypes.DOUBLE);\n \n                         @Override\n                         public FunctionInfo info() {\n"}}, {"oid": "3e7c51cd96858799530566f9777bb4c7566a7f1f", "url": "https://github.com/crate/crate/commit/3e7c51cd96858799530566f9777bb4c7566a7f1f", "message": "Add the ``trunc`` scalar function", "committedDate": "2020-02-17T12:02:49Z", "type": "forcePushed"}, {"oid": "1500b2a40db5f18b0632c48eb2deb23fdb330307", "url": "https://github.com/crate/crate/commit/1500b2a40db5f18b0632c48eb2deb23fdb330307", "message": "Add the ``trunc`` scalar function", "committedDate": "2020-02-17T12:05:39Z", "type": "forcePushed"}, {"oid": "73c3d0ca2541a6294e15bde15861ec7722cccfac", "url": "https://github.com/crate/crate/commit/73c3d0ca2541a6294e15bde15861ec7722cccfac", "message": "Add the ``trunc`` scalar function", "committedDate": "2020-02-17T12:07:47Z", "type": "commit"}, {"oid": "73c3d0ca2541a6294e15bde15861ec7722cccfac", "url": "https://github.com/crate/crate/commit/73c3d0ca2541a6294e15bde15861ec7722cccfac", "message": "Add the ``trunc`` scalar function", "committedDate": "2020-02-17T12:07:47Z", "type": "forcePushed"}]}