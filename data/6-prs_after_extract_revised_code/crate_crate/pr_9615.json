{"pr_number": 9615, "pr_title": "Returning clause for insert", "pr_createdAt": "2020-01-31T12:29:00Z", "pr_url": "https://github.com/crate/crate/pull/9615", "timeline": [{"oid": "2c4e3f8840a877b34ff10c9e5d00faca32d96d1c", "url": "https://github.com/crate/crate/commit/2c4e3f8840a877b34ff10c9e5d00faca32d96d1c", "message": "Add documentation for returning clause for insert", "committedDate": "2020-01-31T15:04:32Z", "type": "forcePushed"}, {"oid": "a705c47cf3fe21d9b796ab94297fc1ba71da3c35", "url": "https://github.com/crate/crate/commit/a705c47cf3fe21d9b796ab94297fc1ba71da3c35", "message": "Add returning clause for insert to storage engine", "committedDate": "2020-02-12T13:27:02Z", "type": "forcePushed"}, {"oid": "aaac781f921142fc6fe6a2fa60b28379b5b6db98", "url": "https://github.com/crate/crate/commit/aaac781f921142fc6fe6a2fa60b28379b5b6db98", "message": "Add returning clause for insert to storage engine", "committedDate": "2020-02-12T13:37:53Z", "type": "forcePushed"}, {"oid": "108071f87108760beec4976bd2883282e29b108b", "url": "https://github.com/crate/crate/commit/108071f87108760beec4976bd2883282e29b108b", "message": "Add returning clause for insert to storage engine", "committedDate": "2020-02-12T14:04:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxMjg1Nw==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378312857", "bodyText": "isn't onConflict still missing here?", "author": "seut", "createdAt": "2020-02-12T15:11:41Z", "path": "sql-parser/src/main/java/io/crate/sql/SqlFormatter.java", "diffHunk": "@@ -205,6 +206,41 @@ protected Void visitExplain(Explain node, Integer indent) {\n             return null;\n         }\n \n+        @Override\n+        public Void visitInsert(Insert<?> node, Integer indent) {\n+            append(indent, \"INSERT\");\n+            builder.append(' ');\n+            append(indent, \"INTO\");\n+            builder.append(' ');\n+            node.table().accept(this, indent);\n+            builder.append(' ');\n+            var columns = node.columns().iterator();\n+            if (columns.hasNext()) {\n+                builder.append('(');\n+                while (columns.hasNext()) {\n+                    builder.append(columns.next());\n+                    if (columns.hasNext()) {\n+                        builder.append(\", \");\n+                    }\n+                }\n+                builder.append(')');\n+            }\n+            builder.append(' ');\n+            node.insertSource().accept(this, indent);", "originalCommit": "108071f87108760beec4976bd2883282e29b108b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY5MDY1Nw==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378690657", "bodyText": "True, It is missing, although it was added in the \n  \n    \n      crate/sql-parser/src/test/java/io/crate/sql/parser/TestStatementBuilder.java\n    \n    \n         Line 1050\n      in\n      208553a\n    \n    \n    \n    \n\n        \n          \n           printStatement(\"insert into t (a, b) values (1, 2) on conflict do nothing\"); \n        \n    \n  \n\n\nbut not failing. I think the TestStatementBuilder is not testing as i would expected it. I will add it. I thought it is part of the insert source since it was passing right away.", "author": "mkleen", "createdAt": "2020-02-13T07:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxMjg1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "033eb9eae500a53b0bdef25a64215edd153cd865", "chunk": "diff --git a/sql-parser/src/main/java/io/crate/sql/SqlFormatter.java b/sql-parser/src/main/java/io/crate/sql/SqlFormatter.java\nindex 835f803b8a..f61e39c228 100644\n--- a/sql-parser/src/main/java/io/crate/sql/SqlFormatter.java\n+++ b/sql-parser/src/main/java/io/crate/sql/SqlFormatter.java\n\n@@ -227,6 +228,42 @@ public final class SqlFormatter {\n             }\n             builder.append(' ');\n             node.insertSource().accept(this, indent);\n+            var duplicateKeyContext = node.duplicateKeyContext();\n+            if (duplicateKeyContext.getType() != NONE) {\n+                builder.append(\" ON CONFLICT\");\n+                var constraintColumns = duplicateKeyContext.getConstraintColumns().iterator();\n+                if (constraintColumns.hasNext()) {\n+                    builder.append(\" (\");\n+                    while (constraintColumns.hasNext()) {\n+                        builder.append(constraintColumns.next());\n+                        if (constraintColumns.hasNext()) {\n+                            builder.append(\", \");\n+                        }\n+                    }\n+                    builder.append(')');\n+                }\n+                switch (duplicateKeyContext.getType()) {\n+                    case ON_CONFLICT_DO_NOTHING:\n+                        builder.append(\" DO NOTHING\");\n+                        break;\n+                    case ON_CONFLICT_DO_UPDATE_SET:\n+                        builder.append(\" DO UPDATE\");\n+                        var assignments = duplicateKeyContext.getAssignments().iterator();\n+                        if (assignments.hasNext()) {\n+                            builder.append(\" SET \");\n+                            while (assignments.hasNext()) {\n+                                assignments.next().accept(this, indent);\n+                                if (assignments.hasNext()) {\n+                                    builder.append(\", \");\n+                                }\n+                            }\n+                        }\n+                        break;\n+                    case NONE:\n+                    default:\n+                }\n+            }\n+\n             var returning = node.returningClause().iterator();\n             if (returning.hasNext()) {\n                 append(indent, \"RETURNING\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNzA5Mw==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378317093", "bodyText": "Please remove Nullable annotation as it is expected to not be null by next assertion", "author": "seut", "createdAt": "2020-02-12T15:18:03Z", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {", "originalCommit": "108071f87108760beec4976bd2883282e29b108b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1NzM4MA==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378657380", "bodyText": "You are right, I had a different (wrong) understanding of what Nullable means.", "author": "mkleen", "createdAt": "2020-02-13T05:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNzA5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "033eb9eae500a53b0bdef25a64215edd153cd865", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\nindex 56adc67599..4afd5e66d0 100644\n--- a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n+++ b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n\n@@ -311,7 +311,7 @@ public class TransportShardUpsertAction extends TransportShardAction<ShardUpsert\n                                        IndexShard indexShard,\n                                        boolean isRetry,\n                                        @Nullable ReturnValueGen returnGen,\n-                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+                                       InsertSourceGen insertSourceGen) throws Exception {\n         assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n         BytesReference rawSource;\n         Map<String, Object> source = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMTcyOA==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378321728", "bodyText": "shouldn't this be indexResult.getTerm()?", "author": "seut", "createdAt": "2020-02-12T15:25:02Z", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based, so we can take directly\n+            // the rawSource\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,", "originalCommit": "108071f87108760beec4976bd2883282e29b108b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1ODA2Ng==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378658066", "bodyText": "\ud83d\udc4d", "author": "mkleen", "createdAt": "2020-02-13T05:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMTcyOA=="}], "type": "inlineReview", "revised_code": {"commit": "033eb9eae500a53b0bdef25a64215edd153cd865", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\nindex 56adc67599..4afd5e66d0 100644\n--- a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n+++ b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n\n@@ -311,7 +311,7 @@ public class TransportShardUpsertAction extends TransportShardAction<ShardUpsert\n                                        IndexShard indexShard,\n                                        boolean isRetry,\n                                        @Nullable ReturnValueGen returnGen,\n-                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+                                       InsertSourceGen insertSourceGen) throws Exception {\n         assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n         BytesReference rawSource;\n         Map<String, Object> source = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMzAxNg==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378323016", "bodyText": "why not passing in the rawSource here as well? don't we want to support _raw as returning for performance reasons? If this was already discussed, sorry. If so a reasoning comment would be helpful ;)", "author": "seut", "createdAt": "2020-02-12T15:27:00Z", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based, so we can take directly\n+            // the rawSource\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,\n+                    source,\n+                    () -> \"\"", "originalCommit": "108071f87108760beec4976bd2883282e29b108b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY3NDA0MQ==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378674041", "bodyText": "Yes, lets do it!", "author": "mkleen", "createdAt": "2020-02-13T06:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMzAxNg=="}], "type": "inlineReview", "revised_code": {"commit": "033eb9eae500a53b0bdef25a64215edd153cd865", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\nindex 56adc67599..4afd5e66d0 100644\n--- a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n+++ b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n\n@@ -311,7 +311,7 @@ public class TransportShardUpsertAction extends TransportShardAction<ShardUpsert\n                                        IndexShard indexShard,\n                                        boolean isRetry,\n                                        @Nullable ReturnValueGen returnGen,\n-                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+                                       InsertSourceGen insertSourceGen) throws Exception {\n         assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n         BytesReference rawSource;\n         Map<String, Object> source = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMzMyOA==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378323328", "bodyText": "same here, no _raw support wanted?", "author": "seut", "createdAt": "2020-02-12T15:27:28Z", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,112 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based, so we can take directly\n+            // the rawSource\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,\n+                    source,\n+                    () -> \"\"\n+                )\n+            );\n+        }\n+        return new IndexItemResponse(indexResult.getTranslogLocation(), returnvalues);\n+    }\n \n-            item.source(BytesReference.bytes(XContentFactory.jsonBuilder().map(updatedSource)));\n-            seqNo = item.seqNo();\n-            primaryTerm = item.primaryTerm();\n-            version = Versions.MATCH_ANY;\n+    protected IndexItemResponse update(ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable UpdateSourceGen updateSourceGen) throws Exception {\n+        assert updateSourceGen != null : \"UpdateSourceGen must not be null\";\n+        Doc fetchedDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n+        Map<String, Object> source = updateSourceGen.generateSource(\n+            fetchedDoc,\n+            item.updateAssignments(),\n+            item.insertValues()\n+        );\n+        BytesReference rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n+        item.source(rawSource);\n+        long seqNo = item.seqNo();\n+        long primaryTerm = item.primaryTerm();\n+        long version = Versions.MATCH_ANY;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(\n+                    fetchedDoc.docId(),\n+                    fetchedDoc.getIndex(),\n+                    fetchedDoc.getId(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    indexResult.getTerm(),\n+                    source,\n+                    () -> \"\"", "originalCommit": "108071f87108760beec4976bd2883282e29b108b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "033eb9eae500a53b0bdef25a64215edd153cd865", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\nindex 56adc67599..4afd5e66d0 100644\n--- a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n+++ b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n\n@@ -311,7 +311,7 @@ public class TransportShardUpsertAction extends TransportShardAction<ShardUpsert\n                                        IndexShard indexShard,\n                                        boolean isRetry,\n                                        @Nullable ReturnValueGen returnGen,\n-                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+                                       InsertSourceGen insertSourceGen) throws Exception {\n         assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n         BytesReference rawSource;\n         Map<String, Object> source = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyOTg2NQ==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378329865", "bodyText": "very minor:  Isn't toArray(new Object[0]) still faster, safer than toArray(new Object[])? (see https://shipilev.net/blog/2016/arrays-wisdom-ancients/)", "author": "seut", "createdAt": "2020-02-12T15:36:43Z", "path": "sql/src/main/java/io/crate/execution/engine/indexing/ColumnIndexWriterProjector.java", "diffHunk": "@@ -94,20 +96,31 @@ public ColumnIndexWriterProjector(ClusterService clusterService,\n             updateColumnNames = convert.targetNames();\n             assignments = convert.sources();\n         }\n+\n+        Symbol[] returnValueOrNull = returnValues.isEmpty() ? null : returnValues.toArray(new Symbol[]{});", "originalCommit": "108071f87108760beec4976bd2883282e29b108b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1Nzg3Mw==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378657873", "bodyText": "Good point i was not aware of this. (btw, great link)", "author": "mkleen", "createdAt": "2020-02-13T05:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyOTg2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "033eb9eae500a53b0bdef25a64215edd153cd865", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/engine/indexing/ColumnIndexWriterProjector.java b/sql/src/main/java/io/crate/execution/engine/indexing/ColumnIndexWriterProjector.java\nindex d7e34ef310..8615928edc 100644\n--- a/sql/src/main/java/io/crate/execution/engine/indexing/ColumnIndexWriterProjector.java\n+++ b/sql/src/main/java/io/crate/execution/engine/indexing/ColumnIndexWriterProjector.java\n\n@@ -97,7 +97,7 @@ public class ColumnIndexWriterProjector implements Projector {\n             assignments = convert.sources();\n         }\n \n-        Symbol[] returnValueOrNull = returnValues.isEmpty() ? null : returnValues.toArray(new Symbol[]{});\n+        Symbol[] returnValueOrNull = returnValues.isEmpty() ? null : returnValues.toArray(new Symbol[0]);\n \n         ShardUpsertRequest.Builder builder = new ShardUpsertRequest.Builder(\n             txnCtx.sessionSettings(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzMTI5OA==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378331298", "bodyText": "format: indent issue (also @Test annotation missing)", "author": "seut", "createdAt": "2020-02-12T15:38:55Z", "path": "sql/src/test/java/io/crate/integrationtests/InsertIntoIntegrationTest.java", "diffHunk": "@@ -1458,4 +1458,133 @@ public void testInsertDefaultExpressions() {\n                \"5| cr8\\n\")\n         );\n     }\n+\n+    @Test\n+    public void test_insert_with_id_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"id\"));\n+        assertThat(response.rows()[0][0], is(1));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_multiple_values_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id, owner\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"id\"));\n+        assertThat(response.cols()[1], is(\"owner\"));\n+        assertThat(response.rows()[0][0], is(1));\n+        assertThat(response.rows()[0][1], is(\"crate\"));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_function_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning id + 1 as bar\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"bar\"));\n+        assertThat(response.rows()[0][0], is(2));\n+\n+    }\n+\n+\n+    @Test\n+    public void test_insert_with_seq_no_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning _seq_no as seq\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"seq\"));\n+        assertThat(response.rows()[0][0], is(0L));\n+\n+    }\n+\n+    @Test\n+    public void test_insert_with_owner_renamed_in_returning_clause() {\n+        execute(\"create table t (\" +\n+                \" id int,\" +\n+                \" owner text default 'crate'\" +\n+                \") with (number_of_replicas=0)\");\n+\n+        execute(\"insert into t (id) values (?) returning owner as name\",\n+                new Object[]{1});\n+\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat(response.cols()[0], is(\"name\"));\n+        assertThat(response.rows()[0][0], is(\"crate\"));\n+\n+    }\n+\n+        public void test_insert_from_subquery_with_id_field_in_returning_clause() {", "originalCommit": "108071f87108760beec4976bd2883282e29b108b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1Nzk4OA==", "url": "https://github.com/crate/crate/pull/9615#discussion_r378657988", "bodyText": "Good catch, thank you!", "author": "mkleen", "createdAt": "2020-02-13T05:30:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzMTI5OA=="}], "type": "inlineReview", "revised_code": {"commit": "033eb9eae500a53b0bdef25a64215edd153cd865", "chunk": "diff --git a/sql/src/test/java/io/crate/integrationtests/InsertIntoIntegrationTest.java b/sql/src/test/java/io/crate/integrationtests/InsertIntoIntegrationTest.java\nindex 005dc32b4e..62cd2fac9f 100644\n--- a/sql/src/test/java/io/crate/integrationtests/InsertIntoIntegrationTest.java\n+++ b/sql/src/test/java/io/crate/integrationtests/InsertIntoIntegrationTest.java\n\n@@ -1542,7 +1542,8 @@ public class InsertIntoIntegrationTest extends SQLTransportIntegrationTest {\n \n     }\n \n-        public void test_insert_from_subquery_with_id_field_in_returning_clause() {\n+    @Test\n+    public void test_insert_from_subquery_with_id_field_in_returning_clause() {\n         execute(\"create table t (\" +\n                 \" id int,\" +\n                 \" owner text default 'crate'\" +\n"}}, {"oid": "033eb9eae500a53b0bdef25a64215edd153cd865", "url": "https://github.com/crate/crate/commit/033eb9eae500a53b0bdef25a64215edd153cd865", "message": "Add returning clause for insert to storage engine", "committedDate": "2020-02-13T10:16:57Z", "type": "forcePushed"}, {"oid": "510d6958902a565b1e13018c8a52247a25d17233", "url": "https://github.com/crate/crate/commit/510d6958902a565b1e13018c8a52247a25d17233", "message": "Add documentation for returning clause for insert", "committedDate": "2020-02-13T11:28:56Z", "type": "commit"}, {"oid": "9697c21f979cc260fdfc2d3e0013862778f3ca29", "url": "https://github.com/crate/crate/commit/9697c21f979cc260fdfc2d3e0013862778f3ca29", "message": "Add returning clause for insert to grammar and parser", "committedDate": "2020-02-13T11:28:56Z", "type": "commit"}, {"oid": "61a3ca5d6cafc41bb1d6e416a486346ed4f7bffa", "url": "https://github.com/crate/crate/commit/61a3ca5d6cafc41bb1d6e416a486346ed4f7bffa", "message": "Add returnvalues and output fields for insert to analyzer", "committedDate": "2020-02-13T11:31:25Z", "type": "commit"}, {"oid": "f64e19b09795f12c2bc5f1d72bb70420cb5f164d", "url": "https://github.com/crate/crate/commit/f64e19b09795f12c2bc5f1d72bb70420cb5f164d", "message": "Add returning clause for insert to storage engine", "committedDate": "2020-02-13T11:31:30Z", "type": "commit"}, {"oid": "f64e19b09795f12c2bc5f1d72bb70420cb5f164d", "url": "https://github.com/crate/crate/commit/f64e19b09795f12c2bc5f1d72bb70420cb5f164d", "message": "Add returning clause for insert to storage engine", "committedDate": "2020-02-13T11:31:30Z", "type": "forcePushed"}]}