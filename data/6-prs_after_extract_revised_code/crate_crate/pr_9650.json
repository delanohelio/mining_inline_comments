{"pr_number": 9650, "pr_title": "Terminate ordered lucene collector on cancel/kill ", "pr_createdAt": "2020-02-11T15:32:53Z", "pr_url": "https://github.com/crate/crate/pull/9650", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxNDMyMQ==", "url": "https://github.com/crate/crate/pull/9650#discussion_r377714321", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                                Consumer<Throwable> beforeExceptional) {\n          \n          \n            \n                                                                Consumer<Throwable> onKill) {", "author": "mfussenegger", "createdAt": "2020-02-11T15:37:56Z", "path": "shared/src/main/java/io/crate/concurrent/CompletableFutures.java", "diffHunk": "@@ -57,4 +67,349 @@ private CompletableFutures() {\n         }\n     }\n \n+    public static <T> CompletionStage<T> asKillable(CompletableFuture<T> delegate,\n+                                                    Consumer<Throwable> beforeExceptional) {", "originalCommit": "063d6f3a73eb39336ced0ce957ec440a97f39a16", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "24ab00eb94ab06fbfa150a1b26874612ee463009", "chunk": "diff --git a/shared/src/main/java/io/crate/concurrent/CompletableFutures.java b/shared/src/main/java/io/crate/concurrent/CompletableFutures.java\nindex c6506afa61..813c371bbb 100644\n--- a/shared/src/main/java/io/crate/concurrent/CompletableFutures.java\n+++ b/shared/src/main/java/io/crate/concurrent/CompletableFutures.java\n\n@@ -67,349 +57,4 @@ public final class CompletableFutures {\n         }\n     }\n \n-    public static <T> CompletionStage<T> asKillable(CompletableFuture<T> delegate,\n-                                                    Consumer<Throwable> beforeExceptional) {\n-        return new KillableCompletableFuture<>(delegate, beforeExceptional);\n-    }\n-\n-    @SuppressForbidden\n-    private static class KillableCompletableFuture<T> extends CompletableFuture<T> implements Killable {\n-\n-        private final CompletableFuture<T> delegate;\n-        private final Consumer<Throwable> onKill;\n-\n-        private KillableCompletableFuture(CompletableFuture<T> delegate, Consumer<Throwable> onKill) {\n-            this.delegate = delegate;\n-            this.onKill = onKill;\n-        }\n-\n-        @Override\n-        public void kill(@Nonnull Throwable throwable) {\n-            onKill.accept(throwable);\n-        }\n-\n-        @Override\n-        public boolean completeExceptionally(Throwable ex) {\n-            return delegate.completeExceptionally(ex);\n-        }\n-\n-        @Override\n-        public boolean cancel(boolean mayInterruptIfRunning) {\n-            return delegate.cancel(mayInterruptIfRunning);\n-        }\n-\n-        @Override\n-        public boolean isDone() {\n-            return delegate.isDone();\n-        }\n-\n-        @Override\n-        public T get() throws InterruptedException, ExecutionException {\n-            return delegate.get();\n-        }\n-\n-        @Override\n-        public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n-            return delegate.get(timeout, unit);\n-        }\n-\n-        @Override\n-        public T join() {\n-            return delegate.join();\n-        }\n-\n-        @Override\n-        public T getNow(T valueIfAbsent) {\n-            return delegate.getNow(valueIfAbsent);\n-        }\n-\n-        @Override\n-        public boolean complete(T value) {\n-            return delegate.complete(value);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenApply(Function<? super T, ? extends U> fn) {\n-            return delegate.thenApply(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends U> fn) {\n-            return delegate.thenApplyAsync(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends U> fn,\n-                                                       Executor executor) {\n-            return delegate.thenApplyAsync(fn, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenAccept(Consumer<? super T> action) {\n-            return delegate.thenAccept(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action) {\n-            return delegate.thenAcceptAsync(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor) {\n-            return delegate.thenAcceptAsync(action, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenRun(Runnable action) {\n-            return delegate.thenRun(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenRunAsync(Runnable action) {\n-            return delegate.thenRunAsync(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor) {\n-            return delegate.thenRunAsync(action, executor);\n-        }\n-\n-        @Override\n-        public <U, V> CompletableFuture<V> thenCombine(CompletionStage<? extends U> other,\n-                                                       BiFunction<? super T, ? super U, ? extends V> fn) {\n-            return delegate.thenCombine(other, fn);\n-        }\n-\n-        @Override\n-        public <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other,\n-                                                            BiFunction<? super T, ? super U, ? extends V> fn) {\n-            return delegate.thenCombineAsync(other, fn);\n-        }\n-\n-        @Override\n-        public <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other,\n-                                                            BiFunction<? super T, ? super U, ? extends V> fn,\n-                                                            Executor executor) {\n-            return delegate.thenCombineAsync(other, fn, executor);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends U> other,\n-                                                          BiConsumer<? super T, ? super U> action) {\n-            return delegate.thenAcceptBoth(other, action);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other,\n-                                                               BiConsumer<? super T, ? super U> action) {\n-            return delegate.thenAcceptBothAsync(other, action);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other,\n-                                                               BiConsumer<? super T, ? super U> action,\n-                                                               Executor executor) {\n-            return delegate.thenAcceptBothAsync(other, action, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable action) {\n-            return delegate.runAfterBoth(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,\n-                                                         Runnable action) {\n-            return delegate.runAfterBothAsync(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,\n-                                                         Runnable action, Executor executor) {\n-            return delegate.runAfterBothAsync(other, action, executor);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T> other,\n-                                                      Function<? super T, U> fn) {\n-            return delegate.applyToEither(other, fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other,\n-                                                           Function<? super T, U> fn) {\n-            return delegate.applyToEitherAsync(other, fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other,\n-                                                           Function<? super T, U> fn,\n-                                                           Executor executor) {\n-            return delegate.applyToEitherAsync(other, fn, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other,\n-                                                    Consumer<? super T> action) {\n-            return delegate.acceptEither(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other,\n-                                                         Consumer<? super T> action) {\n-            return delegate.acceptEitherAsync(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other,\n-                                                         Consumer<? super T> action, Executor executor) {\n-            return delegate.acceptEitherAsync(other, action, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable action) {\n-            return delegate.runAfterEither(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,\n-                                                           Runnable action) {\n-            return delegate.runAfterEitherAsync(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,\n-                                                           Runnable action, Executor executor) {\n-            return delegate.runAfterEitherAsync(other, action, executor);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn) {\n-            return delegate.thenCompose(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn) {\n-            return delegate.thenComposeAsync(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn,\n-                                                         Executor executor) {\n-            return delegate.thenComposeAsync(fn, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable> action) {\n-            return delegate.whenComplete(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action) {\n-            return delegate.whenCompleteAsync(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action,\n-                                                      Executor executor) {\n-            return delegate.whenCompleteAsync(action, executor);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn) {\n-            return delegate.handle(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn) {\n-            return delegate.handleAsync(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn,\n-                                                    Executor executor) {\n-            return delegate.handleAsync(fn, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> toCompletableFuture() {\n-            return delegate.toCompletableFuture();\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn) {\n-            return delegate.exceptionally(fn);\n-        }\n-\n-        @Override\n-        public boolean isCancelled() {\n-            return delegate.isCancelled();\n-        }\n-\n-        @Override\n-        public boolean isCompletedExceptionally() {\n-            return delegate.isCompletedExceptionally();\n-        }\n-\n-        @Override\n-        public void obtrudeValue(T value) {\n-            delegate.obtrudeValue(value);\n-        }\n-\n-        @Override\n-        public void obtrudeException(Throwable ex) {\n-            delegate.obtrudeException(ex);\n-        }\n-\n-        @Override\n-        public int getNumberOfDependents() {\n-            return delegate.getNumberOfDependents();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return delegate.toString();\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> newIncompleteFuture() {\n-            return delegate.newIncompleteFuture();\n-        }\n-\n-        @Override\n-        public Executor defaultExecutor() {\n-            return delegate.defaultExecutor();\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> copy() {\n-            return delegate.copy();\n-        }\n-\n-        @Override\n-        public CompletionStage<T> minimalCompletionStage() {\n-            return delegate.minimalCompletionStage();\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier, Executor executor) {\n-            return delegate.completeAsync(supplier, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier) {\n-            return delegate.completeAsync(supplier);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> orTimeout(long timeout, TimeUnit unit) {\n-            return delegate.orTimeout(timeout, unit);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit) {\n-            return delegate.completeOnTimeout(value, timeout, unit);\n-        }\n-    }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxNTY4MA==", "url": "https://github.com/crate/crate/pull/9650#discussion_r377715680", "bodyText": "Just curious, what's the forbidden part here?", "author": "mfussenegger", "createdAt": "2020-02-11T15:39:58Z", "path": "shared/src/main/java/io/crate/concurrent/CompletableFutures.java", "diffHunk": "@@ -57,4 +67,349 @@ private CompletableFutures() {\n         }\n     }\n \n+    public static <T> CompletionStage<T> asKillable(CompletableFuture<T> delegate,\n+                                                    Consumer<Throwable> beforeExceptional) {\n+        return new KillableCompletableFuture<>(delegate, beforeExceptional);\n+    }\n+\n+    @SuppressForbidden", "originalCommit": "063d6f3a73eb39336ced0ce957ec440a97f39a16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MjU1Ng==", "url": "https://github.com/crate/crate/pull/9650#discussion_r377742556", "bodyText": "See https://github.com/crate/crate/blob/master/gradle/forbidden-signatures.txt#L5", "author": "seut", "createdAt": "2020-02-11T16:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxNTY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "24ab00eb94ab06fbfa150a1b26874612ee463009", "chunk": "diff --git a/shared/src/main/java/io/crate/concurrent/CompletableFutures.java b/shared/src/main/java/io/crate/concurrent/CompletableFutures.java\nindex c6506afa61..813c371bbb 100644\n--- a/shared/src/main/java/io/crate/concurrent/CompletableFutures.java\n+++ b/shared/src/main/java/io/crate/concurrent/CompletableFutures.java\n\n@@ -67,349 +57,4 @@ public final class CompletableFutures {\n         }\n     }\n \n-    public static <T> CompletionStage<T> asKillable(CompletableFuture<T> delegate,\n-                                                    Consumer<Throwable> beforeExceptional) {\n-        return new KillableCompletableFuture<>(delegate, beforeExceptional);\n-    }\n-\n-    @SuppressForbidden\n-    private static class KillableCompletableFuture<T> extends CompletableFuture<T> implements Killable {\n-\n-        private final CompletableFuture<T> delegate;\n-        private final Consumer<Throwable> onKill;\n-\n-        private KillableCompletableFuture(CompletableFuture<T> delegate, Consumer<Throwable> onKill) {\n-            this.delegate = delegate;\n-            this.onKill = onKill;\n-        }\n-\n-        @Override\n-        public void kill(@Nonnull Throwable throwable) {\n-            onKill.accept(throwable);\n-        }\n-\n-        @Override\n-        public boolean completeExceptionally(Throwable ex) {\n-            return delegate.completeExceptionally(ex);\n-        }\n-\n-        @Override\n-        public boolean cancel(boolean mayInterruptIfRunning) {\n-            return delegate.cancel(mayInterruptIfRunning);\n-        }\n-\n-        @Override\n-        public boolean isDone() {\n-            return delegate.isDone();\n-        }\n-\n-        @Override\n-        public T get() throws InterruptedException, ExecutionException {\n-            return delegate.get();\n-        }\n-\n-        @Override\n-        public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n-            return delegate.get(timeout, unit);\n-        }\n-\n-        @Override\n-        public T join() {\n-            return delegate.join();\n-        }\n-\n-        @Override\n-        public T getNow(T valueIfAbsent) {\n-            return delegate.getNow(valueIfAbsent);\n-        }\n-\n-        @Override\n-        public boolean complete(T value) {\n-            return delegate.complete(value);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenApply(Function<? super T, ? extends U> fn) {\n-            return delegate.thenApply(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends U> fn) {\n-            return delegate.thenApplyAsync(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends U> fn,\n-                                                       Executor executor) {\n-            return delegate.thenApplyAsync(fn, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenAccept(Consumer<? super T> action) {\n-            return delegate.thenAccept(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action) {\n-            return delegate.thenAcceptAsync(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor) {\n-            return delegate.thenAcceptAsync(action, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenRun(Runnable action) {\n-            return delegate.thenRun(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenRunAsync(Runnable action) {\n-            return delegate.thenRunAsync(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor) {\n-            return delegate.thenRunAsync(action, executor);\n-        }\n-\n-        @Override\n-        public <U, V> CompletableFuture<V> thenCombine(CompletionStage<? extends U> other,\n-                                                       BiFunction<? super T, ? super U, ? extends V> fn) {\n-            return delegate.thenCombine(other, fn);\n-        }\n-\n-        @Override\n-        public <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other,\n-                                                            BiFunction<? super T, ? super U, ? extends V> fn) {\n-            return delegate.thenCombineAsync(other, fn);\n-        }\n-\n-        @Override\n-        public <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other,\n-                                                            BiFunction<? super T, ? super U, ? extends V> fn,\n-                                                            Executor executor) {\n-            return delegate.thenCombineAsync(other, fn, executor);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends U> other,\n-                                                          BiConsumer<? super T, ? super U> action) {\n-            return delegate.thenAcceptBoth(other, action);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other,\n-                                                               BiConsumer<? super T, ? super U> action) {\n-            return delegate.thenAcceptBothAsync(other, action);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other,\n-                                                               BiConsumer<? super T, ? super U> action,\n-                                                               Executor executor) {\n-            return delegate.thenAcceptBothAsync(other, action, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable action) {\n-            return delegate.runAfterBoth(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,\n-                                                         Runnable action) {\n-            return delegate.runAfterBothAsync(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,\n-                                                         Runnable action, Executor executor) {\n-            return delegate.runAfterBothAsync(other, action, executor);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T> other,\n-                                                      Function<? super T, U> fn) {\n-            return delegate.applyToEither(other, fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other,\n-                                                           Function<? super T, U> fn) {\n-            return delegate.applyToEitherAsync(other, fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other,\n-                                                           Function<? super T, U> fn,\n-                                                           Executor executor) {\n-            return delegate.applyToEitherAsync(other, fn, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other,\n-                                                    Consumer<? super T> action) {\n-            return delegate.acceptEither(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other,\n-                                                         Consumer<? super T> action) {\n-            return delegate.acceptEitherAsync(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other,\n-                                                         Consumer<? super T> action, Executor executor) {\n-            return delegate.acceptEitherAsync(other, action, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable action) {\n-            return delegate.runAfterEither(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,\n-                                                           Runnable action) {\n-            return delegate.runAfterEitherAsync(other, action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,\n-                                                           Runnable action, Executor executor) {\n-            return delegate.runAfterEitherAsync(other, action, executor);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn) {\n-            return delegate.thenCompose(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn) {\n-            return delegate.thenComposeAsync(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn,\n-                                                         Executor executor) {\n-            return delegate.thenComposeAsync(fn, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable> action) {\n-            return delegate.whenComplete(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action) {\n-            return delegate.whenCompleteAsync(action);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action,\n-                                                      Executor executor) {\n-            return delegate.whenCompleteAsync(action, executor);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn) {\n-            return delegate.handle(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn) {\n-            return delegate.handleAsync(fn);\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn,\n-                                                    Executor executor) {\n-            return delegate.handleAsync(fn, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> toCompletableFuture() {\n-            return delegate.toCompletableFuture();\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn) {\n-            return delegate.exceptionally(fn);\n-        }\n-\n-        @Override\n-        public boolean isCancelled() {\n-            return delegate.isCancelled();\n-        }\n-\n-        @Override\n-        public boolean isCompletedExceptionally() {\n-            return delegate.isCompletedExceptionally();\n-        }\n-\n-        @Override\n-        public void obtrudeValue(T value) {\n-            delegate.obtrudeValue(value);\n-        }\n-\n-        @Override\n-        public void obtrudeException(Throwable ex) {\n-            delegate.obtrudeException(ex);\n-        }\n-\n-        @Override\n-        public int getNumberOfDependents() {\n-            return delegate.getNumberOfDependents();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return delegate.toString();\n-        }\n-\n-        @Override\n-        public <U> CompletableFuture<U> newIncompleteFuture() {\n-            return delegate.newIncompleteFuture();\n-        }\n-\n-        @Override\n-        public Executor defaultExecutor() {\n-            return delegate.defaultExecutor();\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> copy() {\n-            return delegate.copy();\n-        }\n-\n-        @Override\n-        public CompletionStage<T> minimalCompletionStage() {\n-            return delegate.minimalCompletionStage();\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier, Executor executor) {\n-            return delegate.completeAsync(supplier, executor);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier) {\n-            return delegate.completeAsync(supplier);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> orTimeout(long timeout, TimeUnit unit) {\n-            return delegate.orTimeout(timeout, unit);\n-        }\n-\n-        @Override\n-        public CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit) {\n-            return delegate.completeOnTimeout(value, timeout, unit);\n-        }\n-    }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxOTQxNw==", "url": "https://github.com/crate/crate/pull/9650#discussion_r377719417", "bodyText": "I am not sure if we need both of these to be volatile.\nWe could probably remove the check here https://github.com/crate/crate/pull/9650/files#diff-1360f05e99db1b25d5f53dec74c7abb2R137 and always depend on the kill raising via the Collector. I think the operations happening between those actions are cheap enough to ignore.", "author": "mfussenegger", "createdAt": "2020-02-11T15:45:20Z", "path": "sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java", "diffHunk": "@@ -72,6 +79,11 @@\n     private int batchSize;\n     private boolean batchSizeReduced = false;\n \n+    @Nullable\n+    private volatile KillableCollector currentCollector;\n+\n+    @Nullable\n+    private volatile Throwable killed;", "originalCommit": "063d6f3a73eb39336ced0ce957ec440a97f39a16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0NjM1Ng==", "url": "https://github.com/crate/crate/pull/9650#discussion_r377746356", "bodyText": "I am not sure if we need both of these to be volatile.\n\nBoth can be set and used from different threads.\n    t1                       t2\n                          OrderedDocCollector\n                          -> collect()\n                            -> set currentCollector\n                            -> check killed and raise\n\n  kill()\n      ------------------> OrderedDocCollector\n                        -> set killed\n                        -> check currentCollector and call kill()  if set", "author": "seut", "createdAt": "2020-02-11T16:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxOTQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0NjU4OQ==", "url": "https://github.com/crate/crate/pull/9650#discussion_r377746589", "bodyText": "We could probably remove the check here https://github.com/crate/crate/pull/9650/files#diff-1360f05e99db1b25d5f53dec74c7abb2R137 and always depend on the kill raising via the Collector. I think the operations happening between those actions are cheap enough to ignore.\n\nYep agree.", "author": "seut", "createdAt": "2020-02-11T16:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxOTQxNw=="}], "type": "inlineReview", "revised_code": {"commit": "7c23a88568ea92f6e83aa32b55b0f739e9414728", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java b/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java\nindex c024a80b3b..ef5987ed14 100644\n--- a/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java\n+++ b/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java\n\n@@ -75,16 +75,11 @@ public class LuceneOrderedDocCollector extends OrderedDocCollector {\n     private final ScoreDocRowFunction rowFunction;\n     private final DummyScorer scorer;\n     private final IndexSearcher searcher;\n+    private final AtomicReference<Throwable> killed = new AtomicReference<>();\n \n     private int batchSize;\n     private boolean batchSizeReduced = false;\n \n-    @Nullable\n-    private volatile KillableCollector currentCollector;\n-\n-    @Nullable\n-    private volatile Throwable killed;\n-\n     @Nullable\n     private FieldDoc lastDoc = null;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMzY3NA==", "url": "https://github.com/crate/crate/pull/9650#discussion_r377723674", "bodyText": "I think there is a race condition between getLeafCollector and kill:\nt1: Is before `killed = t;`\nt2: Is past `raiseIfKilled(killed);` but hasn`t done the assignment to `currentLeafCollector`\n\nIn that case the kill would be swallowed I think. Could probably be solved with a compare and set operation", "author": "mfussenegger", "createdAt": "2020-02-11T15:51:42Z", "path": "sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java", "diffHunk": "@@ -205,4 +231,83 @@ private Query query(FieldDoc lastDoc) {\n         searchAfterQuery.add(optimizedQuery, BooleanClause.Occur.MUST_NOT);\n         return searchAfterQuery.build();\n     }\n+\n+    private static void raiseIfKilled(@Nullable Throwable t) {\n+        if (t != null) {\n+            Exceptions.rethrowUnchecked(t);\n+        }\n+    }\n+\n+    private static class KillableCollector implements Collector, Killable {\n+\n+        private final Collector delegate;\n+\n+        @Nullable\n+        private volatile KillableLeafCollector currentLeafCollector;\n+\n+        @Nullable\n+        private volatile Throwable killed;\n+\n+        public KillableCollector(Collector delegate, @Nullable Throwable killed) {\n+            this.delegate = delegate;\n+            this.killed = killed;\n+        }\n+\n+        @Override\n+        public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n+            raiseIfKilled(killed);\n+            currentLeafCollector = new KillableLeafCollector(delegate.getLeafCollector(context), killed);\n+            return currentLeafCollector;\n+        }\n+\n+        @Override\n+        public ScoreMode scoreMode() {\n+            return delegate.scoreMode();\n+        }\n+\n+        @Override\n+        public void kill(@Nonnull Throwable t) {\n+            if (killed != null) {\n+                return;\n+            }\n+            killed = t;\n+            var leafCollector = currentLeafCollector;\n+            if (leafCollector != null) {", "originalCommit": "063d6f3a73eb39336ced0ce957ec440a97f39a16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MTk5Nw==", "url": "https://github.com/crate/crate/pull/9650#discussion_r377741997", "bodyText": "I don't think so as killed is passed to the leaf collector ctor.", "author": "seut", "createdAt": "2020-02-11T16:19:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEyNzEwMg==", "url": "https://github.com/crate/crate/pull/9650#discussion_r378127102", "bodyText": "Yes, but only if killed has been assigned before the leaf collector is created.\nThe scenario I have in mind is that killed hasn't been assignd to yet, and the other thread read the volatile (unassigned) 'killed' but didn't finish the 'currentLeafCollector'  assignment yet.\nHow about having a final AtomicReference in the top most class and the collector + leaf collector receive a reference to that? That would replace the individual killed attributes.", "author": "mfussenegger", "createdAt": "2020-02-12T09:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0OTkzNw==", "url": "https://github.com/crate/crate/pull/9650#discussion_r378149937", "bodyText": "Right, there is still a race condition, good catch.\n\nHow about having a final AtomicReference in the top most class and the collector + leaf collector receive a reference to that? That would replace the individual killed attributes.\n\nYep, sounds good.", "author": "seut", "createdAt": "2020-02-12T10:04:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2MDYwOA==", "url": "https://github.com/crate/crate/pull/9650#discussion_r378160608", "bodyText": "Pushed a fixup.", "author": "seut", "createdAt": "2020-02-12T10:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMzY3NA=="}], "type": "inlineReview", "revised_code": {"commit": "7c23a88568ea92f6e83aa32b55b0f739e9414728", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java b/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java\nindex c024a80b3b..ef5987ed14 100644\n--- a/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java\n+++ b/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java\n\n@@ -232,82 +221,55 @@ public class LuceneOrderedDocCollector extends OrderedDocCollector {\n         return searchAfterQuery.build();\n     }\n \n-    private static void raiseIfKilled(@Nullable Throwable t) {\n+    private void raiseIfKilled() {\n+        var t = killed.get();\n         if (t != null) {\n             Exceptions.rethrowUnchecked(t);\n         }\n     }\n \n-    private static class KillableCollector implements Collector, Killable {\n+    private static class KillableCollector implements Collector {\n \n         private final Collector delegate;\n+        private final Runnable raiseIfKilled;\n \n-        @Nullable\n-        private volatile KillableLeafCollector currentLeafCollector;\n-\n-        @Nullable\n-        private volatile Throwable killed;\n-\n-        public KillableCollector(Collector delegate, @Nullable Throwable killed) {\n+        public KillableCollector(Collector delegate, Runnable raiseIfKilled) {\n             this.delegate = delegate;\n-            this.killed = killed;\n+            this.raiseIfKilled = raiseIfKilled;\n         }\n \n         @Override\n         public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n-            raiseIfKilled(killed);\n-            currentLeafCollector = new KillableLeafCollector(delegate.getLeafCollector(context), killed);\n-            return currentLeafCollector;\n+            raiseIfKilled.run();\n+            return new KillableLeafCollector(delegate.getLeafCollector(context), raiseIfKilled);\n         }\n \n         @Override\n         public ScoreMode scoreMode() {\n             return delegate.scoreMode();\n         }\n-\n-        @Override\n-        public void kill(@Nonnull Throwable t) {\n-            if (killed != null) {\n-                return;\n-            }\n-            killed = t;\n-            var leafCollector = currentLeafCollector;\n-            if (leafCollector != null) {\n-                leafCollector.kill(t);\n-            }\n-        }\n     }\n \n-    private static class KillableLeafCollector implements LeafCollector, Killable {\n+    private static class KillableLeafCollector implements LeafCollector {\n \n         private final LeafCollector delegate;\n+        private final Runnable raiseIfKilled;\n \n-        @Nullable\n-        private volatile Throwable killed;\n-\n-        public KillableLeafCollector(LeafCollector delegate, @Nullable Throwable killed) {\n+        public KillableLeafCollector(LeafCollector delegate, Runnable raiseIfKilled) {\n             this.delegate = delegate;\n-            this.killed = killed;\n+            this.raiseIfKilled = raiseIfKilled;\n         }\n \n         @Override\n         public void setScorer(Scorable scorer) throws IOException {\n-            raiseIfKilled(killed);\n+            raiseIfKilled.run();\n             delegate.setScorer(scorer);\n         }\n \n         @Override\n         public void collect(int doc) throws IOException {\n-            raiseIfKilled(killed);\n+            raiseIfKilled.run();\n             delegate.collect(doc);\n         }\n-\n-        @Override\n-        public void kill(@Nonnull Throwable t) {\n-            if (killed != null) {\n-                return;\n-            }\n-            killed = t;\n-        }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyNTUxNA==", "url": "https://github.com/crate/crate/pull/9650#discussion_r377725514", "bodyText": "I think here we could actually return the new KillableCompletableFuture. Otherwise the call-site has to know that this might implement Killable, that is not very common.\nBy changing the interface to return CompletionStage I was referring to loadNextBatch, but that could probably be a dedicated PR, as it isn't involved here at all.", "author": "mfussenegger", "createdAt": "2020-02-11T15:54:30Z", "path": "sql/src/main/java/io/crate/execution/engine/collect/collectors/OrderedLuceneBatchIteratorFactory.java", "diffHunk": "@@ -102,22 +104,24 @@\n             );\n         }\n \n-        private CompletableFuture<List<KeyIterable<ShardId, Row>>> tryFetchMore(ShardId shardId) {\n+        private CompletionStage<List<KeyIterable<ShardId, Row>>> tryFetchMore(ShardId shardId) {", "originalCommit": "063d6f3a73eb39336ced0ce957ec440a97f39a16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNTA3MQ==", "url": "https://github.com/crate/crate/pull/9650#discussion_r377735071", "bodyText": "Or maybe we expose a KillableCompletionStage here?", "author": "mfussenegger", "createdAt": "2020-02-11T16:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyNTUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNjcyOA==", "url": "https://github.com/crate/crate/pull/9650#discussion_r377736728", "bodyText": "By changing the interface to return CompletionStage I was referring to loadNextBatch\n\nThat's already in place.", "author": "seut", "createdAt": "2020-02-11T16:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyNTUxNA=="}], "type": "inlineReview", "revised_code": {"commit": "24ab00eb94ab06fbfa150a1b26874612ee463009", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/engine/collect/collectors/OrderedLuceneBatchIteratorFactory.java b/sql/src/main/java/io/crate/execution/engine/collect/collectors/OrderedLuceneBatchIteratorFactory.java\nindex c74b50f7cc..d66a7c834c 100644\n--- a/sql/src/main/java/io/crate/execution/engine/collect/collectors/OrderedLuceneBatchIteratorFactory.java\n+++ b/sql/src/main/java/io/crate/execution/engine/collect/collectors/OrderedLuceneBatchIteratorFactory.java\n\n@@ -104,21 +104,23 @@ public class OrderedLuceneBatchIteratorFactory {\n             );\n         }\n \n-        private CompletionStage<List<KeyIterable<ShardId, Row>>> tryFetchMore(ShardId shardId) {\n+        private KillableCompletionStage<List<KeyIterable<ShardId, Row>>> tryFetchMore(ShardId shardId) {\n             if (allExhausted()) {\n-                return CompletableFuture.failedFuture(new IllegalStateException(\"Cannot fetch more if source is exhausted\"));\n+                return KillableCompletionStage.whenKilled(\n+                    CompletableFuture.failedFuture(new IllegalStateException(\"Cannot fetch more if source is exhausted\")),\n+                    t -> { });\n             }\n+            CompletionStage<List<KeyIterable<ShardId, Row>>> stage;\n             if (shardId == null) {\n                 // when running inside threads, the threads must be cancelled/interrupted to stop further processing\n-                return CompletableFutures.asKillable(\n-                    ThreadPools.runWithAvailableThreads(\n+                stage = ThreadPools.runWithAvailableThreads(\n                         executor,\n                         availableThreads,\n-                        Lists2.map(orderedDocCollectors, Function.identity())),\n-                    this::kill);\n+                        Lists2.map(orderedDocCollectors, Function.identity()));\n             } else {\n-                return loadFrom(collectorsByShardId.get(shardId));\n+                stage = loadFrom(collectorsByShardId.get(shardId));\n             }\n+            return KillableCompletionStage.whenKilled(stage, this::kill);\n         }\n \n         private static CompletionStage<List<KeyIterable<ShardId, Row>>> loadFrom(OrderedDocCollector collector) {\n"}}, {"oid": "24ab00eb94ab06fbfa150a1b26874612ee463009", "url": "https://github.com/crate/crate/commit/24ab00eb94ab06fbfa150a1b26874612ee463009", "message": "fixup! fixup! Terminate ordered lucene collector on cancel/kill", "committedDate": "2020-02-11T19:49:02Z", "type": "forcePushed"}, {"oid": "eab3bdb91d8d7ce5188d82ba03beb8c7e2e80243", "url": "https://github.com/crate/crate/commit/eab3bdb91d8d7ce5188d82ba03beb8c7e2e80243", "message": "fixup! fixup! Terminate ordered lucene collector on cancel/kill", "committedDate": "2020-02-11T19:51:55Z", "type": "forcePushed"}, {"oid": "3f751c3aa98b59a0648c32c5d3c9109d5eeada5f", "url": "https://github.com/crate/crate/commit/3f751c3aa98b59a0648c32c5d3c9109d5eeada5f", "message": "fixup! fixup! Terminate ordered lucene collector on cancel/kill", "committedDate": "2020-02-11T19:53:36Z", "type": "forcePushed"}, {"oid": "ca52c75556965792960ec7e8a4b7993166c1b464", "url": "https://github.com/crate/crate/commit/ca52c75556965792960ec7e8a4b7993166c1b464", "message": "fixup! fixup! Terminate ordered lucene collector on cancel/kill", "committedDate": "2020-02-11T19:57:39Z", "type": "forcePushed"}, {"oid": "779d1e5fd1d79fdf604ea3e8e72ddacf1b13aecb", "url": "https://github.com/crate/crate/commit/779d1e5fd1d79fdf604ea3e8e72ddacf1b13aecb", "message": "Terminate ordered lucene collector on cancel/kill\n\nIf an ordered lucene collector is running inside a child thread, it\nshould stop processing and the thread should terminate if cancelled/killed.\nOtherwise it may still occupy resources (e.g. account memory) AFTER the\njob was killed and shared resources (ram accounting) are released.", "committedDate": "2020-02-12T08:30:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2NzUzOA==", "url": "https://github.com/crate/crate/pull/9650#discussion_r378167538", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public KillableCollector(Collector delegate, Consumer<Void> raiseIfKilled) {\n          \n          \n            \n                    public KillableCollector(Collector delegate, Runnable raiseIfKilled) {", "author": "mfussenegger", "createdAt": "2020-02-12T10:36:30Z", "path": "sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java", "diffHunk": "@@ -231,82 +222,55 @@ private Query query(FieldDoc lastDoc) {\n         return searchAfterQuery.build();\n     }\n \n-    private static void raiseIfKilled(@Nullable Throwable t) {\n+    private void raiseIfKilled() {\n+        var t = killed.get();\n         if (t != null) {\n             Exceptions.rethrowUnchecked(t);\n         }\n     }\n \n-    private static class KillableCollector implements Collector, Killable {\n+    private static class KillableCollector implements Collector {\n \n         private final Collector delegate;\n+        private final Consumer<Void> raiseIfKilled;\n \n-        @Nullable\n-        private volatile KillableLeafCollector currentLeafCollector;\n-\n-        @Nullable\n-        private volatile Throwable killed;\n-\n-        public KillableCollector(Collector delegate, @Nullable Throwable killed) {\n+        public KillableCollector(Collector delegate, Consumer<Void> raiseIfKilled) {", "originalCommit": "f68cde661b0a04409a7fa8f2a0a45f9c7c916221", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7c23a88568ea92f6e83aa32b55b0f739e9414728", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java b/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java\nindex aa7bd2612e..ef5987ed14 100644\n--- a/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java\n+++ b/sql/src/main/java/io/crate/execution/engine/collect/collectors/LuceneOrderedDocCollector.java\n\n@@ -232,16 +231,16 @@ public class LuceneOrderedDocCollector extends OrderedDocCollector {\n     private static class KillableCollector implements Collector {\n \n         private final Collector delegate;\n-        private final Consumer<Void> raiseIfKilled;\n+        private final Runnable raiseIfKilled;\n \n-        public KillableCollector(Collector delegate, Consumer<Void> raiseIfKilled) {\n+        public KillableCollector(Collector delegate, Runnable raiseIfKilled) {\n             this.delegate = delegate;\n             this.raiseIfKilled = raiseIfKilled;\n         }\n \n         @Override\n         public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n-            raiseIfKilled.accept(null);\n+            raiseIfKilled.run();\n             return new KillableLeafCollector(delegate.getLeafCollector(context), raiseIfKilled);\n         }\n \n"}}, {"oid": "7c23a88568ea92f6e83aa32b55b0f739e9414728", "url": "https://github.com/crate/crate/commit/7c23a88568ea92f6e83aa32b55b0f739e9414728", "message": "Terminate ordered lucene collector on cancel/kill\n\nIf an ordered lucene collector is running inside a child thread, it\nshould stop processing and the thread should terminate if cancelled/killed.\nOtherwise it may still occupy resources (e.g. account memory) AFTER the\njob was killed and shared resources (ram accounting) are released.", "committedDate": "2020-02-12T10:44:59Z", "type": "commit"}, {"oid": "7c23a88568ea92f6e83aa32b55b0f739e9414728", "url": "https://github.com/crate/crate/commit/7c23a88568ea92f6e83aa32b55b0f739e9414728", "message": "Terminate ordered lucene collector on cancel/kill\n\nIf an ordered lucene collector is running inside a child thread, it\nshould stop processing and the thread should terminate if cancelled/killed.\nOtherwise it may still occupy resources (e.g. account memory) AFTER the\njob was killed and shared resources (ram accounting) are released.", "committedDate": "2020-02-12T10:44:59Z", "type": "forcePushed"}]}