{"pr_number": 9801, "pr_title": "Enable query-then-fetch for more cases", "pr_createdAt": "2020-03-25T12:46:58Z", "pr_url": "https://github.com/crate/crate/pull/9801", "timeline": [{"oid": "c9710624c4683d11e3d24774beb174fbd8617d76", "url": "https://github.com/crate/crate/commit/c9710624c4683d11e3d24774beb174fbd8617d76", "message": "Support fetch rewrite for NestedLoopJoin", "committedDate": "2020-03-25T14:44:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxMjgzNw==", "url": "https://github.com/crate/crate/pull/9801#discussion_r397912837", "bodyText": "I think we can move this in a follow up into either fetchRewrite itself or some utils or make it top-level, because we will need this for other operators as well.", "author": "mfussenegger", "createdAt": "2020-03-25T14:47:14Z", "path": "sql/src/main/java/io/crate/planner/operators/Order.java", "diffHunk": "@@ -83,6 +88,50 @@ public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n         return replaceSources(List.of(newSource));\n     }\n \n+    @Nullable\n+    @Override\n+    public FetchRewrite rewriteToFetch(Collection<Symbol> usedColumns) {\n+        HashSet<Symbol> allUsedColumns = new HashSet<>(usedColumns);\n+        allUsedColumns.addAll(orderBy.orderBySymbols());\n+        FetchRewrite fetchRewrite = source.rewriteToFetch(allUsedColumns);\n+        if (fetchRewrite == null) {\n+            return null;\n+        }\n+        LogicalPlan newSource = fetchRewrite.newPlan();\n+        Order newOrderBy = new Order(newSource, orderBy);\n+        Map<Symbol, Symbol> replacedOutputs = fetchRewrite.replacedOutputs();\n+        if (newOrderBy.outputs.size() > newSource.outputs().size()) {\n+            // This is the case if the `orderBy` contains computations on top of the source outputs.\n+            // e.g. OrderBy [x + y] where the source provides [x, y]\n+            // We need to extend replacedOutputs in this case because it must always contain entries for all outputs\n+            LinkedHashMap<Symbol, Symbol> newReplacedOutputs = new LinkedHashMap<>(replacedOutputs);\n+            FunctionCopyVisitor<Void> mapToFetchStubs = new FunctionCopyVisitor<>() {", "originalCommit": "c9710624c4683d11e3d24774beb174fbd8617d76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e0e838f511943b32b5631245b26f39a388d04048", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/operators/Order.java b/sql/src/main/java/io/crate/planner/operators/Order.java\nindex 12058e58da..c20275bf52 100644\n--- a/sql/src/main/java/io/crate/planner/operators/Order.java\n+++ b/sql/src/main/java/io/crate/planner/operators/Order.java\n\n@@ -88,50 +83,6 @@ public class Order extends ForwardingLogicalPlan {\n         return replaceSources(List.of(newSource));\n     }\n \n-    @Nullable\n-    @Override\n-    public FetchRewrite rewriteToFetch(Collection<Symbol> usedColumns) {\n-        HashSet<Symbol> allUsedColumns = new HashSet<>(usedColumns);\n-        allUsedColumns.addAll(orderBy.orderBySymbols());\n-        FetchRewrite fetchRewrite = source.rewriteToFetch(allUsedColumns);\n-        if (fetchRewrite == null) {\n-            return null;\n-        }\n-        LogicalPlan newSource = fetchRewrite.newPlan();\n-        Order newOrderBy = new Order(newSource, orderBy);\n-        Map<Symbol, Symbol> replacedOutputs = fetchRewrite.replacedOutputs();\n-        if (newOrderBy.outputs.size() > newSource.outputs().size()) {\n-            // This is the case if the `orderBy` contains computations on top of the source outputs.\n-            // e.g. OrderBy [x + y] where the source provides [x, y]\n-            // We need to extend replacedOutputs in this case because it must always contain entries for all outputs\n-            LinkedHashMap<Symbol, Symbol> newReplacedOutputs = new LinkedHashMap<>(replacedOutputs);\n-            FunctionCopyVisitor<Void> mapToFetchStubs = new FunctionCopyVisitor<>() {\n-\n-                @Override\n-                protected Symbol visitSymbol(Symbol symbol, Void context) {\n-                    return replacedOutputs.getOrDefault(symbol, symbol);\n-                }\n-\n-                @Override\n-                public Symbol visitFunction(Function func, Void context) {\n-                    Symbol mappedFunc = replacedOutputs.get(func);\n-                    if (mappedFunc == null) {\n-                        return processAndMaybeCopy(func, context);\n-                    } else {\n-                        return mappedFunc;\n-                    }\n-                }\n-            };\n-            for (int i = newSource.outputs().size(); i < newOrderBy.outputs.size(); i++) {\n-                Symbol extraOutput = newOrderBy.outputs.get(i);\n-                newReplacedOutputs.put(extraOutput, extraOutput.accept(mapToFetchStubs, null));\n-            }\n-            return new FetchRewrite(newReplacedOutputs, newOrderBy);\n-        } else {\n-            return new FetchRewrite(replacedOutputs, newOrderBy);\n-        }\n-    }\n-\n     @Override\n     public ExecutionPlan build(PlannerContext plannerContext,\n                                ProjectionBuilder projectionBuilder,\n"}}, {"oid": "e0e838f511943b32b5631245b26f39a388d04048", "url": "https://github.com/crate/crate/commit/e0e838f511943b32b5631245b26f39a388d04048", "message": "Make fetch rewrite rule propagate through the whole sub-tree", "committedDate": "2020-03-25T14:48:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzMzczMA==", "url": "https://github.com/crate/crate/pull/9801#discussion_r397933730", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * We can in a first phase fetch the values for [_fetchid, a],\n          \n          \n            \n             * In a first phase we can fetch the values for [_fetchid, a],", "author": "seut", "createdAt": "2020-03-25T15:13:13Z", "path": "sql/src/main/java/io/crate/planner/operators/Fetch.java", "diffHunk": "@@ -48,6 +48,35 @@\n import java.util.Map;\n import java.util.function.Function;\n \n+/**\n+ * <p>\n+ *   The fetch operator represents a 2 phase execution that is used to reduce value look-ups.\n+ * </p>\n+ *\n+ * For example:\n+ *\n+ * <pre>\n+ *     Limit[10]\n+ *      \u2514 OrderBy [a]\n+ *        \u2514 Collect [a, b, c]\n+ * </pre>\n+ *\n+ * Would fetch the values for all columns ([a, b, c]) {@code 10 * num_nodes} times.\n+ * With the fetch operator:\n+ *\n+ * <pre>\n+ *     Fetch [a, b, c]\n+ *      \u2514 Limit [10]\n+ *        \u2514 OrderBy [a]\n+ *          \u2514 Collect [_fetchid, a]\n+ * </pre>\n+ *\n+ * We can in a first phase fetch the values for [_fetchid, a],", "originalCommit": "e11f6d9b6ae42fe0864c9d985280552e9a948a79", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1e987fd6b256ca0766ddeab906b7e996cc0b411", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/operators/Fetch.java b/sql/src/main/java/io/crate/planner/operators/Fetch.java\nindex cfb1d39634..c34fd0d0ca 100644\n--- a/sql/src/main/java/io/crate/planner/operators/Fetch.java\n+++ b/sql/src/main/java/io/crate/planner/operators/Fetch.java\n\n@@ -71,7 +71,7 @@ import java.util.function.Function;\n  *          \u2514 Collect [_fetchid, a]\n  * </pre>\n  *\n- * We can in a first phase fetch the values for [_fetchid, a],\n+ * In a first phase we can fetch the values for [_fetchid, a],\n  * then do a sorted merge to apply the limit of 10, and afterwards fetch the values [b, c] for the remaining 10 _fetchids.\n  *\n  * Note: Fetch always requires a merge to the coordinator node.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzNDk5MQ==", "url": "https://github.com/crate/crate/pull/9801#discussion_r397934991", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * because `HashAggregate` needs all columns produce its result.\n          \n          \n            \n                 * because `HashAggregate` needs all columns to produce its result.", "author": "seut", "createdAt": "2020-03-25T15:14:45Z", "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlan.java", "diffHunk": "@@ -149,6 +149,40 @@ default boolean preferShardProjections() {\n      */\n     LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep);\n \n+    /**\n+     * Rewrite an operator and its children to utilize a \"query-then-fetch\" approach.\n+     * See {@link Fetch} for an explanation of query-then-fetch.\n+     * <pre>\n+     * This must propagate if possible. Example:\n+     *\n+     *     Limit[10]            // calls source.rewriteToFetch\n+     *      \u2514 Order [a ASC]     // should call source.rewriteToFetch\n+     *        \u2514 Collect [x, a, b]\n+     *\n+     * This results in:\n+     *\n+     *      Fetch[x, a, b]\n+     *       \u2514 Limit[10]\n+     *         \u2514 Order [a ASC]\n+     *           \u2514 Collect [_fetchid, a]\n+     *\n+     * Note that propagation only needs to happen if all operators can forward the `_fetchid`. Consider the following:\n+     *\n+     *      Limit[10]\n+     *        \u2514 HashAggregate[min(x), min(y)]\n+     *          \u2514 Limit[5]\n+     *            \u2514 Collect [x, y]\n+     *\n+     * In this case a call on `HashAggregate.rewriteToFetch` can return `null` to indicate that there is nothing to fetch,\n+     * because `HashAggregate` needs all columns produce its result.", "originalCommit": "e11f6d9b6ae42fe0864c9d985280552e9a948a79", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1e987fd6b256ca0766ddeab906b7e996cc0b411", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/operators/LogicalPlan.java b/sql/src/main/java/io/crate/planner/operators/LogicalPlan.java\nindex d799d43041..3a3dbb8e56 100644\n--- a/sql/src/main/java/io/crate/planner/operators/LogicalPlan.java\n+++ b/sql/src/main/java/io/crate/planner/operators/LogicalPlan.java\n\n@@ -174,7 +174,7 @@ public interface LogicalPlan extends Plan {\n      *            \u2514 Collect [x, y]\n      *\n      * In this case a call on `HashAggregate.rewriteToFetch` can return `null` to indicate that there is nothing to fetch,\n-     * because `HashAggregate` needs all columns produce its result.\n+     * because `HashAggregate` needs all columns to produce its result.\n      * It is *NOT* responsible to insert a `Fetch` below itself.\n      * </pre>\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzODU5NA==", "url": "https://github.com/crate/crate/pull/9801#discussion_r397938594", "bodyText": "\ud83d\udc4d", "author": "seut", "createdAt": "2020-03-25T15:19:23Z", "path": "sql/src/main/java/io/crate/planner/operators/LogicalPlanner.java", "diffHunk": "@@ -486,8 +486,27 @@ public static NodeOperationTree getNodeOperationTree(LogicalPlan logicalPlan,\n                                                          PlannerContext plannerContext,\n                                                          Row params,\n                                                          SubQueryResults subQueryResults) {\n-        ExecutionPlan executionPlan = logicalPlan.build(\n-            plannerContext, executor.projectionBuilder(), -1, 0, null, null, params, subQueryResults);\n+        ExecutionPlan executionPlan;\n+        try {\n+            executionPlan = logicalPlan.build(\n+                plannerContext, executor.projectionBuilder(), -1, 0, null, null, params, subQueryResults);\n+        } catch (Exception e) {\n+            // This should really only happen if there are planner bugs,\n+            // so the additional costs of creating a more informative exception shouldn't matter.", "originalCommit": "c9710624c4683d11e3d24774beb174fbd8617d76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1e987fd6b256ca0766ddeab906b7e996cc0b411", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/operators/LogicalPlanner.java b/sql/src/main/java/io/crate/planner/operators/LogicalPlanner.java\nindex 5b54fcb082..4eba7c9eba 100644\n--- a/sql/src/main/java/io/crate/planner/operators/LogicalPlanner.java\n+++ b/sql/src/main/java/io/crate/planner/operators/LogicalPlanner.java\n\n@@ -486,27 +486,8 @@ public class LogicalPlanner {\n                                                          PlannerContext plannerContext,\n                                                          Row params,\n                                                          SubQueryResults subQueryResults) {\n-        ExecutionPlan executionPlan;\n-        try {\n-            executionPlan = logicalPlan.build(\n-                plannerContext, executor.projectionBuilder(), -1, 0, null, null, params, subQueryResults);\n-        } catch (Exception e) {\n-            // This should really only happen if there are planner bugs,\n-            // so the additional costs of creating a more informative exception shouldn't matter.\n-            PrintContext printContext = new PrintContext();\n-            logicalPlan.print(printContext);\n-            IllegalArgumentException illegalArgumentException = new IllegalArgumentException(\n-                String.format(\n-                    Locale.ENGLISH,\n-                    \"Couldn't create execution plan from logical plan because of: %s:%n%s\",\n-                    e.getMessage(),\n-                    printContext.toString()\n-                ),\n-                e\n-            );\n-            illegalArgumentException.setStackTrace(e.getStackTrace());\n-            throw illegalArgumentException;\n-        }\n+        ExecutionPlan executionPlan = logicalPlan.build(\n+            plannerContext, executor.projectionBuilder(), -1, 0, null, null, params, subQueryResults);\n         return NodeOperationTreeGenerator.fromPlan(executionPlan, executor.localNodeId());\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk0MTQ5NQ==", "url": "https://github.com/crate/crate/pull/9801#discussion_r397941495", "bodyText": "Looks like there is no LogicalPlan test for this optimization, maybe worth creating one?", "author": "seut", "createdAt": "2020-03-25T15:22:57Z", "path": "sql/src/main/java/io/crate/planner/operators/NestedLoopJoin.java", "diffHunk": "@@ -284,6 +284,42 @@ public LogicalPlan pruneOutputsExcept(Collection<Symbol> outputsToKeep) {\n         );\n     }\n \n+    @Nullable\n+    @Override\n+    public FetchRewrite rewriteToFetch(Collection<Symbol> usedColumns) {\n+        ArrayList<Symbol> usedFromLeft = new ArrayList<>();\n+        ArrayList<Symbol> usedFromRight = new ArrayList<>();\n+        for (Symbol usedColumn : usedColumns) {\n+            SymbolVisitors.intersection(usedColumn, lhs.outputs(), usedFromLeft::add);\n+            SymbolVisitors.intersection(usedColumn, rhs.outputs(), usedFromRight::add);\n+        }\n+        if (joinCondition != null) {\n+            SymbolVisitors.intersection(joinCondition, lhs.outputs(), usedFromLeft::add);\n+            SymbolVisitors.intersection(joinCondition, rhs.outputs(), usedFromRight::add);\n+        }\n+        FetchRewrite lhsFetchRewrite = lhs.rewriteToFetch(usedFromLeft);\n+        if (lhsFetchRewrite == null) {\n+            return null;\n+        }\n+        FetchRewrite rhsFetchRewrite = rhs.rewriteToFetch(usedFromRight);\n+        if (rhsFetchRewrite == null) {\n+            return null;\n+        }\n+        return new FetchRewrite(\n+            Maps.concat(lhsFetchRewrite.replacedOutputs(), rhsFetchRewrite.replacedOutputs()),\n+            new NestedLoopJoin(\n+                lhsFetchRewrite.newPlan(),\n+                rhsFetchRewrite.newPlan(),\n+                joinType,\n+                joinCondition,\n+                isFiltered,\n+                topMostLeftRelation,\n+                orderByWasPushedDown,\n+                rewriteFilterOnOuterJoinToInnerJoinDone\n+            )\n+        );", "originalCommit": "c9710624c4683d11e3d24774beb174fbd8617d76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1e987fd6b256ca0766ddeab906b7e996cc0b411", "chunk": "diff --git a/sql/src/main/java/io/crate/planner/operators/NestedLoopJoin.java b/sql/src/main/java/io/crate/planner/operators/NestedLoopJoin.java\nindex beb98fe0ae..c9bbc8dc16 100644\n--- a/sql/src/main/java/io/crate/planner/operators/NestedLoopJoin.java\n+++ b/sql/src/main/java/io/crate/planner/operators/NestedLoopJoin.java\n\n@@ -284,42 +284,6 @@ public class NestedLoopJoin implements LogicalPlan {\n         );\n     }\n \n-    @Nullable\n-    @Override\n-    public FetchRewrite rewriteToFetch(Collection<Symbol> usedColumns) {\n-        ArrayList<Symbol> usedFromLeft = new ArrayList<>();\n-        ArrayList<Symbol> usedFromRight = new ArrayList<>();\n-        for (Symbol usedColumn : usedColumns) {\n-            SymbolVisitors.intersection(usedColumn, lhs.outputs(), usedFromLeft::add);\n-            SymbolVisitors.intersection(usedColumn, rhs.outputs(), usedFromRight::add);\n-        }\n-        if (joinCondition != null) {\n-            SymbolVisitors.intersection(joinCondition, lhs.outputs(), usedFromLeft::add);\n-            SymbolVisitors.intersection(joinCondition, rhs.outputs(), usedFromRight::add);\n-        }\n-        FetchRewrite lhsFetchRewrite = lhs.rewriteToFetch(usedFromLeft);\n-        if (lhsFetchRewrite == null) {\n-            return null;\n-        }\n-        FetchRewrite rhsFetchRewrite = rhs.rewriteToFetch(usedFromRight);\n-        if (rhsFetchRewrite == null) {\n-            return null;\n-        }\n-        return new FetchRewrite(\n-            Maps.concat(lhsFetchRewrite.replacedOutputs(), rhsFetchRewrite.replacedOutputs()),\n-            new NestedLoopJoin(\n-                lhsFetchRewrite.newPlan(),\n-                rhsFetchRewrite.newPlan(),\n-                joinType,\n-                joinCondition,\n-                isFiltered,\n-                topMostLeftRelation,\n-                orderByWasPushedDown,\n-                rewriteFilterOnOuterJoinToInnerJoinDone\n-            )\n-        );\n-    }\n-\n     private Tuple<Collection<String>, List<MergePhase>> configureExecution(ExecutionPlan left,\n                                                                            ExecutionPlan right,\n                                                                            PlannerContext plannerContext,\n"}}, {"oid": "a1e987fd6b256ca0766ddeab906b7e996cc0b411", "url": "https://github.com/crate/crate/commit/a1e987fd6b256ca0766ddeab906b7e996cc0b411", "message": "Enable query-then-fetch for Limit \u2192 Order \u2192 Collect", "committedDate": "2020-03-25T15:57:17Z", "type": "commit"}, {"oid": "443cd0fda2422fc54b7311ee9f477ffa3aa659e8", "url": "https://github.com/crate/crate/commit/443cd0fda2422fc54b7311ee9f477ffa3aa659e8", "message": "Support fetch rewrite for NestedLoopJoin", "committedDate": "2020-03-25T16:01:33Z", "type": "commit"}, {"oid": "443cd0fda2422fc54b7311ee9f477ffa3aa659e8", "url": "https://github.com/crate/crate/commit/443cd0fda2422fc54b7311ee9f477ffa3aa659e8", "message": "Support fetch rewrite for NestedLoopJoin", "committedDate": "2020-03-25T16:01:33Z", "type": "forcePushed"}]}