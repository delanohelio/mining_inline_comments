{"pr_number": 9915, "pr_title": "New TimeTZType to be returned by scalar function current_time", "pr_createdAt": "2020-05-04T06:41:20Z", "pr_url": "https://github.com/crate/crate/pull/9915", "timeline": [{"oid": "bbc4d8db07481bc91999ce5627d4978bc31661c9", "url": "https://github.com/crate/crate/commit/bbc4d8db07481bc91999ce5627d4978bc31661c9", "message": "Fix postgres.rst", "committedDate": "2020-05-06T17:26:05Z", "type": "forcePushed"}, {"oid": "b347cb1b845a7143bdf102b0d9540a0d38d5909c", "url": "https://github.com/crate/crate/commit/b347cb1b845a7143bdf102b0d9540a0d38d5909c", "message": "Fist idea on how to implement TimeType on an Integer, WIP", "committedDate": "2020-05-06T17:37:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxMzcwNQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r421313705", "bodyText": "Why is BOOLEAN allowed here?", "author": "mfussenegger", "createdAt": "2020-05-07T08:01:11Z", "path": "common/src/main/java/io/crate/types/DataTypes.java", "diffHunk": "@@ -169,6 +174,7 @@\n         entry(IP.id(), Set.of(STRING.id())),\n         entry(TIMESTAMPZ.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id(), TIMESTAMP.id())),\n         entry(TIMESTAMP.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id(), TIMESTAMPZ.id())),\n+        entry(TIME.id(), Set.of(BOOLEAN.id(), STRING.id(), INTEGER.id())),", "originalCommit": "9c039c0436c10d2017eed7295ed74f94aec82d2b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b37861c93ef185dd14de0f637ef7dd92120ed5de", "chunk": "diff --git a/common/src/main/java/io/crate/types/DataTypes.java b/common/src/main/java/io/crate/types/DataTypes.java\ndeleted file mode 100644\nindex cf226bd389..0000000000\n--- a/common/src/main/java/io/crate/types/DataTypes.java\n+++ /dev/null\n\n@@ -1,486 +0,0 @@\n-/*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n- */\n-\n-package io.crate.types;\n-\n-import io.crate.Streamer;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.apache.lucene.util.BytesRef;\n-import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.io.stream.Writeable;\n-import org.locationtech.spatial4j.shape.impl.PointImpl;\n-import org.locationtech.spatial4j.shape.jts.JtsPoint;\n-\n-import javax.annotation.Nullable;\n-import java.io.IOException;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.RandomAccess;\n-import java.util.Set;\n-import java.util.stream.Stream;\n-\n-import static java.util.Map.entry;\n-import static java.util.stream.Collectors.toSet;\n-\n-public final class DataTypes {\n-\n-    private static final Logger LOGGER = LogManager.getLogger(DataTypes.class);\n-\n-    /**\n-     * If you add types here make sure to update the SizeEstimatorFactory in the SQL module.\n-     */\n-    public static final UndefinedType UNDEFINED = UndefinedType.INSTANCE;\n-    public static final NotSupportedType NOT_SUPPORTED = NotSupportedType.INSTANCE;\n-\n-    public static final ByteType BYTE = ByteType.INSTANCE;\n-    public static final BooleanType BOOLEAN = BooleanType.INSTANCE;\n-\n-    public static final StringType STRING = StringType.INSTANCE;\n-    public static final IpType IP = IpType.INSTANCE;\n-\n-    public static final DoubleType DOUBLE = DoubleType.INSTANCE;\n-    public static final FloatType FLOAT = FloatType.INSTANCE;\n-\n-    public static final ShortType SHORT = ShortType.INSTANCE;\n-    public static final IntegerType INTEGER = IntegerType.INSTANCE;\n-    public static final LongType LONG = LongType.INSTANCE;\n-\n-    public static final TimeType TIME = TimeType.INSTANCE;\n-\n-    public static final TimestampType TIMESTAMPZ = TimestampType.INSTANCE_WITH_TZ;\n-    public static final TimestampType TIMESTAMP = TimestampType.INSTANCE_WITHOUT_TZ;\n-\n-    public static final GeoPointType GEO_POINT = GeoPointType.INSTANCE;\n-    public static final GeoShapeType GEO_SHAPE = GeoShapeType.INSTANCE;\n-\n-    public static final ArrayType<Double> DOUBLE_ARRAY = new ArrayType<>(DOUBLE);\n-    public static final ArrayType<Float> FLOAT_ARRAY = new ArrayType<>(FLOAT);\n-    public static final ArrayType<String> STRING_ARRAY = new ArrayType<>(STRING);\n-    public static final ArrayType<Integer> INTEGER_ARRAY = new ArrayType<>(INTEGER);\n-    public static final ArrayType<Short> SHORT_ARRAY = new ArrayType<>(SHORT);\n-    public static final ArrayType<Long> BIGINT_ARRAY = new ArrayType<>(LONG);\n-\n-    public static final IntervalType INTERVAL = IntervalType.INSTANCE;\n-\n-    public static final ObjectType UNTYPED_OBJECT = ObjectType.UNTYPED;\n-\n-    public static Set<String> PRIMITIVE_TYPE_NAMES_WITH_SPACES = Set.of(\n-        TIMESTAMPZ.getName(),\n-        TIMESTAMP.getName(),\n-        TIME.getName(),\n-        DOUBLE.getName()\n-    );\n-\n-    public static final List<DataType> PRIMITIVE_TYPES = List.of(\n-        BYTE,\n-        BOOLEAN,\n-        STRING,\n-        IP,\n-        DOUBLE,\n-        FLOAT,\n-        SHORT,\n-        INTEGER,\n-        INTERVAL,\n-        LONG,\n-        TIME,\n-        TIMESTAMPZ,\n-        TIMESTAMP\n-    );\n-\n-    public static final Set<DataType> STORAGE_UNSUPPORTED = Set.of(\n-        INTERVAL\n-    );\n-\n-    public static final List<DataType> NUMERIC_PRIMITIVE_TYPES = List.of(\n-        DOUBLE,\n-        FLOAT,\n-        BYTE,\n-        SHORT,\n-        INTEGER,\n-        LONG\n-    );\n-\n-    /**\n-     * Type registry mapping type ids to the according data type instance.\n-     */\n-    private static final Map<Integer, Writeable.Reader<DataType<?>>> TYPE_REGISTRY = new HashMap<>(\n-        Map.ofEntries(\n-            entry(UndefinedType.ID, in -> UNDEFINED),\n-            entry(NotSupportedType.ID, in -> NOT_SUPPORTED),\n-            entry(ByteType.ID, in -> BYTE),\n-            entry(BooleanType.ID, in -> BOOLEAN),\n-            entry(StringType.ID, in -> STRING),\n-            entry(IpType.ID, in -> IP),\n-            entry(DoubleType.ID, in -> DOUBLE),\n-            entry(FloatType.ID, in -> FLOAT),\n-            entry(ShortType.ID, in -> SHORT),\n-            entry(IntegerType.ID, in -> INTEGER),\n-            entry(LongType.ID, in -> LONG),\n-            entry(TimeType.ID, in -> TIME),\n-            entry(TimestampType.ID_WITH_TZ, in -> TIMESTAMPZ),\n-            entry(TimestampType.ID_WITHOUT_TZ, in -> TIMESTAMP),\n-            entry(ObjectType.ID, ObjectType::new),\n-            entry(UncheckedObjectType.ID, in -> UncheckedObjectType.INSTANCE),\n-            entry(GeoPointType.ID, in -> GEO_POINT),\n-            entry(GeoShapeType.ID, in -> GEO_SHAPE),\n-            entry(ArrayType.ID, ArrayType::new),\n-            entry(IntervalType.ID, in -> INTERVAL),\n-            entry(RowType.ID, RowType::new))\n-        );\n-\n-    private static final Set<Integer> NUMBER_CONVERSIONS = Stream.concat(\n-        Stream.of(BOOLEAN, STRING, TIMESTAMPZ, TIMESTAMP, IP),\n-        NUMERIC_PRIMITIVE_TYPES.stream()\n-    ).map(DataType::id).collect(toSet());\n-\n-    // allowed conversion from key to one of the value types\n-    // the key type itself does not need to be in the value set\n-    static final Map<Integer, Set<Integer>> ALLOWED_CONVERSIONS = Map.ofEntries(\n-        entry(BYTE.id(), NUMBER_CONVERSIONS),\n-        entry(SHORT.id(), NUMBER_CONVERSIONS),\n-        entry(INTEGER.id(), NUMBER_CONVERSIONS),\n-        entry(LONG.id(), NUMBER_CONVERSIONS),\n-        entry(FLOAT.id(), NUMBER_CONVERSIONS),\n-        entry(DOUBLE.id(), NUMBER_CONVERSIONS),\n-        entry(BOOLEAN.id(), Set.of(STRING.id())),\n-        entry(STRING.id(), Stream.concat(\n-            Stream.of(GEO_SHAPE.id(), GEO_POINT.id(), ObjectType.ID),\n-            NUMBER_CONVERSIONS.stream()\n-        ).collect(toSet())),\n-        entry(IP.id(), Set.of(STRING.id())),\n-        entry(TIMESTAMPZ.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id(), TIMESTAMP.id())),\n-        entry(TIMESTAMP.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id(), TIMESTAMPZ.id())),\n-        entry(TIME.id(), Set.of(BOOLEAN.id(), STRING.id(), INTEGER.id())),\n-        entry(UNDEFINED.id(), Set.of()), // actually convertible to every type, see NullType\n-        entry(GEO_POINT.id(), Set.of()),\n-        entry(GEO_SHAPE.id(), Set.of(ObjectType.ID)),\n-        entry(ObjectType.ID, Set.of(GEO_SHAPE.id())),\n-        entry(ArrayType.ID, Set.of()) // convertability handled in ArrayType\n-    );\n-\n-    /**\n-     * Contains number conversions which are \"safe\" (= a conversion would not reduce the number of bytes\n-     * used to store the value)\n-     */\n-    private static final Map<Integer, Set<DataType>> SAFE_CONVERSIONS = Map.of(\n-        BYTE.id(), Set.of(SHORT, INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n-        SHORT.id(), Set.of(INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n-        INTEGER.id(), Set.of(LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n-        LONG.id(), Set.of(TIMESTAMPZ, TIMESTAMP, DOUBLE),\n-        FLOAT.id(), Set.of(TIME, DOUBLE));\n-\n-    public static boolean isArray(DataType<?> type) {\n-        return type.id() == ArrayType.ID;\n-    }\n-\n-    public static List<DataType> listFromStream(StreamInput in) throws IOException {\n-        return in.readList(DataTypes::fromStream);\n-    }\n-\n-    public static DataType fromStream(StreamInput in) throws IOException {\n-        int i = in.readVInt();\n-        try {\n-            return TYPE_REGISTRY.get(i).read(in);\n-        } catch (NullPointerException e) {\n-            LOGGER.error(String.format(Locale.ENGLISH, \"%d is missing in TYPE_REGISTRY\", i), e);\n-            throw e;\n-        }\n-    }\n-\n-    public static void toStream(Collection<? extends DataType> types, StreamOutput out) throws IOException {\n-        out.writeVInt(types.size());\n-        for (DataType type : types) {\n-            toStream(type, out);\n-        }\n-    }\n-\n-    public static void toStream(DataType type, StreamOutput out) throws IOException {\n-        out.writeVInt(type.id());\n-        type.writeTo(out);\n-    }\n-\n-    private static final Map<Class<?>, DataType<?>> POJO_TYPE_MAPPING = Map.ofEntries(\n-        entry(Double.class, DOUBLE),\n-        entry(Float.class, FLOAT),\n-        entry(Integer.class, INTEGER),\n-        entry(Long.class, LONG),\n-        entry(Short.class, SHORT),\n-        entry(Byte.class, BYTE),\n-        entry(Boolean.class, BOOLEAN),\n-        entry(Map.class, UNTYPED_OBJECT),\n-        entry(String.class, STRING),\n-        entry(BytesRef.class, STRING),\n-        entry(PointImpl.class, GEO_POINT),\n-        entry(JtsPoint.class, GEO_POINT),\n-        entry(Character.class, STRING));\n-\n-    public static DataType<?> guessType(Object value) {\n-        if (value == null) {\n-            return UNDEFINED;\n-        } else if (value instanceof Map) {\n-            return UNTYPED_OBJECT;\n-        } else if (value instanceof List) {\n-            return valueFromList((List) value);\n-        } else if (value.getClass().isArray()) {\n-            return valueFromList(Arrays.asList((Object[]) value));\n-        }\n-        return POJO_TYPE_MAPPING.get(value.getClass());\n-    }\n-\n-    /**\n-     * @return Returns the closest integral type for a numeric type or null\n-     */\n-    @Nullable\n-    public static DataType getIntegralReturnType(DataType argumentType) {\n-        switch (argumentType.id()) {\n-            case ByteType.ID:\n-            case ShortType.ID:\n-            case IntegerType.ID:\n-            case FloatType.ID:\n-                return DataTypes.INTEGER;\n-\n-            case DoubleType.ID:\n-            case LongType.ID:\n-                return DataTypes.LONG;\n-\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    private static DataType<?> valueFromList(List<Object> value) {\n-        DataType<?> highest = DataTypes.UNDEFINED;\n-        for (Object o : value) {\n-            if (o == null) {\n-                continue;\n-            }\n-            DataType<?> current = guessType(o);\n-            // JSON libraries tend to optimize things like [ 0.0, 1.2 ] to [ 0, 1.2 ]; so we allow mixed types\n-            // in such cases.\n-            if (!current.equals(highest) && !safeConversionPossible(current, highest)) {\n-                throw new IllegalArgumentException(\n-                    \"Mixed dataTypes inside a list are not supported. Found \" + highest + \" and \" + current);\n-            }\n-            if (current.precedes(highest)) {\n-                highest = current;\n-            }\n-        }\n-        return new ArrayType<>(highest);\n-    }\n-\n-    private static boolean safeConversionPossible(DataType type1, DataType type2) {\n-        final DataType source;\n-        final DataType target;\n-        if (type1.precedes(type2)) {\n-            source = type2;\n-            target = type1;\n-        } else {\n-            source = type1;\n-            target = type2;\n-        }\n-        if (source.id() == DataTypes.UNDEFINED.id()) {\n-            return true;\n-        }\n-        Set<DataType> conversions = SAFE_CONVERSIONS.get(source.id());\n-        return conversions != null && conversions.contains(target);\n-    }\n-\n-    private static final Map<String, DataType> TYPES_BY_NAME_OR_ALIAS = Map.ofEntries(\n-        entry(UNDEFINED.getName(), UNDEFINED),\n-        entry(BYTE.getName(), BYTE),\n-        entry(BOOLEAN.getName(), BOOLEAN),\n-        entry(STRING.getName(), STRING),\n-        entry(IP.getName(), IP),\n-        entry(DOUBLE.getName(), DOUBLE),\n-        entry(FLOAT.getName(), FLOAT),\n-        entry(SHORT.getName(), SHORT),\n-        entry(INTEGER.getName(), INTEGER),\n-        entry(LONG.getName(), LONG),\n-        entry(RowType.EMPTY.getName(), RowType.EMPTY),\n-        entry(TIME.getName(), TIME),\n-        entry(TIMESTAMPZ.getName(), TIMESTAMPZ),\n-        entry(TIMESTAMP.getName(), TIMESTAMP),\n-        entry(ObjectType.NAME, UNTYPED_OBJECT),\n-        entry(GEO_POINT.getName(), GEO_POINT),\n-        entry(GEO_SHAPE.getName(), GEO_SHAPE),\n-        entry(\"int2\", SHORT),\n-        entry(\"int\", INTEGER),\n-        entry(\"int4\", INTEGER),\n-        entry(\"int8\", LONG),\n-        entry(\"name\", STRING),\n-        entry(\"regproc\", STRING),\n-        entry(\"long\", LONG),\n-        entry(\"byte\", BYTE),\n-        entry(\"short\", SHORT),\n-        entry(\"float\", FLOAT),\n-        entry(\"double\", DOUBLE),\n-        entry(\"string\", STRING),\n-        entry(\"varchar\", STRING),\n-        entry(\"character varying\", STRING),\n-        entry(\"time\", TIME),\n-        entry(\"timestamptz\", TIMESTAMPZ),\n-        // The usage of the `timestamp` data type as a data type with time\n-        // zone is deprecate, use `timestamp with time zone` or `timestamptz`\n-        // instead. In future releases the `timestamp` data type will be changed\n-        // to behave as a timestamp without time zone. For now, we use the\n-        // `timestamp` as an alias for the `timestamp with time zone` data type\n-        // to warn users about the data type semantic change and give a time\n-        // to adjust to the change.\n-        entry(\"timestamp\", TIMESTAMPZ),\n-        entry(\"interval\", INTERVAL));\n-\n-    public static DataType<?> ofName(String typeName) {\n-        DataType<?> dataType = ofNameOrNull(typeName);\n-        if (dataType == null) {\n-            throw new IllegalArgumentException(\"Cannot find data type: \" + typeName);\n-        }\n-        return dataType;\n-    }\n-\n-    @Nullable\n-    public static DataType<?> ofNameOrNull(String typeName) {\n-        return TYPES_BY_NAME_OR_ALIAS.get(typeName);\n-    }\n-\n-    private static final Map<String, DataType> MAPPING_NAMES_TO_TYPES = Map.ofEntries(\n-        entry(\"date\", DataTypes.TIMESTAMPZ),\n-        entry(\"string\", DataTypes.STRING),\n-        entry(\"keyword\", DataTypes.STRING),\n-        entry(\"text\", DataTypes.STRING),\n-        entry(\"boolean\", DataTypes.BOOLEAN),\n-        entry(\"byte\", DataTypes.BYTE),\n-        entry(\"short\", DataTypes.SHORT),\n-        entry(\"integer\", DataTypes.INTEGER),\n-        entry(\"long\", DataTypes.LONG),\n-        entry(\"float\", DataTypes.FLOAT),\n-        entry(\"double\", DataTypes.DOUBLE),\n-        entry(\"ip\", DataTypes.IP),\n-        entry(\"geo_point\", DataTypes.GEO_POINT),\n-        entry(\"geo_shape\", DataTypes.GEO_SHAPE),\n-        entry(\"object\", UNTYPED_OBJECT),\n-        entry(\"nested\", UNTYPED_OBJECT),\n-        entry(\"interval\", DataTypes.INTERVAL)\n-    );\n-\n-    private static final Map<Integer, String> TYPE_IDS_TO_MAPPINGS = Map.ofEntries(\n-        entry(TIME.id(), \"integer\"),\n-        entry(TIMESTAMPZ.id(), \"date\"),\n-        entry(TIMESTAMP.id(), \"date\"),\n-        entry(STRING.id(), \"text\"),\n-        entry(BYTE.id(), \"byte\"),\n-        entry(BOOLEAN.id(), \"boolean\"),\n-        entry(IP.id(), \"ip\"),\n-        entry(DOUBLE.id(), \"double\"),\n-        entry(FLOAT.id(), \"float\"),\n-        entry(SHORT.id(), \"short\"),\n-        entry(INTEGER.id(), \"integer\"),\n-        entry(LONG.id(), \"long\"),\n-        entry(ObjectType.ID, \"object\"),\n-        entry(GEO_SHAPE.id(), \"geo_shape\"),\n-        entry(GEO_POINT.id(), \"geo_point\"),\n-        entry(INTERVAL.id(), \"interval\")\n-    );\n-\n-    @Nullable\n-    public static String esMappingNameFrom(int typeId) {\n-        return TYPE_IDS_TO_MAPPINGS.get(typeId);\n-    }\n-\n-    @Nullable\n-    public static DataType ofMappingName(String name) {\n-        return MAPPING_NAMES_TO_TYPES.get(name);\n-    }\n-\n-    public static boolean isPrimitive(DataType type) {\n-        return PRIMITIVE_TYPES.contains(type);\n-    }\n-\n-    /**\n-     * Register a custom data type to the type registry.\n-     *\n-     * <p>Note: If registering is done inside a static block, be sure the class is loaded initially.\n-     * Otherwise it might not be registered on all nodes.\n-     * </p>\n-     */\n-    public static void register(int id, Writeable.Reader<DataType<?>> dataType) {\n-        if (TYPE_REGISTRY.put(id, dataType) != null) {\n-            throw new IllegalArgumentException(\"Already got a dataType with id \" + id);\n-        }\n-    }\n-\n-    public static Streamer[] getStreamers(Collection<? extends DataType> dataTypes) {\n-        Streamer[] streamer = new Streamer[dataTypes.size()];\n-        int idx = 0;\n-        for (DataType dataType : dataTypes) {\n-            streamer[idx] = dataType.streamer();\n-            idx++;\n-        }\n-        return streamer;\n-    }\n-\n-    public static boolean compareTypesById(DataType<?> left, DataType<?> right) {\n-        if (left.id() != right.id()) {\n-            return false;\n-        } else if (isArray(left)) {\n-            return compareTypesById(\n-                ((ArrayType) left).innerType(),\n-                ((ArrayType) right).innerType());\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    public static boolean compareTypesById(List<DataType> left, List<DataType> right) {\n-        if (left.size() != right.size()) {\n-            return false;\n-        }\n-        assert left instanceof RandomAccess && right instanceof RandomAccess\n-            : \"data type lists should support RandomAccess for fast lookups\";\n-        for (int i = 0; i < left.size(); i++) {\n-            if (!compareTypesById(left.get(i), right.get(i))) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Returns the first data type that is not {@link UndefinedType}, or {@code UNDEFINED} if none found.\n-     */\n-    public static DataType<?> tryFindNotNullType(List<DataType> dataTypes) {\n-        return dataTypes.stream()\n-            .filter(t -> t != UNDEFINED)\n-            .findFirst().orElse(UNDEFINED);\n-    }\n-\n-    public static DataType<?> fromId(Integer id) {\n-        return TYPES_BY_NAME_OR_ALIAS.values().stream()\n-            .filter(x -> x.id() == id)\n-            .findFirst()\n-            .orElse(DataTypes.UNDEFINED);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxNDI2Ng==", "url": "https://github.com/crate/crate/pull/9915#discussion_r421314266", "bodyText": "Is  float -> time really a safe (lossless) conversion?", "author": "mfussenegger", "createdAt": "2020-05-07T08:02:07Z", "path": "common/src/main/java/io/crate/types/DataTypes.java", "diffHunk": "@@ -181,11 +187,11 @@\n      * used to store the value)\n      */\n     private static final Map<Integer, Set<DataType>> SAFE_CONVERSIONS = Map.of(\n-        BYTE.id(), Set.of(SHORT, INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, FLOAT, DOUBLE),\n-        SHORT.id(), Set.of(INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, FLOAT, DOUBLE),\n-        INTEGER.id(), Set.of(LONG, TIMESTAMPZ, TIMESTAMP, FLOAT, DOUBLE),\n+        BYTE.id(), Set.of(SHORT, INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n+        SHORT.id(), Set.of(INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n+        INTEGER.id(), Set.of(LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n         LONG.id(), Set.of(TIMESTAMPZ, TIMESTAMP, DOUBLE),\n-        FLOAT.id(), Set.of(DOUBLE));\n+        FLOAT.id(), Set.of(TIME, DOUBLE));", "originalCommit": "9c039c0436c10d2017eed7295ed74f94aec82d2b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b37861c93ef185dd14de0f637ef7dd92120ed5de", "chunk": "diff --git a/common/src/main/java/io/crate/types/DataTypes.java b/common/src/main/java/io/crate/types/DataTypes.java\ndeleted file mode 100644\nindex cf226bd389..0000000000\n--- a/common/src/main/java/io/crate/types/DataTypes.java\n+++ /dev/null\n\n@@ -1,486 +0,0 @@\n-/*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n- */\n-\n-package io.crate.types;\n-\n-import io.crate.Streamer;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.apache.lucene.util.BytesRef;\n-import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.io.stream.Writeable;\n-import org.locationtech.spatial4j.shape.impl.PointImpl;\n-import org.locationtech.spatial4j.shape.jts.JtsPoint;\n-\n-import javax.annotation.Nullable;\n-import java.io.IOException;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.RandomAccess;\n-import java.util.Set;\n-import java.util.stream.Stream;\n-\n-import static java.util.Map.entry;\n-import static java.util.stream.Collectors.toSet;\n-\n-public final class DataTypes {\n-\n-    private static final Logger LOGGER = LogManager.getLogger(DataTypes.class);\n-\n-    /**\n-     * If you add types here make sure to update the SizeEstimatorFactory in the SQL module.\n-     */\n-    public static final UndefinedType UNDEFINED = UndefinedType.INSTANCE;\n-    public static final NotSupportedType NOT_SUPPORTED = NotSupportedType.INSTANCE;\n-\n-    public static final ByteType BYTE = ByteType.INSTANCE;\n-    public static final BooleanType BOOLEAN = BooleanType.INSTANCE;\n-\n-    public static final StringType STRING = StringType.INSTANCE;\n-    public static final IpType IP = IpType.INSTANCE;\n-\n-    public static final DoubleType DOUBLE = DoubleType.INSTANCE;\n-    public static final FloatType FLOAT = FloatType.INSTANCE;\n-\n-    public static final ShortType SHORT = ShortType.INSTANCE;\n-    public static final IntegerType INTEGER = IntegerType.INSTANCE;\n-    public static final LongType LONG = LongType.INSTANCE;\n-\n-    public static final TimeType TIME = TimeType.INSTANCE;\n-\n-    public static final TimestampType TIMESTAMPZ = TimestampType.INSTANCE_WITH_TZ;\n-    public static final TimestampType TIMESTAMP = TimestampType.INSTANCE_WITHOUT_TZ;\n-\n-    public static final GeoPointType GEO_POINT = GeoPointType.INSTANCE;\n-    public static final GeoShapeType GEO_SHAPE = GeoShapeType.INSTANCE;\n-\n-    public static final ArrayType<Double> DOUBLE_ARRAY = new ArrayType<>(DOUBLE);\n-    public static final ArrayType<Float> FLOAT_ARRAY = new ArrayType<>(FLOAT);\n-    public static final ArrayType<String> STRING_ARRAY = new ArrayType<>(STRING);\n-    public static final ArrayType<Integer> INTEGER_ARRAY = new ArrayType<>(INTEGER);\n-    public static final ArrayType<Short> SHORT_ARRAY = new ArrayType<>(SHORT);\n-    public static final ArrayType<Long> BIGINT_ARRAY = new ArrayType<>(LONG);\n-\n-    public static final IntervalType INTERVAL = IntervalType.INSTANCE;\n-\n-    public static final ObjectType UNTYPED_OBJECT = ObjectType.UNTYPED;\n-\n-    public static Set<String> PRIMITIVE_TYPE_NAMES_WITH_SPACES = Set.of(\n-        TIMESTAMPZ.getName(),\n-        TIMESTAMP.getName(),\n-        TIME.getName(),\n-        DOUBLE.getName()\n-    );\n-\n-    public static final List<DataType> PRIMITIVE_TYPES = List.of(\n-        BYTE,\n-        BOOLEAN,\n-        STRING,\n-        IP,\n-        DOUBLE,\n-        FLOAT,\n-        SHORT,\n-        INTEGER,\n-        INTERVAL,\n-        LONG,\n-        TIME,\n-        TIMESTAMPZ,\n-        TIMESTAMP\n-    );\n-\n-    public static final Set<DataType> STORAGE_UNSUPPORTED = Set.of(\n-        INTERVAL\n-    );\n-\n-    public static final List<DataType> NUMERIC_PRIMITIVE_TYPES = List.of(\n-        DOUBLE,\n-        FLOAT,\n-        BYTE,\n-        SHORT,\n-        INTEGER,\n-        LONG\n-    );\n-\n-    /**\n-     * Type registry mapping type ids to the according data type instance.\n-     */\n-    private static final Map<Integer, Writeable.Reader<DataType<?>>> TYPE_REGISTRY = new HashMap<>(\n-        Map.ofEntries(\n-            entry(UndefinedType.ID, in -> UNDEFINED),\n-            entry(NotSupportedType.ID, in -> NOT_SUPPORTED),\n-            entry(ByteType.ID, in -> BYTE),\n-            entry(BooleanType.ID, in -> BOOLEAN),\n-            entry(StringType.ID, in -> STRING),\n-            entry(IpType.ID, in -> IP),\n-            entry(DoubleType.ID, in -> DOUBLE),\n-            entry(FloatType.ID, in -> FLOAT),\n-            entry(ShortType.ID, in -> SHORT),\n-            entry(IntegerType.ID, in -> INTEGER),\n-            entry(LongType.ID, in -> LONG),\n-            entry(TimeType.ID, in -> TIME),\n-            entry(TimestampType.ID_WITH_TZ, in -> TIMESTAMPZ),\n-            entry(TimestampType.ID_WITHOUT_TZ, in -> TIMESTAMP),\n-            entry(ObjectType.ID, ObjectType::new),\n-            entry(UncheckedObjectType.ID, in -> UncheckedObjectType.INSTANCE),\n-            entry(GeoPointType.ID, in -> GEO_POINT),\n-            entry(GeoShapeType.ID, in -> GEO_SHAPE),\n-            entry(ArrayType.ID, ArrayType::new),\n-            entry(IntervalType.ID, in -> INTERVAL),\n-            entry(RowType.ID, RowType::new))\n-        );\n-\n-    private static final Set<Integer> NUMBER_CONVERSIONS = Stream.concat(\n-        Stream.of(BOOLEAN, STRING, TIMESTAMPZ, TIMESTAMP, IP),\n-        NUMERIC_PRIMITIVE_TYPES.stream()\n-    ).map(DataType::id).collect(toSet());\n-\n-    // allowed conversion from key to one of the value types\n-    // the key type itself does not need to be in the value set\n-    static final Map<Integer, Set<Integer>> ALLOWED_CONVERSIONS = Map.ofEntries(\n-        entry(BYTE.id(), NUMBER_CONVERSIONS),\n-        entry(SHORT.id(), NUMBER_CONVERSIONS),\n-        entry(INTEGER.id(), NUMBER_CONVERSIONS),\n-        entry(LONG.id(), NUMBER_CONVERSIONS),\n-        entry(FLOAT.id(), NUMBER_CONVERSIONS),\n-        entry(DOUBLE.id(), NUMBER_CONVERSIONS),\n-        entry(BOOLEAN.id(), Set.of(STRING.id())),\n-        entry(STRING.id(), Stream.concat(\n-            Stream.of(GEO_SHAPE.id(), GEO_POINT.id(), ObjectType.ID),\n-            NUMBER_CONVERSIONS.stream()\n-        ).collect(toSet())),\n-        entry(IP.id(), Set.of(STRING.id())),\n-        entry(TIMESTAMPZ.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id(), TIMESTAMP.id())),\n-        entry(TIMESTAMP.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id(), TIMESTAMPZ.id())),\n-        entry(TIME.id(), Set.of(BOOLEAN.id(), STRING.id(), INTEGER.id())),\n-        entry(UNDEFINED.id(), Set.of()), // actually convertible to every type, see NullType\n-        entry(GEO_POINT.id(), Set.of()),\n-        entry(GEO_SHAPE.id(), Set.of(ObjectType.ID)),\n-        entry(ObjectType.ID, Set.of(GEO_SHAPE.id())),\n-        entry(ArrayType.ID, Set.of()) // convertability handled in ArrayType\n-    );\n-\n-    /**\n-     * Contains number conversions which are \"safe\" (= a conversion would not reduce the number of bytes\n-     * used to store the value)\n-     */\n-    private static final Map<Integer, Set<DataType>> SAFE_CONVERSIONS = Map.of(\n-        BYTE.id(), Set.of(SHORT, INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n-        SHORT.id(), Set.of(INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n-        INTEGER.id(), Set.of(LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n-        LONG.id(), Set.of(TIMESTAMPZ, TIMESTAMP, DOUBLE),\n-        FLOAT.id(), Set.of(TIME, DOUBLE));\n-\n-    public static boolean isArray(DataType<?> type) {\n-        return type.id() == ArrayType.ID;\n-    }\n-\n-    public static List<DataType> listFromStream(StreamInput in) throws IOException {\n-        return in.readList(DataTypes::fromStream);\n-    }\n-\n-    public static DataType fromStream(StreamInput in) throws IOException {\n-        int i = in.readVInt();\n-        try {\n-            return TYPE_REGISTRY.get(i).read(in);\n-        } catch (NullPointerException e) {\n-            LOGGER.error(String.format(Locale.ENGLISH, \"%d is missing in TYPE_REGISTRY\", i), e);\n-            throw e;\n-        }\n-    }\n-\n-    public static void toStream(Collection<? extends DataType> types, StreamOutput out) throws IOException {\n-        out.writeVInt(types.size());\n-        for (DataType type : types) {\n-            toStream(type, out);\n-        }\n-    }\n-\n-    public static void toStream(DataType type, StreamOutput out) throws IOException {\n-        out.writeVInt(type.id());\n-        type.writeTo(out);\n-    }\n-\n-    private static final Map<Class<?>, DataType<?>> POJO_TYPE_MAPPING = Map.ofEntries(\n-        entry(Double.class, DOUBLE),\n-        entry(Float.class, FLOAT),\n-        entry(Integer.class, INTEGER),\n-        entry(Long.class, LONG),\n-        entry(Short.class, SHORT),\n-        entry(Byte.class, BYTE),\n-        entry(Boolean.class, BOOLEAN),\n-        entry(Map.class, UNTYPED_OBJECT),\n-        entry(String.class, STRING),\n-        entry(BytesRef.class, STRING),\n-        entry(PointImpl.class, GEO_POINT),\n-        entry(JtsPoint.class, GEO_POINT),\n-        entry(Character.class, STRING));\n-\n-    public static DataType<?> guessType(Object value) {\n-        if (value == null) {\n-            return UNDEFINED;\n-        } else if (value instanceof Map) {\n-            return UNTYPED_OBJECT;\n-        } else if (value instanceof List) {\n-            return valueFromList((List) value);\n-        } else if (value.getClass().isArray()) {\n-            return valueFromList(Arrays.asList((Object[]) value));\n-        }\n-        return POJO_TYPE_MAPPING.get(value.getClass());\n-    }\n-\n-    /**\n-     * @return Returns the closest integral type for a numeric type or null\n-     */\n-    @Nullable\n-    public static DataType getIntegralReturnType(DataType argumentType) {\n-        switch (argumentType.id()) {\n-            case ByteType.ID:\n-            case ShortType.ID:\n-            case IntegerType.ID:\n-            case FloatType.ID:\n-                return DataTypes.INTEGER;\n-\n-            case DoubleType.ID:\n-            case LongType.ID:\n-                return DataTypes.LONG;\n-\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    private static DataType<?> valueFromList(List<Object> value) {\n-        DataType<?> highest = DataTypes.UNDEFINED;\n-        for (Object o : value) {\n-            if (o == null) {\n-                continue;\n-            }\n-            DataType<?> current = guessType(o);\n-            // JSON libraries tend to optimize things like [ 0.0, 1.2 ] to [ 0, 1.2 ]; so we allow mixed types\n-            // in such cases.\n-            if (!current.equals(highest) && !safeConversionPossible(current, highest)) {\n-                throw new IllegalArgumentException(\n-                    \"Mixed dataTypes inside a list are not supported. Found \" + highest + \" and \" + current);\n-            }\n-            if (current.precedes(highest)) {\n-                highest = current;\n-            }\n-        }\n-        return new ArrayType<>(highest);\n-    }\n-\n-    private static boolean safeConversionPossible(DataType type1, DataType type2) {\n-        final DataType source;\n-        final DataType target;\n-        if (type1.precedes(type2)) {\n-            source = type2;\n-            target = type1;\n-        } else {\n-            source = type1;\n-            target = type2;\n-        }\n-        if (source.id() == DataTypes.UNDEFINED.id()) {\n-            return true;\n-        }\n-        Set<DataType> conversions = SAFE_CONVERSIONS.get(source.id());\n-        return conversions != null && conversions.contains(target);\n-    }\n-\n-    private static final Map<String, DataType> TYPES_BY_NAME_OR_ALIAS = Map.ofEntries(\n-        entry(UNDEFINED.getName(), UNDEFINED),\n-        entry(BYTE.getName(), BYTE),\n-        entry(BOOLEAN.getName(), BOOLEAN),\n-        entry(STRING.getName(), STRING),\n-        entry(IP.getName(), IP),\n-        entry(DOUBLE.getName(), DOUBLE),\n-        entry(FLOAT.getName(), FLOAT),\n-        entry(SHORT.getName(), SHORT),\n-        entry(INTEGER.getName(), INTEGER),\n-        entry(LONG.getName(), LONG),\n-        entry(RowType.EMPTY.getName(), RowType.EMPTY),\n-        entry(TIME.getName(), TIME),\n-        entry(TIMESTAMPZ.getName(), TIMESTAMPZ),\n-        entry(TIMESTAMP.getName(), TIMESTAMP),\n-        entry(ObjectType.NAME, UNTYPED_OBJECT),\n-        entry(GEO_POINT.getName(), GEO_POINT),\n-        entry(GEO_SHAPE.getName(), GEO_SHAPE),\n-        entry(\"int2\", SHORT),\n-        entry(\"int\", INTEGER),\n-        entry(\"int4\", INTEGER),\n-        entry(\"int8\", LONG),\n-        entry(\"name\", STRING),\n-        entry(\"regproc\", STRING),\n-        entry(\"long\", LONG),\n-        entry(\"byte\", BYTE),\n-        entry(\"short\", SHORT),\n-        entry(\"float\", FLOAT),\n-        entry(\"double\", DOUBLE),\n-        entry(\"string\", STRING),\n-        entry(\"varchar\", STRING),\n-        entry(\"character varying\", STRING),\n-        entry(\"time\", TIME),\n-        entry(\"timestamptz\", TIMESTAMPZ),\n-        // The usage of the `timestamp` data type as a data type with time\n-        // zone is deprecate, use `timestamp with time zone` or `timestamptz`\n-        // instead. In future releases the `timestamp` data type will be changed\n-        // to behave as a timestamp without time zone. For now, we use the\n-        // `timestamp` as an alias for the `timestamp with time zone` data type\n-        // to warn users about the data type semantic change and give a time\n-        // to adjust to the change.\n-        entry(\"timestamp\", TIMESTAMPZ),\n-        entry(\"interval\", INTERVAL));\n-\n-    public static DataType<?> ofName(String typeName) {\n-        DataType<?> dataType = ofNameOrNull(typeName);\n-        if (dataType == null) {\n-            throw new IllegalArgumentException(\"Cannot find data type: \" + typeName);\n-        }\n-        return dataType;\n-    }\n-\n-    @Nullable\n-    public static DataType<?> ofNameOrNull(String typeName) {\n-        return TYPES_BY_NAME_OR_ALIAS.get(typeName);\n-    }\n-\n-    private static final Map<String, DataType> MAPPING_NAMES_TO_TYPES = Map.ofEntries(\n-        entry(\"date\", DataTypes.TIMESTAMPZ),\n-        entry(\"string\", DataTypes.STRING),\n-        entry(\"keyword\", DataTypes.STRING),\n-        entry(\"text\", DataTypes.STRING),\n-        entry(\"boolean\", DataTypes.BOOLEAN),\n-        entry(\"byte\", DataTypes.BYTE),\n-        entry(\"short\", DataTypes.SHORT),\n-        entry(\"integer\", DataTypes.INTEGER),\n-        entry(\"long\", DataTypes.LONG),\n-        entry(\"float\", DataTypes.FLOAT),\n-        entry(\"double\", DataTypes.DOUBLE),\n-        entry(\"ip\", DataTypes.IP),\n-        entry(\"geo_point\", DataTypes.GEO_POINT),\n-        entry(\"geo_shape\", DataTypes.GEO_SHAPE),\n-        entry(\"object\", UNTYPED_OBJECT),\n-        entry(\"nested\", UNTYPED_OBJECT),\n-        entry(\"interval\", DataTypes.INTERVAL)\n-    );\n-\n-    private static final Map<Integer, String> TYPE_IDS_TO_MAPPINGS = Map.ofEntries(\n-        entry(TIME.id(), \"integer\"),\n-        entry(TIMESTAMPZ.id(), \"date\"),\n-        entry(TIMESTAMP.id(), \"date\"),\n-        entry(STRING.id(), \"text\"),\n-        entry(BYTE.id(), \"byte\"),\n-        entry(BOOLEAN.id(), \"boolean\"),\n-        entry(IP.id(), \"ip\"),\n-        entry(DOUBLE.id(), \"double\"),\n-        entry(FLOAT.id(), \"float\"),\n-        entry(SHORT.id(), \"short\"),\n-        entry(INTEGER.id(), \"integer\"),\n-        entry(LONG.id(), \"long\"),\n-        entry(ObjectType.ID, \"object\"),\n-        entry(GEO_SHAPE.id(), \"geo_shape\"),\n-        entry(GEO_POINT.id(), \"geo_point\"),\n-        entry(INTERVAL.id(), \"interval\")\n-    );\n-\n-    @Nullable\n-    public static String esMappingNameFrom(int typeId) {\n-        return TYPE_IDS_TO_MAPPINGS.get(typeId);\n-    }\n-\n-    @Nullable\n-    public static DataType ofMappingName(String name) {\n-        return MAPPING_NAMES_TO_TYPES.get(name);\n-    }\n-\n-    public static boolean isPrimitive(DataType type) {\n-        return PRIMITIVE_TYPES.contains(type);\n-    }\n-\n-    /**\n-     * Register a custom data type to the type registry.\n-     *\n-     * <p>Note: If registering is done inside a static block, be sure the class is loaded initially.\n-     * Otherwise it might not be registered on all nodes.\n-     * </p>\n-     */\n-    public static void register(int id, Writeable.Reader<DataType<?>> dataType) {\n-        if (TYPE_REGISTRY.put(id, dataType) != null) {\n-            throw new IllegalArgumentException(\"Already got a dataType with id \" + id);\n-        }\n-    }\n-\n-    public static Streamer[] getStreamers(Collection<? extends DataType> dataTypes) {\n-        Streamer[] streamer = new Streamer[dataTypes.size()];\n-        int idx = 0;\n-        for (DataType dataType : dataTypes) {\n-            streamer[idx] = dataType.streamer();\n-            idx++;\n-        }\n-        return streamer;\n-    }\n-\n-    public static boolean compareTypesById(DataType<?> left, DataType<?> right) {\n-        if (left.id() != right.id()) {\n-            return false;\n-        } else if (isArray(left)) {\n-            return compareTypesById(\n-                ((ArrayType) left).innerType(),\n-                ((ArrayType) right).innerType());\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    public static boolean compareTypesById(List<DataType> left, List<DataType> right) {\n-        if (left.size() != right.size()) {\n-            return false;\n-        }\n-        assert left instanceof RandomAccess && right instanceof RandomAccess\n-            : \"data type lists should support RandomAccess for fast lookups\";\n-        for (int i = 0; i < left.size(); i++) {\n-            if (!compareTypesById(left.get(i), right.get(i))) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Returns the first data type that is not {@link UndefinedType}, or {@code UNDEFINED} if none found.\n-     */\n-    public static DataType<?> tryFindNotNullType(List<DataType> dataTypes) {\n-        return dataTypes.stream()\n-            .filter(t -> t != UNDEFINED)\n-            .findFirst().orElse(UNDEFINED);\n-    }\n-\n-    public static DataType<?> fromId(Integer id) {\n-        return TYPES_BY_NAME_OR_ALIAS.values().stream()\n-            .filter(x -> x.id() == id)\n-            .findFirst()\n-            .orElse(DataTypes.UNDEFINED);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxNjA0OQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r421316049", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final int id;\n          \n          \n            \n                private final String name;\n          \n      \n    \n    \n  \n\nGiven that there is only a single instance with fixed types we can remove the attributes and just return the constants. Reduces the memory footprint a bit.", "author": "mfussenegger", "createdAt": "2020-05-07T08:05:17Z", "path": "common/src/main/java/io/crate/types/TimeType.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.format.ResolverStyle;\n+import java.util.Locale;\n+\n+public final class TimeType extends DataType<Integer> implements FixedWidthType, Streamer<Integer> {\n+\n+    public static final int ID = 19;\n+    public static final String NAME = \"time without time zone\";\n+    public static final TimeType INSTANCE = new TimeType(ID, NAME);\n+\n+\n+    private final int id;\n+    private final String name;\n+", "originalCommit": "9c039c0436c10d2017eed7295ed74f94aec82d2b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b37861c93ef185dd14de0f637ef7dd92120ed5de", "chunk": "diff --git a/common/src/main/java/io/crate/types/TimeType.java b/common/src/main/java/io/crate/types/TimeType.java\ndeleted file mode 100644\nindex 9efe508948..0000000000\n--- a/common/src/main/java/io/crate/types/TimeType.java\n+++ /dev/null\n\n@@ -1,159 +0,0 @@\n-/*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n- */\n-\n-package io.crate.types;\n-\n-import io.crate.Streamer;\n-import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n-\n-import javax.annotation.Nonnull;\n-import java.io.IOException;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.time.LocalDateTime;\n-import java.time.LocalTime;\n-import java.time.ZoneOffset;\n-import java.time.format.DateTimeFormatter;\n-import java.time.format.DateTimeFormatterBuilder;\n-import java.time.format.ResolverStyle;\n-import java.util.Locale;\n-\n-public final class TimeType extends DataType<Integer> implements FixedWidthType, Streamer<Integer> {\n-\n-    public static final int ID = 19;\n-    public static final String NAME = \"time without time zone\";\n-    public static final TimeType INSTANCE = new TimeType(ID, NAME);\n-\n-\n-    private final int id;\n-    private final String name;\n-\n-    private TimeType(int id, String name) {\n-        this.id = id;\n-        this.name = name;\n-    }\n-\n-    @Override\n-    public int id() {\n-        return id;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return name;\n-    }\n-\n-    @Override\n-    public Precedence precedence() {\n-        return Precedence.TIME;\n-    }\n-\n-    @Override\n-    public Streamer<Integer> streamer() {\n-        return this;\n-    }\n-\n-    @Override\n-    public int compare(Integer val1, Integer val2) {\n-        return Integer.compare(val1, val2);\n-    }\n-\n-    @Override\n-    public Integer readValueFrom(StreamInput in) throws IOException {\n-        return in.readBoolean() ? null : in.readInt();\n-    }\n-\n-    @Override\n-    public void writeValueTo(StreamOutput out, Integer v) throws IOException {\n-        out.writeBoolean(v == null);\n-        if (v != null) {\n-            out.writeInt(v);\n-        }\n-    }\n-\n-    @Override\n-    public int fixedSize() {\n-        return IntegerType.INTEGER_SIZE;\n-    }\n-\n-    @Override\n-    public Integer value(Object value) throws ClassCastException {\n-        if (value == null) {\n-            return null;\n-        }\n-        if (value instanceof String) {\n-            return parseTime((String) value);\n-        }\n-        // float values are treated as \"seconds.milliseconds\"\n-        if (value instanceof Double) {\n-            Double n = (Double) value;\n-            if (n.doubleValue() < Float.MAX_VALUE) {\n-                return translateFrom(n.floatValue());\n-            }\n-            throw new IllegalArgumentException(String.format(\n-                Locale.ENGLISH,\n-                \"value too large [%f] if does not fit in a float\",\n-                value));\n-        }\n-        if (value instanceof Float) {\n-            return translateFrom((Float) value);\n-        }\n-        return value instanceof Integer ? (Integer) value : ((Number) value).intValue();\n-    }\n-\n-    public static int translateFrom(@Nonnull Float number) {\n-        // number is: seconds.milliseconds\n-        return (int) (Instant\n-            .ofEpochMilli((long) Math.floor(number.floatValue() * 1000))\n-            .atZone(ZoneOffset.UTC)\n-            .toInstant()\n-            .toEpochMilli() - Instant.EPOCH.toEpochMilli());\n-    }\n-\n-    public static int parseTime(@Nonnull String time) {\n-        try {\n-            return Integer.parseInt(time);\n-        } catch (NumberFormatException e) {\n-            // the time zone is ignored if present\n-            LocalTime lt = LocalTime.parse(time, TIME_PARSER);\n-            return (int) LocalDateTime\n-                .of(ZERO_DATE, lt)\n-                .toInstant(ZoneOffset.UTC)\n-                .toEpochMilli();\n-        }\n-    }\n-\n-    public static String formatTime(@Nonnull Integer time) {\n-        return LocalDateTime\n-            .ofInstant(Instant.ofEpochMilli(time), ZoneOffset.UTC)\n-            .format(DateTimeFormatter.ISO_LOCAL_TIME);\n-    }\n-\n-    private static final DateTimeFormatter TIME_PARSER = new DateTimeFormatterBuilder()\n-        .append(DateTimeFormatter.ISO_LOCAL_TIME)\n-        .optionalStart()\n-            .appendPattern(\"[Z][VV][x][xx][xxx]\")\n-        .toFormatter(Locale.ENGLISH)\n-        .withResolverStyle(ResolverStyle.STRICT);\n-\n-    private static final LocalDate ZERO_DATE = LocalDate.of(1970, 1, 1);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxNjQwOQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r421316409", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static int translateFrom(@Nonnull Float number) {\n          \n          \n            \n                public static int translateFrom(float number) {", "author": "mfussenegger", "createdAt": "2020-05-07T08:05:58Z", "path": "common/src/main/java/io/crate/types/TimeType.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.format.ResolverStyle;\n+import java.util.Locale;\n+\n+public final class TimeType extends DataType<Integer> implements FixedWidthType, Streamer<Integer> {\n+\n+    public static final int ID = 19;\n+    public static final String NAME = \"time without time zone\";\n+    public static final TimeType INSTANCE = new TimeType(ID, NAME);\n+\n+\n+    private final int id;\n+    private final String name;\n+\n+    private TimeType(int id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public int id() {\n+        return id;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.TIME;\n+    }\n+\n+    @Override\n+    public Streamer<Integer> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public int compare(Integer val1, Integer val2) {\n+        return Integer.compare(val1, val2);\n+    }\n+\n+    @Override\n+    public Integer readValueFrom(StreamInput in) throws IOException {\n+        return in.readBoolean() ? null : in.readInt();\n+    }\n+\n+    @Override\n+    public void writeValueTo(StreamOutput out, Integer v) throws IOException {\n+        out.writeBoolean(v == null);\n+        if (v != null) {\n+            out.writeInt(v);\n+        }\n+    }\n+\n+    @Override\n+    public int fixedSize() {\n+        return IntegerType.INTEGER_SIZE;\n+    }\n+\n+    @Override\n+    public Integer value(Object value) throws ClassCastException {\n+        if (value == null) {\n+            return null;\n+        }\n+        if (value instanceof String) {\n+            return parseTime((String) value);\n+        }\n+        // float values are treated as \"seconds.milliseconds\"\n+        if (value instanceof Double) {\n+            Double n = (Double) value;\n+            if (n.doubleValue() < Float.MAX_VALUE) {\n+                return translateFrom(n.floatValue());\n+            }\n+            throw new IllegalArgumentException(String.format(\n+                Locale.ENGLISH,\n+                \"value too large [%f] if does not fit in a float\",\n+                value));\n+        }\n+        if (value instanceof Float) {\n+            return translateFrom((Float) value);\n+        }\n+        return value instanceof Integer ? (Integer) value : ((Number) value).intValue();\n+    }\n+\n+    public static int translateFrom(@Nonnull Float number) {", "originalCommit": "9c039c0436c10d2017eed7295ed74f94aec82d2b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b37861c93ef185dd14de0f637ef7dd92120ed5de", "chunk": "diff --git a/common/src/main/java/io/crate/types/TimeType.java b/common/src/main/java/io/crate/types/TimeType.java\ndeleted file mode 100644\nindex 9efe508948..0000000000\n--- a/common/src/main/java/io/crate/types/TimeType.java\n+++ /dev/null\n\n@@ -1,159 +0,0 @@\n-/*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n- */\n-\n-package io.crate.types;\n-\n-import io.crate.Streamer;\n-import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n-\n-import javax.annotation.Nonnull;\n-import java.io.IOException;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.time.LocalDateTime;\n-import java.time.LocalTime;\n-import java.time.ZoneOffset;\n-import java.time.format.DateTimeFormatter;\n-import java.time.format.DateTimeFormatterBuilder;\n-import java.time.format.ResolverStyle;\n-import java.util.Locale;\n-\n-public final class TimeType extends DataType<Integer> implements FixedWidthType, Streamer<Integer> {\n-\n-    public static final int ID = 19;\n-    public static final String NAME = \"time without time zone\";\n-    public static final TimeType INSTANCE = new TimeType(ID, NAME);\n-\n-\n-    private final int id;\n-    private final String name;\n-\n-    private TimeType(int id, String name) {\n-        this.id = id;\n-        this.name = name;\n-    }\n-\n-    @Override\n-    public int id() {\n-        return id;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return name;\n-    }\n-\n-    @Override\n-    public Precedence precedence() {\n-        return Precedence.TIME;\n-    }\n-\n-    @Override\n-    public Streamer<Integer> streamer() {\n-        return this;\n-    }\n-\n-    @Override\n-    public int compare(Integer val1, Integer val2) {\n-        return Integer.compare(val1, val2);\n-    }\n-\n-    @Override\n-    public Integer readValueFrom(StreamInput in) throws IOException {\n-        return in.readBoolean() ? null : in.readInt();\n-    }\n-\n-    @Override\n-    public void writeValueTo(StreamOutput out, Integer v) throws IOException {\n-        out.writeBoolean(v == null);\n-        if (v != null) {\n-            out.writeInt(v);\n-        }\n-    }\n-\n-    @Override\n-    public int fixedSize() {\n-        return IntegerType.INTEGER_SIZE;\n-    }\n-\n-    @Override\n-    public Integer value(Object value) throws ClassCastException {\n-        if (value == null) {\n-            return null;\n-        }\n-        if (value instanceof String) {\n-            return parseTime((String) value);\n-        }\n-        // float values are treated as \"seconds.milliseconds\"\n-        if (value instanceof Double) {\n-            Double n = (Double) value;\n-            if (n.doubleValue() < Float.MAX_VALUE) {\n-                return translateFrom(n.floatValue());\n-            }\n-            throw new IllegalArgumentException(String.format(\n-                Locale.ENGLISH,\n-                \"value too large [%f] if does not fit in a float\",\n-                value));\n-        }\n-        if (value instanceof Float) {\n-            return translateFrom((Float) value);\n-        }\n-        return value instanceof Integer ? (Integer) value : ((Number) value).intValue();\n-    }\n-\n-    public static int translateFrom(@Nonnull Float number) {\n-        // number is: seconds.milliseconds\n-        return (int) (Instant\n-            .ofEpochMilli((long) Math.floor(number.floatValue() * 1000))\n-            .atZone(ZoneOffset.UTC)\n-            .toInstant()\n-            .toEpochMilli() - Instant.EPOCH.toEpochMilli());\n-    }\n-\n-    public static int parseTime(@Nonnull String time) {\n-        try {\n-            return Integer.parseInt(time);\n-        } catch (NumberFormatException e) {\n-            // the time zone is ignored if present\n-            LocalTime lt = LocalTime.parse(time, TIME_PARSER);\n-            return (int) LocalDateTime\n-                .of(ZERO_DATE, lt)\n-                .toInstant(ZoneOffset.UTC)\n-                .toEpochMilli();\n-        }\n-    }\n-\n-    public static String formatTime(@Nonnull Integer time) {\n-        return LocalDateTime\n-            .ofInstant(Instant.ofEpochMilli(time), ZoneOffset.UTC)\n-            .format(DateTimeFormatter.ISO_LOCAL_TIME);\n-    }\n-\n-    private static final DateTimeFormatter TIME_PARSER = new DateTimeFormatterBuilder()\n-        .append(DateTimeFormatter.ISO_LOCAL_TIME)\n-        .optionalStart()\n-            .appendPattern(\"[Z][VV][x][xx][xxx]\")\n-        .toFormatter(Locale.ENGLISH)\n-        .withResolverStyle(ResolverStyle.STRICT);\n-\n-    private static final LocalDate ZERO_DATE = LocalDate.of(1970, 1, 1);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxNzcyNg==", "url": "https://github.com/crate/crate/pull/9915#discussion_r421317726", "bodyText": "Could you add some docs that explain the allowed input formats and the internal storage format a bit?", "author": "mfussenegger", "createdAt": "2020-05-07T08:08:21Z", "path": "common/src/main/java/io/crate/types/TimeType.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.format.ResolverStyle;\n+import java.util.Locale;\n+\n+public final class TimeType extends DataType<Integer> implements FixedWidthType, Streamer<Integer> {", "originalCommit": "9c039c0436c10d2017eed7295ed74f94aec82d2b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b37861c93ef185dd14de0f637ef7dd92120ed5de", "chunk": "diff --git a/common/src/main/java/io/crate/types/TimeType.java b/common/src/main/java/io/crate/types/TimeType.java\ndeleted file mode 100644\nindex 9efe508948..0000000000\n--- a/common/src/main/java/io/crate/types/TimeType.java\n+++ /dev/null\n\n@@ -1,159 +0,0 @@\n-/*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n- */\n-\n-package io.crate.types;\n-\n-import io.crate.Streamer;\n-import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n-\n-import javax.annotation.Nonnull;\n-import java.io.IOException;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.time.LocalDateTime;\n-import java.time.LocalTime;\n-import java.time.ZoneOffset;\n-import java.time.format.DateTimeFormatter;\n-import java.time.format.DateTimeFormatterBuilder;\n-import java.time.format.ResolverStyle;\n-import java.util.Locale;\n-\n-public final class TimeType extends DataType<Integer> implements FixedWidthType, Streamer<Integer> {\n-\n-    public static final int ID = 19;\n-    public static final String NAME = \"time without time zone\";\n-    public static final TimeType INSTANCE = new TimeType(ID, NAME);\n-\n-\n-    private final int id;\n-    private final String name;\n-\n-    private TimeType(int id, String name) {\n-        this.id = id;\n-        this.name = name;\n-    }\n-\n-    @Override\n-    public int id() {\n-        return id;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return name;\n-    }\n-\n-    @Override\n-    public Precedence precedence() {\n-        return Precedence.TIME;\n-    }\n-\n-    @Override\n-    public Streamer<Integer> streamer() {\n-        return this;\n-    }\n-\n-    @Override\n-    public int compare(Integer val1, Integer val2) {\n-        return Integer.compare(val1, val2);\n-    }\n-\n-    @Override\n-    public Integer readValueFrom(StreamInput in) throws IOException {\n-        return in.readBoolean() ? null : in.readInt();\n-    }\n-\n-    @Override\n-    public void writeValueTo(StreamOutput out, Integer v) throws IOException {\n-        out.writeBoolean(v == null);\n-        if (v != null) {\n-            out.writeInt(v);\n-        }\n-    }\n-\n-    @Override\n-    public int fixedSize() {\n-        return IntegerType.INTEGER_SIZE;\n-    }\n-\n-    @Override\n-    public Integer value(Object value) throws ClassCastException {\n-        if (value == null) {\n-            return null;\n-        }\n-        if (value instanceof String) {\n-            return parseTime((String) value);\n-        }\n-        // float values are treated as \"seconds.milliseconds\"\n-        if (value instanceof Double) {\n-            Double n = (Double) value;\n-            if (n.doubleValue() < Float.MAX_VALUE) {\n-                return translateFrom(n.floatValue());\n-            }\n-            throw new IllegalArgumentException(String.format(\n-                Locale.ENGLISH,\n-                \"value too large [%f] if does not fit in a float\",\n-                value));\n-        }\n-        if (value instanceof Float) {\n-            return translateFrom((Float) value);\n-        }\n-        return value instanceof Integer ? (Integer) value : ((Number) value).intValue();\n-    }\n-\n-    public static int translateFrom(@Nonnull Float number) {\n-        // number is: seconds.milliseconds\n-        return (int) (Instant\n-            .ofEpochMilli((long) Math.floor(number.floatValue() * 1000))\n-            .atZone(ZoneOffset.UTC)\n-            .toInstant()\n-            .toEpochMilli() - Instant.EPOCH.toEpochMilli());\n-    }\n-\n-    public static int parseTime(@Nonnull String time) {\n-        try {\n-            return Integer.parseInt(time);\n-        } catch (NumberFormatException e) {\n-            // the time zone is ignored if present\n-            LocalTime lt = LocalTime.parse(time, TIME_PARSER);\n-            return (int) LocalDateTime\n-                .of(ZERO_DATE, lt)\n-                .toInstant(ZoneOffset.UTC)\n-                .toEpochMilli();\n-        }\n-    }\n-\n-    public static String formatTime(@Nonnull Integer time) {\n-        return LocalDateTime\n-            .ofInstant(Instant.ofEpochMilli(time), ZoneOffset.UTC)\n-            .format(DateTimeFormatter.ISO_LOCAL_TIME);\n-    }\n-\n-    private static final DateTimeFormatter TIME_PARSER = new DateTimeFormatterBuilder()\n-        .append(DateTimeFormatter.ISO_LOCAL_TIME)\n-        .optionalStart()\n-            .appendPattern(\"[Z][VV][x][xx][xxx]\")\n-        .toFormatter(Locale.ENGLISH)\n-        .withResolverStyle(ResolverStyle.STRICT);\n-\n-    private static final LocalDate ZERO_DATE = LocalDate.of(1970, 1, 1);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyMDEzMw==", "url": "https://github.com/crate/crate/pull/9915#discussion_r421320133", "bodyText": "The conditions seem a bit redundant - maybe this could be changed to avoid the duplicate isTime checks - I think then it would also be easier to read.", "author": "mfussenegger", "createdAt": "2020-05-07T08:12:32Z", "path": "sql/src/main/java/io/crate/analyze/expressions/ExpressionAnalyzer.java", "diffHunk": "@@ -448,13 +449,15 @@ protected Symbol visitExpression(Expression node, ExpressionAnalysisContext cont\n \n         @Override\n         protected Symbol visitCurrentTime(CurrentTime node, ExpressionAnalysisContext context) {\n-            if (!node.getType().equals(CurrentTime.Type.TIMESTAMP)) {\n+            boolean isTime = node.getType().equals(CurrentTime.Type.TIME);\n+            if (!(node.getType().equals(CurrentTime.Type.TIMESTAMP) || isTime)) {\n                 visitExpression(node, context);\n             }\n+            String functionName = isTime ? CurrentTimeFunction.NAME : CurrentTimestampFunction.NAME;", "originalCommit": "9c039c0436c10d2017eed7295ed74f94aec82d2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU2ODgyMw==", "url": "https://github.com/crate/crate/pull/9915#discussion_r428568823", "bodyText": "I have removed the implementation of CurrentTimeFunction from this PR.\nIt was dragged in by mistake, as I rebased from the branch I use for it.\nThe plan is to get TimeType in and then use it to move forward with the function. I'd rather not mix.", "author": "marregui", "createdAt": "2020-05-21T10:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyMDEzMw=="}], "type": "inlineReview", "revised_code": {"commit": "f746ad18c19dc0b43e5f56312dfa6c2f74af433f", "chunk": "diff --git a/sql/src/main/java/io/crate/analyze/expressions/ExpressionAnalyzer.java b/server/src/main/java/io/crate/analyze/expressions/ExpressionAnalyzer.java\nsimilarity index 99%\nrename from sql/src/main/java/io/crate/analyze/expressions/ExpressionAnalyzer.java\nrename to server/src/main/java/io/crate/analyze/expressions/ExpressionAnalyzer.java\nindex 6bdf597b8a..b6fecc1d88 100644\n--- a/sql/src/main/java/io/crate/analyze/expressions/ExpressionAnalyzer.java\n+++ b/server/src/main/java/io/crate/analyze/expressions/ExpressionAnalyzer.java\n\n@@ -449,15 +448,13 @@ public class ExpressionAnalyzer {\n \n         @Override\n         protected Symbol visitCurrentTime(CurrentTime node, ExpressionAnalysisContext context) {\n-            boolean isTime = node.getType().equals(CurrentTime.Type.TIME);\n-            if (!(node.getType().equals(CurrentTime.Type.TIMESTAMP) || isTime)) {\n+            if (!node.getType().equals(CurrentTime.Type.TIMESTAMP)) {\n                 visitExpression(node, context);\n             }\n-            String functionName = isTime ? CurrentTimeFunction.NAME : CurrentTimestampFunction.NAME;\n             List<Symbol> args = List.of(\n                 Literal.of(node.getPrecision().orElse(CurrentTimestampFunction.DEFAULT_PRECISION))\n             );\n-            return allocateFunction(functionName, args, context);\n+            return allocateFunction(CurrentTimestampFunction.NAME, args, context);\n         }\n \n         @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyMTMxMA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r421321310", "bodyText": "Why does this return Long and TIMESTAMPZ ? Shouldn't this return the new time type?", "author": "mfussenegger", "createdAt": "2020-05-07T08:14:27Z", "path": "sql/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.timestamp;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+\n+import javax.annotation.Nullable;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class CurrentTimeFunction extends Scalar<Long, Integer> {\n+\n+    public static final String NAME = \"current_time\";\n+\n+    public static final FunctionInfo INFO = new FunctionInfo(\n+        new FunctionIdent(NAME, List.of(DataTypes.INTEGER)),\n+        DataTypes.TIMESTAMPZ,\n+        FunctionInfo.Type.SCALAR,", "originalCommit": "9c039c0436c10d2017eed7295ed74f94aec82d2b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f746ad18c19dc0b43e5f56312dfa6c2f74af433f", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java b/sql/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java\ndeleted file mode 100644\nindex 189fbc0879..0000000000\n--- a/sql/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java\n+++ /dev/null\n\n@@ -1,90 +0,0 @@\n-/*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n- */\n-\n-package io.crate.expression.scalar.timestamp;\n-\n-import io.crate.data.Input;\n-import io.crate.expression.scalar.ScalarFunctionModule;\n-import io.crate.metadata.FunctionIdent;\n-import io.crate.metadata.FunctionInfo;\n-import io.crate.metadata.Scalar;\n-import io.crate.metadata.TransactionContext;\n-import io.crate.metadata.functions.Signature;\n-import io.crate.types.DataTypes;\n-\n-import javax.annotation.Nullable;\n-import java.time.Instant;\n-import java.time.ZoneOffset;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Collections;\n-import java.util.List;\n-\n-public class CurrentTimeFunction extends Scalar<Long, Integer> {\n-\n-    public static final String NAME = \"current_time\";\n-\n-    public static final FunctionInfo INFO = new FunctionInfo(\n-        new FunctionIdent(NAME, List.of(DataTypes.INTEGER)),\n-        DataTypes.TIMESTAMPZ,\n-        FunctionInfo.Type.SCALAR,\n-        Collections.emptySet());\n-\n-    public static void register(ScalarFunctionModule module) {\n-        module.register(\n-            Signature.scalar(\n-                NAME,\n-                DataTypes.INTEGER.getTypeSignature(),\n-                DataTypes.TIMESTAMPZ.getTypeSignature()\n-            ),\n-            (signature, args) -> new CurrentTimeFunction(signature)\n-        );\n-    }\n-\n-    private final Signature signature;\n-\n-    public CurrentTimeFunction(Signature signature) {\n-        this.signature = signature;\n-    }\n-\n-    @Override\n-    @SafeVarargs\n-    public final Long evaluate(TransactionContext txnCtx, Input<Integer>... args) {\n-        long now = txnCtx.currentTimeMillis();\n-        long justDate = Instant\n-            .ofEpochMilli(now)\n-            .atZone(ZoneOffset.UTC)\n-            .truncatedTo(ChronoUnit.DAYS)\n-            .toInstant()\n-            .toEpochMilli();\n-        return CurrentTimestampFunction.applyPrecision(now - justDate, args);\n-    }\n-\n-    @Override\n-    public FunctionInfo info() {\n-        return INFO;\n-    }\n-\n-    @Nullable\n-    @Override\n-    public Signature signature() {\n-        return signature;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyMzEwNQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r421323105", "bodyText": "Using Instant may be a bit expensive for what it does", "author": "mfussenegger", "createdAt": "2020-05-07T08:17:30Z", "path": "sql/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.timestamp;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+\n+import javax.annotation.Nullable;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class CurrentTimeFunction extends Scalar<Long, Integer> {\n+\n+    public static final String NAME = \"current_time\";\n+\n+    public static final FunctionInfo INFO = new FunctionInfo(\n+        new FunctionIdent(NAME, List.of(DataTypes.INTEGER)),\n+        DataTypes.TIMESTAMPZ,\n+        FunctionInfo.Type.SCALAR,\n+        Collections.emptySet());\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.TIMESTAMPZ.getTypeSignature()\n+            ),\n+            (signature, args) -> new CurrentTimeFunction(signature)\n+        );\n+    }\n+\n+    private final Signature signature;\n+\n+    public CurrentTimeFunction(Signature signature) {\n+        this.signature = signature;\n+    }\n+\n+    @Override\n+    @SafeVarargs\n+    public final Long evaluate(TransactionContext txnCtx, Input<Integer>... args) {\n+        long now = txnCtx.currentTimeMillis();\n+        long justDate = Instant\n+            .ofEpochMilli(now)\n+            .atZone(ZoneOffset.UTC)\n+            .truncatedTo(ChronoUnit.DAYS)\n+            .toInstant()\n+            .toEpochMilli();\n+        return CurrentTimestampFunction.applyPrecision(now - justDate, args);", "originalCommit": "9c039c0436c10d2017eed7295ed74f94aec82d2b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f746ad18c19dc0b43e5f56312dfa6c2f74af433f", "chunk": "diff --git a/sql/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java b/sql/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java\ndeleted file mode 100644\nindex 189fbc0879..0000000000\n--- a/sql/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java\n+++ /dev/null\n\n@@ -1,90 +0,0 @@\n-/*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n- */\n-\n-package io.crate.expression.scalar.timestamp;\n-\n-import io.crate.data.Input;\n-import io.crate.expression.scalar.ScalarFunctionModule;\n-import io.crate.metadata.FunctionIdent;\n-import io.crate.metadata.FunctionInfo;\n-import io.crate.metadata.Scalar;\n-import io.crate.metadata.TransactionContext;\n-import io.crate.metadata.functions.Signature;\n-import io.crate.types.DataTypes;\n-\n-import javax.annotation.Nullable;\n-import java.time.Instant;\n-import java.time.ZoneOffset;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Collections;\n-import java.util.List;\n-\n-public class CurrentTimeFunction extends Scalar<Long, Integer> {\n-\n-    public static final String NAME = \"current_time\";\n-\n-    public static final FunctionInfo INFO = new FunctionInfo(\n-        new FunctionIdent(NAME, List.of(DataTypes.INTEGER)),\n-        DataTypes.TIMESTAMPZ,\n-        FunctionInfo.Type.SCALAR,\n-        Collections.emptySet());\n-\n-    public static void register(ScalarFunctionModule module) {\n-        module.register(\n-            Signature.scalar(\n-                NAME,\n-                DataTypes.INTEGER.getTypeSignature(),\n-                DataTypes.TIMESTAMPZ.getTypeSignature()\n-            ),\n-            (signature, args) -> new CurrentTimeFunction(signature)\n-        );\n-    }\n-\n-    private final Signature signature;\n-\n-    public CurrentTimeFunction(Signature signature) {\n-        this.signature = signature;\n-    }\n-\n-    @Override\n-    @SafeVarargs\n-    public final Long evaluate(TransactionContext txnCtx, Input<Integer>... args) {\n-        long now = txnCtx.currentTimeMillis();\n-        long justDate = Instant\n-            .ofEpochMilli(now)\n-            .atZone(ZoneOffset.UTC)\n-            .truncatedTo(ChronoUnit.DAYS)\n-            .toInstant()\n-            .toEpochMilli();\n-        return CurrentTimestampFunction.applyPrecision(now - justDate, args);\n-    }\n-\n-    @Override\n-    public FunctionInfo info() {\n-        return INFO;\n-    }\n-\n-    @Nullable\n-    @Override\n-    public Signature signature() {\n-        return signature;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTA1OQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r421325059", "bodyText": "In PostgreSQL the typlen is 8. Which would imply that we use less storage and that the streaming implementation is not compatible.", "author": "mfussenegger", "createdAt": "2020-05-07T08:20:51Z", "path": "sql/src/main/java/io/crate/protocols/postgres/types/TimeType.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres.types;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import javax.annotation.Nonnull;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+\n+import static io.crate.types.TimeType.parseTime;\n+import static io.crate.types.TimeType.formatTime;\n+\n+\n+final class TimeType extends PGType<Integer> {\n+\n+    public static final PGType<Integer> INSTANCE = new TimeType();\n+\n+    private static final int OID = 1083;\n+    private static final int TYPE_MOD = -1;\n+    private static final int TYPE_LEN = 4;", "originalCommit": "9c039c0436c10d2017eed7295ed74f94aec82d2b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b37861c93ef185dd14de0f637ef7dd92120ed5de", "chunk": "diff --git a/sql/src/main/java/io/crate/protocols/postgres/types/TimeType.java b/sql/src/main/java/io/crate/protocols/postgres/types/TimeType.java\ndeleted file mode 100644\nindex 3b396dcb8d..0000000000\n--- a/sql/src/main/java/io/crate/protocols/postgres/types/TimeType.java\n+++ /dev/null\n\n@@ -1,89 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.protocols.postgres.types;\n-\n-import io.netty.buffer.ByteBuf;\n-\n-import javax.annotation.Nonnull;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Locale;\n-\n-import static io.crate.types.TimeType.parseTime;\n-import static io.crate.types.TimeType.formatTime;\n-\n-\n-final class TimeType extends PGType<Integer> {\n-\n-    public static final PGType<Integer> INSTANCE = new TimeType();\n-\n-    private static final int OID = 1083;\n-    private static final int TYPE_MOD = -1;\n-    private static final int TYPE_LEN = 4;\n-    private static final String TYPE_NAME = \"time without time zone\";\n-\n-\n-    TimeType() {\n-        super(OID, TYPE_LEN, TYPE_MOD, TYPE_NAME);\n-    }\n-\n-    @Override\n-    public int typArray() {\n-        return PGArray.TIME_ARRAY.oid();\n-    }\n-\n-    @Override\n-    public String typeCategory() {\n-        return TypeCategory.DATETIME.code();\n-    }\n-\n-    @Override\n-    public String type() {\n-        return Type.BASE.code();\n-    }\n-\n-    @Override\n-    public int writeAsBinary(ByteBuf buffer, @Nonnull Integer value) {\n-        buffer.writeInt(TYPE_LEN);\n-        buffer.writeInt(value);\n-        return INT32_BYTE_SIZE + TYPE_LEN;\n-    }\n-\n-    @Override\n-    public Integer readBinaryValue(ByteBuf buffer, int valueLength) {\n-        assert valueLength == TYPE_LEN : String.format(\n-            Locale.ENGLISH,\n-            \"valueLength must be %d because time is a 32 bit int. Actual length: %d\",\n-            TYPE_LEN, valueLength);\n-        return buffer.readInt();\n-    }\n-\n-    @Override\n-    byte[] encodeAsUTF8Text(@Nonnull Integer time) {\n-        return formatTime(time).getBytes(StandardCharsets.UTF_8);\n-    }\n-\n-    @Override\n-    Integer decodeUTF8Text(byte[] bytes) {\n-        return parseTime(new String(bytes, StandardCharsets.UTF_8));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTk5OQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r421325999", "bodyText": "Why is this necessary?", "author": "mfussenegger", "createdAt": "2020-05-07T08:22:28Z", "path": "sql/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java", "diffHunk": "@@ -313,7 +314,10 @@ public void testWhereNotEqualAnyWithLargeArray() throws Exception {\n \n     @Test\n     public void testNullOperators() throws Exception {\n-        DataType<?> type = randomType();\n+        DataType<?> type;\n+        do {\n+           type = randomType();\n+        } while (type == DataTypes.INTERVAL);", "originalCommit": "9c039c0436c10d2017eed7295ed74f94aec82d2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU3MTYwOQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r428571609", "bodyText": "Because you cannot have a column of type interval.\ncr> create table t1(c interval);\nSQLActionException[SQLParseException: Cannot use the type `interval` for column: c]\n\nSQLActionException: 400 Bad Request 4000 SQLParseException: Cannot use the type `interval` for column: c\n\tat io.crate.analyze.AnalyzedColumnDefinition.validate(AnalyzedColumnDefinition.java:369)\n\tat io.crate.analyze.AnalyzedTableElements.finalizeAndValidate(AnalyzedTableElements.java:319)\n\tat io.crate.planner.node.ddl.CreateTablePlan.bind(CreateTablePlan.java:150)\n\tat io.crate.planner.node.ddl.CreateTablePlan.executeOrFail(CreateTablePlan.java:97)\n\tat io.crate.planner.Plan.execute(Plan.java:74)\n       ...", "author": "marregui", "createdAt": "2020-05-21T10:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTk5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b2ce6b01172c13642e76c620b62c792d6e828707", "chunk": "diff --git a/sql/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java b/sql/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java\ndeleted file mode 100644\nindex 1444ff532e..0000000000\n--- a/sql/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java\n+++ /dev/null\n\n@@ -1,416 +0,0 @@\n-/*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n- */\n-\n-package io.crate.integrationtests;\n-\n-import com.carrotsearch.randomizedtesting.annotations.Seed;\n-import io.crate.testing.DataTypeTesting;\n-import io.crate.types.DataType;\n-import io.crate.types.DataTypes;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.search.SearchModule;\n-import org.elasticsearch.test.ESIntegTestCase;\n-import org.junit.Test;\n-\n-import java.util.List;\n-import java.util.function.Supplier;\n-\n-import static com.carrotsearch.randomizedtesting.RandomizedTest.$;\n-import static com.carrotsearch.randomizedtesting.RandomizedTest.$$;\n-import static io.crate.testing.DataTypeTesting.randomType;\n-import static io.crate.testing.TestingHelpers.printedTable;\n-import static org.hamcrest.CoreMatchers.anyOf;\n-import static org.hamcrest.core.Is.is;\n-\n-@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST)\n-@Seed(\"54904E791E52DEFD\")\n-public class LuceneQueryBuilderIntegrationTest extends SQLTransportIntegrationTest {\n-\n-    private static final int NUMBER_OF_BOOLEAN_CLAUSES = 10_000;\n-\n-    @Override\n-    protected Settings nodeSettings(int nodeOrdinal) {\n-        return Settings.builder()\n-                       .put(super.nodeSettings(nodeOrdinal))\n-                       .put(SearchModule.INDICES_MAX_CLAUSE_COUNT_SETTING.getKey(), NUMBER_OF_BOOLEAN_CLAUSES)\n-                       .build();\n-    }\n-\n-    @Test\n-    public void testWhereFunctionWithAnalyzedColumnArgument() throws Exception {\n-        execute(\"create table t (text string index using fulltext) \" +\n-                \"clustered into 1 shards with (number_of_replicas = 0)\");\n-        ensureYellow();\n-        execute(\"insert into t (text) values ('hello world')\");\n-        refresh();\n-\n-        execute(\"select text from t where substr(text, 1, 1) = 'h'\");\n-        assertThat(response.rowCount(), is(1L));\n-    }\n-\n-    @Test\n-    public void testEqualsQueryOnArrayType() throws Exception {\n-        execute(\"create table t (a array(integer)) with (number_of_replicas = 0)\");\n-        ensureYellow();\n-        execute(\"insert into t (a) values (?)\", new Object[][]{\n-            new Object[]{new Object[]{10, 10, 20}},\n-            new Object[]{new Object[]{40, 50, 60}},\n-            new Object[]{new Object[]{null, null}}\n-        });\n-        execute(\"refresh table t\");\n-\n-        execute(\"select * from t where a = [10, 10, 20]\");\n-        assertThat(response.rowCount(), is(1L));\n-\n-        execute(\"select * from t where a = [10, 20]\");\n-        assertThat(response.rowCount(), is(0L));\n-\n-        execute(\"select * from t where a = [null, null]\");\n-        assertThat(response.rowCount(), is(1L));\n-    }\n-\n-    @Test\n-    public void testWhereFunctionWithIndexOffColumn() throws Exception {\n-        execute(\"create table t (text string index off) \" +\n-                \"clustered into 1 shards with (number_of_replicas = 0)\");\n-        ensureYellow();\n-        execute(\"insert into t (text) values ('hello world')\");\n-        refresh();\n-\n-        execute(\"select text from t where substr(text, 1, 1) = 'h'\");\n-        assertThat(response.rowCount(), is(1L));\n-    }\n-\n-    @Test\n-    public void testWhereFunctionWithIndexReference() throws Exception {\n-        execute(\"create table t (text string, index text_ft using fulltext (text)) \" +\n-                \"clustered into 2 shards with (number_of_replicas = 0)\");\n-        ensureYellow();\n-        execute(\"insert into t (text) values ('hello world')\");\n-        execute(\"insert into t (text) values ('harr')\");\n-        execute(\"insert into t (text) values ('hh')\");\n-        refresh();\n-\n-        execute(\"select text from t where substr(text_ft, 1, 1) = 'h'\");\n-        assertThat(response.rowCount(), is(0L));\n-    }\n-\n-    @Test\n-    public void testAnyFunctionWithSubscript() throws Exception {\n-        execute(\"create table t (a array(object as (b array(object as (n integer))))) \" +\n-                \"clustered into 1 shards with (number_of_replicas = 0)\");\n-        ensureYellow();\n-        execute(\"insert into t (a) values ([{b=[{n=1}, {n=2}, {n=3}]}])\");\n-        execute(\"insert into t (a) values ([{b=[{n=3}, {n=4}, {n=5}]}])\");\n-        refresh();\n-\n-        execute(\"select * from t where 3 = any(a[1]['b']['n'])\");\n-        assertThat(response.rowCount(), is(2L));\n-        execute(\"select a[1]['b']['n'] from t where 1 = any(a[1]['b']['n'])\");\n-        assertThat(response.rowCount(), is(1L));\n-        assertThat(((List) response.rows()[0][0]).get(0), is(1));\n-        assertThat(((List) response.rows()[0][0]).get(1), is(2));\n-        assertThat(((List) response.rows()[0][0]).get(2), is(3));\n-    }\n-\n-    @Test\n-    public void testWhereSubstringWithSysColumn() throws Exception {\n-        execute(\"create table t (dummy string) clustered into 2 shards with (number_of_replicas = 0)\");\n-        ensureYellow();\n-        execute(\"insert into t (dummy) values ('yalla')\");\n-        refresh();\n-\n-        execute(\"select dummy from t where substr(_uid, 1, 1) != '{'\");\n-        assertThat(response.rowCount(), is(1L));\n-        assertThat(((String) response.rows()[0][0]), is(\"yalla\"));\n-    }\n-\n-    @Test\n-    public void testInWithArgs() throws Exception {\n-        execute(\"create table t (i int) clustered into 1 shards with (number_of_replicas = 0)\");\n-        ensureYellow();\n-        execute(\"insert into t values (1), (2)\");\n-        execute(\"refresh table t\");\n-\n-        StringBuilder sb = new StringBuilder(\"select i from t where i in (\");\n-\n-        int i = 0;\n-        for (; i < 1500; i++) {\n-            sb.append(i);\n-            sb.append(',');\n-        }\n-        sb.append(i);\n-        sb.append(')');\n-\n-        execute(sb.toString());\n-        assertThat(response.rowCount(), is(2L));\n-    }\n-\n-    @Test\n-    public void testWithinGenericFunction() throws Exception {\n-        execute(\"create table shaped (id int, point geo_point, shape geo_shape) with (number_of_replicas=0)\");\n-        ensureYellow();\n-        execute(\"insert into shaped (id, point, shape) VALUES (?, ?, ?)\", $$(\n-            $(1, \"POINT (15 15)\", \"polygon (( 10 10, 10 20, 20 20, 20 15, 10 10))\"),\n-            $(1, \"POINT (-10 -10)\", \"polygon (( 10 10, 10 20, 20 20, 20 15, 10 10))\")\n-        ));\n-        execute(\"refresh table shaped\");\n-\n-        execute(\"select * from shaped where within(point, shape) order by id\");\n-        assertThat(response.rowCount(), is(1L));\n-    }\n-\n-    @Test\n-    public void testWithinQueryMatches() throws Exception {\n-        // test a regression where wrong lucene query was used and therefore did not return any results\n-        execute(\"CREATE TABLE locations (id INT, point GEO_POINT) WITH (number_of_replicas=0)\");\n-        ensureYellow();\n-        execute(\"INSERT INTO locations (id, point) VALUES (?, ?)\", $$(\n-            $(1, \"POINT(-71.06244564056396 42.35373619523924)\")\n-        ));\n-        execute(\"REFRESH TABLE locations\");\n-        execute(\"SELECT * FROM locations WHERE within(point, 'POLYGON((\" +\n-                \"-71.06042861938477 42.35473836290108,\" +\n-                \"-71.05982780456543 42.35251834962908,\" +\n-                \"-71.06463432312012 42.35213776805158,\" +\n-                \"-71.06403350830078 42.35359665158396,\" +\n-                \"-71.06042861938477 42.35473836290108))')\");\n-        assertThat(response.rowCount(), is(1L));\n-\n-    }\n-\n-    @Test\n-    public void testObjectEq() throws Exception {\n-        execute(\"create table t (o object as (x int, y long))\");\n-        ensureYellow();\n-\n-        execute(\"insert into t (o) values ({x=10, y=20})\");\n-        execute(\"refresh table t\");\n-\n-        assertThat(execute(\"select * from t where o = {x=10, y=20}\").rowCount(), is(1L));\n-    }\n-\n-    @Test\n-    public void testFunctionWhereIn() throws Exception {\n-        execute(\"create table t (x string) with (number_of_replicas = 0)\");\n-        ensureYellow();\n-\n-        execute(\"insert into t (x) values ('x'), ('y')\");\n-        execute(\"refresh table t\");\n-\n-        execute(\"select * from t where concat(x, '') in ('x', 'y')\");\n-        assertThat(response.rowCount(), is(2L));\n-    }\n-\n-    @Test\n-    public void testWhereINWithNullArguments() throws Exception {\n-        execute(\"create table t (x int) with (number_of_replicas = 0)\");\n-        ensureYellow();\n-\n-        execute(\"insert into t (x) values (1), (2)\");\n-        execute(\"refresh table t\");\n-\n-        execute(\"select * from t where x in (1, null)\");\n-        assertThat(printedTable(response.rows()), is(\"1\\n\"));\n-\n-        execute(\"select * from t where x in (3, null)\");\n-        assertThat(response.rowCount(), is(0L));\n-\n-        execute(\"select * from t where coalesce(x in (3, null), true)\");\n-        assertThat(response.rowCount(), is(2L));\n-    }\n-\n-    @Test\n-    public void testQueriesOnColumnThatDoesNotExistInAllPartitions() throws Exception {\n-        // LuceneQueryBuilder uses a MappedFieldType to generate queries\n-        // this MappedFieldType is not available on partitions that are missing fields\n-        // this test verifies that this case works correctly\n-\n-        execute(\"create table t (p int) \" +\n-                \"clustered into 1 shards \" +\n-                \"partitioned by (p) \" +\n-                \"with (number_of_replicas = 0, column_policy = 'dynamic') \");\n-        execute(\"insert into t (p) values (1)\");\n-        execute(\"insert into t (p, x, numbers, obj, objects, s, b) \" +\n-                \"values (2, 10, [10, 20, 30], {x=10}, [{x=10}, {x=20}], 'foo', true)\");\n-        ensureYellow();\n-        execute(\"refresh table t\");\n-\n-        // match on partition with the columns\n-\n-        assertThat(printedTable(execute(\"select p from t where x = 10\").rows()), is(\"2\\n\"));\n-        // range queries all hit the same code path, so only > is tested\n-        assertThat(printedTable(execute(\"select p from t where x > 9\").rows()), is(\"2\\n\"));\n-        assertThat(printedTable(execute(\"select p from t where x is not null\").rows()), is(\"2\\n\"));\n-        assertThat(printedTable(execute(\"select p from t where x::string like 10\").rows()), is(\"2\\n\"));\n-        assertThat(printedTable(execute(\"select p from t where s like 'f%'\").rows()), is(\"2\\n\"));\n-        assertThat(printedTable(execute(\"select p from t where s ilike 'F%'\").rows()), is(\"2\\n\"));\n-        assertThat(printedTable(execute(\"select p from t where obj = {x=10}\").rows()), is(\"2\\n\"));\n-        assertThat(printedTable(execute(\"select p from t where b\").rows()), is(\"2\\n\"));\n-\n-        assertThat(printedTable(execute(\"select p from t where 10 = any(numbers)\").rows()), is(\"2\\n\"));\n-        assertThat(printedTable(execute(\"select p from t where 10 != any(numbers)\").rows()), is(\"2\\n\"));\n-        assertThat(printedTable(execute(\"select p from t where 15 > any(numbers)\").rows()), is(\"2\\n\"));\n-\n-        assertThat(printedTable(execute(\"select p from t where x = any([10, 20])\").rows()), is(\"2\\n\"));\n-        assertThat(printedTable(execute(\"select p from t where x != any([20, 30])\").rows()), is(\"2\\n\"));\n-        assertThat(printedTable(execute(\"select p from t where x > any([1, 2])\").rows()), is(\"2\\n\"));\n-\n-\n-        // match on partitions where the column does not exist\n-        assertThat(printedTable(execute(\"select p from t where x is null\").rows()), is(\"1\\n\"));\n-        assertThat(printedTable(execute(\"select p from t where obj is null\").rows()), is(\"1\\n\"));\n-    }\n-\n-    @Test\n-    public void testWhereNotIdInFunction() throws Exception {\n-        execute(\"create table t (dummy string) clustered into 2 shards with (number_of_replicas = 0)\");\n-        ensureYellow();\n-        execute(\"insert into t (dummy) values ('yalla')\");\n-        refresh();\n-\n-        execute(\"select dummy from t where substr(_id, 1, 1) != '{'\");\n-        assertThat(response.rowCount(), is(1L));\n-        assertThat(response.rows()[0][0], is(\"yalla\"));\n-    }\n-\n-    @Test\n-    public void testWhereNotEqualAnyWithLargeArray() throws Exception {\n-        // Test overriding of default value 8192 for indices.query.bool.max_clause_count\n-        execute(\"create table t1 (id integer) clustered into 2 shards with (number_of_replicas = 0)\");\n-        execute(\"create table t2 (id integer) clustered into 2 shards with (number_of_replicas = 0)\");\n-        ensureYellow();\n-\n-        int bulkSize = NUMBER_OF_BOOLEAN_CLAUSES;\n-        Object[][] bulkArgs = new Object[bulkSize][];\n-        for (int i = 0; i < bulkSize; i++) {\n-            bulkArgs[i] = new Object[]{i};\n-        }\n-        execute(\"insert into t1 (id) values (?)\", bulkArgs);\n-        execute(\"insert into t2 (id) values (1)\");\n-        execute(\"refresh table t1, t2\");\n-\n-        execute(\"select count(*) from t2 where id != any(select id from t1)\");\n-        assertThat(response.rows()[0][0], is(1L));\n-    }\n-\n-    @Test\n-    public void testNullOperators() throws Exception {\n-        DataType<?> type;\n-        do {\n-           type = randomType();\n-        } while (type == DataTypes.INTERVAL);\n-        execute(\"create table t1 (c \" + type.getName() + \") with (number_of_replicas = 0)\");\n-        Supplier dataGenerator = DataTypeTesting.getDataGenerator(type);\n-\n-        Object[][] bulkArgs = $$($(dataGenerator.get()), $(dataGenerator.get()), new Object[]{null});\n-        execute(\"insert into t1 (c) values (?)\", bulkArgs);\n-        execute(\"refresh table t1\");\n-\n-        execute(\"select count(*) from t1 where c is null\");\n-        assertThat(printedTable(response.rows()), is(\"1\\n\"));\n-\n-        execute(\"select count(*) from t1 where c is not null\");\n-        assertThat(printedTable(response.rows()), is(\"2\\n\"));\n-    }\n-\n-    @Test\n-    public void testIsNotNullFilterMatchesNotNullRecordOnArrayObjectColumn() {\n-        execute(\"create table bag (id short primary key, ob array (object))\");\n-        execute(\"insert into bag (id) values (1)\");\n-        execute(\"insert into bag (id, ob) values (2, [{bbb = 2}])\");\n-        execute(\"refresh table bag\");\n-\n-        execute(\"SELECT id, ob FROM bag WHERE ob IS NOT NULL\");\n-        assertThat(printedTable(response.rows()), is(\"2| [{bbb=2}]\\n\"));\n-    }\n-\n-    @Test\n-    public void testNotEqualAnyWithAndWithoutThreeValuedLogic() {\n-        execute(\"create table t1 (a array(integer)) clustered into 2 shards with (number_of_replicas = 0)\");\n-        ensureYellow();\n-\n-        execute(\"insert into t1(a) values ([1, 2, 3])\");\n-        execute(\"insert into t1(a) values ([1, 2, 3, null])\");\n-        execute(\"insert into t1(a) values ([4, 5])\");\n-        execute(\"insert into t1(a) values ([4, 5, null])\");\n-        execute(\"refresh table t1\");\n-\n-        execute(\"select * from t1 where not 5 = any(a)\");\n-        assertThat(printedTable(response.rows()), is(\"[1, 2, 3]\\n\"));\n-        execute(\"select * from t1 where not ignore3vl(5 = any(a))\");\n-        assertThat(printedTable(response.rows()), anyOf(is(\"[1, 2, 3, null]\\n\" +\n-                                                           \"[1, 2, 3]\\n\"),\n-                                                        is(\"[1, 2, 3]\\n\" +\n-                                                           \"[1, 2, 3, null]\\n\")));\n-    }\n-\n-    @Test\n-    public void testArrayElementComparisons() {\n-        execute(\"create table t1 (a array(long)) clustered into 1 shards with (number_of_replicas = 0)\");\n-        execute(\"insert into t1(a) values ([1, 2, 3])\");\n-        execute(\"insert into t1(a) values ([3, 4, 5, 1])\");\n-        execute(\"insert into t1(a) values ([6, 7, 8])\");\n-        execute(\"refresh table t1\");\n-\n-        execute(\"select * from t1 where a[1] = 1\");\n-        assertThat(printedTable(response.rows()), is(\"[1, 2, 3]\\n\"));\n-\n-        execute(\"select * from t1 where a[1] != 1\");\n-        assertThat(printedTable(response.rows()), is(\"[3, 4, 5, 1]\\n\" +\n-                                                     \"[6, 7, 8]\\n\"));\n-\n-        execute(\"select * from t1 where a[1] > 1\");\n-        assertThat(printedTable(response.rows()), is(\"[3, 4, 5, 1]\\n\" +\n-                                                     \"[6, 7, 8]\\n\"));\n-\n-        execute(\"select * from t1 where a[3] >= 3\");\n-        assertThat(printedTable(response.rows()), is(\"[1, 2, 3]\\n\" +\n-                                                     \"[3, 4, 5, 1]\\n\" +\n-                                                     \"[6, 7, 8]\\n\"));\n-\n-        execute(\"select * from t1 where a[1] < 3\");\n-        assertThat(printedTable(response.rows()), is(\"[1, 2, 3]\\n\"));\n-\n-        execute(\"select * from t1 where a[2] <= 4\");\n-        assertThat(printedTable(response.rows()), is(\"[1, 2, 3]\\n\" +\n-                                                     \"[3, 4, 5, 1]\\n\"));\n-    }\n-\n-    @Test\n-    public void testAnyOnNestedArray() {\n-        execute(\"create table t (obj array(object as (xs array(integer))))\");\n-        execute(\"insert into t (obj) values ([{xs = [1, 2, 3]}, {xs = [3, 4]}])\");\n-        execute(\"refresh table t\");\n-\n-        assertThat(\n-            \"query matches\",\n-            printedTable(execute(\"select * from t where [1, 2, 3] = any(obj['xs'])\").rows()),\n-            is(\"[{xs=[1, 2, 3]}, {xs=[3, 4]}]\\n\")\n-        );\n-\n-        assertThat(\n-            \"query doesn't match\",\n-            printedTable(execute(\"select * from t where [1, 2] = any(obj['xs'])\").rows()),\n-            is(\"\")\n-        );\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNjMwOA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r421326308", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ensureYellow();\n          \n      \n    \n    \n  \n\nensureYellow is implicit on CREATE TABLE", "author": "mfussenegger", "createdAt": "2020-05-07T08:22:59Z", "path": "sql/src/test/java/io/crate/integrationtests/SQLTypeMappingTest.java", "diffHunk": "@@ -575,4 +575,15 @@ public void testInsertTimestampPreferMillis() {\n         assertThat((Long) response.rows()[0][0], is(1000L));\n         assertThat((Long) response.rows()[1][0], is(2016L));\n     }\n+\n+    @Test\n+    public void test_insert_time_without_time_zone() {\n+        execute(\"create table eons_table (dt time) \" +\n+                \"clustered into 2 shards with (number_of_replicas=0)\");\n+        ensureYellow();", "originalCommit": "9c039c0436c10d2017eed7295ed74f94aec82d2b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b37861c93ef185dd14de0f637ef7dd92120ed5de", "chunk": "diff --git a/sql/src/test/java/io/crate/integrationtests/SQLTypeMappingTest.java b/sql/src/test/java/io/crate/integrationtests/SQLTypeMappingTest.java\ndeleted file mode 100644\nindex 165ee2d32e..0000000000\n--- a/sql/src/test/java/io/crate/integrationtests/SQLTypeMappingTest.java\n+++ /dev/null\n\n@@ -1,589 +0,0 @@\n-/*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n- */\n-\n-package io.crate.integrationtests;\n-\n-import io.crate.action.sql.SQLActionException;\n-import io.crate.testing.SQLResponse;\n-import io.crate.testing.TestingHelpers;\n-import io.crate.testing.UseJdbc;\n-import org.elasticsearch.test.ESIntegTestCase;\n-import org.junit.Test;\n-\n-import java.io.IOException;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-\n-import static org.hamcrest.Matchers.allOf;\n-import static org.hamcrest.Matchers.containsString;\n-import static org.hamcrest.Matchers.hasItems;\n-import static org.hamcrest.Matchers.is;\n-import static org.hamcrest.Matchers.not;\n-import static org.hamcrest.core.IsInstanceOf.instanceOf;\n-\n-@ESIntegTestCase.ClusterScope(minNumDataNodes = 2)\n-public class SQLTypeMappingTest extends SQLTransportIntegrationTest {\n-\n-    private void setUpSimple() throws IOException {\n-        setUpSimple(2);\n-    }\n-\n-    private void setUpSimple(int numShards) {\n-        String stmt = String.format(Locale.ENGLISH, \"create table t1 (\" +\n-                                                    \" id integer primary key,\" +\n-                                                    \" string_field string,\" +\n-                                                    \" boolean_field boolean,\" +\n-                                                    \" byte_field byte,\" +\n-                                                    \" short_field short,\" +\n-                                                    \" integer_field integer,\" +\n-                                                    \" long_field long,\" +\n-                                                    \" float_field float,\" +\n-                                                    \" double_field double,\" +\n-                                                    \" timestamp_field timestamp with time zone,\" +\n-                                                    \" object_field object as (\\\"inner\\\" timestamp with time zone),\" +\n-                                                    \" ip_field ip\" +\n-                                                    \") clustered by (id) into %d shards \" +\n-                                                    \"with (number_of_replicas=0, column_policy = 'dynamic')\", numShards);\n-        execute(stmt);\n-        ensureYellow();\n-    }\n-\n-    @Test\n-    public void testInsertAtNodeWithoutShard() throws Exception {\n-        setUpSimple(1);\n-\n-        execute(\"insert into t1 (id, string_field, timestamp_field, byte_field) values (?, ?, ?, ?)\",\n-                new Object[]{1, \"With\", \"1970-01-01T00:00:00\", 127},\n-                createSessionOnNode(internalCluster().getNodeNames()[0]));\n-\n-        execute(\"insert into t1 (id, string_field, timestamp_field, byte_field) values (?, ?, ?, ?)\",\n-                new Object[]{2, \"Without\", \"1970-01-01T01:00:00\", Byte.MIN_VALUE},\n-                createSessionOnNode(internalCluster().getNodeNames()[1]));\n-\n-        refresh();\n-        SQLResponse response = execute(\"select id, string_field, timestamp_field, byte_field from t1 order by id\");\n-\n-        assertEquals(1, response.rows()[0][0]);\n-        assertEquals(\"With\", response.rows()[0][1]);\n-        assertEquals(0L, response.rows()[0][2]);\n-        assertEquals((byte) 127, response.rows()[0][3]);\n-\n-        assertEquals(2, response.rows()[1][0]);\n-        assertEquals(\"Without\", response.rows()[1][1]);\n-        assertEquals(3600000L, response.rows()[1][2]);\n-        assertEquals((byte) -128, response.rows()[1][3]);\n-    }\n-\n-    public void setUpObjectTable() {\n-        execute(\"create table test12 (\" +\n-                \" object_field object(dynamic) as (size byte, created timestamp with time zone),\" +\n-                \" strict_field object(strict) as (path string, created timestamp with time zone),\" +\n-                \" no_dynamic_field object(ignored) as (\" +\n-                \"  path string, \" +\n-                \"  dynamic_again object(dynamic) as (field timestamp with time zone)\" +\n-                \" )\" +\n-                \") clustered into 2 shards with(number_of_replicas=0)\");\n-        ensureYellow();\n-    }\n-\n-    /**\n-     * Disabled JDBC usage cause of text mode JSON encoding which is not type safe on numeric types.\n-     * E.g. byte values are always converted to integers,\n-     * see {@link com.fasterxml.jackson.core.JsonGenerator#writeNumber(short)}.\n-     */\n-    @UseJdbc(0)\n-    @Test\n-    public void testParseInsertObject() throws Exception {\n-        setUpObjectTable();\n-\n-        execute(\"insert into test12 (object_field, strict_field, \" +\n-                \"no_dynamic_field) values (?,?,?)\",\n-            new Object[]{\n-                new HashMap<String, Object>() {{\n-                    put(\"size\", 127);\n-                    put(\"created\", \"2013-11-19\");\n-                }},\n-                new HashMap<String, Object>() {{\n-                    put(\"path\", \"/dev/null\");\n-                    put(\"created\", \"1970-01-01T00:00:00\");\n-                }},\n-                new HashMap<String, Object>() {{\n-                    put(\"path\", \"/etc/shadow\");\n-                    put(\"dynamic_again\", new HashMap<String, Object>() {{\n-                            put(\"field\", 1384790145.289);\n-                        }}\n-                    );\n-                }}\n-            });\n-        refresh();\n-\n-        SQLResponse response = execute(\"select object_field, strict_field, no_dynamic_field from test12\");\n-        assertEquals(1, response.rowCount());\n-        assertThat(response.rows()[0][0], instanceOf(Map.class));\n-        @SuppressWarnings(\"unchecked\")\n-        Map<String, Object> objectMap = (Map<String, Object>) response.rows()[0][0];\n-        assertEquals(1384819200000L, objectMap.get(\"created\"));\n-        assertEquals((byte) 127, objectMap.get(\"size\"));\n-\n-        assertThat(response.rows()[0][1], instanceOf(Map.class));\n-        @SuppressWarnings(\"unchecked\")\n-        Map<String, Object> strictMap = (Map<String, Object>) response.rows()[0][1];\n-        assertEquals(\"/dev/null\", strictMap.get(\"path\"));\n-        assertEquals(0L, strictMap.get(\"created\"));\n-\n-        assertThat(response.rows()[0][2], instanceOf(Map.class));\n-        @SuppressWarnings(\"unchecked\")\n-        Map<String, Object> noDynamicMap = (Map<String, Object>) response.rows()[0][2];\n-        assertEquals(\"/etc/shadow\", noDynamicMap.get(\"path\"));\n-        assertEquals(\n-            new HashMap<String, Object>() {{\n-                put(\"field\", 1384790145289L);\n-            }},\n-            noDynamicMap.get(\"dynamic_again\")\n-        );\n-\n-        response = execute(\"select object_field['created'], object_field['size'], \" +\n-                           \"no_dynamic_field['dynamic_again']['field'] from test12\");\n-        assertEquals(1384819200000L, response.rows()[0][0]);\n-        assertEquals((byte) 127, response.rows()[0][1]);\n-        assertEquals(1384790145289L, response.rows()[0][2]);\n-    }\n-\n-    @Test\n-    public void testInsertObjectField() throws Exception {\n-        expectedException.expect(SQLActionException.class);\n-\n-        setUpObjectTable();\n-        execute(\"insert into test12 (object_field['size']) values (127)\");\n-\n-    }\n-\n-    @Test\n-    public void testInvalidInsertIntoObject() throws Exception {\n-        setUpObjectTable();\n-\n-        expectedException.expect(SQLActionException.class);\n-        // Value formatting differs between jdbc & non jdbc\n-        expectedException.expectMessage(allOf(\n-            containsString(\"Validation failed for object_field\"),\n-            containsString(\"Invalid value\"),\n-            containsString(\"for type 'object'\"))\n-        );\n-        execute(\"insert into test12 (object_field, strict_field) values (?,?)\", new Object[]{\n-            new HashMap<String, Object>() {{\n-                put(\"created\", true);\n-                put(\"size\", 127);\n-            }},\n-            new HashMap<String, Object>() {{\n-                put(\"path\", \"/dev/null\");\n-                put(\"created\", 0);\n-            }}\n-        });\n-    }\n-\n-    @Test\n-    public void testInvalidWhereClause() throws Exception {\n-        expectedException.expect(SQLActionException.class);\n-        expectedException.expectMessage(\"Cannot cast `129` of type `bigint` to type `char`\");\n-\n-        setUpSimple();\n-        execute(\"delete from t1 where byte_field=129\");\n-    }\n-\n-    @Test\n-    public void testInvalidWhereInWhereClause() throws Exception {\n-        expectedException.expect(SQLActionException.class);\n-        expectedException.expectMessage(\"Cannot cast `['a']` of type `text_array` to type `char_array`\");\n-\n-        setUpSimple();\n-        execute(\"update t1 set byte_field=0 where byte_field in ('a')\");\n-    }\n-\n-    @Test\n-    public void testSetUpdate() throws Exception {\n-        setUpSimple();\n-\n-        execute(\"insert into t1 (id, byte_field, short_field, integer_field, long_field, \" +\n-                \"float_field, double_field, boolean_field, string_field, timestamp_field,\" +\n-                \"object_field) values (?,?,?,?,?,?,?,?,?,?,?)\", new Object[]{\n-            0, 0, 0, 0, 0, 0.0f, 1.0, false, \"\", \"1970-01-01\", new HashMap<String, Object>() {{\n-            put(\"inner\", \"1970-01-01\");\n-        }}\n-        });\n-        execute(\"update t1 set \" +\n-                \"byte_field=?,\" +\n-                \"short_field=?,\" +\n-                \"integer_field=?,\" +\n-                \"long_field=?,\" +\n-                \"float_field=?,\" +\n-                \"double_field=?,\" +\n-                \"boolean_field=?,\" +\n-                \"string_field=?,\" +\n-                \"timestamp_field=?,\" +\n-                \"object_field=?,\" +\n-                \"ip_field=? \" +\n-                \"where id=0\", new Object[]{\n-            Byte.MAX_VALUE, Short.MIN_VALUE, Integer.MAX_VALUE, Long.MIN_VALUE,\n-            1.0f, Math.PI, true, \"a string\", \"2013-11-20\",\n-            new HashMap<String, Object>() {{\n-                put(\"inner\", \"2013-11-20\");\n-            }}, \"127.0.0.1\"\n-        });\n-        refresh();\n-\n-        SQLResponse response = execute(\"select id, byte_field, short_field, integer_field, long_field,\" +\n-                                       \"float_field, double_field, boolean_field, string_field, timestamp_field,\" +\n-                                       \"object_field, ip_field from t1 where id=0\");\n-        assertEquals(1, response.rowCount());\n-        assertEquals(0, response.rows()[0][0]);\n-        assertEquals((byte) 127, response.rows()[0][1]);\n-        assertEquals((short) -32768, response.rows()[0][2]);\n-        assertEquals(0x7fffffff, response.rows()[0][3]);\n-        assertEquals(0x8000000000000000L, response.rows()[0][4]);\n-        assertEquals(1.0f, ((Number) response.rows()[0][5]).floatValue(), 0.01f);\n-        assertEquals(Math.PI, response.rows()[0][6]);\n-        assertEquals(true, response.rows()[0][7]);\n-        assertEquals(\"a string\", response.rows()[0][8]);\n-        assertEquals(1384905600000L, response.rows()[0][9]);\n-        assertEquals(new HashMap<String, Object>() {{\n-            put(\"inner\", 1384905600000L);\n-        }}, response.rows()[0][10]);\n-        assertEquals(\"127.0.0.1\", response.rows()[0][11]);\n-    }\n-\n-    /**\n-     * We must fix this test to run ALL statements via JDBC or not because object/map values are NOT preserving exact\n-     * its elements numeric types (e.g. Long(0) becomes Integer(0)). This is caused by the usage of JSON for psql text\n-     * serialization. See e.g. {@link org.codehaus.jackson.io.NumberOutput#outputLong(long, byte[], int)}.\n-     */\n-    @UseJdbc(0)\n-    @Test\n-    public void testGetRequestMapping() throws Exception {\n-        setUpSimple();\n-        execute(\"insert into t1 (id, string_field, boolean_field, byte_field, short_field, integer_field,\" +\n-                \"long_field, float_field, double_field, object_field,\" +\n-                \"timestamp_field, ip_field) values \" +\n-                \"(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\", new Object[]{\n-            0, \"Blabla\", true, 120, 1000, 1200000,\n-            120000000000L, 1.4, 3.456789, new HashMap<String, Object>() {{\n-            put(\"inner\", \"1970-01-01\");\n-        }},\n-            \"1970-01-01\", \"127.0.0.1\"\n-        });\n-        refresh();\n-        SQLResponse getResponse = execute(\"select * from t1 where id=0\");\n-        SQLResponse searchResponse = execute(\"select * from t1 limit 1\");\n-        for (int i = 0; i < getResponse.rows()[0].length; i++) {\n-            assertThat(getResponse.rows()[0][i], is(searchResponse.rows()[0][i]));\n-        }\n-    }\n-\n-    @Test\n-    public void testInsertObjectIntoString() throws Exception {\n-        execute(\"create table t1 (o object)\");\n-        execute(\"insert into t1 values ({a='abc'})\");\n-        waitForMappingUpdateOnAll(\"t1\", \"o.a\");\n-\n-        expectedException.expect(SQLActionException.class);\n-        expectedException.expectMessage(\"Cannot cast `{\\\"a\\\"=['123', '456']}` of type `object` to type `object`\");\n-        execute(\"insert into t1 values ({a=['123', '456']})\");\n-    }\n-\n-    /**\n-     * Disable JDBC/PSQL as object values are streamed via JSON on the PSQL wire protocol which is not type safe.\n-     */\n-    @UseJdbc(0)\n-    @Test\n-    public void testInsertNewObjectColumn() throws Exception {\n-        setUpSimple();\n-        execute(\"insert into t1 (id, new_col) values (?,?)\", new Object[]{\n-            0,\n-            new HashMap<String, Object>() {{\n-                put(\"a_date\", \"1970-01-01\");\n-                put(\"an_int\", 127);\n-                put(\"a_long\", Long.MAX_VALUE);\n-                put(\"a_boolean\", true);\n-            }}\n-        });\n-        refresh();\n-\n-        waitForMappingUpdateOnAll(\"t1\", \"new_col\");\n-        SQLResponse response = execute(\"select id, new_col from t1 where id=0\");\n-        @SuppressWarnings(\"unchecked\")\n-        Map<String, Object> mapped = (Map<String, Object>) response.rows()[0][1];\n-        assertEquals(\"1970-01-01\", mapped.get(\"a_date\"));\n-        assertEquals(0x7fffffffffffffffL, mapped.get(\"a_long\"));\n-        assertEquals(true, mapped.get(\"a_boolean\"));\n-\n-        // The inner value will result in an Long type as we rely on ES mappers here and the dynamic ES parsing\n-        // will define integers as longs (no concrete type was specified so use long to be safe)\n-        assertEquals(127L, mapped.get(\"an_int\"));\n-    }\n-\n-    @Test\n-    public void testInsertNewColumnToObject() throws Exception {\n-        setUpObjectTable();\n-        Map<String, Object> objectContent = new HashMap<String, Object>() {{\n-            put(\"new_col\", \"a string\");\n-            put(\"another_new_col\", \"1970-01-01T00:00:00\");\n-        }};\n-        execute(\"insert into test12 (object_field) values (?)\",\n-            new Object[]{objectContent});\n-        refresh();\n-        SQLResponse response = execute(\"select object_field from test12\");\n-        assertEquals(1, response.rowCount());\n-        @SuppressWarnings(\"unchecked\")\n-        Map<String, Object> selectedObject = (Map<String, Object>) response.rows()[0][0];\n-\n-        assertThat((String) selectedObject.get(\"new_col\"), is(\"a string\"));\n-        assertEquals(\"1970-01-01T00:00:00\", selectedObject.get(\"another_new_col\"));\n-    }\n-\n-    @Test\n-    public void testInsertNewColumnToStrictObject() throws Exception {\n-\n-        expectedException.expect(SQLActionException.class);\n-        expectedException.expectMessage(\n-            containsString(\"dynamic introduction of [another_new_col] within [strict_field] is not allowed\"));\n-\n-        setUpObjectTable();\n-        Map<String, Object> strictContent = new HashMap<String, Object>() {{\n-            put(\"another_new_col\", \"1970-01-01T00:00:00\");\n-        }};\n-        execute(\"insert into test12 (strict_field) values (?)\",\n-            new Object[]{strictContent});\n-    }\n-\n-    @Test\n-    public void testInsertNewColumnToIgnoredObject() throws Exception {\n-\n-        setUpObjectTable();\n-        Map<String, Object> notDynamicContent = new HashMap<String, Object>() {{\n-            put(\"new_col\", \"a string\");\n-            put(\"another_new_col\", \"1970-01-01T00:00:00\");\n-        }};\n-        execute(\"insert into test12 (no_dynamic_field) values (?)\",\n-            new Object[]{notDynamicContent});\n-        refresh();\n-        SQLResponse response = execute(\"select no_dynamic_field from test12\");\n-        assertEquals(1, response.rowCount());\n-        @SuppressWarnings(\"unchecked\")\n-        Map<String, Object> selectedNoDynamic = (Map<String, Object>) response.rows()[0][0];\n-        // no mapping applied\n-        assertThat((String) selectedNoDynamic.get(\"new_col\"), is(\"a string\"));\n-        assertThat((String) selectedNoDynamic.get(\"another_new_col\"), is(\"1970-01-01T00:00:00\"));\n-    }\n-\n-    /* TODO: find a good policy for unknown types or support them all\n-    @Test\n-    public void testUnknownTypesSelect() throws Exception {\n-        this.setup.setUpObjectMappingWithUnknownTypes();\n-        SQLResponse response = execute(\"select * from ut\");\n-        assertEquals(2, response.rowCount());\n-        assertArrayEquals(new String[]{\"name\", \"population\"}, response.cols());\n-\n-        response = execute(\"select name, location from ut order by name\");\n-        assertEquals(\"Berlin\", response.rows()[0][0]);\n-        assertEquals(null, response.rows()[0][1]);\n-    }\n-\n-\n-    @Test\n-    public void testUnknownTypesInsert() throws Exception {\n-        this.setup.setUpObjectMappingWithUnknownTypes();\n-        SQLResponse response = execute(\n-                \"insert into ut (name, location, population) values (?, ?, ?)\",\n-                new Object[]{\"K\u00f6ln\", \"2014-01-09\", 0}\n-        );\n-        assertEquals(1, response.rowCount());\n-        refresh();\n-\n-        response = execute(\"select name, location, population from ut order by name\");\n-        assertEquals(3, response.rowCount());\n-        assertEquals(\"Berlin\", response.rows()[0][0]);\n-        assertEquals(null, response.rows()[0][1]);\n-\n-        assertEquals(\"Dornbirn\", response.rows()[1][0]);\n-        assertEquals(null, response.rows()[1][1]);\n-\n-        assertEquals(\"K\u00f6ln\", response.rows()[2][0]);\n-        assertEquals(null, response.rows()[2][1]);\n-    }\n-\n-    @Test\n-    public void testUnknownTypesUpdate() throws Exception {\n-        this.setup.setUpObjectMappingWithUnknownTypes();\n-        execute(\"update ut set location='2014-01-09' where name='Berlin'\");\n-        SQLResponse response = execute(\"select name, location from ut where name='Berlin'\");\n-        assertEquals(1, response.rowCount());\n-        assertEquals(\"Berlin\", response.rows()[0][0]);\n-        assertEquals(\"52.5081,13.4416\", response.rows()[0][1]);\n-    } */\n-\n-    @Test\n-    public void testDynamicEmptyArray() throws Exception {\n-        execute(\"create table arr (id short primary key, tags array(string)) \" +\n-                \"with (number_of_replicas=0, column_policy = 'dynamic')\");\n-        ensureYellow();\n-        execute(\"insert into arr (id, tags, new) values (1, ['wow', 'much', 'wow'], [])\");\n-        refresh();\n-        waitNoPendingTasksOnAll();\n-        execute(\"select column_name, data_type from information_schema.columns where table_name='arr'\");\n-        Object[] columns = TestingHelpers.getColumn(response.rows(), 0);\n-        assertThat(Arrays.asList(columns), not(hasItems((Object) \"new\")));\n-    }\n-\n-    @Test\n-    public void testDynamicNullArray() throws Exception {\n-        execute(\"create table arr (id short primary key, tags array(string)) \" +\n-                \"with (number_of_replicas=0, column_policy = 'dynamic')\");\n-        ensureYellow();\n-        execute(\"insert into arr (id, tags, new) values (2, ['wow', 'much', 'wow'], [null])\");\n-        refresh();\n-        waitNoPendingTasksOnAll();\n-        execute(\"select column_name, data_type from information_schema.columns where table_name='arr'\");\n-        Object[] columns = TestingHelpers.getColumn(response.rows(), 0);\n-        assertThat(Arrays.asList(columns), not(hasItems((Object) \"new\")));\n-    }\n-\n-    @Test\n-    public void testDynamicNullArrayAndDouble() throws Exception {\n-        execute(\"create table arr (id short primary key, tags array(string)) \" +\n-                \"with (number_of_replicas=0, column_policy = 'dynamic')\");\n-        ensureYellow();\n-        execute(\"insert into arr (id, tags, new) values (3, ['wow', 'much', 'wow'], ?)\", new Object[]{new Double[]{null, 42.7}});\n-        refresh();\n-        waitNoPendingTasksOnAll();\n-        awaitBusy(() -> {\n-            SQLResponse res = execute(\"select column_name, data_type from information_schema.columns where table_name='arr'\");\n-            for (Object[] row : res.rows()) {\n-                if (\"new\".equals(row[0]) && \"double_array\".equals(row[1])) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        });\n-    }\n-\n-    @Test\n-    public void testTwoLevelNestedArrayColumn() throws Exception {\n-        execute(\"create table assets (categories array(object as (items array(object as (id int)))))\");\n-        execute(\"insert into assets (categories) values ([{items=[{id=10}, {id=20}]}])\");\n-        ensureYellow();\n-        execute(\"refresh table assets\");\n-\n-        refresh();\n-        waitNoPendingTasksOnAll();\n-        execute(\"select categories['items']['id'] from assets\");\n-        Object[] columns = TestingHelpers.getColumn(response.rows(), 0);\n-//TODO: Re-enable once SQLResponse also includes the data types for the columns\n-//        assertThat(response.columnTypes()[0], is((DataType)new ArrayType(new ArrayType(IntegerType.INSTANCE))));\n-        assertThat(((List) ((List) columns[0]).get(0)).get(0), is(10));\n-        assertThat(((List) ((List) columns[0]).get(0)).get(1), is(20));\n-    }\n-\n-    @Test\n-    public void testThreeLevelNestedArrayColumn() throws Exception {\n-        execute(\"create table assets (categories array(object as (subcategories array(object as (\" +\n-                \"items array(object as (id int)))))))\");\n-        execute(\"insert into assets (categories) values ([{subcategories=[{items=[{id=10}, {id=20}]}]}])\");\n-        ensureYellow();\n-        execute(\"refresh table assets\");\n-\n-        refresh();\n-        waitNoPendingTasksOnAll();\n-        execute(\"select categories['subcategories']['items']['id'] from assets\");\n-        Object[] columns = TestingHelpers.getColumn(response.rows(), 0);\n-//TODO: Re-enable once SQLResponse also includes the data types for the columns\n-//        assertThat(response.columnTypes()[0],\n-//                   is((DataType)new ArrayType(new ArrayType(new ArrayType(IntegerType.INSTANCE)))));\n-        assertThat(((List) ((List) ((List) columns[0]).get(0)).get(0)).get(0), is(10));\n-        assertThat(((List) ((List) ((List) columns[0]).get(0)).get(0)).get(1), is(20));\n-    }\n-\n-    @Test\n-    public void testTwoLevelNestedObjectInArray() throws Exception {\n-        execute(\"create table assets (\\n\" +\n-                \"    categories array(object (dynamic) as (\\n\" +\n-                \"       subcategories object (dynamic) as (\\n\" +\n-                \"          id int))))\");\n-        execute(\"insert into assets(categories) values ([{subcategories={id=10}}, {subcategories={id=20}}])\");\n-        ensureYellow();\n-        execute(\"refresh table assets\");\n-\n-        refresh();\n-        waitNoPendingTasksOnAll();\n-        SQLResponse response = execute(\"select categories[1]['subcategories']['id'] from assets\");\n-        assertEquals(response.rowCount(), 1L);\n-        assertThat((Integer) response.rows()[0][0], is(10));\n-    }\n-\n-    @Test\n-    public void testInsertTimestamp() {\n-        // This is a regression test that we allow timestamps that have more than 13 digits.\n-        execute(\n-            \"create table ts_table (\" +\n-            \"   ts timestamp with time zone\" +\n-            \") clustered into 2 shards with (number_of_replicas=0)\");\n-        ensureYellow();\n-        // biggest Long that can be converted to Double without losing precision\n-        // equivalent to 33658-09-27T01:46:39.999Z\n-        long maxDateMillis = 999999999999999L;\n-        // smallest Long that can be converted to Double without losing precision\n-        // equivalent to -29719-04-05T22:13:20.001Z\n-        long minDateMillis = -999999999999999L;\n-\n-        execute(\"insert into ts_table (ts) values (?)\", new Object[]{ minDateMillis });\n-        execute(\"insert into ts_table (ts) values (?)\", new Object[]{ 0L });\n-        execute(\"insert into ts_table (ts) values (?)\", new Object[]{ maxDateMillis });\n-        // TODO: select timestamps with correct sorting\n-        refresh();\n-        SQLResponse response = execute(\"select * from ts_table order by ts desc\");\n-        assertEquals(response.rowCount(), 3L);\n-    }\n-\n-    @Test\n-    public void testInsertTimestampPreferMillis() {\n-        execute(\"create table ts_table (ts timestamp with time zone) \" +\n-                \"clustered into 2 shards with (number_of_replicas=0)\");\n-        ensureYellow();\n-        execute(\"insert into ts_table (ts) values (?)\", new Object[]{ 1000L });\n-        execute(\"insert into ts_table (ts) values (?)\", new Object[]{ \"2016\" });\n-        refresh();\n-        SQLResponse response = execute(\"select ts from ts_table order by ts asc\");\n-        assertThat((Long) response.rows()[0][0], is(1000L));\n-        assertThat((Long) response.rows()[1][0], is(2016L));\n-    }\n-\n-    @Test\n-    public void test_insert_time_without_time_zone() {\n-        execute(\"create table eons_table (dt time) \" +\n-                \"clustered into 2 shards with (number_of_replicas=0)\");\n-        ensureYellow();\n-        execute(\"insert into eons_table (dt) values (?)\", new Integer[]{ 45296789 });\n-        refresh();\n-        SQLResponse response = execute(\"select dt from eons_table\");\n-        assertThat(response.rows()[0][0], is(45296789));\n-    }\n-}\n"}}, {"oid": "f746ad18c19dc0b43e5f56312dfa6c2f74af433f", "url": "https://github.com/crate/crate/commit/f746ad18c19dc0b43e5f56312dfa6c2f74af433f", "message": "Add missing method", "committedDate": "2020-05-11T10:09:11Z", "type": "forcePushed"}, {"oid": "7d4c28784b2faa7212a193ea6382c4de450bd61f", "url": "https://github.com/crate/crate/commit/7d4c28784b2faa7212a193ea6382c4de450bd61f", "message": "Add missing method", "committedDate": "2020-05-21T08:20:30Z", "type": "forcePushed"}, {"oid": "b37861c93ef185dd14de0f637ef7dd92120ed5de", "url": "https://github.com/crate/crate/commit/b37861c93ef185dd14de0f637ef7dd92120ed5de", "message": "Fix TimeType wiring in DataTypes, paying attention to conversions and mapping to lucene long", "committedDate": "2020-05-21T11:50:08Z", "type": "forcePushed"}, {"oid": "e262734e8d3c08935e8c85e04175c08b0306830e", "url": "https://github.com/crate/crate/commit/e262734e8d3c08935e8c85e04175c08b0306830e", "message": "Remove unnecessary translateFrom", "committedDate": "2020-05-22T10:22:16Z", "type": "forcePushed"}, {"oid": "9fd0ca5b4ed1de4c7c7bb84365381d0c92b722ba", "url": "https://github.com/crate/crate/commit/9fd0ca5b4ed1de4c7c7bb84365381d0c92b722ba", "message": "Improve parser, add tests, document the class for clarity", "committedDate": "2020-05-23T18:22:05Z", "type": "forcePushed"}, {"oid": "09bec9092ab9c13daadeb2ae73d3f87ffad7481b", "url": "https://github.com/crate/crate/commit/09bec9092ab9c13daadeb2ae73d3f87ffad7481b", "message": "Conversions", "committedDate": "2020-05-25T15:07:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAyOTA0OA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430029048", "bodyText": "Where is this difference in precision coming from?", "author": "mfussenegger", "createdAt": "2020-05-25T17:36:25Z", "path": "server/src/main/java/io/crate/types/TimeType.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.format.DateTimeParseException;\n+import java.time.format.ResolverStyle;\n+import java.util.Locale;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Represents time as milliseconds from Jan 1st 1970 (EPOCH), ignoring\n+ * the date portion, the time zone, and storing the value as UTC long.\n+ * <p>\n+ * Accepts two kinds of literal:\n+ * <ol>\n+ *    <li><b>numeric:</b>\n+ *      <ul>\n+ *        <li>short, integer and long values are taken at face value\n+ *        and range checked.</li>\n+ *        <li>double and float values are interpreted as seconds.millis\n+ *        and are range checked. float values loose some precision (milliseconds).\n+ *        </li>\n+ *      </ul>\n+ *    </li>\n+ *\n+ *    <li>text:\n+ *      <ul>\n+ *        <li>hhmmss: e.g. 23:12:21</li>\n+ *        <li>hhmm: e.g. 23:12:00</li>\n+ *        <li>hh: e.g. 23:00:00</li>\n+ *        <li>hhmmss.ffffff: e.g. 23:12:21.999</li>\n+ *        <li>hhmm.ffffff: e.g. 23:12:00.999</li>\n+ *        <li>hh.ffffff: e.g. 23:00:00.999</li>\n+ *        <li>any ISO-8601 extended local time format</li>\n+ *      </ul>\n+ *    </li>\n+ * </ol>\n+ *\n+ * Precision is milli seconds (10e3 in a second, unlike postgres which is", "originalCommit": "09bec9092ab9c13daadeb2ae73d3f87ffad7481b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA0MjA5Mw==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430042093", "bodyText": "I store milliseconds from EPOCH, instead of microseconds from midnight (0L). Although I suppose that as EPOCH is also 0L, it would just be a matter of interpretation of the value. I went for milliseconds from epoch to make time look like a timestamp with no date.\nShould I try microseconds?", "author": "marregui", "createdAt": "2020-05-25T18:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAyOTA0OA=="}], "type": "inlineReview", "revised_code": {"commit": "693bc0d6eb7e0a6a978f63d61bb68ef2d1b73d2e", "chunk": "diff --git a/server/src/main/java/io/crate/types/TimeType.java b/server/src/main/java/io/crate/types/TimeType.java\nindex 779859c40f..d78c17e76f 100644\n--- a/server/src/main/java/io/crate/types/TimeType.java\n+++ b/server/src/main/java/io/crate/types/TimeType.java\n\n@@ -27,21 +27,19 @@ import org.elasticsearch.common.io.stream.StreamOutput;\n \n import javax.annotation.Nonnull;\n import java.io.IOException;\n-import java.time.Instant;\n import java.time.LocalDate;\n-import java.time.LocalDateTime;\n import java.time.LocalTime;\n-import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.format.DateTimeFormatterBuilder;\n import java.time.format.DateTimeParseException;\n import java.time.format.ResolverStyle;\n+import java.time.temporal.ChronoField;\n import java.util.Locale;\n import java.util.function.Supplier;\n \n /**\n- * Represents time as milliseconds from Jan 1st 1970 (EPOCH), ignoring\n- * the date portion, the time zone, and storing the value as UTC long.\n+ * Represents time as microseconds from midnight, ignoring the time zone\n+ * and storing the value as UTC long.\n  * <p>\n  * Accepts two kinds of literal:\n  * <ol>\n"}}, {"oid": "76ceeaeafd74cb56f1b360a6c9037ab3458bdea6", "url": "https://github.com/crate/crate/commit/76ceeaeafd74cb56f1b360a6c9037ab3458bdea6", "message": "Cannot create/alter table if column definition of type time", "committedDate": "2020-05-26T13:40:38Z", "type": "forcePushed"}, {"oid": "693bc0d6eb7e0a6a978f63d61bb68ef2d1b73d2e", "url": "https://github.com/crate/crate/commit/693bc0d6eb7e0a6a978f63d61bb68ef2d1b73d2e", "message": "Time is now internally stored as micros", "committedDate": "2020-05-26T18:31:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwNzEyMg==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430907122", "bodyText": "I think I'd rather be restrictive here for now and not allow any casts unless required for PostgreSQL compatibility (e.g. casting the string to time, but only if done explicitly)", "author": "mfussenegger", "createdAt": "2020-05-27T07:21:06Z", "path": "server/src/main/java/io/crate/types/DataTypes.java", "diffHunk": "@@ -170,6 +175,7 @@\n         entry(IP.id(), Set.of(STRING.id())),\n         entry(TIMESTAMPZ.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id(), TIMESTAMP.id())),\n         entry(TIMESTAMP.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id(), TIMESTAMPZ.id())),\n+        entry(TIME.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id())),", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "918d137534f32ff19b17e360e2d27467ac187cbe", "chunk": "diff --git a/server/src/main/java/io/crate/types/DataTypes.java b/server/src/main/java/io/crate/types/DataTypes.java\nindex c97c010f3d..e989314e65 100644\n--- a/server/src/main/java/io/crate/types/DataTypes.java\n+++ b/server/src/main/java/io/crate/types/DataTypes.java\n\n@@ -169,13 +168,12 @@ public final class DataTypes {\n         entry(DOUBLE.id(), NUMBER_CONVERSIONS),\n         entry(BOOLEAN.id(), Set.of(STRING.id())),\n         entry(STRING.id(), Stream.concat(\n-            Stream.of(GEO_SHAPE.id(), GEO_POINT.id(), ObjectType.ID),\n+            Stream.of(GEO_SHAPE.id(), GEO_POINT.id(), ObjectType.ID, TimeZType.ID),\n             NUMBER_CONVERSIONS.stream()\n         ).collect(toSet())),\n         entry(IP.id(), Set.of(STRING.id())),\n         entry(TIMESTAMPZ.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id(), TIMESTAMP.id())),\n         entry(TIMESTAMP.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id(), TIMESTAMPZ.id())),\n-        entry(TIME.id(), Set.of(DOUBLE.id(), LONG.id(), STRING.id())),\n         entry(UNDEFINED.id(), Set.of()), // actually convertible to every type, see NullType\n         entry(GEO_POINT.id(), Set.of()),\n         entry(GEO_SHAPE.id(), Set.of(ObjectType.ID)),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwNzM2NQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430907365", "bodyText": "Similar here. I'd leave TIME out for now.", "author": "mfussenegger", "createdAt": "2020-05-27T07:21:34Z", "path": "server/src/main/java/io/crate/types/DataTypes.java", "diffHunk": "@@ -182,10 +188,11 @@\n      * used to store the value)\n      */\n     private static final Map<Integer, Set<DataType>> SAFE_CONVERSIONS = Map.of(\n-        BYTE.id(), Set.of(SHORT, INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, FLOAT, DOUBLE),\n-        SHORT.id(), Set.of(INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, FLOAT, DOUBLE),\n-        INTEGER.id(), Set.of(LONG, TIMESTAMPZ, TIMESTAMP, FLOAT, DOUBLE),\n-        LONG.id(), Set.of(TIMESTAMPZ, TIMESTAMP, DOUBLE),\n+        BYTE.id(), Set.of(SHORT, INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n+        SHORT.id(), Set.of(INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n+        INTEGER.id(), Set.of(LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n+        LONG.id(), Set.of(TIMESTAMPZ, TIMESTAMP, TIME, DOUBLE),\n+        DOUBLE.id(), Set.of(TIME),", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "918d137534f32ff19b17e360e2d27467ac187cbe", "chunk": "diff --git a/server/src/main/java/io/crate/types/DataTypes.java b/server/src/main/java/io/crate/types/DataTypes.java\nindex c97c010f3d..e989314e65 100644\n--- a/server/src/main/java/io/crate/types/DataTypes.java\n+++ b/server/src/main/java/io/crate/types/DataTypes.java\n\n@@ -188,11 +186,10 @@ public final class DataTypes {\n      * used to store the value)\n      */\n     private static final Map<Integer, Set<DataType>> SAFE_CONVERSIONS = Map.of(\n-        BYTE.id(), Set.of(SHORT, INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n-        SHORT.id(), Set.of(INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n-        INTEGER.id(), Set.of(LONG, TIMESTAMPZ, TIMESTAMP, TIME, FLOAT, DOUBLE),\n-        LONG.id(), Set.of(TIMESTAMPZ, TIMESTAMP, TIME, DOUBLE),\n-        DOUBLE.id(), Set.of(TIME),\n+        BYTE.id(), Set.of(SHORT, INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, FLOAT, DOUBLE),\n+        SHORT.id(), Set.of(INTEGER, LONG, TIMESTAMPZ, TIMESTAMP, FLOAT, DOUBLE),\n+        INTEGER.id(), Set.of(LONG, TIMESTAMPZ, TIMESTAMP, FLOAT, DOUBLE),\n+        LONG.id(), Set.of(TIMESTAMPZ, TIMESTAMP, DOUBLE),\n         FLOAT.id(), Set.of(DOUBLE));\n \n     public static boolean isArray(DataType<?> type) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwNzg5Nw==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430907897", "bodyText": "Given that we don't want to support storage yet, can we remove this entry?", "author": "mfussenegger", "createdAt": "2020-05-27T07:22:28Z", "path": "server/src/main/java/io/crate/types/DataTypes.java", "diffHunk": "@@ -380,6 +390,7 @@ private static boolean safeConversionPossible(DataType type1, DataType type2) {\n     );\n \n     private static final Map<Integer, String> TYPE_IDS_TO_MAPPINGS = Map.ofEntries(\n+        entry(TIME.id(), \"long\"),", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "918d137534f32ff19b17e360e2d27467ac187cbe", "chunk": "diff --git a/server/src/main/java/io/crate/types/DataTypes.java b/server/src/main/java/io/crate/types/DataTypes.java\nindex c97c010f3d..e989314e65 100644\n--- a/server/src/main/java/io/crate/types/DataTypes.java\n+++ b/server/src/main/java/io/crate/types/DataTypes.java\n\n@@ -390,7 +386,6 @@ public final class DataTypes {\n     );\n \n     private static final Map<Integer, String> TYPE_IDS_TO_MAPPINGS = Map.ofEntries(\n-        entry(TIME.id(), \"long\"),\n         entry(TIMESTAMPZ.id(), \"date\"),\n         entry(TIMESTAMP.id(), \"date\"),\n         entry(STRING.id(), \"text\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwOTY2Mg==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430909662", "bodyText": "PostgreSQL doesn't support numeric conversion to time:\nselect 231221.999::time;\nERROR:  42846: cannot cast type numeric to time without time zone\nLINE 1: select 231221.999::time\n\nI think we should also restrict this and not support it.\nCompared to using a string literal, which is supported:\n# select '231221.999'::time;\n     time\n--------------\n 23:12:21.999\n(1 row)", "author": "mfussenegger", "createdAt": "2020-05-27T07:25:42Z", "path": "server/src/main/java/io/crate/types/TimeType.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.time.LocalTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.format.DateTimeParseException;\n+import java.time.format.ResolverStyle;\n+import java.time.temporal.ChronoField;\n+import java.util.Locale;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Represents time as microseconds from midnight, ignoring the time\n+ * zone and storing the value as UTC <b>long</b>.\n+ *\n+ * <p>\n+ *\n+ * There are 1000_000 microseconds in one second:\n+ *\n+ * <pre>\n+ *     (24 * 3600 + 59 * 60 + 59) * 1000_000L > Integer.MAX_VALUE\n+ * </pre>\n+ *\n+ * Thus the range for time values is 0 .. 86400000000 (max number\n+ * of micros in a day), where both extremes are equivalent to\n+ * '00:00:00:000000' and '24:00:00.000000' respectively.\n+ *\n+ * <p>\n+ *\n+ * Accepts four kinds of literal:\n+ * <ol>\n+ *    <li>text:\n+ *      <ul>\n+ *        <li>'hhmmss': e.g. '232121', equivalent to '23:12:21'</li>\n+ *        <li>'hhmm': e.g. '2312', equivalent to '23:12:00'</li>\n+ *        <li>'hh': e.g. '23', equivalent to '23:00:00'</li>\n+ *      </ul>\n+ *    </li>\n+ *\n+ *    <li>numeric:\n+ *      <ul>\n+ *        <li>integer and long values are first interpreted as\n+ *        'text'. Failing this they are kept as is, representing\n+ *        microseconds from midnight, ignoring the time zone\n+ *        and storing the value as UTC.\n+ *    </li>\n+ *\n+ *    <li>text high precision:\n+ *      <p>\n+ *      Expects up to six digits after the floating point (number of\n+ *      micro seconds), and it will right pad with zeroes if this is\n+ *      not the case. For instance the examples below are all padded\n+ *      to 999000 micro seconds.\n+ *      <ul>\n+ *        <li>'hhmmss.ffffff': e.g. '231221.999', equivalent to '23:12:21.999'</li>\n+ *        <li>'hhmm.ffffff': e.g. '2312.999', equivalent to '23:12:00.999'</li>\n+ *        <li>'hh.ffffff': e.g. '23.999', equivalent to '23:00:00.999'</li>\n+ *      </ul>\n+ *    </li>\n+ *\n+ *    <li>numeric high precision:\n+ *      <ul>\n+ *        <li>double and float values are interpreted as", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "918d137534f32ff19b17e360e2d27467ac187cbe", "chunk": "diff --git a/server/src/main/java/io/crate/types/TimeType.java b/server/src/main/java/io/crate/types/TimeType.java\ndeleted file mode 100644\nindex f69ba32ccd..0000000000\n--- a/server/src/main/java/io/crate/types/TimeType.java\n+++ /dev/null\n\n@@ -1,277 +0,0 @@\n-/*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n- */\n-\n-package io.crate.types;\n-\n-import io.crate.Streamer;\n-import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n-\n-import javax.annotation.Nonnull;\n-import java.io.IOException;\n-import java.time.LocalTime;\n-import java.time.format.DateTimeFormatter;\n-import java.time.format.DateTimeFormatterBuilder;\n-import java.time.format.DateTimeParseException;\n-import java.time.format.ResolverStyle;\n-import java.time.temporal.ChronoField;\n-import java.util.Locale;\n-import java.util.function.Supplier;\n-\n-/**\n- * Represents time as microseconds from midnight, ignoring the time\n- * zone and storing the value as UTC <b>long</b>.\n- *\n- * <p>\n- *\n- * There are 1000_000 microseconds in one second:\n- *\n- * <pre>\n- *     (24 * 3600 + 59 * 60 + 59) * 1000_000L > Integer.MAX_VALUE\n- * </pre>\n- *\n- * Thus the range for time values is 0 .. 86400000000 (max number\n- * of micros in a day), where both extremes are equivalent to\n- * '00:00:00:000000' and '24:00:00.000000' respectively.\n- *\n- * <p>\n- *\n- * Accepts four kinds of literal:\n- * <ol>\n- *    <li>text:\n- *      <ul>\n- *        <li>'hhmmss': e.g. '232121', equivalent to '23:12:21'</li>\n- *        <li>'hhmm': e.g. '2312', equivalent to '23:12:00'</li>\n- *        <li>'hh': e.g. '23', equivalent to '23:00:00'</li>\n- *      </ul>\n- *    </li>\n- *\n- *    <li>numeric:\n- *      <ul>\n- *        <li>integer and long values are first interpreted as\n- *        'text'. Failing this they are kept as is, representing\n- *        microseconds from midnight, ignoring the time zone\n- *        and storing the value as UTC.\n- *    </li>\n- *\n- *    <li>text high precision:\n- *      <p>\n- *      Expects up to six digits after the floating point (number of\n- *      micro seconds), and it will right pad with zeroes if this is\n- *      not the case. For instance the examples below are all padded\n- *      to 999000 micro seconds.\n- *      <ul>\n- *        <li>'hhmmss.ffffff': e.g. '231221.999', equivalent to '23:12:21.999'</li>\n- *        <li>'hhmm.ffffff': e.g. '2312.999', equivalent to '23:12:00.999'</li>\n- *        <li>'hh.ffffff': e.g. '23.999', equivalent to '23:00:00.999'</li>\n- *      </ul>\n- *    </li>\n- *\n- *    <li>numeric high precision:\n- *      <ul>\n- *        <li>double and float values are interpreted as\n- *        'text high precision'. Failing this, the number is not\n- *        accepted as a valid literal for time.\n- *        </li>\n- *      </ul>\n- *    </li>\n- *\n- *    <li>All ISO-8601 extended local time format.</li>\n- * </ol>\n- */\n-public final class TimeType extends DataType<Long> implements FixedWidthType, Streamer<Long> {\n-\n-    public static final int ID = 19;\n-    public static final String NAME = \"time without time zone\";\n-    public static final TimeType INSTANCE = new TimeType();\n-    public static final long MAX_MICROS = 24 * 60 * 60 * 1000_000L;\n-\n-\n-    @Override\n-    public int id() {\n-        return ID;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public Precedence precedence() {\n-        return Precedence.TIME;\n-    }\n-\n-    @Override\n-    public Streamer<Long> streamer() {\n-        return this;\n-    }\n-\n-    @Override\n-    public int compare(Long val1, Long val2) {\n-        return Long.compare(val1, val2);\n-    }\n-\n-    @Override\n-    public Long readValueFrom(StreamInput in) throws IOException {\n-        return in.readBoolean() ? null : in.readLong();\n-    }\n-\n-    @Override\n-    public void writeValueTo(StreamOutput out, Long val) throws IOException {\n-        out.writeBoolean(val == null);\n-        if (val != null) {\n-            out.writeLong(val);\n-        }\n-    }\n-\n-    @Override\n-    public int fixedSize() {\n-        return LongType.LONG_SIZE;\n-    }\n-\n-    @Override\n-    public Long value(Object value) throws ClassCastException {\n-        if (value == null) {\n-            return null;\n-        }\n-        if (value instanceof Double) {\n-            return parseTimeFromFloatingPoint(String.valueOf(((Number) value).doubleValue()));\n-        }\n-        if (value instanceof Float) {\n-            return parseTimeFromFloatingPoint(String.valueOf(((Number) value).floatValue()));\n-        }\n-        if (value instanceof Long || value instanceof Number) {\n-            long v = ((Number) value).longValue();\n-            return parseFormattedTime(String.valueOf(v), 0L, () -> v);\n-        }\n-        if (value instanceof String) {\n-            return parseTime((String) value);\n-        }\n-        throw new IllegalArgumentException(String.format(\n-            Locale.ENGLISH,\n-            \"unexpected value [%s] is not a valid literal for type %s\",\n-            value, TimeType.class.getSimpleName()));\n-    }\n-\n-    private static long parseTimeFromFloatingPoint(@Nonnull String time) {\n-        int dotIdx = time.indexOf(\".\");\n-        String format = time.substring(0, dotIdx);\n-        String micros = time.substring(dotIdx + 1);\n-        int padding = 6 - micros.length();\n-        if (padding > 0) {\n-            StringBuilder sb = new StringBuilder(6);\n-            sb.append(micros);\n-            for (int i = 0; i < padding; i++) {\n-                sb.append(\"0\");\n-            }\n-            micros = sb.toString();\n-        }\n-        return parseFormattedTime(format, Integer.valueOf(micros), () -> {\n-            throw new IllegalArgumentException(String.format(\n-                Locale.ENGLISH,\n-                \"value [%s] is not a valid literal for type %s\",\n-                time, TimeType.class.getSimpleName()));\n-        });\n-    }\n-\n-    private static long parseFormattedTime(@Nonnull String time, long micros, Supplier<Long> defaultSupplier) {\n-        switch (time.length()) {\n-            case 6:\n-                // hhmmss\n-                int hh = Integer.parseInt(time.substring(0, 2));\n-                int mm = Integer.parseInt(time.substring(2, 4));\n-                int ss = Integer.parseInt(time.substring(4));\n-                return toEpochMicro(hh, mm, ss, micros);\n-\n-            case 4:\n-                // hhmm\n-                hh = Integer.parseInt(time.substring(0, 2));\n-                mm = Integer.parseInt(time.substring(2, 4));\n-                return toEpochMicro(hh, mm, 0, micros);\n-\n-            case 2:\n-                // hh\n-                hh = Integer.parseInt(time.substring(0, 2));\n-                return toEpochMicro(hh, 0, 0, micros);\n-\n-            default:\n-                return checkRange(defaultSupplier.get());\n-        }\n-    }\n-\n-    private static long toEpochMicro(int hh, int mm, int ss, long micros) {\n-        checkRange(\"hh\", hh, 0, 24);\n-        checkRange(\"mm\", mm, 0, 59);\n-        checkRange(\"ss\", ss, 0, 59);\n-        checkRange(\"micros\", micros, 0, 999999L);\n-        return checkRange(((((hh * 60 + mm) * 60) + ss) * 1000_000L + micros));\n-    }\n-\n-    private static long checkRange(long epochMicro) {\n-        return checkRange(TimeType.class.getSimpleName(), epochMicro, 0, MAX_MICROS);\n-    }\n-\n-    private static long checkRange(String name, long value, long min, long max) {\n-        if (value < min || value > max) {\n-            throw new IllegalArgumentException(String.format(\n-                Locale.ENGLISH,\n-                \"value [%d] is out of range for '%s' [0, %d]\",\n-                value, name, max));\n-        }\n-        return value;\n-    }\n-\n-    public static long parseTime(@Nonnull String format) {\n-        try {\n-            long v = Long.parseLong(format);\n-            return parseFormattedTime(format, 0L, () -> v);\n-        } catch (NumberFormatException e0) {\n-            try {\n-                Double.parseDouble(format);\n-                return parseTimeFromFloatingPoint(format);\n-            } catch (NumberFormatException e1) {\n-                try {\n-                    // the time zone is ignored if present\n-                    return LocalTime\n-                        .parse(format, TIME_PARSER)\n-                        .getLong(ChronoField.MICRO_OF_DAY);\n-                } catch (DateTimeParseException e2) {\n-                    throw new IllegalArgumentException(String.format(\n-                        Locale.ENGLISH, \"value [%s] is not a valid literal for TimeType\", format));\n-                }\n-            }\n-        }\n-    }\n-\n-    public static String formatTime(@Nonnull Long time) {\n-        return LocalTime\n-            .ofNanoOfDay(time * 1000L)\n-            .format(DateTimeFormatter.ISO_LOCAL_TIME);\n-    }\n-\n-    private static final DateTimeFormatter TIME_PARSER = new DateTimeFormatterBuilder()\n-        .append(DateTimeFormatter.ISO_LOCAL_TIME)\n-        .optionalStart()\n-            .appendPattern(\"[Z][VV][x][xx][xxx]\")\n-        .toFormatter(Locale.ENGLISH)\n-        .withResolverStyle(ResolverStyle.STRICT);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMDM1OQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430910359", "bodyText": "PostgreSQL also seems to support : inbetween:\nselect '14:32'::time;\n   time\n----------\n 14:32:00\n(1 row)\n\nCan we extend this?", "author": "mfussenegger", "createdAt": "2020-05-27T07:27:00Z", "path": "server/src/main/java/io/crate/types/TimeType.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.time.LocalTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.format.DateTimeParseException;\n+import java.time.format.ResolverStyle;\n+import java.time.temporal.ChronoField;\n+import java.util.Locale;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Represents time as microseconds from midnight, ignoring the time\n+ * zone and storing the value as UTC <b>long</b>.\n+ *\n+ * <p>\n+ *\n+ * There are 1000_000 microseconds in one second:\n+ *\n+ * <pre>\n+ *     (24 * 3600 + 59 * 60 + 59) * 1000_000L > Integer.MAX_VALUE\n+ * </pre>\n+ *\n+ * Thus the range for time values is 0 .. 86400000000 (max number\n+ * of micros in a day), where both extremes are equivalent to\n+ * '00:00:00:000000' and '24:00:00.000000' respectively.\n+ *\n+ * <p>\n+ *\n+ * Accepts four kinds of literal:\n+ * <ol>\n+ *    <li>text:\n+ *      <ul>\n+ *        <li>'hhmmss': e.g. '232121', equivalent to '23:12:21'</li>", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "918d137534f32ff19b17e360e2d27467ac187cbe", "chunk": "diff --git a/server/src/main/java/io/crate/types/TimeType.java b/server/src/main/java/io/crate/types/TimeType.java\ndeleted file mode 100644\nindex f69ba32ccd..0000000000\n--- a/server/src/main/java/io/crate/types/TimeType.java\n+++ /dev/null\n\n@@ -1,277 +0,0 @@\n-/*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n- */\n-\n-package io.crate.types;\n-\n-import io.crate.Streamer;\n-import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n-\n-import javax.annotation.Nonnull;\n-import java.io.IOException;\n-import java.time.LocalTime;\n-import java.time.format.DateTimeFormatter;\n-import java.time.format.DateTimeFormatterBuilder;\n-import java.time.format.DateTimeParseException;\n-import java.time.format.ResolverStyle;\n-import java.time.temporal.ChronoField;\n-import java.util.Locale;\n-import java.util.function.Supplier;\n-\n-/**\n- * Represents time as microseconds from midnight, ignoring the time\n- * zone and storing the value as UTC <b>long</b>.\n- *\n- * <p>\n- *\n- * There are 1000_000 microseconds in one second:\n- *\n- * <pre>\n- *     (24 * 3600 + 59 * 60 + 59) * 1000_000L > Integer.MAX_VALUE\n- * </pre>\n- *\n- * Thus the range for time values is 0 .. 86400000000 (max number\n- * of micros in a day), where both extremes are equivalent to\n- * '00:00:00:000000' and '24:00:00.000000' respectively.\n- *\n- * <p>\n- *\n- * Accepts four kinds of literal:\n- * <ol>\n- *    <li>text:\n- *      <ul>\n- *        <li>'hhmmss': e.g. '232121', equivalent to '23:12:21'</li>\n- *        <li>'hhmm': e.g. '2312', equivalent to '23:12:00'</li>\n- *        <li>'hh': e.g. '23', equivalent to '23:00:00'</li>\n- *      </ul>\n- *    </li>\n- *\n- *    <li>numeric:\n- *      <ul>\n- *        <li>integer and long values are first interpreted as\n- *        'text'. Failing this they are kept as is, representing\n- *        microseconds from midnight, ignoring the time zone\n- *        and storing the value as UTC.\n- *    </li>\n- *\n- *    <li>text high precision:\n- *      <p>\n- *      Expects up to six digits after the floating point (number of\n- *      micro seconds), and it will right pad with zeroes if this is\n- *      not the case. For instance the examples below are all padded\n- *      to 999000 micro seconds.\n- *      <ul>\n- *        <li>'hhmmss.ffffff': e.g. '231221.999', equivalent to '23:12:21.999'</li>\n- *        <li>'hhmm.ffffff': e.g. '2312.999', equivalent to '23:12:00.999'</li>\n- *        <li>'hh.ffffff': e.g. '23.999', equivalent to '23:00:00.999'</li>\n- *      </ul>\n- *    </li>\n- *\n- *    <li>numeric high precision:\n- *      <ul>\n- *        <li>double and float values are interpreted as\n- *        'text high precision'. Failing this, the number is not\n- *        accepted as a valid literal for time.\n- *        </li>\n- *      </ul>\n- *    </li>\n- *\n- *    <li>All ISO-8601 extended local time format.</li>\n- * </ol>\n- */\n-public final class TimeType extends DataType<Long> implements FixedWidthType, Streamer<Long> {\n-\n-    public static final int ID = 19;\n-    public static final String NAME = \"time without time zone\";\n-    public static final TimeType INSTANCE = new TimeType();\n-    public static final long MAX_MICROS = 24 * 60 * 60 * 1000_000L;\n-\n-\n-    @Override\n-    public int id() {\n-        return ID;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public Precedence precedence() {\n-        return Precedence.TIME;\n-    }\n-\n-    @Override\n-    public Streamer<Long> streamer() {\n-        return this;\n-    }\n-\n-    @Override\n-    public int compare(Long val1, Long val2) {\n-        return Long.compare(val1, val2);\n-    }\n-\n-    @Override\n-    public Long readValueFrom(StreamInput in) throws IOException {\n-        return in.readBoolean() ? null : in.readLong();\n-    }\n-\n-    @Override\n-    public void writeValueTo(StreamOutput out, Long val) throws IOException {\n-        out.writeBoolean(val == null);\n-        if (val != null) {\n-            out.writeLong(val);\n-        }\n-    }\n-\n-    @Override\n-    public int fixedSize() {\n-        return LongType.LONG_SIZE;\n-    }\n-\n-    @Override\n-    public Long value(Object value) throws ClassCastException {\n-        if (value == null) {\n-            return null;\n-        }\n-        if (value instanceof Double) {\n-            return parseTimeFromFloatingPoint(String.valueOf(((Number) value).doubleValue()));\n-        }\n-        if (value instanceof Float) {\n-            return parseTimeFromFloatingPoint(String.valueOf(((Number) value).floatValue()));\n-        }\n-        if (value instanceof Long || value instanceof Number) {\n-            long v = ((Number) value).longValue();\n-            return parseFormattedTime(String.valueOf(v), 0L, () -> v);\n-        }\n-        if (value instanceof String) {\n-            return parseTime((String) value);\n-        }\n-        throw new IllegalArgumentException(String.format(\n-            Locale.ENGLISH,\n-            \"unexpected value [%s] is not a valid literal for type %s\",\n-            value, TimeType.class.getSimpleName()));\n-    }\n-\n-    private static long parseTimeFromFloatingPoint(@Nonnull String time) {\n-        int dotIdx = time.indexOf(\".\");\n-        String format = time.substring(0, dotIdx);\n-        String micros = time.substring(dotIdx + 1);\n-        int padding = 6 - micros.length();\n-        if (padding > 0) {\n-            StringBuilder sb = new StringBuilder(6);\n-            sb.append(micros);\n-            for (int i = 0; i < padding; i++) {\n-                sb.append(\"0\");\n-            }\n-            micros = sb.toString();\n-        }\n-        return parseFormattedTime(format, Integer.valueOf(micros), () -> {\n-            throw new IllegalArgumentException(String.format(\n-                Locale.ENGLISH,\n-                \"value [%s] is not a valid literal for type %s\",\n-                time, TimeType.class.getSimpleName()));\n-        });\n-    }\n-\n-    private static long parseFormattedTime(@Nonnull String time, long micros, Supplier<Long> defaultSupplier) {\n-        switch (time.length()) {\n-            case 6:\n-                // hhmmss\n-                int hh = Integer.parseInt(time.substring(0, 2));\n-                int mm = Integer.parseInt(time.substring(2, 4));\n-                int ss = Integer.parseInt(time.substring(4));\n-                return toEpochMicro(hh, mm, ss, micros);\n-\n-            case 4:\n-                // hhmm\n-                hh = Integer.parseInt(time.substring(0, 2));\n-                mm = Integer.parseInt(time.substring(2, 4));\n-                return toEpochMicro(hh, mm, 0, micros);\n-\n-            case 2:\n-                // hh\n-                hh = Integer.parseInt(time.substring(0, 2));\n-                return toEpochMicro(hh, 0, 0, micros);\n-\n-            default:\n-                return checkRange(defaultSupplier.get());\n-        }\n-    }\n-\n-    private static long toEpochMicro(int hh, int mm, int ss, long micros) {\n-        checkRange(\"hh\", hh, 0, 24);\n-        checkRange(\"mm\", mm, 0, 59);\n-        checkRange(\"ss\", ss, 0, 59);\n-        checkRange(\"micros\", micros, 0, 999999L);\n-        return checkRange(((((hh * 60 + mm) * 60) + ss) * 1000_000L + micros));\n-    }\n-\n-    private static long checkRange(long epochMicro) {\n-        return checkRange(TimeType.class.getSimpleName(), epochMicro, 0, MAX_MICROS);\n-    }\n-\n-    private static long checkRange(String name, long value, long min, long max) {\n-        if (value < min || value > max) {\n-            throw new IllegalArgumentException(String.format(\n-                Locale.ENGLISH,\n-                \"value [%d] is out of range for '%s' [0, %d]\",\n-                value, name, max));\n-        }\n-        return value;\n-    }\n-\n-    public static long parseTime(@Nonnull String format) {\n-        try {\n-            long v = Long.parseLong(format);\n-            return parseFormattedTime(format, 0L, () -> v);\n-        } catch (NumberFormatException e0) {\n-            try {\n-                Double.parseDouble(format);\n-                return parseTimeFromFloatingPoint(format);\n-            } catch (NumberFormatException e1) {\n-                try {\n-                    // the time zone is ignored if present\n-                    return LocalTime\n-                        .parse(format, TIME_PARSER)\n-                        .getLong(ChronoField.MICRO_OF_DAY);\n-                } catch (DateTimeParseException e2) {\n-                    throw new IllegalArgumentException(String.format(\n-                        Locale.ENGLISH, \"value [%s] is not a valid literal for TimeType\", format));\n-                }\n-            }\n-        }\n-    }\n-\n-    public static String formatTime(@Nonnull Long time) {\n-        return LocalTime\n-            .ofNanoOfDay(time * 1000L)\n-            .format(DateTimeFormatter.ISO_LOCAL_TIME);\n-    }\n-\n-    private static final DateTimeFormatter TIME_PARSER = new DateTimeFormatterBuilder()\n-        .append(DateTimeFormatter.ISO_LOCAL_TIME)\n-        .optionalStart()\n-            .appendPattern(\"[Z][VV][x][xx][xxx]\")\n-        .toFormatter(Locale.ENGLISH)\n-        .withResolverStyle(ResolverStyle.STRICT);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwNzM5OA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430907398", "bodyText": "i think we do not need two entries for one type in the precedence", "author": "kovrus", "createdAt": "2020-05-27T07:21:37Z", "path": "server/src/main/java/io/crate/types/DataType.java", "diffHunk": "@@ -52,6 +52,8 @@\n         BYTE,\n         BOOLEAN,\n         SHORT,\n+        TIME_WITHOUT_TIME_ZONE,\n+        TIME,", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8700fd3699eff185f7416a200f8f7b5fe1f163e8", "chunk": "diff --git a/server/src/main/java/io/crate/types/DataType.java b/server/src/main/java/io/crate/types/DataType.java\nindex 36269f8dd9..8d5fd94d62 100644\n--- a/server/src/main/java/io/crate/types/DataType.java\n+++ b/server/src/main/java/io/crate/types/DataType.java\n\n@@ -52,13 +52,13 @@ public abstract class DataType<T> implements Comparable<DataType<?>>, Writeable,\n         BYTE,\n         BOOLEAN,\n         SHORT,\n-        TIME_WITHOUT_TIME_ZONE,\n-        TIME,\n+        TIMETZ,\n         INTEGER,\n         INTERVAL,\n         TIMESTAMP_WITH_TIME_ZONE,\n         TIMESTAMP,\n         LONG,\n+        IP,\n         FLOAT,\n         DOUBLE,\n         ARRAY,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwNzc1Mg==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430907752", "bodyText": "in pg it is just time\ntemplate1=# select typname from pg_catalog.pg_type where oid = 1083;\n typname\n---------\n time\n(1 row)", "author": "kovrus", "createdAt": "2020-05-27T07:22:13Z", "path": "server/src/main/java/io/crate/protocols/postgres/types/TimeType.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres.types;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import javax.annotation.Nonnull;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+\n+import static io.crate.types.TimeType.parseTime;\n+import static io.crate.types.TimeType.formatTime;\n+\n+\n+final class TimeType extends PGType<Long> {\n+\n+    public static final PGType<Long> INSTANCE = new TimeType();\n+\n+    private static final int OID = 1083;\n+    private static final int TYPE_MOD = -1;\n+    private static final int TYPE_LEN = 8;\n+    private static final String TYPE_NAME = \"time without time zone\";", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "918d137534f32ff19b17e360e2d27467ac187cbe", "chunk": "diff --git a/server/src/main/java/io/crate/protocols/postgres/types/TimeType.java b/server/src/main/java/io/crate/protocols/postgres/types/TimeZType.java\nsimilarity index 87%\nrename from server/src/main/java/io/crate/protocols/postgres/types/TimeType.java\nrename to server/src/main/java/io/crate/protocols/postgres/types/TimeZType.java\nindex 4237bd7f3f..100cfc8ede 100644\n--- a/server/src/main/java/io/crate/protocols/postgres/types/TimeType.java\n+++ b/server/src/main/java/io/crate/protocols/postgres/types/TimeZType.java\n\n@@ -28,22 +28,22 @@ import javax.annotation.Nonnull;\n import java.nio.charset.StandardCharsets;\n import java.util.Locale;\n \n-import static io.crate.types.TimeType.parseTime;\n-import static io.crate.types.TimeType.formatTime;\n+import static io.crate.types.TimeZType.parseTime;\n+import static io.crate.types.TimeZType.formatTime;\n+import static io.crate.types.TimeZType.NAME;\n \n \n-final class TimeType extends PGType<Long> {\n+final class TimeZType extends PGType<Long> {\n \n-    public static final PGType<Long> INSTANCE = new TimeType();\n+    public static final PGType<Long> INSTANCE = new TimeZType();\n \n     private static final int OID = 1083;\n     private static final int TYPE_MOD = -1;\n     private static final int TYPE_LEN = 8;\n-    private static final String TYPE_NAME = \"time without time zone\";\n \n \n-    TimeType() {\n-        super(OID, TYPE_LEN, TYPE_MOD, TYPE_NAME);\n+    TimeZType() {\n+        super(OID, TYPE_LEN, TYPE_MOD, NAME);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwODU4NQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430908585", "bodyText": "should be removed ?", "author": "kovrus", "createdAt": "2020-05-27T07:23:47Z", "path": "server/src/test/java/io/crate/planner/selectivity/SelectivityFunctionsTest.java", "diffHunk": "@@ -24,6 +25,7 @@\n \n public class SelectivityFunctionsTest extends CrateDummyClusterServiceUnitTest {\n \n+    @Seed(\"BAAF67D01CA68AAE\")", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "918d137534f32ff19b17e360e2d27467ac187cbe", "chunk": "diff --git a/server/src/test/java/io/crate/planner/selectivity/SelectivityFunctionsTest.java b/server/src/test/java/io/crate/planner/selectivity/SelectivityFunctionsTest.java\nindex 302b39a382..27f118d8b6 100644\n--- a/server/src/test/java/io/crate/planner/selectivity/SelectivityFunctionsTest.java\n+++ b/server/src/test/java/io/crate/planner/selectivity/SelectivityFunctionsTest.java\n\n@@ -25,7 +24,6 @@ import java.util.stream.IntStream;\n \n public class SelectivityFunctionsTest extends CrateDummyClusterServiceUnitTest {\n \n-    @Seed(\"BAAF67D01CA68AAE\")\n     @Test\n     public void test_eq_not_in_mcv_is_based_on_approx_distinct() {\n         SqlExpressions expressions = new SqlExpressions(T3.sources(clusterService));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwOTUwMA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430909500", "bodyText": "maybe extends CrateUnitTest, you also will get  ExpectedException from base class", "author": "kovrus", "createdAt": "2020-05-27T07:25:25Z", "path": "server/src/test/java/io/crate/types/TimeTypeTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+package io.crate.types;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.util.function.Function;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+\n+public class TimeTypeTest {\n+\n+    @Rule\n+    public ExpectedException expectedException = ExpectedException.none();", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "918d137534f32ff19b17e360e2d27467ac187cbe", "chunk": "diff --git a/server/src/test/java/io/crate/types/TimeTypeTest.java b/server/src/test/java/io/crate/types/TimeTypeTest.java\ndeleted file mode 100644\nindex 3610c0393c..0000000000\n--- a/server/src/test/java/io/crate/types/TimeTypeTest.java\n+++ /dev/null\n\n@@ -1,186 +0,0 @@\n-package io.crate.types;\n-\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-\n-import java.util.function.Function;\n-\n-import static org.hamcrest.Matchers.is;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertThat;\n-\n-public class TimeTypeTest {\n-\n-    @Rule\n-    public ExpectedException expectedException = ExpectedException.none();\n-\n-    @Test\n-    public void test_parse_time_range_overflow() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [86400000001] is out of range for 'TimeType' [0, 86400000000]\");\n-        TimeType.parseTime(String.valueOf(24 * 3600 * 1000_000L + 1));\n-    }\n-\n-    @Test\n-    public void test_parse_time_range_underflow() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [-86400000000] is out of range for 'TimeType' [0, 86400000000]\");\n-        TimeType.parseTime(String.valueOf(-24 * 3600 * 1000_000L));\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hh() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [25] is out of range for 'hh' [0, 24]\");\n-        TimeType.parseTime(\"25\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hhmm() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [78] is out of range for 'mm' [0, 59]\");\n-        TimeType.parseTime(\"1778\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hhmmss() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [78] is out of range for 'ss' [0, 59]\");\n-        TimeType.parseTime(\"175978\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hh_floating_point() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [25] is out of range for 'hh' [0, 24]\");\n-        TimeType.parseTime(\"25.999999\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hhmm_floating_point() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [78] is out of range for 'mm' [0, 59]\");\n-        TimeType.parseTime(\"1778.999999\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hhmmss_floating_point() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [78] is out of range for 'ss' [0, 59]\");\n-        TimeType.parseTime(\"175978.999999\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_micros_floating_point() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [9999999] is out of range for 'micros' [0, 999999]\");\n-        TimeType.parseTime(\"00.9999999\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_range_overflow_take_two() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [86400999000] is out of range for 'TimeType' [0, 86400000000]\");\n-        TimeType.parseTime(\"240000.999\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_midnight_when_ISO_parser_does_not_like_it() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [24:00:00.000] is not a valid literal for TimeType\");\n-        TimeType.parseTime(\"24:00:00.000\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_midnight_when_ISO_parser_does_like_it() {\n-        assertThat(TimeType.parseTime(\"240000.000\"), is(24 * 60 * 60 * 1000_000L));\n-    }\n-\n-    @Test\n-    public void test_parse_time_should_always_ignore_time_zone() {\n-        assertThat(TimeType.parseTime(\"01:00:00Z\"), is(3600000000L));\n-        assertThat(TimeType.parseTime(\"01:00:00+00\"), is(3600000000L));\n-        assertThat(TimeType.parseTime(\"04:00:00-03:00\"), is(14400000000L));\n-        assertThat(TimeType.parseTime(\"04:00:00+0300\"), is(14400000000L));\n-        assertThat(TimeType.parseTime(\"04:00:00+03:00\"), is(14400000000L));\n-        assertThat(TimeType.parseTime(\"04:00:00.123456789+03:00\"), is(14400123456L));\n-        assertThat(TimeType.parseTime(\"04:00:00+0000\"), is(14400000000L));\n-        assertThat(TimeType.parseTime(\"04:00:00.123456789-0000\"), is(14400123456L));\n-    }\n-\n-    @Test\n-    public void test_parse_time_no_time_zone_explicitly_mentioned() {\n-        assertThat(TimeType.parseTime(\"04:00:00\"), is(14400000000L));\n-        assertThat(TimeType.parseTime(\"14400000\"), is(14400000L));\n-        assertThat(TimeType.parseTime(\"04:00:00.123456789\"), is(14400123456L));\n-        assertThat(TimeType.parseTime(\"14400123\"), is(14400123L));\n-    }\n-\n-    @Test\n-    public void test_format_time() {\n-        assertThat(TimeType.formatTime(14400000000L), is(\"04:00:00\"));\n-        assertThat(TimeType.formatTime(14400123000L), is(\"04:00:00.123\"));\n-    }\n-\n-    @Test\n-    public void test_value() {\n-\n-        Function<Object, Long> fun = TimeType.INSTANCE::value;\n-\n-        assertNull(fun.apply(null));\n-        assertThat(fun.apply(\"01:00:00.000\"), is(3600000000L));\n-        assertThat(fun.apply(\"00:01:00.000\"), is(60000000L));\n-        assertThat(fun.apply(\"00:00:01.000\"), is(1000000L));\n-        assertThat(fun.apply(\"00:00:00.000\"), is(0L));\n-        assertThat(fun.apply(\"23:59:59.999998\"), is(24 * 60 * 60 * 1000_000L - 2L));\n-\n-        assertThat(fun.apply(\"010000.000\"), is(3600000000L));\n-        assertThat(fun.apply(\"000100.000\"), is(60000000L));\n-        assertThat(fun.apply(\"000001.000\"), is(1000000L));\n-        assertThat(fun.apply(\"000000.000\"), is(0L));\n-        assertThat(fun.apply(\"235959.999998\"), is(24 * 60 * 60 * 1000_000L - 2L));\n-\n-        assertThat(fun.apply(\"235959.998\"), is(24 * 60 * 60 * 1000_000L - 2000L));\n-        assertThat(fun.apply(\"240000.000\"), is(24 * 60 * 60 * 1000_000L));\n-\n-        assertThat(fun.apply(\"010000\"), is(3600000000L)); // same as 01:00:00.000\n-        assertThat(fun.apply(\"000100\"), is(60000000L));\n-        assertThat(fun.apply(\"000001\"), is(1000000L));\n-        assertThat(fun.apply(\"000000\"), is(0L));\n-        assertThat(fun.apply(\"235959\"), is(24 * 60 * 60 * 1000_000L - 1000_000L));\n-\n-        assertThat(fun.apply(\"010000000\"), is(10000000L));\n-        assertThat(fun.apply(\"000100000\"), is(100000L));\n-        assertThat(fun.apply(\"000001000\"), is(1000L));\n-        assertThat(fun.apply(\"000000000\"), is(0L));\n-        assertThat(fun.apply(String.valueOf(24 * 60 * 60 * 1000L - 1L)), is(24 * 60 * 60 * 1000 - 1L));\n-\n-        assertThat(fun.apply(100000.987), is(36000987000L));\n-        assertThat(fun.apply(100100.987), is(36060987000L));\n-        assertThat(fun.apply(100003.14159), is(36003141590L));\n-        assertThat(fun.apply(100000.321), is(36000321000L));\n-\n-        // floats drop precision, but you can still use them\n-        assertThat(fun.apply(100000.987F), is(36000984000L));\n-        assertThat(fun.apply(100100.987F), is(36060984000L));\n-        assertThat(fun.apply(100003.14159F), is(36003140000L));\n-        assertThat(fun.apply(100000.321F), is(36000320000L));\n-\n-        assertThat(fun.apply(10000), is(10000L));\n-        assertThat(fun.apply(100), is(100L));\n-        assertThat(fun.apply(1), is(1L));\n-        assertThat(fun.apply(0), is(0L));\n-        assertThat(fun.apply(25959), is(25959L));\n-        assertThat(fun.apply((short) 144), is(144L));\n-\n-        assertThat(fun.apply(\"01:00:00Z\"), is(3600000000L));\n-        assertThat(fun.apply(\"01:00:00+00\"), is(3600000000L));\n-        assertThat(fun.apply(\"04:00:00-03:00\"), is(14400000000L));\n-        assertThat(fun.apply(\"04:00:00+0300\"), is(14400000000L));\n-        assertThat(fun.apply(\"04:00:00+03:00\"), is(14400000000L));\n-        assertThat(fun.apply(\"04:00:00.123456789+03:00\"), is(14400123456L));\n-        assertThat(fun.apply(\"04:00:00+0000\"), is(14400000000L));\n-        assertThat(fun.apply(\"04:00:00.123456789-0000\"), is(14400123456L));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMDYwNw==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430910607", "bodyText": "this test case has around 60 assertions, is it possible to reduce or split it?", "author": "kovrus", "createdAt": "2020-05-27T07:27:26Z", "path": "server/src/test/java/io/crate/types/TimeTypeTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+package io.crate.types;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.util.function.Function;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+\n+public class TimeTypeTest {\n+\n+    @Rule\n+    public ExpectedException expectedException = ExpectedException.none();\n+\n+    @Test\n+    public void test_parse_time_range_overflow() {\n+        expectedException.expect(IllegalArgumentException.class);\n+        expectedException.expectMessage(\"value [86400000001] is out of range for 'TimeType' [0, 86400000000]\");\n+        TimeType.parseTime(String.valueOf(24 * 3600 * 1000_000L + 1));\n+    }\n+\n+    @Test\n+    public void test_parse_time_range_underflow() {\n+        expectedException.expect(IllegalArgumentException.class);\n+        expectedException.expectMessage(\"value [-86400000000] is out of range for 'TimeType' [0, 86400000000]\");\n+        TimeType.parseTime(String.valueOf(-24 * 3600 * 1000_000L));\n+    }\n+\n+    @Test\n+    public void test_parse_time_out_of_range_hh() {\n+        expectedException.expect(IllegalArgumentException.class);\n+        expectedException.expectMessage(\"value [25] is out of range for 'hh' [0, 24]\");\n+        TimeType.parseTime(\"25\");\n+    }\n+\n+    @Test\n+    public void test_parse_time_out_of_range_hhmm() {\n+        expectedException.expect(IllegalArgumentException.class);\n+        expectedException.expectMessage(\"value [78] is out of range for 'mm' [0, 59]\");\n+        TimeType.parseTime(\"1778\");\n+    }\n+\n+    @Test\n+    public void test_parse_time_out_of_range_hhmmss() {\n+        expectedException.expect(IllegalArgumentException.class);\n+        expectedException.expectMessage(\"value [78] is out of range for 'ss' [0, 59]\");\n+        TimeType.parseTime(\"175978\");\n+    }\n+\n+    @Test\n+    public void test_parse_time_out_of_range_hh_floating_point() {\n+        expectedException.expect(IllegalArgumentException.class);\n+        expectedException.expectMessage(\"value [25] is out of range for 'hh' [0, 24]\");\n+        TimeType.parseTime(\"25.999999\");\n+    }\n+\n+    @Test\n+    public void test_parse_time_out_of_range_hhmm_floating_point() {\n+        expectedException.expect(IllegalArgumentException.class);\n+        expectedException.expectMessage(\"value [78] is out of range for 'mm' [0, 59]\");\n+        TimeType.parseTime(\"1778.999999\");\n+    }\n+\n+    @Test\n+    public void test_parse_time_out_of_range_hhmmss_floating_point() {\n+        expectedException.expect(IllegalArgumentException.class);\n+        expectedException.expectMessage(\"value [78] is out of range for 'ss' [0, 59]\");\n+        TimeType.parseTime(\"175978.999999\");\n+    }\n+\n+    @Test\n+    public void test_parse_time_out_of_range_micros_floating_point() {\n+        expectedException.expect(IllegalArgumentException.class);\n+        expectedException.expectMessage(\"value [9999999] is out of range for 'micros' [0, 999999]\");\n+        TimeType.parseTime(\"00.9999999\");\n+    }\n+\n+    @Test\n+    public void test_parse_time_range_overflow_take_two() {\n+        expectedException.expect(IllegalArgumentException.class);\n+        expectedException.expectMessage(\"value [86400999000] is out of range for 'TimeType' [0, 86400000000]\");\n+        TimeType.parseTime(\"240000.999\");\n+    }\n+\n+    @Test\n+    public void test_parse_time_midnight_when_ISO_parser_does_not_like_it() {\n+        expectedException.expect(IllegalArgumentException.class);\n+        expectedException.expectMessage(\"value [24:00:00.000] is not a valid literal for TimeType\");\n+        TimeType.parseTime(\"24:00:00.000\");\n+    }\n+\n+    @Test\n+    public void test_parse_time_midnight_when_ISO_parser_does_like_it() {\n+        assertThat(TimeType.parseTime(\"240000.000\"), is(24 * 60 * 60 * 1000_000L));\n+    }\n+\n+    @Test\n+    public void test_parse_time_should_always_ignore_time_zone() {\n+        assertThat(TimeType.parseTime(\"01:00:00Z\"), is(3600000000L));\n+        assertThat(TimeType.parseTime(\"01:00:00+00\"), is(3600000000L));\n+        assertThat(TimeType.parseTime(\"04:00:00-03:00\"), is(14400000000L));\n+        assertThat(TimeType.parseTime(\"04:00:00+0300\"), is(14400000000L));\n+        assertThat(TimeType.parseTime(\"04:00:00+03:00\"), is(14400000000L));\n+        assertThat(TimeType.parseTime(\"04:00:00.123456789+03:00\"), is(14400123456L));\n+        assertThat(TimeType.parseTime(\"04:00:00+0000\"), is(14400000000L));\n+        assertThat(TimeType.parseTime(\"04:00:00.123456789-0000\"), is(14400123456L));\n+    }\n+\n+    @Test\n+    public void test_parse_time_no_time_zone_explicitly_mentioned() {\n+        assertThat(TimeType.parseTime(\"04:00:00\"), is(14400000000L));\n+        assertThat(TimeType.parseTime(\"14400000\"), is(14400000L));\n+        assertThat(TimeType.parseTime(\"04:00:00.123456789\"), is(14400123456L));\n+        assertThat(TimeType.parseTime(\"14400123\"), is(14400123L));\n+    }\n+\n+    @Test\n+    public void test_format_time() {\n+        assertThat(TimeType.formatTime(14400000000L), is(\"04:00:00\"));\n+        assertThat(TimeType.formatTime(14400123000L), is(\"04:00:00.123\"));\n+    }\n+\n+    @Test\n+    public void test_value() {", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "918d137534f32ff19b17e360e2d27467ac187cbe", "chunk": "diff --git a/server/src/test/java/io/crate/types/TimeTypeTest.java b/server/src/test/java/io/crate/types/TimeTypeTest.java\ndeleted file mode 100644\nindex 3610c0393c..0000000000\n--- a/server/src/test/java/io/crate/types/TimeTypeTest.java\n+++ /dev/null\n\n@@ -1,186 +0,0 @@\n-package io.crate.types;\n-\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-\n-import java.util.function.Function;\n-\n-import static org.hamcrest.Matchers.is;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertThat;\n-\n-public class TimeTypeTest {\n-\n-    @Rule\n-    public ExpectedException expectedException = ExpectedException.none();\n-\n-    @Test\n-    public void test_parse_time_range_overflow() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [86400000001] is out of range for 'TimeType' [0, 86400000000]\");\n-        TimeType.parseTime(String.valueOf(24 * 3600 * 1000_000L + 1));\n-    }\n-\n-    @Test\n-    public void test_parse_time_range_underflow() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [-86400000000] is out of range for 'TimeType' [0, 86400000000]\");\n-        TimeType.parseTime(String.valueOf(-24 * 3600 * 1000_000L));\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hh() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [25] is out of range for 'hh' [0, 24]\");\n-        TimeType.parseTime(\"25\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hhmm() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [78] is out of range for 'mm' [0, 59]\");\n-        TimeType.parseTime(\"1778\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hhmmss() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [78] is out of range for 'ss' [0, 59]\");\n-        TimeType.parseTime(\"175978\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hh_floating_point() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [25] is out of range for 'hh' [0, 24]\");\n-        TimeType.parseTime(\"25.999999\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hhmm_floating_point() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [78] is out of range for 'mm' [0, 59]\");\n-        TimeType.parseTime(\"1778.999999\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_hhmmss_floating_point() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [78] is out of range for 'ss' [0, 59]\");\n-        TimeType.parseTime(\"175978.999999\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_out_of_range_micros_floating_point() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [9999999] is out of range for 'micros' [0, 999999]\");\n-        TimeType.parseTime(\"00.9999999\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_range_overflow_take_two() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [86400999000] is out of range for 'TimeType' [0, 86400000000]\");\n-        TimeType.parseTime(\"240000.999\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_midnight_when_ISO_parser_does_not_like_it() {\n-        expectedException.expect(IllegalArgumentException.class);\n-        expectedException.expectMessage(\"value [24:00:00.000] is not a valid literal for TimeType\");\n-        TimeType.parseTime(\"24:00:00.000\");\n-    }\n-\n-    @Test\n-    public void test_parse_time_midnight_when_ISO_parser_does_like_it() {\n-        assertThat(TimeType.parseTime(\"240000.000\"), is(24 * 60 * 60 * 1000_000L));\n-    }\n-\n-    @Test\n-    public void test_parse_time_should_always_ignore_time_zone() {\n-        assertThat(TimeType.parseTime(\"01:00:00Z\"), is(3600000000L));\n-        assertThat(TimeType.parseTime(\"01:00:00+00\"), is(3600000000L));\n-        assertThat(TimeType.parseTime(\"04:00:00-03:00\"), is(14400000000L));\n-        assertThat(TimeType.parseTime(\"04:00:00+0300\"), is(14400000000L));\n-        assertThat(TimeType.parseTime(\"04:00:00+03:00\"), is(14400000000L));\n-        assertThat(TimeType.parseTime(\"04:00:00.123456789+03:00\"), is(14400123456L));\n-        assertThat(TimeType.parseTime(\"04:00:00+0000\"), is(14400000000L));\n-        assertThat(TimeType.parseTime(\"04:00:00.123456789-0000\"), is(14400123456L));\n-    }\n-\n-    @Test\n-    public void test_parse_time_no_time_zone_explicitly_mentioned() {\n-        assertThat(TimeType.parseTime(\"04:00:00\"), is(14400000000L));\n-        assertThat(TimeType.parseTime(\"14400000\"), is(14400000L));\n-        assertThat(TimeType.parseTime(\"04:00:00.123456789\"), is(14400123456L));\n-        assertThat(TimeType.parseTime(\"14400123\"), is(14400123L));\n-    }\n-\n-    @Test\n-    public void test_format_time() {\n-        assertThat(TimeType.formatTime(14400000000L), is(\"04:00:00\"));\n-        assertThat(TimeType.formatTime(14400123000L), is(\"04:00:00.123\"));\n-    }\n-\n-    @Test\n-    public void test_value() {\n-\n-        Function<Object, Long> fun = TimeType.INSTANCE::value;\n-\n-        assertNull(fun.apply(null));\n-        assertThat(fun.apply(\"01:00:00.000\"), is(3600000000L));\n-        assertThat(fun.apply(\"00:01:00.000\"), is(60000000L));\n-        assertThat(fun.apply(\"00:00:01.000\"), is(1000000L));\n-        assertThat(fun.apply(\"00:00:00.000\"), is(0L));\n-        assertThat(fun.apply(\"23:59:59.999998\"), is(24 * 60 * 60 * 1000_000L - 2L));\n-\n-        assertThat(fun.apply(\"010000.000\"), is(3600000000L));\n-        assertThat(fun.apply(\"000100.000\"), is(60000000L));\n-        assertThat(fun.apply(\"000001.000\"), is(1000000L));\n-        assertThat(fun.apply(\"000000.000\"), is(0L));\n-        assertThat(fun.apply(\"235959.999998\"), is(24 * 60 * 60 * 1000_000L - 2L));\n-\n-        assertThat(fun.apply(\"235959.998\"), is(24 * 60 * 60 * 1000_000L - 2000L));\n-        assertThat(fun.apply(\"240000.000\"), is(24 * 60 * 60 * 1000_000L));\n-\n-        assertThat(fun.apply(\"010000\"), is(3600000000L)); // same as 01:00:00.000\n-        assertThat(fun.apply(\"000100\"), is(60000000L));\n-        assertThat(fun.apply(\"000001\"), is(1000000L));\n-        assertThat(fun.apply(\"000000\"), is(0L));\n-        assertThat(fun.apply(\"235959\"), is(24 * 60 * 60 * 1000_000L - 1000_000L));\n-\n-        assertThat(fun.apply(\"010000000\"), is(10000000L));\n-        assertThat(fun.apply(\"000100000\"), is(100000L));\n-        assertThat(fun.apply(\"000001000\"), is(1000L));\n-        assertThat(fun.apply(\"000000000\"), is(0L));\n-        assertThat(fun.apply(String.valueOf(24 * 60 * 60 * 1000L - 1L)), is(24 * 60 * 60 * 1000 - 1L));\n-\n-        assertThat(fun.apply(100000.987), is(36000987000L));\n-        assertThat(fun.apply(100100.987), is(36060987000L));\n-        assertThat(fun.apply(100003.14159), is(36003141590L));\n-        assertThat(fun.apply(100000.321), is(36000321000L));\n-\n-        // floats drop precision, but you can still use them\n-        assertThat(fun.apply(100000.987F), is(36000984000L));\n-        assertThat(fun.apply(100100.987F), is(36060984000L));\n-        assertThat(fun.apply(100003.14159F), is(36003140000L));\n-        assertThat(fun.apply(100000.321F), is(36000320000L));\n-\n-        assertThat(fun.apply(10000), is(10000L));\n-        assertThat(fun.apply(100), is(100L));\n-        assertThat(fun.apply(1), is(1L));\n-        assertThat(fun.apply(0), is(0L));\n-        assertThat(fun.apply(25959), is(25959L));\n-        assertThat(fun.apply((short) 144), is(144L));\n-\n-        assertThat(fun.apply(\"01:00:00Z\"), is(3600000000L));\n-        assertThat(fun.apply(\"01:00:00+00\"), is(3600000000L));\n-        assertThat(fun.apply(\"04:00:00-03:00\"), is(14400000000L));\n-        assertThat(fun.apply(\"04:00:00+0300\"), is(14400000000L));\n-        assertThat(fun.apply(\"04:00:00+03:00\"), is(14400000000L));\n-        assertThat(fun.apply(\"04:00:00.123456789+03:00\"), is(14400123456L));\n-        assertThat(fun.apply(\"04:00:00+0000\"), is(14400000000L));\n-        assertThat(fun.apply(\"04:00:00.123456789-0000\"), is(14400123456L));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMjEwMg==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430912102", "bodyText": "is there a mapping with the time without time zonename?", "author": "kovrus", "createdAt": "2020-05-27T07:30:11Z", "path": "server/src/main/java/io/crate/types/DataTypes.java", "diffHunk": "@@ -360,7 +369,8 @@ private static boolean safeConversionPossible(DataType type1, DataType type2) {\n     }\n \n     private static final Map<String, DataType> MAPPING_NAMES_TO_TYPES = Map.ofEntries(\n-        entry(\"date\", DataTypes.TIMESTAMPZ),\n+        entry(\"time\", DataTypes.TIME),\n+        entry(DataTypes.TIME.getName(), DataTypes.TIME),", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "918d137534f32ff19b17e360e2d27467ac187cbe", "chunk": "diff --git a/server/src/main/java/io/crate/types/DataTypes.java b/server/src/main/java/io/crate/types/DataTypes.java\nindex c97c010f3d..e989314e65 100644\n--- a/server/src/main/java/io/crate/types/DataTypes.java\n+++ b/server/src/main/java/io/crate/types/DataTypes.java\n\n@@ -369,8 +365,8 @@ public final class DataTypes {\n     }\n \n     private static final Map<String, DataType> MAPPING_NAMES_TO_TYPES = Map.ofEntries(\n-        entry(\"time\", DataTypes.TIME),\n-        entry(DataTypes.TIME.getName(), DataTypes.TIME),\n+        entry(DataTypes.TIMEZ.getName(), DataTypes.TIMEZ),\n+        entry(\"date\", DataTypes.TIMESTAMPZ),\n         entry(\"string\", DataTypes.STRING),\n         entry(\"keyword\", DataTypes.STRING),\n         entry(\"text\", DataTypes.STRING),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMzI2MQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r430913261", "bodyText": "why date is removed?", "author": "kovrus", "createdAt": "2020-05-27T07:32:34Z", "path": "server/src/main/java/io/crate/types/DataTypes.java", "diffHunk": "@@ -360,7 +369,8 @@ private static boolean safeConversionPossible(DataType type1, DataType type2) {\n     }\n \n     private static final Map<String, DataType> MAPPING_NAMES_TO_TYPES = Map.ofEntries(\n-        entry(\"date\", DataTypes.TIMESTAMPZ),", "originalCommit": "f4c87e68a1a2ab5892ca3f18da647d52ee1e45f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "918d137534f32ff19b17e360e2d27467ac187cbe", "chunk": "diff --git a/server/src/main/java/io/crate/types/DataTypes.java b/server/src/main/java/io/crate/types/DataTypes.java\nindex c97c010f3d..e989314e65 100644\n--- a/server/src/main/java/io/crate/types/DataTypes.java\n+++ b/server/src/main/java/io/crate/types/DataTypes.java\n\n@@ -369,8 +365,8 @@ public final class DataTypes {\n     }\n \n     private static final Map<String, DataType> MAPPING_NAMES_TO_TYPES = Map.ofEntries(\n-        entry(\"time\", DataTypes.TIME),\n-        entry(DataTypes.TIME.getName(), DataTypes.TIME),\n+        entry(DataTypes.TIMEZ.getName(), DataTypes.TIMEZ),\n+        entry(\"date\", DataTypes.TIMESTAMPZ),\n         entry(\"string\", DataTypes.STRING),\n         entry(\"keyword\", DataTypes.STRING),\n         entry(\"text\", DataTypes.STRING),\n"}}, {"oid": "918d137534f32ff19b17e360e2d27467ac187cbe", "url": "https://github.com/crate/crate/commit/918d137534f32ff19b17e360e2d27467ac187cbe", "message": "Fix style", "committedDate": "2020-05-28T19:06:57Z", "type": "forcePushed"}, {"oid": "8700fd3699eff185f7416a200f8f7b5fe1f163e8", "url": "https://github.com/crate/crate/commit/8700fd3699eff185f7416a200f8f7b5fe1f163e8", "message": "Make TimeTZType a 12 byte structure, long for micros from midnight, int for secs from UTC (WIP)", "committedDate": "2020-06-01T07:29:12Z", "type": "forcePushed"}, {"oid": "830673911fdaeae8e8686f9ea589c504f964b46e", "url": "https://github.com/crate/crate/commit/830673911fdaeae8e8686f9ea589c504f964b46e", "message": "Fixup", "committedDate": "2020-06-02T16:37:48Z", "type": "forcePushed"}, {"oid": "e6da852a73a8a9d14255471e2b013dcdee638410", "url": "https://github.com/crate/crate/commit/e6da852a73a8a9d14255471e2b013dcdee638410", "message": "Cosmetics", "committedDate": "2020-06-03T08:35:47Z", "type": "forcePushed"}, {"oid": "684e366e25824529b81d578a35e94b841e08e1e3", "url": "https://github.com/crate/crate/commit/684e366e25824529b81d578a35e94b841e08e1e3", "message": "Fix indentation", "committedDate": "2020-06-03T09:23:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMTcwMA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r434431700", "bodyText": "does this time with time zone mapping exist?", "author": "kovrus", "createdAt": "2020-06-03T09:26:02Z", "path": "server/src/main/java/io/crate/types/DataTypes.java", "diffHunk": "@@ -360,6 +366,8 @@ private static boolean safeConversionPossible(DataType type1, DataType type2) {\n     }\n \n     private static final Map<String, DataType> MAPPING_NAMES_TO_TYPES = Map.ofEntries(\n+        entry(DataTypes.TIMETZ.getName(), DataTypes.TIMETZ),", "originalCommit": "684e366e25824529b81d578a35e94b841e08e1e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyOTQ0NA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r434529444", "bodyText": "Nope, with the question I realised, thank you:\nhttps://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html", "author": "marregui", "createdAt": "2020-06-03T12:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMTcwMA=="}], "type": "inlineReview", "revised_code": {"commit": "b6abf87a63a616deeaccfd37c8ed3252a7427923", "chunk": "diff --git a/server/src/main/java/io/crate/types/DataTypes.java b/server/src/main/java/io/crate/types/DataTypes.java\nindex 77f7d87f48..168d7872a2 100644\n--- a/server/src/main/java/io/crate/types/DataTypes.java\n+++ b/server/src/main/java/io/crate/types/DataTypes.java\n\n@@ -366,8 +377,6 @@ public final class DataTypes {\n     }\n \n     private static final Map<String, DataType> MAPPING_NAMES_TO_TYPES = Map.ofEntries(\n-        entry(DataTypes.TIMETZ.getName(), DataTypes.TIMETZ),\n-        entry(\"timetz\", DataTypes.TIMETZ),\n         entry(\"date\", DataTypes.TIMESTAMPZ),\n         entry(\"string\", DataTypes.STRING),\n         entry(\"keyword\", DataTypes.STRING),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNzUzNA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r434437534", "bodyText": "Maybe TimeTZParser.formatTime, because of class TimeTZType extends DataType<TimeTZ>?", "author": "kovrus", "createdAt": "2020-06-03T09:35:38Z", "path": "server/src/main/java/io/crate/types/TimeTZ.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.Objects;\n+\n+\n+public final class TimeTZ implements Comparable<TimeTZ> {\n+\n+    private final long microsFromMidnight;\n+    private final int secondsFromUTC;\n+\n+    public TimeTZ(long microsFromMidnight, int secondsFromUTC) {\n+        this.microsFromMidnight = microsFromMidnight;\n+        this.secondsFromUTC = secondsFromUTC;\n+    }\n+\n+    public long getMicrosFromMidnight() {\n+        return microsFromMidnight;\n+    }\n+\n+    public int getSecondsFromUTC() {\n+        return secondsFromUTC;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || false == o instanceof TimeTZ) {\n+            return false;\n+        }\n+        TimeTZ that = (TimeTZ) o;\n+        return microsFromMidnight == that.microsFromMidnight && secondsFromUTC == that.secondsFromUTC;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(microsFromMidnight, secondsFromUTC);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return TimeTZType.formatTime(this);", "originalCommit": "684e366e25824529b81d578a35e94b841e08e1e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMDg1Nw==", "url": "https://github.com/crate/crate/pull/9915#discussion_r434530857", "bodyText": "keen eye!", "author": "marregui", "createdAt": "2020-06-03T12:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNzUzNA=="}], "type": "inlineReview", "revised_code": {"commit": "8847d6d6c27e55f135fb9368a84c4085fb079019", "chunk": "diff --git a/server/src/main/java/io/crate/types/TimeTZ.java b/server/src/main/java/io/crate/types/TimeTZ.java\nindex b747f309f8..7f30dcc9f1 100644\n--- a/server/src/main/java/io/crate/types/TimeTZ.java\n+++ b/server/src/main/java/io/crate/types/TimeTZ.java\n\n@@ -61,7 +61,7 @@ public final class TimeTZ implements Comparable<TimeTZ> {\n \n     @Override\n     public String toString() {\n-        return TimeTZType.formatTime(this);\n+        return TimeTZParser.formatTime(this);\n     }\n \n     @Override\n"}}, {"oid": "b6abf87a63a616deeaccfd37c8ed3252a7427923", "url": "https://github.com/crate/crate/commit/b6abf87a63a616deeaccfd37c8ed3252a7427923", "message": "Remove non existing mapping", "committedDate": "2020-06-03T12:28:49Z", "type": "forcePushed"}, {"oid": "8847d6d6c27e55f135fb9368a84c4085fb079019", "url": "https://github.com/crate/crate/commit/8847d6d6c27e55f135fb9368a84c4085fb079019", "message": "Fix oid name", "committedDate": "2020-06-03T13:46:17Z", "type": "forcePushed"}, {"oid": "57a24eb2d64e801b5e2092f4a5af5e54ecc82143", "url": "https://github.com/crate/crate/commit/57a24eb2d64e801b5e2092f4a5af5e54ecc82143", "message": "Fix message, holly molly", "committedDate": "2020-06-03T15:05:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2NDUyMQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r434664521", "bodyText": "Not sure if there is much value in re-exporting these functions here. Either TimeTZ could have a formatTime directly, or TimeTZParser.formatTime could be used directly.", "author": "mfussenegger", "createdAt": "2020-06-03T15:41:04Z", "path": "server/src/main/java/io/crate/types/TimeTZType.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+\n+import static io.crate.types.TimeTZParser.timeTZOf;\n+import static io.crate.types.TimeTZParser.exceptionForInvalidLiteral;\n+\n+public final class TimeTZType extends DataType<TimeTZ> implements FixedWidthType, Streamer<TimeTZ> {\n+\n+    public static final int ID = 19;\n+    public static final int TYPE_LEN = 12;\n+    public static final String NAME = \"timetz\";\n+    public static final TimeTZType INSTANCE = new TimeTZType();\n+\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NAME;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.TIMETZ;\n+    }\n+\n+    @Override\n+    public Streamer<TimeTZ> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public int compare(TimeTZ val1, TimeTZ val2) {\n+        return val1.compareTo(val2);\n+    }\n+\n+    @Override\n+    public TimeTZ readValueFrom(StreamInput in) throws IOException {\n+        if (in.readBoolean()) {\n+            return null;\n+        }\n+        return new TimeTZ(in.readLong(), in.readInt());\n+    }\n+\n+    @Override\n+    public void writeValueTo(StreamOutput out, TimeTZ tz) throws IOException {\n+        out.writeBoolean(tz == null);\n+        if (tz != null) {\n+            out.writeLong(tz.getMicrosFromMidnight());\n+            out.writeInt(tz.getSecondsFromUTC());\n+        }\n+    }\n+\n+    @Override\n+    public int fixedSize() {\n+        return TYPE_LEN;\n+    }\n+\n+    @Override\n+    public TimeTZ value(Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+        if (value instanceof TimeTZ) {\n+            return (TimeTZ) value;\n+        }\n+        if (value instanceof String) {\n+            try {\n+                return parseTime((String) value);\n+            } catch (IllegalArgumentException e0) {\n+                try {\n+                    return timeTZOf(\n+                        TimeTZType.class.getSimpleName(),\n+                        Long.valueOf((String) value));\n+                } catch (NumberFormatException e1) {\n+                    throw exceptionForInvalidLiteral(value);\n+                }\n+            }\n+        }\n+        throw exceptionForInvalidLiteral(value);\n+    }\n+\n+    public static String formatTime(@Nonnull TimeTZ time) {", "originalCommit": "57a24eb2d64e801b5e2092f4a5af5e54ecc82143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2ce6b01172c13642e76c620b62c792d6e828707", "chunk": "diff --git a/server/src/main/java/io/crate/types/TimeTZType.java b/server/src/main/java/io/crate/types/TimeTZType.java\nindex 8f3c7958ba..0f00f92259 100644\n--- a/server/src/main/java/io/crate/types/TimeTZType.java\n+++ b/server/src/main/java/io/crate/types/TimeTZType.java\n\n@@ -25,7 +25,6 @@ import io.crate.Streamer;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n \n-import javax.annotation.Nonnull;\n import java.io.IOException;\n \n import static io.crate.types.TimeTZParser.timeTZOf;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2NTExNg==", "url": "https://github.com/crate/crate/pull/9915#discussion_r434665116", "bodyText": "Same here. Consumers could use TimeTZParser.parse directly, or maybe there could be a TimeTZ.parse and the TimeTZParser could become package private.", "author": "mfussenegger", "createdAt": "2020-06-03T15:41:52Z", "path": "server/src/main/java/io/crate/types/TimeTZType.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+\n+import static io.crate.types.TimeTZParser.timeTZOf;\n+import static io.crate.types.TimeTZParser.exceptionForInvalidLiteral;\n+\n+public final class TimeTZType extends DataType<TimeTZ> implements FixedWidthType, Streamer<TimeTZ> {\n+\n+    public static final int ID = 19;\n+    public static final int TYPE_LEN = 12;\n+    public static final String NAME = \"timetz\";\n+    public static final TimeTZType INSTANCE = new TimeTZType();\n+\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NAME;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.TIMETZ;\n+    }\n+\n+    @Override\n+    public Streamer<TimeTZ> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public int compare(TimeTZ val1, TimeTZ val2) {\n+        return val1.compareTo(val2);\n+    }\n+\n+    @Override\n+    public TimeTZ readValueFrom(StreamInput in) throws IOException {\n+        if (in.readBoolean()) {\n+            return null;\n+        }\n+        return new TimeTZ(in.readLong(), in.readInt());\n+    }\n+\n+    @Override\n+    public void writeValueTo(StreamOutput out, TimeTZ tz) throws IOException {\n+        out.writeBoolean(tz == null);\n+        if (tz != null) {\n+            out.writeLong(tz.getMicrosFromMidnight());\n+            out.writeInt(tz.getSecondsFromUTC());\n+        }\n+    }\n+\n+    @Override\n+    public int fixedSize() {\n+        return TYPE_LEN;\n+    }\n+\n+    @Override\n+    public TimeTZ value(Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+        if (value instanceof TimeTZ) {\n+            return (TimeTZ) value;\n+        }\n+        if (value instanceof String) {\n+            try {\n+                return parseTime((String) value);\n+            } catch (IllegalArgumentException e0) {\n+                try {\n+                    return timeTZOf(\n+                        TimeTZType.class.getSimpleName(),\n+                        Long.valueOf((String) value));\n+                } catch (NumberFormatException e1) {\n+                    throw exceptionForInvalidLiteral(value);\n+                }\n+            }\n+        }\n+        throw exceptionForInvalidLiteral(value);\n+    }\n+\n+    public static String formatTime(@Nonnull TimeTZ time) {\n+        return TimeTZParser.formatTime(time);\n+    }\n+\n+    public static TimeTZ parseTime(@Nonnull String time) {\n+        return TimeTZParser.parse(time);\n+    }", "originalCommit": "57a24eb2d64e801b5e2092f4a5af5e54ecc82143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2ce6b01172c13642e76c620b62c792d6e828707", "chunk": "diff --git a/server/src/main/java/io/crate/types/TimeTZType.java b/server/src/main/java/io/crate/types/TimeTZType.java\nindex 8f3c7958ba..0f00f92259 100644\n--- a/server/src/main/java/io/crate/types/TimeTZType.java\n+++ b/server/src/main/java/io/crate/types/TimeTZType.java\n\n@@ -25,7 +25,6 @@ import io.crate.Streamer;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n \n-import javax.annotation.Nonnull;\n import java.io.IOException;\n \n import static io.crate.types.TimeTZParser.timeTZOf;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2NTg1OA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r434665858", "bodyText": "I still don't really undestand why this change became necessary within this PR? That interval cannot be stored isn't new. Did randomType change in some unrelated way?", "author": "mfussenegger", "createdAt": "2020-06-03T15:42:54Z", "path": "server/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java", "diffHunk": "@@ -313,7 +314,10 @@ public void testWhereNotEqualAnyWithLargeArray() throws Exception {\n \n     @Test\n     public void testNullOperators() throws Exception {\n-        DataType<?> type = randomType();\n+        DataType<?> type;\n+        do {\n+           type = randomType();\n+        } while (type == DataTypes.INTERVAL);", "originalCommit": "57a24eb2d64e801b5e2092f4a5af5e54ecc82143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2ce6b01172c13642e76c620b62c792d6e828707", "chunk": "diff --git a/server/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java b/server/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java\nindex 1444ff532e..3a11968ad5 100644\n--- a/server/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java\n+++ b/server/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java\n\n@@ -314,10 +314,7 @@ public class LuceneQueryBuilderIntegrationTest extends SQLTransportIntegrationTe\n \n     @Test\n     public void testNullOperators() throws Exception {\n-        DataType<?> type;\n-        do {\n-           type = randomType();\n-        } while (type == DataTypes.INTERVAL);\n+        DataType<?> type = randomType();\n         execute(\"create table t1 (c \" + type.getName() + \") with (number_of_replicas = 0)\");\n         Supplier dataGenerator = DataTypeTesting.getDataGenerator(type);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2NzU3Mw==", "url": "https://github.com/crate/crate/pull/9915#discussion_r434667573", "bodyText": "These additions here shouldn't be necessary anymore, since TIMETZ is no longer part of the allowed conversions for BYTE.", "author": "mfussenegger", "createdAt": "2020-06-03T15:45:18Z", "path": "server/src/test/java/io/crate/types/TypeConversionTest.java", "diffHunk": "@@ -97,6 +98,8 @@ public void numberConversionTest() throws Exception {\n                 var t = DataTypes.fromId(id);\n                 if (t.equals(DataTypes.IP)) {\n                     byteVal = (byte) Math.abs(byteVal == Byte.MIN_VALUE ? byteVal >> 1 : byteVal);\n+                } else if (t.equals(DataTypes.TIMETZ)) {", "originalCommit": "57a24eb2d64e801b5e2092f4a5af5e54ecc82143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2ce6b01172c13642e76c620b62c792d6e828707", "chunk": "diff --git a/server/src/test/java/io/crate/types/TypeConversionTest.java b/server/src/test/java/io/crate/types/TypeConversionTest.java\nindex 5c6abb8f83..547fed678c 100644\n--- a/server/src/test/java/io/crate/types/TypeConversionTest.java\n+++ b/server/src/test/java/io/crate/types/TypeConversionTest.java\n\n@@ -98,8 +98,6 @@ public class TypeConversionTest extends CrateUnitTest {\n                 var t = DataTypes.fromId(id);\n                 if (t.equals(DataTypes.IP)) {\n                     byteVal = (byte) Math.abs(byteVal == Byte.MIN_VALUE ? byteVal >> 1 : byteVal);\n-                } else if (t.equals(DataTypes.TIMETZ)) {\n-                    byteVal = (byte) ThreadLocalRandom.current().nextInt(25);\n                 }\n                 t.value(byteVal);\n             }\n"}}, {"oid": "b2ce6b01172c13642e76c620b62c792d6e828707", "url": "https://github.com/crate/crate/commit/b2ce6b01172c13642e76c620b62c792d6e828707", "message": "Fix tests", "committedDate": "2020-06-03T19:14:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4MDg2Mw==", "url": "https://github.com/crate/crate/pull/9915#discussion_r434880863", "bodyText": "TIMETZ name does not contain spaces.", "author": "kovrus", "createdAt": "2020-06-03T21:57:39Z", "path": "server/src/main/java/io/crate/types/DataTypes.java", "diffHunk": "@@ -90,6 +92,7 @@\n     public static Set<String> PRIMITIVE_TYPE_NAMES_WITH_SPACES = Set.of(\n         TIMESTAMPZ.getName(),\n         TIMESTAMP.getName(),\n+        TIMETZ.getName(),", "originalCommit": "b2ce6b01172c13642e76c620b62c792d6e828707", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b73bf96560090896774dd93ab9dddb20da1a3b7b", "chunk": "diff --git a/server/src/main/java/io/crate/types/DataTypes.java b/server/src/main/java/io/crate/types/DataTypes.java\nindex 25457865f4..77b83ccee4 100644\n--- a/server/src/main/java/io/crate/types/DataTypes.java\n+++ b/server/src/main/java/io/crate/types/DataTypes.java\n\n@@ -92,7 +92,6 @@ public final class DataTypes {\n     public static Set<String> PRIMITIVE_TYPE_NAMES_WITH_SPACES = Set.of(\n         TIMESTAMPZ.getName(),\n         TIMESTAMP.getName(),\n-        TIMETZ.getName(),\n         DOUBLE.getName()\n     );\n \n"}}, {"oid": "b73bf96560090896774dd93ab9dddb20da1a3b7b", "url": "https://github.com/crate/crate/commit/b73bf96560090896774dd93ab9dddb20da1a3b7b", "message": "Simplify parser/formatter", "committedDate": "2020-06-04T10:37:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NDI4NA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r435764284", "bodyText": "Shouldn't the type name be time with time zone, see https://www.postgresql.org/docs/9.1/datatype-datetime.html and timetz would be an alias?\n\ntimetz is a valid alias for time with time zone.\n\nYou have documented it as it supposedly has to be, but in implementation it is another way around.", "author": "kovrus", "createdAt": "2020-06-05T08:20:35Z", "path": "server/src/main/java/io/crate/types/DataTypes.java", "diffHunk": "@@ -346,6 +350,7 @@ private static boolean safeConversionPossible(DataType type1, DataType type2) {\n         entry(\"string\", STRING),\n         entry(\"varchar\", STRING),\n         entry(\"character varying\", STRING),\n+        entry(\"time with time zone\", TIMETZ),", "originalCommit": "2bd296f89274f987f54d87f0a4d6f7049ccb2e24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MjU2MA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r435782560", "bodyText": "ok, yes, I suppose I need to declare it as time with time zone, but make sure that it ends up as timetz in here.", "author": "marregui", "createdAt": "2020-06-05T08:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NDI4NA=="}], "type": "inlineReview", "revised_code": {"commit": "d65e18a7846053ee99a3e40191d0c6abac87d5cc", "chunk": "diff --git a/server/src/main/java/io/crate/types/DataTypes.java b/server/src/main/java/io/crate/types/DataTypes.java\nindex 77b83ccee4..f0494d9fd2 100644\n--- a/server/src/main/java/io/crate/types/DataTypes.java\n+++ b/server/src/main/java/io/crate/types/DataTypes.java\n\n@@ -350,7 +351,7 @@ public final class DataTypes {\n         entry(\"string\", STRING),\n         entry(\"varchar\", STRING),\n         entry(\"character varying\", STRING),\n-        entry(\"time with time zone\", TIMETZ),\n+        entry(\"timetz\", TIMETZ),\n         entry(\"timestamptz\", TIMESTAMPZ),\n         // The usage of the `timestamp` data type as a data type with time\n         // zone is deprecate, use `timestamp with time zone` or `timestamptz`\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTI3NQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r435771275", "bodyText": "You catch only NumberFormatException which could be thrown by Long.valueOf, but timeTZOf-> checkRange could throw IllegalArgumentException that is not handled.", "author": "kovrus", "createdAt": "2020-06-05T08:33:11Z", "path": "server/src/main/java/io/crate/types/TimeTZType.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+\n+import static io.crate.types.TimeTZParser.timeTZOf;\n+import static io.crate.types.TimeTZParser.exceptionForInvalidLiteral;\n+\n+public final class TimeTZType extends DataType<TimeTZ> implements FixedWidthType, Streamer<TimeTZ> {\n+\n+    public static final int ID = 19;\n+    public static final int TYPE_LEN = 12;\n+    public static final String NAME = \"timetz\";\n+    public static final TimeTZType INSTANCE = new TimeTZType();\n+\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NAME;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.TIMETZ;\n+    }\n+\n+    @Override\n+    public Streamer<TimeTZ> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public int compare(TimeTZ val1, TimeTZ val2) {\n+        return val1.compareTo(val2);\n+    }\n+\n+    @Override\n+    public TimeTZ readValueFrom(StreamInput in) throws IOException {\n+        if (in.readBoolean()) {\n+            return null;\n+        }\n+        return new TimeTZ(in.readLong(), in.readInt());\n+    }\n+\n+    @Override\n+    public void writeValueTo(StreamOutput out, TimeTZ tz) throws IOException {\n+        out.writeBoolean(tz == null);\n+        if (tz != null) {\n+            out.writeLong(tz.getMicrosFromMidnight());\n+            out.writeInt(tz.getSecondsFromUTC());\n+        }\n+    }\n+\n+    @Override\n+    public int fixedSize() {\n+        return TYPE_LEN;\n+    }\n+\n+    @Override\n+    public TimeTZ value(Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+        if (value instanceof TimeTZ) {\n+            return (TimeTZ) value;\n+        }\n+        if (value instanceof String) {\n+            try {\n+                return TimeTZParser.parse((String) value);\n+            } catch (IllegalArgumentException e0) {\n+                try {\n+                    return timeTZOf(\n+                        TimeTZType.class.getSimpleName(),\n+                        Long.valueOf((String) value));\n+                } catch (NumberFormatException e1) {", "originalCommit": "2bd296f89274f987f54d87f0a4d6f7049ccb2e24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NTc4NA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r435785784", "bodyText": "IllegalArgumentException is what I throw to issue a problem with the format, including range fail:\n static IllegalArgumentException exceptionForInvalidLiteral(Object literal) {\n        throw new IllegalArgumentException(String.format(\n            Locale.ENGLISH,\n            \"value [%s] is not a valid literal for %s\",\n            literal, TimeTZType.class.getSimpleName()));\n    }", "author": "marregui", "createdAt": "2020-06-05T08:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTI3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d65e18a7846053ee99a3e40191d0c6abac87d5cc", "chunk": "diff --git a/server/src/main/java/io/crate/types/TimeTZType.java b/server/src/main/java/io/crate/types/TimeTZType.java\nindex 0f00f92259..442418a537 100644\n--- a/server/src/main/java/io/crate/types/TimeTZType.java\n+++ b/server/src/main/java/io/crate/types/TimeTZType.java\n\n@@ -34,7 +34,7 @@ public final class TimeTZType extends DataType<TimeTZ> implements FixedWidthType\n \n     public static final int ID = 19;\n     public static final int TYPE_LEN = 12;\n-    public static final String NAME = \"timetz\";\n+    public static final String NAME = \"time with time zone\";\n     public static final TimeTZType INSTANCE = new TimeTZType();\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTQ4Nw==", "url": "https://github.com/crate/crate/pull/9915#discussion_r435771487", "bodyText": "I'm not sure if this is the best representation for HTTP.\n@seut Do you have any inputs here how we should represent time with time zone to users via HTTP?", "author": "mfussenegger", "createdAt": "2020-06-05T08:33:31Z", "path": "server/src/main/java/io/crate/types/DataTypeXContentExtension.java", "diffHunk": "@@ -63,6 +63,13 @@\n                     b.value(row.get(i));\n                 }\n                 b.endArray();\n+            }),\n+            Map.entry(TimeTZ.class, (b, v) -> {\n+                TimeTZ timetz = (TimeTZ) v;\n+                b.startArray();\n+                b.value(timetz.getMicrosFromMidnight());\n+                b.value(timetz.getSecondsFromUTC());\n+                b.endArray();", "originalCommit": "2b3bebd0f04dee6dd40e008fc3208cd953d6cd63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3NzA0OA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r435777048", "bodyText": "I was not sure either, but as it makes the micros offset, as well as the seconds offset, explicit, I went with it. Please let me know your thoughts.", "author": "marregui", "createdAt": "2020-06-05T08:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NjA0MQ==", "url": "https://github.com/crate/crate/pull/9915#discussion_r435876041", "bodyText": "I guess it makes sense to keep it in a format that is easy to parse for clients - we do the same for timestamp (long instead of text format)\nWe also have to extend the documentation here:\n\n  \n    \n      crate/docs/interfaces/http.rst\n    \n    \n        Lines 233 to 237\n      in\n      e09e00d\n    \n    \n    \n    \n\n        \n          \n           IDs of all currently available data types: \n        \n\n        \n          \n            \n        \n\n        \n          \n           ===== =================== \n        \n\n        \n          \n           ID    Data Type \n        \n\n        \n          \n           ===== =================== \n        \n    \n  \n\n\nand we should probably also follow up:\n\nAdd the time to the python client (mapping it to datetime.time)\ninterpreting it in the Admin UI. (To have a human readable display as well)\n\ncc @autophagy", "author": "mfussenegger", "createdAt": "2020-06-05T12:04:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTQ4Nw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "1fd3f603f226529804c48352df5a217b3c37621e", "url": "https://github.com/crate/crate/commit/1fd3f603f226529804c48352df5a217b3c37621e", "message": "Mention that timetz cannot be used in create/alter statements", "committedDate": "2020-06-05T08:46:50Z", "type": "forcePushed"}, {"oid": "d65e18a7846053ee99a3e40191d0c6abac87d5cc", "url": "https://github.com/crate/crate/commit/d65e18a7846053ee99a3e40191d0c6abac87d5cc", "message": "Make the type name be `time with time zone` and `timetz` an alias", "committedDate": "2020-06-07T18:05:16Z", "type": "forcePushed"}, {"oid": "f2d8d7ee21d4bc05efe635cf1e26c70cc8b59b83", "url": "https://github.com/crate/crate/commit/f2d8d7ee21d4bc05efe635cf1e26c70cc8b59b83", "message": "Improve javadoc", "committedDate": "2020-06-08T14:29:50Z", "type": "forcePushed"}, {"oid": "e741d79ca700d214fe4e34812bddd47a604ffa9f", "url": "https://github.com/crate/crate/commit/e741d79ca700d214fe4e34812bddd47a604ffa9f", "message": "Reformat table to 'list-table' and describe timetz lazily", "committedDate": "2020-06-09T19:38:27Z", "type": "forcePushed"}, {"oid": "048aabf85ea6a6c24a509cfc55527f293a526b62", "url": "https://github.com/crate/crate/commit/048aabf85ea6a6c24a509cfc55527f293a526b62", "message": "Change timetz type's id to 20", "committedDate": "2020-06-10T18:29:11Z", "type": "forcePushed"}, {"oid": "8f7c141b9d1870e238715397f3e155d4355c0ea9", "url": "https://github.com/crate/crate/commit/8f7c141b9d1870e238715397f3e155d4355c0ea9", "message": "Change timetz type's id to 20", "committedDate": "2020-06-11T08:36:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0MDAxMA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r438640010", "bodyText": "Maybe this part can be moved into the method that is responsible for the cast now https://github.com/crate/crate/blob/master/server/src/main/java/io/crate/types/DataType.java#L93 It is the correct place for the cast routine and would simplify future refactoring/removing/renaming of the DataType#value.\nand the DataType#value can be probably just or smth like that\npublic TimeTZ value(Object value) {\n        if (value == null) {\n            return null;\n        }\n        return (TimeTZ) value;\n}", "author": "kovrus", "createdAt": "2020-06-11T08:54:28Z", "path": "server/src/main/java/io/crate/types/TimeTZType.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+\n+import static io.crate.types.TimeTZParser.timeTZOf;\n+import static io.crate.types.TimeTZParser.exceptionForInvalidLiteral;\n+\n+public final class TimeTZType extends DataType<TimeTZ> implements FixedWidthType, Streamer<TimeTZ> {\n+\n+    public static final int ID = 20;\n+    public static final int TYPE_LEN = 12;\n+    public static final String NAME = \"time with time zone\";\n+    public static final TimeTZType INSTANCE = new TimeTZType();\n+\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NAME;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.TIMETZ;\n+    }\n+\n+    @Override\n+    public Streamer<TimeTZ> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public int compare(TimeTZ val1, TimeTZ val2) {\n+        return val1.compareTo(val2);\n+    }\n+\n+    @Override\n+    public TimeTZ readValueFrom(StreamInput in) throws IOException {\n+        if (in.readBoolean()) {\n+            return null;\n+        }\n+        return new TimeTZ(in.readLong(), in.readInt());\n+    }\n+\n+    @Override\n+    public void writeValueTo(StreamOutput out, TimeTZ tz) throws IOException {\n+        out.writeBoolean(tz == null);\n+        if (tz != null) {\n+            out.writeLong(tz.getMicrosFromMidnight());\n+            out.writeInt(tz.getSecondsFromUTC());\n+        }\n+    }\n+\n+    @Override\n+    public int fixedSize() {\n+        return TYPE_LEN;\n+    }\n+\n+    @Override\n+    public TimeTZ value(Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+        if (value instanceof TimeTZ) {\n+            return (TimeTZ) value;\n+        }\n+        if (value instanceof String) {", "originalCommit": "8f7c141b9d1870e238715397f3e155d4355c0ea9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "946b493745c0071ddf47ee07eeccce414a81cff1", "chunk": "diff --git a/server/src/main/java/io/crate/types/TimeTZType.java b/server/src/main/java/io/crate/types/TimeTZType.java\nindex ad0c282805..816eb844db 100644\n--- a/server/src/main/java/io/crate/types/TimeTZType.java\n+++ b/server/src/main/java/io/crate/types/TimeTZType.java\n\n@@ -86,13 +86,7 @@ public final class TimeTZType extends DataType<TimeTZ> implements FixedWidthType\n     }\n \n     @Override\n-    public TimeTZ value(Object value) {\n-        if (value == null) {\n-            return null;\n-        }\n-        if (value instanceof TimeTZ) {\n-            return (TimeTZ) value;\n-        }\n+    public TimeTZ implicitCast(Object value) {\n         if (value instanceof String) {\n             try {\n                 return TimeTZParser.parse((String) value);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0MDU3Mw==", "url": "https://github.com/crate/crate/pull/9915#discussion_r438640573", "bodyText": "is it needed?", "author": "kovrus", "createdAt": "2020-06-11T08:55:19Z", "path": "server/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java", "diffHunk": "@@ -24,6 +24,7 @@\n import com.carrotsearch.randomizedtesting.annotations.Seed;\n import io.crate.testing.DataTypeTesting;\n import io.crate.types.DataType;\n+import io.crate.types.DataTypes;", "originalCommit": "0b66904d3c51d996939b741ea44a9cab836f5a6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "946b493745c0071ddf47ee07eeccce414a81cff1", "chunk": "diff --git a/server/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java b/server/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java\nindex 3a11968ad5..793a5bb995 100644\n--- a/server/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java\n+++ b/server/src/test/java/io/crate/integrationtests/LuceneQueryBuilderIntegrationTest.java\n\n@@ -24,7 +24,6 @@ package io.crate.integrationtests;\n import com.carrotsearch.randomizedtesting.annotations.Seed;\n import io.crate.testing.DataTypeTesting;\n import io.crate.types.DataType;\n-import io.crate.types.DataTypes;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.search.SearchModule;\n import org.elasticsearch.test.ESIntegTestCase;\n"}}, {"oid": "946b493745c0071ddf47ee07eeccce414a81cff1", "url": "https://github.com/crate/crate/commit/946b493745c0071ddf47ee07eeccce414a81cff1", "message": "Make use of implicitCast", "committedDate": "2020-06-11T09:59:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4Mjg1MA==", "url": "https://github.com/crate/crate/pull/9915#discussion_r438782850", "bodyText": "DataType#value must not call DataType#implicitCast and perform the casting.\nYou would probably also have to adjust tests accordingly.\nI'll copy-paste jordi's comment from the slack discussion regarding refactoring DataType and splitting\nDataType#value for a better context.\nBasically what I'm proposing is to split up value into multiple use cases because\nright now it is a bit overloaded:\n- cast, with a comment that this is only to be used via the cast function\n CastFunction, supports explicit/try/implicit\n- valueForInsert - for the new implicit whitespace truncation case\n- santizeType - for the cases where we currently use dataType#value to fix\na type read from source or so where an integer might have been stored as long\n(This is mostly in the reference resolvers / column expression implementations)\n\nFor the timetz it seems that it'd be enough to implement the implicitCast, which is done already and keep the DataType#value as it was suggested in the previous comment.", "author": "kovrus", "createdAt": "2020-06-11T13:32:11Z", "path": "server/src/main/java/io/crate/types/TimeTZType.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+\n+import static io.crate.types.TimeTZParser.timeTZOf;\n+import static io.crate.types.TimeTZParser.exceptionForInvalidLiteral;\n+\n+public final class TimeTZType extends DataType<TimeTZ> implements FixedWidthType, Streamer<TimeTZ> {\n+\n+    public static final int ID = 20;\n+    public static final int TYPE_LEN = 12;\n+    public static final String NAME = \"time with time zone\";\n+    public static final TimeTZType INSTANCE = new TimeTZType();\n+\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NAME;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.TIMETZ;\n+    }\n+\n+    @Override\n+    public Streamer<TimeTZ> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public int compare(TimeTZ val1, TimeTZ val2) {\n+        return val1.compareTo(val2);\n+    }\n+\n+    @Override\n+    public TimeTZ readValueFrom(StreamInput in) throws IOException {\n+        if (in.readBoolean()) {\n+            return null;\n+        }\n+        return new TimeTZ(in.readLong(), in.readInt());\n+    }\n+\n+    @Override\n+    public void writeValueTo(StreamOutput out, TimeTZ tz) throws IOException {\n+        out.writeBoolean(tz == null);\n+        if (tz != null) {\n+            out.writeLong(tz.getMicrosFromMidnight());\n+            out.writeInt(tz.getSecondsFromUTC());\n+        }\n+    }\n+\n+    @Override\n+    public int fixedSize() {\n+        return TYPE_LEN;\n+    }\n+\n+    @Override\n+    public TimeTZ implicitCast(Object value) {\n+        if (value instanceof String) {\n+            try {\n+                return TimeTZParser.parse((String) value);\n+            } catch (IllegalArgumentException e0) {\n+                try {\n+                    return timeTZOf(\n+                        TimeTZType.class.getSimpleName(),\n+                        Long.valueOf((String) value));\n+                } catch (NumberFormatException e1) {\n+                    throw exceptionForInvalidLiteral(value);\n+                }\n+            }\n+        }\n+        throw exceptionForInvalidLiteral(value);\n+    }\n+\n+    @Override\n+    public TimeTZ value(Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+        return value instanceof TimeTZ ? (TimeTZ) value : implicitCast(value);", "originalCommit": "946b493745c0071ddf47ee07eeccce414a81cff1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "923e57475fb62e221621a623ceeb7510c8dd182e", "chunk": "diff --git a/server/src/main/java/io/crate/types/TimeTZType.java b/server/src/main/java/io/crate/types/TimeTZType.java\nindex 816eb844db..b97c25903e 100644\n--- a/server/src/main/java/io/crate/types/TimeTZType.java\n+++ b/server/src/main/java/io/crate/types/TimeTZType.java\n\n@@ -26,6 +26,7 @@ import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n \n import java.io.IOException;\n+import java.util.Locale;\n \n import static io.crate.types.TimeTZParser.timeTZOf;\n import static io.crate.types.TimeTZParser.exceptionForInvalidLiteral;\n"}}, {"oid": "923e57475fb62e221621a623ceeb7510c8dd182e", "url": "https://github.com/crate/crate/commit/923e57475fb62e221621a623ceeb7510c8dd182e", "message": "Correct documentation, note regarding use of type in create/alter", "committedDate": "2020-06-15T10:16:47Z", "type": "forcePushed"}, {"oid": "16174e93b7807b92025e09b4c1fec121fe121352", "url": "https://github.com/crate/crate/commit/16174e93b7807b92025e09b4c1fec121fe121352", "message": "Add type \"time with time zone\", alias timetz\n\nThis type is used as return value for time related functions, such as\n\"current_time\".\nLiterals can be constructed using a string literal and a cast. Syntax\nfor the string literal:\n\ntime-element [offset]\n\n    time-element: time-only [fraction]\n    time-only:    HH[[:][mm[:]ss]]\n    fraction:     '.' digit+\n    offset:       {+ | -} time-only | geo-region\n    geo-region:   As defined by ISO 8601.\n\nfraction accepts up to 6 digits, delivering microsecond precision.\nThe type cannot be used in CREATE/ALTER statements.", "committedDate": "2020-06-15T11:08:04Z", "type": "forcePushed"}, {"oid": "6b165196499a5657448094dedd485d53bc820673", "url": "https://github.com/crate/crate/commit/6b165196499a5657448094dedd485d53bc820673", "message": "Add type \"time with time zone\", alias timetz\n\nThis type is used as return value for time related functions, such as\n\"current_time\".\nLiterals can be constructed using a string literal and a cast. Syntax\nfor the string literal:\n\ntime-element [offset]\n\n    time-element: time-only [fraction]\n    time-only:    HH[[:][mm[:]ss]]\n    fraction:     '.' digit+\n    offset:       {+ | -} time-only | geo-region\n    geo-region:   As defined by ISO 8601.\n\nfraction accepts up to 6 digits, delivering microsecond precision.\nThe type cannot be used in CREATE/ALTER statements.", "committedDate": "2020-06-16T08:29:18Z", "type": "forcePushed"}, {"oid": "cbe8a7371a0fb45d0f2e350cbccc391bec898e32", "url": "https://github.com/crate/crate/commit/cbe8a7371a0fb45d0f2e350cbccc391bec898e32", "message": "Add type \"time with time zone\", alias timetz\n\nThis type is used as return value for time related functions, such as\n\"current_time\".\nLiterals can be constructed using a string literal and a cast. Syntax\nfor the string literal:\n\ntime-element [offset]\n\n    time-element: time-only [fraction]\n    time-only:    HH[[:][mm[:]ss]]\n    fraction:     '.' digit+\n    offset:       {+ | -} time-only | geo-region\n    geo-region:   As defined by ISO 8601.\n\nfraction accepts up to 6 digits, delivering microsecond precision.\nThe type cannot be used in CREATE/ALTER statements.", "committedDate": "2020-06-16T09:23:15Z", "type": "commit"}, {"oid": "cbe8a7371a0fb45d0f2e350cbccc391bec898e32", "url": "https://github.com/crate/crate/commit/cbe8a7371a0fb45d0f2e350cbccc391bec898e32", "message": "Add type \"time with time zone\", alias timetz\n\nThis type is used as return value for time related functions, such as\n\"current_time\".\nLiterals can be constructed using a string literal and a cast. Syntax\nfor the string literal:\n\ntime-element [offset]\n\n    time-element: time-only [fraction]\n    time-only:    HH[[:][mm[:]ss]]\n    fraction:     '.' digit+\n    offset:       {+ | -} time-only | geo-region\n    geo-region:   As defined by ISO 8601.\n\nfraction accepts up to 6 digits, delivering microsecond precision.\nThe type cannot be used in CREATE/ALTER statements.", "committedDate": "2020-06-16T09:23:15Z", "type": "forcePushed"}]}