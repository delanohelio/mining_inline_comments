{"pr_number": 10708, "pr_title": "Add support for PK lookup if additional filters are combined by AND", "pr_createdAt": "2020-10-27T09:37:14Z", "pr_url": "https://github.com/crate/crate/pull/10708", "timeline": [{"oid": "3b50f690cf5127756ea20201ff4aaffe38b15d9a", "url": "https://github.com/crate/crate/commit/3b50f690cf5127756ea20201ff4aaffe38b15d9a", "message": "Add support for PK lookup if additional filters are combined by AND\n\nIf filters are combined by AND operators in addition to filters\non primary key columns, the optimized PK lookup plan is used now.\n\nCloses #10298.", "committedDate": "2020-10-29T16:01:21Z", "type": "forcePushed"}, {"oid": "514fe793e8d32e6d23292bcb768f35f925509d75", "url": "https://github.com/crate/crate/commit/514fe793e8d32e6d23292bcb768f35f925509d75", "message": "Add support for PK lookup if additional filters are combined by AND\n\nIf filters are combined by AND operators in addition to filters\non primary key columns, the optimized PK lookup plan is used now.\n\nCloses #10298.", "committedDate": "2020-10-29T16:27:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyMjU4NA==", "url": "https://github.com/crate/crate/pull/10708#discussion_r514922584", "bodyText": "This isn't streamed and looking at the usages I think being able to change the granularity is currently also not really necessary?", "author": "mfussenegger", "createdAt": "2020-10-30T07:54:01Z", "path": "server/src/main/java/io/crate/execution/dsl/projection/EvalProjection.java", "diffHunk": "@@ -41,6 +42,7 @@\n public class EvalProjection extends Projection {\n \n     private final List<Symbol> outputs;\n+    private RowGranularity requiredGranularity = RowGranularity.CLUSTER;", "originalCommit": "514fe793e8d32e6d23292bcb768f35f925509d75", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "770bd3dcc253017a6738b44500d38eb32a049014", "chunk": "diff --git a/server/src/main/java/io/crate/execution/dsl/projection/EvalProjection.java b/server/src/main/java/io/crate/execution/dsl/projection/EvalProjection.java\nindex ea00a6f733..84d802a852 100644\n--- a/server/src/main/java/io/crate/execution/dsl/projection/EvalProjection.java\n+++ b/server/src/main/java/io/crate/execution/dsl/projection/EvalProjection.java\n\n@@ -42,7 +41,6 @@ import java.util.Map;\n public class EvalProjection extends Projection {\n \n     private final List<Symbol> outputs;\n-    private RowGranularity requiredGranularity = RowGranularity.CLUSTER;\n \n     public EvalProjection(List<Symbol> outputs) {\n         assert outputs.stream().noneMatch(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyNjAxNg==", "url": "https://github.com/crate/crate/pull/10708#discussion_r514926016", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Symbol> boundOutputs = Lists2.map(\n          \n          \n            \n                        outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n          \n          \n            \n                    var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n          \n          \n            \n                    var binder = new SubQueryAndParamBinder(params, subQueryResults);\n          \n          \n            \n                    List<Symbol> boundOutputs = Lists2.map(outputs, binder)\n          \n          \n            \n                    var boundQuery = binder.convert(query);\n          \n      \n    \n    \n  \n\nAvoids creating 2 SubQueryAndParamBinder instances", "author": "mfussenegger", "createdAt": "2020-10-30T08:02:11Z", "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);", "originalCommit": "514fe793e8d32e6d23292bcb768f35f925509d75", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "770bd3dcc253017a6738b44500d38eb32a049014", "chunk": "diff --git a/server/src/main/java/io/crate/planner/operators/Get.java b/server/src/main/java/io/crate/planner/operators/Get.java\nindex 6aae4dfed7..5ffcea260a 100644\n--- a/server/src/main/java/io/crate/planner/operators/Get.java\n+++ b/server/src/main/java/io/crate/planner/operators/Get.java\n\n@@ -155,25 +156,40 @@ public class Get implements LogicalPlan {\n         docKeyColumns.add(DocSysColumns.SEQ_NO);\n         docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n \n-        List<Symbol> boundOutputs = Lists2.map(\n-            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n-        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+        var binder = new SubQueryAndParamBinder(params, subQueryResults);\n+        List<Symbol> boundOutputs = Lists2.map(outputs, binder);\n+        var boundQuery = binder.apply(query);\n \n-        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        // Collect all columns which are used inside the query\n+        // If the query contains only DocKeys, no filter is needed as all DocKeys are handled by the PKLookupOperation\n+        AtomicBoolean requiresAdditionalFilteringOnNonDocKeyColumns = new AtomicBoolean(false);\n+        var toCollectSet = new LinkedHashSet<>(boundOutputs);\n         Consumer<Reference> addRefIfMatch = ref -> {\n-            if (ref.ident().tableIdent().equals(tableRelation.relationName())\n-                && docKeyColumns.contains(ref.column()) == false) {\n-                toCollect.add(ref);\n+            toCollectSet.add(ref);\n+            if (docKeyColumns.contains(ref.column()) == false) {\n+                requiresAdditionalFilteringOnNonDocKeyColumns.set(true);\n             }\n         };\n         RefVisitor.visitRefs(boundQuery, addRefIfMatch);\n \n+        var toCollect = boundOutputs;\n+        ArrayList<Projection> projections = new ArrayList<>();\n+        if (requiresAdditionalFilteringOnNonDocKeyColumns.get()) {\n+            toCollect = List.copyOf(toCollectSet);\n+            var filterProjection = ProjectionBuilder.filterProjection(toCollect, boundQuery);\n+            projections.add(filterProjection);\n+\n+            // reduce outputs which have been added for the filter projection\n+            var evalProjection = new EvalProjection(InputColumn.mapToInputColumns(boundOutputs));\n+            projections.add(evalProjection);\n+        }\n+\n         var collect = new Collect(\n             new PKLookupPhase(\n                 plannerContext.jobId(),\n                 plannerContext.nextExecutionPhaseId(),\n                 docTableInfo.partitionedBy(),\n-                List.copyOf(toCollect),\n+                toCollect,\n                 idsByShardByNode\n             ),\n             TopN.NO_LIMIT,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyNjI4Mw==", "url": "https://github.com/crate/crate/pull/10708#discussion_r514926283", "bodyText": "In which case can ref.ident().tableIdent().equals(tableRelation.relationName()) be false here?", "author": "mfussenegger", "createdAt": "2020-10-30T08:02:50Z", "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+\n+        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        Consumer<Reference> addRefIfMatch = ref -> {\n+            if (ref.ident().tableIdent().equals(tableRelation.relationName())", "originalCommit": "514fe793e8d32e6d23292bcb768f35f925509d75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE5ODk0NQ==", "url": "https://github.com/crate/crate/pull/10708#discussion_r515198945", "bodyText": "Should, not happen, I'll remove this.", "author": "seut", "createdAt": "2020-10-30T15:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyNjI4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "770bd3dcc253017a6738b44500d38eb32a049014", "chunk": "diff --git a/server/src/main/java/io/crate/planner/operators/Get.java b/server/src/main/java/io/crate/planner/operators/Get.java\nindex 6aae4dfed7..5ffcea260a 100644\n--- a/server/src/main/java/io/crate/planner/operators/Get.java\n+++ b/server/src/main/java/io/crate/planner/operators/Get.java\n\n@@ -155,25 +156,40 @@ public class Get implements LogicalPlan {\n         docKeyColumns.add(DocSysColumns.SEQ_NO);\n         docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n \n-        List<Symbol> boundOutputs = Lists2.map(\n-            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n-        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+        var binder = new SubQueryAndParamBinder(params, subQueryResults);\n+        List<Symbol> boundOutputs = Lists2.map(outputs, binder);\n+        var boundQuery = binder.apply(query);\n \n-        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        // Collect all columns which are used inside the query\n+        // If the query contains only DocKeys, no filter is needed as all DocKeys are handled by the PKLookupOperation\n+        AtomicBoolean requiresAdditionalFilteringOnNonDocKeyColumns = new AtomicBoolean(false);\n+        var toCollectSet = new LinkedHashSet<>(boundOutputs);\n         Consumer<Reference> addRefIfMatch = ref -> {\n-            if (ref.ident().tableIdent().equals(tableRelation.relationName())\n-                && docKeyColumns.contains(ref.column()) == false) {\n-                toCollect.add(ref);\n+            toCollectSet.add(ref);\n+            if (docKeyColumns.contains(ref.column()) == false) {\n+                requiresAdditionalFilteringOnNonDocKeyColumns.set(true);\n             }\n         };\n         RefVisitor.visitRefs(boundQuery, addRefIfMatch);\n \n+        var toCollect = boundOutputs;\n+        ArrayList<Projection> projections = new ArrayList<>();\n+        if (requiresAdditionalFilteringOnNonDocKeyColumns.get()) {\n+            toCollect = List.copyOf(toCollectSet);\n+            var filterProjection = ProjectionBuilder.filterProjection(toCollect, boundQuery);\n+            projections.add(filterProjection);\n+\n+            // reduce outputs which have been added for the filter projection\n+            var evalProjection = new EvalProjection(InputColumn.mapToInputColumns(boundOutputs));\n+            projections.add(evalProjection);\n+        }\n+\n         var collect = new Collect(\n             new PKLookupPhase(\n                 plannerContext.jobId(),\n                 plannerContext.nextExecutionPhaseId(),\n                 docTableInfo.partitionedBy(),\n-                List.copyOf(toCollect),\n+                toCollect,\n                 idsByShardByNode\n             ),\n             TopN.NO_LIMIT,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ==", "url": "https://github.com/crate/crate/pull/10708#discussion_r514928485", "bodyText": "I also don't quite understand why this check is necessary. toCollect is a set, so duplicates won't be added anyways?\nIs this under the assumption that the symbol might not be needed because it is only used in the docKeys part? I'm not sure if that assertion is safe. Couldn't the query still use columns from docKeyColumns ?", "author": "mfussenegger", "createdAt": "2020-10-30T08:08:05Z", "path": "server/src/main/java/io/crate/planner/operators/Get.java", "diffHunk": "@@ -135,20 +147,55 @@ public ExecutionPlan build(PlannerContext plannerContext,\n                 .orElse(SequenceNumbers.UNASSIGNED_PRIMARY_TERM);\n             pkAndVersions.add(new PKAndVersion(id, version, sequenceNumber, primaryTerm));\n         }\n-        return new Collect(\n+\n+        var docKeyColumns = new ArrayList<>(docTableInfo.primaryKey());\n+        docKeyColumns.addAll(docTableInfo.partitionedBy());\n+        docKeyColumns.add(docTableInfo.clusteredBy());\n+        docKeyColumns.add(DocSysColumns.VERSION);\n+        docKeyColumns.add(DocSysColumns.SEQ_NO);\n+        docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n+\n+        List<Symbol> boundOutputs = Lists2.map(\n+            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n+        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+\n+        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        Consumer<Reference> addRefIfMatch = ref -> {\n+            if (ref.ident().tableIdent().equals(tableRelation.relationName())\n+                && docKeyColumns.contains(ref.column()) == false) {", "originalCommit": "514fe793e8d32e6d23292bcb768f35f925509d75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk0NTM2MQ==", "url": "https://github.com/crate/crate/pull/10708#discussion_r514945361", "bodyText": "Maybe it would make sense to use something like SymbolVisitors.intersection(query, allPossibleTableOutputs, toCollect::add); ?\nI think that would handle functions better. If you have a SELECT substr(x, ...) WHERE .. (pk = 1 AND substr(x, ..) it wouldn't add x to the outputs I think.", "author": "mfussenegger", "createdAt": "2020-10-30T08:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIwMDE2MQ==", "url": "https://github.com/crate/crate/pull/10708#discussion_r515200161", "bodyText": "Yep right, good catch. This logic which is intended to only add a filter projection when needed (other columns than DocKeys are part of the query) was not correct. I'll push a new safe logic.", "author": "seut", "createdAt": "2020-10-30T15:52:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIyOTg4NQ==", "url": "https://github.com/crate/crate/pull/10708#discussion_r515229885", "bodyText": "Pushed a fixup before I saw your recent suggestion with the intersection. If you still think I should go in this direction instead, please shout.", "author": "seut", "createdAt": "2020-10-30T16:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwMzE0Mw==", "url": "https://github.com/crate/crate/pull/10708#discussion_r515303143", "bodyText": "And related to WHERE .. (pk = 1 AND substr(x, ..), as the RevVisitor traverses the tree x will be added to the outputs. This query works as expected. Do I miss anything?", "author": "seut", "createdAt": "2020-10-30T18:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5ODAwOQ==", "url": "https://github.com/crate/crate/pull/10708#discussion_r515798009", "bodyText": "I thought something along the lines of\ncreate table tbl (id int primary key, x int);\nselect x from tbl where id = 1 and (_seq_no = 1 or x = 1)\n\nBut that is forbidden.\nOr\nselect x from tbl where id = 1 and (id = 3 or x = 1);\n\nbut that works. So all good \ud83d\udc4d", "author": "mfussenegger", "createdAt": "2020-11-02T08:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyODQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "770bd3dcc253017a6738b44500d38eb32a049014", "chunk": "diff --git a/server/src/main/java/io/crate/planner/operators/Get.java b/server/src/main/java/io/crate/planner/operators/Get.java\nindex 6aae4dfed7..5ffcea260a 100644\n--- a/server/src/main/java/io/crate/planner/operators/Get.java\n+++ b/server/src/main/java/io/crate/planner/operators/Get.java\n\n@@ -155,25 +156,40 @@ public class Get implements LogicalPlan {\n         docKeyColumns.add(DocSysColumns.SEQ_NO);\n         docKeyColumns.add(DocSysColumns.PRIMARY_TERM);\n \n-        List<Symbol> boundOutputs = Lists2.map(\n-            outputs, s -> SubQueryAndParamBinder.convert(s, params, subQueryResults));\n-        var boundQuery = SubQueryAndParamBinder.convert(query, params, subQueryResults);\n+        var binder = new SubQueryAndParamBinder(params, subQueryResults);\n+        List<Symbol> boundOutputs = Lists2.map(outputs, binder);\n+        var boundQuery = binder.apply(query);\n \n-        var toCollect = new LinkedHashSet<>(boundOutputs);\n+        // Collect all columns which are used inside the query\n+        // If the query contains only DocKeys, no filter is needed as all DocKeys are handled by the PKLookupOperation\n+        AtomicBoolean requiresAdditionalFilteringOnNonDocKeyColumns = new AtomicBoolean(false);\n+        var toCollectSet = new LinkedHashSet<>(boundOutputs);\n         Consumer<Reference> addRefIfMatch = ref -> {\n-            if (ref.ident().tableIdent().equals(tableRelation.relationName())\n-                && docKeyColumns.contains(ref.column()) == false) {\n-                toCollect.add(ref);\n+            toCollectSet.add(ref);\n+            if (docKeyColumns.contains(ref.column()) == false) {\n+                requiresAdditionalFilteringOnNonDocKeyColumns.set(true);\n             }\n         };\n         RefVisitor.visitRefs(boundQuery, addRefIfMatch);\n \n+        var toCollect = boundOutputs;\n+        ArrayList<Projection> projections = new ArrayList<>();\n+        if (requiresAdditionalFilteringOnNonDocKeyColumns.get()) {\n+            toCollect = List.copyOf(toCollectSet);\n+            var filterProjection = ProjectionBuilder.filterProjection(toCollect, boundQuery);\n+            projections.add(filterProjection);\n+\n+            // reduce outputs which have been added for the filter projection\n+            var evalProjection = new EvalProjection(InputColumn.mapToInputColumns(boundOutputs));\n+            projections.add(evalProjection);\n+        }\n+\n         var collect = new Collect(\n             new PKLookupPhase(\n                 plannerContext.jobId(),\n                 plannerContext.nextExecutionPhaseId(),\n                 docTableInfo.partitionedBy(),\n-                List.copyOf(toCollect),\n+                toCollect,\n                 idsByShardByNode\n             ),\n             TopN.NO_LIMIT,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyOTg1MA==", "url": "https://github.com/crate/crate/pull/10708#discussion_r514929850", "bodyText": "Would it be possible to use the existing SymbolVisitors.any or Symbols.containsColumn  for this?", "author": "mfussenegger", "createdAt": "2020-10-30T08:11:19Z", "path": "server/src/main/java/io/crate/planner/statement/DeletePlanner.java", "diffHunk": "@@ -193,4 +203,32 @@ private static ExecutionPlan deleteByQuery(DocTableRelation table, PlannerContex\n         Collect collect = new Collect(collectPhase, TopN.NO_LIMIT, 0, 1, 1, null);\n         return Merge.ensureOnHandler(collect, context, Collections.singletonList(MergeCountProjection.INSTANCE));\n     }\n+\n+    private static class NonPartitionReferenceDetector extends SymbolVisitor<List<Reference>, Boolean> {", "originalCommit": "514fe793e8d32e6d23292bcb768f35f925509d75", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "770bd3dcc253017a6738b44500d38eb32a049014", "chunk": "diff --git a/server/src/main/java/io/crate/planner/statement/DeletePlanner.java b/server/src/main/java/io/crate/planner/statement/DeletePlanner.java\nindex 8659a738d6..123d156394 100644\n--- a/server/src/main/java/io/crate/planner/statement/DeletePlanner.java\n+++ b/server/src/main/java/io/crate/planner/statement/DeletePlanner.java\n\n@@ -203,32 +201,4 @@ public final class DeletePlanner {\n         Collect collect = new Collect(collectPhase, TopN.NO_LIMIT, 0, 1, 1, null);\n         return Merge.ensureOnHandler(collect, context, Collections.singletonList(MergeCountProjection.INSTANCE));\n     }\n-\n-    private static class NonPartitionReferenceDetector extends SymbolVisitor<List<Reference>, Boolean> {\n-        @Override\n-        public Boolean visitFunction(Function symbol, List<Reference> partitionedByColumns) {\n-            for (var arg : symbol.arguments()) {\n-                if (arg.accept(this, partitionedByColumns)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public Boolean visitReference(Reference symbol, List<Reference> partitionedByColumns) {\n-            return !partitionedByColumns.contains(symbol);\n-        }\n-\n-        @Override\n-        public Boolean visitDynamicReference(DynamicReference symbol,\n-                                             List<Reference> context) {\n-            return visitReference(symbol, context);\n-        }\n-\n-        @Override\n-        protected Boolean visitSymbol(Symbol symbol, List<Reference> partitionedByColumns) {\n-            return false;\n-        }\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkzMDU4Mw==", "url": "https://github.com/crate/crate/pull/10708#discussion_r514930583", "bodyText": "Isn't this already tested in testUpdateUsingSeqNoRequiresPk (UpdatePlannerTest) ?", "author": "mfussenegger", "createdAt": "2020-10-30T08:12:55Z", "path": "server/src/test/java/io/crate/integrationtests/SeqNoBasedOCCIntegrationTest.java", "diffHunk": "@@ -126,4 +126,26 @@ public void testSelectWhereSeqNoAndPTWithoutPrimaryKey() throws Exception {\n                                 HttpResponseStatus.BAD_REQUEST,\n                                 4000));\n     }\n+\n+    @Test\n+    public void test_update_where_id_and_seq_missing_primary_term() throws Exception {", "originalCommit": "514fe793e8d32e6d23292bcb768f35f925509d75", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "770bd3dcc253017a6738b44500d38eb32a049014", "chunk": "diff --git a/server/src/test/java/io/crate/integrationtests/SeqNoBasedOCCIntegrationTest.java b/server/src/test/java/io/crate/integrationtests/SeqNoBasedOCCIntegrationTest.java\nindex ec7ec0b461..d84f590c2b 100644\n--- a/server/src/test/java/io/crate/integrationtests/SeqNoBasedOCCIntegrationTest.java\n+++ b/server/src/test/java/io/crate/integrationtests/SeqNoBasedOCCIntegrationTest.java\n\n@@ -115,37 +115,4 @@ public class SeqNoBasedOCCIntegrationTest extends SQLTransportIntegrationTest {\n         assertEquals(1L, response.rowCount());\n         assertEquals(\"don't panic\", response.rows()[0][0]);\n     }\n-\n-    @Test\n-    public void testSelectWhereSeqNoAndPTWithoutPrimaryKey() throws Exception {\n-        execute(\"create table t (x integer primary key, y string)\");\n-        ensureYellow();\n-        assertThrows(() -> execute(\"select _seq_no, _primary_term from t where y = 'hello' and _seq_no = 1 and _primary_term = 2\"),\n-                     isSQLError(containsString(VersioninigValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG),\n-                                PGErrorStatus.INTERNAL_ERROR,\n-                                HttpResponseStatus.BAD_REQUEST,\n-                                4000));\n-    }\n-\n-    @Test\n-    public void test_update_where_id_and_seq_missing_primary_term() throws Exception {\n-        execute(\"create table t (x integer primary key, y string)\");\n-        ensureYellow();\n-        assertThrows(() -> execute(\"update t set y = 1 where x = 1 and _seq_no = 1\"),\n-                     isSQLError(containsString(VersioninigValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG),\n-                                PGErrorStatus.INTERNAL_ERROR,\n-                                HttpResponseStatus.BAD_REQUEST,\n-                                4000));\n-    }\n-\n-    @Test\n-    public void test_delete_where_id_and_seq_missing_primary_term() throws Exception {\n-        execute(\"create table t (x integer primary key, y string)\");\n-        ensureYellow();\n-        assertThrows(() -> execute(\"delete from t where x = 1 and _seq_no = 1\"),\n-                     isSQLError(containsString(VersioninigValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG),\n-                                PGErrorStatus.INTERNAL_ERROR,\n-                                HttpResponseStatus.BAD_REQUEST,\n-                                4000));\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkzMTI3Mw==", "url": "https://github.com/crate/crate/pull/10708#discussion_r514931273", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    execute(\"select id from t1 where id = 1 and x = 2\");\n          \n          \n            \n                    assertThat(response.rowCount(), is(0L));\n          \n          \n            \n                    execute(\"select id from t1 where id = 1 and x = 2\");\n          \n          \n            \n                    assertThat(response.rowCount(), is(0L));\n          \n          \n            \n            \n          \n          \n            \n                    execute(\"select id from t1 where id = 1 and x = 1\");\n          \n          \n            \n                    assertThat(response.rowCount(), is(1L));\n          \n      \n    \n    \n  \n\nTo have the \"pk lookup matches and query matches\" part covered too.", "author": "mfussenegger", "createdAt": "2020-10-30T08:14:29Z", "path": "server/src/test/java/io/crate/integrationtests/WherePKIntegrationTest.java", "diffHunk": "@@ -304,7 +304,14 @@ public void testDeleteByQueryCommaRouting() throws Exception {\n \n         execute(\"select * from explicit_routing\");\n         assertThat(response.rowCount(), is(2L));\n+    }\n \n+    @Test\n+    public void test_select_where_pk_and_additional_filter() {\n+        execute(\"create table t1 (id int primary key, x int) with (refresh_interval=0)\");\n+        execute(\"insert into t1 (id, x) values (1, 1)\");\n+        execute(\"select id from t1 where id = 1 and x = 2\");\n+        assertThat(response.rowCount(), is(0L));", "originalCommit": "514fe793e8d32e6d23292bcb768f35f925509d75", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "770bd3dcc253017a6738b44500d38eb32a049014", "chunk": "diff --git a/server/src/test/java/io/crate/integrationtests/WherePKIntegrationTest.java b/server/src/test/java/io/crate/integrationtests/WherePKIntegrationTest.java\nindex 80b78f71c7..d6978aeec9 100644\n--- a/server/src/test/java/io/crate/integrationtests/WherePKIntegrationTest.java\n+++ b/server/src/test/java/io/crate/integrationtests/WherePKIntegrationTest.java\n\n@@ -310,8 +310,12 @@ public class WherePKIntegrationTest extends SQLTransportIntegrationTest {\n     public void test_select_where_pk_and_additional_filter() {\n         execute(\"create table t1 (id int primary key, x int) with (refresh_interval=0)\");\n         execute(\"insert into t1 (id, x) values (1, 1)\");\n+\n         execute(\"select id from t1 where id = 1 and x = 2\");\n         assertThat(response.rowCount(), is(0L));\n+\n+        execute(\"select id from t1 where id = 1 and x = 1\");\n+        assertThat(response.rowCount(), is(1L));\n     }\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5Njc3OA==", "url": "https://github.com/crate/crate/pull/10708#discussion_r515796778", "bodyText": "Isn't this the same as org.junit.jupiter.api.Assertions.assertThrows ?", "author": "mfussenegger", "createdAt": "2020-11-02T08:07:40Z", "path": "server/src/test/java/io/crate/testing/Asserts.java", "diffHunk": "@@ -40,4 +42,14 @@ public static void assertThrows(Executable executable, Matcher<? super Throwable\n             assertThat(t, matcher);\n         }\n     }\n+\n+    public static void assertThrows(Executable executable, Class<? extends Throwable> type, String subString) {", "originalCommit": "eda372b47d75ef09fb7018cf6ff771c1147b5bb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5OTYzOA==", "url": "https://github.com/crate/crate/pull/10708#discussion_r515799638", "bodyText": "On the methods I know of/found, the given message is used as a prefix for a failure output instead of matching the thrown exception message. Or do other assertThrows implementation exists which I'm not aware of?", "author": "seut", "createdAt": "2020-11-02T08:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5Njc3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgwMjc0OA==", "url": "https://github.com/crate/crate/pull/10708#discussion_r515802748", "bodyText": "Oh right \ud83d\udc4d", "author": "mfussenegger", "createdAt": "2020-11-02T08:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5Njc3OA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "770bd3dcc253017a6738b44500d38eb32a049014", "url": "https://github.com/crate/crate/commit/770bd3dcc253017a6738b44500d38eb32a049014", "message": "Add support for PK lookup if additional filters are combined by AND\n\nIf filters are combined by AND operators in addition to filters\non primary key columns, the optimized PK lookup plan is used now.\n\nCloses #10298.", "committedDate": "2020-11-02T08:49:26Z", "type": "commit"}, {"oid": "770bd3dcc253017a6738b44500d38eb32a049014", "url": "https://github.com/crate/crate/commit/770bd3dcc253017a6738b44500d38eb32a049014", "message": "Add support for PK lookup if additional filters are combined by AND\n\nIf filters are combined by AND operators in addition to filters\non primary key columns, the optimized PK lookup plan is used now.\n\nCloses #10298.", "committedDate": "2020-11-02T08:49:26Z", "type": "forcePushed"}, {"oid": "c1a9c8097d312473db645ff1e149ea942fed204b", "url": "https://github.com/crate/crate/commit/c1a9c8097d312473db645ff1e149ea942fed204b", "message": "Merge branch 'master' into s/pk-filter", "committedDate": "2020-11-02T15:15:20Z", "type": "commit"}]}