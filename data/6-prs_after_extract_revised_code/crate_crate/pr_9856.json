{"pr_number": 9856, "pr_title": "Fix OFFSET application for UNION with ORDER BY", "pr_createdAt": "2020-04-09T14:10:53Z", "pr_url": "https://github.com/crate/crate/pull/9856", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzNDkwNQ==", "url": "https://github.com/crate/crate/pull/9856#discussion_r406234905", "bodyText": "This removed the resultDescription.orderBy information, which is required so that further merges on top of the union are ordered correctly.\nThe UnionExecutionPlan carries on the limit + offset, so that later operators which force a merge apply it correctly.", "author": "mfussenegger", "createdAt": "2020-04-09T14:13:37Z", "path": "sql/src/main/java/io/crate/planner/operators/Union.java", "diffHunk": "@@ -195,21 +191,4 @@ public long estimatedRowSize() {\n     public <C, R> R accept(LogicalPlanVisitor<C, R> visitor, C context) {\n         return visitor.visitUnion(this, context);\n     }\n-\n-    /**\n-     * Wraps the plan inside a Merge plan if limit or offset need to be applied.\n-     */\n-    private static ExecutionPlan addMergeIfNeeded(ExecutionPlan plan, PlannerContext plannerContext) {\n-        ResultDescription resultDescription = plan.resultDescription();\n-        if (resultDescription.hasRemainingLimitOrOffset()) {\n-            // Do a merge because we have to apply a limit/offset projection\n-            //\n-            // Note: Currently, this is performed on the handler node. It would be possible to\n-            // do this on another involved node instead but we don't do that for now because\n-            // the Merge of the union itself is always performed on the handler. So the\n-            // performance gain would be small.\n-            return Merge.ensureOnHandler(plan, plannerContext);", "originalCommit": "17f2513d1173b8c98d040278f56f502cf45e6ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM5OTcyNg==", "url": "https://github.com/crate/crate/pull/9856#discussion_r406399726", "bodyText": "@mkleen had to push a fixup because if there is a limit - order by operator beneath the union   it must be merged before the union. So I had to re-add this part", "author": "mfussenegger", "createdAt": "2020-04-09T18:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzNDkwNQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "db12ecd9598bfc98d3b95e1ef0275910b3d07d62", "url": "https://github.com/crate/crate/commit/db12ecd9598bfc98d3b95e1ef0275910b3d07d62", "message": "Fix OFFSET application for UNION with ORDER BY\n\nThe logical plan was correct, but the offset of the Limit operator was\npassed down too far.\n\n    Limit[100;1]                          // Due to the offset application below, OFFSET 2 was already applied *before* the LIMIT operator\n      \u2514 Union[id, num]                    // passed down (limit + offset) as limit BUT also offset (1)\n        \u251c OrderBy[max(num) AS num ASC]    // Resulted in a OrderedTopN with limit 101, offset 1\n        \u2502  \u2514 Eval[id, max(num) AS num]\n        \u2502    \u2514 GroupHashAggregate[id | max(num)]\n        \u2502      \u2514 Rename[id, num] AS t\n        \u2502        \u2514 TableFunction[unnest | [col1, col2] | true]\n        \u2514 OrderBy[max(num) AS num ASC]    // Same as above\n          \u2514 Eval[id, max(num) AS num]\n            \u2514 GroupHashAggregate[id | max(num)]\n              \u2514 Rename[id, num] AS t\n                \u2514 TableFunction[unnest | [col1, col2] | true]", "committedDate": "2020-04-09T19:09:44Z", "type": "commit"}, {"oid": "db12ecd9598bfc98d3b95e1ef0275910b3d07d62", "url": "https://github.com/crate/crate/commit/db12ecd9598bfc98d3b95e1ef0275910b3d07d62", "message": "Fix OFFSET application for UNION with ORDER BY\n\nThe logical plan was correct, but the offset of the Limit operator was\npassed down too far.\n\n    Limit[100;1]                          // Due to the offset application below, OFFSET 2 was already applied *before* the LIMIT operator\n      \u2514 Union[id, num]                    // passed down (limit + offset) as limit BUT also offset (1)\n        \u251c OrderBy[max(num) AS num ASC]    // Resulted in a OrderedTopN with limit 101, offset 1\n        \u2502  \u2514 Eval[id, max(num) AS num]\n        \u2502    \u2514 GroupHashAggregate[id | max(num)]\n        \u2502      \u2514 Rename[id, num] AS t\n        \u2502        \u2514 TableFunction[unnest | [col1, col2] | true]\n        \u2514 OrderBy[max(num) AS num ASC]    // Same as above\n          \u2514 Eval[id, max(num) AS num]\n            \u2514 GroupHashAggregate[id | max(num)]\n              \u2514 Rename[id, num] AS t\n                \u2514 TableFunction[unnest | [col1, col2] | true]", "committedDate": "2020-04-09T19:09:44Z", "type": "forcePushed"}]}