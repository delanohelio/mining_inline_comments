{"pr_number": 9887, "pr_title": "Migrate more tables to SystemTable", "pr_createdAt": "2020-04-23T15:49:19Z", "pr_url": "https://github.com/crate/crate/pull/9887", "timeline": [{"oid": "74f5ae3ac69323262840f46fbc4612d04d4d0ebd", "url": "https://github.com/crate/crate/commit/74f5ae3ac69323262840f46fbc4612d04d4d0ebd", "message": "Migrate InformationReferentialConstraintsTableInfo to SystemTable", "committedDate": "2020-04-24T09:31:41Z", "type": "commit"}, {"oid": "c38b2a8b68e4f096dbfc83f2bd348d9c7bdcf8be", "url": "https://github.com/crate/crate/commit/c38b2a8b68e4f096dbfc83f2bd348d9c7bdcf8be", "message": "Migrate InformationRoutinesTableInfo to SystemTable", "committedDate": "2020-04-24T09:31:41Z", "type": "commit"}, {"oid": "b6a6d753d202b390be43f02cf4bfce73d8e1737f", "url": "https://github.com/crate/crate/commit/b6a6d753d202b390be43f02cf4bfce73d8e1737f", "message": "Migrate InformationSchemataTableInfo to SystemTable", "committedDate": "2020-04-24T09:31:41Z", "type": "commit"}, {"oid": "3349855bc204dd763c53fcb22aba53924fe8c60a", "url": "https://github.com/crate/crate/commit/3349855bc204dd763c53fcb22aba53924fe8c60a", "message": "Migrate InformationSqlFeaturesTableInfo to SystemTable", "committedDate": "2020-04-24T09:31:41Z", "type": "commit"}, {"oid": "36f705169959dea1eef874219d1e02a0a4b01fba", "url": "https://github.com/crate/crate/commit/36f705169959dea1eef874219d1e02a0a4b01fba", "message": "Migrate InformationTableConstraintsTableInfo to SystemTable", "committedDate": "2020-04-24T09:31:41Z", "type": "commit"}, {"oid": "b1cae3792addf25cf14ad48974fba3344b7d0a1e", "url": "https://github.com/crate/crate/commit/b1cae3792addf25cf14ad48974fba3344b7d0a1e", "message": "Move ObjectBuilder and ObjectArrayBuilder out of RelationBuilder\n\nReduces the amount of nesting.", "committedDate": "2020-04-24T09:59:17Z", "type": "commit"}, {"oid": "b1cae3792addf25cf14ad48974fba3344b7d0a1e", "url": "https://github.com/crate/crate/commit/b1cae3792addf25cf14ad48974fba3344b7d0a1e", "message": "Move ObjectBuilder and ObjectArrayBuilder out of RelationBuilder\n\nReduces the amount of nesting.", "committedDate": "2020-04-24T09:59:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyMDg5MQ==", "url": "https://github.com/crate/crate/pull/9887#discussion_r414620891", "bodyText": "Is there a way to avoid to catch a NullPointerException ?", "author": "mkleen", "createdAt": "2020-04-24T14:30:12Z", "path": "sql/src/main/java/io/crate/metadata/SystemTable.java", "diffHunk": "@@ -295,139 +295,141 @@ public void addExpression(HashMap<ColumnIdent, RowCollectExpressionFactory<T>> e\n             return this;\n         }\n \n-        public static class ObjectBuilder<T, P extends Builder<T>> extends Builder<T> {\n \n-            private final P parent;\n-            private final ColumnIdent baseColumn;\n-            private final ArrayList<Column<T, ?>> columns = new ArrayList<>();\n+    }\n \n-            public ObjectBuilder(P parent, ColumnIdent baseColumn) {\n-                this.parent = parent;\n-                this.baseColumn = baseColumn;\n-            }\n+    public static class ObjectBuilder<T, P extends Builder<T>> extends Builder<T> {\n \n-            public <U> ObjectBuilder<T, P> add(String column, DataType<U> type, Function<T, U> getProperty) {\n-                return add(new Column<>(baseColumn.append(column), type, getProperty));\n-            }\n+        private final P parent;\n+        private final ColumnIdent baseColumn;\n+        private final ArrayList<Column<T, ?>> columns = new ArrayList<>();\n \n-            @Override\n-            protected <U> ObjectBuilder<T, P> add(Column<T, U> column) {\n-                columns.add(column);\n-                return this;\n-            }\n+        public ObjectBuilder(P parent, ColumnIdent baseColumn) {\n+            this.parent = parent;\n+            this.baseColumn = baseColumn;\n+        }\n \n-            public <U> ObjectArrayBuilder<U, T, ObjectBuilder<T, P>> startObjectArray(String column, Function<T, List<U>> getItems) {\n-                return new ObjectArrayBuilder<>(this, baseColumn.append(column), getItems);\n-            }\n+        public <U> ObjectBuilder<T, P> add(String column, DataType<U> type, Function<T, U> getProperty) {\n+            return add(new Column<>(baseColumn.append(column), type, getProperty));\n+        }\n \n-            public ObjectBuilder<T, ObjectBuilder<T, P>> startObject(String column) {\n-                return new ObjectBuilder<>(this, baseColumn.append(column));\n-            }\n+        @Override\n+        protected <U> ObjectBuilder<T, P> add(Column<T, U> column) {\n+            columns.add(column);\n+            return this;\n+        }\n \n-            public P endObject() {\n-                ObjectType.Builder typeBuilder = ObjectType.builder();\n-                ArrayList<Column<T, ?>> directChildren = new ArrayList<>();\n-                for (var col : columns) {\n-                    if (col.column.path().size() == baseColumn.path().size() + 1) {\n-                        directChildren.add(col);\n-                    }\n-                }\n-                for (var column : directChildren) {\n-                    typeBuilder.setInnerType(column.column.leafName(), column.type);\n-                }\n-                ObjectType objectType = typeBuilder.build();\n-                parent.add(new Column<>(baseColumn, objectType, new ObjectExpression<>(directChildren)));\n-                for (Column<T, ?> column : columns) {\n-                    addColumnToParent(column);\n+        public <U> ObjectArrayBuilder<U, T, ObjectBuilder<T, P>> startObjectArray(String column, Function<T, List<U>> getItems) {\n+            return new ObjectArrayBuilder<>(this, baseColumn.append(column), getItems);\n+        }\n+\n+        public ObjectBuilder<T, ObjectBuilder<T, P>> startObject(String column) {\n+            return new ObjectBuilder<>(this, baseColumn.append(column));\n+        }\n+\n+        public P endObject() {\n+            ObjectType.Builder typeBuilder = ObjectType.builder();\n+            ArrayList<Column<T, ?>> directChildren = new ArrayList<>();\n+            for (var col : columns) {\n+                if (col.column.path().size() == baseColumn.path().size() + 1) {\n+                    directChildren.add(col);\n                 }\n-                return parent;\n             }\n-\n-            public <U> void addColumnToParent(Column<T, U> column) {\n-                parent.add(new Column<>(column.column, column.type, column.getProperty));\n+            for (var column : directChildren) {\n+                typeBuilder.setInnerType(column.column.leafName(), column.type);\n+            }\n+            ObjectType objectType = typeBuilder.build();\n+            parent.add(new Column<>(baseColumn, objectType, new ObjectExpression<>(directChildren)));\n+            for (Column<T, ?> column : columns) {\n+                addColumnToParent(column);\n             }\n+            return parent;\n+        }\n+\n+        private <U> void addColumnToParent(Column<T, U> column) {\n+            parent.add(new Column<>(column.column, column.type, column.getProperty));\n         }\n+    }\n+\n+    public static class ObjectArrayBuilder<ItemType, ParentItemType, P extends Builder<ParentItemType>> extends Builder<ItemType> {\n \n-        public static class ObjectArrayBuilder<ItemType, ParentItemType, P extends Builder<ParentItemType>> extends Builder<ItemType> {\n+        private final P parent;\n+        private final ArrayList<Column<ItemType, ?>> columns = new ArrayList<>();\n+        private final ColumnIdent baseColumn;\n+        private final Function<ParentItemType, List<ItemType>> getItems;\n \n-            private final P parent;\n-            private final ArrayList<Column<ItemType, ?>> columns = new ArrayList<>();\n-            private final ColumnIdent baseColumn;\n-            private final Function<ParentItemType, List<ItemType>> getItems;\n+        public ObjectArrayBuilder(P parent, ColumnIdent baseColumn, Function<ParentItemType, List<ItemType>> getItems) {\n+            this.parent = parent;\n+            this.baseColumn = baseColumn;\n+            this.getItems = getItems;\n+        }\n \n-            public ObjectArrayBuilder(P parent, ColumnIdent baseColumn, Function<ParentItemType, List<ItemType>> getItems) {\n-                this.parent = parent;\n-                this.baseColumn = baseColumn;\n-                this.getItems = getItems;\n+        public P endObjectArray() {\n+            ObjectType.Builder typeBuilder = ObjectType.builder();\n+            ArrayList<Column<ItemType, ?>> directChildren = new ArrayList<>();\n+            for (var col : columns) {\n+                if (col.column.path().size() == baseColumn.path().size() + 1) {\n+                    directChildren.add(col);\n+                }\n+            }\n+            for (var column : directChildren) {\n+                typeBuilder.setInnerType(column.column.leafName(), column.type);\n+            }\n+            ObjectType objectType = typeBuilder.build();\n+            parent.add(new Column<>(baseColumn, new ArrayType<>(objectType), getLeafColumnValues(directChildren)));\n+            for (var column : columns) {\n+                addColumnToParent(column);\n             }\n+            return parent;\n+        }\n \n-            public P endObjectArray() {\n-                ObjectType.Builder typeBuilder = ObjectType.builder();\n-                ArrayList<Column<ItemType, ?>> directChildren = new ArrayList<>();\n-                for (var col : columns) {\n-                    if (col.column.path().size() == baseColumn.path().size() + 1) {\n-                        directChildren.add(col);\n+        public Function<ParentItemType, List<Map<String, Object>>> getLeafColumnValues(ArrayList<Column<ItemType, ?>> directChildren) {\n+            return xs -> {\n+                var items = getItems.apply(xs);\n+                ArrayList<Map<String, Object>> result = new ArrayList<>(items.size());\n+                for (ItemType item : items) {\n+                    HashMap<String, Object> map = new HashMap<>(directChildren.size());\n+                    for (int i = 0; i < directChildren.size(); i++) {\n+                        Column<ItemType, ?> column = directChildren.get(i);\n+                        try {\n+                            Object value = column.getProperty.apply(item);\n+                            map.put(column.column.leafName(), value);\n+                        } catch (NullPointerException ignored) {", "originalCommit": "b1cae3792addf25cf14ad48974fba3344b7d0a1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyMzgxNg==", "url": "https://github.com/crate/crate/pull/9887#discussion_r414623816", "bodyText": "Yes, by making sure that all the expressions we use to retrieve the properties handle null cases correctly.  Not sure if that's worth it. We could follow up on it but I'd keep it for now.", "author": "mfussenegger", "createdAt": "2020-04-24T14:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyMDg5MQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "42efa0a3e17649f955098cd1e80b4cceea7d7925", "url": "https://github.com/crate/crate/commit/42efa0a3e17649f955098cd1e80b4cceea7d7925", "message": "Merge branch 'master' into j/sys-tables", "committedDate": "2020-04-24T14:35:27Z", "type": "commit"}]}