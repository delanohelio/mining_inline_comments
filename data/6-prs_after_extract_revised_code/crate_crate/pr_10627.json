{"pr_number": 10627, "pr_title": "Fix the partitions deletion from the subquery expressions.", "pr_createdAt": "2020-10-07T12:41:33Z", "pr_url": "https://github.com/crate/crate/pull/10627", "timeline": [{"oid": "8cc6ccde61cc5464c5ae0dbe544a4f0a7a00a62a", "url": "https://github.com/crate/crate/commit/8cc6ccde61cc5464c5ae0dbe544a4f0a7a00a62a", "message": "Make WhereClause#hasQuery return false if query is a value symbol.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type.\nThis change restores the previous behaviour.", "committedDate": "2020-10-07T12:42:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMDM5NA==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501000394", "bodyText": "Looking at some of the usages I think this could also lead to bugs if the query is a literal false.\nMaybe we should combine this with canMatch ?", "author": "mfussenegger", "createdAt": "2020-10-07T13:13:05Z", "path": "server/src/main/java/io/crate/analyze/WhereClause.java", "diffHunk": "@@ -81,7 +81,7 @@ public WhereClause(@Nullable Symbol normalizedQuery,\n     }\n \n     public boolean hasQuery() {\n-        return query != null;\n+        return query != null && !query.symbolType().isValueSymbol();", "originalCommit": "8cc6ccde61cc5464c5ae0dbe544a4f0a7a00a62a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2MDkyNw==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501060927", "bodyText": "hm do you mean combine it with the method body logic query != null && !query.symbolType().isValueSymbol() or at the hasQuery call sides? Combining it in the method body would probably be semantically incorrect Another possible solution would be just using canMatch in the DeletePlanner instead of !hasQuery https://github.com/crate/crate/blob/master/server/src/main/java/io/crate/planner/statement/DeletePlanner.java#L136 and leave the hasQuery without further modifications.", "author": "kovrus", "createdAt": "2020-10-07T14:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMDM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA3MDA2NQ==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501070065", "bodyText": "Another possible solution would be just using canMatch in the DeletePlanner instead of !hasQuery\n\nI like that solution \ud83d\udc4d", "author": "mfussenegger", "createdAt": "2020-10-07T14:42:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMDM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA3MTUwNg==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501071506", "bodyText": "Although I think it would also change semantics? If there still is a query, then it's not guranteed that it matches the entire query?\nI think we'd have to be explicit and check that either there is no query, or it matches everything", "author": "mfussenegger", "createdAt": "2020-10-07T14:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMDM5NA=="}], "type": "inlineReview", "revised_code": {"commit": "ecffe7207c0556d8e88fbd1e3c6d94d399ef49e6", "chunk": "diff --git a/server/src/main/java/io/crate/analyze/WhereClause.java b/server/src/main/java/io/crate/analyze/WhereClause.java\nindex 6025f837bd..a2b0a8f143 100644\n--- a/server/src/main/java/io/crate/analyze/WhereClause.java\n+++ b/server/src/main/java/io/crate/analyze/WhereClause.java\n\n@@ -81,7 +81,7 @@ public class WhereClause {\n     }\n \n     public boolean hasQuery() {\n-        return query != null && !query.symbolType().isValueSymbol();\n+        return query != null;\n     }\n \n     @Nullable\n"}}, {"oid": "ecffe7207c0556d8e88fbd1e3c6d94d399ef49e6", "url": "https://github.com/crate/crate/commit/ecffe7207c0556d8e88fbd1e3c6d94d399ef49e6", "message": "Fix the deletion of partiitions from the subquery expressions.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type\nrepresented by Literal.TRUE. This change address this issue in the\nDeletePlanner by adding an additional `canMatch` check when deciding\nwhich delete plan to execute.", "committedDate": "2020-10-08T08:08:31Z", "type": "forcePushed"}, {"oid": "edd43782abbf334e1e152034348fa1d45a032c6c", "url": "https://github.com/crate/crate/commit/edd43782abbf334e1e152034348fa1d45a032c6c", "message": "Fix the partitions deletion from the subquery expressions.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type\nrepresented by Literal.TRUE. That resulted in the wrong plan that would\nleave empty orphaned partitions after the delition.\n\nThis change address this issue in the DeletePlanner by adding an additional\n`canMatch` check when deciding which delete plan to execute.", "committedDate": "2020-10-08T08:21:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU0NDQ5Ng==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501544496", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            && (!where.hasQuery() || WhereClause.canMatch(where.query()))) {\n          \n          \n            \n                            && (!where.hasQuery() || Literal.BOOLEAN_TRUE.equals(where.query()))) {\n          \n      \n    \n    \n  \n\nI think canMatch could also return true for queries that have a chance of matching a sub-set of the records. In that case we cannot delete the full partition.\nSee \n  \n    \n      crate/server/src/main/java/io/crate/analyze/where/WhereClauseAnalyzer.java\n    \n    \n        Lines 142 to 149\n      in\n      ced7812\n    \n    \n    \n    \n\n        \n          \n           } else if (queryPartitionMap.size() > 0) { \n        \n\n        \n          \n               PartitionResult partitionResult = tieBreakPartitionQueries( \n        \n\n        \n          \n                   normalizer, queryPartitionMap, coordinatorTxnCtx); \n        \n\n        \n          \n               return partitionResult == null \n        \n\n        \n          \n                   // if partitionResult is null we can't narrow the partitions and keep the full query + use all partitions \n        \n\n        \n          \n                   // the query will then be evaluated correctly within each partition to see whether it matches or not \n        \n\n        \n          \n                   ? new PartitionResult(query, Lists2.map(tableInfo.partitions(), PartitionName::asIndexName)) \n        \n\n        \n          \n                   : partitionResult; \n        \n    \n  \n\n\ntest_where_on_date_with_null_partition_or_id_can_match_all_partitions and test_where_clause_that_could_match_on_null_partition_filters_correct_records are examples where that can be the case.", "author": "mfussenegger", "createdAt": "2020-10-08T08:37:25Z", "path": "server/src/main/java/io/crate/planner/statement/DeletePlanner.java", "diffHunk": "@@ -133,7 +133,8 @@ public void executeOrFail(DependencyCarrier executor,\n                 subQueryResults,\n                 plannerContext.transactionContext(),\n                 executor.nodeContext());\n-            if (!where.partitions().isEmpty() && !where.hasQuery()) {\n+            if (!where.partitions().isEmpty()\n+                && (!where.hasQuery() || WhereClause.canMatch(where.query()))) {", "originalCommit": "edd43782abbf334e1e152034348fa1d45a032c6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU0NTYxOQ==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501545619", "bodyText": "Yep, true. WIll check the quality against the Literal.BOOLEAN_TRUE \ud83d\udc4d tnx", "author": "kovrus", "createdAt": "2020-10-08T08:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU0NDQ5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "abcc3cea66a2172274a9744ddd9b00d58e9fa13a", "chunk": "diff --git a/server/src/main/java/io/crate/planner/statement/DeletePlanner.java b/server/src/main/java/io/crate/planner/statement/DeletePlanner.java\nindex 5c79b79cdf..f8a10752c0 100644\n--- a/server/src/main/java/io/crate/planner/statement/DeletePlanner.java\n+++ b/server/src/main/java/io/crate/planner/statement/DeletePlanner.java\n\n@@ -134,7 +135,7 @@ public final class DeletePlanner {\n                 plannerContext.transactionContext(),\n                 executor.nodeContext());\n             if (!where.partitions().isEmpty()\n-                && (!where.hasQuery() || WhereClause.canMatch(where.query()))) {\n+                && (!where.hasQuery() || Literal.BOOLEAN_TRUE.equals(where.query()))) {\n                 DeleteIndexRequest request = new DeleteIndexRequest(where.partitions().toArray(new String[0]));\n                 request.indicesOptions(IndicesOptions.lenientExpandOpen());\n                 executor.transportActionProvider().transportDeleteIndexAction()\n"}}, {"oid": "abcc3cea66a2172274a9744ddd9b00d58e9fa13a", "url": "https://github.com/crate/crate/commit/abcc3cea66a2172274a9744ddd9b00d58e9fa13a", "message": "Fix the partitions deletion from the subquery expressions.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type\nrepresented by Literal.BOOLEAN_TRUE. That resulted in the wrong plan that\nwould leave empty orphaned partitions after the delition.\n\nThis change address this issue in the DeletePlanner by adding an additional\nwhere clause = Literal.BOOLEAN_TRUE check to decide which delete plan to execute.", "committedDate": "2020-10-08T08:40:07Z", "type": "forcePushed"}, {"oid": "96bb1c9148d72b9211abe8311681e6bb949df87c", "url": "https://github.com/crate/crate/commit/96bb1c9148d72b9211abe8311681e6bb949df87c", "message": "Fix the partitions deletion from the subquery expressions.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type\nrepresented by Literal.BOOLEAN_TRUE. That resulted in the wrong plan that\nwould leave empty orphaned partitions after the delition.\n\nThis change address this issue in the DeletePlanner by adding an additional\nwhere clause = Literal.BOOLEAN_TRUE check to decide which delete plan to execute.", "committedDate": "2020-10-08T08:43:38Z", "type": "commit"}, {"oid": "96bb1c9148d72b9211abe8311681e6bb949df87c", "url": "https://github.com/crate/crate/commit/96bb1c9148d72b9211abe8311681e6bb949df87c", "message": "Fix the partitions deletion from the subquery expressions.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type\nrepresented by Literal.BOOLEAN_TRUE. That resulted in the wrong plan that\nwould leave empty orphaned partitions after the delition.\n\nThis change address this issue in the DeletePlanner by adding an additional\nwhere clause = Literal.BOOLEAN_TRUE check to decide which delete plan to execute.", "committedDate": "2020-10-08T08:43:38Z", "type": "forcePushed"}]}