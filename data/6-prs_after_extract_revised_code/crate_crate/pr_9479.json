{"pr_number": 9479, "pr_title": "Remove `RamAccountingContext`, use new eagerly ram accounting instead", "pr_createdAt": "2020-01-06T10:37:48Z", "pr_url": "https://github.com/crate/crate/pull/9479", "timeline": [{"oid": "48f8bb895bc41c67b86bf56e0e88093f93f8e597", "url": "https://github.com/crate/crate/commit/48f8bb895bc41c67b86bf56e0e88093f93f8e597", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-01-17T10:38:17Z", "type": "forcePushed"}, {"oid": "c6328e384abfd699242598c0d515c7e648a6f90c", "url": "https://github.com/crate/crate/commit/c6328e384abfd699242598c0d515c7e648a6f90c", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-01-20T11:30:26Z", "type": "forcePushed"}, {"oid": "96169dbef760e8dc3ab699656f04e472f3aa4869", "url": "https://github.com/crate/crate/commit/96169dbef760e8dc3ab699656f04e472f3aa4869", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-02-14T10:53:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM3OTI0Ng==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379379246", "bodyText": "We could also decide if we should account inside the NodeFetchResponse only if (numReaders > 0) https://github.com/crate/crate/blob/master/sql/src/main/java/io/crate/execution/engine/fetch/NodeFetchResponse.java#L56.", "author": "seut", "createdAt": "2020-02-14T11:19:37Z", "path": "sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java", "diffHunk": "@@ -64,8 +68,22 @@ public TransportFetchOperation(TransportFetchNodeAction transportFetchNodeAction\n             nodeId,\n             nodeIdToReaderIdToStreamers.get(nodeId),\n             new NodeFetchRequest(jobId, fetchPhaseId, closeContext, toFetch),\n-            ramAccounting,\n+            ramAccountingForIncomingResponse(ramAccounting, toFetch, closeContext),", "originalCommit": "96169dbef760e8dc3ab699656f04e472f3aa4869", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java b/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java\nindex 17a4be6aed..84785ebdca 100644\n--- a/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java\n+++ b/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java\n\n@@ -68,22 +64,8 @@ public class TransportFetchOperation implements FetchOperation {\n             nodeId,\n             nodeIdToReaderIdToStreamers.get(nodeId),\n             new NodeFetchRequest(jobId, fetchPhaseId, closeContext, toFetch),\n-            ramAccountingForIncomingResponse(ramAccounting, toFetch, closeContext),\n+            ramAccounting,\n             listener);\n         return listener;\n     }\n-\n-    @VisibleForTesting\n-    static RamAccounting ramAccountingForIncomingResponse(RamAccounting ramAccounting,\n-                                                          IntObjectMap<? extends IntContainer> toFetch,\n-                                                          boolean closeContext) {\n-        if (toFetch.isEmpty() && closeContext) {\n-            // No data will arrive, so no ram accounting needed.\n-            // Indeed, with valid ram accounting, incoming accounted bytes may never be released because the release\n-            // logic may already happened (BatchAccumulator.close() calls do not block/wait for asynchronous responses)\n-            return RamAccounting.NO_ACCOUNTING;\n-        }\n-        // Each response may run in a different thread and thus should use its own ram accounting instance\n-        return new BlockBasedRamAccounting(ramAccounting::addBytes, MAX_BLOCK_SIZE_IN_BYTES);\n-    }\n }\n"}}, {"oid": "ba89f84b2651c5a4915e10610d9501a86d0b077c", "url": "https://github.com/crate/crate/commit/ba89f84b2651c5a4915e10610d9501a86d0b077c", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-02-14T11:25:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQzOTExOQ==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379439119", "bodyText": "The when in-time when sounds weird. Maybe re-phrase to by the time the teardown runs\nOr re-phrase completely to something like the following, omitting the second part completely.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // Due to asynchronous operations, Crate's completion future's may not be completed when in-time when\n          \n          \n            \n                            // RamAccouting-release operations can run asynchronous after clients already received results.", "author": "mfussenegger", "createdAt": "2020-02-14T13:50:42Z", "path": "es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java", "diffHunk": "@@ -2210,6 +2210,21 @@ public void ensureEstimatedStats() {\n                 } catch (Exception e) {\n                     throw new AssertionError(\"Exception during check for request breaker reset to 0\", e);\n                 }\n+\n+                // Due to asynchronous operations, Crate's completion future's may not be completed when in-time when", "originalCommit": "ba89f84b2651c5a4915e10610d9501a86d0b077c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "chunk": "diff --git a/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java b/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java\nindex 7b2c9e45dd..af01ba78b7 100644\n--- a/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java\n+++ b/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java\n\n@@ -2210,21 +2210,6 @@ public final class InternalTestCluster extends TestCluster {\n                 } catch (Exception e) {\n                     throw new AssertionError(\"Exception during check for request breaker reset to 0\", e);\n                 }\n-\n-                // Due to asynchronous operations, Crate's completion future's may not be completed when in-time when\n-                // this test tear down runs, the check will run inside an assertBusy loop.\n-                try {\n-                    assertBusy(() -> {\n-                        CircuitBreaker crateQueryBreaker = breakerService.getBreaker(\"query\");\n-                        if (crateQueryBreaker != null) {\n-                            assertThat(\"Query breaker not reset to 0 on node: \" + name,\n-                                       crateQueryBreaker.getUsed(),\n-                                       equalTo(0L));\n-                        }\n-                    });\n-                } catch (Exception e) {\n-                    throw new AssertionError(\"Exception during check for query breaker reset to 0\", e);\n-                }\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MTA2OQ==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379441069", "bodyText": "Do we need the ConcurrentRamAccounting here? I think the SingleBucketBuilder isn't used concurrently. (Yes, threads may change, but there is no concurrent use by multiple threads)", "author": "mfussenegger", "createdAt": "2020-02-14T13:54:46Z", "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "diffHunk": "@@ -278,9 +279,16 @@ private void registerContextPhases(Iterable<? extends NodeOperation> nodeOperati\n             }\n             if (ExecutionPhases.hasDirectResponseDownstream(nodeOperation.downstreamNodes())) {\n                 var executionPhase = nodeOperation.executionPhase();\n-                var ramAccounting = RamAccountingContext.forExecutionPhase(breaker(), executionPhase);\n+                CircuitBreaker breaker = breaker();\n+                int ramAccountingBlockSizeInBytes = BlockBasedRamAccounting.calculateBlockSizeInBytes(\n+                    breaker.getLimit(),\n+                    1\n+                );\n+                var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(executionPhase.label(), breaker);", "originalCommit": "ba89f84b2651c5a4915e10610d9501a86d0b077c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0NTgxMg==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379445812", "bodyText": "right, good catch", "author": "seut", "createdAt": "2020-02-14T14:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MTA2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\nindex 1a240ae2a7..2cc4597847 100644\n--- a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n+++ b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n\n@@ -284,11 +284,11 @@ public class JobSetup {\n                     breaker.getLimit(),\n                     1\n                 );\n-                var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(executionPhase.label(), breaker);\n+                var ramAccounting = new BlockBasedRamAccounting(\n+                    b -> breaker.addEstimateBytesAndMaybeBreak(b, executionPhase.label()),\n+                    ramAccountingBlockSizeInBytes);\n                 Streamer<?>[] streamers = StreamerVisitor.streamersFromOutputs(executionPhase);\n-                SingleBucketBuilder bucketBuilder = new SingleBucketBuilder(\n-                    streamers,\n-                    new BlockBasedRamAccounting(ramAccounting::addBytes, ramAccountingBlockSizeInBytes));\n+                SingleBucketBuilder bucketBuilder = new SingleBucketBuilder(streamers, ramAccounting);\n                 context.directResponseFutures.add(bucketBuilder.completionFuture().whenComplete((res, err) -> ramAccounting.close()));\n                 context.registerBatchConsumer(nodeOperation.downstreamExecutionPhaseId(), bucketBuilder);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MjQ2Mg==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379442462", "bodyText": "Do we need multiple MemoryManager instances here?\nI think if the ramAccounting instance is thread-safe, the MemoryManager instances inherit that thread-safety. So we could probably get away with using one.", "author": "mfussenegger", "createdAt": "2020-02-14T13:57:36Z", "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "diffHunk": "@@ -803,34 +847,33 @@ public Boolean visitFetchPhase(final FetchPhase phase, final Context context) {\n \n         @Override\n         public Boolean visitNestedLoopPhase(NestedLoopPhase phase, Context context) {\n-            MergePhase leftMerge = phase.leftMergePhase();\n-            MergePhase rightMerge = phase.rightMergePhase();\n-            RamAccountingContext ramAccountingLeft = leftMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), leftMerge);\n-            RamAccountingContext ramAccountingRight = rightMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), rightMerge);\n-\n-            RamAccountingContext ramAccountingContext = RamAccountingContext.forExecutionPhase(breaker(), phase);\n-            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingContext);\n-            MemoryManager memoryManager = memoryManagerFactory.getMemoryManager(ramAccountingContext);\n-\n+            CircuitBreaker breaker = breaker();\n+            int ramAccountingBlockSizeInBytes = BlockBasedRamAccounting.calculateBlockSizeInBytes(\n+                breaker.getLimit(),\n+                1\n+            );\n+            var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(phase.label(), breaker);\n+            var ramAccountingOfOperation = new BlockBasedRamAccounting(\n+                ramAccounting::addBytes,\n+                ramAccountingBlockSizeInBytes);\n+            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingOfOperation);\n+            var memoryManager = memoryManagerFactory.getMemoryManager(ramAccounting);\n+            var memoryManagerLeft = memoryManagerFactory.getMemoryManager(ramAccounting);", "originalCommit": "ba89f84b2651c5a4915e10610d9501a86d0b077c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\nindex 1a240ae2a7..2cc4597847 100644\n--- a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n+++ b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n\n@@ -858,13 +858,8 @@ public class JobSetup {\n                 ramAccountingBlockSizeInBytes);\n             RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingOfOperation);\n             var memoryManager = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagerLeft = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagerRight = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagers = List.of(memoryManager, memoryManagerLeft, memoryManagerRight);\n             lastConsumer.completionFuture().whenComplete((result, error) -> {\n-                for (MemoryManager memoryManagerToClose : memoryManagers) {\n-                    memoryManagerToClose.close();\n-                }\n+                memoryManager.close();\n                 ramAccounting.close();\n             });\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MTE5Nw==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379451197", "bodyText": "Same here regarding the MemoryManager instances. Sorry I had only pointed it out once as I wasn't sure if I'm missing something.", "author": "mfussenegger", "createdAt": "2020-02-14T14:14:38Z", "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "diffHunk": "@@ -886,33 +924,33 @@ public Boolean visitNestedLoopPhase(NestedLoopPhase phase, Context context) {\n \n         @Override\n         public Boolean visitHashJoinPhase(HashJoinPhase phase, Context context) {\n-            MergePhase leftMerge = phase.leftMergePhase();\n-            MergePhase rightMerge = phase.rightMergePhase();\n-            RamAccountingContext ramAccountingLeft = leftMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), leftMerge);\n-            RamAccountingContext ramAccountingRight = rightMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), rightMerge);\n-\n-            RamAccountingContext ramAccountingContext = RamAccountingContext.forExecutionPhase(breaker(), phase);\n-            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingContext);\n-            MemoryManager memoryManager = memoryManagerFactory.getMemoryManager(ramAccountingContext);\n+            CircuitBreaker breaker = breaker();\n+            int ramAccountingBlockSizeInBytes = BlockBasedRamAccounting.calculateBlockSizeInBytes(\n+                breaker.getLimit(),\n+                1\n+            );\n+            var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(phase.label(), breaker);\n+            var ramAccountingOfOperation = new BlockBasedRamAccounting(\n+                ramAccounting::addBytes,\n+                ramAccountingBlockSizeInBytes);\n+            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingOfOperation);\n+            var memoryManager = memoryManagerFactory.getMemoryManager(ramAccounting);\n+            var memoryManagerLeft = memoryManagerFactory.getMemoryManager(ramAccounting);", "originalCommit": "2564653f664b8caeda79b744602f3edfd7382ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyMTEzNA==", "url": "https://github.com/crate/crate/pull/9479#discussion_r380021134", "bodyText": "ah thanks!", "author": "seut", "createdAt": "2020-02-17T07:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MTE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "chunk": "diff --git a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\nindex afc79291cf..2cc4597847 100644\n--- a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n+++ b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n\n@@ -935,13 +935,8 @@ public class JobSetup {\n                 ramAccountingBlockSizeInBytes);\n             RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingOfOperation);\n             var memoryManager = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagerLeft = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagerRight = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagers = List.of(memoryManager, memoryManagerLeft, memoryManagerRight);\n             lastConsumer.completionFuture().whenComplete((result, error) -> {\n-                for (MemoryManager memoryManagerToClose : memoryManagers) {\n-                    memoryManagerToClose.close();\n-                }\n+                memoryManager.close();\n                 ramAccounting.close();\n             });\n \n"}}, {"oid": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "url": "https://github.com/crate/crate/commit/5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "message": "Remove `RamAccountingContext`, use new eagerly ram accounting instead.\n\nThe old `RamAccountingContext` uses a flush buffer to prevent flushing to\nthe circuit breaker on every accounted bytes. This leads to a possible\nunderaccounting.\nAdditionally the implementation isn't thread-safe but was used\nfrom multiple threads which also leads to wrong accounting.\n\nThis implementation is superseeded by new `RamAccounting` implementations\nwhich are either thread-safe (`ConcurrentRamAccounting`) or eagerly allocate\n(on-demand) a block of bytes (`BlockBasedRamAccounting`, this one must be\ncreated dedicated per thread).", "committedDate": "2020-02-17T09:19:32Z", "type": "commit"}, {"oid": "0570230ce0a2e8e6d76c2362452f62e23f9ca7d9", "url": "https://github.com/crate/crate/commit/0570230ce0a2e8e6d76c2362452f62e23f9ca7d9", "message": "Do not account ram for incoming close fetch context responses\n\nOn `FetchBatchAccumulator.close()` (which may called by a `kill`) calls,\na fetch requests is sent to close open fetch contexts without waiting\nfor the response by design.\nAs job related resources may already be released (in this case the ram\naccounting), the response should not result in additional accounted ram.\nAlso the response won\u2019t contain any rows and such ram accounting isn\u2019t\nneeded.", "committedDate": "2020-02-17T09:19:32Z", "type": "commit"}, {"oid": "64c205dfeb1fb70b7b661f15ad1d831cf51ab2dd", "url": "https://github.com/crate/crate/commit/64c205dfeb1fb70b7b661f15ad1d831cf51ab2dd", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-02-17T09:19:32Z", "type": "commit"}, {"oid": "64c205dfeb1fb70b7b661f15ad1d831cf51ab2dd", "url": "https://github.com/crate/crate/commit/64c205dfeb1fb70b7b661f15ad1d831cf51ab2dd", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-02-17T09:19:32Z", "type": "forcePushed"}]}