{"pr_number": 36, "pr_title": "Fix a leak where FileWatchers are added but never removed", "pr_createdAt": "2020-02-04T19:56:20Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36", "timeline": [{"oid": "4016df678c1d23a2c670ee07505d0c928e326463", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/4016df678c1d23a2c670ee07505d0c928e326463", "message": "Fix a leak where FileWatchers are added but never removed upon being expired from the cache, and some minor updates to privatize the cache by calling the public API in consumers\n\nPrior to this change, FileWatchers to track when a KNN index is deleted are added to the ResourceWatcherService but never\nremoved even after indexes have been deleted, which causes the set of watchers to grow unbounded over time. This change\nupdates the logic to clean up FileWatchers upon cache eviction.", "committedDate": "2020-02-04T19:53:46Z", "type": "commit"}, {"oid": "b6d7eb2ff49b10e1f91068b24435c590a39ad8a8", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/b6d7eb2ff49b10e1f91068b24435c590a39ad8a8", "message": "Fix javadoc to not declare @throws IOException", "committedDate": "2020-02-04T20:02:08Z", "type": "commit"}, {"oid": "99923b1ac56f75d02f36d8414601e95e93f0df20", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/99923b1ac56f75d02f36d8414601e95e93f0df20", "message": "Fix NPE on initialization", "committedDate": "2020-02-04T20:22:28Z", "type": "commit"}, {"oid": "fcec9c82b8b785d6483d96b6d31834a2ae3e292f", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/fcec9c82b8b785d6483d96b6d31834a2ae3e292f", "message": "Initialize ResourceWatcherService in integ test", "committedDate": "2020-02-04T20:47:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwNzQ1Ng==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374907456", "bodyText": "Minor: java doc for class", "author": "vamshin", "createdAt": "2020-02-04T20:33:55Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -175,18 +178,57 @@ public void setCacheCapacityReached(Boolean value) {\n      * Loads hnsw index to memory. Registers the location of the serialized graph with ResourceWatcher.\n      *\n      * @param indexPathUrl path for serialized hnsw graph\n-     * @param algoParams hnsw algoparams\n+     * @param algoParams hnsw algorithm parameters\n      * @return KNNIndex holding the heap pointer of the loaded graph\n      * @throws Exception Exception could occur when registering the index path\n      * to Resource watcher or if the JNI call throws\n      */\n-    public KNNIndex loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n+    public KNNIndexCacheEntry loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n         if(Strings.isNullOrEmpty(indexPathUrl))\n             throw new IllegalStateException(\"indexPath is null while performing load index\");\n         logger.debug(\"Loading index on cache miss .. {}\", indexPathUrl);\n         Path indexPath = Paths.get(indexPathUrl);\n-        knnIndexFileListener.register(indexPath);\n-        return KNNIndex.loadIndex(indexPathUrl, algoParams);\n+        FileWatcher fileWatcher = new FileWatcher(indexPath);\n+        fileWatcher.addListener(KNN_INDEX_FILE_DELETED_LISTENER);\n+\n+        // Calling init() on the FileWatcher will bootstrap initial state that indicates whether or not the file\n+        // is present. If it is not present at time of init(), then KNNIndex.loadIndex will fail and we won't cache\n+        // the entry\n+        fileWatcher.init();\n+\n+        final KNNIndex knnIndex = KNNIndex.loadIndex(indexPathUrl, algoParams);\n+\n+        // TODO verify that this is safe - ideally we'd explicitly ensure that the FileWatcher is only checked\n+        // after the guava cache has finished loading the key to avoid a race condition where the watcher\n+        // causes us to invalidate an entry before the key has been fully loaded.\n+        final WatcherHandle<FileWatcher> watcherHandle = resourceWatcherService.add(fileWatcher);\n+\n+        return new KNNIndexCacheEntry(knnIndex, watcherHandle);\n     }\n-}\n \n+    private static class KNNIndexCacheEntry {", "originalCommit": "b6d7eb2ff49b10e1f91068b24435c590a39ad8a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1NDk4Nw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374954987", "bodyText": "Will add", "author": "jschmitz28", "createdAt": "2020-02-04T22:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwNzQ1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "fcec9c82b8b785d6483d96b6d31834a2ae3e292f", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java b/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java\nindex 875efc3..b172db0 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java\n\n@@ -228,7 +228,7 @@ public class KNNIndexCache {\n         @Override\n         public void onFileDeleted(Path indexFilePath) {\n             logger.debug(\"[KNN] Invalidated because file {} is deleted\", indexFilePath.toString());\n-            INSTANCE.cache.invalidate(indexFilePath.toString());\n+            getInstance().cache.invalidate(indexFilePath.toString());\n         }\n     };\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwODMwMw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374908303", "bodyText": "Should we add try/finally block and move knnIndexCacheEntry.getFileWatcherHandle().stop(); to finally block to ensure the watcher is removed as file is deleted at this point?", "author": "vamshin", "createdAt": "2020-02-04T20:35:46Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -103,10 +106,12 @@ public synchronized void rebuild() {\n      *\n      * @param removalNotification key, value that got evicted.\n      */\n-    private void onRemoval(RemovalNotification<String, KNNIndex> removalNotification) {\n-        KNNIndex knnIndex = removalNotification.getValue();\n+    private void onRemoval(RemovalNotification<String, KNNIndexCacheEntry> removalNotification) {\n+        KNNIndexCacheEntry knnIndexCacheEntry = removalNotification.getValue();\n+\n+        knnIndexCacheEntry.getFileWatcherHandle().stop();", "originalCommit": "b6d7eb2ff49b10e1f91068b24435c590a39ad8a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1NTYyNw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374955627", "bodyText": "Can you clarify what would be wrapped in the try{}? knnIndexCacheEntry.getFileWatcherHandle().stop() should not throw - it just removes the watcher from the set, and doesn't declare any kind of exceptions.", "author": "jschmitz28", "createdAt": "2020-02-04T22:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwODMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1OTMyNA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374959324", "bodyText": "I was referring to ensuring knnIndexCacheEntry.getFileWatcherHandle().stop() being called when cache invalidate happens. some thing like this\ntry {\n        KNNIndexCacheEntry knnIndexCacheEntry = removalNotification.getValue();\n               executor.execute(() -> knnIndexCacheEntry.getKnnIndex().close());\n} finally {\n       knnIndexCacheEntry.getFileWatcherHandle().stop();\n}", "author": "vamshin", "createdAt": "2020-02-04T22:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwODMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3MDgzNA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374970834", "bodyText": "Is there a perceived difference in behavior here? Both should be called regardless - in the case of the PR, FileWatcher.stop is called first, and should doesn't have an expected failure mode, and then we submit a task to gc the index.", "author": "jschmitz28", "createdAt": "2020-02-04T22:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwODMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5NDkxNA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374994914", "bodyText": "Agree there is no failure mode at this point. Ideally we want to ensure both gc() and stop() always get called in this function. We can defer this until we use functions that throws.", "author": "vamshin", "createdAt": "2020-02-05T00:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwODMwMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNDM2MA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374914360", "bodyText": "I think we should first do  resourceWatcherService.add and then load the index.\n\nresourceWatcherService.add seems to already call init() on the filewatcher.  So no explicit call to init()\nthis will also address the case of  index not loaded if file is only present", "author": "vamshin", "createdAt": "2020-02-04T20:48:59Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -175,18 +178,57 @@ public void setCacheCapacityReached(Boolean value) {\n      * Loads hnsw index to memory. Registers the location of the serialized graph with ResourceWatcher.\n      *\n      * @param indexPathUrl path for serialized hnsw graph\n-     * @param algoParams hnsw algoparams\n+     * @param algoParams hnsw algorithm parameters\n      * @return KNNIndex holding the heap pointer of the loaded graph\n      * @throws Exception Exception could occur when registering the index path\n      * to Resource watcher or if the JNI call throws\n      */\n-    public KNNIndex loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n+    public KNNIndexCacheEntry loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n         if(Strings.isNullOrEmpty(indexPathUrl))\n             throw new IllegalStateException(\"indexPath is null while performing load index\");\n         logger.debug(\"Loading index on cache miss .. {}\", indexPathUrl);\n         Path indexPath = Paths.get(indexPathUrl);\n-        knnIndexFileListener.register(indexPath);\n-        return KNNIndex.loadIndex(indexPathUrl, algoParams);\n+        FileWatcher fileWatcher = new FileWatcher(indexPath);\n+        fileWatcher.addListener(KNN_INDEX_FILE_DELETED_LISTENER);\n+\n+        // Calling init() on the FileWatcher will bootstrap initial state that indicates whether or not the file\n+        // is present. If it is not present at time of init(), then KNNIndex.loadIndex will fail and we won't cache\n+        // the entry\n+        fileWatcher.init();\n+\n+        final KNNIndex knnIndex = KNNIndex.loadIndex(indexPathUrl, algoParams);", "originalCommit": "b6d7eb2ff49b10e1f91068b24435c590a39ad8a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2NzkyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374967921", "bodyText": "Can you clarify what you mean by the second case?\nFor the first case, the reason why I'm calling loadIndex in between FileWatcher.init and resourceWatcherService.add is because I'm still not totally confident about the guarantee of no search threads executing while the file is deleted.\nBy calling init() first, we know with certainty whether the file existed at the time we started loading the graph, and if it did not exist, we are guaranteed that loadIndex will fail. If we also start the monitor before loading the index, then in the case that we're wrong about the guarantee mentioned above, we're effectively creating a multi-second window (depending on index loading time) for which the watcher could notify about a file delete, and invalidate() would cause a no-op.", "author": "jschmitz28", "createdAt": "2020-02-04T22:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNDM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk4MjE0NA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374982144", "bodyText": "makes sense. Thanks", "author": "vamshin", "createdAt": "2020-02-04T23:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNDM2MA=="}], "type": "inlineReview", "revised_code": {"commit": "64173ce80f8bda50cbc339a11f03fff1c7890f67", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java b/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java\nindex 875efc3..2b80974 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java\n\n@@ -206,6 +206,11 @@ public class KNNIndexCache {\n         return new KNNIndexCacheEntry(knnIndex, watcherHandle);\n     }\n \n+    /**\n+     * KNNIndexCacheEntry is the value type for entries in the cache held by {@link KNNIndexCache}.\n+     * It holds a reference to both the KNNIndex and the WatcherHandle so that each can be cleaned up\n+     * upon expiration of the cache.\n+     */\n     private static class KNNIndexCacheEntry {\n         private final KNNIndex knnIndex;\n         private final WatcherHandle<FileWatcher> fileWatcherHandle;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNzg3OQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374917879", "bodyText": "I think guava cache takes the lock when loading the entry for the key. So when invalidate happens, it should happen after the graph is loaded?\nhttps://github.com/google/guava/blob/master/guava/src/com/google/common/cache/Cache.java#L91", "author": "vamshin", "createdAt": "2020-02-04T20:56:31Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -175,18 +178,57 @@ public void setCacheCapacityReached(Boolean value) {\n      * Loads hnsw index to memory. Registers the location of the serialized graph with ResourceWatcher.\n      *\n      * @param indexPathUrl path for serialized hnsw graph\n-     * @param algoParams hnsw algoparams\n+     * @param algoParams hnsw algorithm parameters\n      * @return KNNIndex holding the heap pointer of the loaded graph\n      * @throws Exception Exception could occur when registering the index path\n      * to Resource watcher or if the JNI call throws\n      */\n-    public KNNIndex loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n+    public KNNIndexCacheEntry loadIndex(String indexPathUrl, final String[] algoParams) throws Exception {\n         if(Strings.isNullOrEmpty(indexPathUrl))\n             throw new IllegalStateException(\"indexPath is null while performing load index\");\n         logger.debug(\"Loading index on cache miss .. {}\", indexPathUrl);\n         Path indexPath = Paths.get(indexPathUrl);\n-        knnIndexFileListener.register(indexPath);\n-        return KNNIndex.loadIndex(indexPathUrl, algoParams);\n+        FileWatcher fileWatcher = new FileWatcher(indexPath);\n+        fileWatcher.addListener(KNN_INDEX_FILE_DELETED_LISTENER);\n+\n+        // Calling init() on the FileWatcher will bootstrap initial state that indicates whether or not the file\n+        // is present. If it is not present at time of init(), then KNNIndex.loadIndex will fail and we won't cache\n+        // the entry\n+        fileWatcher.init();\n+\n+        final KNNIndex knnIndex = KNNIndex.loadIndex(indexPathUrl, algoParams);\n+\n+        // TODO verify that this is safe - ideally we'd explicitly ensure that the FileWatcher is only checked\n+        // after the guava cache has finished loading the key to avoid a race condition where the watcher\n+        // causes us to invalidate an entry before the key has been fully loaded.\n+        final WatcherHandle<FileWatcher> watcherHandle = resourceWatcherService.add(fileWatcher);", "originalCommit": "b6d7eb2ff49b10e1f91068b24435c590a39ad8a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1ODYwMQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374958601", "bodyText": "See the following gist. Guava invalidate(key) does not block but is instead a no-op when executed if guava hasn't fully loaded the key into the cache: https://gist.github.com/jschmitz28/c8ff2d3b5856f625cf1f5a98095b7a51", "author": "jschmitz28", "createdAt": "2020-02-04T22:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNzg3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk4Mjg1Mw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374982853", "bodyText": "Got it. You mean invalidating entry would not interrupt loading graph but no-op would make us miss gc() on the graph.  Agree this minimizes the risk of race condition assuming the index deletion happens during search.", "author": "vamshin", "createdAt": "2020-02-04T23:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNzg3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "64173ce80f8bda50cbc339a11f03fff1c7890f67", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java b/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java\nindex 875efc3..2b80974 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java\n\n@@ -206,6 +206,11 @@ public class KNNIndexCache {\n         return new KNNIndexCacheEntry(knnIndex, watcherHandle);\n     }\n \n+    /**\n+     * KNNIndexCacheEntry is the value type for entries in the cache held by {@link KNNIndexCache}.\n+     * It holds a reference to both the KNNIndex and the WatcherHandle so that each can be cleaned up\n+     * upon expiration of the cache.\n+     */\n     private static class KNNIndexCacheEntry {\n         private final KNNIndex knnIndex;\n         private final WatcherHandle<FileWatcher> fileWatcherHandle;\n"}}, {"oid": "64173ce80f8bda50cbc339a11f03fff1c7890f67", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/64173ce80f8bda50cbc339a11f03fff1c7890f67", "message": "Add javadoc, disable resource watcher service", "committedDate": "2020-02-04T23:52:30Z", "type": "commit"}, {"oid": "01abb18daa28cbf9a196314cacefa1febda7e516", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/01abb18daa28cbf9a196314cacefa1febda7e516", "message": "Remove unused import", "committedDate": "2020-02-04T23:56:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5NjAzMA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/36#discussion_r374996030", "bodyText": "Why not just do:\nreturn cache.get(key, () -> loadIndex(key, algoParams)).getKnnIndex();", "author": "jmazanec15", "createdAt": "2020-02-05T00:13:09Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/KNNIndexCache.java", "diffHunk": "@@ -121,15 +126,13 @@ private void onRemoval(RemovalNotification<String, KNNIndex> removalNotification\n      * Loads corresponding index for the given key to memory and returns the index object.\n      *\n      * @param key indexPath where the serialized hnsw graph is stored\n-     * @param algoParams hnsw algoparams\n-     * @return KNNIndex holding the heap pointer of the loaded graph or empty if there was\n-     * a failure to load the\n-     * @throws RuntimeException if there's an unexpected failure in loading, which implies that the value for\n-     * the key will be both out of the cache and the underlying index will not be loaded\n+     * @param algoParams hnsw algorithm parameters\n+     * @return KNNIndex holding the heap pointer of the loaded graph\n      */\n     public KNNIndex getIndex(String key, final String[] algoParams) {\n         try {\n-            return cache.get(key, () -> loadIndex(key, algoParams));\n+            final KNNIndexCacheEntry knnIndexCacheEntry = cache.get(key, () -> loadIndex(key, algoParams));", "originalCommit": "01abb18daa28cbf9a196314cacefa1febda7e516", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}