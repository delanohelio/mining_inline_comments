{"pr_number": 1413, "pr_title": "Upgrading to new Key Vault (and MSAL) libraries", "pr_createdAt": "2020-08-25T21:43:24Z", "pr_url": "https://github.com/microsoft/mssql-jdbc/pull/1413", "timeline": [{"oid": "9fbc98936839a5b38ab504a69887c75be90c501b", "url": "https://github.com/microsoft/mssql-jdbc/commit/9fbc98936839a5b38ab504a69887c75be90c501b", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-10-10T01:30:25Z", "type": "commit"}, {"oid": "a011ea785fa37b356746671fa1d06ae99f5274f4", "url": "https://github.com/microsoft/mssql-jdbc/commit/a011ea785fa37b356746671fa1d06ae99f5274f4", "message": "Merge pull request #9 from lilgreenbird/msal\n\nadd tenantID to pipeline and merged with dev", "committedDate": "2020-10-10T02:06:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE3Mjc4Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r504172782", "bodyText": "Please search for ADAL in SQLServerResource and make similar changes to the error messages that mentioned ADAL.", "author": "ulvii", "createdAt": "2020-10-13T18:32:05Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -404,7 +404,7 @@ static String getResource(String key) {\n                     \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n             {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n                     \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_ADALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},", "originalCommit": "a011ea785fa37b356746671fa1d06ae99f5274f4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "d8f20da4cfd2156c8ca08d54b6eaa8718493e85e", "url": "https://github.com/microsoft/mssql-jdbc/commit/d8f20da4cfd2156c8ca08d54b6eaa8718493e85e", "message": "updated error msgs", "committedDate": "2020-10-13T19:11:35Z", "type": "commit"}, {"oid": "c6d444cae4b34e9b56c6870c0c4bcc731bbae4ba", "url": "https://github.com/microsoft/mssql-jdbc/commit/c6d444cae4b34e9b56c6870c0c4bcc731bbae4ba", "message": "update version", "committedDate": "2020-10-13T19:16:56Z", "type": "commit"}, {"oid": "f7aeb12a67a165f6f09448bc958c0d22f4d617cc", "url": "https://github.com/microsoft/mssql-jdbc/commit/f7aeb12a67a165f6f09448bc958c0d22f4d617cc", "message": "Update README.md\n\nupdated for MSAL", "committedDate": "2020-10-13T21:20:46Z", "type": "commit"}, {"oid": "61ee2d4c1131ec15530a10105f4cbd8c759bc2d9", "url": "https://github.com/microsoft/mssql-jdbc/commit/61ee2d4c1131ec15530a10105f4cbd8c759bc2d9", "message": "Merge pull request #10 from lilgreenbird/msal\n\nFixed error msgs", "committedDate": "2020-10-13T22:26:21Z", "type": "commit"}, {"oid": "53d44087620cbda9bcce55aad1d2cb810c9d50f7", "url": "https://github.com/microsoft/mssql-jdbc/commit/53d44087620cbda9bcce55aad1d2cb810c9d50f7", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-28T00:38:19Z", "type": "commit"}, {"oid": "5bc675535eb3db983b094164a2b898855e6b57a7", "url": "https://github.com/microsoft/mssql-jdbc/commit/5bc675535eb3db983b094164a2b898855e6b57a7", "message": "Merge pull request #1 from lilgreenbird/msal\n\nformatting and merged with latest dev", "committedDate": "2020-08-28T00:49:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5Mjg5OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481492899", "bodyText": "@lilgreenbird\nThis is not how we handle exception messages. Error messages need to be localized and also make sure to throw SQLServerException. Please make sure to change this in all occurrences.", "author": "ulvii", "createdAt": "2020-09-01T23:47:01Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MzM4OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481493389", "bodyText": ". at the end.", "author": "ulvii", "createdAt": "2020-09-01T23:48:36Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MjM3OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481492378", "bodyText": "We'll need to doc this. Since it's been deprecated for prior major version bumps, do we need to bump the major version for this change? I'm leaning towards yes.", "author": "David-Engel", "createdAt": "2020-09-01T23:45:19Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -84,76 +90,38 @@ public String getName() {\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Key of the client requesting the token.\n+     *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n-     *         when an error occurs\n+     *         If either {@code clientId} or {@code clientKey} are {@code null}.\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n\n@@ -98,7 +98,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * @param clientKey\n      *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n-     *         If either {@code clientId} or {@code clientKey} are {@code null}.\n+     *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n         if (null == clientId || clientId.isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MzkyNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481493924", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package com.microsoft.sqlserver.jdbc;\n          \n          \n            \n            /*\n          \n          \n            \n             * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n          \n          \n            \n             * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n          \n          \n            \n             */\n          \n          \n            \n            \n          \n          \n            \n            package com.microsoft.sqlserver.jdbc;", "author": "David-Engel", "createdAt": "2020-09-01T23:50:26Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.microsoft.sqlserver.jdbc;", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nindex 91d54f94..b36ccba2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n\n@@ -1,3 +1,7 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n package com.microsoft.sqlserver.jdbc;\n \n import com.azure.core.credential.AccessToken;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5OTgxMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481499810", "bodyText": "This is not how exception are handled in the driver, @lilgreenbird please make sure to follow the guidelines.", "author": "ulvii", "createdAt": "2020-09-02T00:10:48Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential() {}\n-\n-    KeyVaultCredential(String clientId, String clientKey) {\n-        this.clientId = clientId;\n-        this.clientKey = clientKey;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    public KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwMzc4Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481503786", "bodyText": "Please pay attention  to public APIs. We don't want to create public APIs unless it is by design.", "author": "ulvii", "createdAt": "2020-09-02T00:24:10Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential() {}\n-\n-    KeyVaultCredential(String clientId, String clientKey) {\n-        this.clientId = clientId;\n-        this.clientKey = clientKey;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxODQ3Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481518473", "bodyText": "Driver should not throw a NullPointerException . Better add a null check to the constructor and throw SQLServerException .", "author": "ulvii", "createdAt": "2020-09-02T01:03:29Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -134,10 +126,10 @@ public void testBadAkv(String serverName, String url, String protocol) throws Ex\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n+                    (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        } catch (NullPointerException exception) {", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 73b11a85..55cad5f1 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n\n@@ -116,20 +132,38 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n     }\n \n     /*\n-     * Test bad Azure Key Vault\n+     * Test bad Azure Key Vault using SQLServerKeyVaultAuthenticationCallback\n      */\n     @SuppressWarnings(\"unused\")\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n-    public void testBadAkv(String serverName, String url, String protocol) throws Exception {\n+    public void testBadAkvCallback(String serverName, String url, String protocol) throws Exception {\n+        setAEConnectionString(serverName, url, protocol);\n+\n+        try {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n+            fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        }\n+    }\n+\n+    /*\n+     * Test bad Azure Key Vault using TokenCredential\n+     */\n+    @SuppressWarnings(\"unused\")\n+    @ParameterizedTest\n+    @MethodSource(\"enclaveParams\")\n+    public void testBadAkvTokenCredential(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n                     (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (NullPointerException exception) {\n-            assertNull(exception.getMessage());\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxODY2Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481518667", "bodyText": "Need to add license header here.", "author": "ulvii", "createdAt": "2020-09-02T01:04:14Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.microsoft.sqlserver.jdbc;", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nindex 91d54f94..b36ccba2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n\n@@ -1,3 +1,7 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n package com.microsoft.sqlserver.jdbc;\n \n import com.azure.core.credential.AccessToken;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyNzQ1MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481527451", "bodyText": "CamelCase here", "author": "ulvii", "createdAt": "2020-09-02T01:28:25Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -198,7 +182,7 @@ public SQLServerColumnEncryptionAzureKeyVaultProvider(\n         }\n \n         // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n\n@@ -182,7 +237,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMTYxNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481531617", "bodyText": "The methods in this class should probably not be public.", "author": "ulvii", "createdAt": "2020-09-02T01:34:53Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.ClientLogger;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\n+final class KeyVaultHttpPipelineBuilder {", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1NDQ4MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r482254481", "bodyText": "I will change the visibility of these methods to package-private.", "author": "srnagar", "createdAt": "2020-09-02T17:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMTYxNw=="}], "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nindex ca5c3d44..51ff4eeb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n\n@@ -12,46 +12,41 @@ import com.azure.core.http.policy.HttpLoggingPolicy;\n import com.azure.core.http.policy.HttpPipelinePolicy;\n import com.azure.core.http.policy.HttpPolicyProviders;\n import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.http.policy.UserAgentPolicy;\n-import com.azure.core.util.Configuration;\n-import com.azure.core.util.logging.ClientLogger;\n+\n+import java.text.MessageFormat;\n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Objects;\n-\n \n+/**\n+ * The HTTP pipeline builder which includes all the necessary HTTP pipeline policies that will be applied for\n+ * sending and receiving HTTP requests to the Key Vault service.\n+ */\n final class KeyVaultHttpPipelineBuilder {\n-    public static final String APPLICATION_ID = \"ms-sql-jdbc\";\n-    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n-    private static final String SDK_VERSION = \"4.2.0\";\n-\n-    private final ClientLogger logger = new ClientLogger(KeyVaultHttpPipelineBuilder.class);\n \n     private final List<HttpPipelinePolicy> policies;\n-    private KeyVaultCredential credential;\n+    private KeyVaultTokenCredential credential;\n     private HttpLogOptions httpLogOptions;\n     private final RetryPolicy retryPolicy;\n \n     /**\n-     * The constructor with defaults.\n+     * The constructor with default retry policy and log options.\n      */\n-    public KeyVaultHttpPipelineBuilder() {\n+    KeyVaultHttpPipelineBuilder() {\n         retryPolicy = new RetryPolicy();\n         httpLogOptions = new HttpLogOptions();\n         policies = new ArrayList<>();\n     }\n \n-    public HttpPipeline buildPipeline() {\n-        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n-\n-        if (null == credential) {\n-            throw logger.logExceptionAsError(new IllegalStateException(\"Token Credential should be specified.\"));\n-        }\n-\n+    /**\n+     * Builds the HTTP pipeline with all the necessary HTTP policies included in the pipeline.\n+     *\n+     * @return A fully built HTTP pipeline including the default HTTP client.\n+     * @throws SQLServerException If the {@link KeyVaultCustomCredentialPolicy} policy cannot be added to the pipeline.\n+     */\n+    HttpPipeline buildPipeline() throws SQLServerException {\n         // Closest to API goes first, closest to wire goes last.\n         final List<HttpPipelinePolicy> policies = new ArrayList<>();\n \n-        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n         HttpPolicyProviders.addBeforeRetryPolicies(policies);\n         policies.add(retryPolicy);\n         policies.add(new KeyVaultCustomCredentialPolicy(credential));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMjAzNQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481532035", "bodyText": "The methods in this class should probably not be public.", "author": "ulvii", "createdAt": "2020-09-02T01:35:34Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex 86edbf87..c9f85e23 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n\n@@ -11,10 +11,11 @@ import com.azure.core.http.HttpPipelineNextPolicy;\n import com.azure.core.http.HttpResponse;\n import com.azure.core.http.policy.HttpPipelinePolicy;\n import com.azure.core.util.CoreUtils;\n+\n+import java.text.MessageFormat;\n import java.util.HashMap;\n import java.util.Locale;\n import java.util.Map;\n-import java.util.Objects;\n import reactor.core.publisher.Mono;\n \n \n"}}, {"oid": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "url": "https://github.com/microsoft/mssql-jdbc/commit/3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "message": "Update src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n\nCo-authored-by: David Engel <dengel1012@gmail.com>", "committedDate": "2020-09-02T05:25:49Z", "type": "commit"}, {"oid": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "url": "https://github.com/microsoft/mssql-jdbc/commit/d9bad87bda75441fad79010fb31e90c7de8b6a5d", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-02T05:47:37Z", "type": "commit"}, {"oid": "d24dbff950d63d622a54555fca81d7a0e50451ea", "url": "https://github.com/microsoft/mssql-jdbc/commit/d24dbff950d63d622a54555fca81d7a0e50451ea", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-02T05:48:23Z", "type": "commit"}, {"oid": "59aebe6a2f663c70638530cba96e898ee0b3d03f", "url": "https://github.com/microsoft/mssql-jdbc/commit/59aebe6a2f663c70638530cba96e898ee0b3d03f", "message": "exception handling and removed unnecessary public apis", "committedDate": "2020-09-02T18:30:20Z", "type": "commit"}, {"oid": "6b2f1a2c2490d7cfb090ed889e0d9bf2f1329508", "url": "https://github.com/microsoft/mssql-jdbc/commit/6b2f1a2c2490d7cfb090ed889e0d9bf2f1329508", "message": "added header", "committedDate": "2020-09-02T18:38:56Z", "type": "commit"}, {"oid": "2e6180f8ae90791f662a2da9d6f0f2a5112c5ec3", "url": "https://github.com/microsoft/mssql-jdbc/commit/2e6180f8ae90791f662a2da9d6f0f2a5112c5ec3", "message": "merged", "committedDate": "2020-09-02T18:42:01Z", "type": "commit"}, {"oid": "c7cd5984f0e7d02a52d2bcaba154ddf32acaabe7", "url": "https://github.com/microsoft/mssql-jdbc/commit/c7cd5984f0e7d02a52d2bcaba154ddf32acaabe7", "message": "Merge pull request #2 from lilgreenbird/msal\n\nUpdates", "committedDate": "2020-09-02T18:47:26Z", "type": "commit"}, {"oid": "4ef6a37eb23996361d8d0c0200ce1bbed71052c7", "url": "https://github.com/microsoft/mssql-jdbc/commit/4ef6a37eb23996361d8d0c0200ce1bbed71052c7", "message": "more updates", "committedDate": "2020-09-02T22:27:44Z", "type": "commit"}, {"oid": "a0644beb6235fa466ac8998d8dd21284b92e239e", "url": "https://github.com/microsoft/mssql-jdbc/commit/a0644beb6235fa466ac8998d8dd21284b92e239e", "message": "update", "committedDate": "2020-09-02T22:36:37Z", "type": "commit"}, {"oid": "042ade5a8b3c75658b4d72fa04566f682781601a", "url": "https://github.com/microsoft/mssql-jdbc/commit/042ade5a8b3c75658b4d72fa04566f682781601a", "message": "Merge pull request #3 from lilgreenbird/msal\n\nmore updates", "committedDate": "2020-09-02T22:47:54Z", "type": "commit"}, {"oid": "abdf38daab8061c05458362a62496e79fb5e3dae", "url": "https://github.com/microsoft/mssql-jdbc/commit/abdf38daab8061c05458362a62496e79fb5e3dae", "message": "merged", "committedDate": "2020-09-04T06:16:43Z", "type": "commit"}, {"oid": "573dfb93fcd1c7e12c19c760d7160377f5dc04a3", "url": "https://github.com/microsoft/mssql-jdbc/commit/573dfb93fcd1c7e12c19c760d7160377f5dc04a3", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-04T06:16:57Z", "type": "commit"}, {"oid": "48fbe2c381292e7358d074e6efb098de837d26f8", "url": "https://github.com/microsoft/mssql-jdbc/commit/48fbe2c381292e7358d074e6efb098de837d26f8", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-05T02:08:55Z", "type": "commit"}, {"oid": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "url": "https://github.com/microsoft/mssql-jdbc/commit/a2e50b9b66d9207415d6853fa449fc55e968a44a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-09T19:00:26Z", "type": "commit"}, {"oid": "7ff97dee94ec4144ef22e5d12ba76f1a84ebe3c9", "url": "https://github.com/microsoft/mssql-jdbc/commit/7ff97dee94ec4144ef22e5d12ba76f1a84ebe3c9", "message": "enable ADintegrated tests for non-windows", "committedDate": "2020-09-09T23:20:13Z", "type": "commit"}, {"oid": "887d9b14be71883977d8d2dc0bde233b59ec7759", "url": "https://github.com/microsoft/mssql-jdbc/commit/887d9b14be71883977d8d2dc0bde233b59ec7759", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-10T00:32:20Z", "type": "commit"}, {"oid": "4a8b4f389937aed352098be48709a04ed50a9519", "url": "https://github.com/microsoft/mssql-jdbc/commit/4a8b4f389937aed352098be48709a04ed50a9519", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-10T23:32:02Z", "type": "commit"}, {"oid": "7cae3b431dc533e07042f1bbc810995f78b64510", "url": "https://github.com/microsoft/mssql-jdbc/commit/7cae3b431dc533e07042f1bbc810995f78b64510", "message": "fixed user test for kerberos", "committedDate": "2020-09-11T05:34:42Z", "type": "commit"}, {"oid": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "url": "https://github.com/microsoft/mssql-jdbc/commit/c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "message": "Update to latest version of KV and Identity", "committedDate": "2020-09-16T20:05:04Z", "type": "commit"}, {"oid": "d0186a9dec2411976db528bb90ece338a5f61a9a", "url": "https://github.com/microsoft/mssql-jdbc/commit/d0186a9dec2411976db528bb90ece338a5f61a9a", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-16T22:11:51Z", "type": "commit"}, {"oid": "4c9b6277174d8bb12de84b310a4296a6577075c1", "url": "https://github.com/microsoft/mssql-jdbc/commit/4c9b6277174d8bb12de84b310a4296a6577075c1", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-16T22:18:03Z", "type": "commit"}, {"oid": "e863c056cb2d36309c757e25bcf1bdc708bb9b26", "url": "https://github.com/microsoft/mssql-jdbc/commit/e863c056cb2d36309c757e25bcf1bdc708bb9b26", "message": "user name check", "committedDate": "2020-09-16T22:33:25Z", "type": "commit"}, {"oid": "43060f9fb25d71ab6724d2aa12712745d899c562", "url": "https://github.com/microsoft/mssql-jdbc/commit/43060f9fb25d71ab6724d2aa12712745d899c562", "message": "Bring back deprecated constructors", "committedDate": "2020-09-16T22:33:29Z", "type": "commit"}, {"oid": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "url": "https://github.com/microsoft/mssql-jdbc/commit/c8c5a2977c700d62815ab8073ea11a8d40885deb", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-16T22:34:15Z", "type": "commit"}, {"oid": "1550a9771ba87a07d1e767e63e3afe9133be6759", "url": "https://github.com/microsoft/mssql-jdbc/commit/1550a9771ba87a07d1e767e63e3afe9133be6759", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-16T22:35:05Z", "type": "commit"}, {"oid": "f4825dbdfdfb4ea3d1a64df845527e6532076196", "url": "https://github.com/microsoft/mssql-jdbc/commit/f4825dbdfdfb4ea3d1a64df845527e6532076196", "message": "Resolve merge conflicts", "committedDate": "2020-09-16T22:39:20Z", "type": "commit"}, {"oid": "b85e3c20207d7119b4e8e1e671de905c3e3589db", "url": "https://github.com/microsoft/mssql-jdbc/commit/b85e3c20207d7119b4e8e1e671de905c3e3589db", "message": "merged", "committedDate": "2020-09-17T21:37:24Z", "type": "commit"}, {"oid": "7d4274f06582ee91a43eff1e6b276a93f785f688", "url": "https://github.com/microsoft/mssql-jdbc/commit/7d4274f06582ee91a43eff1e6b276a93f785f688", "message": "Add auth callback tests", "committedDate": "2020-09-18T20:49:14Z", "type": "commit"}, {"oid": "2a92d4dc6b373d166fe85200586b33730a5e71ab", "url": "https://github.com/microsoft/mssql-jdbc/commit/2a92d4dc6b373d166fe85200586b33730a5e71ab", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-19T00:48:44Z", "type": "commit"}, {"oid": "61b787f737ddf8c9d1fd0342be7c1d8826c42fe0", "url": "https://github.com/microsoft/mssql-jdbc/commit/61b787f737ddf8c9d1fd0342be7c1d8826c42fe0", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-22T04:13:14Z", "type": "commit"}, {"oid": "360a8d4bb6f6e680e3ee0043f32d738b806cf22e", "url": "https://github.com/microsoft/mssql-jdbc/commit/360a8d4bb6f6e680e3ee0043f32d738b806cf22e", "message": "lib conflict", "committedDate": "2020-09-22T05:04:17Z", "type": "commit"}, {"oid": "d76368aedf39c5dbc573f7449e91524b1227daf7", "url": "https://github.com/microsoft/mssql-jdbc/commit/d76368aedf39c5dbc573f7449e91524b1227daf7", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-22T05:08:08Z", "type": "commit"}, {"oid": "e5aafd300061bee1968463cf7ad1d07d6da8356d", "url": "https://github.com/microsoft/mssql-jdbc/commit/e5aafd300061bee1968463cf7ad1d07d6da8356d", "message": "Merge branch 'dev' of https://github.com/lilgreenbird/mssql-jdbc into dev", "committedDate": "2020-09-22T05:08:27Z", "type": "commit"}, {"oid": "1108103183860d69b772d9902c434d59c5f239af", "url": "https://github.com/microsoft/mssql-jdbc/commit/1108103183860d69b772d9902c434d59c5f239af", "message": "merged", "committedDate": "2020-09-22T05:15:41Z", "type": "commit"}, {"oid": "950677fd4de54a43fd5b085da4b71e371058dbf5", "url": "https://github.com/microsoft/mssql-jdbc/commit/950677fd4de54a43fd5b085da4b71e371058dbf5", "message": "merged", "committedDate": "2020-09-22T05:19:56Z", "type": "commit"}, {"oid": "12f2da986ea6412b19d6d6e14eb27de7af224966", "url": "https://github.com/microsoft/mssql-jdbc/commit/12f2da986ea6412b19d6d6e14eb27de7af224966", "message": "back to prev lib version", "committedDate": "2020-09-22T06:49:51Z", "type": "commit"}, {"oid": "2b3ccd6930333ac63f25320c5a3a0ea0c243b07d", "url": "https://github.com/microsoft/mssql-jdbc/commit/2b3ccd6930333ac63f25320c5a3a0ea0c243b07d", "message": "fix", "committedDate": "2020-09-23T05:33:46Z", "type": "commit"}, {"oid": "497f1bead6faa74a53460e4182727ab22a772489", "url": "https://github.com/microsoft/mssql-jdbc/commit/497f1bead6faa74a53460e4182727ab22a772489", "message": "merged", "committedDate": "2020-09-23T05:36:57Z", "type": "commit"}, {"oid": "972f95c65fcfd3bc9a99064ccb22ce2f7e2147e9", "url": "https://github.com/microsoft/mssql-jdbc/commit/972f95c65fcfd3bc9a99064ccb22ce2f7e2147e9", "message": "Merge branch 'msal' of https://github.com/lilgreenbird/mssql-jdbc into msal", "committedDate": "2020-09-23T05:37:44Z", "type": "commit"}, {"oid": "216d77aa795dfd7b1ea89d9626ad0c94341c5f91", "url": "https://github.com/microsoft/mssql-jdbc/commit/216d77aa795dfd7b1ea89d9626ad0c94341c5f91", "message": "fixed", "committedDate": "2020-09-23T05:51:29Z", "type": "commit"}, {"oid": "791e2b6b473f6cac5a9ecde7359527c78921d3f0", "url": "https://github.com/microsoft/mssql-jdbc/commit/791e2b6b473f6cac5a9ecde7359527c78921d3f0", "message": "update", "committedDate": "2020-09-23T06:02:38Z", "type": "commit"}, {"oid": "a7119131d567639e5a97a35f20ffe8759745d89d", "url": "https://github.com/microsoft/mssql-jdbc/commit/a7119131d567639e5a97a35f20ffe8759745d89d", "message": "merged", "committedDate": "2020-09-23T06:04:34Z", "type": "commit"}, {"oid": "122e408633ef0aca67e2a1358ce19c4caead5904", "url": "https://github.com/microsoft/mssql-jdbc/commit/122e408633ef0aca67e2a1358ce19c4caead5904", "message": "Merge pull request #4 from lilgreenbird/msal\n\nMsal", "committedDate": "2020-09-23T06:10:11Z", "type": "commit"}, {"oid": "b4799ca4f4028d82b0791e9f89e81103e9191c7d", "url": "https://github.com/microsoft/mssql-jdbc/commit/b4799ca4f4028d82b0791e9f89e81103e9191c7d", "message": "Remove hardcoded version and package name", "committedDate": "2020-09-24T19:27:53Z", "type": "commit"}, {"oid": "c722d34e80fc7d8c9954ebb9a859bb2e90e11107", "url": "https://github.com/microsoft/mssql-jdbc/commit/c722d34e80fc7d8c9954ebb9a859bb2e90e11107", "message": "clean and exclude lib", "committedDate": "2020-09-25T18:03:41Z", "type": "commit"}, {"oid": "9c28d9844c1e30f210f1b685859396653a5d7363", "url": "https://github.com/microsoft/mssql-jdbc/commit/9c28d9844c1e30f210f1b685859396653a5d7363", "message": "Add code comments and javadoc", "committedDate": "2020-09-29T08:05:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODI2MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499748260", "bodyText": "Can the url be HTTP? Also please add a . to the end of the error message.", "author": "ulvii", "createdAt": "2020-10-05T17:09:36Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -648,5 +648,6 @@ static String getResource(String key) {\n             {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n-                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},};\n+                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme\"},};", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NDkyNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499754924", "bodyText": "I figured HTTP is not supported, so the question can be ignored.", "author": "ulvii", "createdAt": "2020-10-05T17:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2MDkzMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r501860931", "bodyText": "@lilgreenbird  please add . to the end of the error message.", "author": "ulvii", "createdAt": "2020-10-08T16:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex b83772f3..8045d1f8 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n\n@@ -649,5 +649,5 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n                     \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme\"},};\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n };\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5NDIyNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499794226", "bodyText": "If only HTTPS supported lets change this to  if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {", "author": "ulvii", "createdAt": "2020-10-05T18:35:05Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.CoreUtils;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * A policy that authenticates requests with Azure Key Vault service.\n+ */\n+class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n+    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n+    private static final String AUTHORIZATION = \"Authorization\";\n+    private final ScopeTokenCache cache;\n+    private final KeyVaultTokenCredential keyVaultTokenCredential;\n+\n+    /**\n+     * Creates KeyVaultCustomCredentialPolicy.\n+     *\n+     * @param credential\n+     *        the token credential to authenticate the request\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCustomCredentialPolicy(KeyVaultTokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.cache = new ScopeTokenCache(credential::getToken);\n+        this.keyVaultTokenCredential = credential;\n+    }\n+\n+    /**\n+     * Adds the required header to authenticate a request to Azure Key Vault service.\n+     *\n+     * @param context\n+     *        The request context\n+     * @param next\n+     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n+     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n+     */\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex a51340d1..c9f85e23 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n\n@@ -18,6 +18,7 @@ import java.util.Locale;\n import java.util.Map;\n import reactor.core.publisher.Mono;\n \n+\n /**\n  * A policy that authenticates requests with Azure Key Vault service.\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMDg2NA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499800864", "bodyText": "Please change this to multi-line comment.", "author": "ulvii", "createdAt": "2020-10-05T18:47:42Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+    private String resource;\n+    private String scope;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultTokenCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.authenticationCallback = null;\n+    }\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param authenticationCallback The authentication callback that gets invoked when an access token is requested.\n+     */\n+    KeyVaultTokenCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+        this.clientId = null;\n+        this.clientSecret = null;\n+    }\n+\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        if (null != authenticationCallback) {\n+            // If the callback is not null, invoke the callback to get the token. This gets invoked each time", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNDg1OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499904859", "bodyText": "Not resolved.", "author": "ulvii", "createdAt": "2020-10-05T22:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMDg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUwNTI4MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r500505280", "bodyText": "sorry you're right, this change isn't merged to this PR yet..", "author": "lilgreenbird", "createdAt": "2020-10-06T18:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMDg2NA=="}], "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n\n@@ -9,7 +9,6 @@ import com.azure.core.annotation.Immutable;\n import com.azure.core.credential.AccessToken;\n import com.azure.core.credential.TokenCredential;\n import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n import com.microsoft.aad.msal4j.ClientCredentialFactory;\n import com.microsoft.aad.msal4j.ClientCredentialParameters;\n import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwNjUxMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499806511", "bodyText": "For consistency, please change this to use the driver's logger.  You can take a look at KerbAuthentication.java for reference usage.", "author": "ulvii", "createdAt": "2020-10-05T18:58:11Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n\n@@ -9,7 +9,6 @@ import com.azure.core.annotation.Immutable;\n import com.azure.core.credential.AccessToken;\n import com.azure.core.credential.TokenCredential;\n import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n import com.microsoft.aad.msal4j.ClientCredentialFactory;\n import com.microsoft.aad.msal4j.ClientCredentialParameters;\n import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MDg4OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499850889", "bodyText": "Could you explain why we log a warning here instead of an exception?", "author": "ulvii", "createdAt": "2020-10-05T20:23:56Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+    private String resource;\n+    private String scope;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultTokenCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.authenticationCallback = null;\n+    }\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param authenticationCallback The authentication callback that gets invoked when an access token is requested.\n+     */\n+    KeyVaultTokenCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+        this.clientId = null;\n+        this.clientSecret = null;\n+    }\n+\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        if (null != authenticationCallback) {\n+            // If the callback is not null, invoke the callback to get the token. This gets invoked each time\n+            // this method is called and will not cache the token. It's the callback's responsibility to return a valid\n+            // token each time it's invoked.\n+            String accessToken = authenticationCallback.getAccessToken(this.authorization, this.resource, this.scope);\n+            return Mono.just(new AccessToken(accessToken, OffsetDateTime.MIN));\n+        }\n+\n+        // gets the token from MSAL\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n+    }\n+\n+    /**\n+     * Sets the authority that will be used for authentication.\n+     *\n+     * @param authorization The name of the authorization.\n+     * @return The updated {@link KeyVaultTokenCredential} instance.\n+     */\n+    KeyVaultTokenCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n+    }\n+\n+    /**\n+     * Creates an instance of {@link ConfidentialClientApplication} using the provided client id and secret.\n+     *\n+     * @return An instance of {@link ConfidentialClientApplication}.\n+     */\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == authorization) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Authorization\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == clientSecret) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        // Create the credential using the MSAL factory method.\n+        IClientCredential credential;\n+        credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    /**\n+     * Attempts to get the access token from the client cache if it's not expired. If it's expired this returns an\n+     * empty response.\n+     * @param request The context for requesting the token including the scope.\n+     * @return The cached access token if it's not expired.\n+     */\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMDczOA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499900738", "bodyText": "it doesn't it's actually throwing a RuntimeException and doesn't need to be logged as that's a fatal error", "author": "lilgreenbird", "createdAt": "2020-10-05T22:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MDg4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n\n@@ -9,7 +9,6 @@ import com.azure.core.annotation.Immutable;\n import com.azure.core.credential.AccessToken;\n import com.azure.core.credential.TokenCredential;\n import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n import com.microsoft.aad.msal4j.ClientCredentialFactory;\n import com.microsoft.aad.msal4j.ClientCredentialParameters;\n import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MzMxMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499853313", "bodyText": "These variables shouldn't be public.", "author": "ulvii", "createdAt": "2020-10-05T20:28:23Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -51,29 +56,35 @@\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    public static final int KEY_NAME_INDEX = 4;", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n\n@@ -56,9 +55,9 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-    public static final int KEY_NAME_INDEX = 4;\n-    public static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n-    public static final String KEY_URL_DELIMITER = \"/\";\n+    private static final int KEY_NAME_INDEX = 4;\n+    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n+    private static final String KEY_URL_DELIMITER = \"/\";\n     private HttpPipeline keyVaultPipeline;\n     private KeyVaultTokenCredential keyVaultTokenCredential;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1NzE2MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499857161", "bodyText": "Please revert the changes to this file.", "author": "ulvii", "createdAt": "2020-10-05T20:35:55Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java", "diffHunk": "@@ -1,26 +1,26 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-/**\n- * Provides a callback delegate which is to be implemented by the client code\n- * \n- */\n-public interface SQLServerKeyVaultAuthenticationCallback {\n-\n-    /**\n-     * Returns the acesss token of the authentication request\n-     * \n-     * @param authority\n-     *        - Identifier of the authority, a URL.\n-     * @param resource\n-     *        - Identifier of the target resource that is the recipient of the requested token, a URL.\n-     * @param scope\n-     *        - The scope of the authentication request.\n-     * @return access token\n-     */\n-    String getAccessToken(String authority, String resource, String scope);\n-}\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+/**\r\n+ * Provides a callback delegate which is to be implemented by the client code\r\n+ *\r\n+ */\r\n+public interface SQLServerKeyVaultAuthenticationCallback {\r\n+\r\n+        /**\r", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\nindex 21199c58..4a954388 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\n\n@@ -11,16 +11,16 @@ package com.microsoft.sqlserver.jdbc;\n  */\n public interface SQLServerKeyVaultAuthenticationCallback {\n \n-        /**\n-         * Returns the acesss token of the authentication request\n-         *\n-         * @param authority\n-         *        - Identifier of the authority, a URL.\n-         * @param resource\n-         *        - Identifier of the target resource that is the recipient of the requested token, a URL.\n-         * @param scope\n-         *        - The scope of the authentication request.\n-         * @return access token\n-         */\n-        String getAccessToken(String authority, String resource, String scope);\n+    /**\n+     * Returns the acesss token of the authentication request\n+     *\n+     * @param authority\n+     *        - Identifier of the authority, a URL.\n+     * @param resource\n+     *        - Identifier of the target resource that is the recipient of the requested token, a URL.\n+     * @param scope\n+     *        - The scope of the authentication request.\n+     * @return access token\n+     */\n+    String getAccessToken(String authority, String resource, String scope);\n }\n"}}, {"oid": "338f48051d001bf324b2a90de757c3572a6883c7", "url": "https://github.com/microsoft/mssql-jdbc/commit/338f48051d001bf324b2a90de757c3572a6883c7", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-10-05T20:58:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3OTMyOA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499879328", "bodyText": "No need to deprecate this constructor anymore, because authenticationCallback works with MSAL now.", "author": "ulvii", "createdAt": "2020-10-05T21:21:03Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -124,56 +198,43 @@ public SQLServerColumnEncryptionAzureKeyVaultProvider(\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n      * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n+     *\n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n+    @Deprecated", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n\n@@ -173,38 +168,18 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         setCredential(tokenCredential);\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     *\n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n-    }\n-\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      *\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3ODE2NQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499878165", "bodyText": "Do we need to deprecate this public interface? If so, why?\nI do recall the previous discussion about removing it because we thought we couldn't support it via MSAL. But since we can support it, is there a compelling reason to push applications to the new interface?", "author": "David-Engel", "createdAt": "2020-10-05T21:18:36Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -124,56 +198,43 @@ public SQLServerColumnEncryptionAzureKeyVaultProvider(\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n      * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n+     *\n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n+    @Deprecated", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMTEyNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499901124", "bodyText": "no it doesn't anymore, I've removed that", "author": "lilgreenbird", "createdAt": "2020-10-05T22:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3ODE2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n\n@@ -173,38 +168,18 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         setCredential(tokenCredential);\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     *\n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n-    }\n-\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      *\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n"}}, {"oid": "9010b5fc89ddc188b425e303a0f99f6429203852", "url": "https://github.com/microsoft/mssql-jdbc/commit/9010b5fc89ddc188b425e303a0f99f6429203852", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-10-05T22:00:52Z", "type": "commit"}, {"oid": "da75dccca5d12df3b5d558af7fc3b0e501b9aec0", "url": "https://github.com/microsoft/mssql-jdbc/commit/da75dccca5d12df3b5d558af7fc3b0e501b9aec0", "message": "updates", "committedDate": "2020-10-05T22:04:41Z", "type": "commit"}, {"oid": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "url": "https://github.com/microsoft/mssql-jdbc/commit/0d509af9f2c34faf3eb5636654af974d1e5528f5", "message": "Merge pull request #5 from lilgreenbird/msal\n\ncleanup and exclude lib", "committedDate": "2020-10-05T22:08:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMDgxMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499900810", "bodyText": "This test should not be removed, it is the only test thats actually using SQLServerColumnEncryptionAzureKeyVaultProvider(authenticationCallback).", "author": "ulvii", "createdAt": "2020-10-05T22:12:09Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java", "diffHunk": "@@ -128,7 +121,7 @@ public void testFedAuthWithAE_AKV() throws SQLException {\n             dropCMK(stmt, cmkName3);\r\n             setupCMK_AKVOld(cmkName3, stmt);\r\n \r\n-            createCEK(cmkName3, setupKeyStoreProvider_AKVOld(), stmt, keyIDs[0]);\r", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\nindex 573500cd..4193c9a6 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n\n@@ -121,7 +128,7 @@ public class FedauthWithAE extends FedauthCommon {\n             dropCMK(stmt, cmkName3);\n             setupCMK_AKVOld(cmkName3, stmt);\n \n-            createCEK(cmkName3, setupKeyStoreProvider_AKVNew(), stmt, keyIDs[0]);\n+            createCEK(cmkName3, setupKeyStoreProvider_AKVOld(), stmt, keyIDs[0]);\n             createCharTable(stmt, charTableOld);\n \n             populateCharNormalCase(charValues, connection, charTableOld);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjcwMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499906703", "bodyText": "What is the actual exception type here? is it being thrown as SQLServerException?", "author": "ulvii", "createdAt": "2020-10-05T22:28:53Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -299,7 +300,9 @@ public void testNumericAkvWithBadCred() throws SQLException {\n             testNumericAKV(connStr);\r\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\r\n         } catch (Exception e) {\r\n-            assert (e.getMessage().contains(\"AuthenticationException\"));\r\n+            assertTrue(e.getCause() instanceof MsalServiceException);\r", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex b4c28a17..7688b098 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n\n@@ -300,7 +300,6 @@ public class MSITest extends AESetup {\n             testNumericAKV(connStr);\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\n         } catch (Exception e) {\n-            assertTrue(e.getCause() instanceof MsalServiceException);\n             // https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-aadsts-error-codes\n             assertTrue(e.getMessage().contains(\"AADSTS700016\"));\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxNjE5Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499916192", "bodyText": "Please do not remove this test, it is still valid.", "author": "ulvii", "createdAt": "2020-10-05T22:57:58Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -91,18 +92,15 @@ public void testJksName(String serverName, String url, String protocol) throws E\n      */\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n+    @Tag(Constants.reqExternalSetup)\n     public void testAkvName(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n-        try {", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU3ODgzMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r502578833", "bodyText": "this is not removed, it's been renamed to testAkvNameWithAuthCallback", "author": "lilgreenbird", "createdAt": "2020-10-09T17:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxNjE5Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxNzI1MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499917251", "bodyText": "There is no tests for this constructor, please add a few tests. I could only find one test, which only tests bad AKV name.", "author": "ulvii", "createdAt": "2020-10-05T23:01:13Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -84,96 +95,126 @@ public String getName() {\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Key of the client requesting the token.\n+     *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        // create a token credential with given client id and secret which internally identifies the tenant id.\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n+        // create the pipeline with the custom Key Vault credential\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n      * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        setCredential(new ManagedIdentityCredentialBuilder().build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            Object[] msgArgs1 = {\"Client ID\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n+        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex aae4be84..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n\n@@ -199,8 +194,11 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n \n     /**\n      * Sets the credential that will be used for authenticating requests to Key Vault service.\n-     * @param credential A credential of type {@link TokenCredential}.\n-     * @throws SQLServerException If the credential is null.\n+     * \n+     * @param credential\n+     *        A credential of type {@link TokenCredential}.\n+     * @throws SQLServerException\n+     *         If the credential is null.\n      */\n     private void setCredential(TokenCredential credential) throws SQLServerException {\n         if (null == credential) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyNzMwNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499927306", "bodyText": "This is very interesting syntax but can we either link a source for a spec detailing why we want these specific fields or add some comments to explain. The string field names should also be changed to constants incase it changes in the future.", "author": "rene-ye", "createdAt": "2020-10-05T23:34:19Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.CoreUtils;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * A policy that authenticates requests with Azure Key Vault service.\n+ */\n+class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n+    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n+    private static final String AUTHORIZATION = \"Authorization\";\n+    private final ScopeTokenCache cache;\n+    private final KeyVaultTokenCredential keyVaultTokenCredential;\n+\n+    /**\n+     * Creates KeyVaultCustomCredentialPolicy.\n+     *\n+     * @param credential\n+     *        the token credential to authenticate the request\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCustomCredentialPolicy(KeyVaultTokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.cache = new ScopeTokenCache(credential::getToken);\n+        this.keyVaultTokenCredential = credential;\n+    }\n+\n+    /**\n+     * Adds the required header to authenticate a request to Azure Key Vault service.\n+     *\n+     * @param context\n+     *        The request context\n+     * @param next\n+     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n+     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n+     */\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n+        }\n+\n+        return next.clone().process()\n+                // Ignore body\n+                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n+                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n+                    keyVaultTokenCredential.setAuthorization(map.get(\"authorization\"));\n+                    keyVaultTokenCredential.setResource(map.get(\"resource\"));\n+                    keyVaultTokenCredential.setScope(map.get(\"scope\"));\n+                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n+                    return cache.getToken();\n+                }).flatMap(token -> {\n+                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n+                    return next.process();\n+                });", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex a51340d1..c9f85e23 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n\n@@ -18,6 +18,7 @@ import java.util.Locale;\n import java.util.Map;\n import reactor.core.publisher.Mono;\n \n+\n /**\n  * A policy that authenticates requests with Azure Key Vault service.\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyODA4OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499928088", "bodyText": "None of these new tests seem to actually test authenticationCallback .As far as I understand, driver applications will be able to implement  SQLServerKeyVaultAuthenticationCallback.getAccessToken() API in 2 ways:\n\nUsing adal4j library, see the sample here.\nUsing msal4j library, as implemented below.\nRegardless of which method the application chooses to use, the driver needs to be able to handle both. Please add appropriate tests for both scenarios. Make sure to use actual CEKs/CMK to encrypt/decrypt instead of using empty CEK.", "author": "ulvii", "createdAt": "2020-10-05T23:37:11Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -2244,22 +2234,69 @@ void testNumerics(SQLServerStatement stmt, String cekName, String[][] table, Str\n         }\n     }\n \n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = new SQLServerKeyVaultAuthenticationCallback() {\n-        // @Override\n-        ExecutorService service = Executors.newFixedThreadPool(2);\n+    @ParameterizedTest", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex c073fee2..55cad5f1 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n\n@@ -2251,6 +2279,46 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n         }\n     }\n \n+    @ParameterizedTest\n+    @MethodSource(\"enclaveParams\")\n+    @Tag(Constants.reqExternalSetup)\n+    public void testAkvNameWithTokenCredential(String serverName, String url, String protocol) throws Exception {\n+        setAEConnectionString(serverName, url, protocol);\n+\n+        ClientSecretCredential credential = new ClientSecretCredentialBuilder().tenantId(tenantID)\n+                .clientId(applicationClientID).clientSecret(applicationKey).build();\n+\n+        try {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    credential);\n+            String keystoreName = \"keystoreName\";\n+            akv.setName(keystoreName);\n+            assertTrue(akv.getName().equals(keystoreName));\n+        } catch (SQLServerException e) {\n+            fail(TestResource.getResource(\"R_unexpectedException\") + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This tests callback implemented using ADAL lib\n+     */\n+    @ParameterizedTest\n+    @MethodSource(\"enclaveParams\")\n+    @Tag(Constants.reqExternalSetup)\n+    public void testAkvNameWithAuthCallback_ADAL(String serverName, String url, String protocol) throws Exception {\n+        setAEConnectionString(serverName, url, protocol);\n+\n+        try {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    authenticationCallback_ADAL);\n+            String keystoreName = \"keystoreName\";\n+            akv.setName(keystoreName);\n+            assertTrue(akv.getName().equals(keystoreName));\n+        } catch (SQLServerException e) {\n+            fail(TestResource.getResource(\"R_unexpectedException\") + e.getMessage());\n+        }\n+    }\n+\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n     @Tag(Constants.reqExternalSetup)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyODY5Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499928693", "bodyText": "Again, we are not removing the SQLServerKeyVaultAuthenticationCallback anymore, so keep this test as it is and add a test for TokenCredential separately.", "author": "ulvii", "createdAt": "2020-10-05T23:39:38Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -134,7 +132,7 @@ public void testBadAkv(String serverName, String url, String protocol) throws Ex\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n+                    (TokenCredential) null);", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex c073fee2..55cad5f1 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n\n@@ -122,12 +132,30 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n     }\n \n     /*\n-     * Test bad Azure Key Vault\n+     * Test bad Azure Key Vault using SQLServerKeyVaultAuthenticationCallback\n      */\n     @SuppressWarnings(\"unused\")\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n-    public void testBadAkv(String serverName, String url, String protocol) throws Exception {\n+    public void testBadAkvCallback(String serverName, String url, String protocol) throws Exception {\n+        setAEConnectionString(serverName, url, protocol);\n+\n+        try {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n+            fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        }\n+    }\n+\n+    /*\n+     * Test bad Azure Key Vault using TokenCredential\n+     */\n+    @SuppressWarnings(\"unused\")\n+    @ParameterizedTest\n+    @MethodSource(\"enclaveParams\")\n+    public void testBadAkvTokenCredential(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n         try {\n"}}, {"oid": "33c276a47484a0dad04d71dd96f6325bba705847", "url": "https://github.com/microsoft/mssql-jdbc/commit/33c276a47484a0dad04d71dd96f6325bba705847", "message": "formatting and reive updates", "committedDate": "2020-10-06T00:01:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5ODA0Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499998046", "bodyText": "Shouldn't the comment here and below for the constructors say \"Creates a KeyVaultTokenCredential\" instead of \"Creates  a KeyVaultCredential\"?", "author": "peterbae", "createdAt": "2020-10-06T04:24:05Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final String clientId;\n+    private final String clientSecret;\n+    private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+    private String resource;\n+    private String scope;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 0593bb83..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n\n@@ -38,7 +38,7 @@ class KeyVaultTokenCredential implements TokenCredential {\n     private String scope;\n \n     /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n+     * Creates a KeyVaultTokenCredential with the given identity client options.\n      *\n      * @param clientId\n      *        the client ID of the application\n"}}, {"oid": "ad27b884cabfdd2b530b0b4a06b7f3dc5fc2d8dd", "url": "https://github.com/microsoft/mssql-jdbc/commit/ad27b884cabfdd2b530b0b4a06b7f3dc5fc2d8dd", "message": "Rebase from remote branch", "committedDate": "2020-10-06T08:16:04Z", "type": "commit"}, {"oid": "089933342f5ea3e3c478f5b0152adbb91a456984", "url": "https://github.com/microsoft/mssql-jdbc/commit/089933342f5ea3e3c478f5b0152adbb91a456984", "message": "Update tests", "committedDate": "2020-10-06T08:17:41Z", "type": "commit"}, {"oid": "a4a99ec4da0e02a8413dfef87a91b0ee98b04b36", "url": "https://github.com/microsoft/mssql-jdbc/commit/a4a99ec4da0e02a8413dfef87a91b0ee98b04b36", "message": "Rebase from remote branch", "committedDate": "2020-10-06T08:18:10Z", "type": "commit"}, {"oid": "ca36f3469bdb927f1f01075b91e9a24e6a55f09d", "url": "https://github.com/microsoft/mssql-jdbc/commit/ca36f3469bdb927f1f01075b91e9a24e6a55f09d", "message": "Update pom.xml", "committedDate": "2020-10-06T08:21:38Z", "type": "commit"}, {"oid": "2bf012bdab01468aec967f17b8ae9bef86958deb", "url": "https://github.com/microsoft/mssql-jdbc/commit/2bf012bdab01468aec967f17b8ae9bef86958deb", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-10-06T21:34:36Z", "type": "commit"}, {"oid": "9e38cc336d505b58956d9674881763d5b9b70937", "url": "https://github.com/microsoft/mssql-jdbc/commit/9e38cc336d505b58956d9674881763d5b9b70937", "message": "Merge pull request #6 from lilgreenbird/msal\n\nMsal", "committedDate": "2020-10-06T21:49:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYyODYxMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r500628613", "bodyText": "Can just declare private static final List<String> akvTrustedEndpoints = getTrustedEndpoints(); since getTrustedEndpoints is static.", "author": "rene-ye", "createdAt": "2020-10-06T22:20:31Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -51,29 +55,35 @@\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    private static final int KEY_NAME_INDEX = 4;\n+    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n+    private static final String KEY_URL_DELIMITER = \"/\";\n+    private HttpPipeline keyVaultPipeline;\n+    private KeyVaultTokenCredential keyVaultTokenCredential;\n+\n     /**\n      * Column Encryption Key Store Provider string\n      */\n     String name = \"AZURE_KEY_VAULT\";\n \n-    private final String baseUrl = \"https://{vaultBaseUrl}\";\n-\n     private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n     private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n     private static final List<String> akvTrustedEndpoints;\n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n-    private final String rsaEncryptionAlgorithmWithOAEPForAKV = \"RSA-OAEP\";\n \n     /**\n      * Algorithm version\n      */\n     private final byte[] firstVersion = new byte[] {0x01};\n \n-    private KeyVaultClient keyVaultClient;\n+    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+    private TokenCredential credential;\n \n-    private KeyVaultCredential credentials;\n+    static {\n+        akvTrustedEndpoints = getTrustedEndpoints();\n+    }", "originalCommit": "9e38cc336d505b58956d9674881763d5b9b70937", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 79383446..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n\n@@ -70,7 +70,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n     private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n \n-    private static final List<String> akvTrustedEndpoints;\n+    private static final List<String> akvTrustedEndpoints = getTrustedEndpoints();\n \n     /**\n      * Algorithm version\n"}}, {"oid": "7a035c6333044677e99dbc96114959c49e10e954", "url": "https://github.com/microsoft/mssql-jdbc/commit/7a035c6333044677e99dbc96114959c49e10e954", "message": "review updates", "committedDate": "2020-10-08T23:36:11Z", "type": "commit"}, {"oid": "a6308974dfe7b2d7106292f069c697a83b5ad5de", "url": "https://github.com/microsoft/mssql-jdbc/commit/a6308974dfe7b2d7106292f069c697a83b5ad5de", "message": "catch exception", "committedDate": "2020-10-09T00:26:28Z", "type": "commit"}, {"oid": "48cacfad6362e53ec29bd3132187989c7bcadb15", "url": "https://github.com/microsoft/mssql-jdbc/commit/48cacfad6362e53ec29bd3132187989c7bcadb15", "message": "Merge pull request #7 from lilgreenbird/msal\n\nAdded tests and catch exception from getKeyClient", "committedDate": "2020-10-09T17:30:18Z", "type": "commit"}, {"oid": "793207e04ec7d1f9990044a64c3e6eabab8240f4", "url": "https://github.com/microsoft/mssql-jdbc/commit/793207e04ec7d1f9990044a64c3e6eabab8240f4", "message": "added test for token credential", "committedDate": "2020-10-09T22:26:32Z", "type": "commit"}, {"oid": "1a22d786577af55749e218ac694a61b1944500c8", "url": "https://github.com/microsoft/mssql-jdbc/commit/1a22d786577af55749e218ac694a61b1944500c8", "message": "Merge pull request #8 from lilgreenbird/msal\n\nadded test for token credential and other cosmetic fixes", "committedDate": "2020-10-09T22:39:52Z", "type": "commit"}, {"oid": "8f483e2a14477e6410cd7380f2372c6a0bb28cea", "url": "https://github.com/microsoft/mssql-jdbc/commit/8f483e2a14477e6410cd7380f2372c6a0bb28cea", "message": "added tenantID property", "committedDate": "2020-10-10T00:25:07Z", "type": "commit"}, {"oid": "c97b863c95385bdcd1afc897ef39cbebaf495578", "url": "https://github.com/microsoft/mssql-jdbc/commit/c97b863c95385bdcd1afc897ef39cbebaf495578", "message": "Fix AEv2 tests exclude for reqExternalSetup and cleanup (#1247)", "committedDate": "2020-02-05T19:03:48Z", "type": "commit"}, {"oid": "54b5a194e5d46552419c86e0d1f8c800f42d3de8", "url": "https://github.com/microsoft/mssql-jdbc/commit/54b5a194e5d46552419c86e0d1f8c800f42d3de8", "message": "Fix | Add null check for getObject() with LocalTime and LocalDate (#1250)", "committedDate": "2020-02-08T00:19:05Z", "type": "commit"}, {"oid": "672b7d67caae75250c53f82a760e8d3880e62a37", "url": "https://github.com/microsoft/mssql-jdbc/commit/672b7d67caae75250c53f82a760e8d3880e62a37", "message": "added all AKV tests to use reqExternalSetup tag so they will be skipped by default (#1254)\n\n* skip AKV test properly\r\n\r\n* removed enclave properties string to failed errors as enclave tests could be skipped", "committedDate": "2020-02-10T19:04:22Z", "type": "commit"}, {"oid": "3c3331b7b0ff1b27b1e80271bf9ffdc6aae7be79", "url": "https://github.com/microsoft/mssql-jdbc/commit/3c3331b7b0ff1b27b1e80271bf9ffdc6aae7be79", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-25T06:21:47Z", "type": "commit"}, {"oid": "e2c5640370daa89c0d8c1559b5791e99656f78c8", "url": "https://github.com/microsoft/mssql-jdbc/commit/e2c5640370daa89c0d8c1559b5791e99656f78c8", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-26T06:10:08Z", "type": "commit"}, {"oid": "aad696640378b75f3cb8cb24cc2fa299358db9ac", "url": "https://github.com/microsoft/mssql-jdbc/commit/aad696640378b75f3cb8cb24cc2fa299358db9ac", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-28T03:18:02Z", "type": "commit"}, {"oid": "92bf04c2787c3b2a704f641f50cb4a83193f1d6d", "url": "https://github.com/microsoft/mssql-jdbc/commit/92bf04c2787c3b2a704f641f50cb4a83193f1d6d", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-31T01:58:20Z", "type": "commit"}, {"oid": "3ba5ab72008501e23f43dbcbcc333775320ddafa", "url": "https://github.com/microsoft/mssql-jdbc/commit/3ba5ab72008501e23f43dbcbcc333775320ddafa", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-04T05:47:37Z", "type": "commit"}, {"oid": "d20823deffea162b2b17b079cc291f91269558aa", "url": "https://github.com/microsoft/mssql-jdbc/commit/d20823deffea162b2b17b079cc291f91269558aa", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-07T00:45:05Z", "type": "commit"}, {"oid": "4cc959f7e76eedbf49e30e5b92de43c86d7eb803", "url": "https://github.com/microsoft/mssql-jdbc/commit/4cc959f7e76eedbf49e30e5b92de43c86d7eb803", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-29T02:59:23Z", "type": "commit"}, {"oid": "7b301f8184b26da4d99b2feab8b2aea886c01cea", "url": "https://github.com/microsoft/mssql-jdbc/commit/7b301f8184b26da4d99b2feab8b2aea886c01cea", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-30T06:36:21Z", "type": "commit"}, {"oid": "56bcf139fe6acd87c41b3829b4f157c59bd9f873", "url": "https://github.com/microsoft/mssql-jdbc/commit/56bcf139fe6acd87c41b3829b4f157c59bd9f873", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-07T22:26:03Z", "type": "commit"}, {"oid": "744e0ca78e57bc6c0db98910a9066d5b583c6ba8", "url": "https://github.com/microsoft/mssql-jdbc/commit/744e0ca78e57bc6c0db98910a9066d5b583c6ba8", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-12T22:47:18Z", "type": "commit"}, {"oid": "df8fd41ffa6005b18b0e328593faaeb495ce6547", "url": "https://github.com/microsoft/mssql-jdbc/commit/df8fd41ffa6005b18b0e328593faaeb495ce6547", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-19T01:06:51Z", "type": "commit"}, {"oid": "652e68b110828db6b172c1b02df6a06ab04c2b59", "url": "https://github.com/microsoft/mssql-jdbc/commit/652e68b110828db6b172c1b02df6a06ab04c2b59", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-26T07:07:35Z", "type": "commit"}, {"oid": "53736db944298004a4a383be14ae83370ffab717", "url": "https://github.com/microsoft/mssql-jdbc/commit/53736db944298004a4a383be14ae83370ffab717", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-26T23:02:59Z", "type": "commit"}, {"oid": "9ba6a42285fcc046a0a68e110454b62d8f7f6657", "url": "https://github.com/microsoft/mssql-jdbc/commit/9ba6a42285fcc046a0a68e110454b62d8f7f6657", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-02T06:50:57Z", "type": "commit"}, {"oid": "6d156f728a1253dd469da1c6896189762b00097b", "url": "https://github.com/microsoft/mssql-jdbc/commit/6d156f728a1253dd469da1c6896189762b00097b", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-05T19:15:40Z", "type": "commit"}, {"oid": "e08ffe5f54050344920bc48d44dc8e04cd143866", "url": "https://github.com/microsoft/mssql-jdbc/commit/e08ffe5f54050344920bc48d44dc8e04cd143866", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-10T21:34:05Z", "type": "commit"}, {"oid": "6b6cab266b655c48858187f56071aa3e4ba87054", "url": "https://github.com/microsoft/mssql-jdbc/commit/6b6cab266b655c48858187f56071aa3e4ba87054", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-18T19:14:21Z", "type": "commit"}, {"oid": "f4555d66335e5ea3b053b9af303383cbfd50ef42", "url": "https://github.com/microsoft/mssql-jdbc/commit/f4555d66335e5ea3b053b9af303383cbfd50ef42", "message": "First pass at porting to new Key Vault", "committedDate": "2020-06-24T04:57:40Z", "type": "commit"}, {"oid": "c2025901e1c9e8b279f42279da2f25ffd6c4232a", "url": "https://github.com/microsoft/mssql-jdbc/commit/c2025901e1c9e8b279f42279da2f25ffd6c4232a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-24T18:58:46Z", "type": "commit"}, {"oid": "0515d4b0d51c3150b2149438f8b8a69be3dfc2bd", "url": "https://github.com/microsoft/mssql-jdbc/commit/0515d4b0d51c3150b2149438f8b8a69be3dfc2bd", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-24T20:34:25Z", "type": "commit"}, {"oid": "892eb2be48d9d9706004c96ca43e9400eaea1197", "url": "https://github.com/microsoft/mssql-jdbc/commit/892eb2be48d9d9706004c96ca43e9400eaea1197", "message": "Everything now compiles, but I'm sure there are numerous bugs, and testing has not been run yet.", "committedDate": "2020-06-25T01:42:07Z", "type": "commit"}, {"oid": "088d2f73cdd507404c2fe6398f78647c3b84a31c", "url": "https://github.com/microsoft/mssql-jdbc/commit/088d2f73cdd507404c2fe6398f78647c3b84a31c", "message": "Beginning to re-enable some disabled unit tests", "committedDate": "2020-06-25T02:39:22Z", "type": "commit"}, {"oid": "30e7fdf4c6b4a185132ca36d661e29371727e13f", "url": "https://github.com/microsoft/mssql-jdbc/commit/30e7fdf4c6b4a185132ca36d661e29371727e13f", "message": "Add requirement for a tenant ID to be set to run tests", "committedDate": "2020-06-25T03:48:10Z", "type": "commit"}, {"oid": "2c63b5828becf3f737f4edf95593d98ada4e273a", "url": "https://github.com/microsoft/mssql-jdbc/commit/2c63b5828becf3f737f4edf95593d98ada4e273a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-25T06:36:46Z", "type": "commit"}, {"oid": "2d62262aa453ecf96807f5f52b6f9a1bd908e4ca", "url": "https://github.com/microsoft/mssql-jdbc/commit/2d62262aa453ecf96807f5f52b6f9a1bd908e4ca", "message": "Minor tidy ups", "committedDate": "2020-06-30T02:04:24Z", "type": "commit"}, {"oid": "a6b75cdaf634a3899fd5586d0418df181d9e9cef", "url": "https://github.com/microsoft/mssql-jdbc/commit/a6b75cdaf634a3899fd5586d0418df181d9e9cef", "message": "Upgrade gradle file to include equivalent dependencies as in pom.xml, and remove try / catch in some test code where it is not required.", "committedDate": "2020-06-30T02:18:19Z", "type": "commit"}, {"oid": "78aa941fab02af4aef190c7da6141b1251a84b4b", "url": "https://github.com/microsoft/mssql-jdbc/commit/78aa941fab02af4aef190c7da6141b1251a84b4b", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-02T18:43:21Z", "type": "commit"}, {"oid": "90e99cd54a0cb4347f813d965ea38b0a9801e8b0", "url": "https://github.com/microsoft/mssql-jdbc/commit/90e99cd54a0cb4347f813d965ea38b0a9801e8b0", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-02T20:57:03Z", "type": "commit"}, {"oid": "5e373227bfc1deec11a6d8d5c820afabb00d38aa", "url": "https://github.com/microsoft/mssql-jdbc/commit/5e373227bfc1deec11a6d8d5c820afabb00d38aa", "message": "add -DtenantID=$(tenantID)", "committedDate": "2020-07-03T20:28:32Z", "type": "commit"}, {"oid": "1df8828c03c162c6685f095f211fa8c8e51fccfc", "url": "https://github.com/microsoft/mssql-jdbc/commit/1df8828c03c162c6685f095f211fa8c8e51fccfc", "message": "Merge pull request #1 from peterbae/keyvault-upgrade\n\nAdd tenantID", "committedDate": "2020-07-05T20:44:52Z", "type": "commit"}, {"oid": "da1004bb9862d31941e537e77bd0e2ded5edef96", "url": "https://github.com/microsoft/mssql-jdbc/commit/da1004bb9862d31941e537e77bd0e2ded5edef96", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-06T22:39:35Z", "type": "commit"}, {"oid": "8c9a94473deee94dd40f928a710d2b2b279b45e3", "url": "https://github.com/microsoft/mssql-jdbc/commit/8c9a94473deee94dd40f928a710d2b2b279b45e3", "message": "Updating APIs to propagate tenantId. Still I am sure the tests will fail, but this is a step in the right direction.", "committedDate": "2020-07-06T23:25:56Z", "type": "commit"}, {"oid": "f7f12d9d6bb5a868e6bf4d127a34be75353727f7", "url": "https://github.com/microsoft/mssql-jdbc/commit/f7f12d9d6bb5a868e6bf4d127a34be75353727f7", "message": "Merge branch 'keyvault-upgrade' of github.com:JonathanGiles/mssql-jdbc into keyvault-upgrade", "committedDate": "2020-07-06T23:26:24Z", "type": "commit"}, {"oid": "cc0ac7f33655ab1e105c12cd6da9abe06a6830bc", "url": "https://github.com/microsoft/mssql-jdbc/commit/cc0ac7f33655ab1e105c12cd6da9abe06a6830bc", "message": "Updating method call to add missing tenantId", "committedDate": "2020-07-06T23:31:09Z", "type": "commit"}, {"oid": "86fc00cbd8813fc9b2888a2dd078291753ffcf7c", "url": "https://github.com/microsoft/mssql-jdbc/commit/86fc00cbd8813fc9b2888a2dd078291753ffcf7c", "message": "Wiring in vaultBaseUrl env var lookup for Key Vault", "committedDate": "2020-07-06T23:50:31Z", "type": "commit"}, {"oid": "8fec202dca9cf413dfdadca1f99a89cd6d454fb3", "url": "https://github.com/microsoft/mssql-jdbc/commit/8fec202dca9cf413dfdadca1f99a89cd6d454fb3", "message": "Debugging key path format (hopefully)", "committedDate": "2020-07-07T00:01:29Z", "type": "commit"}, {"oid": "9f44f0f45a6daa99b2a121bfc62a59491e867821", "url": "https://github.com/microsoft/mssql-jdbc/commit/9f44f0f45a6daa99b2a121bfc62a59491e867821", "message": "Clean up algorithm code", "committedDate": "2020-07-07T00:10:22Z", "type": "commit"}, {"oid": "dab428f8ed0c1fce1dc3dc2158c1c233f701bb2e", "url": "https://github.com/microsoft/mssql-jdbc/commit/dab428f8ed0c1fce1dc3dc2158c1c233f701bb2e", "message": "Adding validation for vaultBaseURL", "committedDate": "2020-07-07T00:22:10Z", "type": "commit"}, {"oid": "9ca12848377fad04ad8f8d2a29258ea8500f70d2", "url": "https://github.com/microsoft/mssql-jdbc/commit/9ca12848377fad04ad8f8d2a29258ea8500f70d2", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-28T07:45:46Z", "type": "commit"}, {"oid": "c67d8edea9341b2b94a075ecbbc4768e313f0658", "url": "https://github.com/microsoft/mssql-jdbc/commit/c67d8edea9341b2b94a075ecbbc4768e313f0658", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-08-01T00:41:25Z", "type": "commit"}, {"oid": "1d0a4adf7296966d52421ace5011fcc2fcc3147a", "url": "https://github.com/microsoft/mssql-jdbc/commit/1d0a4adf7296966d52421ace5011fcc2fcc3147a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-08-05T00:02:31Z", "type": "commit"}, {"oid": "398c2d86514e4e31e61ddfd5cf9e2ac83b3c56cf", "url": "https://github.com/microsoft/mssql-jdbc/commit/398c2d86514e4e31e61ddfd5cf9e2ac83b3c56cf", "message": "Fixes for Key and Crypto client", "committedDate": "2020-08-12T21:10:43Z", "type": "commit"}, {"oid": "1b363f7659ec1ed2576b616c97608063a541812e", "url": "https://github.com/microsoft/mssql-jdbc/commit/1b363f7659ec1ed2576b616c97608063a541812e", "message": "Merge pull request #2 from srnagar/keyvault-upgrade\n\nFixes for Key and Crypto client", "committedDate": "2020-08-12T21:16:05Z", "type": "commit"}, {"oid": "948939f99833c8741f42c97fc82b80a33d16cbf1", "url": "https://github.com/microsoft/mssql-jdbc/commit/948939f99833c8741f42c97fc82b80a33d16cbf1", "message": "Merge from master", "committedDate": "2020-08-12T21:22:10Z", "type": "commit"}, {"oid": "6d014b55e3d91988b2c09223dbff95d975d95fd5", "url": "https://github.com/microsoft/mssql-jdbc/commit/6d014b55e3d91988b2c09223dbff95d975d95fd5", "message": "Merge pull request #3 from srnagar/keyvault-upgrade\n\nMerge from master to resolve conflicts.", "committedDate": "2020-08-12T21:25:11Z", "type": "commit"}, {"oid": "dcf2f79d8dae25e5dce29f6c8f132f60f0a52de4", "url": "https://github.com/microsoft/mssql-jdbc/commit/dcf2f79d8dae25e5dce29f6c8f132f60f0a52de4", "message": "Fix compilation errors after merging from master", "committedDate": "2020-08-12T23:33:34Z", "type": "commit"}, {"oid": "62a83e4ad025e0377552869844b0f2ce074ba2b6", "url": "https://github.com/microsoft/mssql-jdbc/commit/62a83e4ad025e0377552869844b0f2ce074ba2b6", "message": "Merge pull request #4 from srnagar/keyvault-upgrade\n\nFix compilation errors after merging from master", "committedDate": "2020-08-12T23:36:35Z", "type": "commit"}, {"oid": "73d160fb9b57cba324a766edadcc96a6b7bec5f1", "url": "https://github.com/microsoft/mssql-jdbc/commit/73d160fb9b57cba324a766edadcc96a6b7bec5f1", "message": "Add tenantID to pipeline yml", "committedDate": "2020-08-13T08:14:10Z", "type": "commit"}, {"oid": "fba2a23884398f5bd0b5ff012b317166db80bc1b", "url": "https://github.com/microsoft/mssql-jdbc/commit/fba2a23884398f5bd0b5ff012b317166db80bc1b", "message": "Merge pull request #5 from srnagar/keyvault-upgrade\n\nAdd tenantID to pipeline yml", "committedDate": "2020-08-13T08:17:24Z", "type": "commit"}, {"oid": "54642abbb1caf15cdd9148d7360a2684adf68460", "url": "https://github.com/microsoft/mssql-jdbc/commit/54642abbb1caf15cdd9148d7360a2684adf68460", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-13T18:56:11Z", "type": "commit"}, {"oid": "f006a63e331016e1a6bdfbe42095156711a21bde", "url": "https://github.com/microsoft/mssql-jdbc/commit/f006a63e331016e1a6bdfbe42095156711a21bde", "message": "Fix unit test", "committedDate": "2020-08-13T19:54:01Z", "type": "commit"}, {"oid": "b2db031c2e2aca675d9ba87068b14ab878cce5fc", "url": "https://github.com/microsoft/mssql-jdbc/commit/b2db031c2e2aca675d9ba87068b14ab878cce5fc", "message": "Merge pull request #6 from srnagar/keyvault-upgrade\n\nFix unit test", "committedDate": "2020-08-13T19:55:57Z", "type": "commit"}, {"oid": "96e32f4c156d31264f14b91f786bcf06044726d7", "url": "https://github.com/microsoft/mssql-jdbc/commit/96e32f4c156d31264f14b91f786bcf06044726d7", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-13T22:22:11Z", "type": "commit"}, {"oid": "47a7b945ce8e84c88498c31d688556a24d4f0d7f", "url": "https://github.com/microsoft/mssql-jdbc/commit/47a7b945ce8e84c88498c31d688556a24d4f0d7f", "message": "Address PR comments", "committedDate": "2020-08-18T00:53:42Z", "type": "commit"}, {"oid": "9b1cac05c0bd83f343d95921b88b754a7ebe6707", "url": "https://github.com/microsoft/mssql-jdbc/commit/9b1cac05c0bd83f343d95921b88b754a7ebe6707", "message": "Merge remote-tracking branch 'upstream/dev' into keyvault-upgrade", "committedDate": "2020-08-18T00:54:59Z", "type": "commit"}, {"oid": "fcf327e11ba401078d988e7c13da18120de14a44", "url": "https://github.com/microsoft/mssql-jdbc/commit/fcf327e11ba401078d988e7c13da18120de14a44", "message": "Merge pull request #7 from srnagar/keyvault-upgrade\n\nKeyvault upgrade", "committedDate": "2020-08-18T01:07:13Z", "type": "commit"}, {"oid": "23b7f6a96e404bf08237cd07e7c2ce9bfcf11589", "url": "https://github.com/microsoft/mssql-jdbc/commit/23b7f6a96e404bf08237cd07e7c2ce9bfcf11589", "message": "Remove tenant Id and fix adal issues", "committedDate": "2020-08-18T20:25:10Z", "type": "commit"}, {"oid": "4121bc57cb984891fef55cc5af6fce68304f0208", "url": "https://github.com/microsoft/mssql-jdbc/commit/4121bc57cb984891fef55cc5af6fce68304f0208", "message": "Merge pull request #8 from srnagar/keyvault-upgrade\n\nRemove tenant Id and fix adal issues", "committedDate": "2020-08-18T20:32:33Z", "type": "commit"}, {"oid": "bca00d2aa8c8e7968ef1641e1468cf4e8ea3fa69", "url": "https://github.com/microsoft/mssql-jdbc/commit/bca00d2aa8c8e7968ef1641e1468cf4e8ea3fa69", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-18T21:09:51Z", "type": "commit"}, {"oid": "37c676d7aea6b43c7d347e353476a544da38b29f", "url": "https://github.com/microsoft/mssql-jdbc/commit/37c676d7aea6b43c7d347e353476a544da38b29f", "message": "Fix test failures", "committedDate": "2020-08-18T23:25:18Z", "type": "commit"}, {"oid": "8e8517b4797d404c2ff65f9f34230fe421dd3c3a", "url": "https://github.com/microsoft/mssql-jdbc/commit/8e8517b4797d404c2ff65f9f34230fe421dd3c3a", "message": "Merge pull request #9 from srnagar/keyvault-upgrade\n\nFix test failures", "committedDate": "2020-08-18T23:26:53Z", "type": "commit"}, {"oid": "b2eb9cb166f80d496b3bbcd030397e12d9c85455", "url": "https://github.com/microsoft/mssql-jdbc/commit/b2eb9cb166f80d496b3bbcd030397e12d9c85455", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-19T00:10:13Z", "type": "commit"}, {"oid": "ee3b5c88ceb8542bef086ff2d109247f07491032", "url": "https://github.com/microsoft/mssql-jdbc/commit/ee3b5c88ceb8542bef086ff2d109247f07491032", "message": "Use cached key and crypto clients", "committedDate": "2020-08-19T00:58:23Z", "type": "commit"}, {"oid": "48c6dac906e5d5553440105ec9f806a56255797a", "url": "https://github.com/microsoft/mssql-jdbc/commit/48c6dac906e5d5553440105ec9f806a56255797a", "message": "Merge pull request #10 from srnagar/keyvault-upgrade\n\nUse cached key and crypto clients", "committedDate": "2020-08-19T01:36:24Z", "type": "commit"}, {"oid": "6baad02d1a21995d197a88ab220616c56ea2c431", "url": "https://github.com/microsoft/mssql-jdbc/commit/6baad02d1a21995d197a88ab220616c56ea2c431", "message": "Update license header and cleanup pipeline builder", "committedDate": "2020-08-20T00:05:34Z", "type": "commit"}, {"oid": "a053426d5a30ccc86aaf6478810e1bba7dce5ccc", "url": "https://github.com/microsoft/mssql-jdbc/commit/a053426d5a30ccc86aaf6478810e1bba7dce5ccc", "message": "Merge pull request #11 from srnagar/keyvault-upgrade\n\nUpdate license header and cleanup pipeline builder", "committedDate": "2020-08-20T00:07:43Z", "type": "commit"}, {"oid": "0a3cb0f316c1d29ea29298402f02b15b8d872578", "url": "https://github.com/microsoft/mssql-jdbc/commit/0a3cb0f316c1d29ea29298402f02b15b8d872578", "message": "Fix unit tests", "committedDate": "2020-08-20T04:40:06Z", "type": "commit"}, {"oid": "1bf984a45b4d0b4478be3fdcbcd853a3bf088b96", "url": "https://github.com/microsoft/mssql-jdbc/commit/1bf984a45b4d0b4478be3fdcbcd853a3bf088b96", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-20T18:23:00Z", "type": "commit"}, {"oid": "684ecce1f043edeb5621f8b3dc956b3b59d7024f", "url": "https://github.com/microsoft/mssql-jdbc/commit/684ecce1f043edeb5621f8b3dc956b3b59d7024f", "message": "Merge pull request #12 from srnagar/keyvault-upgrade\n\nFix unit tests", "committedDate": "2020-08-20T18:27:52Z", "type": "commit"}, {"oid": "62ab01a648baa75f4c44940fb43b8c56b4142845", "url": "https://github.com/microsoft/mssql-jdbc/commit/62ab01a648baa75f4c44940fb43b8c56b4142845", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-21T06:14:21Z", "type": "commit"}, {"oid": "ef464f912bb19208c77d86f12fc2547ce0890288", "url": "https://github.com/microsoft/mssql-jdbc/commit/ef464f912bb19208c77d86f12fc2547ce0890288", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-22T03:59:10Z", "type": "commit"}, {"oid": "e4206e1d96aab063aeb7ec5d5a2e9b1c99aa855b", "url": "https://github.com/microsoft/mssql-jdbc/commit/e4206e1d96aab063aeb7ec5d5a2e9b1c99aa855b", "message": "Java 8 compatibility", "committedDate": "2020-08-24T05:03:57Z", "type": "commit"}, {"oid": "d7c23058a745beab1f10ffe9077b10b365783a13", "url": "https://github.com/microsoft/mssql-jdbc/commit/d7c23058a745beab1f10ffe9077b10b365783a13", "message": "Merge pull request #13 from srnagar/keyvault-upgrade\n\nJava 8 compatibility", "committedDate": "2020-08-24T05:07:14Z", "type": "commit"}, {"oid": "fccc5b7efa64a060d730252265904e4720bfce16", "url": "https://github.com/microsoft/mssql-jdbc/commit/fccc5b7efa64a060d730252265904e4720bfce16", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-24T17:35:46Z", "type": "commit"}, {"oid": "be1d739e84b0304d9b31e655108a2896a05eb86b", "url": "https://github.com/microsoft/mssql-jdbc/commit/be1d739e84b0304d9b31e655108a2896a05eb86b", "message": "Change Set.of to Collections.singleton()", "committedDate": "2020-08-24T18:43:15Z", "type": "commit"}, {"oid": "1423d9382cf7e1f8e3286e6e83fd5f67362ad6a7", "url": "https://github.com/microsoft/mssql-jdbc/commit/1423d9382cf7e1f8e3286e6e83fd5f67362ad6a7", "message": "Remote tenant id from JDBC tests", "committedDate": "2020-08-24T19:14:06Z", "type": "commit"}, {"oid": "e077ffe4fc5de650928c573f384015c8cba13b13", "url": "https://github.com/microsoft/mssql-jdbc/commit/e077ffe4fc5de650928c573f384015c8cba13b13", "message": "Merge pull request #14 from srnagar/keyvault-upgrade\n\nKeyvault upgrade", "committedDate": "2020-08-24T20:20:46Z", "type": "commit"}, {"oid": "9ad6edce5beaf5b97578d675f8462635dd07f9f7", "url": "https://github.com/microsoft/mssql-jdbc/commit/9ad6edce5beaf5b97578d675f8462635dd07f9f7", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-24T20:57:06Z", "type": "commit"}, {"oid": "f7493610d9583abd6f2c4d4dc63efe6fe3c730a0", "url": "https://github.com/microsoft/mssql-jdbc/commit/f7493610d9583abd6f2c4d4dc63efe6fe3c730a0", "message": "Merge remote-tracking branch 'upstream/dev' into keyvault-upgrade", "committedDate": "2020-08-24T23:49:23Z", "type": "commit"}, {"oid": "b08233c665cb54257a756169c216525f6add54c4", "url": "https://github.com/microsoft/mssql-jdbc/commit/b08233c665cb54257a756169c216525f6add54c4", "message": "Merge from dev", "committedDate": "2020-08-24T23:50:12Z", "type": "commit"}, {"oid": "49b802e1fc28bdfb1bac6ea247e895744f92f526", "url": "https://github.com/microsoft/mssql-jdbc/commit/49b802e1fc28bdfb1bac6ea247e895744f92f526", "message": "Merge pull request #15 from srnagar/keyvault-upgrade\n\nMerge from upstream dev branch", "committedDate": "2020-08-25T00:24:54Z", "type": "commit"}, {"oid": "c7bfe70cb9700d323f029d69792ae467a6a22906", "url": "https://github.com/microsoft/mssql-jdbc/commit/c7bfe70cb9700d323f029d69792ae467a6a22906", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-25T01:12:34Z", "type": "commit"}, {"oid": "e743268660f5506588ef578273246202d12e7a88", "url": "https://github.com/microsoft/mssql-jdbc/commit/e743268660f5506588ef578273246202d12e7a88", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-25T06:30:56Z", "type": "commit"}, {"oid": "c2622e46aa4001374e7aa69ff7ffd234ab061128", "url": "https://github.com/microsoft/mssql-jdbc/commit/c2622e46aa4001374e7aa69ff7ffd234ab061128", "message": "Merge remote-tracking branch 'upstream/dev' into keyvault-upgrade", "committedDate": "2020-08-25T21:39:30Z", "type": "commit"}, {"oid": "ffd6a7462323077d97ec3ad64047329288f08609", "url": "https://github.com/microsoft/mssql-jdbc/commit/ffd6a7462323077d97ec3ad64047329288f08609", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-08-26T18:06:10Z", "type": "commit"}, {"oid": "90ccde041653f327be0bddf55f0c4c31c6d4fcb1", "url": "https://github.com/microsoft/mssql-jdbc/commit/90ccde041653f327be0bddf55f0c4c31c6d4fcb1", "message": "Remove tenant id and reverse null checks", "committedDate": "2020-08-26T19:11:36Z", "type": "commit"}, {"oid": "f1b1dfbf14ed46682044e343a9e1e34e258827d3", "url": "https://github.com/microsoft/mssql-jdbc/commit/f1b1dfbf14ed46682044e343a9e1e34e258827d3", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-08-26T20:44:33Z", "type": "commit"}, {"oid": "d7c44b59affd57d3bb1c96557cc3711f7d99266d", "url": "https://github.com/microsoft/mssql-jdbc/commit/d7c44b59affd57d3bb1c96557cc3711f7d99266d", "message": "Fix compile errors", "committedDate": "2020-08-26T21:33:01Z", "type": "commit"}, {"oid": "fe0953145cc7b3e61444fe92e372e57bc2b855c5", "url": "https://github.com/microsoft/mssql-jdbc/commit/fe0953145cc7b3e61444fe92e372e57bc2b855c5", "message": "Remove tenant id from pipelines yml", "committedDate": "2020-08-26T23:10:15Z", "type": "commit"}, {"oid": "15db9cd8b34f8e0aba09f639bd278b7b7996b26d", "url": "https://github.com/microsoft/mssql-jdbc/commit/15db9cd8b34f8e0aba09f639bd278b7b7996b26d", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-08-27T19:21:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczMzkyMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r478733921", "bodyText": "remove, no longer needed", "author": "lilgreenbird", "createdAt": "2020-08-27T22:39:19Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java", "diffHunk": "@@ -669,6 +669,8 @@ boolean getSendTemporalDataTypesAsStringForBulkCopy() {\n     String keyStoreLocation = null;\n     String keyStorePrincipalId = null;\n \n+    String keyVaultProviderTenantId = null;", "originalCommit": "fe0953145cc7b3e61444fe92e372e57bc2b855c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 466f362b..c1514714 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n\n@@ -669,8 +669,6 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n     String keyStoreLocation = null;\n     String keyStorePrincipalId = null;\n \n-    String keyVaultProviderTenantId = null;\n-\n     private ColumnEncryptionVersion serverColumnEncryptionVersion = ColumnEncryptionVersion.AE_NotSupported;\n \n     private String enclaveType = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczNjAxMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r478736011", "bodyText": "[WARNING] Javadoc Warnings\n[WARNING] C:\\mssql-jdbc\\src\\main\\java\\com\\microsoft\\sqlserver\\jdbc\\SQLServerColumnEncryptionAzureKeyVaultProvider.java:145: warning: no @throws for com.microsoft.sqlserver.jdbc.SQLServerException\n[WARNING] public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential)\n[WARNING] ^", "author": "lilgreenbird", "createdAt": "2020-08-27T22:45:21Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -49,668 +53,682 @@\n  */\n public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {\n \n-    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n-            .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-    /**\n-     * Column Encryption Key Store Provider string\n-     */\n-    String name = \"AZURE_KEY_VAULT\";\n-\n-    private final String baseUrl = \"https://{vaultBaseUrl}\";\n-\n-    private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n-    private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-    private static final List<String> akvTrustedEndpoints;\n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n-    private final String rsaEncryptionAlgorithmWithOAEPForAKV = \"RSA-OAEP\";\n-\n-    /**\n-     * Algorithm version\n-     */\n-    private final byte[] firstVersion = new byte[] {0x01};\n-\n-    private KeyVaultClient keyVaultClient;\n-\n-    private KeyVaultCredential credentials;\n-\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return this.name;\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * @param clientKey\n-     *        Key of the client requesting the token.\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n+        private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n+                .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+        private HttpPipeline keyVaultPipeline;\n+        private KeyVaultCredential keyVaultCredential;\n+        /**\n+         * Column Encryption Key Store Provider string\n+         */\n+        String name = \"AZURE_KEY_VAULT\";\n+\n+        private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n+        private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+        private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n+        private static final List<String> akvTrustedEndpoints;\n+        /**\n+         * Algorithm version\n+         */\n+        private final byte[] firstVersion = new byte[] {0x01};\n+\n+        private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+        private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+        private TokenCredential credential;\n+\n+        static {\n+                akvTrustedEndpoints = getTrustedEndpoints();\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     * \n-     * @param masterKeyPath\n-     *        - Complete path of an asymmetric key in AKV\n-     * @param encryptionAlgorithm\n-     *        - Asymmetric Key Encryption Algorithm\n-     * @param encryptedColumnEncryptionKey\n-     *        - Encrypted Column Encryption Key\n-     * @return Plain text column encryption key\n-     */\n-    @Override\n-    public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-\n-        // Validate the input parameters\n-        this.ValidateNonEmptyAKVPath(masterKeyPath);\n-\n-        if (null == encryptedColumnEncryptionKey) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n+\n+        public void setName(String name) {\n+                this.name = name;\n         }\n \n-        if (0 == encryptedColumnEncryptionKey.length) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n+        public String getName() {\n+                return this.name;\n         }\n \n-        // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n-\n-        // Validate whether the key is RSA one or not and then get the key size\n-        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n-\n-        // Validate and decrypt the EncryptedColumnEncryptionKey\n-        // Format is\n-        // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-        //\n-        // keyPath is present in the encrypted column encryption key for identifying the original source of the\n-        // asymmetric key pair and\n-        // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n-\n-        // Validate the version byte\n-        if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n-            MessageFormat form = new MessageFormat(\n-                    SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n-            Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n-                    String.format(\"%02X \", firstVersion[0])};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and\n+         * client key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+         * @param clientId Identifier of the client requesting the token.\n+         * @param clientKey Secret key of the client requesting the token.\n+         * @throws SQLServerException If either {@code clientId} or {@code clientKey} are {@code null}.\n+         */\n+        public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey)\n+                throws SQLServerException {\n+                if (null == clientId || clientId.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client ID\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+                if (null == clientKey || clientKey.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client Key\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+\n+                keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n+                keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential)\n+                        .buildPipeline();\n         }\n \n-        // Get key path length\n-        int currentIndex = firstVersion.length;\n-        short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-        // We just read 2 bytes\n-        currentIndex += 2;\n-\n-        // Get ciphertext length\n-        short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-        currentIndex += 2;\n-\n-        // Skip KeyPath\n-        // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n-        currentIndex += keyPathLength;\n-\n-        // validate the ciphertext length\n-        if (cipherTextLength != keySizeInBytes) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n-            Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         */\n+        SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+                createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n         }\n \n-        // Validate the signature length\n-        int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         *\n+         * @param clientId Identifier of the client requesting the token.\n+         */\n+        SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+                if (null == clientId || clientId.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client ID\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+                createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        }\n \n-        if (signatureLength != keySizeInBytes) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n-            Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to\n+         * authenticate to AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         *\n+         * @param tokenCredential The TokenCredential to use to authenticate to Azure Key Vault.\n+         */", "originalCommit": "fe0953145cc7b3e61444fe92e372e57bc2b855c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex b76ca77d..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n\n@@ -53,682 +53,785 @@ import com.azure.security.keyvault.keys.models.KeyVaultKey;\n  */\n public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {\n \n-        private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n-                .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-        private HttpPipeline keyVaultPipeline;\n-        private KeyVaultCredential keyVaultCredential;\n-        /**\n-         * Column Encryption Key Store Provider string\n-         */\n-        String name = \"AZURE_KEY_VAULT\";\n-\n-        private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n-        private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-        private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n-\n-        private static final List<String> akvTrustedEndpoints;\n-        /**\n-         * Algorithm version\n-         */\n-        private final byte[] firstVersion = new byte[] {0x01};\n-\n-        private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n-        private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n-        private TokenCredential credential;\n-\n-        static {\n-                akvTrustedEndpoints = getTrustedEndpoints();\n+    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n+            .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    private static final int KEY_NAME_INDEX = 4;\n+    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n+    private static final String KEY_URL_DELIMITER = \"/\";\n+    private HttpPipeline keyVaultPipeline;\n+    private KeyVaultTokenCredential keyVaultTokenCredential;\n+\n+    /**\n+     * Column Encryption Key Store Provider string\n+     */\n+    String name = \"AZURE_KEY_VAULT\";\n+\n+    private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n+    private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n+    private static final List<String> akvTrustedEndpoints = getTrustedEndpoints();\n+\n+    /**\n+     * Algorithm version\n+     */\n+    private final byte[] firstVersion = new byte[] {0x01};\n+\n+    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+    private TokenCredential credential;\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * @param clientKey\n+     *        Secret key of the client requesting the token.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        public void setName(String name) {\n-                this.name = name;\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        public String getName() {\n-                return this.name;\n+        // create a token credential with given client id and secret which internally identifies the tenant id.\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n+        // create the pipeline with the custom Key Vault credential\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        setCredential(new ManagedIdentityCredentialBuilder().build());\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and\n-         * client key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n-         * @param clientId Identifier of the client requesting the token.\n-         * @param clientKey Secret key of the client requesting the token.\n-         * @throws SQLServerException If either {@code clientId} or {@code clientKey} are {@code null}.\n-         */\n-        public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey)\n-                throws SQLServerException {\n-                if (null == clientId || clientId.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client ID\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-                if (null == clientKey || clientKey.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client Key\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-\n-                keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-                keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential)\n-                        .buildPipeline();\n+        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         */\n-        SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-                createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+        setCredential(tokenCredential);\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         *\n-         * @param clientId Identifier of the client requesting the token.\n-         */\n-        SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-                if (null == clientId || clientId.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client ID\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-                createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n+    }\n+\n+    /**\n+     * Sets the credential that will be used for authenticating requests to Key Vault service.\n+     * \n+     * @param credential\n+     *        A credential of type {@link TokenCredential}.\n+     * @throws SQLServerException\n+     *         If the credential is null.\n+     */\n+    private void setCredential(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to\n-         * authenticate to AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         *\n-         * @param tokenCredential The TokenCredential to use to authenticate to Azure Key Vault.\n-         */\n-        public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential)\n-                throws SQLServerException {\n-                createKeyvaultClients(tokenCredential);\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n+     * @param masterKeyPath\n+     *        - Complete path of an asymmetric key in AKV\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric Key Encryption Algorithm\n+     * @param encryptedColumnEncryptionKey\n+     *        - Encrypted Column Encryption Key\n+     * @return Plain text column encryption key\n+     */\n+    @Override\n+    public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n+\n+        // Validate the input parameters\n+        this.ValidateNonEmptyAKVPath(masterKeyPath);\n+\n+        if (null == encryptedColumnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n         }\n \n-        private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-                this.credential = Objects.requireNonNull(credential);\n+        if (0 == encryptedColumnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n         }\n \n-        /**\n-         * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-         *\n-         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n-         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n-         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key\n-         * @return Plain text column encryption key\n-         */\n-        @Override public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-\n-                // Validate the input parameters\n-                this.ValidateNonEmptyAKVPath(masterKeyPath);\n-\n-                if (null == encryptedColumnEncryptionKey) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n-                }\n-\n-                if (0 == encryptedColumnEncryptionKey.length) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n-                }\n-\n-                // Validate encryptionAlgorithm\n-                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n-\n-                // Validate whether the key is RSA one or not and then get the key size\n-                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n-\n-                // Validate and decrypt the EncryptedColumnEncryptionKey\n-                // Format is\n-                // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-                //\n-                // keyPath is present in the encrypted column encryption key for identifying the original source of the\n-                // asymmetric key pair and\n-                // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n-\n-                // Validate the version byte\n-                if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n-                        Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n-                                String.format(\"%02X \", firstVersion[0])};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Get key path length\n-                int currentIndex = firstVersion.length;\n-                short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-                // We just read 2 bytes\n-                currentIndex += 2;\n-\n-                // Get ciphertext length\n-                short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-                currentIndex += 2;\n-\n-                // Skip KeyPath\n-                // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n-                currentIndex += keyPathLength;\n-\n-                // validate the ciphertext length\n-                if (cipherTextLength != keySizeInBytes) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n-                        Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Validate the signature length\n-                int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n-\n-                if (signatureLength != keySizeInBytes) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n-                        Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Get ciphertext\n-                byte[] cipherText = new byte[cipherTextLength];\n-                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n-                currentIndex += cipherTextLength;\n-\n-                // Get signature\n-                byte[] signature = new byte[signatureLength];\n-                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n-\n-                // Compute the hash to validate the signature\n-                byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n-\n-                System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n-                        encryptedColumnEncryptionKey.length - signature.length);\n-\n-                MessageDigest md = null;\n-                try {\n-                        md = MessageDigest.getInstance(\"SHA-256\");\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n-                md.update(hash);\n-                byte dataToVerify[] = md.digest();\n-\n-                if (null == dataToVerify) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-                }\n+        // Validate encryptionAlgorithm\n+        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+\n+        // Validate whether the key is RSA one or not and then get the key size\n+        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n+\n+        // Validate and decrypt the EncryptedColumnEncryptionKey\n+        // Format is\n+        // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+        //\n+        // keyPath is present in the encrypted column encryption key for identifying the original source of the\n+        // asymmetric key pair and\n+        // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n+\n+        // Validate the version byte\n+        if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n+            MessageFormat form = new MessageFormat(\n+                    SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n+            Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n+                    String.format(\"%02X \", firstVersion[0])};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                // Validate the signature\n-                if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n+        // Get key path length\n+        int currentIndex = firstVersion.length;\n+        short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+        // We just read 2 bytes\n+        currentIndex += 2;\n+\n+        // Get ciphertext length\n+        short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+        currentIndex += 2;\n+\n+        // Skip KeyPath\n+        // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n+        currentIndex += keyPathLength;\n+\n+        // validate the ciphertext length\n+        if (cipherTextLength != keySizeInBytes) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n+            Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                // Decrypt the CEK\n-                byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, _encryptionAlgorithm, cipherText);\n+        // Validate the signature length\n+        int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n \n-                return decryptedCEK;\n+        if (signatureLength != keySizeInBytes) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n+            Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n         }\n \n-        private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n+        // Get ciphertext\n+        byte[] cipherText = new byte[cipherTextLength];\n+        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n+        currentIndex += cipherTextLength;\n \n-                short shortVal;\n-                if (index + 1 >= input.length) {\n-                        throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"),\n-                                null, 0, false);\n-                }\n-                ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n-                byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n-                byteBuffer.put(input[index]);\n-                byteBuffer.put(input[index + 1]);\n-                shortVal = byteBuffer.getShort(0);\n-                return shortVal;\n-\n-        }\n-\n-        /**\n-         * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n-         *\n-         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n-         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n-         * @param columnEncryptionKey - Plain text column encryption key\n-         * @return Encrypted column encryption key\n-         */\n-        @Override public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-                byte[] columnEncryptionKey) throws SQLServerException {\n+        // Get signature\n+        byte[] signature = new byte[signatureLength];\n+        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n \n-                // Validate the input parameters\n-                this.ValidateNonEmptyAKVPath(masterKeyPath);\n+        // Compute the hash to validate the signature\n+        byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n \n-                if (null == columnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"),\n-                                null);\n-                }\n+        System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n+                encryptedColumnEncryptionKey.length - signature.length);\n \n-                if (0 == columnEncryptionKey.length) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n-                }\n-\n-                // Validate encryptionAlgorithm\n-                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        MessageDigest md = null;\n+        try {\n+            md = MessageDigest.getInstance(\"SHA-256\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+        }\n+        md.update(hash);\n+        byte dataToVerify[] = md.digest();\n \n-                // Validate whether the key is RSA one or not and then get the key size\n-                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n+        if (null == dataToVerify) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n+        }\n \n-                // Construct the encryptedColumnEncryptionKey\n-                // Format is\n-                // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n-                //\n-                // We currently only support one version\n-                byte[] version = new byte[] {firstVersion[0]};\n+        // Validate the signature\n+        if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n-                byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n+        // Decrypt the CEK\n+        byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, keyWrapAlgorithm, cipherText);\n \n-                byte[] keyPathLength = new byte[2];\n-                keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n-                keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n+        return decryptedCEK;\n+    }\n \n-                // Encrypt the plain text\n-                byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, _encryptionAlgorithm, columnEncryptionKey);\n+    private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n \n-                byte[] cipherTextLength = new byte[2];\n-                cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n-                cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n+        short shortVal;\n+        if (index + 1 >= input.length) {\n+            throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"), null, 0,\n+                    false);\n+        }\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n+        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n+        byteBuffer.put(input[index]);\n+        byteBuffer.put(input[index + 1]);\n+        shortVal = byteBuffer.getShort(0);\n+        return shortVal;\n+\n+    }\n+\n+    /**\n+     * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n+     *\n+     * @param masterKeyPath\n+     *        - Complete path of an asymmetric key in AKV\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric Key Encryption Algorithm\n+     * @param columnEncryptionKey\n+     *        - Plain text column encryption key\n+     * @return Encrypted column encryption key\n+     */\n+    @Override\n+    public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] columnEncryptionKey) throws SQLServerException {\n+\n+        // Validate the input parameters\n+        this.ValidateNonEmptyAKVPath(masterKeyPath);\n+\n+        if (null == columnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"), null);\n+        }\n \n-                if (cipherText.length != keySizeInBytes) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n-                }\n+        if (0 == columnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n+        }\n \n-                // Compute hash\n-                // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n-                byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n-                        + masterKeyPathBytes.length + cipherText.length];\n-                int destinationPosition = version.length;\n-                System.arraycopy(version, 0, dataToHash, 0, version.length);\n+        // Validate encryptionAlgorithm\n+        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n-                System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n-                destinationPosition += keyPathLength.length;\n+        // Validate whether the key is RSA one or not and then get the key size\n+        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n \n-                System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n-                destinationPosition += cipherTextLength.length;\n+        // Construct the encryptedColumnEncryptionKey\n+        // Format is\n+        // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n+        //\n+        // We currently only support one version\n+        byte[] version = new byte[] {firstVersion[0]};\n \n-                System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n-                destinationPosition += masterKeyPathBytes.length;\n+        // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n+        byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n \n-                System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n+        byte[] keyPathLength = new byte[2];\n+        keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n+        keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n \n-                MessageDigest md = null;\n-                try {\n-                        md = MessageDigest.getInstance(\"SHA-256\");\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n-                md.update(dataToHash);\n-                byte dataToSign[] = md.digest();\n+        // Encrypt the plain text\n+        byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, keyWrapAlgorithm, columnEncryptionKey);\n \n-                // Sign the hash\n-                byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n+        byte[] cipherTextLength = new byte[2];\n+        cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n+        cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n \n-                if (signedHash.length != keySizeInBytes) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n-                }\n+        if (cipherText.length != keySizeInBytes) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n+        }\n \n-                if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"),\n-                                null);\n-                }\n+        // Compute hash\n+        // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n+        byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n+                + masterKeyPathBytes.length + cipherText.length];\n+        int destinationPosition = version.length;\n+        System.arraycopy(version, 0, dataToHash, 0, version.length);\n \n-                // Construct the encrypted column encryption key\n-                // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-                int encryptedColumnEncryptionKeyLength =\n-                        version.length + cipherTextLength.length + keyPathLength.length + cipherText.length\n-                                + masterKeyPathBytes.length + signedHash.length;\n-                byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n+        System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n+        destinationPosition += keyPathLength.length;\n \n-                // Copy version byte\n-                int currentIndex = 0;\n-                System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n-                currentIndex += version.length;\n+        System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n+        destinationPosition += cipherTextLength.length;\n \n-                // Copy key path length\n-                System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n-                currentIndex += keyPathLength.length;\n+        System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n+        destinationPosition += masterKeyPathBytes.length;\n \n-                // Copy ciphertext length\n-                System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex,\n-                        cipherTextLength.length);\n-                currentIndex += cipherTextLength.length;\n+        System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n \n-                // Copy key path\n-                System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex,\n-                        masterKeyPathBytes.length);\n-                currentIndex += masterKeyPathBytes.length;\n+        MessageDigest md = null;\n+        try {\n+            md = MessageDigest.getInstance(\"SHA-256\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+        }\n+        md.update(dataToHash);\n+        byte dataToSign[] = md.digest();\n \n-                // Copy ciphertext\n-                System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n-                currentIndex += cipherText.length;\n+        // Sign the hash\n+        byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n \n-                // copy the signature\n-                System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n+        if (signedHash.length != keySizeInBytes) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n+        }\n \n-                return encryptedColumnEncryptionKey;\n+        if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"), null);\n         }\n \n-        /**\n-         * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n-         *\n-         * @param encryptionAlgorithm - Asymmetric key encryptio algorithm\n-         * @return The encryption algorithm that is going to be used.\n-         * @throws SQLServerException\n-         */\n-        private KeyWrapAlgorithm validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n+        // Construct the encrypted column encryption key\n+        // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+        int encryptedColumnEncryptionKeyLength = version.length + cipherTextLength.length + keyPathLength.length\n+                + cipherText.length + masterKeyPathBytes.length + signedHash.length;\n+        byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n+\n+        // Copy version byte\n+        int currentIndex = 0;\n+        System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n+        currentIndex += version.length;\n+\n+        // Copy key path length\n+        System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n+        currentIndex += keyPathLength.length;\n+\n+        // Copy ciphertext length\n+        System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex, cipherTextLength.length);\n+        currentIndex += cipherTextLength.length;\n+\n+        // Copy key path\n+        System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex, masterKeyPathBytes.length);\n+        currentIndex += masterKeyPathBytes.length;\n+\n+        // Copy ciphertext\n+        System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n+        currentIndex += cipherText.length;\n+\n+        // copy the signature\n+        System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n+\n+        return encryptedColumnEncryptionKey;\n+    }\n+\n+    /**\n+     * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n+     *\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric key encryptio algorithm\n+     * @return The encryption algorithm that is going to be used.\n+     * @throws SQLServerException\n+     */\n+    private KeyWrapAlgorithm validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n+\n+        if (null == encryptionAlgorithm) {\n+            throw new SQLServerException(null, SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0,\n+                    false);\n+        }\n \n-                if (null == encryptionAlgorithm) {\n-                        throw new SQLServerException(null,\n-                                SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0, false);\n-                }\n+        // Transform to standard format (dash instead of underscore) to support enum lookup\n+        if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n+            encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;\n+        }\n \n-                // Transform to standard format (dash instead of underscore) to support enum lookup\n-                if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n-                        encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;\n-                }\n+        if (!RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n+            Object[] msgArgs = {encryptionAlgorithm, RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                if (!RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n-                        Object[] msgArgs = {encryptionAlgorithm, RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n+        return KeyWrapAlgorithm.fromString(encryptionAlgorithm);\n+    }\n+\n+    /**\n+     * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n+     *\n+     * @param masterKeyPath\n+     * @throws SQLServerException\n+     */\n+    private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n+        // throw appropriate error if masterKeyPath is null or empty\n+        if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+        } else {\n+            URI parsedUri = null;\n+            try {\n+                parsedUri = new URI(masterKeyPath);\n+\n+                // A valid URI.\n+                // Check if it is pointing to a trusted endpoint.\n+                String host = parsedUri.getHost();\n+                if (null != host) {\n+                    host = host.toLowerCase(Locale.ENGLISH);\n+                }\n+                for (final String endpoint : akvTrustedEndpoints) {\n+                    if (null != host && host.endsWith(endpoint)) {\n+                        return;\n+                    }\n+                }\n+            } catch (URISyntaxException e) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n+                Object[] msgArgs = {masterKeyPath};\n+                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n+            }\n \n-                return KeyWrapAlgorithm.fromString(encryptionAlgorithm);\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n         }\n-\n-        /**\n-         * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n-         *\n-         * @param masterKeyPath\n-         * @throws SQLServerException\n-         */\n-        private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n-                // throw appropriate error if masterKeyPath is null or empty\n-                if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                } else {\n-                        URI parsedUri = null;\n-                        try {\n-                                parsedUri = new URI(masterKeyPath);\n-\n-                                // A valid URI.\n-                                // Check if it is pointing to a trusted endpoint.\n-                                String host = parsedUri.getHost();\n-                                if (null != host) {\n-                                        host = host.toLowerCase(Locale.ENGLISH);\n-                                }\n-                                for (final String endpoint : akvTrustedEndpoints) {\n-                                        if (null != host && host.endsWith(endpoint)) {\n-                                                return;\n-                                        }\n-                                }\n-                        } catch (URISyntaxException e) {\n-                                MessageFormat form = new MessageFormat(\n-                                        SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n-                                Object[] msgArgs = {masterKeyPath};\n-                                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n-                        }\n-\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n+    }\n+\n+    /**\n+     * Encrypts the text using specified Azure Key Vault key.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @param encryptionAlgorithm\n+     *        - Encryption Algorithm.\n+     * @param columnEncryptionKey\n+     *        - Plain text Column Encryption Key.\n+     * @return Returns an encrypted blob or throws an exception if there are any errors.\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n+            byte[] columnEncryptionKey) throws SQLServerException {\n+        if (null == columnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n         }\n \n-        /**\n-         * Encrypts the text using specified Azure Key Vault key.\n-         *\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @param encryptionAlgorithm - Encryption Algorithm.\n-         * @param columnEncryptionKey - Plain text Column Encryption Key.\n-         * @return Returns an encrypted blob or throws an exception if there are any errors.\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-                byte[] columnEncryptionKey) throws SQLServerException {\n-                if (null == columnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n-                }\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                WrapResult wrappedKey = cryptoClient.wrapKey(KeyWrapAlgorithm.RSA_OAEP, columnEncryptionKey);\n-                return wrappedKey.getEncryptedKey();\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        WrapResult wrappedKey = cryptoClient.wrapKey(KeyWrapAlgorithm.RSA_OAEP, columnEncryptionKey);\n+        return wrappedKey.getEncryptedKey();\n+    }\n+\n+    /**\n+     * Encrypts the text using specified Azure Key Vault key.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @param encryptionAlgorithm\n+     *        - Encrypted Column Encryption Key.\n+     * @param encryptedColumnEncryptionKey\n+     *        - Encrypted Column Encryption Key.\n+     * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultUnWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n+            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n+        if (null == encryptedColumnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n         }\n \n-        /**\n-         * Encrypts the text using specified Azure Key Vault key.\n-         *\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @param encryptionAlgorithm - Encrypted Column Encryption Key.\n-         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key.\n-         * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultUnWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-                if (null == encryptedColumnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n-                }\n+        if (0 == encryptedColumnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n+        }\n \n-                if (0 == encryptedColumnEncryptionKey.length) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n-                }\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n \n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        UnwrapResult unwrappedKey = cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);\n \n-                UnwrapResult unwrappedKey = cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);\n+        return unwrappedKey.getKey();\n+    }\n \n-                return unwrappedKey.getKey();\n+    private CryptographyClient getCryptographyClient(String masterKeyPath) throws SQLServerException {\n+        if (this.cachedCryptographyClients.containsKey(masterKeyPath)) {\n+            return cachedCryptographyClients.get(masterKeyPath);\n         }\n \n-        private CryptographyClient getCryptographyClient(String masterKeyPath) throws SQLServerException {\n-                if (this.cachedCryptographyClients.containsKey(masterKeyPath)) {\n-                        return cachedCryptographyClients.get(masterKeyPath);\n-                }\n-\n-                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n+        KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n \n-                CryptographyClient cryptoClient;\n-                if (null != credential) {\n-                        cryptoClient = new CryptographyClientBuilder().credential(credential)\n-                                .keyIdentifier(retrievedKey.getId()).buildClient();\n-                } else {\n-                        cryptoClient = new CryptographyClientBuilder().pipeline(keyVaultPipeline)\n-                                .keyIdentifier(retrievedKey.getId()).buildClient();\n-                }\n-                cachedCryptographyClients.putIfAbsent(masterKeyPath, cryptoClient);\n-                return cachedCryptographyClients.get(masterKeyPath);\n+        CryptographyClient cryptoClient;\n+        if (null != credential) {\n+            cryptoClient = new CryptographyClientBuilder().credential(credential).keyIdentifier(retrievedKey.getId())\n+                    .buildClient();\n+        } else {\n+            cryptoClient = new CryptographyClientBuilder().pipeline(keyVaultPipeline)\n+                    .keyIdentifier(retrievedKey.getId()).buildClient();\n+        }\n+        cachedCryptographyClients.putIfAbsent(masterKeyPath, cryptoClient);\n+        return cachedCryptographyClients.get(masterKeyPath);\n+    }\n+\n+    /**\n+     * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n+     *\n+     * @param dataToSign\n+     *        - Text to sign.\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @return Signature\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n+        assert ((null != dataToSign) && (0 != dataToSign.length));\n+\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        SignResult signedData = cryptoClient.sign(SignatureAlgorithm.RS256, dataToSign);\n+        return signedData.getSignature();\n+    }\n+\n+    /**\n+     * Verifies the given RSA PKCSv1.5 signature.\n+     *\n+     * @param dataToVerify\n+     * @param signature\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @return true if signature is valid, false if it is not valid\n+     * @throws SQLServerException\n+     */\n+    private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature,\n+            String masterKeyPath) throws SQLServerException {\n+        assert ((null != dataToVerify) && (0 != dataToVerify.length));\n+        assert ((null != signature) && (0 != signature.length));\n+\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        VerifyResult valid = cryptoClient.verify(SignatureAlgorithm.RS256, dataToVerify, signature);\n+\n+        return valid.isValid();\n+    }\n+\n+    /**\n+     * Returns the public Key size in bytes.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault Key path\n+     * @return Key size in bytes\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n+        KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n+        return retrievedKey.getKey().getN().length;\n+    }\n+\n+    /**\n+     * Fetches the key from Azure Key Vault for given key path. If the key path includes a version, then that specific\n+     * version of the key is retrieved, otherwise the latest key will be retrieved.\n+     * \n+     * @param masterKeyPath\n+     *        The key path associated with the key\n+     * @return The Key Vault key.\n+     * @throws SQLServerException\n+     *         If there was an error retrieving the key from Key Vault.\n+     */\n+    private KeyVaultKey getKeyVaultKey(String masterKeyPath) throws SQLServerException {\n+        String[] keyTokens = masterKeyPath.split(KEY_URL_DELIMITER);\n+        String keyName = keyTokens[KEY_NAME_INDEX];\n+        String keyVersion = null;\n+        if (keyTokens.length == KEY_URL_SPLIT_LENGTH_WITH_VERSION) {\n+            keyVersion = keyTokens[keyTokens.length - 1];\n         }\n \n-        /**\n-         * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n-         *\n-         * @param dataToSign - Text to sign.\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @return Signature\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n-                assert ((null != dataToSign) && (0 != dataToSign.length));\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                SignResult signedData = cryptoClient.sign(SignatureAlgorithm.RS256, dataToSign);\n-                return signedData.getSignature();\n-        }\n-\n-        /**\n-         * Verifies the given RSA PKCSv1.5 signature.\n-         *\n-         * @param dataToVerify\n-         * @param signature\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @return true if signature is valid, false if it is not valid\n-         * @throws SQLServerException\n-         */\n-        private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature, String masterKeyPath)\n-                throws SQLServerException {\n-                assert ((null != dataToVerify) && (0 != dataToVerify.length));\n-                assert ((null != signature) && (0 != signature.length));\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                VerifyResult valid = cryptoClient.verify(SignatureAlgorithm.RS256, dataToVerify, signature);\n+        try {\n+            KeyClient keyClient = getKeyClient(masterKeyPath);\n+            KeyVaultKey retrievedKey;\n+            if (null != keyVersion) {\n+                retrievedKey = keyClient.getKey(keyName, keyVersion);\n+            } else {\n+                retrievedKey = keyClient.getKey(keyName);\n+            }\n+            if (null == retrievedKey) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n+                Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n+                throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+            }\n \n-                return valid.isValid();\n+            if (retrievedKey.getKeyType() != KeyType.RSA && retrievedKey.getKeyType() != KeyType.RSA_HSM) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n+                Object[] msgArgs = {retrievedKey.getKeyType().toString()};\n+                throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+            }\n+            return retrievedKey;\n+        } catch (RuntimeException e) {\n+            throw new SQLServerException(e.getMessage(), e);\n         }\n \n-        /**\n-         * Returns the public Key size in bytes.\n-         *\n-         * @param masterKeyPath - Azure Key Vault Key path\n-         * @return Key size in bytes\n-         * @throws SQLServerException when an error occurs\n-         */\n-        private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n-                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n-                return retrievedKey.getKey().getN().length;\n-        }\n-\n-        private KeyVaultKey getKeyVaultKey(String masterKeyPath)\n-                throws SQLServerException {\n-                String[] keyTokens = masterKeyPath.split(\"/\");\n-                String keyName = keyTokens[keyTokens.length - 2];\n-                String keyVersion = keyTokens[keyTokens.length - 1];\n-                KeyClient keyClient = getKeyClient(masterKeyPath);\n-                KeyVaultKey retrievedKey = keyClient.getKey(keyName, keyVersion);\n-\n-                if (null == retrievedKey) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n-                        Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n+    }\n+\n+    /**\n+     * Creates a new {@link KeyClient} if one does not exist for the given key path. If the client already exists, the\n+     * client is returned from the cache. As the client is stateless, it's safe to cache the client for each key path.\n+     * \n+     * @param masterKeyPath\n+     *        The key path for which the {@link KeyClient} will be created, if it does not exist.\n+     * @return The {@link KeyClient} associated with the key path.\n+     */\n+    private KeyClient getKeyClient(String masterKeyPath) {\n+        if (cachedKeyClients.containsKey(masterKeyPath)) {\n+            return cachedKeyClients.get(masterKeyPath);\n+        }\n+        String vaultUrl = getVaultUrl(masterKeyPath);\n \n-                if (retrievedKey.getKeyType() != KeyType.RSA && retrievedKey.getKeyType() != KeyType.RSA_HSM) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n-                        Object[] msgArgs = {retrievedKey.getKeyType().toString()};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n-                return retrievedKey;\n+        KeyClient keyClient;\n+        if (null != credential) {\n+            keyClient = new KeyClientBuilder().credential(credential).vaultUrl(vaultUrl).buildClient();\n+        } else {\n+            keyClient = new KeyClientBuilder().pipeline(keyVaultPipeline).vaultUrl(vaultUrl).buildClient();\n+        }\n+        cachedKeyClients.putIfAbsent(masterKeyPath, keyClient);\n+        return cachedKeyClients.get(masterKeyPath);\n+    }\n+\n+    /**\n+     * Returns the vault url extracted from the master key path.\n+     * \n+     * @param masterKeyPath\n+     *        The master key path.\n+     * @return The vault url.\n+     */\n+    private static String getVaultUrl(String masterKeyPath) {\n+        String[] keyTokens = masterKeyPath.split(\"/\");\n+        String hostName = keyTokens[2];\n+        return \"https://\" + hostName;\n+    }\n+\n+    @Override\n+    public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n+            byte[] signature) throws SQLServerException {\n+        if (!allowEnclaveComputations) {\n+            return false;\n         }\n \n-        private KeyClient getKeyClient(String masterKeyPath) {\n-                if (cachedKeyClients.containsKey(masterKeyPath)) {\n-                        return cachedKeyClients.get(masterKeyPath);\n-                }\n-                String vaultUrl = getVaultUrl(masterKeyPath);\n+        KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n \n-                KeyClient keyClient;\n-                if (null != credential) {\n-                        keyClient = new KeyClientBuilder().credential(credential).vaultUrl(vaultUrl).buildClient();\n-                } else {\n-                        keyClient = new KeyClientBuilder().pipeline(keyVaultPipeline).vaultUrl(vaultUrl).buildClient();\n-                }\n-                cachedKeyClients.putIfAbsent(masterKeyPath, keyClient);\n-                return cachedKeyClients.get(masterKeyPath);\n-        }\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+            md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+            // value of allowEnclaveComputations is always true here\n+            md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n \n-        private static String getVaultUrl(String masterKeyPath) {\n-                String[] keyTokens = masterKeyPath.split(\"/\");\n-                String hostName = keyTokens[2];\n-                return \"https://\" + hostName;\n-        }\n+            byte[] dataToVerify = md.digest();\n+            if (null == dataToVerify) {\n+                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n+            }\n \n-        @Override public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n-                byte[] signature) throws SQLServerException {\n-            if (!allowEnclaveComputations) {\n-                return false;\n+            // Sign the hash\n+            byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n+            if (null == signedHash) {\n+                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n             }\n \n-                KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n-\n-                try {\n-                        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n-                        md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-                        md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-                        // value of allowEnclaveComputations is always true here\n-                        md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-\n-                        byte[] dataToVerify = md.digest();\n-                        if (null == dataToVerify) {\n-                                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-                        }\n-\n-                        // Sign the hash\n-                        byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n-                        if (null == signedHash) {\n-                                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"),\n-                                        null);\n-                        }\n-\n-                        // Validate the signature\n-                        return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n+            // Validate the signature\n+            return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n         }\n-\n-        private static List<String> getTrustedEndpoints() {\n-                Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n-                List<String> trustedEndpoints = new ArrayList<String>();\n-                boolean append = true;\n-                if (null != mssqlJdbcProperties) {\n-                        String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n-                        if (null != endpoints && !endpoints.trim().isEmpty()) {\n-                                endpoints = endpoints.trim();\n-                                // Append if the list starts with a semicolon.\n-                                if (';' != endpoints.charAt(0)) {\n-                                        append = false;\n-                                } else {\n-                                        endpoints = endpoints.substring(1);\n-                                }\n-                                String[] entries = endpoints.split(\";\");\n-                                for (String entry : entries) {\n-                                        if (null != entry && !entry.trim().isEmpty()) {\n-                                                trustedEndpoints.add(entry.trim());\n-                                        }\n-                                }\n-                        }\n+    }\n+\n+    private static List<String> getTrustedEndpoints() {\n+        Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n+        List<String> trustedEndpoints = new ArrayList<String>();\n+        boolean append = true;\n+        if (null != mssqlJdbcProperties) {\n+            String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n+            if (null != endpoints && !endpoints.trim().isEmpty()) {\n+                endpoints = endpoints.trim();\n+                // Append if the list starts with a semicolon.\n+                if (';' != endpoints.charAt(0)) {\n+                    append = false;\n+                } else {\n+                    endpoints = endpoints.substring(1);\n                 }\n-                /*\n-                 * List of Azure trusted endpoints\n-                 * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n-                 */\n-                if (append) {\n-                        trustedEndpoints.add(\"vault.azure.net\");\n-                        trustedEndpoints.add(\"vault.azure.cn\");\n-                        trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n-                        trustedEndpoints.add(\"vault.microsoftazure.de\");\n+                String[] entries = endpoints.split(\";\");\n+                for (String entry : entries) {\n+                    if (null != entry && !entry.trim().isEmpty()) {\n+                        trustedEndpoints.add(entry.trim());\n+                    }\n                 }\n-                return trustedEndpoints;\n+            }\n         }\n-\n-        /**\n-         * Attempt to read MSSQL_JDBC_PROPERTIES.\n-         *\n-         * @return corresponding Properties object or null if failed to read the file.\n+        /*\n+         * List of Azure trusted endpoints\n+         * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n          */\n-        private static Properties getMssqlJdbcProperties() {\n-                Properties props = null;\n-                try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n-                        props = new Properties();\n-                        props.load(in);\n-                } catch (IOException e) {\n-                        if (akvLogger.isLoggable(Level.FINER)) {\n-                                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n-                        }\n-                }\n-                return (null != props && !props.isEmpty()) ? props : null;\n+        if (append) {\n+            trustedEndpoints.add(\"vault.azure.net\");\n+            trustedEndpoints.add(\"vault.azure.cn\");\n+            trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n+            trustedEndpoints.add(\"vault.microsoftazure.de\");\n+        }\n+        return trustedEndpoints;\n+    }\n+\n+    /**\n+     * Attempt to read MSSQL_JDBC_PROPERTIES.\n+     *\n+     * @return corresponding Properties object or null if failed to read the file.\n+     */\n+    private static Properties getMssqlJdbcProperties() {\n+        Properties props = null;\n+        try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n+            props = new Properties();\n+            props.load(in);\n+        } catch (IOException e) {\n+            if (akvLogger.isLoggable(Level.FINER)) {\n+                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n+            }\n         }\n+        return (null != props && !props.isEmpty()) ? props : null;\n+    }\n }\n"}}, {"oid": "8d1f4622295ed6fa69a2d57c57797f6dc1261620", "url": "https://github.com/microsoft/mssql-jdbc/commit/8d1f4622295ed6fa69a2d57c57797f6dc1261620", "message": "Update javadoc", "committedDate": "2020-08-27T23:12:23Z", "type": "commit"}, {"oid": "22515502167d60947676e4cebf7e210bf5ceafc7", "url": "https://github.com/microsoft/mssql-jdbc/commit/22515502167d60947676e4cebf7e210bf5ceafc7", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-08-28T00:19:08Z", "type": "commit"}, {"oid": "fd9837610a9c3c0201fa691257d79474f2e5be0c", "url": "https://github.com/microsoft/mssql-jdbc/commit/fd9837610a9c3c0201fa691257d79474f2e5be0c", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-28T00:19:22Z", "type": "commit"}, {"oid": "04c05bdbcf9de991536d7972a6874d3dfc58148c", "url": "https://github.com/microsoft/mssql-jdbc/commit/04c05bdbcf9de991536d7972a6874d3dfc58148c", "message": "formatting", "committedDate": "2020-08-28T00:30:07Z", "type": "commit"}]}