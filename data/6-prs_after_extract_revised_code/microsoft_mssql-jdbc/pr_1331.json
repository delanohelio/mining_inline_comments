{"pr_number": 1331, "pr_title": "Extended bulk copy support for Azure DW", "pr_createdAt": "2020-05-07T21:45:02Z", "pr_url": "https://github.com/microsoft/mssql-jdbc/pull/1331", "timeline": [{"oid": "938499230ebc019f1ebcc8216043b5ff862de515", "url": "https://github.com/microsoft/mssql-jdbc/commit/938499230ebc019f1ebcc8216043b5ff862de515", "message": "first commit", "committedDate": "2020-05-07T04:31:59Z", "type": "commit"}, {"oid": "52ca698c08dc46d51b9f3f50e1bce5bee88aa327", "url": "https://github.com/microsoft/mssql-jdbc/commit/52ca698c08dc46d51b9f3f50e1bce5bee88aa327", "message": "Merge branch 'dev' of https://github.com/Microsoft/mssql-jdbc into bulkCopySupport", "committedDate": "2020-05-07T04:32:07Z", "type": "commit"}, {"oid": "ba4ac41a4826306566681d648eb3ea36954a6a0c", "url": "https://github.com/microsoft/mssql-jdbc/commit/ba4ac41a4826306566681d648eb3ea36954a6a0c", "message": "test changes", "committedDate": "2020-05-07T16:50:48Z", "type": "commit"}, {"oid": "7acedcf44b85a5590f5612d3424b5516dce80c98", "url": "https://github.com/microsoft/mssql-jdbc/commit/7acedcf44b85a5590f5612d3424b5516dce80c98", "message": "more tests", "committedDate": "2020-05-07T19:07:49Z", "type": "commit"}, {"oid": "ddfffcc161402ff52ba0206c118ae9fe5ca50286", "url": "https://github.com/microsoft/mssql-jdbc/commit/ddfffcc161402ff52ba0206c118ae9fe5ca50286", "message": "test changes", "committedDate": "2020-05-07T21:30:44Z", "type": "commit"}, {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03", "url": "https://github.com/microsoft/mssql-jdbc/commit/04c498f39f0f8b3bf69dfc42e619b76d03876a03", "message": "test changes", "committedDate": "2020-05-07T21:39:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMTI1MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423331251", "bodyText": "Make sure to follow JUnit test name standards.", "author": "ulvii", "createdAt": "2020-05-11T21:29:56Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\r", "originalCommit": "04c498f39f0f8b3bf69dfc42e619b76d03876a03", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c167c6abd08a36724137f837b99ee166e7de6265", "chunk": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java b/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\nsimilarity index 95%\nrename from src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java\nrename to src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\nindex aa3abe4e..1a03a9e8 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\n\n@@ -53,7 +53,7 @@ import com.microsoft.sqlserver.testframework.PrepUtil;\n  * \n  */\n @RunWith(JUnitPlatform.class)\n-public class BulkCopySendTemporalDataTypesAsString extends AbstractTest {\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\n     static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\n     static String encoding = \"UTF-8\";\n     static String delimiter = \",\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0NzQ2Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423347466", "bodyText": "Please use multi-line comments. Apply this to all the changes you made.", "author": "ulvii", "createdAt": "2020-05-11T22:06:42Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/DDC.java", "diffHunk": "@@ -323,6 +323,28 @@ static final Object convertDoubleToObject(double doubleVal, JDBCType jdbcType, S\n \n         return valueBytes;\n     }\n+    \n+    static final byte[] convertMoneyToBytes(BigDecimal bigDecimalVal, int bLength) {\n+        byte[] valueBytes = new byte[bLength];\n+        \n+        BigInteger bi = bigDecimalVal.unscaledValue();\n+        \n+        if (bLength == 8) {\n+            // money\n+            byte[] longbArray = new byte[bLength];\n+            Util.writeLong(bi.longValue(), longbArray, 0);\n+            // TDS 2.2.5.5.1.4 Fixed-Point Numbers\n+            // Money is represented as a 8 byte signed integer, with one 4-byte integer that represents", "originalCommit": "04c498f39f0f8b3bf69dfc42e619b76d03876a03", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c167c6abd08a36724137f837b99ee166e7de6265", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/DDC.java b/src/main/java/com/microsoft/sqlserver/jdbc/DDC.java\nindex 1d0cd468..cd4256f3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/DDC.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/DDC.java\n\n@@ -323,26 +323,28 @@ final class DDC {\n \n         return valueBytes;\n     }\n-    \n+\n     static final byte[] convertMoneyToBytes(BigDecimal bigDecimalVal, int bLength) {\n         byte[] valueBytes = new byte[bLength];\n-        \n+\n         BigInteger bi = bigDecimalVal.unscaledValue();\n-        \n+\n         if (bLength == 8) {\n             // money\n             byte[] longbArray = new byte[bLength];\n             Util.writeLong(bi.longValue(), longbArray, 0);\n-            // TDS 2.2.5.5.1.4 Fixed-Point Numbers\n-            // Money is represented as a 8 byte signed integer, with one 4-byte integer that represents\n-            // the more significant half, and one 4-byte integer that represents the less significant half.\n+            /*\n+             * TDS 2.2.5.5.1.4 Fixed-Point Numbers\n+             * Money is represented as a 8 byte signed integer, with one 4-byte integer that represents\n+             * the more significant half, and one 4-byte integer that represents the less significant half.\n+             */\n             System.arraycopy(longbArray, 0, valueBytes, 4, 4);\n             System.arraycopy(longbArray, 4, valueBytes, 0, 4);\n         } else {\n             // smallmoney\n             Util.writeInt(bi.intValue(), valueBytes, 0);\n         }\n-        \n+\n         return valueBytes;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDExNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423354116", "bodyText": "This is assuming insertion order is the same as select order, which is not true. Make sure to have an ID column to be able to order the select result by ID.", "author": "ulvii", "createdAt": "2020-05-11T22:23:28Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsString extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r\n+\r\n+        try (Connection conn = dsLocal.getConnection()) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyResultSet(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            try (ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destTableName);\r\n+                    SQLServerBulkCopy bcOperation = new SQLServerBulkCopy(conn);) {\r\n+                bcOperation.setDestinationTableName(destTableName2);\r\n+                bcOperation.writeToServer(rs);\r\n+            }\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName2, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "originalCommit": "04c498f39f0f8b3bf69dfc42e619b76d03876a03", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c167c6abd08a36724137f837b99ee166e7de6265", "chunk": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java b/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\nsimilarity index 95%\nrename from src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java\nrename to src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\nindex aa3abe4e..1a03a9e8 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\n\n@@ -53,7 +53,7 @@ import com.microsoft.sqlserver.testframework.PrepUtil;\n  * \n  */\n @RunWith(JUnitPlatform.class)\n-public class BulkCopySendTemporalDataTypesAsString extends AbstractTest {\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\n     static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\n     static String encoding = \"UTF-8\";\n     static String delimiter = \",\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423354358", "bodyText": "This is assuming insertion order is the same as select order, which is not true. Make sure to have an ID column to be able to order the select result by ID.", "author": "ulvii", "createdAt": "2020-05-11T22:24:06Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+public class BulkCopySendTemporalDataTypesAsStringAE extends AESetup {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+    static String filePath = null;\r\n+\r\n+    static String destTableNameAE = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTableAE\"));\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, with AE enabled.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyAE() throws SQLException {\r\n+        beforeEachSetupAE();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(AETestConnectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\", AEInfo)) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord, destTableNameAE);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord, String tableName) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(tableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, tableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "originalCommit": "04c498f39f0f8b3bf69dfc42e619b76d03876a03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk2MjEwMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423962103", "bodyText": "This is still not fixed.", "author": "ulvii", "createdAt": "2020-05-12T18:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNDM5MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424014391", "bodyText": "Why is this not fixed? Doesn't specifying the column names individually guarantee order?", "author": "peterbae", "createdAt": "2020-05-12T20:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNTcwMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424015701", "bodyText": "oh never mind, you meant the row order. I'll fix that.", "author": "peterbae", "createdAt": "2020-05-12T20:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMjUwNQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424022505", "bodyText": "I have a similar test, you can refer to this PR: #1312", "author": "ulvii", "createdAt": "2020-05-12T20:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTQ1MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424179451", "bodyText": "Thanks, done", "author": "peterbae", "createdAt": "2020-05-13T05:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}], "type": "inlineReview", "revised_code": {"commit": "c167c6abd08a36724137f837b99ee166e7de6265", "chunk": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAETest.java\nsimilarity index 95%\nrename from src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java\nrename to src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAETest.java\nindex fd371fc1..f7895d53 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAETest.java\n\n@@ -56,7 +56,7 @@ import com.microsoft.sqlserver.testframework.PrepUtil;\n @Tag(Constants.xSQLv12)\n @Tag(Constants.xAzureSQLDB)\n @Tag(Constants.xAzureSQLDW)\n-public class BulkCopySendTemporalDataTypesAsStringAE extends AESetup {\n+public class BulkCopySendTemporalDataTypesAsStringAETest extends AESetup {\n     static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\n     static String encoding = \"UTF-8\";\n     static String delimiter = \",\";\n"}}, {"oid": "c167c6abd08a36724137f837b99ee166e7de6265", "url": "https://github.com/microsoft/mssql-jdbc/commit/c167c6abd08a36724137f837b99ee166e7de6265", "message": "review comments", "committedDate": "2020-05-12T01:01:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1NDczOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423954739", "bodyText": "Please make javadoc consistent with other methods.", "author": "ulvii", "createdAt": "2020-05-12T18:44:28Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "diffHunk": "@@ -991,4 +991,19 @@\n      */\n     void setClientKeyPassword(String password);\n \n+    /**", "originalCommit": "c167c6abd08a36724137f837b99ee166e7de6265", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTQzMg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424179432", "bodyText": "done", "author": "peterbae", "createdAt": "2020-05-13T05:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1NDczOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex baaa0d45..6e401075 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n\n@@ -992,17 +992,17 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     void setClientKeyPassword(String password);\n \n     /**\n-     * Returns whether the driver will send temporal datatypes as String value to the server for bulk copy.\n+     * Returns the current flag for value sendTemporalDataTypesAsStringForBulkCopy\n      * \n-     * @return sendTemporalDataTypesAsStringForBulkCopy flag.\n+     * @return 'sendTemporalDataTypesAsStringForBulkCopy' property value.\n      */\n     boolean getSendTemporalDataTypesAsStringForBulkCopy();\n \n     /**\n-     * Sets whether the driver will send temporal datatypes as String value to the server for bulk copy.\n+     * Specifies the flag to send temporal datatypes as String for Bulk Copy.\n      * \n      * @param sendTemporalDataTypesAsStringForBulkCopy\n-     *        the flag for connection string.\n+     *        boolean value for 'sendTemporalDataTypesAsStringForBulkCopy'.\n      */\n     void setSendTemporalDataTypesAsStringForBulkCopy(boolean sendTemporalDataTypesAsStringForBulkCopy);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NTg2MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423975860", "bodyText": "Shouldn't this be destSSType instead?", "author": "ulvii", "createdAt": "2020-05-12T19:20:48Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2122,6 +2163,25 @@ else if (null != sourceCryptoMeta) {\n \n                 case microsoft.sql.Types.MONEY:\n                 case microsoft.sql.Types.SMALLMONEY:\n+                    if (null == colValue) {\n+                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);\n+                    } else {\n+                        /*\n+                         * if the precision that user provides is smaller than the precision of the actual value, the\n+                         * driver assumes the precision that user provides is the correct precision, and throws\n+                         * exception\n+                         */\n+                        if (bulkPrecision < Util.getValueLengthBaseOnJavaType(colValue, JavaType.of(colValue), null,\n+                                null, JDBCType.of(bulkJdbcType))) {\n+                            MessageFormat form = new MessageFormat(\n+                                    SQLServerException.getErrString(\"R_valueOutOfRange\"));\n+                            Object[] msgArgs = {SSType.DECIMAL};", "originalCommit": "c167c6abd08a36724137f837b99ee166e7de6265", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTQxMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424179410", "bodyText": "Sorry, which part of this code should be destSSType?", "author": "peterbae", "createdAt": "2020-05-13T05:24:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MjEyNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424182127", "bodyText": "Actually, I understood. Yes, this should be destSSType instead. I've made similar changes to the decimal/numeric case as well because I think it applies there as well, too.", "author": "peterbae", "createdAt": "2020-05-13T05:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NTg2MA=="}], "type": "inlineReview", "revised_code": {"commit": "f4ca3c0f14588634843fdd18d8033e8c71d911f1", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\nindex 04dec3ad..987eb7d6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\n\n@@ -2175,7 +2175,7 @@ public class SQLServerBulkCopy implements java.lang.AutoCloseable, java.io.Seria\n                                 null, JDBCType.of(bulkJdbcType))) {\n                             MessageFormat form = new MessageFormat(\n                                     SQLServerException.getErrString(\"R_valueOutOfRange\"));\n-                            Object[] msgArgs = {SSType.DECIMAL};\n+                            Object[] msgArgs = {destSSType};\n                             throw new SQLServerException(form.format(msgArgs), SQLState.DATA_EXCEPTION_LENGTH_MISMATCH,\n                                     DriverError.NOT_SET, null);\n                         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1NDc5Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424054792", "bodyText": "I don't get this part of the changes.  So if destSSType is money and srcJdbcType is decimal, the code will write both DSType.MONEYN.byteValue() and TDSType.DECIMALN.byteValue(). Is this expected?", "author": "ulvii", "createdAt": "2020-05-12T21:51:11Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -919,23 +919,37 @@ private void writeTypeInfo(TDSWriter tdsWriter, int srcJdbcType, int srcScale, i\n \n             case microsoft.sql.Types.MONEY:\n             case microsoft.sql.Types.SMALLMONEY:\n+                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n+                if (SSType.MONEY == destSSType)\n+                    tdsWriter.writeByte((byte) 8);\n+                else\n+                    tdsWriter.writeByte((byte) 4);\n+                break;\n             case java.sql.Types.NUMERIC:\n             case java.sql.Types.DECIMAL:\n-                if (isBaseType && ((SSType.MONEY == destSSType) || (SSType.SMALLMONEY == destSSType))) {\n-                    tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n-                    if (SSType.MONEY == destSSType)\n-                        tdsWriter.writeByte((byte) 8);\n-                    else\n-                        tdsWriter.writeByte((byte) 4);\n-                } else {\n-                    if (java.sql.Types.DECIMAL == srcJdbcType)\n-                        tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                    else\n-                        tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n-                    tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n-                    tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n-                    tdsWriter.writeByte((byte) srcScale); // unsigned byte\n+                /*\n+                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column,\n+                 * but Azure DW only accepts money types for money column.\n+                 * To make the code compatible against both SQL Server and Azure DW, always send decimal and\n+                 * numeric as money/smallmoney if the destination column is money/smallmoney\n+                 * and the source is decimal/numeric.\n+                 */", "originalCommit": "c167c6abd08a36724137f837b99ee166e7de6265", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTQxNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424181416", "bodyText": "No, if destSSType is money and srcJdbcType is decimal, the code will only write TDSType.MONEYN.byteValue() and break out of the switch statement.", "author": "peterbae", "createdAt": "2020-05-13T05:31:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1NDc5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "90fae3649819fe2fab94cd227d2c7ae05711ab14", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\nindex 04dec3ad..97de73a0 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\n\n@@ -943,10 +943,8 @@ public class SQLServerBulkCopy implements java.lang.AutoCloseable, java.io.Seria\n                     tdsWriter.writeByte((byte) 4);\n                     break;\n                 }\n-                if (java.sql.Types.DECIMAL == srcJdbcType)\n-                    tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                else\n-                    tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n+                byte byteType = (java.sql.Types.DECIMAL == srcJdbcType) ? TDSType.DECIMALN.byteValue() : TDSType.NUMERICN.byteValue();\n+                tdsWriter.writeByte(byteType);\n                 tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n                 tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n                 tdsWriter.writeByte((byte) srcScale); // unsigned byte\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NDMxNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424064316", "bodyText": "suggest that we be consistent in how we describe our other sendBlahAsBlah properties, ie \"Determines whether the driver will send...\"", "author": "lilgreenbird", "createdAt": "2020-05-12T22:13:13Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -264,6 +264,8 @@ static String getResource(String key) {\n             {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n             {\"R_clientKeyPasswordPropertyDescription\",\n                     \"Password for private key if the private key is password protected.\"},\n+            {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\",\n+                    \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},", "originalCommit": "c167c6abd08a36724137f837b99ee166e7de6265", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2OTgzMg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424169832", "bodyText": "I don't think my new addition here is inconsistent because other descriptive properties don't follow the \"Determines whether...\" starters either. I think the suggestion is good though.", "author": "peterbae", "createdAt": "2020-05-13T04:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NDMxNg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "url": "https://github.com/microsoft/mssql-jdbc/commit/0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "message": "comments", "committedDate": "2020-05-13T05:34:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MTYwMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424651601", "bodyText": "why define all these variables they're only used once below", "author": "lilgreenbird", "createdAt": "2020-05-13T18:38:54Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+            if (offsetString.startsWith(\"-\"))\n+                minutesOffset = -minutesOffset;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+            /*\n+             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+             * use a local time zone determined by the minutes offset of the value, since\n+             * the writers for those types expect local calendars.\n+             */\n+            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+            calendar = new GregorianCalendar(timeZone, Locale.US);\n+\n+            String timestampString = stringValue.substring(0, lastColon - 4);\n+            int year = Integer.valueOf(timestampString.substring(0, 4));\n+            int month = Integer.valueOf(timestampString.substring(5, 7));\n+            int day = Integer.valueOf(timestampString.substring(8, 10));\n+            int hour = Integer.valueOf(timestampString.substring(11, 13));\n+            int minute = Integer.valueOf(timestampString.substring(14, 16));\n+            int second = Integer.valueOf(timestampString.substring(17, 19));\n+", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NjE1OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424796158", "bodyText": "I think it's easier to see this way.", "author": "peterbae", "createdAt": "2020-05-13T23:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MTYwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "42c013ffbf51db58b1dbc9ab870dbed5f4270dc1", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 3f5d3d74..7cd8f566 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n\n@@ -3607,47 +3607,53 @@ final class TDSWriter {\n          * Parse the DTO as string if it's coming from a CSV.\n          */\n         if (value instanceof String) {\n-            String stringValue = (String) value;\n-            int lastColon = stringValue.lastIndexOf(':');\n-\n-            String offsetString = stringValue.substring(lastColon - 3);\n-            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n-                    + Integer.valueOf(offsetString.substring(4, 6));\n-\n-            if (offsetString.startsWith(\"-\"))\n-                minutesOffset = -minutesOffset;\n-\n-            /*\n-             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-             * use a local time zone determined by the minutes offset of the value, since\n-             * the writers for those types expect local calendars.\n-             */\n-            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n-\n-            calendar = new GregorianCalendar(timeZone, Locale.US);\n-\n-            String timestampString = stringValue.substring(0, lastColon - 4);\n-            int year = Integer.valueOf(timestampString.substring(0, 4));\n-            int month = Integer.valueOf(timestampString.substring(5, 7));\n-            int day = Integer.valueOf(timestampString.substring(8, 10));\n-            int hour = Integer.valueOf(timestampString.substring(11, 13));\n-            int minute = Integer.valueOf(timestampString.substring(14, 16));\n-            int second = Integer.valueOf(timestampString.substring(17, 19));\n-\n-            subSecondNanos = (19 == timestampString.indexOf('.')) ? (new BigDecimal(timestampString.substring(19)))\n-                    .scaleByPowerOfTen(9).intValue() : 0;\n-\n-            calendar.setLenient(true);\n-            calendar.set(Calendar.YEAR, year);\n-            calendar.set(Calendar.MONTH, month - 1);\n-            calendar.set(Calendar.DAY_OF_MONTH, day);\n-            calendar.set(Calendar.HOUR_OF_DAY, hour);\n-            calendar.set(Calendar.MINUTE, minute);\n-            calendar.set(Calendar.SECOND, second);\n-            calendar.add(Calendar.MINUTE, -minutesOffset);\n+            try {\n+                String stringValue = (String) value;\n+                int lastColon = stringValue.lastIndexOf(':');\n+\n+                String offsetString = stringValue.substring(lastColon - 3);\n+                minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                        + Integer.valueOf(offsetString.substring(4, 6));\n+\n+                if (offsetString.startsWith(\"-\"))\n+                    minutesOffset = -minutesOffset;\n+\n+                /*\n+                 * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+                 * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+                 * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+                 * use a local time zone determined by the minutes offset of the value, since\n+                 * the writers for those types expect local calendars.\n+                 */\n+                timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                                 : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+                calendar = new GregorianCalendar(timeZone, Locale.CHINA);\n+\n+                String timestampString = stringValue.substring(0, lastColon - 4);\n+                int year = Integer.valueOf(timestampString.substring(0, 4));\n+                int month = Integer.valueOf(timestampString.substring(5, 7));\n+                int day = Integer.valueOf(timestampString.substring(8, 10));\n+                int hour = Integer.valueOf(timestampString.substring(11, 13));\n+                int minute = Integer.valueOf(timestampString.substring(14, 16));\n+                int second = Integer.valueOf(timestampString.substring(17, 19));\n+\n+                subSecondNanos = (19 == timestampString.indexOf('.')) ? (new BigDecimal(timestampString.substring(19)))\n+                        .scaleByPowerOfTen(9).intValue() : 0;\n+\n+                calendar.setLenient(true);\n+                calendar.set(Calendar.YEAR, year);\n+                calendar.set(Calendar.MONTH, month - 1);\n+                calendar.set(Calendar.DAY_OF_MONTH, day);\n+                calendar.set(Calendar.HOUR_OF_DAY, hour);\n+                calendar.set(Calendar.MINUTE, minute);\n+                calendar.set(Calendar.SECOND, second);\n+                calendar.add(Calendar.MINUTE, -minutesOffset);\n+            } catch (NumberFormatException | IndexOutOfBoundsException e) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_ParsingDataError\"));\n+                Object[] msgArgs = {value, JDBCType.DATETIMEOFFSET};\n+                throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+            }\n         } else {\n             long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424660989", "bodyText": "this test doesn't actually test the datasource settings as updateDataSource hasn't been updated to include the new properties", "author": "lilgreenbird", "createdAt": "2020-05-13T18:54:31Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MTcxNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426041717", "bodyText": "I think it is testing the datasource, because I'm calling setSendTemporalDataTypesAsStringForBulkCopy instead of using updateDataSource. I just checked as well to make sure it is using the datasource with the connection property set to false.", "author": "peterbae", "createdAt": "2020-05-15T20:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MjgwMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426192801", "bodyText": "sorry, you're right you are, as you're calling that explicitly after. But that's not how the other connection properties are handled. And updateDataSource needs to be updated to parse all the connection properties properly", "author": "lilgreenbird", "createdAt": "2020-05-16T21:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc5OTYxNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428799616", "bodyText": "sure, i'll add that to my tests too then.", "author": "peterbae", "createdAt": "2020-05-21T17:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "3341bcbbb335812e5c648860d6831016112aaf5f", "chunk": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\nindex 6e21744b..9a064904 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\n\n@@ -55,6 +55,7 @@ import com.microsoft.sqlserver.testframework.PrepUtil;\n @RunWith(JUnitPlatform.class)\n public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\n     static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\n+    static String inputFile2 = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv\";\n     static String encoding = \"UTF-8\";\n     static String delimiter = \",\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MzI1NA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424663254", "bodyText": "why not just use @beforeeach?", "author": "lilgreenbird", "createdAt": "2020-05-13T18:58:18Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MjMzNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426042334", "bodyText": "Sometimes beforeEach didn't work for me properly, so I just call beforeEachSetup. There shouldn't be any functional differences.", "author": "peterbae", "createdAt": "2020-05-15T20:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MzI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "3341bcbbb335812e5c648860d6831016112aaf5f", "chunk": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\nindex 6e21744b..9a064904 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\n\n@@ -55,6 +55,7 @@ import com.microsoft.sqlserver.testframework.PrepUtil;\n @RunWith(JUnitPlatform.class)\n public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\n     static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\n+    static String inputFile2 = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv\";\n     static String encoding = \"UTF-8\";\n     static String delimiter = \",\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NDE4MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424694181", "bodyText": "Need to handle indexoutofbounds here in case the input isn't in the format expected.", "author": "rene-ye", "createdAt": "2020-05-13T19:55:28Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTE5Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424795193", "bodyText": "Thanks, done.", "author": "peterbae", "createdAt": "2020-05-13T23:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NDE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "42c013ffbf51db58b1dbc9ab870dbed5f4270dc1", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 3f5d3d74..7cd8f566 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n\n@@ -3607,47 +3607,53 @@ final class TDSWriter {\n          * Parse the DTO as string if it's coming from a CSV.\n          */\n         if (value instanceof String) {\n-            String stringValue = (String) value;\n-            int lastColon = stringValue.lastIndexOf(':');\n-\n-            String offsetString = stringValue.substring(lastColon - 3);\n-            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n-                    + Integer.valueOf(offsetString.substring(4, 6));\n-\n-            if (offsetString.startsWith(\"-\"))\n-                minutesOffset = -minutesOffset;\n-\n-            /*\n-             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-             * use a local time zone determined by the minutes offset of the value, since\n-             * the writers for those types expect local calendars.\n-             */\n-            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n-\n-            calendar = new GregorianCalendar(timeZone, Locale.US);\n-\n-            String timestampString = stringValue.substring(0, lastColon - 4);\n-            int year = Integer.valueOf(timestampString.substring(0, 4));\n-            int month = Integer.valueOf(timestampString.substring(5, 7));\n-            int day = Integer.valueOf(timestampString.substring(8, 10));\n-            int hour = Integer.valueOf(timestampString.substring(11, 13));\n-            int minute = Integer.valueOf(timestampString.substring(14, 16));\n-            int second = Integer.valueOf(timestampString.substring(17, 19));\n-\n-            subSecondNanos = (19 == timestampString.indexOf('.')) ? (new BigDecimal(timestampString.substring(19)))\n-                    .scaleByPowerOfTen(9).intValue() : 0;\n-\n-            calendar.setLenient(true);\n-            calendar.set(Calendar.YEAR, year);\n-            calendar.set(Calendar.MONTH, month - 1);\n-            calendar.set(Calendar.DAY_OF_MONTH, day);\n-            calendar.set(Calendar.HOUR_OF_DAY, hour);\n-            calendar.set(Calendar.MINUTE, minute);\n-            calendar.set(Calendar.SECOND, second);\n-            calendar.add(Calendar.MINUTE, -minutesOffset);\n+            try {\n+                String stringValue = (String) value;\n+                int lastColon = stringValue.lastIndexOf(':');\n+\n+                String offsetString = stringValue.substring(lastColon - 3);\n+                minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                        + Integer.valueOf(offsetString.substring(4, 6));\n+\n+                if (offsetString.startsWith(\"-\"))\n+                    minutesOffset = -minutesOffset;\n+\n+                /*\n+                 * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+                 * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+                 * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+                 * use a local time zone determined by the minutes offset of the value, since\n+                 * the writers for those types expect local calendars.\n+                 */\n+                timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                                 : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+                calendar = new GregorianCalendar(timeZone, Locale.CHINA);\n+\n+                String timestampString = stringValue.substring(0, lastColon - 4);\n+                int year = Integer.valueOf(timestampString.substring(0, 4));\n+                int month = Integer.valueOf(timestampString.substring(5, 7));\n+                int day = Integer.valueOf(timestampString.substring(8, 10));\n+                int hour = Integer.valueOf(timestampString.substring(11, 13));\n+                int minute = Integer.valueOf(timestampString.substring(14, 16));\n+                int second = Integer.valueOf(timestampString.substring(17, 19));\n+\n+                subSecondNanos = (19 == timestampString.indexOf('.')) ? (new BigDecimal(timestampString.substring(19)))\n+                        .scaleByPowerOfTen(9).intValue() : 0;\n+\n+                calendar.setLenient(true);\n+                calendar.set(Calendar.YEAR, year);\n+                calendar.set(Calendar.MONTH, month - 1);\n+                calendar.set(Calendar.DAY_OF_MONTH, day);\n+                calendar.set(Calendar.HOUR_OF_DAY, hour);\n+                calendar.set(Calendar.MINUTE, minute);\n+                calendar.set(Calendar.SECOND, second);\n+                calendar.add(Calendar.MINUTE, -minutesOffset);\n+            } catch (NumberFormatException | IndexOutOfBoundsException e) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_ParsingDataError\"));\n+                Object[] msgArgs = {value, JDBCType.DATETIMEOFFSET};\n+                throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+            }\n         } else {\n             long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTA1OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424695058", "bodyText": "Doesn't this break if the user's locale isn't US?", "author": "rene-ye", "createdAt": "2020-05-13T19:57:09Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+            if (offsetString.startsWith(\"-\"))\n+                minutesOffset = -minutesOffset;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+            /*\n+             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+             * use a local time zone determined by the minutes offset of the value, since\n+             * the writers for those types expect local calendars.\n+             */\n+            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+            calendar = new GregorianCalendar(timeZone, Locale.US);", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NjA5OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424796099", "bodyText": "The locale doesn't matter. It's only used to determine what is the first day of the week (either saturday, sunday or monday) but that function isn't being used here, so I just put US locale (but anything works)", "author": "peterbae", "createdAt": "2020-05-13T23:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTA1OA=="}], "type": "inlineReview", "revised_code": {"commit": "42c013ffbf51db58b1dbc9ab870dbed5f4270dc1", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 3f5d3d74..7cd8f566 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n\n@@ -3607,47 +3607,53 @@ final class TDSWriter {\n          * Parse the DTO as string if it's coming from a CSV.\n          */\n         if (value instanceof String) {\n-            String stringValue = (String) value;\n-            int lastColon = stringValue.lastIndexOf(':');\n-\n-            String offsetString = stringValue.substring(lastColon - 3);\n-            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n-                    + Integer.valueOf(offsetString.substring(4, 6));\n-\n-            if (offsetString.startsWith(\"-\"))\n-                minutesOffset = -minutesOffset;\n-\n-            /*\n-             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-             * use a local time zone determined by the minutes offset of the value, since\n-             * the writers for those types expect local calendars.\n-             */\n-            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n-\n-            calendar = new GregorianCalendar(timeZone, Locale.US);\n-\n-            String timestampString = stringValue.substring(0, lastColon - 4);\n-            int year = Integer.valueOf(timestampString.substring(0, 4));\n-            int month = Integer.valueOf(timestampString.substring(5, 7));\n-            int day = Integer.valueOf(timestampString.substring(8, 10));\n-            int hour = Integer.valueOf(timestampString.substring(11, 13));\n-            int minute = Integer.valueOf(timestampString.substring(14, 16));\n-            int second = Integer.valueOf(timestampString.substring(17, 19));\n-\n-            subSecondNanos = (19 == timestampString.indexOf('.')) ? (new BigDecimal(timestampString.substring(19)))\n-                    .scaleByPowerOfTen(9).intValue() : 0;\n-\n-            calendar.setLenient(true);\n-            calendar.set(Calendar.YEAR, year);\n-            calendar.set(Calendar.MONTH, month - 1);\n-            calendar.set(Calendar.DAY_OF_MONTH, day);\n-            calendar.set(Calendar.HOUR_OF_DAY, hour);\n-            calendar.set(Calendar.MINUTE, minute);\n-            calendar.set(Calendar.SECOND, second);\n-            calendar.add(Calendar.MINUTE, -minutesOffset);\n+            try {\n+                String stringValue = (String) value;\n+                int lastColon = stringValue.lastIndexOf(':');\n+\n+                String offsetString = stringValue.substring(lastColon - 3);\n+                minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                        + Integer.valueOf(offsetString.substring(4, 6));\n+\n+                if (offsetString.startsWith(\"-\"))\n+                    minutesOffset = -minutesOffset;\n+\n+                /*\n+                 * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+                 * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+                 * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+                 * use a local time zone determined by the minutes offset of the value, since\n+                 * the writers for those types expect local calendars.\n+                 */\n+                timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                                 : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+                calendar = new GregorianCalendar(timeZone, Locale.CHINA);\n+\n+                String timestampString = stringValue.substring(0, lastColon - 4);\n+                int year = Integer.valueOf(timestampString.substring(0, 4));\n+                int month = Integer.valueOf(timestampString.substring(5, 7));\n+                int day = Integer.valueOf(timestampString.substring(8, 10));\n+                int hour = Integer.valueOf(timestampString.substring(11, 13));\n+                int minute = Integer.valueOf(timestampString.substring(14, 16));\n+                int second = Integer.valueOf(timestampString.substring(17, 19));\n+\n+                subSecondNanos = (19 == timestampString.indexOf('.')) ? (new BigDecimal(timestampString.substring(19)))\n+                        .scaleByPowerOfTen(9).intValue() : 0;\n+\n+                calendar.setLenient(true);\n+                calendar.set(Calendar.YEAR, year);\n+                calendar.set(Calendar.MONTH, month - 1);\n+                calendar.set(Calendar.DAY_OF_MONTH, day);\n+                calendar.set(Calendar.HOUR_OF_DAY, hour);\n+                calendar.set(Calendar.MINUTE, minute);\n+                calendar.set(Calendar.SECOND, second);\n+                calendar.add(Calendar.MINUTE, -minutesOffset);\n+            } catch (NumberFormatException | IndexOutOfBoundsException e) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_ParsingDataError\"));\n+                Object[] msgArgs = {value, JDBCType.DATETIMEOFFSET};\n+                throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+            }\n         } else {\n             long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NzcyNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424697727", "bodyText": "byte byteType = (java.sql.Types.DECIMAL == srcJdbcType) ? TDSType.DECIMALN.byteValue() : TDSType.NUMERICN.byteValue();\ntdsWriter.writeByte(byteType);\nChange if block to above to shorten the code and make it more clear.", "author": "rene-ye", "createdAt": "2020-05-13T20:02:02Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -919,23 +919,37 @@ private void writeTypeInfo(TDSWriter tdsWriter, int srcJdbcType, int srcScale, i\n \n             case microsoft.sql.Types.MONEY:\n             case microsoft.sql.Types.SMALLMONEY:\n+                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n+                if (SSType.MONEY == destSSType)\n+                    tdsWriter.writeByte((byte) 8);\n+                else\n+                    tdsWriter.writeByte((byte) 4);\n+                break;\n             case java.sql.Types.NUMERIC:\n             case java.sql.Types.DECIMAL:\n-                if (isBaseType && ((SSType.MONEY == destSSType) || (SSType.SMALLMONEY == destSSType))) {\n-                    tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n-                    if (SSType.MONEY == destSSType)\n-                        tdsWriter.writeByte((byte) 8);\n-                    else\n-                        tdsWriter.writeByte((byte) 4);\n-                } else {\n-                    if (java.sql.Types.DECIMAL == srcJdbcType)\n-                        tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                    else\n-                        tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n-                    tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n-                    tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n-                    tdsWriter.writeByte((byte) srcScale); // unsigned byte\n+                /*\n+                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column,\n+                 * but Azure DW only accepts money types for money column.\n+                 * To make the code compatible against both SQL Server and Azure DW, always send decimal and\n+                 * numeric as money/smallmoney if the destination column is money/smallmoney\n+                 * and the source is decimal/numeric.\n+                 */\n+                if (destSSType == SSType.MONEY) {\n+                    tdsWriter.writeByte(TDSType.MONEYN.byteValue());\n+                    tdsWriter.writeByte((byte) 8);\n+                    break;\n+                } else if (destSSType == SSType.SMALLMONEY) {\n+                    tdsWriter.writeByte(TDSType.MONEYN.byteValue());\n+                    tdsWriter.writeByte((byte) 4);\n+                    break;\n                 }\n+                if (java.sql.Types.DECIMAL == srcJdbcType)\n+                    tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n+                else\n+                    tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5Njk1Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424796957", "bodyText": "done", "author": "peterbae", "createdAt": "2020-05-13T23:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NzcyNw=="}], "type": "inlineReview", "revised_code": {"commit": "90fae3649819fe2fab94cd227d2c7ae05711ab14", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\nindex 04dec3ad..97de73a0 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\n\n@@ -943,10 +943,8 @@ public class SQLServerBulkCopy implements java.lang.AutoCloseable, java.io.Seria\n                     tdsWriter.writeByte((byte) 4);\n                     break;\n                 }\n-                if (java.sql.Types.DECIMAL == srcJdbcType)\n-                    tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                else\n-                    tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n+                byte byteType = (java.sql.Types.DECIMAL == srcJdbcType) ? TDSType.DECIMALN.byteValue() : TDSType.NUMERICN.byteValue();\n+                tdsWriter.writeByte(byteType);\n                 tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n                 tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n                 tdsWriter.writeByte((byte) srcScale); // unsigned byte\n"}}, {"oid": "f4ca3c0f14588634843fdd18d8033e8c71d911f1", "url": "https://github.com/microsoft/mssql-jdbc/commit/f4ca3c0f14588634843fdd18d8033e8c71d911f1", "message": "destSSType", "committedDate": "2020-05-13T23:39:29Z", "type": "commit"}, {"oid": "42c013ffbf51db58b1dbc9ab870dbed5f4270dc1", "url": "https://github.com/microsoft/mssql-jdbc/commit/42c013ffbf51db58b1dbc9ab870dbed5f4270dc1", "message": "check for failure", "committedDate": "2020-05-13T23:56:32Z", "type": "commit"}, {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14", "url": "https://github.com/microsoft/mssql-jdbc/commit/90fae3649819fe2fab94cd227d2c7ae05711ab14", "message": "shorten if statement", "committedDate": "2020-05-13T23:58:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk3MjI3Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r425972272", "bodyText": "Please add a comment which contains the format you are parsing.", "author": "ulvii", "createdAt": "2020-05-15T18:20:26Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,87 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            try {\n+                String stringValue = (String) value;", "originalCommit": "90fae3649819fe2fab94cd227d2c7ae05711ab14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1OTkzNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426059937", "bodyText": "done.", "author": "peterbae", "createdAt": "2020-05-15T21:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk3MjI3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3341bcbbb335812e5c648860d6831016112aaf5f", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 7cd8f566..a4f6155b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n\n@@ -3607,16 +3607,30 @@ final class TDSWriter {\n          * Parse the DTO as string if it's coming from a CSV.\n          */\n         if (value instanceof String) {\n+            // expected format: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\n             try {\n                 String stringValue = (String) value;\n                 int lastColon = stringValue.lastIndexOf(':');\n \n                 String offsetString = stringValue.substring(lastColon - 3);\n-                minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n-                        + Integer.valueOf(offsetString.substring(4, 6));\n \n-                if (offsetString.startsWith(\"-\"))\n-                    minutesOffset = -minutesOffset;\n+                /*\n+                 * At this point, offsetString should look like +hh:mm or -hh:mm. Otherwise, the optional offset\n+                 * value has not been provided. Parse accordingly.\n+                 */\n+                String timestampString;\n+\n+                if (!offsetString.startsWith(\"+\") && !offsetString.startsWith(\"-\")) {\n+                    minutesOffset = 0;\n+                    timestampString = stringValue;\n+                } else {\n+                    minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                            + Integer.valueOf(offsetString.substring(4, 6));\n+                    timestampString = stringValue.substring(0, lastColon - 4);\n+\n+                    if (offsetString.startsWith(\"-\"))\n+                        minutesOffset = -minutesOffset;\n+                }\n \n                 /*\n                  * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1Mjk0Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426052947", "bodyText": "The test fails when I switch to:\nfileRecord.addColumnMetadata(7, \"c6\", microsoft.sql.Types.SMALLDATETIME, 0, 0); // with SmallDatetime", "author": "ulvii", "createdAt": "2020-05-15T21:21:28Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r\n+\r\n+        try (Connection conn = dsLocal.getConnection()) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(8, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(9, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyResultSet(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r", "originalCommit": "90fae3649819fe2fab94cd227d2c7ae05711ab14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MTgxNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426061817", "bodyText": "It's supposed to fail. When performing bulk copy, the users are expected to provide the correct column type. The corresponding column type for smalldatetime is TIMESTAMP, and microsoft.sql.Types.SMALLDATETIME is not a supported column type. If you were to test that scenario without my changes, it will fail as well. The table that outlines which datatypes need to be specified for each datatype for bulk copy is outlined here: https://docs.microsoft.com/en-us/sql/connect/jdbc/using-basic-data-types?view=sql-server-2017", "author": "peterbae", "createdAt": "2020-05-15T21:48:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1Mjk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMDAwNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428910007", "bodyText": "Understood.", "author": "ulvii", "createdAt": "2020-05-21T20:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1Mjk0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "3341bcbbb335812e5c648860d6831016112aaf5f", "chunk": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\nindex 6e21744b..9a064904 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java\n\n@@ -55,6 +55,7 @@ import com.microsoft.sqlserver.testframework.PrepUtil;\n @RunWith(JUnitPlatform.class)\n public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\n     static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\n+    static String inputFile2 = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy2.csv\";\n     static String encoding = \"UTF-8\";\n     static String delimiter = \",\";\n \n"}}, {"oid": "3341bcbbb335812e5c648860d6831016112aaf5f", "url": "https://github.com/microsoft/mssql-jdbc/commit/3341bcbbb335812e5c648860d6831016112aaf5f", "message": "add comment / add test cases", "committedDate": "2020-05-15T21:41:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MTEzMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426061130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            calendar = new GregorianCalendar(timeZone, Locale.CHINA);\n          \n          \n            \n                            calendar = new GregorianCalendar(timeZone);", "author": "ulvii", "createdAt": "2020-05-15T21:45:43Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,100 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            // expected format: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\n+            try {\n+                String stringValue = (String) value;\n+                int lastColon = stringValue.lastIndexOf(':');\n+\n+                String offsetString = stringValue.substring(lastColon - 3);\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+                /*\n+                 * At this point, offsetString should look like +hh:mm or -hh:mm. Otherwise, the optional offset\n+                 * value has not been provided. Parse accordingly.\n+                 */\n+                String timestampString;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+                if (!offsetString.startsWith(\"+\") && !offsetString.startsWith(\"-\")) {\n+                    minutesOffset = 0;\n+                    timestampString = stringValue;\n+                } else {\n+                    minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                            + Integer.valueOf(offsetString.substring(4, 6));\n+                    timestampString = stringValue.substring(0, lastColon - 4);\n+\n+                    if (offsetString.startsWith(\"-\"))\n+                        minutesOffset = -minutesOffset;\n+                }\n+\n+                /*\n+                 * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+                 * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+                 * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+                 * use a local time zone determined by the minutes offset of the value, since\n+                 * the writers for those types expect local calendars.\n+                 */\n+                timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                                 : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+                calendar = new GregorianCalendar(timeZone, Locale.CHINA);", "originalCommit": "3341bcbbb335812e5c648860d6831016112aaf5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ccf8b26fc83c212d84a1b93b03c09bf2e946c907", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex a4f6155b..bd013790 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n\n@@ -3642,7 +3642,7 @@ final class TDSWriter {\n                 timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n                                                                  : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n \n-                calendar = new GregorianCalendar(timeZone, Locale.CHINA);\n+                calendar = new GregorianCalendar(timeZone);\n \n                 int year = Integer.valueOf(timestampString.substring(0, 4));\n                 int month = Integer.valueOf(timestampString.substring(5, 7));\n"}}, {"oid": "ccf8b26fc83c212d84a1b93b03c09bf2e946c907", "url": "https://github.com/microsoft/mssql-jdbc/commit/ccf8b26fc83c212d84a1b93b03c09bf2e946c907", "message": "Update src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n\nCo-authored-by: ulvii <v-ulibra@microsoft.com>", "committedDate": "2020-05-15T21:49:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MjY1MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426062650", "bodyText": "Can you explain this with code comments? Also why do we have to parse for TIME, not for other types?", "author": "ulvii", "createdAt": "2020-05-15T21:50:51Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2397,8 +2468,20 @@ else if (4 >= bulkScale)\n                             tdsWriter.writeByte((byte) 0x04);\n                         else\n                             tdsWriter.writeByte((byte) 0x05);\n-\n-                        tdsWriter.writeTime((java.sql.Timestamp) colValue, bulkScale);\n+                        if (colValue instanceof String) {", "originalCommit": "3341bcbbb335812e5c648860d6831016112aaf5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2Njk0Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426066942", "bodyText": "I added comments. Other datatypes are already handled as if the data was string (this is the case for date, datetime and smalldatetime), so there was no need for extra steps. Time was the only datatype (other than DTO) that the code was assuming was coming on the form of a timestamp, so I needed to adjust accordingly.", "author": "peterbae", "createdAt": "2020-05-15T22:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MjY1MA=="}], "type": "inlineReview", "revised_code": {"commit": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "chunk": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\nindex 97de73a0..c63b8520 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java\n\n@@ -2469,6 +2469,16 @@ public class SQLServerBulkCopy implements java.lang.AutoCloseable, java.io.Seria\n                         else\n                             tdsWriter.writeByte((byte) 0x05);\n                         if (colValue instanceof String) {\n+                            /*\n+                             * if colValue is an instance of String, this means the data is coming from a CSV file.\n+                             * Time string is expected to come in with this pattern: hh:mm:ss[.nnnnnnn]\n+                             * First, look for the '.' character to determine if the String has the optional nanoseconds\n+                             * component.\n+                             * Next, create a java.sql.Time instance with the hh:mm:ss part we extracted, then set that\n+                             * time as the timestamp's time.\n+                             * Then, add the nanoseconds (optional, 0 if not provided) to the timestamp value.\n+                             * Finally, provide the timestamp value to writeTime method.\n+                             */\n                             java.sql.Timestamp ts = new java.sql.Timestamp(0);\n                             int nanos = 0;\n                             int decimalIndex = ((String) colValue).indexOf('.');\n"}}, {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "url": "https://github.com/microsoft/mssql-jdbc/commit/c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "message": "add comments", "committedDate": "2020-05-15T22:01:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3ODUwNQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427578505", "bodyText": "Need to check for connection.getSendTemporalDataTypesAsStringForBulkCopy() here too.", "author": "ulvii", "createdAt": "2020-05-19T20:25:59Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,100 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {", "originalCommit": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzQ0Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428303442", "bodyText": "The check is done before this method is called. Checking for String guarantees that that connection property is set to false, and also that the data is coming from a CSV. Near the beginning of writeColumnToTdsWriter method in SQLServerBulkCopy, this line:\n       } else if (null != serverBulkData && connection.getSendTemporalDataTypesAsStringForBulkCopy()) {\nensures that if getSendTemporalDataTypesAsStringForBulkCopy is true then bulkJdbcType will be varchar, which means that if getSendTemporalDataTypesAsStringForBulkCopy is false, we couldn't have come to this line.", "author": "peterbae", "createdAt": "2020-05-20T20:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3ODUwNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3OTExMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427579113", "bodyText": "Need to check for connection.getSendTemporalDataTypesAsStringForBulkCopy() here too.", "author": "ulvii", "createdAt": "2020-05-19T20:27:12Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2397,8 +2468,30 @@ else if (4 >= bulkScale)\n                             tdsWriter.writeByte((byte) 0x04);\n                         else\n                             tdsWriter.writeByte((byte) 0x05);\n-\n-                        tdsWriter.writeTime((java.sql.Timestamp) colValue, bulkScale);\n+                        if (colValue instanceof String) {", "originalCommit": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzgyOA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428303828", "bodyText": "Same logic applies here, but these are really good observations / questions.", "author": "peterbae", "createdAt": "2020-05-20T20:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3OTExMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427618853", "bodyText": "Please format all the files.", "author": "ulvii", "createdAt": "2020-05-19T21:45:38Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAETest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r", "originalCommit": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjIwMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428306201", "bodyText": "This file is formatted. Do you see something that should've been formatted? My formatter doesn't change anything in this file.", "author": "peterbae", "createdAt": "2020-05-20T21:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMzMDU3MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428330571", "bodyText": "The comments seem to be off.", "author": "ulvii", "createdAt": "2020-05-20T21:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2ODMwNQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428868305", "bodyText": "Which comment for example?", "author": "peterbae", "createdAt": "2020-05-21T19:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "e2e3d031c439318848d39fefcbf497740f1dab8b", "url": "https://github.com/microsoft/mssql-jdbc/commit/e2e3d031c439318848d39fefcbf497740f1dab8b", "message": "update abstractTest", "committedDate": "2020-05-21T19:33:53Z", "type": "commit"}, {"oid": "b49865f8d5732a7bff83789939bf5edcd8395f5c", "url": "https://github.com/microsoft/mssql-jdbc/commit/b49865f8d5732a7bff83789939bf5edcd8395f5c", "message": "test modifications", "committedDate": "2020-05-21T21:42:34Z", "type": "commit"}]}