{"pr_number": 8109, "pr_title": "KAFKA-9545: Fix subscription bugs from Stream refactoring", "pr_createdAt": "2020-02-13T18:10:29Z", "pr_url": "https://github.com/apache/kafka/pull/8109", "timeline": [{"oid": "6c50f63c10848b64ddbd30fb13401092d27289eb", "url": "https://github.com/apache/kafka/commit/6c50f63c10848b64ddbd30fb13401092d27289eb", "message": "resolve error", "committedDate": "2020-02-13T06:23:03Z", "type": "commit"}, {"oid": "c1121770ca210b7e64864675465bb25b4b37cf6d", "url": "https://github.com/apache/kafka/commit/c1121770ca210b7e64864675465bb25b4b37cf6d", "message": "final", "committedDate": "2020-02-13T16:21:39Z", "type": "commit"}, {"oid": "5f61f649507250b7474655d4a6ee548481c1c040", "url": "https://github.com/apache/kafka/commit/5f61f649507250b7474655d4a6ee548481c1c040", "message": "debug", "committedDate": "2020-02-13T18:01:02Z", "type": "commit"}, {"oid": "781f14cafd2390722efa10ab3b9a683661b2d721", "url": "https://github.com/apache/kafka/commit/781f14cafd2390722efa10ab3b9a683661b2d721", "message": "second fix", "committedDate": "2020-02-13T18:04:06Z", "type": "commit"}, {"oid": "ff59b3a0aa289b06b90398ab3f2807a206ab67a4", "url": "https://github.com/apache/kafka/commit/ff59b3a0aa289b06b90398ab3f2807a206ab67a4", "message": "revert debug logs", "committedDate": "2020-02-13T18:57:42Z", "type": "commit"}, {"oid": "ff59b3a0aa289b06b90398ab3f2807a206ab67a4", "url": "https://github.com/apache/kafka/commit/ff59b3a0aa289b06b90398ab3f2807a206ab67a4", "message": "revert debug logs", "committedDate": "2020-02-13T18:57:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MDIyOA==", "url": "https://github.com/apache/kafka/pull/8109#discussion_r379190228", "bodyText": "Can you elaborate a bit on this fix? Do you mean one task is subscribed to a pattern that matches multiple topics, or to two different patterns? I'm not sure I understand why either case would cause containsAll to fail.", "author": "ableegoldman", "createdAt": "2020-02-14T00:13:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -257,9 +257,11 @@ void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n         for (final Task task : tasks.values()) {\n-            if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                revokedTasks.add(task.id());\n-                remainingPartitions.removeAll(task.inputPartitions());\n+            for (final TopicPartition topicPartition : task.inputPartitions()) {", "originalCommit": "ff59b3a0aa289b06b90398ab3f2807a206ab67a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI3MzQ0Mg==", "url": "https://github.com/apache/kafka/pull/8109#discussion_r379273442", "bodyText": "What I mean here is that if one of the partitions this task owns is removed, but not all, then the old logic will not catch the revoked task by containsAll.\njava.lang.IllegalStateException: Some revoked partitions that do not belong to any tasks remain: [TEST-TOPIC-A-0]\n\tat org.apache.kafka.streams.processor.internals.TaskManager.handleRevocation(TaskManager.java:267)\n\tat org.apache.kafka.streams.processor.internals.StreamsRebalanceListener.onPartitionsRevoked(StreamsRebalanceListener.java:72)\n\tat org.apache.kafka.streams.integration.RegexSourceIntegrationTest$TheConsumerRebalanceListener.onPartitionsRevoked(RegexSourceIntegrationTest.java:422)\n\tat org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invokePartitionsRevoked(ConsumerCoordinator.java:297)\n\tat org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.onJoinPrepare(ConsumerCoordinator.java:681)\n\tat org.apache.kafka.clients.consumer.internals.AbstractCoordinator.joinGroupIfNeeded(AbstractCoordinator.java:414)\n\tat org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureActiveGroup(AbstractCoordinator.java:358)\n\tat org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.poll(ConsumerCoordinator.java:477)\n\tat org.apache.kafka.clients.consumer.KafkaConsumer.updateAssignmentMetadataIfNeeded(KafkaConsumer.java:1275)```", "author": "abbccdda", "createdAt": "2020-02-14T06:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNDY4NQ==", "url": "https://github.com/apache/kafka/pull/8109#discussion_r379534685", "bodyText": "Hmm.. why it's possible that only part of the partitions of a task is revoked? We do assignment at the granularity of tasks so this check is to verify specifically that all partitions should be included if a task is going to be removed right?", "author": "guozhangwang", "createdAt": "2020-02-14T16:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYzOTg1NQ==", "url": "https://github.com/apache/kafka/pull/8109#discussion_r379639855", "bodyText": "I think now I understand the reason that part of the partitions can be removed here.\nIf a task is indeed being removed, it should be triggered in the TaskManager#onAssignment; here TaskManager#onRevocation is triggered after the previous call so the tasks map should have been updated --- i.e. the task would not be inside task-manager anymore, and if it is due to regex pattern (like this test) the current condition is okay: we should not suspend the task unless all its input-partitions are included. Otherwise, we can just update the input partition of that task --- right now it is final so we cannot update it, but I think that\u2019s fine since we would no longer pipe any records to that task and there will be no committed offsets for that partition either --- in either case, we can remove it from the remainingPartitions.", "author": "guozhangwang", "createdAt": "2020-02-14T20:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MDIyOA=="}], "type": "inlineReview", "revised_code": {"commit": "aadad10aa96836619aa86a3212a9c98f16d76e3b", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java\nindex f889840bf1..0887303682 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java\n\n@@ -257,12 +257,10 @@ public class TaskManager {\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n         for (final Task task : tasks.values()) {\n-            for (final TopicPartition topicPartition : task.inputPartitions()) {\n-                if (remainingPartitions.contains(topicPartition)) {\n-                    revokedTasks.add(task.id());\n-                    remainingPartitions.remove(topicPartition);\n-                }\n+            if (remainingPartitions.containsAll(task.inputPartitions())) {\n+                revokedTasks.add(task.id());\n             }\n+            remainingPartitions.removeAll(task.inputPartitions());\n         }\n \n         if (!remainingPartitions.isEmpty()) {\n"}}, {"oid": "ff59b3a0aa289b06b90398ab3f2807a206ab67a4", "url": "https://github.com/apache/kafka/commit/ff59b3a0aa289b06b90398ab3f2807a206ab67a4", "message": "revert debug logs", "committedDate": "2020-02-13T18:57:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzMzk1NQ==", "url": "https://github.com/apache/kafka/pull/8109#discussion_r379533955", "bodyText": "This function is called by two callers: xxxFromMetadata and xxxFromAssignment. For the former we do not maintain the old topics but just replace with the passed in value, for the latter we still maintain the  old topics -- this it to take care if the leader did not assign all tasks / partitions due to assignment error. We should still keep that logic here.", "author": "guozhangwang", "createdAt": "2020-02-14T16:44:45Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopologyBuilder.java", "diffHunk": "@@ -1887,8 +1887,6 @@ private void updateSubscribedTopics(final Set<String> topics, final String logPr\n         final Collection<String> existingTopics = subscriptionUpdates();\n \n         if  (!existingTopics.equals(topics)) {\n-            topics.addAll(existingTopics);", "originalCommit": "ff59b3a0aa289b06b90398ab3f2807a206ab67a4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84743ffcfa73595b8bd31a837f29a597fd1a4ba6", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopologyBuilder.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopologyBuilder.java\nindex 13057473d0..6d0b0f3273 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopologyBuilder.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopologyBuilder.java\n\n@@ -1873,28 +1873,30 @@ public class InternalTopologyBuilder {\n             for (final TopicPartition topicPartition : partitions) {\n                 assignedTopics.add(topicPartition.topic());\n             }\n+\n+            final Collection<String> existingTopics = subscriptionUpdates();\n+\n+            if  (!existingTopics.equals(assignedTopics)) {\n+                assignedTopics.addAll(existingTopics);\n+            }\n             updateSubscribedTopics(assignedTopics, logPrefix);\n         }\n     }\n \n     synchronized void addSubscribedTopicsFromMetadata(final Set<String> topics, final String logPrefix) {\n-        if (usesPatternSubscription()) {\n+        if (usesPatternSubscription() && subscriptionUpdates() != topics) {\n             updateSubscribedTopics(topics, logPrefix);\n         }\n     }\n \n     private void updateSubscribedTopics(final Set<String> topics, final String logPrefix) {\n-        final Collection<String> existingTopics = subscriptionUpdates();\n-\n-        if  (!existingTopics.equals(topics)) {\n-            subscriptionUpdates.clear();\n-            subscriptionUpdates.addAll(topics);\n+        subscriptionUpdates.clear();\n+        subscriptionUpdates.addAll(topics);\n \n-            log.debug(\"{}found {} topics possibly matching subscription\", logPrefix, topics.size());\n+        log.debug(\"{}found {} topics possibly matching subscription\", logPrefix, topics.size());\n \n-            setRegexMatchedTopicsToSourceNodes();\n-            setRegexMatchedTopicToStateStore();\n-        }\n+        setRegexMatchedTopicsToSourceNodes();\n+        setRegexMatchedTopicToStateStore();\n     }\n \n     // following functions are for test only\n"}}, {"oid": "84743ffcfa73595b8bd31a837f29a597fd1a4ba6", "url": "https://github.com/apache/kafka/commit/84743ffcfa73595b8bd31a837f29a597fd1a4ba6", "message": "retain old topics for assign", "committedDate": "2020-02-15T00:11:04Z", "type": "commit"}, {"oid": "aadad10aa96836619aa86a3212a9c98f16d76e3b", "url": "https://github.com/apache/kafka/commit/aadad10aa96836619aa86a3212a9c98f16d76e3b", "message": "no revoke unless full", "committedDate": "2020-02-15T01:04:05Z", "type": "commit"}, {"oid": "aadad10aa96836619aa86a3212a9c98f16d76e3b", "url": "https://github.com/apache/kafka/commit/aadad10aa96836619aa86a3212a9c98f16d76e3b", "message": "no revoke unless full", "committedDate": "2020-02-15T01:04:05Z", "type": "forcePushed"}]}