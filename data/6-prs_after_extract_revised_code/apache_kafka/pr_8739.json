{"pr_number": 8739, "pr_title": "KAFKA-10056; Ensure consumer metadata contains new topics on subscription change", "pr_createdAt": "2020-05-28T11:17:55Z", "pr_url": "https://github.com/apache/kafka/pull/8739", "timeline": [{"oid": "63e69e9b9d89004f6bdc0ae6722e929ac8e0c3e9", "url": "https://github.com/apache/kafka/commit/63e69e9b9d89004f6bdc0ae6722e929ac8e0c3e9", "message": "KAFKA-10056; Ensure consumer metadata contains new topics on subscription change", "committedDate": "2020-05-28T11:14:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc2OTc2OQ==", "url": "https://github.com/apache/kafka/pull/8739#discussion_r431769769", "bodyText": "This seems consistent with needsMetadata method below.", "author": "rajinisivaram", "createdAt": "2020-05-28T11:35:23Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/SubscriptionState.java", "diffHunk": "@@ -345,7 +345,17 @@ synchronized boolean matchesSubscribedPattern(String topic) {\n      *   of the current generation; otherwise it returns the same set as {@link #subscription()}\n      */\n     synchronized Set<String> metadataTopics() {\n-        return groupSubscription.isEmpty() ? subscription : groupSubscription;\n+        if (groupSubscription.isEmpty())\n+            return subscription;\n+        else if (groupSubscription.containsAll(subscription))\n+            return groupSubscription;\n+        else {\n+            // When subscription changes `groupSubscription` may be outdated, ensure that\n+            // new subscription topics are returned.\n+            Set<String> topics = new HashSet<>(groupSubscription);\n+            topics.addAll(subscription);", "originalCommit": "63e69e9b9d89004f6bdc0ae6722e929ac8e0c3e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NzkxOA==", "url": "https://github.com/apache/kafka/pull/8739#discussion_r432197918", "bodyText": "I agree this change seems to make sense. I'm trying to understand the edge case a little bit better. It seems the basic scenario is the following:\n\nuser calls subscribe. subscription is updated to (A), while group subscription might be (B)\nwe call requestUpdateForNewTopics which bumps the request version\nmetadata update gets triggered and requests (B) with the bumped request version\n\nAt this point, no further metadata update will be sent, but the consumer should rebalance. The part that confuses me a little bit is that we don't request a metadata update following the rebalance.\nI guess it is due to SubscriptionState.groupSubscribe? Assuming that we remain the leader, if (A) is the only topic subscribed, then we will first change groupSubscription to (A). Then we will not request a new metadata update because groupSubscription matches subscription.\nAlternatively, if we are not the leader, we will call resetGroupSubscription, which will set groupSubscription to (), but will not request an update.\nDo I have that right?", "author": "hachikuji", "createdAt": "2020-05-29T00:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc2OTc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM1NTc3Mw==", "url": "https://github.com/apache/kafka/pull/8739#discussion_r432355773", "bodyText": "@hachikuji Thank you, yes, that is exactly right.", "author": "rajinisivaram", "createdAt": "2020-05-29T09:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc2OTc2OQ=="}], "type": "inlineReview", "revised_code": null}]}