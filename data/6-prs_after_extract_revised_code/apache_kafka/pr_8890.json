{"pr_number": 8890, "pr_title": "KAFKA-9891: add integration tests for EOS and StandbyTask", "pr_createdAt": "2020-06-17T22:06:36Z", "pr_url": "https://github.com/apache/kafka/pull/8890", "timeline": [{"oid": "386c42869d23108856cc426effc7e63438043d86", "url": "https://github.com/apache/kafka/commit/386c42869d23108856cc426effc7e63438043d86", "message": "KAFKA-9891: add integration tests for EOS and StandbyTask", "committedDate": "2020-06-19T01:06:46Z", "type": "commit"}, {"oid": "386c42869d23108856cc426effc7e63438043d86", "url": "https://github.com/apache/kafka/commit/386c42869d23108856cc426effc7e63438043d86", "message": "KAFKA-9891: add integration tests for EOS and StandbyTask", "committedDate": "2020-06-19T01:06:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5ODIwMQ==", "url": "https://github.com/apache/kafka/pull/8890#discussion_r442998201", "bodyText": "Did you mean \"stale\"?", "author": "vvcephei", "createdAt": "2020-06-19T18:54:57Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -151,6 +173,198 @@ private KafkaStreams buildStreamWithDirtyStateDir(final String stateDirPath,\n         return new KafkaStreams(builder.build(), props);\n     }\n \n+    @Test\n+    public void shouldWipeOutStandbyStateDirectoryIfCheckpointIsMissing() throws Exception {\n+        final String base = TestUtils.tempDirectory(appId).getPath();\n+\n+        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+            inputTopic,\n+            Collections.singletonList(\n+                new KeyValue<>(KEY_0, 0)\n+            ),\n+            TestUtils.producerConfig(\n+                CLUSTER.bootstrapServers(),\n+                IntegerSerializer.class,\n+                IntegerSerializer.class,\n+                new Properties()\n+            ),\n+            10L\n+        );\n+\n+        try (\n+            final KafkaStreams streamInstanceOne = buildWithDeduplicationTopology(base + \"-1\");\n+            final KafkaStreams streamInstanceTwo = buildWithDeduplicationTopology(base + \"-2\");\n+            final KafkaStreams streamInstanceOneRecovery = buildWithDeduplicationTopology(base + \"-1\")\n+        ) {\n+            // start first instance and wait for processing\n+            startApplicationAndWaitUntilRunning(Collections.singletonList(streamInstanceOne), Duration.ofSeconds(30));\n+            IntegrationTestUtils.waitUntilMinRecordsReceived(\n+                TestUtils.consumerConfig(\n+                    CLUSTER.bootstrapServers(),\n+                    IntegerDeserializer.class,\n+                    IntegerDeserializer.class\n+                ),\n+                outputTopic,\n+                1\n+            );\n+\n+            // start second instance and wait for standby replication\n+            startApplicationAndWaitUntilRunning(Collections.singletonList(streamInstanceTwo), Duration.ofSeconds(30));\n+            waitForCondition(\n+                () -> streamInstanceTwo.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    ).enableStaleStores()\n+                ).get(KEY_0) != null,\n+                REBALANCE_TIMEOUT,\n+                \"Could not get key from standby store\"\n+            );\n+            // sanity check that first instance is still active\n+            waitForCondition(\n+                () -> streamInstanceOne.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    )\n+                ).get(KEY_0) != null,\n+                \"Could not get key from main store\"\n+            );\n+\n+            // inject poison pill and wait for crash of first instance and recovery on second instance\n+            IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+                inputTopic,\n+                Collections.singletonList(\n+                    new KeyValue<>(KEY_1, 0)\n+                ),\n+                TestUtils.producerConfig(\n+                    CLUSTER.bootstrapServers(),\n+                    IntegerSerializer.class,\n+                    IntegerSerializer.class,\n+                    new Properties()\n+                ),\n+                10L\n+            );\n+            waitForCondition(\n+                () -> streamInstanceOne.state() == KafkaStreams.State.ERROR,\n+                \"Stream instance 1 did not go into error state\"\n+            );\n+            streamInstanceOne.close();\n+\n+            IntegrationTestUtils.waitUntilMinRecordsReceived(\n+                TestUtils.consumerConfig(\n+                    CLUSTER.bootstrapServers(),\n+                    IntegerDeserializer.class,\n+                    IntegerDeserializer.class\n+                ),\n+                outputTopic,\n+                2\n+            );\n+\n+            // \"restart\" first client and wait for standby recovery\n+            // (could actually also be active, but it does not matter as long as we enable \"state stores\"", "originalCommit": "386c42869d23108856cc426effc7e63438043d86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5OTA3Mw==", "url": "https://github.com/apache/kafka/pull/8890#discussion_r442999073", "bodyText": "Do we really need this? It seems like the only thing that depends on knowing which instance would get the active is just waiting for the crash after the poison pill. Could we instead just wait for once of the instances to crash, but not worry about which?", "author": "vvcephei", "createdAt": "2020-06-19T18:57:04Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -162,6 +376,8 @@ private Properties props(final String stateDirPath) {\n         streamsConfiguration.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.Integer().getClass());\n         streamsConfiguration.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.Integer().getClass());\n         streamsConfiguration.put(StreamsConfig.COMMIT_INTERVAL_MS_CONFIG, 1000);\n+        // need to set to zero to get predictable active/standby task assignments\n+        streamsConfiguration.put(StreamsConfig.ACCEPTABLE_RECOVERY_LAG_CONFIG, 0);", "originalCommit": "386c42869d23108856cc426effc7e63438043d86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAyMTIxNA==", "url": "https://github.com/apache/kafka/pull/8890#discussion_r443021214", "bodyText": "Yes. It's for the first phase of the test. We start the first instance and let it process the first record. As there is not enough capacity, no standby is scheduled. When we start the second instance, with \"lag=0\" setting, we ensure that the standby is placed at instance two. With default setting, we don't know which instance will get the active/standby assigned. -> when we inject the poison pill, we know that instance one will fail as it hosts the active.", "author": "mjsax", "createdAt": "2020-06-19T19:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5OTA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAyMjAxNg==", "url": "https://github.com/apache/kafka/pull/8890#discussion_r443022016", "bodyText": "Right, this was my suggestion:\n\nCould we instead just wait for once of the instances to crash, but not worry about which?", "author": "vvcephei", "createdAt": "2020-06-19T20:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5OTA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAyNDM5NQ==", "url": "https://github.com/apache/kafka/pull/8890#discussion_r443024395", "bodyText": "Well, it make the test more complex, because all the following code depends on instance one failing.", "author": "mjsax", "createdAt": "2020-06-19T20:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5OTA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAyODQxNw==", "url": "https://github.com/apache/kafka/pull/8890#discussion_r443028417", "bodyText": "Ok, it's your call. I think this might make the tests flaky, but I guess we can figure that out later.", "author": "vvcephei", "createdAt": "2020-06-19T20:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5OTA3Mw=="}], "type": "inlineReview", "revised_code": null}]}