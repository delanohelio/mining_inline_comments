{"pr_number": 8238, "pr_title": "KAFKA-9130: KIP-518 Allow listing consumer groups per state", "pr_createdAt": "2020-03-06T16:31:31Z", "pr_url": "https://github.com/apache/kafka/pull/8238", "timeline": [{"oid": "88e7a0ca4f15c3816c9f49ef1e4ffc0c1d36f4cc", "url": "https://github.com/apache/kafka/commit/88e7a0ca4f15c3816c9f49ef1e4ffc0c1d36f4cc", "message": "KAFKA-9130: KIP-518 Allow listing consumer groups per state\n\nCo-authored-by: Mickael Maison <mickael.maison@gmail.com>\nCo-authored-by: Edoardo Comar <ecomar@uk.ibm.com>", "committedDate": "2020-04-30T14:28:24Z", "type": "commit"}, {"oid": "143514cc2a880e2896085cdeb34cc697d62296ab", "url": "https://github.com/apache/kafka/commit/143514cc2a880e2896085cdeb34cc697d62296ab", "message": "Add test in admin e2e", "committedDate": "2020-04-30T14:28:24Z", "type": "commit"}, {"oid": "badbc1a40e59fdb56ba53c3f9c8633a705da085d", "url": "https://github.com/apache/kafka/commit/badbc1a40e59fdb56ba53c3f9c8633a705da085d", "message": "First pass at addressing feedback", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "b243a61df164637072453ec1a32ea1cdbfdb4ba1", "url": "https://github.com/apache/kafka/commit/b243a61df164637072453ec1a32ea1cdbfdb4ba1", "message": "Addressed comments", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "145b6897390097d93dfedc52036ac2e48906e96a", "url": "https://github.com/apache/kafka/commit/145b6897390097d93dfedc52036ac2e48906e96a", "message": "addressed a couple of comments and CLI's list state formatting", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "a0247b048d6a7f70fb225c82557bec300c69a6a7", "url": "https://github.com/apache/kafka/commit/a0247b048d6a7f70fb225c82557bec300c69a6a7", "message": "Address latest feedback", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "4bed4d3b2a2f45dc9993bb511bfb6deeb3330585", "url": "https://github.com/apache/kafka/commit/4bed4d3b2a2f45dc9993bb511bfb6deeb3330585", "message": "testDescribeWithMultipleSubActions", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "d6102e8f3025f70004bb3081785708af76f2855e", "url": "https://github.com/apache/kafka/commit/d6102e8f3025f70004bb3081785708af76f2855e", "message": "Address feedback", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "d6102e8f3025f70004bb3081785708af76f2855e", "url": "https://github.com/apache/kafka/commit/d6102e8f3025f70004bb3081785708af76f2855e", "message": "Address feedback", "committedDate": "2020-04-30T14:39:37Z", "type": "forcePushed"}, {"oid": "5854e560da240c68f48b44996f085d37aca9d254", "url": "https://github.com/apache/kafka/commit/5854e560da240c68f48b44996f085d37aca9d254", "message": "Improve error reporting", "committedDate": "2020-04-30T20:06:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2NDMyOA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r426864328", "bodyText": "Probably worth adding a comment about broker compatibility with this API.", "author": "hachikuji", "createdAt": "2020-05-18T20:04:11Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java", "diffHunk": "@@ -26,4 +31,34 @@\n  */\n @InterfaceStability.Evolving\n public class ListConsumerGroupsOptions extends AbstractOptions<ListConsumerGroupsOptions> {\n+\n+    private Optional<Set<ConsumerGroupState>> states = Optional.empty();\n+\n+    /**\n+     * Only groups in these states will be returned by listConsumerGroups()", "originalCommit": "5854e560da240c68f48b44996f085d37aca9d254", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3OTE4MQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r432179181", "bodyText": "Can you address this comment?", "author": "hachikuji", "createdAt": "2020-05-28T23:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2NDMyOA=="}], "type": "inlineReview", "revised_code": {"commit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java b/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java\nindex 72e6af9097..81fffe06c6 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java\n\n@@ -32,18 +32,14 @@ import org.apache.kafka.common.annotation.InterfaceStability;\n @InterfaceStability.Evolving\n public class ListConsumerGroupsOptions extends AbstractOptions<ListConsumerGroupsOptions> {\n \n-    private Optional<Set<ConsumerGroupState>> states = Optional.empty();\n+    private Set<ConsumerGroupState> states = Collections.emptySet();\n \n     /**\n      * Only groups in these states will be returned by listConsumerGroups()\n-     * If not set, all groups are returned without their states\n-     * throw IllegalArgumentException if states is empty\n+     * If not set, all groups are returned with their states\n      */\n     public ListConsumerGroupsOptions inStates(Set<ConsumerGroupState> states) {\n-        if (states == null || states.isEmpty()) {\n-            throw new IllegalArgumentException(\"states should not be null or empty\");\n-        }\n-        this.states = Optional.of(states);\n+        this.states = (states == null) ? Collections.emptySet() : new HashSet<>(states);\n         return this;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2ODc3Nw==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r426868777", "bodyText": "Hmm.. We have an UNKNOWN state in ConsumerGroupState in case the group coordinator adds a new state that the client isn't aware of. Currently we're going to pass this through the request, which is a bit odd. Furthermore, if the coordinator does add new states, we will be unable to see them using this API. I think it might be better to use a null list of states in the request to indicate that any state is needed.", "author": "hachikuji", "createdAt": "2020-05-18T20:13:50Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java", "diffHunk": "@@ -26,4 +31,34 @@\n  */\n @InterfaceStability.Evolving\n public class ListConsumerGroupsOptions extends AbstractOptions<ListConsumerGroupsOptions> {\n+\n+    private Optional<Set<ConsumerGroupState>> states = Optional.empty();\n+\n+    /**\n+     * Only groups in these states will be returned by listConsumerGroups()\n+     * If not set, all groups are returned without their states\n+     * throw IllegalArgumentException if states is empty\n+     */\n+    public ListConsumerGroupsOptions inStates(Set<ConsumerGroupState> states) {\n+        if (states == null || states.isEmpty()) {\n+            throw new IllegalArgumentException(\"states should not be null or empty\");\n+        }\n+        this.states = Optional.of(states);\n+        return this;\n+    }\n+\n+    /**\n+     * All groups with their states will be returned by listConsumerGroups()\n+     */\n+    public ListConsumerGroupsOptions inAnyState() {\n+        this.states = Optional.of(EnumSet.allOf(ConsumerGroupState.class));", "originalCommit": "5854e560da240c68f48b44996f085d37aca9d254", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEzMTAwMg==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r429131002", "bodyText": "That's a good point so I agree, it makes sense to return all states when null (or an empty list) is used.", "author": "mimaison", "createdAt": "2020-05-22T09:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2ODc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEzNjA1OA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r429136058", "bodyText": "This can also be argued for the state value in the response. Currently ConsumerGroupDescription stores the state as ConsumerGroupState so states the client isn't aware of are mapped to UNKNOWN so I'm doing the same in ConsumerGroupListing.", "author": "mimaison", "createdAt": "2020-05-22T09:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2ODc3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java b/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java\nindex 72e6af9097..81fffe06c6 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java\n\n@@ -32,18 +32,14 @@ import org.apache.kafka.common.annotation.InterfaceStability;\n @InterfaceStability.Evolving\n public class ListConsumerGroupsOptions extends AbstractOptions<ListConsumerGroupsOptions> {\n \n-    private Optional<Set<ConsumerGroupState>> states = Optional.empty();\n+    private Set<ConsumerGroupState> states = Collections.emptySet();\n \n     /**\n      * Only groups in these states will be returned by listConsumerGroups()\n-     * If not set, all groups are returned without their states\n-     * throw IllegalArgumentException if states is empty\n+     * If not set, all groups are returned with their states\n      */\n     public ListConsumerGroupsOptions inStates(Set<ConsumerGroupState> states) {\n-        if (states == null || states.isEmpty()) {\n-            throw new IllegalArgumentException(\"states should not be null or empty\");\n-        }\n-        this.states = Optional.of(states);\n+        this.states = (states == null) ? Collections.emptySet() : new HashSet<>(states);\n         return this;\n     }\n \n"}}, {"oid": "1f032e71c50411ecff2d99f86e523e02dd560c32", "url": "https://github.com/apache/kafka/commit/1f032e71c50411ecff2d99f86e523e02dd560c32", "message": "Addressed feedback\n\n- Switch to use regular fields instead of tagged fields\n- Empty/null state filter now means all states", "committedDate": "2020-05-22T08:57:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU2ODkwOQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431568909", "bodyText": "Hmm, seems this is a public class. Would it be safer to add a constructor overload?", "author": "hachikuji", "createdAt": "2020-05-28T04:02:14Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java", "diffHunk": "@@ -17,22 +17,30 @@\n \n package org.apache.kafka.clients.admin;\n \n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.kafka.common.ConsumerGroupState;\n+\n /**\n  * A listing of a consumer group in the cluster.\n  */\n public class ConsumerGroupListing {\n     private final String groupId;\n     private final boolean isSimpleConsumerGroup;\n+    private final Optional<ConsumerGroupState> state;\n \n     /**\n      * Create an instance with the specified parameters.\n      *\n      * @param groupId Group Id\n      * @param isSimpleConsumerGroup If consumer group is simple or not.\n+     * @param state The state of the consumer group\n      */\n-    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup) {\n+    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup, Optional<ConsumerGroupState> state) {", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "499b15b40039927ec5b6a599024a082e001b456e", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java b/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java\nindex 40d9612962..989fbfd932 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java\n\n@@ -30,6 +30,16 @@ public class ConsumerGroupListing {\n     private final boolean isSimpleConsumerGroup;\n     private final Optional<ConsumerGroupState> state;\n \n+    /**\n+     * Create an instance with the specified parameters.\n+     *\n+     * @param groupId Group Id\n+     * @param isSimpleConsumerGroup If consumer group is simple or not.\n+     */\n+    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup) {\n+        this(groupId, isSimpleConsumerGroup, Optional.empty());\n+    }\n+\n     /**\n      * Create an instance with the specified parameters.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU2OTAwOA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431569008", "bodyText": "nit: maybe use requireNonNull?", "author": "hachikuji", "createdAt": "2020-05-28T04:02:38Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java", "diffHunk": "@@ -17,22 +17,30 @@\n \n package org.apache.kafka.clients.admin;\n \n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.kafka.common.ConsumerGroupState;\n+\n /**\n  * A listing of a consumer group in the cluster.\n  */\n public class ConsumerGroupListing {\n     private final String groupId;\n     private final boolean isSimpleConsumerGroup;\n+    private final Optional<ConsumerGroupState> state;\n \n     /**\n      * Create an instance with the specified parameters.\n      *\n      * @param groupId Group Id\n      * @param isSimpleConsumerGroup If consumer group is simple or not.\n+     * @param state The state of the consumer group\n      */\n-    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup) {\n+    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup, Optional<ConsumerGroupState> state) {\n         this.groupId = groupId;\n         this.isSimpleConsumerGroup = isSimpleConsumerGroup;\n+        this.state = state;", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "499b15b40039927ec5b6a599024a082e001b456e", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java b/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java\nindex 40d9612962..989fbfd932 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java\n\n@@ -30,6 +30,16 @@ public class ConsumerGroupListing {\n     private final boolean isSimpleConsumerGroup;\n     private final Optional<ConsumerGroupState> state;\n \n+    /**\n+     * Create an instance with the specified parameters.\n+     *\n+     * @param groupId Group Id\n+     * @param isSimpleConsumerGroup If consumer group is simple or not.\n+     */\n+    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup) {\n+        this(groupId, isSimpleConsumerGroup, Optional.empty());\n+    }\n+\n     /**\n      * Create an instance with the specified parameters.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5NTU5NA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431595594", "bodyText": "nit: I think the parenthesis are unnecessary?", "author": "hachikuji", "createdAt": "2020-05-28T05:50:07Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -3052,14 +3052,23 @@ void handleResponse(AbstractResponse abstractResponse) {\n                     runnable.call(new Call(\"listConsumerGroups\", deadline, new ConstantNodeIdProvider(node.id())) {\n                         @Override\n                         ListGroupsRequest.Builder createRequest(int timeoutMs) {\n-                            return new ListGroupsRequest.Builder(new ListGroupsRequestData());\n+                            List<String> states = (options.states().isEmpty())", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "499b15b40039927ec5b6a599024a082e001b456e", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java b/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java\nindex 471626cb1d..e74c04d347 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java\n\n@@ -3052,7 +3052,7 @@ public class KafkaAdminClient extends AdminClient {\n                     runnable.call(new Call(\"listConsumerGroups\", deadline, new ConstantNodeIdProvider(node.id())) {\n                         @Override\n                         ListGroupsRequest.Builder createRequest(int timeoutMs) {\n-                            List<String> states = (options.states().isEmpty())\n+                            List<String> states = options.states().isEmpty()\n                                     ? null\n                                     : options.states()\n                                         .stream()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5NjA1Ng==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431596056", "bodyText": "Do we need this API? Seems this is the default behavior.", "author": "hachikuji", "createdAt": "2020-05-28T05:51:31Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java", "diffHunk": "@@ -26,4 +31,30 @@\n  */\n @InterfaceStability.Evolving\n public class ListConsumerGroupsOptions extends AbstractOptions<ListConsumerGroupsOptions> {\n+\n+    private Set<ConsumerGroupState> states = Collections.emptySet();\n+\n+    /**\n+     * Only groups in these states will be returned by listConsumerGroups()\n+     * If not set, all groups are returned with their states\n+     */\n+    public ListConsumerGroupsOptions inStates(Set<ConsumerGroupState> states) {\n+        this.states = (states == null) ? Collections.emptySet() : new HashSet<>(states);\n+        return this;\n+    }\n+\n+    /**\n+     * All groups with their states will be returned by listConsumerGroups()\n+     */\n+    public ListConsumerGroupsOptions inAnyState() {", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "499b15b40039927ec5b6a599024a082e001b456e", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java b/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java\nindex 81fffe06c6..e64add431a 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java\n\n@@ -43,14 +43,6 @@ public class ListConsumerGroupsOptions extends AbstractOptions<ListConsumerGroup\n         return this;\n     }\n \n-    /**\n-     * All groups with their states will be returned by listConsumerGroups()\n-     */\n-    public ListConsumerGroupsOptions inAnyState() {\n-        this.states = Collections.emptySet();\n-        return this;\n-    }\n-\n     /**\n      * Returns the list of States that are requested or empty if no states have been specified\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5ODQ0MA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431598440", "bodyText": "It's a little odd that we go on and match the request if it is expected to raise an unsupported version error. Do we have test cases that depend on this? In NetworkClient, if we hit an unsupported version error, the response body would be null.", "author": "hachikuji", "createdAt": "2020-05-28T05:59:12Z", "path": "clients/src/test/java/org/apache/kafka/clients/MockClient.java", "diffHunk": "@@ -215,15 +215,22 @@ public void send(ClientRequest request, long now) {\n             AbstractRequest.Builder<?> builder = request.requestBuilder();\n             short version = nodeApiVersions.latestUsableVersion(request.apiKey(), builder.oldestAllowedVersion(),\n                     builder.latestAllowedVersion());\n-            AbstractRequest abstractRequest = request.requestBuilder().build(version);\n-            if (!futureResp.requestMatcher.matches(abstractRequest))\n-                throw new IllegalStateException(\"Request matcher did not match next-in-line request \" + abstractRequest + \" with prepared response \" + futureResp.responseBody);\n \n             UnsupportedVersionException unsupportedVersionException = null;\n             if (futureResp.isUnsupportedRequest)\n-                unsupportedVersionException = new UnsupportedVersionException(\"Api \" +\n-                        request.apiKey() + \" with version \" + version);\n-\n+                unsupportedVersionException = new UnsupportedVersionException(\n+                        \"Api \" + request.apiKey() + \" with version \" + version);\n+            try {\n+                AbstractRequest abstractRequest = request.requestBuilder().build(version);", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "56f839afcf1d4c956cb807f6d4cdf79cf8f88d55", "chunk": "diff --git a/clients/src/test/java/org/apache/kafka/clients/MockClient.java b/clients/src/test/java/org/apache/kafka/clients/MockClient.java\nindex 8948e9296a..6cfc4fd8d3 100644\n--- a/clients/src/test/java/org/apache/kafka/clients/MockClient.java\n+++ b/clients/src/test/java/org/apache/kafka/clients/MockClient.java\n\n@@ -217,19 +217,14 @@ public class MockClient implements KafkaClient {\n                     builder.latestAllowedVersion());\n \n             UnsupportedVersionException unsupportedVersionException = null;\n-            if (futureResp.isUnsupportedRequest)\n+            if (futureResp.isUnsupportedRequest) {\n                 unsupportedVersionException = new UnsupportedVersionException(\n                         \"Api \" + request.apiKey() + \" with version \" + version);\n-            try {\n+            } else {\n                 AbstractRequest abstractRequest = request.requestBuilder().build(version);\n                 if (!futureResp.requestMatcher.matches(abstractRequest))\n                     throw new IllegalStateException(\"Request matcher did not match next-in-line request \"\n                             + abstractRequest + \" with prepared response \" + futureResp.responseBody);\n-\n-            } catch (UnsupportedVersionException uve) {\n-                if (unsupportedVersionException == null) {\n-                    throw uve;\n-                }\n             }\n             ClientResponse resp = new ClientResponse(request.makeHeader(version), request.callback(), request.destination(),\n                     request.createdTimeMs(), time.milliseconds(), futureResp.disconnected,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5OTIzNg==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431599236", "bodyText": "nit: you can use TestUtils.assertFutureThrows", "author": "hachikuji", "createdAt": "2020-05-28T06:01:37Z", "path": "clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java", "diffHunk": "@@ -1312,6 +1324,79 @@ public void testListConsumerGroupsMetadataFailure() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testListConsumerGroupsWithStates() throws Exception {\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(mockCluster(1, 0))) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(env.cluster(), Errors.NONE));\n+\n+            env.kafkaClient().prepareResponseFrom(\n+                new ListGroupsResponse(new ListGroupsResponseData()\n+                    .setErrorCode(Errors.NONE.code())\n+                    .setGroups(Arrays.asList(\n+                            new ListGroupsResponseData.ListedGroup()\n+                                .setGroupId(\"group-1\")\n+                                .setProtocolType(ConsumerProtocol.PROTOCOL_TYPE)\n+                                .setGroupState(\"Stable\"),\n+                            new ListGroupsResponseData.ListedGroup()\n+                                .setGroupId(\"group-2\")\n+                                .setGroupState(\"Empty\")))),\n+                env.cluster().nodeById(0));\n+\n+            final ListConsumerGroupsOptions options = new ListConsumerGroupsOptions().inAnyState();\n+            final ListConsumerGroupsResult result = env.adminClient().listConsumerGroups(options);\n+            Collection<ConsumerGroupListing> listings = result.valid().get();\n+\n+            assertEquals(2, listings.size());\n+            List<ConsumerGroupListing> expected = new ArrayList<>();\n+            expected.add(new ConsumerGroupListing(\"group-2\", true, Optional.of(ConsumerGroupState.EMPTY)));\n+            expected.add(new ConsumerGroupListing(\"group-1\", false, Optional.of(ConsumerGroupState.STABLE)));\n+            assertEquals(expected, listings);\n+            assertEquals(0, result.errors().get().size());\n+        }\n+    }\n+\n+    @Test\n+    public void testListConsumerGroupsWithStatesOlderBrokerVersion() throws Exception {\n+        ApiVersion listGroupV3 = new ApiVersion(ApiKeys.LIST_GROUPS.id, (short) 0, (short) 3);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(mockCluster(1, 0))) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create(Collections.singletonList(listGroupV3)));\n+\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(env.cluster(), Errors.NONE));\n+\n+            // Check we can list groups with older broker if we don't specify states\n+            env.kafkaClient().prepareResponseFrom(\n+                    new ListGroupsResponse(new ListGroupsResponseData()\n+                        .setErrorCode(Errors.NONE.code())\n+                        .setGroups(Collections.singletonList(\n+                                new ListGroupsResponseData.ListedGroup()\n+                                    .setGroupId(\"group-1\")\n+                                    .setProtocolType(ConsumerProtocol.PROTOCOL_TYPE)))),\n+                    env.cluster().nodeById(0));\n+            ListConsumerGroupsOptions options = new ListConsumerGroupsOptions().inAnyState();\n+            ListConsumerGroupsResult result = env.adminClient().listConsumerGroups(options);\n+            Collection<ConsumerGroupListing> listing = result.all().get();\n+            assertEquals(1, listing.size());\n+            List<ConsumerGroupListing> expected = Collections.singletonList(new ConsumerGroupListing(\"group-1\", false, Optional.empty()));\n+            assertEquals(expected, listing);\n+\n+            // But we cannot set a state filter with older broker\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(env.cluster(), Errors.NONE));\n+            env.kafkaClient().prepareUnsupportedVersionResponse(\n+                body -> body instanceof ListGroupsRequest);\n+\n+            options = new ListConsumerGroupsOptions().inStates(Collections.singleton(ConsumerGroupState.STABLE));\n+            result = env.adminClient().listConsumerGroups(options);\n+            try {\n+                result.all().get();\n+                fail(\"Should have thrown\");", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "499b15b40039927ec5b6a599024a082e001b456e", "chunk": "diff --git a/clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java b/clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java\nindex 742d1d84b6..ba578f3492 100644\n--- a/clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java\n+++ b/clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java\n\n@@ -1344,7 +1344,7 @@ public class KafkaAdminClientTest {\n                                 .setGroupState(\"Empty\")))),\n                 env.cluster().nodeById(0));\n \n-            final ListConsumerGroupsOptions options = new ListConsumerGroupsOptions().inAnyState();\n+            final ListConsumerGroupsOptions options = new ListConsumerGroupsOptions();\n             final ListConsumerGroupsResult result = env.adminClient().listConsumerGroups(options);\n             Collection<ConsumerGroupListing> listings = result.valid().get();\n \n"}}, {"oid": "499b15b40039927ec5b6a599024a082e001b456e", "url": "https://github.com/apache/kafka/commit/499b15b40039927ec5b6a599024a082e001b456e", "message": "Address some of the feedback", "committedDate": "2020-05-28T12:38:23Z", "type": "commit"}, {"oid": "56f839afcf1d4c956cb807f6d4cdf79cf8f88d55", "url": "https://github.com/apache/kafka/commit/56f839afcf1d4c956cb807f6d4cdf79cf8f88d55", "message": "Address some of the feedback", "committedDate": "2020-05-28T18:40:02Z", "type": "commit"}, {"oid": "5e18e5c03c29a33e9098418b98c2c67843624c5b", "url": "https://github.com/apache/kafka/commit/5e18e5c03c29a33e9098418b98c2c67843624c5b", "message": "Address comments", "committedDate": "2020-05-28T20:53:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3ODcwNg==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r432178706", "bodyText": "nit: usually we would write this is this.state = requireNonNull(state);", "author": "hachikuji", "createdAt": "2020-05-28T23:29:53Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java", "diffHunk": "@@ -31,8 +37,21 @@\n      * @param isSimpleConsumerGroup If consumer group is simple or not.\n      */\n     public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup) {\n+        this(groupId, isSimpleConsumerGroup, Optional.empty());\n+    }\n+\n+    /**\n+     * Create an instance with the specified parameters.\n+     *\n+     * @param groupId Group Id\n+     * @param isSimpleConsumerGroup If consumer group is simple or not.\n+     * @param state The state of the consumer group\n+     */\n+    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup, Optional<ConsumerGroupState> state) {\n+        Objects.requireNonNull(state);\n         this.groupId = groupId;\n         this.isSimpleConsumerGroup = isSimpleConsumerGroup;\n+        this.state = state;", "originalCommit": "5e18e5c03c29a33e9098418b98c2c67843624c5b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "acb64f32f6fc2353dcaec2be44d05c6cd1a77b2d", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java b/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java\nindex 989fbfd932..0abc3e01ca 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java\n\n@@ -48,10 +48,9 @@ public class ConsumerGroupListing {\n      * @param state The state of the consumer group\n      */\n     public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup, Optional<ConsumerGroupState> state) {\n-        Objects.requireNonNull(state);\n         this.groupId = groupId;\n         this.isSimpleConsumerGroup = isSimpleConsumerGroup;\n-        this.state = state;\n+        this.state = Objects.requireNonNull(state);\n     }\n \n     /**\n"}}, {"oid": "acb64f32f6fc2353dcaec2be44d05c6cd1a77b2d", "url": "https://github.com/apache/kafka/commit/acb64f32f6fc2353dcaec2be44d05c6cd1a77b2d", "message": "Address last round of reviews", "committedDate": "2020-05-29T09:30:35Z", "type": "commit"}]}