{"pr_number": 9107, "pr_title": "KAFKA-5488: Add type-safe split() operator", "pr_createdAt": "2020-07-30T22:30:31Z", "pr_url": "https://github.com/apache/kafka/pull/9107", "timeline": [{"oid": "8a77301eb628e6684768a5405144a0d02ed17ac2", "url": "https://github.com/apache/kafka/commit/8a77301eb628e6684768a5405144a0d02ed17ac2", "message": "Documentation update", "committedDate": "2020-12-20T15:53:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4NzUyMQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547587521", "bodyText": "nit: should be one line (easier to read)", "author": "mjsax", "createdAt": "2020-12-23T01:16:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 742fd02d2d..8688fe8638 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -16,6 +16,7 @@\n  */\n package org.apache.kafka.streams.kstream;\n \n+import java.util.Objects;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4NzkzOA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547587938", "bodyText": "nit: {@link ' -> {@code(we should use@linkto link to other classes but use@code` to refer to ourself -- there is no point in letting a JavaDoc page link to itself.\nSimilar below.", "author": "mjsax", "createdAt": "2020-12-23T01:17:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 742fd02d2d..8688fe8638 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -16,6 +16,7 @@\n  */\n package org.apache.kafka.streams.kstream;\n \n+import java.util.Objects;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4ODUwNQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547588505", "bodyText": "nit: can you first have all the static builder methods and the instance methods at the end of the class?", "author": "mjsax", "createdAt": "2020-12-23T01:20:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 742fd02d2d..8688fe8638 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -16,6 +16,7 @@\n  */\n package org.apache.kafka.streams.kstream;\n \n+import java.util.Objects;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4ODgwMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547588803", "bodyText": "nit supposed -> used ?\nthis function -> the provided function", "author": "mjsax", "createdAt": "2020-12-23T01:21:33Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NzEzNQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547597135", "bodyText": "Actually, I am wondering if we should allow to pass in null? Thoughts?", "author": "mjsax", "createdAt": "2020-12-23T01:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4ODgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMzgyNA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548503824", "bodyText": "See my reply below, where we discuss null consumers: #9107 (comment)\n(in short: I agree, I think we shouldn't)", "author": "inponomarev", "createdAt": "2020-12-24T11:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4ODgwMw=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 742fd02d2d..8688fe8638 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -16,6 +16,7 @@\n  */\n package org.apache.kafka.streams.kstream;\n \n+import java.util.Objects;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4OTU3MA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547589570", "bodyText": "If a non-null branch is provided here? (branch -> consumer?)\nBut I would propose to simplify it, and just use By default (as passing in a non-null consumer should be the \"default\" usage).", "author": "mjsax", "createdAt": "2020-12-23T01:24:46Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain) {\r\n+        return new Branched<>(null, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain consumer.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NzI5Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547597293", "bodyText": "As above, should we even allow a not-null consumer?", "author": "mjsax", "createdAt": "2020-12-23T01:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4OTU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUxNTUyNg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548515526", "bodyText": "see #9107 (comment)", "author": "inponomarev", "createdAt": "2020-12-24T12:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4OTU3MA=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 742fd02d2d..8688fe8638 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -16,6 +16,7 @@\n  */\n package org.apache.kafka.streams.kstream;\n \n+import java.util.Objects;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDAyNw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547590027", "bodyText": "If {@code null} is passed instead of an actual consumer, the branch will be added unmodified to the resulting {@code Map}.", "author": "mjsax", "createdAt": "2020-12-23T01:26:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain) {\r\n+        return new Branched<>(null, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain consumer.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r\n+     *              the respective branch will not be added to the resulting {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NzY4Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547597683", "bodyText": "I tried to read up on the KIP discussion thread, and I am wondering if we did agree to this behavior? My understanding was that if a consumer is use, there won't be any entry in the Map for this branch?", "author": "mjsax", "createdAt": "2020-12-23T01:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUxNTE4MQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548515181", "bodyText": "OK let me explain how I understood this:\nLet's try to forget about Java type system and look at the problem conceptually, from set / category theory point of view\nWe're using either function or consumer or nothing for branch processing. From mathematical point of view, we can consider consumer to be a function that maps its domain to the empty set. This explains our decision why consumer 'swallows' branch unlike function that 'forwards' its result to the resulting map. Then we agreed that the case when nothing is provided, like in this example\nBranchedKStream<Integer, String> branch = source.split()\n          .branch(isEven)\n          .branch(isMultipleOfSeven);\nis to be interpreted like\nBranchedKStream<Integer, String> branch = source.split()\n         .branch(isEven, Branched.withFunction(Function.identity()))\n         .branch(isMultipleOfSeven, Branched.withFunction(Function.identity()));\nNow back to Java: in Java, for nothing we have null. My original intention was to try to emulate Function|Consumer union type using overloading, but Java didn't allow me to do this dirty trick -- and separate withFunction and withConsumer builder methods appeared \ud83d\ude04\nIf I had succeded, it would have made sence to treat null uniformely for both functions and consumers.\nHope this explains why I allowed nulls and always treated it as an identity function.\nBut now I think you're right. It's best to just prohibit passing in nulls and throw explicit NPEs for both functions and consumers. This, at least, can spare us from further debates :-)", "author": "inponomarev", "createdAt": "2020-12-24T12:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Mzk0Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549543943", "bodyText": "SGTM. In general, even if possible, I don't like to give null semantics :)", "author": "mjsax", "createdAt": "2020-12-29T02:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDAyNw=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 742fd02d2d..8688fe8638 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -16,6 +16,7 @@\n  */\n package org.apache.kafka.streams.kstream;\n \n+import java.util.Objects;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDI2OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547590269", "bodyText": "nit: formatting\nfinal Function<? super KStream<K, V>, ? extends KStream<K, V>> chain,\nfinal String name) {", "author": "mjsax", "createdAt": "2020-12-23T01:27:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain) {\r\n+        return new Branched<>(null, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain consumer.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r\n+     *              the respective branch will not be added to the resulting {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\r\n+     *              and the branch will be added to the resulting {@code Map}.\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\r\n+        return new Branched<K, V>(null, null, chain);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *              (see {@link BranchedKStream} description for details)\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain, final String name) {\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 742fd02d2d..8688fe8638 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -16,6 +16,7 @@\n  */\n package org.apache.kafka.streams.kstream;\n \n+import java.util.Objects;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDM3Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547590377", "bodyText": "used\nIf the provided function", "author": "mjsax", "createdAt": "2020-12-23T01:27:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain) {\r\n+        return new Branched<>(null, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain consumer.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r\n+     *              the respective branch will not be added to the resulting {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\r\n+     *              and the branch will be added to the resulting {@code Map}.\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\r\n+        return new Branched<K, V>(null, null, chain);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 742fd02d2d..8688fe8638 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -16,6 +16,7 @@\n  */\n package org.apache.kafka.streams.kstream;\n \n+import java.util.Objects;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDU2Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547590567", "bodyText": "as above", "author": "mjsax", "createdAt": "2020-12-23T01:28:39Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain) {\r\n+        return new Branched<>(null, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain consumer.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r\n+     *              the respective branch will not be added to the resulting {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\r\n+     *              and the branch will be added to the resulting {@code Map}.\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\r\n+        return new Branched<K, V>(null, null, chain);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *              (see {@link BranchedKStream} description for details)\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain, final String name) {\r\n+        return new Branched<>(name, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 742fd02d2d..8688fe8638 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -16,6 +16,7 @@\n  */\n package org.apache.kafka.streams.kstream;\n \n+import java.util.Objects;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MTIxMA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547591210", "bodyText": "Maybe add a note that not all branches are added to the Map?", "author": "mjsax", "createdAt": "2020-12-23T01:31:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUxOTI2OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548519269", "bodyText": "Rephrased: if certain conditions are met, it also can be accessed from the {@link Map}... -- and all these coditions are described below", "author": "inponomarev", "createdAt": "2020-12-24T12:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MTIxMA=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MTUxMQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547591511", "bodyText": "you can apply [multiple] {#filter} [operators], one for each predicate, instead", "author": "mjsax", "createdAt": "2020-12-23T01:32:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MTY4Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547591683", "bodyText": "nit: Do we need a new paragraph? We get a list below anyway.", "author": "mjsax", "createdAt": "2020-12-23T01:33:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MTkwMQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547591901", "bodyText": "If a [branch?] name is provided [in] {@link BranchedKStream#branch(Predicate, Branched)} via the {@link Branched} parameter", "author": "mjsax", "createdAt": "2020-12-23T01:34:21Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjMyNw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592327", "bodyText": "nit: missing . at the end", "author": "mjsax", "createdAt": "2020-12-23T01:36:00Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjM2OA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592368", "bodyText": "nit: missing . at the end", "author": "mjsax", "createdAt": "2020-12-23T01:36:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUyMTM3OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548521379", "bodyText": "Do we use dots at the end of list items? (Sorry -- English is my second language so I really don't know. I noticed that sometimes you do but in most cases you don't. In Russian language we must always use dots or commas at the end of list items, but Russian and English punctuations are completely different.)", "author": "inponomarev", "createdAt": "2020-12-24T12:49:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjM2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzODU5OA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549538598", "bodyText": "Also my second language... I think, it is mostly a matter of style. Personally, I prefer to use . at the end, because a bullet point is still a sentence from my POV, and actually, a bullet point could be multiple sentences. You also capitalized the first word of each bullet point, so it seems to be a sentence. -- I guess some people don't capitalize the first word and also don't use a . at the en, ie, us a \"no-sentence\" bullet point style. But this only work for \"single sentence\" bullet points.\nIt's really a nit. I just raised my personal (an obviously very subjective) preference.", "author": "mjsax", "createdAt": "2020-12-29T01:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjM2OA=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjM5Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592393", "bodyText": "nit: missing . at the end", "author": "mjsax", "createdAt": "2020-12-23T01:36:12Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjYyMQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592621", "bodyText": "nit: Do we need a new paragraph after a list?", "author": "mjsax", "createdAt": "2020-12-23T01:36:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjY3NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592675", "bodyText": "as above", "author": "mjsax", "createdAt": "2020-12-23T01:37:03Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjY5Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592697", "bodyText": "as above", "author": "mjsax", "createdAt": "2020-12-23T01:37:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\r\n+ * </ul>\r\n+ * <p>\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzA3Mg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547593072", "bodyText": "is provided [in]\nvia [the] {@link Branched} parameter.", "author": "mjsax", "createdAt": "2020-12-23T01:38:50Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzMxMA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547593310", "bodyText": "Do we need the content in the parentheses?", "author": "mjsax", "createdAt": "2020-12-23T01:39:54Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUyMzk3Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548523976", "bodyText": "No we don't, removed )", "author": "inponomarev", "createdAt": "2020-12-24T13:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzMxMA=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzM5NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547593395", "bodyText": "and returns -> that returns (or and it returns)\nvalue -> {@link KStream} ? (and than the returned {@link KStream} is added to the {@code Map}.`", "author": "mjsax", "createdAt": "2020-12-23T01:40:26Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzQ4OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547593489", "bodyText": "nit: missing \".\" (some for other bullet points)", "author": "mjsax", "createdAt": "2020-12-23T01:40:59Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzkyNA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547593924", "bodyText": "then the value is the branch itself ->  then the branch itself is added to the {@code Map} ?", "author": "mjsax", "createdAt": "2020-12-23T01:43:03Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NDIzMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547594233", "bodyText": "the respective entry is not put to the map. -> , then no entry is added to the map.", "author": "mjsax", "createdAt": "2020-12-23T01:44:24Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NDM2NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547594365", "bodyText": "If a [non-null] consumer\nthen the the respective entry is not put to the map -> , then no entry is added to the map.", "author": "mjsax", "createdAt": "2020-12-23T01:44:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NDQ0Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547594447", "bodyText": "Seems the null consumer case is missing (is case we want to allow if, but as mentioned above, I have some doubts)?", "author": "mjsax", "createdAt": "2020-12-23T01:45:14Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\r\n+ * </ul>\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5ODQxOA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547598418", "bodyText": "To simplify the example, should we use predicate1, predicate2 as in the first example?", "author": "mjsax", "createdAt": "2020-12-23T02:01:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\r\n+ * </ul>\r\n+ * <p>\r\n+ * For example:\r\n+ * <pre> {@code\r\n+ * Map<String, KStream<..., ...>> result =\r\n+ *   source.split(Named.as(\"foo-\"))\r\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\r\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\r\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\r\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\r\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\r\n+ * }</pre>\r\n+ *\r\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\r\n+ *\r\n+ * <h3>Direct Branch Consuming</h3>\r\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\r\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\r\n+ *\r\n+ * <pre> {@code\r\n+ * source.split()\r\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.withConsumer(ks -> ks.to(\"A\")))\r\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.withConsumer(ks -> ks.to(\"B\")))\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5OTEwNw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547599107", "bodyText": "{@code BranchedKStream}", "author": "mjsax", "createdAt": "2020-12-23T02:04:21Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\r\n+ * </ul>\r\n+ * <p>\r\n+ * For example:\r\n+ * <pre> {@code\r\n+ * Map<String, KStream<..., ...>> result =\r\n+ *   source.split(Named.as(\"foo-\"))\r\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\r\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\r\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\r\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\r\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\r\n+ * }</pre>\r\n+ *\r\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\r\n+ *\r\n+ * <h3>Direct Branch Consuming</h3>\r\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\r\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\r\n+ *\r\n+ * <pre> {@code\r\n+ * source.split()\r\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.withConsumer(ks -> ks.to(\"A\")))\r\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.withConsumer(ks -> ks.to(\"B\")))\r\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\r\n+ * }</pre>\r\n+ *\r\n+ * <h3>Collecting branches in a single scope</h3>\r\n+ * In other cases we want to combine branches again after splitting. The map returned by\r\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\r\n+ * access to all the branches in the same scope:\r\n+ *\r\n+ * <pre> {@code\r\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\r\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\r\n+ *     .defaultBranch(Branched.as(\"non-null\"));\r\n+ *\r\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\r\n+ * }</pre>\r\n+ *\r\n+ * <h3>Dynamic branching</h3>\r\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\r\n+ *\r\n+ * <pre> {@code\r\n+ * BranchedKStream branched = stream.split();\r\n+ * for (RecordType recordType : RecordType.values())\r\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\r\n+ *         Branched.withConsumer(recordType::processRecords));\r\n+ * }</pre>\r\n+ *\r\n+ * @param <K> Type of keys\r\n+ * @param <V> Type of values\r\n+ * @see KStream\r\n+ */\r\n+public interface BranchedKStream<K, V> {\r\n+    /**\r\n+     * Defines a branch for records that match the predicate.\r\n+     *\r\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\r\n+     *                  If this predicate returns {@code true} for a given record, the record will be\r\n+     *                  routed to the current branch and will not be evaluated against the predicates\r\n+     *                  for the remaining branches.\r\n+     * @return {@code this} to facilitate method chaining\r\n+     */\r\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\r\n+\r\n+    /**\r\n+     * Defines a branch for records that match the predicate.\r\n+     *\r\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\r\n+     *                  If this predicate returns {@code true} for a given record, the record will be\r\n+     *                  routed to the current branch and will not be evaluated against the predicates\r\n+     *                  for the remaining branches.\r\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\r\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\r\n+     *                  for {@link BranchedKStream})\r\n+     * @return {@code this} to facilitate method chaining\r\n+     */\r\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\r\n+\r\n+    /**\r\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\r\n+     * by other branches.\r\n+     *\r\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5OTg4OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547599889", "bodyText": "Add: If a record does not match any predicates, it will be routed to the default branch, or dropped if no default branch is created.", "author": "mjsax", "createdAt": "2020-12-23T02:07:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex d287df82b7..9dd2cbd98c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -24,46 +24,43 @@ import java.util.Map;\n  * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n  * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n  * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}.\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n  * <p>\n  * Each branch (which is a {@link KStream} instance) then can be processed either by\n  * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n  * <p>\n  * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n  * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n- * of branching.\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n  * <p>\n  * The process of routing the records to different branches is a stateless record-by-record operation.\n  * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n  * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n  * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <p>\n  * <ul>\n  *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n  *     a prefix for each key. By default, no prefix is used\n- *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n  *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n  *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n  *     as a decimal number, starting from {@code \"1\"}\n  *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n  *     to {@code prefix + \"0\"}\n  * </ul>\n- * <p>\n  * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <p>\n  * <ul>\n- *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n- *     identity chain function)\n- *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n- *     the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n- *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n  * </ul>\n- * <p>\n  * For example:\n  * <pre> {@code\n  * Map<String, KStream<..., ...>> result =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMDQzNg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547600436", "bodyText": "Nit Split (no s) -- we use imperative to write JavaDocs.\nthis stream -> this {@code KStream}.\n(Same for the overload method)", "author": "mjsax", "createdAt": "2020-12-23T02:09:36Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -773,10 +775,32 @@\n      * @param named  a {@link Named} config used to name the processor in the topology\n      * @param predicates the ordered list of {@link Predicate} instances\n      * @return multiple distinct substreams of this {@code KStream}\n+     * @deprecated since 2.7. Use {@link #split(Named)} instead.\n      */\n+    @Deprecated\n     @SuppressWarnings(\"unchecked\")\n     KStream<K, V>[] branch(final Named named, final Predicate<? super K, ? super V>... predicates);\n \n+    /**\n+     * Splits this stream. {@link BranchedKStream} can be used for routing the records to different branches depending", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java\nindex 765b6b8b30..0387ae4705 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java\n\n@@ -782,7 +782,7 @@ public interface KStream<K, V> {\n     KStream<K, V>[] branch(final Named named, final Predicate<? super K, ? super V>... predicates);\n \n     /**\n-     * Splits this stream. {@link BranchedKStream} can be used for routing the records to different branches depending\n+     * Split this stream. {@link BranchedKStream} can be used for routing the records to different branches depending\n      * on evaluation against the supplied predicates.\n      * Stream branching is a stateless record-by-record operation.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMTI0NA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547601244", "bodyText": "newStream -> branch ?", "author": "mjsax", "createdAt": "2020-12-23T02:13:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+class BranchedInternal<K, V> extends Branched<K, V> {\r\n+    BranchedInternal(final Branched<K, V> branched) {\r\n+        super(branched);\r\n+    }\r\n+\r\n+    BranchedInternal() {\r\n+        super(null, null, null);\r\n+    }\r\n+\r\n+    static <K, V> BranchedInternal<K, V> empty() {\r\n+        return new BranchedInternal<>();\r\n+    }\r\n+\r\n+    String branchProcessorName(final String prefix, final int index) {\r\n+        if (name == null) {\r\n+            return prefix + index;\r\n+        } else {\r\n+            return prefix + name;\r\n+        }\r\n+    }\r\n+\r\n+    public void process(final KStreamImpl<K, V> newStream, final String branchChildName, final Map<String, KStream<K, V>> result) {\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java\nindex 8b9528d3e2..cbf71d148b 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java\n\n@@ -19,7 +19,8 @@ package org.apache.kafka.streams.kstream.internals;\n import org.apache.kafka.streams.kstream.Branched;\n import org.apache.kafka.streams.kstream.KStream;\n \n-import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n \n class BranchedInternal<K, V> extends Branched<K, V> {\n     BranchedInternal(final Branched<K, V> branched) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMjMxNA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547602314", "bodyText": "I think this method is hard to read. Proposal:\nif (chainFunction != null) {\n  final KStream<K, V> transformedStream = chainFunction.apply(newStream);\n  if (transformedStream != null) {\n    result.put(branchChildName, transformedStream);\n  }\n} else if (chainConsumer != null) {\n  chainConsumer.accept(transformedStream);\n} else {\n  result.put(branchChildName, newStream);\n}", "author": "mjsax", "createdAt": "2020-12-23T02:17:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+class BranchedInternal<K, V> extends Branched<K, V> {\r\n+    BranchedInternal(final Branched<K, V> branched) {\r\n+        super(branched);\r\n+    }\r\n+\r\n+    BranchedInternal() {\r\n+        super(null, null, null);\r\n+    }\r\n+\r\n+    static <K, V> BranchedInternal<K, V> empty() {\r\n+        return new BranchedInternal<>();\r\n+    }\r\n+\r\n+    String branchProcessorName(final String prefix, final int index) {\r\n+        if (name == null) {\r\n+            return prefix + index;\r\n+        } else {\r\n+            return prefix + name;\r\n+        }\r\n+    }\r\n+\r\n+    public void process(final KStreamImpl<K, V> newStream, final String branchChildName, final Map<String, KStream<K, V>> result) {\r\n+        final KStream<K, V> transformedStream;\r\n+        if (chainFunction == null) {\r\n+            transformedStream = newStream;\r\n+        } else {\r\n+            transformedStream = chainFunction.apply(newStream);\r\n+        }\r\n+        if (transformedStream == null) {\r\n+            return;\r\n+        }\r\n+        if (chainConsumer != null) {\r\n+            chainConsumer.accept(transformedStream);\r\n+            return;\r\n+        } else {\r\n+            result.put(branchChildName, transformedStream);\r\n+        }\r\n+    }\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYwNjI1MA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548606250", "bodyText": "Agreed, replaced the code as you suggested", "author": "inponomarev", "createdAt": "2020-12-24T16:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMjMxNA=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java\nindex 8b9528d3e2..cbf71d148b 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java\n\n@@ -19,7 +19,8 @@ package org.apache.kafka.streams.kstream.internals;\n import org.apache.kafka.streams.kstream.Branched;\n import org.apache.kafka.streams.kstream.KStream;\n \n-import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n \n class BranchedInternal<K, V> extends Branched<K, V> {\n     BranchedInternal(final Branched<K, V> branched) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMjkyNQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547602925", "bodyText": "Seems we should add a corresponding test for split() ? (Same for other test classes.)", "author": "mjsax", "createdAt": "2020-12-23T02:19:45Z", "path": "streams/src/test/java/org/apache/kafka/streams/StreamsBuilderTest.java", "diffHunk": "@@ -615,7 +615,7 @@ public void shouldUseSpecifiedNameForTransformValuesWithKey() {\n     }\n \n     @Test\n-    @SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings({\"unchecked\", \"deprecation\"})", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYyMTE5MA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548621190", "bodyText": "done, added a new corresponding test!", "author": "inponomarev", "createdAt": "2020-12-24T16:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMjkyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/StreamsBuilderTest.java b/streams/src/test/java/org/apache/kafka/streams/StreamsBuilderTest.java\nindex a0e73fe717..7eddbbbf61 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/StreamsBuilderTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/StreamsBuilderTest.java\n\n@@ -615,7 +644,7 @@ public class StreamsBuilderTest {\n     }\n \n     @Test\n-    @SuppressWarnings({\"unchecked\", \"deprecation\"})\n+    @SuppressWarnings(\"unchecked\")\n     public void shouldUseSpecifiedNameForBranchOperation() {\n         builder.stream(STREAM_TOPIC)\n                .branch(Named.as(\"branch-processor\"), (k, v) -> true, (k, v) -> false);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMzYzOQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547603639", "bodyText": "missing null check for named", "author": "mjsax", "createdAt": "2020-12-23T02:22:53Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -492,6 +496,16 @@ public void foreach(final ForeachAction<? super K, ? super V> action,\n         return branchChildren;\n     }\n \n+    @Override\n+    public BranchedKStream<K, V> split() {\n+        return new BranchedKStreamImpl<>(this, repartitionRequired, NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public BranchedKStream<K, V> split(final Named named) {\n+        return new BranchedKStreamImpl<>(this, repartitionRequired, new NamedInternal(named));", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYyMTMxMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548621313", "bodyText": "done", "author": "inponomarev", "createdAt": "2020-12-24T16:59:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMzYzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java\nindex 6901ef52fb..d20c973f10 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java\n\n@@ -503,6 +503,7 @@ public class KStreamImpl<K, V> extends AbstractStream<K, V> implements KStream<K\n \n     @Override\n     public BranchedKStream<K, V> split(final Named named) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n         return new BranchedKStreamImpl<>(this, repartitionRequired, new NamedInternal(named));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNDg2Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547604866", "bodyText": "Should we really do it this way, or add a predicate to the list that always returns true if a default branch is added?", "author": "mjsax", "createdAt": "2020-12-23T02:27:45Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamBranch.java", "diffHunk": "@@ -41,14 +43,18 @@\n     private class KStreamBranchProcessor extends AbstractProcessor<K, V> {\n         @Override\n         public void process(final K key, final V value) {\n-            for (int i = 0; i < predicates.length; i++) {\n-                if (predicates[i].test(key, value)) {\n+            for (int i = 0; i < predicates.size(); i++) {\n+                if (predicates.get(i).test(key, value)) {\n                     // use forward with child here and then break the loop\n                     // so that no record is going to be piped to multiple streams\n-                    context().forward(key, value, To.child(childNodes[i]));\n-                    break;\n+                    context().forward(key, value, To.child(childNodes.get(i)));\n+                    return;\n                 }\n             }\n+            // using default child node if supplied", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamBranch.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamBranch.java\nindex 21b69f2322..baa9b63f6c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamBranch.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamBranch.java\n\n@@ -43,18 +41,14 @@ class KStreamBranch<K, V> implements ProcessorSupplier<K, V> {\n     private class KStreamBranchProcessor extends AbstractProcessor<K, V> {\n         @Override\n         public void process(final K key, final V value) {\n-            for (int i = 0; i < predicates.size(); i++) {\n-                if (predicates.get(i).test(key, value)) {\n+            for (int i = 0; i < predicates.length; i++) {\n+                if (predicates[i].test(key, value)) {\n                     // use forward with child here and then break the loop\n                     // so that no record is going to be piped to multiple streams\n-                    context().forward(key, value, To.child(childNodes.get(i)));\n-                    return;\n+                    context().forward(key, value, To.child(childNodes[i]));\n+                    break;\n                 }\n             }\n-            // using default child node if supplied\n-            if (childNodes.size() > predicates.size()) {\n-                context().forward(key, value, To.child(childNodes.get(predicates.size())));\n-            }\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNTQzOQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547605439", "bodyText": "Missing null check for predicate (similar below for other methods and parameters).", "author": "mjsax", "createdAt": "2020-12-23T02:30:05Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r\n+\r\n+    private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\r\n+    private final List<String> childNames = new ArrayList<>();\r\n+    private final ProcessorGraphNode<K, V> splitterNode;\r\n+\r\n+    BranchedKStreamImpl(final KStreamImpl<K, V> source, final boolean repartitionRequired, final NamedInternal named) {\r\n+        this.source = source;\r\n+        this.repartitionRequired = repartitionRequired;\r\n+        this.splitterName = named.orElseGenerateWithPrefix(source.builder, BRANCH_NAME);\r\n+\r\n+        // predicates and childNames are passed by reference so when the user adds a branch they get added to\r\n+        final ProcessorParameters<K, V> processorParameters =\r\n+                new ProcessorParameters<>(new KStreamBranch<>(predicates, childNames), splitterName);\r\n+        splitterNode = new ProcessorGraphNode<>(splitterName, processorParameters);\r\n+        source.builder.addGraphNode(source.streamsGraphNode, splitterNode);\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate) {\r\n+        return branch(predicate, BranchedInternal.empty());\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\nindex 861fbac2f8..1baea8e8ce 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n\n@@ -35,7 +35,7 @@ public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\n     private final KStreamImpl<K, V> source;\n     private final boolean repartitionRequired;\n     private final String splitterName;\n-    private final Map<String, KStream<K, V>> result = new HashMap<>();\n+    private final Map<String, KStream<K, V>> outputBranches = new HashMap<>();\n \n     private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\n     private final List<String> childNames = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNjA2NA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547606064", "bodyText": "Should we call branch((k,v) -> true, branched) instead to just add a predicate and branch? This way, the default branch is nothing special at runtime any longer.", "author": "mjsax", "createdAt": "2020-12-23T02:32:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r\n+\r\n+    private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\r\n+    private final List<String> childNames = new ArrayList<>();\r\n+    private final ProcessorGraphNode<K, V> splitterNode;\r\n+\r\n+    BranchedKStreamImpl(final KStreamImpl<K, V> source, final boolean repartitionRequired, final NamedInternal named) {\r\n+        this.source = source;\r\n+        this.repartitionRequired = repartitionRequired;\r\n+        this.splitterName = named.orElseGenerateWithPrefix(source.builder, BRANCH_NAME);\r\n+\r\n+        // predicates and childNames are passed by reference so when the user adds a branch they get added to\r\n+        final ProcessorParameters<K, V> processorParameters =\r\n+                new ProcessorParameters<>(new KStreamBranch<>(predicates, childNames), splitterName);\r\n+        splitterNode = new ProcessorGraphNode<>(splitterName, processorParameters);\r\n+        source.builder.addGraphNode(source.streamsGraphNode, splitterNode);\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate) {\r\n+        return branch(predicate, BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate, final Branched<K, V> branched) {\r\n+        predicates.add(predicate);\r\n+        createBranch(branched, predicates.size());\r\n+        return this;\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch() {\r\n+        return defaultBranch(BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch(final Branched<K, V> branched) {\r\n+        createBranch(branched, 0);\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYyOTIwNQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548629205", "bodyText": "The default branch should have index 0 (so it will be stable when branches are added or removed), but it should always be checked after all other branches. And when we come to the default branch during message processing, there is actually no need in dereferncing a predicate and calling test... that's why I treat the default branch differently.", "author": "inponomarev", "createdAt": "2020-12-24T17:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNjA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Mjg1NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549542855", "bodyText": "I guess it's fine both ways. -- The point about the index is a good one that I missed. But would still be doable I guess.\nI don't think that there would be any measurable runtime difference if you use a \"default predicate\" (what we also do in the current implementation) -- the code is just a little \"cleaner\" as we don't need an extra \"if\" at the end -- but it's also not the end of the world as the process method is fairly simply anyway.", "author": "mjsax", "createdAt": "2020-12-29T02:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNjA2NA=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\nindex 861fbac2f8..1baea8e8ce 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n\n@@ -35,7 +35,7 @@ public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\n     private final KStreamImpl<K, V> source;\n     private final boolean repartitionRequired;\n     private final String splitterName;\n-    private final Map<String, KStream<K, V>> result = new HashMap<>();\n+    private final Map<String, KStream<K, V>> outputBranches = new HashMap<>();\n \n     private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\n     private final List<String> childNames = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNjYxNw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547606617", "bodyText": "As we call branchProcessorName only once, I am wondering if we should embed the code here and remove branchProcessorName -- our usual pattern is to only have getters on the XxxInternal implemenation.", "author": "mjsax", "createdAt": "2020-12-23T02:35:11Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r\n+\r\n+    private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\r\n+    private final List<String> childNames = new ArrayList<>();\r\n+    private final ProcessorGraphNode<K, V> splitterNode;\r\n+\r\n+    BranchedKStreamImpl(final KStreamImpl<K, V> source, final boolean repartitionRequired, final NamedInternal named) {\r\n+        this.source = source;\r\n+        this.repartitionRequired = repartitionRequired;\r\n+        this.splitterName = named.orElseGenerateWithPrefix(source.builder, BRANCH_NAME);\r\n+\r\n+        // predicates and childNames are passed by reference so when the user adds a branch they get added to\r\n+        final ProcessorParameters<K, V> processorParameters =\r\n+                new ProcessorParameters<>(new KStreamBranch<>(predicates, childNames), splitterName);\r\n+        splitterNode = new ProcessorGraphNode<>(splitterName, processorParameters);\r\n+        source.builder.addGraphNode(source.streamsGraphNode, splitterNode);\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate) {\r\n+        return branch(predicate, BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate, final Branched<K, V> branched) {\r\n+        predicates.add(predicate);\r\n+        createBranch(branched, predicates.size());\r\n+        return this;\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch() {\r\n+        return defaultBranch(BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch(final Branched<K, V> branched) {\r\n+        createBranch(branched, 0);\r\n+        return result;\r\n+    }\r\n+\r\n+    private void createBranch(final Branched<K, V> branched, final int index) {\r\n+        final BranchedInternal<K, V> branchedInternal = new BranchedInternal<>(branched);\r\n+        final String branchChildName = branchedInternal.branchProcessorName(splitterName, index);\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\nindex 861fbac2f8..1baea8e8ce 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n\n@@ -35,7 +35,7 @@ public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\n     private final KStreamImpl<K, V> source;\n     private final boolean repartitionRequired;\n     private final String splitterName;\n-    private final Map<String, KStream<K, V>> result = new HashMap<>();\n+    private final Map<String, KStream<K, V>> outputBranches = new HashMap<>();\n \n     private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\n     private final List<String> childNames = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNjg2Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547606866", "bodyText": "result -> outputBranches ?", "author": "mjsax", "createdAt": "2020-12-23T02:36:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\nindex 861fbac2f8..1baea8e8ce 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n\n@@ -35,7 +35,7 @@ public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\n     private final KStreamImpl<K, V> source;\n     private final boolean repartitionRequired;\n     private final String splitterName;\n-    private final Map<String, KStream<K, V>> result = new HashMap<>();\n+    private final Map<String, KStream<K, V>> outputBranches = new HashMap<>();\n \n     private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\n     private final List<String> childNames = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNzczOQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547607739", "bodyText": "I am wondering if it might be better to move this code into a build method that would be called within defaultBranch() / noDefaultBranch() ?\nThe pattern to pass in empty list that we modify later seems undesirable, and we should first build the list, and than pass them in -- otherwise, we make assumptions how ProcessorParameters and ProcessorGraphNode might be implemented what we should avoid.", "author": "mjsax", "createdAt": "2020-12-23T02:39:51Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r\n+\r\n+    private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\r\n+    private final List<String> childNames = new ArrayList<>();\r\n+    private final ProcessorGraphNode<K, V> splitterNode;\r\n+\r\n+    BranchedKStreamImpl(final KStreamImpl<K, V> source, final boolean repartitionRequired, final NamedInternal named) {\r\n+        this.source = source;\r\n+        this.repartitionRequired = repartitionRequired;\r\n+        this.splitterName = named.orElseGenerateWithPrefix(source.builder, BRANCH_NAME);\r\n+\r\n+        // predicates and childNames are passed by reference so when the user adds a branch they get added to\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODY0NTIwMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548645203", "bodyText": "I clearly remember that something made me to write it this way, but I have to recall...", "author": "inponomarev", "createdAt": "2020-12-24T17:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNzczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Mjk5NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549542995", "bodyText": "Would love to learn about it. -- In general, it's easier to follow the same pattern throughout the code base. It easier to reason about the code that way, and also easier for people to learn the code base.", "author": "mjsax", "createdAt": "2020-12-29T02:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNzczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0MzI0Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549543247", "bodyText": "Just saw your other comment: #9107 (comment)", "author": "mjsax", "createdAt": "2020-12-29T02:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNzczOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\nindex 861fbac2f8..1baea8e8ce 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n\n@@ -35,7 +35,7 @@ public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\n     private final KStreamImpl<K, V> source;\n     private final boolean repartitionRequired;\n     private final String splitterName;\n-    private final Map<String, KStream<K, V>> result = new HashMap<>();\n+    private final Map<String, KStream<K, V>> outputBranches = new HashMap<>();\n \n     private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\n     private final List<String> childNames = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwODA0MQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547608041", "bodyText": "Same comment as for branchProcessorName -- it seems better to keep BranchedInternal a simple container and pull in the code into this method.", "author": "mjsax", "createdAt": "2020-12-23T02:41:17Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r\n+\r\n+    private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\r\n+    private final List<String> childNames = new ArrayList<>();\r\n+    private final ProcessorGraphNode<K, V> splitterNode;\r\n+\r\n+    BranchedKStreamImpl(final KStreamImpl<K, V> source, final boolean repartitionRequired, final NamedInternal named) {\r\n+        this.source = source;\r\n+        this.repartitionRequired = repartitionRequired;\r\n+        this.splitterName = named.orElseGenerateWithPrefix(source.builder, BRANCH_NAME);\r\n+\r\n+        // predicates and childNames are passed by reference so when the user adds a branch they get added to\r\n+        final ProcessorParameters<K, V> processorParameters =\r\n+                new ProcessorParameters<>(new KStreamBranch<>(predicates, childNames), splitterName);\r\n+        splitterNode = new ProcessorGraphNode<>(splitterName, processorParameters);\r\n+        source.builder.addGraphNode(source.streamsGraphNode, splitterNode);\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate) {\r\n+        return branch(predicate, BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate, final Branched<K, V> branched) {\r\n+        predicates.add(predicate);\r\n+        createBranch(branched, predicates.size());\r\n+        return this;\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch() {\r\n+        return defaultBranch(BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch(final Branched<K, V> branched) {\r\n+        createBranch(branched, 0);\r\n+        return result;\r\n+    }\r\n+\r\n+    private void createBranch(final Branched<K, V> branched, final int index) {\r\n+        final BranchedInternal<K, V> branchedInternal = new BranchedInternal<>(branched);\r\n+        final String branchChildName = branchedInternal.branchProcessorName(splitterName, index);\r\n+        childNames.add(branchChildName);\r\n+        source.builder.newProcessorName(branchChildName);\r\n+        final ProcessorParameters<K, V> parameters = new ProcessorParameters<>(new PassThrough<>(), branchChildName);\r\n+        final ProcessorGraphNode<K, V> branchChildNode = new ProcessorGraphNode<>(branchChildName, parameters);\r\n+        source.builder.addGraphNode(splitterNode, branchChildNode);\r\n+        final KStreamImpl<K, V> newStream = new KStreamImpl<>(branchChildName, source.keySerde,\r\n+                source.valueSerde, source.subTopologySourceNodes,\r\n+                repartitionRequired, branchChildNode, source.builder);\r\n+        branchedInternal.process(newStream, branchChildName, result);\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODY0MjEzOA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548642138", "bodyText": "done", "author": "inponomarev", "createdAt": "2020-12-24T17:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwODA0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\nindex 861fbac2f8..1baea8e8ce 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java\n\n@@ -35,7 +35,7 @@ public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\n     private final KStreamImpl<K, V> source;\n     private final boolean repartitionRequired;\n     private final String splitterName;\n-    private final Map<String, KStream<K, V>> result = new HashMap<>();\n+    private final Map<String, KStream<K, V>> outputBranches = new HashMap<>();\n \n     private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\n     private final List<String> childNames = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1NTkxNA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549555914", "bodyText": "It's a naming convention in the whole Kafka code base, to omit the get prefix for all getter methods, ie, this should be name(). (Similar below for the other getters.)", "author": "mjsax", "createdAt": "2020-12-29T03:34:43Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+class BranchedInternal<K, V> extends Branched<K, V> {\r\n+    BranchedInternal(final Branched<K, V> branched) {\r\n+        super(branched);\r\n+    }\r\n+\r\n+    BranchedInternal() {\r\n+        super(null, null, null);\r\n+    }\r\n+\r\n+    static <K, V> BranchedInternal<K, V> empty() {\r\n+        return new BranchedInternal<>();\r\n+    }\r\n+\r\n+    String getName() {\r", "originalCommit": "c7bb27eedb09beea3412bea778aee6b73059095b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyMjU0Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549722543", "bodyText": "done", "author": "inponomarev", "createdAt": "2020-12-29T14:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1NTkxNA=="}], "type": "inlineReview", "revised_code": {"commit": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java\nindex c8997bb942..cbf71d148b 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java\n\n@@ -35,15 +35,15 @@ class BranchedInternal<K, V> extends Branched<K, V> {\n         return new BranchedInternal<>();\n     }\n \n-    String getName() {\n+    String name() {\n         return name;\n     }\n \n-    public Function<? super KStream<K, V>, ? extends KStream<K, V>> getChainFunction() {\n+    public Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction() {\n         return chainFunction;\n     }\n \n-    public Consumer<? super KStream<K, V>> getChainConsumer() {\n+    public Consumer<? super KStream<K, V>> chainConsumer() {\n         return chainConsumer;\n     }\n }\n"}}, {"oid": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "url": "https://github.com/apache/kafka/commit/0759478faf0c2d26da8f989840ba21f824b9b5ea", "message": "Scala API wrapper", "committedDate": "2021-01-13T19:49:31Z", "type": "forcePushed"}, {"oid": "2ef3837ea963cc6f4d1940a1fc3cb3346d653644", "url": "https://github.com/apache/kafka/commit/2ef3837ea963cc6f4d1940a1fc3cb3346d653644", "message": "Rewrite StreamsGraphTest using split()", "committedDate": "2021-01-20T02:07:40Z", "type": "forcePushed"}, {"oid": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "url": "https://github.com/apache/kafka/commit/9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "message": "Rewrite StreamsGraphTest using split()", "committedDate": "2021-01-20T02:30:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2NjM4OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564766389", "bodyText": "nit: should not -> cannot  (or can't if you prefer)", "author": "mjsax", "createdAt": "2021-01-26T19:15:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 342d159a46..b148a50278 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -1,149 +1,140 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-/**\n- * The {@code Branched} class is used to define the optional parameters when building branches with\n- * {@link BranchedKStream}.\n- *\n- * @param <K> type of record key\n- * @param <V> type of record value\n- */\n-public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n-\n-    protected final String name;\n-    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n-    protected final Consumer<? super KStream<K, V>> chainConsumer;\n-\n-    protected Branched(final String name,\n-                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n-                       final Consumer<? super KStream<K, V>> chainConsumer) {\n-        this.name = name;\n-        this.chainFunction = chainFunction;\n-        this.chainConsumer = chainConsumer;\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *             (see {@link BranchedKStream} description for details)\n-     * @param <K>  key type\n-     * @param <V>  value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> as(final String name) {\n-        return new Branched<>(name, null, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function.\n-     *\n-     * @param chain A function that will be applied to the branch. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(null, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(null, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n-     *\n-     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n-     *              {@code kStream -> kStream} function will be used. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(name, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<? super KStream<K, V>> chain,\n-                                                     final String name) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(name, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} from an existing instance.\n-     *\n-     * @param branched the instance of {@code Branched} to copy\n-     */\n-    protected Branched(final Branched<K, V> branched) {\n-        this(branched.name, branched.chainFunction, branched.chainConsumer);\n-    }\n-\n-    /**\n-     * Configure the instance of {@code Branched} with a branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null} a default branch name suffix will be generated (see\n-     *             {@link BranchedKStream} description for details)\n-     * @return {@code this}\n-     */\n-    @Override\n-    public Branched<K, V> withName(final String name) {\n-        return new Branched<>(name, chainFunction, chainConsumer);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    private final String name;\n+    private final Function<? super KStream<? super K, ? super V>,\n+            ? extends KStream<? extends K, ? extends V>> chainFunction;\n+    private final Consumer<? super KStream<? super K, ? super V>> chainConsumer;\n+\n+    private Branched(String name,\n+                     Function<? super KStream<? super K, ? super V>, ? extends KStream<? extends K, ? extends V>> chainFunction,\n+                     Consumer<? super KStream<? super K, ? super V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Configure the instance of {@link Branched} with a branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\n+     *             {@link BranchedKStream} description for details)\n+     * @return {@code this}\n+     */\n+    @Override\n+    public Branched<K, V> withName(String name) {\n+        return new Branched<>(name, chainFunction, chainConsumer);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain) {\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *              and the branch will be added to the resulting {@code Map}.\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain) {\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain, String name) {\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *      *              the respective branch will not be added to the resulting {@code Map} returned\n+     *      *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *      *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *      *              and the branch will be added to the resulting {@code Map}.\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain, String name) {\n+        return new Branched<>(name, null, chain);\n+    }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2NzA2OA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564767068", "bodyText": "nit: should not -> cannot", "author": "mjsax", "createdAt": "2021-01-26T19:16:06Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 342d159a46..b148a50278 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -1,149 +1,140 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-/**\n- * The {@code Branched} class is used to define the optional parameters when building branches with\n- * {@link BranchedKStream}.\n- *\n- * @param <K> type of record key\n- * @param <V> type of record value\n- */\n-public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n-\n-    protected final String name;\n-    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n-    protected final Consumer<? super KStream<K, V>> chainConsumer;\n-\n-    protected Branched(final String name,\n-                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n-                       final Consumer<? super KStream<K, V>> chainConsumer) {\n-        this.name = name;\n-        this.chainFunction = chainFunction;\n-        this.chainConsumer = chainConsumer;\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *             (see {@link BranchedKStream} description for details)\n-     * @param <K>  key type\n-     * @param <V>  value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> as(final String name) {\n-        return new Branched<>(name, null, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function.\n-     *\n-     * @param chain A function that will be applied to the branch. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(null, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(null, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n-     *\n-     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n-     *              {@code kStream -> kStream} function will be used. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(name, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<? super KStream<K, V>> chain,\n-                                                     final String name) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(name, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} from an existing instance.\n-     *\n-     * @param branched the instance of {@code Branched} to copy\n-     */\n-    protected Branched(final Branched<K, V> branched) {\n-        this(branched.name, branched.chainFunction, branched.chainConsumer);\n-    }\n-\n-    /**\n-     * Configure the instance of {@code Branched} with a branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null} a default branch name suffix will be generated (see\n-     *             {@link BranchedKStream} description for details)\n-     * @return {@code this}\n-     */\n-    @Override\n-    public Branched<K, V> withName(final String name) {\n-        return new Branched<>(name, chainFunction, chainConsumer);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    private final String name;\n+    private final Function<? super KStream<? super K, ? super V>,\n+            ? extends KStream<? extends K, ? extends V>> chainFunction;\n+    private final Consumer<? super KStream<? super K, ? super V>> chainConsumer;\n+\n+    private Branched(String name,\n+                     Function<? super KStream<? super K, ? super V>, ? extends KStream<? extends K, ? extends V>> chainFunction,\n+                     Consumer<? super KStream<? super K, ? super V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Configure the instance of {@link Branched} with a branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\n+     *             {@link BranchedKStream} description for details)\n+     * @return {@code this}\n+     */\n+    @Override\n+    public Branched<K, V> withName(String name) {\n+        return new Branched<>(name, chainFunction, chainConsumer);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain) {\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *              and the branch will be added to the resulting {@code Map}.\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain) {\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain, String name) {\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *      *              the respective branch will not be added to the resulting {@code Map} returned\n+     *      *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *      *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *      *              and the branch will be added to the resulting {@code Map}.\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain, String name) {\n+        return new Branched<>(name, null, chain);\n+    }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2NzIzOQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564767239", "bodyText": "nit: remove here", "author": "mjsax", "createdAt": "2021-01-26T19:16:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 342d159a46..b148a50278 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -1,149 +1,140 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-/**\n- * The {@code Branched} class is used to define the optional parameters when building branches with\n- * {@link BranchedKStream}.\n- *\n- * @param <K> type of record key\n- * @param <V> type of record value\n- */\n-public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n-\n-    protected final String name;\n-    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n-    protected final Consumer<? super KStream<K, V>> chainConsumer;\n-\n-    protected Branched(final String name,\n-                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n-                       final Consumer<? super KStream<K, V>> chainConsumer) {\n-        this.name = name;\n-        this.chainFunction = chainFunction;\n-        this.chainConsumer = chainConsumer;\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *             (see {@link BranchedKStream} description for details)\n-     * @param <K>  key type\n-     * @param <V>  value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> as(final String name) {\n-        return new Branched<>(name, null, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function.\n-     *\n-     * @param chain A function that will be applied to the branch. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(null, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(null, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n-     *\n-     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n-     *              {@code kStream -> kStream} function will be used. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(name, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<? super KStream<K, V>> chain,\n-                                                     final String name) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(name, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} from an existing instance.\n-     *\n-     * @param branched the instance of {@code Branched} to copy\n-     */\n-    protected Branched(final Branched<K, V> branched) {\n-        this(branched.name, branched.chainFunction, branched.chainConsumer);\n-    }\n-\n-    /**\n-     * Configure the instance of {@code Branched} with a branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null} a default branch name suffix will be generated (see\n-     *             {@link BranchedKStream} description for details)\n-     * @return {@code this}\n-     */\n-    @Override\n-    public Branched<K, V> withName(final String name) {\n-        return new Branched<>(name, chainFunction, chainConsumer);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    private final String name;\n+    private final Function<? super KStream<? super K, ? super V>,\n+            ? extends KStream<? extends K, ? extends V>> chainFunction;\n+    private final Consumer<? super KStream<? super K, ? super V>> chainConsumer;\n+\n+    private Branched(String name,\n+                     Function<? super KStream<? super K, ? super V>, ? extends KStream<? extends K, ? extends V>> chainFunction,\n+                     Consumer<? super KStream<? super K, ? super V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Configure the instance of {@link Branched} with a branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\n+     *             {@link BranchedKStream} description for details)\n+     * @return {@code this}\n+     */\n+    @Override\n+    public Branched<K, V> withName(String name) {\n+        return new Branched<>(name, chainFunction, chainConsumer);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain) {\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *              and the branch will be added to the resulting {@code Map}.\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain) {\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain, String name) {\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *      *              the respective branch will not be added to the resulting {@code Map} returned\n+     *      *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *      *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *      *              and the branch will be added to the resulting {@code Map}.\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain, String name) {\n+        return new Branched<>(name, null, chain);\n+    }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2Nzg4MQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564767881", "bodyText": "remove  If {@code null}, the identity {@code kStream -> kStream} function will be used. -- we don't allow null", "author": "mjsax", "createdAt": "2021-01-26T19:17:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 342d159a46..b148a50278 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -1,149 +1,140 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-/**\n- * The {@code Branched} class is used to define the optional parameters when building branches with\n- * {@link BranchedKStream}.\n- *\n- * @param <K> type of record key\n- * @param <V> type of record value\n- */\n-public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n-\n-    protected final String name;\n-    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n-    protected final Consumer<? super KStream<K, V>> chainConsumer;\n-\n-    protected Branched(final String name,\n-                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n-                       final Consumer<? super KStream<K, V>> chainConsumer) {\n-        this.name = name;\n-        this.chainFunction = chainFunction;\n-        this.chainConsumer = chainConsumer;\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *             (see {@link BranchedKStream} description for details)\n-     * @param <K>  key type\n-     * @param <V>  value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> as(final String name) {\n-        return new Branched<>(name, null, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function.\n-     *\n-     * @param chain A function that will be applied to the branch. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(null, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(null, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n-     *\n-     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n-     *              {@code kStream -> kStream} function will be used. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(name, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<? super KStream<K, V>> chain,\n-                                                     final String name) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(name, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} from an existing instance.\n-     *\n-     * @param branched the instance of {@code Branched} to copy\n-     */\n-    protected Branched(final Branched<K, V> branched) {\n-        this(branched.name, branched.chainFunction, branched.chainConsumer);\n-    }\n-\n-    /**\n-     * Configure the instance of {@code Branched} with a branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null} a default branch name suffix will be generated (see\n-     *             {@link BranchedKStream} description for details)\n-     * @return {@code this}\n-     */\n-    @Override\n-    public Branched<K, V> withName(final String name) {\n-        return new Branched<>(name, chainFunction, chainConsumer);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    private final String name;\n+    private final Function<? super KStream<? super K, ? super V>,\n+            ? extends KStream<? extends K, ? extends V>> chainFunction;\n+    private final Consumer<? super KStream<? super K, ? super V>> chainConsumer;\n+\n+    private Branched(String name,\n+                     Function<? super KStream<? super K, ? super V>, ? extends KStream<? extends K, ? extends V>> chainFunction,\n+                     Consumer<? super KStream<? super K, ? super V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Configure the instance of {@link Branched} with a branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\n+     *             {@link BranchedKStream} description for details)\n+     * @return {@code this}\n+     */\n+    @Override\n+    public Branched<K, V> withName(String name) {\n+        return new Branched<>(name, chainFunction, chainConsumer);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain) {\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *              and the branch will be added to the resulting {@code Map}.\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain) {\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain, String name) {\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *      *              the respective branch will not be added to the resulting {@code Map} returned\n+     *      *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *      *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *      *              and the branch will be added to the resulting {@code Map}.\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain, String name) {\n+        return new Branched<>(name, null, chain);\n+    }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2ODE0Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564768146", "bodyText": "nit: should not -> cannot", "author": "mjsax", "createdAt": "2021-01-26T19:17:45Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be used. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 342d159a46..b148a50278 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -1,149 +1,140 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-/**\n- * The {@code Branched} class is used to define the optional parameters when building branches with\n- * {@link BranchedKStream}.\n- *\n- * @param <K> type of record key\n- * @param <V> type of record value\n- */\n-public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n-\n-    protected final String name;\n-    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n-    protected final Consumer<? super KStream<K, V>> chainConsumer;\n-\n-    protected Branched(final String name,\n-                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n-                       final Consumer<? super KStream<K, V>> chainConsumer) {\n-        this.name = name;\n-        this.chainFunction = chainFunction;\n-        this.chainConsumer = chainConsumer;\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *             (see {@link BranchedKStream} description for details)\n-     * @param <K>  key type\n-     * @param <V>  value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> as(final String name) {\n-        return new Branched<>(name, null, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function.\n-     *\n-     * @param chain A function that will be applied to the branch. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(null, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(null, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n-     *\n-     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n-     *              {@code kStream -> kStream} function will be used. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(name, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<? super KStream<K, V>> chain,\n-                                                     final String name) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(name, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} from an existing instance.\n-     *\n-     * @param branched the instance of {@code Branched} to copy\n-     */\n-    protected Branched(final Branched<K, V> branched) {\n-        this(branched.name, branched.chainFunction, branched.chainConsumer);\n-    }\n-\n-    /**\n-     * Configure the instance of {@code Branched} with a branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null} a default branch name suffix will be generated (see\n-     *             {@link BranchedKStream} description for details)\n-     * @return {@code this}\n-     */\n-    @Override\n-    public Branched<K, V> withName(final String name) {\n-        return new Branched<>(name, chainFunction, chainConsumer);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    private final String name;\n+    private final Function<? super KStream<? super K, ? super V>,\n+            ? extends KStream<? extends K, ? extends V>> chainFunction;\n+    private final Consumer<? super KStream<? super K, ? super V>> chainConsumer;\n+\n+    private Branched(String name,\n+                     Function<? super KStream<? super K, ? super V>, ? extends KStream<? extends K, ? extends V>> chainFunction,\n+                     Consumer<? super KStream<? super K, ? super V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Configure the instance of {@link Branched} with a branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\n+     *             {@link BranchedKStream} description for details)\n+     * @return {@code this}\n+     */\n+    @Override\n+    public Branched<K, V> withName(String name) {\n+        return new Branched<>(name, chainFunction, chainConsumer);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain) {\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *              and the branch will be added to the resulting {@code Map}.\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain) {\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain, String name) {\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *      *              the respective branch will not be added to the resulting {@code Map} returned\n+     *      *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *      *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *      *              and the branch will be added to the resulting {@code Map}.\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain, String name) {\n+        return new Branched<>(name, null, chain);\n+    }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2ODM1Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564768353", "bodyText": "nit: remove here", "author": "mjsax", "createdAt": "2021-01-26T19:18:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be used. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 342d159a46..b148a50278 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -1,149 +1,140 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-/**\n- * The {@code Branched} class is used to define the optional parameters when building branches with\n- * {@link BranchedKStream}.\n- *\n- * @param <K> type of record key\n- * @param <V> type of record value\n- */\n-public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n-\n-    protected final String name;\n-    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n-    protected final Consumer<? super KStream<K, V>> chainConsumer;\n-\n-    protected Branched(final String name,\n-                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n-                       final Consumer<? super KStream<K, V>> chainConsumer) {\n-        this.name = name;\n-        this.chainFunction = chainFunction;\n-        this.chainConsumer = chainConsumer;\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *             (see {@link BranchedKStream} description for details)\n-     * @param <K>  key type\n-     * @param <V>  value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> as(final String name) {\n-        return new Branched<>(name, null, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function.\n-     *\n-     * @param chain A function that will be applied to the branch. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(null, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(null, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n-     *\n-     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n-     *              {@code kStream -> kStream} function will be used. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(name, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<? super KStream<K, V>> chain,\n-                                                     final String name) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(name, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} from an existing instance.\n-     *\n-     * @param branched the instance of {@code Branched} to copy\n-     */\n-    protected Branched(final Branched<K, V> branched) {\n-        this(branched.name, branched.chainFunction, branched.chainConsumer);\n-    }\n-\n-    /**\n-     * Configure the instance of {@code Branched} with a branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null} a default branch name suffix will be generated (see\n-     *             {@link BranchedKStream} description for details)\n-     * @return {@code this}\n-     */\n-    @Override\n-    public Branched<K, V> withName(final String name) {\n-        return new Branched<>(name, chainFunction, chainConsumer);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    private final String name;\n+    private final Function<? super KStream<? super K, ? super V>,\n+            ? extends KStream<? extends K, ? extends V>> chainFunction;\n+    private final Consumer<? super KStream<? super K, ? super V>> chainConsumer;\n+\n+    private Branched(String name,\n+                     Function<? super KStream<? super K, ? super V>, ? extends KStream<? extends K, ? extends V>> chainFunction,\n+                     Consumer<? super KStream<? super K, ? super V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Configure the instance of {@link Branched} with a branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\n+     *             {@link BranchedKStream} description for details)\n+     * @return {@code this}\n+     */\n+    @Override\n+    public Branched<K, V> withName(String name) {\n+        return new Branched<>(name, chainFunction, chainConsumer);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain) {\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *              and the branch will be added to the resulting {@code Map}.\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain) {\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain, String name) {\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *      *              the respective branch will not be added to the resulting {@code Map} returned\n+     *      *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *      *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *      *              and the branch will be added to the resulting {@code Map}.\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain, String name) {\n+        return new Branched<>(name, null, chain);\n+    }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2ODU0Mg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564768542", "bodyText": "nit: should not -> cannot", "author": "mjsax", "createdAt": "2021-01-26T19:18:18Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be used. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<? super KStream<K, V>> chain,\n+                                                     final String name) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 342d159a46..b148a50278 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -1,149 +1,140 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-/**\n- * The {@code Branched} class is used to define the optional parameters when building branches with\n- * {@link BranchedKStream}.\n- *\n- * @param <K> type of record key\n- * @param <V> type of record value\n- */\n-public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n-\n-    protected final String name;\n-    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n-    protected final Consumer<? super KStream<K, V>> chainConsumer;\n-\n-    protected Branched(final String name,\n-                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n-                       final Consumer<? super KStream<K, V>> chainConsumer) {\n-        this.name = name;\n-        this.chainFunction = chainFunction;\n-        this.chainConsumer = chainConsumer;\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *             (see {@link BranchedKStream} description for details)\n-     * @param <K>  key type\n-     * @param <V>  value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> as(final String name) {\n-        return new Branched<>(name, null, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function.\n-     *\n-     * @param chain A function that will be applied to the branch. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(null, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(null, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n-     *\n-     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n-     *              {@code kStream -> kStream} function will be used. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(name, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<? super KStream<K, V>> chain,\n-                                                     final String name) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(name, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} from an existing instance.\n-     *\n-     * @param branched the instance of {@code Branched} to copy\n-     */\n-    protected Branched(final Branched<K, V> branched) {\n-        this(branched.name, branched.chainFunction, branched.chainConsumer);\n-    }\n-\n-    /**\n-     * Configure the instance of {@code Branched} with a branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null} a default branch name suffix will be generated (see\n-     *             {@link BranchedKStream} description for details)\n-     * @return {@code this}\n-     */\n-    @Override\n-    public Branched<K, V> withName(final String name) {\n-        return new Branched<>(name, chainFunction, chainConsumer);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    private final String name;\n+    private final Function<? super KStream<? super K, ? super V>,\n+            ? extends KStream<? extends K, ? extends V>> chainFunction;\n+    private final Consumer<? super KStream<? super K, ? super V>> chainConsumer;\n+\n+    private Branched(String name,\n+                     Function<? super KStream<? super K, ? super V>, ? extends KStream<? extends K, ? extends V>> chainFunction,\n+                     Consumer<? super KStream<? super K, ? super V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Configure the instance of {@link Branched} with a branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\n+     *             {@link BranchedKStream} description for details)\n+     * @return {@code this}\n+     */\n+    @Override\n+    public Branched<K, V> withName(String name) {\n+        return new Branched<>(name, chainFunction, chainConsumer);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain) {\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *              and the branch will be added to the resulting {@code Map}.\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain) {\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain, String name) {\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *      *              the respective branch will not be added to the resulting {@code Map} returned\n+     *      *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *      *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *      *              and the branch will be added to the resulting {@code Map}.\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain, String name) {\n+        return new Branched<>(name, null, chain);\n+    }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODAyMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564968023", "bodyText": "nit: {@code true}", "author": "mjsax", "createdAt": "2021-01-27T01:52:00Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODE4Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564968187", "bodyText": "nit: first match (without dash) ?", "author": "mjsax", "createdAt": "2021-01-27T01:52:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4ODgwMA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564988800", "bodyText": "\\cc @vvcephei", "author": "mjsax", "createdAt": "2021-01-27T02:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxOTkxMg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r565519912", "bodyText": "Yes, I agree, unless you want to add a noun:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n          \n          \n            \n             * The branching happens on a first-match basis: A record in the original stream is assigned to the corresponding result", "author": "vvcephei", "createdAt": "2021-01-27T18:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODE4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODU0NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564968545", "bodyText": "proposal (add) operators[ to the same {@link KStream} instance],", "author": "mjsax", "createdAt": "2021-01-27T01:53:32Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODgzMQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564968831", "bodyText": "nit: add empty line above headline for better readability in the code (won't change the produced html).", "author": "mjsax", "createdAt": "2021-01-27T01:54:24Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MDA1Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564970057", "bodyText": "If a non-null chain function -> If a chain function\n(We don't allow null as chain function.)", "author": "mjsax", "createdAt": "2021-01-27T01:57:38Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MDcwNg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564970706", "bodyText": "Remove non-null (null is not allowed anyway)", "author": "mjsax", "createdAt": "2021-01-27T01:59:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MTA2Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564971066", "bodyText": "Should we merge this sentence to the previous bullet point, instead of making a new bullet point?", "author": "mjsax", "createdAt": "2021-01-27T02:00:15Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MjczOQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564972739", "bodyText": "I think it's worth to highlight that defaultBranch / noDefaultBranch are optional (to avoid the confusion about \"builder pattern\"):\nby an optional {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}  method call (see ...).", "author": "mjsax", "createdAt": "2021-01-27T02:05:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MzAyNg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564973026", "bodyText": "Define (no s -- we use imperative in JavaDocs)", "author": "mjsax", "createdAt": "2021-01-27T02:06:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MzE5MQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564973191", "bodyText": "as above", "author": "mjsax", "createdAt": "2021-01-27T02:06:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3Mzg1MQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564973851", "bodyText": "Finalize (no `s')", "author": "mjsax", "createdAt": "2021-01-27T02:08:15Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDIxMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974213", "bodyText": "Add:\nCalling {@code defaultBranch()} or {@link #noDefaultBranch()} is optional.", "author": "mjsax", "createdAt": "2021-01-27T02:09:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDI0Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974247", "bodyText": "as above", "author": "mjsax", "createdAt": "2021-01-27T02:09:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDI3Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974273", "bodyText": "Add:\nCalling {@code defaultBranch()} or {@link #noDefaultBranch()} is optional.", "author": "mjsax", "createdAt": "2021-01-27T02:09:33Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDM2OA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974368", "bodyText": "as above", "author": "mjsax", "createdAt": "2021-01-27T02:09:49Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDQ3NA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974474", "bodyText": "Add:\nCalling {@code noDefaultBranch()} or {@link #defaultBranch()} is optional.", "author": "mjsax", "createdAt": "2021-01-27T02:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDM2OA=="}], "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\nindex 8c75de5322..c6523ac86e 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java\n\n@@ -1,169 +1,172 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Map;\n-\n-/**\n- * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n- * <p>\n- * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n- * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n- * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n- * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n- * or dropped if no default branch is created.\n- * <p>\n- * Each branch (which is a {@link KStream} instance) then can be processed either by\n- * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n- * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n- * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n- * (see <a href=\"#examples\">usage examples</a>).\n- * <p>\n- * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n- * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n- * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n- * one for each predicate, instead of branching.\n- * <p>\n- * The process of routing the records to different branches is a stateless record-by-record operation.\n- * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n- * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n- * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n- * <ul>\n- *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n- *     a prefix for each key. By default, no prefix is used\n- *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n- *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n- *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n- *     as a decimal number, starting from {@code \"1\"}\n- *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n- *     to {@code prefix + \"0\"}\n- * </ul>\n- * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n- * <ul>\n- *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n- *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n- *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n- *     is the result returned by this function\n- *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n- *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n- * </ul>\n- * For example:\n- * <pre> {@code\n- * Map<String, KStream<..., ...>> result =\n- *   source.split(Named.as(\"foo-\"))\n- *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n- *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n- *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n- *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n- *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n- * }</pre>\n- *\n- * <h2><a name=\"examples\">Usage examples</a></h2>\n- *\n- * <h3>Direct Branch Consuming</h3>\n- * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n- * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n- *\n- * <pre> {@code\n- * source.split()\n- *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n- *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n- *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n- * }</pre>\n- *\n- * <h3>Collecting branches in a single scope</h3>\n- * In other cases we want to combine branches again after splitting. The map returned by\n- * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n- * access to all the branches in the same scope:\n- *\n- * <pre> {@code\n- * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n- *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n- *     .defaultBranch(Branched.as(\"non-null\"));\n- *\n- * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n- * }</pre>\n- *\n- * <h3>Dynamic branching</h3>\n- * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n- *\n- * <pre> {@code\n- * BranchedKStream branched = stream.split();\n- * for (RecordType recordType : RecordType.values())\n- *     branched.branch((k, v) -> v.getRecType() == recordType,\n- *         Branched.withConsumer(recordType::processRecords));\n- * }</pre>\n- *\n- * @param <K> Type of keys\n- * @param <V> Type of values\n- * @see KStream\n- */\n-public interface BranchedKStream<K, V> {\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n-\n-    /**\n-     * Defines a branch for records that match the predicate.\n-     *\n-     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n-     *                  If this predicate returns {@code true} for a given record, the record will be\n-     *                  routed to the current branch and will not be evaluated against the predicates\n-     *                  for the remaining branches.\n-     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                  for {@link BranchedKStream})\n-     * @return {@code this} to facilitate method chaining\n-     */\n-    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch();\n-\n-    /**\n-     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n-     * by other branches.\n-     *\n-     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n-     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n-     *                 for {@link BranchedKStream})\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n-\n-    /**\n-     * Finalizes the construction of branches without forming a default branch.\n-     *\n-     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n-     * <a href=\"#maprules\">description</a>.\n-     */\n-    Map<String, KStream<K, V>> noDefaultBranch();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\n+ * of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <p>\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * <p>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <p>\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\n+ *     identity chain function)\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\n+ *     the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *     source.split(Named.as(\"foo-\"))\n+ *         .branch(predicate1, Branched.as(\"bar\"))            // \"foo-bar\"\n+ *         .branch(predicate2, Branched.with(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *         .branch(predicate3, Branched.with(ks->null))       // no entry: chain function returns null\n+ *         .branch(predicate4)                                // \"foo-4\": name defaults to the branch position\n+ *         .defaultBranch()                                   // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.with(ks -> ks.to(\"A\")))\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.with(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.with(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split()\n+ *     .branch((key, value) -> value == null, Branched.with(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"non-null\").merge(branches.get(\"null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.with(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> noDefaultBranch();\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDkwMg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974902", "bodyText": "2.7 -> 2.8", "author": "mjsax", "createdAt": "2021-01-27T02:11:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -773,10 +775,32 @@\n      * @param named  a {@link Named} config used to name the processor in the topology\n      * @param predicates the ordered list of {@link Predicate} instances\n      * @return multiple distinct substreams of this {@code KStream}\n+     * @deprecated since 2.7. Use {@link #split(Named)} instead.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java\nindex 0387ae4705..765b6b8b30 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java\n\n@@ -782,7 +782,7 @@ public interface KStream<K, V> {\n     KStream<K, V>[] branch(final Named named, final Predicate<? super K, ? super V>... predicates);\n \n     /**\n-     * Split this stream. {@link BranchedKStream} can be used for routing the records to different branches depending\n+     * Splits this stream. {@link BranchedKStream} can be used for routing the records to different branches depending\n      * on evaluation against the supplied predicates.\n      * Stream branching is a stateless record-by-record operation.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4MjY1Mg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564982652", "bodyText": "Missing null check for name", "author": "mjsax", "createdAt": "2021-01-27T02:34:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4Nzc2OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564987769", "bodyText": "\\cc @vvcephei", "author": "mjsax", "createdAt": "2021-01-27T02:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4MjY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxOTA2Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r565519066", "bodyText": "I agree, it seems like a good idea to check for null here.", "author": "vvcephei", "createdAt": "2021-01-27T17:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4MjY1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 342d159a46..b148a50278 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -1,149 +1,140 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-/**\n- * The {@code Branched} class is used to define the optional parameters when building branches with\n- * {@link BranchedKStream}.\n- *\n- * @param <K> type of record key\n- * @param <V> type of record value\n- */\n-public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n-\n-    protected final String name;\n-    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n-    protected final Consumer<? super KStream<K, V>> chainConsumer;\n-\n-    protected Branched(final String name,\n-                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n-                       final Consumer<? super KStream<K, V>> chainConsumer) {\n-        this.name = name;\n-        this.chainFunction = chainFunction;\n-        this.chainConsumer = chainConsumer;\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *             (see {@link BranchedKStream} description for details)\n-     * @param <K>  key type\n-     * @param <V>  value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> as(final String name) {\n-        return new Branched<>(name, null, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function.\n-     *\n-     * @param chain A function that will be applied to the branch. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(null, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(null, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n-     *\n-     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n-     *              {@code kStream -> kStream} function will be used. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(name, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<? super KStream<K, V>> chain,\n-                                                     final String name) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(name, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} from an existing instance.\n-     *\n-     * @param branched the instance of {@code Branched} to copy\n-     */\n-    protected Branched(final Branched<K, V> branched) {\n-        this(branched.name, branched.chainFunction, branched.chainConsumer);\n-    }\n-\n-    /**\n-     * Configure the instance of {@code Branched} with a branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null} a default branch name suffix will be generated (see\n-     *             {@link BranchedKStream} description for details)\n-     * @return {@code this}\n-     */\n-    @Override\n-    public Branched<K, V> withName(final String name) {\n-        return new Branched<>(name, chainFunction, chainConsumer);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    private final String name;\n+    private final Function<? super KStream<? super K, ? super V>,\n+            ? extends KStream<? extends K, ? extends V>> chainFunction;\n+    private final Consumer<? super KStream<? super K, ? super V>> chainConsumer;\n+\n+    private Branched(String name,\n+                     Function<? super KStream<? super K, ? super V>, ? extends KStream<? extends K, ? extends V>> chainFunction,\n+                     Consumer<? super KStream<? super K, ? super V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Configure the instance of {@link Branched} with a branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\n+     *             {@link BranchedKStream} description for details)\n+     * @return {@code this}\n+     */\n+    @Override\n+    public Branched<K, V> withName(String name) {\n+        return new Branched<>(name, chainFunction, chainConsumer);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain) {\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *              and the branch will be added to the resulting {@code Map}.\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain) {\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain, String name) {\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *      *              the respective branch will not be added to the resulting {@code Map} returned\n+     *      *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *      *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *      *              and the branch will be added to the resulting {@code Map}.\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain, String name) {\n+        return new Branched<>(name, null, chain);\n+    }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4MzA0Mg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564983042", "bodyText": "remove: If {@code null}, a default branch name suffix will be generated (we should not allow null to align to other methods, eg, Named.as())", "author": "mjsax", "createdAt": "2021-01-27T02:35:33Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\nindex 342d159a46..b148a50278 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java\n\n@@ -1,149 +1,140 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.kstream;\n-\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-/**\n- * The {@code Branched} class is used to define the optional parameters when building branches with\n- * {@link BranchedKStream}.\n- *\n- * @param <K> type of record key\n- * @param <V> type of record value\n- */\n-public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n-\n-    protected final String name;\n-    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n-    protected final Consumer<? super KStream<K, V>> chainConsumer;\n-\n-    protected Branched(final String name,\n-                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n-                       final Consumer<? super KStream<K, V>> chainConsumer) {\n-        this.name = name;\n-        this.chainFunction = chainFunction;\n-        this.chainConsumer = chainConsumer;\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *             (see {@link BranchedKStream} description for details)\n-     * @param <K>  key type\n-     * @param <V>  value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> as(final String name) {\n-        return new Branched<>(name, null, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function.\n-     *\n-     * @param chain A function that will be applied to the branch. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(null, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(null, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n-     *\n-     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n-     *              {@code kStream -> kStream} function will be used. If the provided function returns\n-     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withFunction(\n-            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n-        Objects.requireNonNull(chain, \"chain function should not be null\");\n-        return new Branched<>(name, chain, null);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n-     *\n-     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,\n-     *              the respective branch will not be added to the resulting {@code Map} returned\n-     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n-     *              {@link BranchedKStream} description for details).\n-     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n-     *              (see {@link BranchedKStream} description for details)\n-     * @param <K>   key type\n-     * @param <V>   value type\n-     * @return a new instance of {@code Branched}\n-     */\n-    public static <K, V> Branched<K, V> withConsumer(final Consumer<? super KStream<K, V>> chain,\n-                                                     final String name) {\n-        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n-        return new Branched<>(name, null, chain);\n-    }\n-\n-    /**\n-     * Create an instance of {@code Branched} from an existing instance.\n-     *\n-     * @param branched the instance of {@code Branched} to copy\n-     */\n-    protected Branched(final Branched<K, V> branched) {\n-        this(branched.name, branched.chainFunction, branched.chainConsumer);\n-    }\n-\n-    /**\n-     * Configure the instance of {@code Branched} with a branch name suffix.\n-     *\n-     * @param name the branch name suffix to be used. If {@code null} a default branch name suffix will be generated (see\n-     *             {@link BranchedKStream} description for details)\n-     * @return {@code this}\n-     */\n-    @Override\n-    public Branched<K, V> withName(final String name) {\n-        return new Branched<>(name, chainFunction, chainConsumer);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    private final String name;\n+    private final Function<? super KStream<? super K, ? super V>,\n+            ? extends KStream<? extends K, ? extends V>> chainFunction;\n+    private final Consumer<? super KStream<? super K, ? super V>> chainConsumer;\n+\n+    private Branched(String name,\n+                     Function<? super KStream<? super K, ? super V>, ? extends KStream<? extends K, ? extends V>> chainFunction,\n+                     Consumer<? super KStream<? super K, ? super V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Configure the instance of {@link Branched} with a branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\n+     *             {@link BranchedKStream} description for details)\n+     * @return {@code this}\n+     */\n+    @Override\n+    public Branched<K, V> withName(String name) {\n+        return new Branched<>(name, chainFunction, chainConsumer);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided branch name postfix.\n+     *\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain) {\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *              and the branch will be added to the resulting {@code Map}.\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain) {\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(\n+            Function<? super KStream<? super K, ? super V>,\n+                    ? extends KStream<? extends K, ? extends V>> chain, String name) {\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\n+     *      *              the respective branch will not be added to the resulting {@code Map} returned\n+     *      *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *      *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\n+     *      *              and the branch will be added to the resulting {@code Map}.\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@link Branched}\n+     */\n+    public static <K, V> Branched<K, V> with(Consumer<? super KStream<? super K, ? super V>> chain, String name) {\n+        return new Branched<>(name, null, chain);\n+    }\n+}\n"}}, {"oid": "199fd074baaa05ca691192355b68e1618c0de778", "url": "https://github.com/apache/kafka/commit/199fd074baaa05ca691192355b68e1618c0de778", "message": "Rewrite StreamsGraphTest using split()", "committedDate": "2021-01-28T03:14:40Z", "type": "forcePushed"}, {"oid": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "url": "https://github.com/apache/kafka/commit/1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "message": "public interfaces and JavaDoc", "committedDate": "2021-02-02T11:32:35Z", "type": "commit"}, {"oid": "2ccaeac4b5af57cf48d36e454eb1a241ccc6c2da", "url": "https://github.com/apache/kafka/commit/2ccaeac4b5af57cf48d36e454eb1a241ccc6c2da", "message": "added implementation class", "committedDate": "2021-02-02T11:32:36Z", "type": "commit"}, {"oid": "876421a0c2fae8c3c9dd850050a32d0b8f05c97f", "url": "https://github.com/apache/kafka/commit/876421a0c2fae8c3c9dd850050a32d0b8f05c97f", "message": "update reference in JavaDoc", "committedDate": "2021-02-02T11:32:37Z", "type": "commit"}, {"oid": "73c0349163db6346bd6c8c5687eb23f447724c9d", "url": "https://github.com/apache/kafka/commit/73c0349163db6346bd6c8c5687eb23f447724c9d", "message": "remove compiler warnings", "committedDate": "2021-02-02T11:32:38Z", "type": "commit"}, {"oid": "74b21f97cba2a9b39dbbaa0dc10dd9332ef7b40f", "url": "https://github.com/apache/kafka/commit/74b21f97cba2a9b39dbbaa0dc10dd9332ef7b40f", "message": "implementation and test", "committedDate": "2021-02-02T11:32:40Z", "type": "commit"}, {"oid": "c60a1a0a207faef40dd30033486e83432aeae7aa", "url": "https://github.com/apache/kafka/commit/c60a1a0a207faef40dd30033486e83432aeae7aa", "message": "more tests", "committedDate": "2021-02-02T11:32:41Z", "type": "commit"}, {"oid": "15dd15233180dbfc45c15a50b46aa3c830c3e7da", "url": "https://github.com/apache/kafka/commit/15dd15233180dbfc45c15a50b46aa3c830c3e7da", "message": "Documentation update", "committedDate": "2021-02-02T11:32:42Z", "type": "commit"}, {"oid": "106ca5dd7f8abac27f39054b3e9a0a773c5041b9", "url": "https://github.com/apache/kafka/commit/106ca5dd7f8abac27f39054b3e9a0a773c5041b9", "message": "code review fixes", "committedDate": "2021-02-02T11:32:43Z", "type": "commit"}, {"oid": "184728d2b4c82e5d8b954dcf21bc0ba07b037958", "url": "https://github.com/apache/kafka/commit/184728d2b4c82e5d8b954dcf21bc0ba07b037958", "message": "requireNonNull for chain function and consumer", "committedDate": "2021-02-02T11:32:43Z", "type": "commit"}, {"oid": "89a79e3ff4a86e99377f0c63c027c8b08f590a07", "url": "https://github.com/apache/kafka/commit/89a79e3ff4a86e99377f0c63c027c8b08f590a07", "message": "test for branching with no defaultBranch()/noDefaultBranch()", "committedDate": "2021-02-02T11:32:44Z", "type": "commit"}, {"oid": "cb5f1a6412146a309e43102b843ef0375d18f69e", "url": "https://github.com/apache/kafka/commit/cb5f1a6412146a309e43102b843ef0375d18f69e", "message": "changelog, naming convention for BranchedInternal", "committedDate": "2021-02-02T11:32:45Z", "type": "commit"}, {"oid": "9179a33177f5f67ff332845e5f3ee372142025e2", "url": "https://github.com/apache/kafka/commit/9179a33177f5f67ff332845e5f3ee372142025e2", "message": "Scala API wrapper", "committedDate": "2021-02-02T14:43:24Z", "type": "commit"}, {"oid": "ad6d6cca6f5bf82ed06849878ebeb326f20d01c7", "url": "https://github.com/apache/kafka/commit/ad6d6cca6f5bf82ed06849878ebeb326f20d01c7", "message": "spotlessApply", "committedDate": "2021-02-02T14:43:26Z", "type": "commit"}, {"oid": "bb684e06f533a2b8b449ea079cf1c7c56e3888c0", "url": "https://github.com/apache/kafka/commit/bb684e06f533a2b8b449ea079cf1c7c56e3888c0", "message": "Correct the test to use the Scala Branched, not the Java one.", "committedDate": "2021-02-02T14:43:27Z", "type": "commit"}, {"oid": "4780f5279ccda10880f806db57689dc1379f633b", "url": "https://github.com/apache/kafka/commit/4780f5279ccda10880f806db57689dc1379f633b", "message": "Use default arguments instead of method overloads", "committedDate": "2021-02-02T14:43:29Z", "type": "commit"}, {"oid": "f4fbe74421f102124d7ebfe8df79ea933b97e460", "url": "https://github.com/apache/kafka/commit/f4fbe74421f102124d7ebfe8df79ea933b97e460", "message": "Use \"suffix\" instead of \"postfix\"", "committedDate": "2021-02-02T14:43:31Z", "type": "commit"}, {"oid": "aa3309e99448212034075961ed0c1e3d2fcff9c1", "url": "https://github.com/apache/kafka/commit/aa3309e99448212034075961ed0c1e3d2fcff9c1", "message": "convert CRLF -> LF", "committedDate": "2021-02-02T14:43:32Z", "type": "commit"}, {"oid": "c0540b16e45885e537eee3e90e9a9b3c7eb9afb3", "url": "https://github.com/apache/kafka/commit/c0540b16e45885e537eee3e90e9a9b3c7eb9afb3", "message": "fixed JavaDoc/Scaladoc\n\n* consumers cannot be null\n* typo: \"function\"->\"consumer\"", "committedDate": "2021-02-02T14:43:33Z", "type": "commit"}, {"oid": "68a830aaff0c4e8ce83f34a846316be9f2a1df31", "url": "https://github.com/apache/kafka/commit/68a830aaff0c4e8ce83f34a846316be9f2a1df31", "message": "Rewrite StreamsGraphTest using split()", "committedDate": "2021-02-02T14:43:34Z", "type": "commit"}, {"oid": "a82e991edd7701282b266cd3fadec14ff91ebbbc", "url": "https://github.com/apache/kafka/commit/a82e991edd7701282b266cd3fadec14ff91ebbbc", "message": "Javadoc/Scaladoc and Developer Guide updates", "committedDate": "2021-02-02T14:43:37Z", "type": "commit"}, {"oid": "a99018f2aafda722dbb56d4b4201b744408d45f7", "url": "https://github.com/apache/kafka/commit/a99018f2aafda722dbb56d4b4201b744408d45f7", "message": "unused Named import", "committedDate": "2021-02-02T15:04:25Z", "type": "commit"}, {"oid": "a99018f2aafda722dbb56d4b4201b744408d45f7", "url": "https://github.com/apache/kafka/commit/a99018f2aafda722dbb56d4b4201b744408d45f7", "message": "unused Named import", "committedDate": "2021-02-02T15:04:25Z", "type": "forcePushed"}, {"oid": "db573f522fa959d82d85b6964715cf3501205d38", "url": "https://github.com/apache/kafka/commit/db573f522fa959d82d85b6964715cf3501205d38", "message": "remove FunctionConverters", "committedDate": "2021-02-02T15:11:06Z", "type": "commit"}]}