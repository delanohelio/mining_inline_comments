{"pr_number": 9186, "pr_title": "KAFKA-10277: Allow null keys with non-null mappedKey in KStreamKGlobalTable join", "pr_createdAt": "2020-08-16T08:50:47Z", "pr_url": "https://github.com/apache/kafka/pull/9186", "timeline": [{"oid": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30", "url": "https://github.com/apache/kafka/commit/6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30", "message": "KAFKA-10277: Allow null keys with non-null mappedKey in KStreamGlobalKTable join", "committedDate": "2020-08-16T08:46:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDkzMTI4OQ==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r474931289", "bodyText": "Should we really catch NPE here? It seems like if the user wants to return a non-null mapped key from a null key, then they should handle the null case specifically in their keyMapper and not just throw an NPE. In general, an NPE is a sign that something has gone wrong. I would be pretty surprised if I threw an NPE explicitly in my user code and it just got swallowed and interpreted as if I had actually returned null.", "author": "ableegoldman", "createdAt": "2020-08-21T20:16:29Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,29 +60,46 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join\n+        // we do join iff the joining keys are equal, thus, if the mappedKey is null we cannot join\n+        // and just ignore the record.\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n+        if (!maybeMappedKey.isPresent()) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = keyMapper.apply(key, value);\n-            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));\n+            final K2 mappedKey = maybeMappedKey.get();\n+            final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n             }\n         }\n     }\n \n+    private Optional<K2> maybeExtractMappedKey(final K1 key, final V1 value) {\n+        if (value == null) {\n+            return Optional.empty();\n+        }\n+\n+        // we allow the case where the key is null but mappedKey is not null and thus\n+        // we need to guard against nullPointerExceptions. This may happen for GlobalKTables.\n+        // For KTables, the keyMapper simply returns the key, so this will never happen\n+        Optional<K2> maybeMappedKey;\n+        try {\n+            maybeMappedKey = Optional.ofNullable(keyMapper.apply(key, value));\n+        } catch (final NullPointerException e) {", "originalCommit": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE5ODg2OA==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r475198868", "bodyText": "Yea I think what you say makes sense. When I wrote this I was thinking about backwards compatibility: previously all null keys would never be passed to keyMappers but now they are. It feels like existing users might be surprised if their existing keyMappers start throwing NPEs. But it would also be suprising if the NPE a user throws get swallowed as you mentioned.\nI agree that it's better not to catch the NPE and it possibly looks like users should have always been handling the case where the key is null anyway so it should be fine?", "author": "JoelWee", "createdAt": "2020-08-23T09:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDkzMTI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgwMDQ4Mg==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r475800482", "bodyText": "Yeah the compatibility argument is reasonable, but you could say that users should have been handling the null case all along and it was just due to a bug in Streams that we never actually passed in a null key. If people aren't handling null, we should try and alert them quickly (and nothing catches people's attention faster than an NPE)", "author": "ableegoldman", "createdAt": "2020-08-24T18:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDkzMTI4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e9616c64dfdc33481d0b831f80ecd0385801c761", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\nindex 9af4174b35..4a0d7cccda 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n\n@@ -67,15 +65,14 @@ class KStreamKTableJoinProcessor<K1, K2, V1, V2, R> extends AbstractProcessor<K1\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n-        if (!maybeMappedKey.isPresent()) {\n+        final K2 mappedKey = keyMapper.apply(key, value);\n+        if (mappedKey == null || value == null) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = maybeMappedKey.get();\n             final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDkzNTcyNg==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r474935726", "bodyText": "Why remove this check? The valueGetter.get does an actual table lookup, which would be wasteful if we're going to skip this record anyways because the mapped key is null. Also, I'm pretty sure the lookup would throw an NPE", "author": "ableegoldman", "createdAt": "2020-08-21T20:21:58Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,29 +60,46 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join\n+        // we do join iff the joining keys are equal, thus, if the mappedKey is null we cannot join\n+        // and just ignore the record.\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n+        if (!maybeMappedKey.isPresent()) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = keyMapper.apply(key, value);\n-            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));", "originalCommit": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE5Njk0NA==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r475196944", "bodyText": "maybeExtractMappedKey will return Optional.empty() if the mappedKey is null. So mappedKey will never be null in this portion of the code and we can skip the check I think", "author": "JoelWee", "createdAt": "2020-08-23T09:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDkzNTcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5MTEyNg==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r475791126", "bodyText": "Oh yeah, duh. Nevermind this \ud83d\ude42", "author": "ableegoldman", "createdAt": "2020-08-24T17:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDkzNTcyNg=="}], "type": "inlineReview", "revised_code": {"commit": "e9616c64dfdc33481d0b831f80ecd0385801c761", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\nindex 9af4174b35..4a0d7cccda 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n\n@@ -67,15 +65,14 @@ class KStreamKTableJoinProcessor<K1, K2, V1, V2, R> extends AbstractProcessor<K1\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n-        if (!maybeMappedKey.isPresent()) {\n+        final K2 mappedKey = keyMapper.apply(key, value);\n+        if (mappedKey == null || value == null) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = maybeMappedKey.get();\n             final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk0MTczOA==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r474941738", "bodyText": "We need to remove this too, right? We shouldn't forward anything regardless of whether it's a left join, if the mapped key is null then there's nothing to map it to", "author": "ableegoldman", "createdAt": "2020-08-21T20:29:31Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,29 +60,46 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join\n+        // we do join iff the joining keys are equal, thus, if the mappedKey is null we cannot join\n+        // and just ignore the record.\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n+        if (!maybeMappedKey.isPresent()) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = keyMapper.apply(key, value);\n-            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));\n+            final K2 mappedKey = maybeMappedKey.get();\n+            final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {", "originalCommit": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9616c64dfdc33481d0b831f80ecd0385801c761", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\nindex 9af4174b35..4a0d7cccda 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n\n@@ -67,15 +65,14 @@ class KStreamKTableJoinProcessor<K1, K2, V1, V2, R> extends AbstractProcessor<K1\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n-        if (!maybeMappedKey.isPresent()) {\n+        final K2 mappedKey = keyMapper.apply(key, value);\n+        if (mappedKey == null || value == null) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = maybeMappedKey.get();\n             final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5Mjc0NQ==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r475792745", "bodyText": "This seems a little subtle. Can we just return the actual mapped key (or .empty()) in this method, and keep the explicit null check for value up above?", "author": "ableegoldman", "createdAt": "2020-08-24T17:53:24Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,29 +60,46 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join\n+        // we do join iff the joining keys are equal, thus, if the mappedKey is null we cannot join\n+        // and just ignore the record.\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n+        if (!maybeMappedKey.isPresent()) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = keyMapper.apply(key, value);\n-            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));\n+            final K2 mappedKey = maybeMappedKey.get();\n+            final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n             }\n         }\n     }\n \n+    private Optional<K2> maybeExtractMappedKey(final K1 key, final V1 value) {\n+        if (value == null) {\n+            return Optional.empty();", "originalCommit": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxOTA4Ng==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r477019086", "bodyText": "Yep agreed \u2013 was originally worried about NPEs arising from the null value as well. Done now :)", "author": "JoelWee", "createdAt": "2020-08-26T03:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5Mjc0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e9616c64dfdc33481d0b831f80ecd0385801c761", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\nindex 9af4174b35..4a0d7cccda 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n\n@@ -67,15 +65,14 @@ class KStreamKTableJoinProcessor<K1, K2, V1, V2, R> extends AbstractProcessor<K1\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n-        if (!maybeMappedKey.isPresent()) {\n+        final K2 mappedKey = keyMapper.apply(key, value);\n+        if (mappedKey == null || value == null) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = maybeMappedKey.get();\n             final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n"}}, {"oid": "e9616c64dfdc33481d0b831f80ecd0385801c761", "url": "https://github.com/apache/kafka/commit/e9616c64dfdc33481d0b831f80ecd0385801c761", "message": "KAFKA-10277: refactor join processor", "committedDate": "2020-08-26T03:55:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYwMjAxMA==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r481602010", "bodyText": "It looks like we removed this comment about not ignoring it if it's a left join, but we didn't actually remove the code for that (yet). Which one is right? It seems like the comment is correct, and we shouldn't ignore the null key regardless of whether it is a left join. In that case, we should remove the leftJoin  part of the condition on line 78 below", "author": "ableegoldman", "createdAt": "2020-09-02T03:24:43Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,23 +58,22 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join", "originalCommit": "e9616c64dfdc33481d0b831f80ecd0385801c761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk5ODMzOA==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r483998338", "bodyText": "Yea I agree the comment is right and we need to allow the case of non-null key with null mappedKey when it's a left join, since we view a null mappedKey as equivalent to \"key not found in GlobalKTable\" (except if the key is null, in which it should just be invalid I think?). Have made the changes now.", "author": "JoelWee", "createdAt": "2020-09-05T23:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYwMjAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NzE4Ng==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485097186", "bodyText": "Sorry, I think my original comment here was a bit ambiguous & confusingly phrased. What I meant was that the removal of the comment seemed correct to me, ie we should not make any special exceptions for the left join case and should remove the leftJoin part of the if (leftJoin || value2 != null)  check down on line 79", "author": "ableegoldman", "createdAt": "2020-09-08T17:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYwMjAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzMDk0Mg==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485130942", "bodyText": "Right, thanks for the clarification! Wouldn't we still want the leftJoin in that case though? When we reach the leftJoin in the code, the mappedKey is never null but it might not exist in the GlobalKTable (and so value2 is null). If we're doing a leftJoin, then we'll want to allow these null values? (If not, the leftJoin is just the same as the normal join?)", "author": "JoelWee", "createdAt": "2020-09-08T18:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYwMjAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIxNzI3OA==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485217278", "bodyText": "Ah yeah sorry, I'm getting things mixed up here...this comment is referring to when the mappedKey is null while the condition I cited below now only applies to when the value is null.  Your reasoning sounds correct, we should still process the record in that case if it's a left join. But we should also remove this comment, since if the mappedKey is null then we drop it, regardless of if its a left join or any other", "author": "ableegoldman", "createdAt": "2020-09-08T21:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYwMjAxMA=="}], "type": "inlineReview", "revised_code": {"commit": "29c988afbb5d506474413ab387a45438cc0528d6", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\nindex 4a0d7cccda..e7803fcc2a 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n\n@@ -58,22 +58,24 @@ class KStreamKTableJoinProcessor<K1, K2, V1, V2, R> extends AbstractProcessor<K1\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff the joining keys are equal, thus, if the mappedKey is null we cannot join\n-        // and just ignore the record.\n+        // We allow null keys unless {@code keyMapper} returns {@code null} and we ignore it as invalid.\n+        // This happens for GlobalKTables but never for KTables since keyMapper just returns the key.\n+        // For non-null keys, if {@code keyMapper} returns {@code null} it implies there is no match,\n+        // so ignore unless it is a left join\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n         final K2 mappedKey = keyMapper.apply(key, value);\n-        if (mappedKey == null || value == null) {\n+        if ((key == null && mappedKey == null) || (!leftJoin && mappedKey == null) || value == null) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n+            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n             }\n"}}, {"oid": "29c988afbb5d506474413ab387a45438cc0528d6", "url": "https://github.com/apache/kafka/commit/29c988afbb5d506474413ab387a45438cc0528d6", "message": "KAFKA-10277: Fix null mappedKey with leftJoin condition", "committedDate": "2020-09-05T23:07:09Z", "type": "commit"}, {"oid": "29c988afbb5d506474413ab387a45438cc0528d6", "url": "https://github.com/apache/kafka/commit/29c988afbb5d506474413ab387a45438cc0528d6", "message": "KAFKA-10277: Fix null mappedKey with leftJoin condition", "committedDate": "2020-09-05T23:07:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NTczNQ==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485095735", "bodyText": "I guess we don't care about the original key any longer and only consider if keyMapper returns null or not?", "author": "mjsax", "createdAt": "2020-09-08T17:50:50Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,22 +58,23 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n+        // We allow null keys unless {@code keyMapper} returns {@code null} and we ignore it as invalid.", "originalCommit": "29c988afbb5d506474413ab387a45438cc0528d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNjY1NA==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485126654", "bodyText": "I think that makes sense - but that will mean removing the previous logic of \"mappedKey is null implies key not found in global table\"? (Original line 62)", "author": "JoelWee", "createdAt": "2020-09-08T18:48:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NTczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIxODYyNQ==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485218625", "bodyText": "Well, if mappedKey is null then there can't be a match in the global table since we can't do a lookup with a null key. I think what @mjsax means here (correct me if wrong) is just that we could phrase it a bit differently to say something like\n// If the mappedKey is null, we ignore it as invalid. This should never happen for KTables \n// since keyMapper just returns the key, but for GlobalKTables a non-null key can result \n// in a null mappedKey. There can't be a match for a null mappedKey, so we drop it\n\n...or something. Thoughts?", "author": "ableegoldman", "createdAt": "2020-09-08T21:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NTczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0NDQxMw==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485244413", "bodyText": "Yep makes sense. Have updated it now. Just noting here that this means we're changing a test we previously had", "author": "JoelWee", "createdAt": "2020-09-08T23:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NTczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d23f46c11c41b03834d67e5cdc6b558923365d61", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\nindex e7803fcc2a..0da96ecd76 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n\n@@ -58,24 +58,23 @@ class KStreamKTableJoinProcessor<K1, K2, V1, V2, R> extends AbstractProcessor<K1\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // We allow null keys unless {@code keyMapper} returns {@code null} and we ignore it as invalid.\n-        // This happens for GlobalKTables but never for KTables since keyMapper just returns the key.\n-        // For non-null keys, if {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join\n+        // we do join iff the join keys are equal, thus, if {@code keyMapper} returns {@code null} we\n+        // cannot join and just ignore the record. Note for KTables, this is the same as having a null key\n+        // since keyMapper just returns the key, but for GlobalKTables we can have other keyMappers\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n         final K2 mappedKey = keyMapper.apply(key, value);\n-        if ((key == null && mappedKey == null) || (!leftJoin && mappedKey == null) || value == null) {\n+        if (mappedKey == null || value == null) {\n             LOG.warn(\n-                \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n-                key, value, context().topic(), context().partition(), context().offset()\n+                    \"Skipping record due to null join key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));\n+            final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NjA5MA==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485096090", "bodyText": "This condition seems unnecessary complex. Should it not just be:\nif (mappedKey == null || value == null) {", "author": "mjsax", "createdAt": "2020-09-08T17:51:26Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,22 +58,23 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n+        // We allow null keys unless {@code keyMapper} returns {@code null} and we ignore it as invalid.\n+        // This happens for GlobalKTables but never for KTables since keyMapper just returns the key.\n+        // For non-null keys, if {@code keyMapper} returns {@code null} it implies there is no match,\n         // so ignore unless it is a left join\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final K2 mappedKey = keyMapper.apply(key, value);\n+        if ((key == null && mappedKey == null) || (!leftJoin && mappedKey == null) || value == null) {", "originalCommit": "29c988afbb5d506474413ab387a45438cc0528d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d23f46c11c41b03834d67e5cdc6b558923365d61", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\nindex e7803fcc2a..0da96ecd76 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n\n@@ -58,24 +58,23 @@ class KStreamKTableJoinProcessor<K1, K2, V1, V2, R> extends AbstractProcessor<K1\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // We allow null keys unless {@code keyMapper} returns {@code null} and we ignore it as invalid.\n-        // This happens for GlobalKTables but never for KTables since keyMapper just returns the key.\n-        // For non-null keys, if {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join\n+        // we do join iff the join keys are equal, thus, if {@code keyMapper} returns {@code null} we\n+        // cannot join and just ignore the record. Note for KTables, this is the same as having a null key\n+        // since keyMapper just returns the key, but for GlobalKTables we can have other keyMappers\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n         final K2 mappedKey = keyMapper.apply(key, value);\n-        if ((key == null && mappedKey == null) || (!leftJoin && mappedKey == null) || value == null) {\n+        if (mappedKey == null || value == null) {\n             LOG.warn(\n-                \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n-                key, value, context().topic(), context().partition(), context().offset()\n+                    \"Skipping record due to null join key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));\n+            final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NjU4MQ==", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485096581", "bodyText": "At this point, we know that mappedKey != null, otherwise, we would have dropped the record.", "author": "mjsax", "createdAt": "2020-09-08T17:52:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,22 +58,23 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n+        // We allow null keys unless {@code keyMapper} returns {@code null} and we ignore it as invalid.\n+        // This happens for GlobalKTables but never for KTables since keyMapper just returns the key.\n+        // For non-null keys, if {@code keyMapper} returns {@code null} it implies there is no match,\n         // so ignore unless it is a left join\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final K2 mappedKey = keyMapper.apply(key, value);\n+        if ((key == null && mappedKey == null) || (!leftJoin && mappedKey == null) || value == null) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = keyMapper.apply(key, value);\n             final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));", "originalCommit": "29c988afbb5d506474413ab387a45438cc0528d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d23f46c11c41b03834d67e5cdc6b558923365d61", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\nindex e7803fcc2a..0da96ecd76 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java\n\n@@ -58,24 +58,23 @@ class KStreamKTableJoinProcessor<K1, K2, V1, V2, R> extends AbstractProcessor<K1\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // We allow null keys unless {@code keyMapper} returns {@code null} and we ignore it as invalid.\n-        // This happens for GlobalKTables but never for KTables since keyMapper just returns the key.\n-        // For non-null keys, if {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join\n+        // we do join iff the join keys are equal, thus, if {@code keyMapper} returns {@code null} we\n+        // cannot join and just ignore the record. Note for KTables, this is the same as having a null key\n+        // since keyMapper just returns the key, but for GlobalKTables we can have other keyMappers\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n         final K2 mappedKey = keyMapper.apply(key, value);\n-        if ((key == null && mappedKey == null) || (!leftJoin && mappedKey == null) || value == null) {\n+        if (mappedKey == null || value == null) {\n             LOG.warn(\n-                \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n-                key, value, context().topic(), context().partition(), context().offset()\n+                    \"Skipping record due to null join key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));\n+            final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n             }\n"}}, {"oid": "d23f46c11c41b03834d67e5cdc6b558923365d61", "url": "https://github.com/apache/kafka/commit/d23f46c11c41b03834d67e5cdc6b558923365d61", "message": "KAFKA-10277: fix mappedKey logic", "committedDate": "2020-09-08T23:03:41Z", "type": "commit"}]}