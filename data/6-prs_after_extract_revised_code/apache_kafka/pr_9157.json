{"pr_number": 9157, "pr_title": "KAFKA-5636: Update for KIP-450 to handle early records", "pr_createdAt": "2020-08-10T18:26:27Z", "pr_url": "https://github.com/apache/kafka/pull/9157", "timeline": [{"oid": "1b2b7583c481a7fbd3dedc35c838e3d98603e16d", "url": "https://github.com/apache/kafka/commit/1b2b7583c481a7fbd3dedc35c838e3d98603e16d", "message": "Initial classes for SlidingWindows, changes to processors", "committedDate": "2020-07-17T15:42:48Z", "type": "commit"}, {"oid": "3ee045a49a0c5e6478112af400e57c277b38f312", "url": "https://github.com/apache/kafka/commit/3ee045a49a0c5e6478112af400e57c277b38f312", "message": "updates to processor", "committedDate": "2020-07-17T18:31:10Z", "type": "commit"}, {"oid": "ff6ca4f62482d32f2f22a45647448727cfb67980", "url": "https://github.com/apache/kafka/commit/ff6ca4f62482d32f2f22a45647448727cfb67980", "message": "updated for grace period checks", "committedDate": "2020-07-17T20:19:34Z", "type": "commit"}, {"oid": "56a86f1718ba74e6ce4b808cb205ecf71a3d0b16", "url": "https://github.com/apache/kafka/commit/56a86f1718ba74e6ce4b808cb205ecf71a3d0b16", "message": "fixes for checkstyle", "committedDate": "2020-07-20T14:17:03Z", "type": "commit"}, {"oid": "0a3d6d490f0894ad128d4f981f9d7f87cf165f7d", "url": "https://github.com/apache/kafka/commit/0a3d6d490f0894ad128d4f981f9d7f87cf165f7d", "message": "fixes for checkstyle", "committedDate": "2020-07-20T14:20:42Z", "type": "commit"}, {"oid": "c6d358dfb62d09f4e8f406487b1f887c3db49267", "url": "https://github.com/apache/kafka/commit/c6d358dfb62d09f4e8f406487b1f887c3db49267", "message": "update algorithm, KIP changes, test", "committedDate": "2020-07-27T22:19:10Z", "type": "commit"}, {"oid": "0c1541ab543d2cfa0cb5e1e5288d39ec86187317", "url": "https://github.com/apache/kafka/commit/0c1541ab543d2cfa0cb5e1e5288d39ec86187317", "message": "Merge remote-tracking branch 'upstream/trunk' into slidingwindows", "committedDate": "2020-07-27T22:27:14Z", "type": "commit"}, {"oid": "7f1b886f9da1f0ee5d84806875f93088c7b3c4d8", "url": "https://github.com/apache/kafka/commit/7f1b886f9da1f0ee5d84806875f93088c7b3c4d8", "message": "updates for windowedBy and associated processors", "committedDate": "2020-07-28T16:36:31Z", "type": "commit"}, {"oid": "de89fe07b9ac515a0c430274200c39cadddbf64b", "url": "https://github.com/apache/kafka/commit/de89fe07b9ac515a0c430274200c39cadddbf64b", "message": "test fixes, updating algorithms", "committedDate": "2020-07-29T17:10:05Z", "type": "commit"}, {"oid": "35e637d6c0d932129d69b50072d2d1b412af7d10", "url": "https://github.com/apache/kafka/commit/35e637d6c0d932129d69b50072d2d1b412af7d10", "message": ":review updates", "committedDate": "2020-07-31T19:59:41Z", "type": "commit"}, {"oid": "dc2f65f711a54e995094a1885df1dc728c479b1b", "url": "https://github.com/apache/kafka/commit/dc2f65f711a54e995094a1885df1dc728c479b1b", "message": "review updates, test additions", "committedDate": "2020-08-05T00:09:33Z", "type": "commit"}, {"oid": "9cca939e7b54f60cbbf0fc8abdd0f94fbbe19f45", "url": "https://github.com/apache/kafka/commit/9cca939e7b54f60cbbf0fc8abdd0f94fbbe19f45", "message": "sophie's reviews", "committedDate": "2020-08-05T14:20:20Z", "type": "commit"}, {"oid": "e5a0d4b4a60f55d2ee7f412486ed8b567d493e25", "url": "https://github.com/apache/kafka/commit/e5a0d4b4a60f55d2ee7f412486ed8b567d493e25", "message": "cleaning up pr", "committedDate": "2020-08-05T15:37:05Z", "type": "commit"}, {"oid": "0afd88e97047c97e91e6d6273eb909e76eb782f4", "url": "https://github.com/apache/kafka/commit/0afd88e97047c97e91e6d6273eb909e76eb782f4", "message": "Merge branch 'trunk' of github.com:apache/kafka into slidingwindows", "committedDate": "2020-08-05T18:54:34Z", "type": "commit"}, {"oid": "24d91d8c33d3d3660f548623d6bcc7ef727d0862", "url": "https://github.com/apache/kafka/commit/24d91d8c33d3d3660f548623d6bcc7ef727d0862", "message": "updated tests", "committedDate": "2020-08-05T19:43:05Z", "type": "commit"}, {"oid": "65231139fb27f8e380d8bf6552a31c09f5fd28ff", "url": "https://github.com/apache/kafka/commit/65231139fb27f8e380d8bf6552a31c09f5fd28ff", "message": "grouped k stream and suppression tests", "committedDate": "2020-08-07T15:17:24Z", "type": "commit"}, {"oid": "34b3f5a2f6dee16a514698f39187eddcfab134bc", "url": "https://github.com/apache/kafka/commit/34b3f5a2f6dee16a514698f39187eddcfab134bc", "message": "removing reverse iterator, to be implemented later", "committedDate": "2020-08-07T20:41:17Z", "type": "commit"}, {"oid": "1071098d77ebda24f4a5791ca449efbb0cdabd48", "url": "https://github.com/apache/kafka/commit/1071098d77ebda24f4a5791ca449efbb0cdabd48", "message": "sophie's comments and testing updates", "committedDate": "2020-08-12T15:54:25Z", "type": "commit"}, {"oid": "824f8702114bff71944a2004cf8eadbd7144c785", "url": "https://github.com/apache/kafka/commit/824f8702114bff71944a2004cf8eadbd7144c785", "message": "trunk updates", "committedDate": "2020-08-17T14:38:32Z", "type": "commit"}, {"oid": "1163c2faa84d3bb05c178ce67ecb047a92b9a054", "url": "https://github.com/apache/kafka/commit/1163c2faa84d3bb05c178ce67ecb047a92b9a054", "message": "cogrouped builder updates", "committedDate": "2020-08-17T14:44:58Z", "type": "commit"}, {"oid": "296a6c3035f7eda71729d5cec7e16778383b7fad", "url": "https://github.com/apache/kafka/commit/296a6c3035f7eda71729d5cec7e16778383b7fad", "message": "test updates and clean up", "committedDate": "2020-08-19T18:12:59Z", "type": "commit"}, {"oid": "bb609a89ec7543943d03a1939e61f8208847ce8e", "url": "https://github.com/apache/kafka/commit/bb609a89ec7543943d03a1939e61f8208847ce8e", "message": "randomized and small test improvements", "committedDate": "2020-08-24T17:07:55Z", "type": "commit"}, {"oid": "64d4cbbdec80580a91c13a57e4d091efebf749d7", "url": "https://github.com/apache/kafka/commit/64d4cbbdec80580a91c13a57e4d091efebf749d7", "message": "testing clean up", "committedDate": "2020-08-26T16:30:45Z", "type": "commit"}, {"oid": "48328f651602f2078add6f780bb42199cd2c0316", "url": "https://github.com/apache/kafka/commit/48328f651602f2078add6f780bb42199cd2c0316", "message": "udpates wtih john's comments", "committedDate": "2020-08-28T15:04:32Z", "type": "commit"}, {"oid": "fdfb1cde038e3750bb6d8c3900558bacc18feabc", "url": "https://github.com/apache/kafka/commit/fdfb1cde038e3750bb6d8c3900558bacc18feabc", "message": "udpates wtih john's comments", "committedDate": "2020-08-28T15:42:10Z", "type": "commit"}, {"oid": "1ce06f9321e8c74eeb0c80daaf1acb0ca70f8bd8", "url": "https://github.com/apache/kafka/commit/1ce06f9321e8c74eeb0c80daaf1acb0ca70f8bd8", "message": "Merge branch 'slidingwindows' of github.com:lct45/kafka into slidingwindows", "committedDate": "2020-08-28T15:43:54Z", "type": "commit"}, {"oid": "dd8c4e431479ce88ce3e95a5fe3ba288e5741ce8", "url": "https://github.com/apache/kafka/commit/dd8c4e431479ce88ce3e95a5fe3ba288e5741ce8", "message": "fixes for early records", "committedDate": "2020-08-31T14:33:17Z", "type": "commit"}, {"oid": "8c7e736d6b0b7c9d40e946375065ac976428742b", "url": "https://github.com/apache/kafka/commit/8c7e736d6b0b7c9d40e946375065ac976428742b", "message": "working updates", "committedDate": "2020-08-31T14:33:17Z", "type": "commit"}, {"oid": "8e1d23504ad4c733718fe1f491e0c95bb28e732e", "url": "https://github.com/apache/kafka/commit/8e1d23504ad4c733718fe1f491e0c95bb28e732e", "message": "algorithm and test updates", "committedDate": "2020-08-31T14:33:17Z", "type": "commit"}, {"oid": "c061076d72e51ed0ab056a8dc808566398cbf0d2", "url": "https://github.com/apache/kafka/commit/c061076d72e51ed0ab056a8dc808566398cbf0d2", "message": "updates from sophie's comments", "committedDate": "2020-08-31T14:33:17Z", "type": "commit"}, {"oid": "b7663e7673f470ed74429440689904d92a7132d8", "url": "https://github.com/apache/kafka/commit/b7663e7673f470ed74429440689904d92a7132d8", "message": "PreviousRecord updates, method streamlining", "committedDate": "2020-08-31T15:17:44Z", "type": "commit"}, {"oid": "b7663e7673f470ed74429440689904d92a7132d8", "url": "https://github.com/apache/kafka/commit/b7663e7673f470ed74429440689904d92a7132d8", "message": "PreviousRecord updates, method streamlining", "committedDate": "2020-08-31T15:17:44Z", "type": "forcePushed"}, {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "url": "https://github.com/apache/kafka/commit/8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "message": "rebase with sliding windows pr", "committedDate": "2020-08-31T22:49:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzNTUyOA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481335528", "bodyText": "Seems like we should move this above into the top-level process instead of first calling processInOrder and then calling processEarly.  For one thing, since we actually do need to iterate the full range for the early records, we can just call processEarly without having to decide between processInOrder and processReverse", "author": "ableegoldman", "createdAt": "2020-09-01T18:08:24Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -135,7 +127,11 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             observedStreamTime = Math.max(observedStreamTime, timestamp);\n             final long closeTime = observedStreamTime - windows.gracePeriodMs();\n \n-            //store start times of windows we find\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -118,13 +118,6 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             }\n \n             final long timestamp = context().timestamp();\n-\n-            processInOrder(key, value, timestamp);\n-        }\n-\n-        public void processInOrder(final K key, final V value, final long timestamp) {\n-\n-            observedStreamTime = Math.max(observedStreamTime, timestamp);\n             final long closeTime = observedStreamTime - windows.gracePeriodMs();\n \n             if (timestamp < windows.timeDifferenceMs()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzNTg0OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481335848", "bodyText": "Use previousRecordTimestamp like in processEarly.  You can probably remove the comment then", "author": "ableegoldman", "createdAt": "2020-09-01T18:09:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,13 +142,14 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            // Store the previous record\n+            Long previousRecord = null;", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -142,8 +142,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // Store the previous record\n-            Long previousRecord = null;\n+            Long previousRecordTimestamp = null;\n \n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzODAzMA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481338030", "bodyText": "This comment doesn't really add anything, it just describes what the code says. Also, don't we need to check that   windowMaxTimestamp > previousRecordTimestamp before updating previousRecordTimestamp (where windowMaxTimestamp = next.value.timestamp -- it would be nice to assign this to a variable with an explicit name to make it clear what next.value.timestamp actually means).\nSame goes for the below, I guess you could just put the check in a maybeUpdatePreviousRecordTimestamp() method and call it from both places", "author": "ableegoldman", "createdAt": "2020-09-01T18:13:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -164,11 +161,13 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n+                        // update to store the previous record", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTgzNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481375834", "bodyText": "I'm not sure we need to check that, I think that by the nature of going through windows forward, the next window we find will always have a max timestamp that's larger than the previous window. Right? Lemme do an example:\nRecord comes in @30, previous record was at @23, timeDifference = 10. The last window we find with an endTime < timestamp will be 23's left window, where the max record value is 23. Any earlier windows with endTime < timestamp will have a max value less than 23, so we can override them safely", "author": "lct45", "createdAt": "2020-09-01T19:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzODAzMA=="}], "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -158,30 +157,30 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                     windowStartTimes.add(next.key.window().start());\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n-                        // update to store the previous record\n-                        previousRecord = next.value.timestamp();\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n                     } else if (endTime == timestamp) {\n                         leftWinAlreadyCreated = true;\n-                        if (next.value.timestamp() < timestamp) {\n-                            previousRecord = next.value.timestamp();\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n                         }\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n                     } else if (endTime > timestamp && startTime <= timestamp) {\n                         rightWinAgg = next.value;\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                    } else if (startTime == timestamp + 1){\n                         rightWinAlreadyCreated = true;\n                     }\n                 }\n             }\n \n             //create right window for previous record\n-            if (previousRecord != null) {\n-                final long previousRightWinStart = previousRecord + 1;\n-                if (!windowStartTimes.contains(previousRightWinStart)) {\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n                     final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n                     final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                     putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MTQ0Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481341446", "bodyText": "This doesn't look right..why would we need to pass in the key and value to createRightWindow ? The distinguishing feature of the current record's right window is that it doesn't  include the current record at all. I see that createRightWindow ultimately calls putAndForward which takes a key and value, but that just seems misleading. I think we should either pass in null to putAndForward for things we don't need, or better yet (imo) don't use putAndForward for the right window creation and just have a clean separation between creation of the right window and everything else", "author": "ableegoldman", "createdAt": "2020-09-01T18:19:17Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -192,7 +191,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n                 // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MjA4Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481342082", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n          \n          \n            \n                     * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create", "author": "ableegoldman", "createdAt": "2020-09-01T18:20:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -192,7 +191,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n                 // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MjM5Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481342393", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n          \n          \n            \n                     * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]", "author": "ableegoldman", "createdAt": "2020-09-01T18:20:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -192,7 +191,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n                 // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MjU2MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481342561", "bodyText": "update, or create? (or both?)", "author": "ableegoldman", "createdAt": "2020-09-01T18:21:16Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -192,7 +191,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n                 // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MzIyMA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481343220", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        //window from [0,timeDifference] that holds all early records\n          \n          \n            \n                        // A window from [0, timeDifferenceMs] that holds all early records\n          \n      \n    \n    \n  \n\nAlso I'd suggest putting the combinedWindow declaration (and comment) above rightWinAgg to avoid ambiguity in what the comment refers to", "author": "ableegoldman", "createdAt": "2020-09-01T18:22:31Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -192,7 +191,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n                 // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0NDk0NQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481344945", "bodyText": "I think we should always assign the next.value.timestamp value to a variable with an explicit name, eg windowMaxRecordTimestamp, because it's pretty non-obvious what it means and easy to forget", "author": "ableegoldman", "createdAt": "2020-09-01T18:25:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -192,7 +191,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n                 // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0ODM4Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481348387", "bodyText": "I think we should add a comment somewhere clarifying some things about how we set the previousRecordTimestamp in processEarly:\nBasically, we only need to check and maybe set it when we're on the combined window, because if it's still null when we're past the combined window then we know there was a record greater than the current record in the combined window already, and in that case we must have already created the right window for the actual previous record. Hopefully you can find a better & more concise way to explain that \ud83d\ude04", "author": "ableegoldman", "createdAt": "2020-09-01T18:32:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -192,7 +191,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n                 // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481355973", "bodyText": "Just leaving a note to the next reviewer, and making sure I understand this myself:\nIf we didn't find a right window agg that either means\n\nthere were no other windows with startTime <= timestamp, which means there are no records earlier than the current one, and no records later than timeDifference (but within range of the current record). We take that to mean that whatever is in the combined window is an aggregate of records that are all to the right of the current record. Note that there could be a record at the same timestamp as the current record, but we will check for that before actually creating the right window below (by checking !rightWinAlreadyCreated)\nThere is just a single record in the combined window that is earlier than the current record. We check for that with the combinedWindow.value.timestamp() > timestamp condition and in that case create no right window\n\nBy the way, can we move the creation of the right window to just after this block, to keep all the relevant logic together?", "author": "ableegoldman", "createdAt": "2020-09-01T18:46:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4NTQ5Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483285496", "bodyText": "Not sure if I can follow. If combinedWindow.value.timestamp() > timestamp this seems to imply that the current record is out-of-order? Above, you state that for the out-of-order case, the right window would always exist already though? So why do we need this additional check?", "author": "mjsax", "createdAt": "2020-09-03T22:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwNzA4MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483307081", "bodyText": "I think the case you're referring to above is saying that for the out-of-order case, the previous record's right window should already exist -- this line is dealing with the right window of the current record. Maybe that's a signal that we need to clarify the comment/code above (you are referring to this comment, right?)", "author": "ableegoldman", "createdAt": "2020-09-03T23:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxODQ4MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483718480", "bodyText": "Updated the comment in an attempt to do a mini-proof:\n`If there wasn't a right window agg found and we need a right window for our new record, the current aggregate in the combined window will go in the new record's right window. We can be sure that the combined window only holds records that fall into the current record's right window for two reasons:\n\nIf there were records earlier than the current record AND later than the current record, there would be a right window found when we looked for right window agg.\nIf there was only a record before the current record, we wouldn't need a right window for the current record and wouldn't update the rightWinAgg value here, as the combinedWindow.value.timestamp() < inputRecordTimestamp`", "author": "lct45", "createdAt": "2020-09-04T16:10:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0MjM2MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483742361", "bodyText": "I think the case you're referring to above is saying that for the out-of-order case, the previous record's right window should already exist -- this line is dealing with the right window of the current record.\n\nAh. I missed this.\n@lct45: the explanation makes sense. Thx!", "author": "mjsax", "createdAt": "2020-09-04T16:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -192,7 +191,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n                 // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MDY3Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481360673", "bodyText": "It's pretty weird to have to pass in key and value when they're not used to create the right window. I notice they're used in the log message for dropped late windows actually, but it seems odd that we should ever end up dropping the right window of the current record. If the record itself is that old, we should just drop it before even processing it, right?\nAssuming you do that, then it feels a lot more reasonable to not call putAndForward from createRightWindow at all, and just do the actual putting and forwarding for the right window case inline.", "author": "ableegoldman", "createdAt": "2020-09-01T18:53:58Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+                if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                    final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createRightWindow(final long timestamp,\n+                                       final ValueAndTimestamp<Agg> rightWinAgg,\n+                                       final K key,\n+                                       final V value,\n+                                       final long closeTime) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3ODIwMQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481378201", "bodyText": "Key is still used when the window is put into the windowStore, but value isn't needed. I agree that it's nice to separate them to clean up the if() checks as well", "author": "lct45", "createdAt": "2020-09-01T19:23:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MDY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2OTAyMQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481469021", "bodyText": "Oh good point, we definitely need the key. But I think separating them turned out well", "author": "ableegoldman", "createdAt": "2020-09-01T22:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MDY3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -192,7 +191,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n                 // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTQ4NQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481361485", "bodyText": "This isn't used anymore, right?", "author": "ableegoldman", "createdAt": "2020-09-01T18:54:35Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+                if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                    final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createRightWindow(final long timestamp,\n+                                       final ValueAndTimestamp<Agg> rightWinAgg,\n+                                       final K key,\n+                                       final V value,\n+                                       final long closeTime) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n         }\n \n-        private boolean isLeftWindow(final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> window) {\n-            return window.key.window().end() == window.value.timestamp();\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n+                                                        final long previousRightWindowStart,\n+                                                        final long currentRecordTimestamp) {\n+            return !windowStartTimes.contains(previousRightWindowStart) && previousRightWindowStart + windows.timeDifferenceMs() >= currentRecordTimestamp;\n+        }", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5MTk5Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481391993", "bodyText": "Just ran it with updates and we do need to check to make sure that the previous record is close enough for us to make a right window from the current record, so I've updated the processEarly create right window for previous record to call this method again", "author": "lct45", "createdAt": "2020-09-01T19:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2MzMzMw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481463333", "bodyText": "I think you mean  processInOrder, not  processEarly (this is correct in the code, it's just the latest comment that doesn't match up)", "author": "ableegoldman", "createdAt": "2020-09-01T22:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA3OTIyMA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482079220", "bodyText": "Aha yes I very much mean processInOrder", "author": "lct45", "createdAt": "2020-09-02T13:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 73455e91b3..23b415a0ba 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -192,7 +191,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n                 // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTc0OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481361749", "bodyText": "nit: remove this added line", "author": "ableegoldman", "createdAt": "2020-09-01T18:54:49Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java", "diffHunk": "@@ -239,6 +239,7 @@ private void doCountSlidingWindows(final  MockProcessorSupplier<Windowed<String>\n             inputTopic.pipeInput(\"2\", \"B\", 1000L);\n             inputTopic.pipeInput(\"3\", \"C\", 600L);\n         }\n+", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java b/streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java\nindex 4bcf1235a2..a23b98df5b 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java\n\n@@ -239,7 +239,6 @@ public class KGroupedStreamImplTest {\n             inputTopic.pipeInput(\"2\", \"B\", 1000L);\n             inputTopic.pipeInput(\"3\", \"C\", 600L);\n         }\n-\n         assertThat(supplier.theCapturedProcessor().processed(), equalTo(Arrays.asList(\n                 // processing A@500\n                 new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(0L, 500L)), 1L, 500L),\n"}}, {"oid": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "url": "https://github.com/apache/kafka/commit/7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "message": "Method clean-up", "committedDate": "2020-09-01T20:40:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2MDQxMw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481460413", "bodyText": "Sorry, I think my previous comment was a bit unclear. I meant that we should move this block up to where we set the rightWinAgg right after the loop, since this is what we actually use the rightWinAgg for.\nI think the \"create right window for previous record\" logic is fine wherever", "author": "ableegoldman", "createdAt": "2020-09-01T22:10:53Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +190,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);", "originalCommit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "99507f5d005023eec78a21b6c52cb4e228ee1434", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 23b415a0ba..1418c86f6d 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -257,6 +280,11 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                 rightWinAgg = combinedWindow.value;\n             }\n \n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n             //create the right window for the previous record if the previous record exists and the window hasn't already been created\n             if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n                 final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NTI2Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481465262", "bodyText": "Do we need to use getValueOrNull here? It seems like rightWinAgg should never be null if we are using it to create a right window", "author": "ableegoldman", "createdAt": "2020-09-01T22:22:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -254,35 +257,43 @@ private void processEarly(final K key, final V value, final long timestamp, fina\n                 rightWinAgg = combinedWindow.value;\n             }\n \n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n             if (combinedWindow == null) {\n                 final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n                 final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n \n             } else {\n-                //create the right window for the previous record if the previous record exists and the window hasn't already been created\n-                if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n-                    final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n-                }\n                 //update the combined window with the new aggregate\n                 putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n             //create right window for new record if needed\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n             }\n         }\n \n-        private void createRightWindow(final long timestamp,\n-                                       final ValueAndTimestamp<Agg> rightWinAgg,\n-                                       final K key,\n-                                       final V value,\n-                                       final long closeTime) {\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n             final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), rightWinAgg.timestamp());", "originalCommit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA3ODM0Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482078343", "bodyText": "Yeah good point, we check for null before calling it", "author": "lct45", "createdAt": "2020-09-02T13:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NTI2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "99507f5d005023eec78a21b6c52cb4e228ee1434", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 23b415a0ba..1418c86f6d 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -257,6 +280,11 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                 rightWinAgg = combinedWindow.value;\n             }\n \n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n             //create the right window for the previous record if the previous record exists and the window hasn't already been created\n             if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n                 final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NzA1Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481467056", "bodyText": "Same here, can this ever be null? It doesn't seem like it, even if it's a new window we still pass in the initializer value so valueAndTime won't ever be null. ...right?", "author": "ableegoldman", "createdAt": "2020-09-01T22:27:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -311,13 +322,8 @@ private void putAndForward(final Window window,\n             if (windowEnd > closeTime) {\n                 //get aggregate from existing window\n                 final Agg oldAgg = getValueOrNull(valueAndTime);", "originalCommit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4NDg1MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482084851", "bodyText": "I just ran the tests and it's mostly true that it won't be null. We do have a test, and so it seems like a real life scenario (?), where the reduce initializer is null, so when creating a new window valueAndTime is null.", "author": "lct45", "createdAt": "2020-09-02T13:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNDYxMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482234612", "bodyText": "True, I guess there's no reason the initializer can't return null. Nevermind then", "author": "ableegoldman", "createdAt": "2020-09-02T17:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NzA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 23b415a0ba..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -222,101 +251,106 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    0,\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n-                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n                 while (iterator.hasNext()) {\n-                    next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n-                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> existingWindow = iterator.next();\n+                    final long startTime = existingWindow.key.window().start();\n+                    windowStartTimes.add(startTime);\n+                    final long windowMaxRecordTimestamp = existingWindow.value.timestamp();\n \n                     if (startTime == 0) {\n-                        combinedWindow = next;\n-                        if (windowMaxRecordTimestamp < timestamp) {\n-                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n-                            // previous record's right window would have been created already by other records. This\n-                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                        combinedWindow = existingWindow;\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n                             previousRecordTimestamp = windowMaxRecordTimestamp;\n                         }\n \n-                    } else if (startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (startTime == timestamp + 1) {\n+                    } else if (startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = existingWindow.value;\n+                        updateWindowAndForward(existingWindow.key.window(), existingWindow.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n             }\n \n-            // if there wasn't a right window agg found and we need a right window for our new record,\n-            // the current aggregate in the combined window will go in the new record's right window\n-            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+            // If there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window. We can be sure that the combined\n+            // window only holds records that fall into the current record's right window for two reasons:\n+            // 1. If there were records earlier than the current record AND later than the current record, there would be a right window found\n+            // when we looked for right window agg.\n+            // 2. If there was only a record before the current record, we wouldn't need a right window for the current record and wouldn't update the\n+            // rightWinAgg value here, as the combinedWindow.value.timestamp() < inputRecordTimestamp\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > inputRecordTimestamp) {\n                 rightWinAgg = combinedWindow.value;\n             }\n \n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, inputRecordTimestamp)) {\n+                createCurrentRecordRightWindow(inputRecordTimestamp, rightWinAgg, key);\n+            }\n+\n             //create the right window for the previous record if the previous record exists and the window hasn't already been created\n             if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n                 final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n             }\n \n             if (combinedWindow == null) {\n                 final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n \n             } else {\n                 //update the combined window with the new aggregate\n-                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n-            }\n-            //create right window for new record if needed\n-            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+                updateWindowAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, inputRecordTimestamp);\n             }\n+\n         }\n \n-        private void createCurrentRecordRightWindow(final long timestamp,\n+        private void createCurrentRecordRightWindow(final long inputRecordTimestamp,\n                                                     final ValueAndTimestamp<Agg> rightWinAgg,\n                                                     final K key) {\n-            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), rightWinAgg.timestamp());\n-            final long windowStart = window.start();\n+            final TimeWindow window = new TimeWindow(inputRecordTimestamp + 1, inputRecordTimestamp + 1 + windows.timeDifferenceMs());\n             windowStore.put(\n                 key,\n-                valueAndTime,\n-                windowStart);\n+                rightWinAgg,\n+                window.start());\n             tupleForwarder.maybeForward(\n-                new Windowed<K>(key, window),\n-                getValueOrNull(rightWinAgg),\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n                 null,\n                 rightWinAgg.timestamp());\n         }\n \n-        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n-            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n+        // checks if the previous record falls into the current records left window; if yes, the left window is not empty, otherwise it is empty\n+        private boolean leftWindowNotEmpty(final Long previousRecordTimestamp, final long inputRecordTimestamp) {\n+            return previousRecordTimestamp != null && inputRecordTimestamp - windows.timeDifferenceMs() <= previousRecordTimestamp;\n         }\n \n-        // previous record's right window does not already exist and current record falls within previous record's right window\n+        // checks if the previous record's right window does not already exist and the current record falls within previous record's right window\n         private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n                                                         final long previousRightWindowStart,\n-                                                        final long currentRecordTimestamp) {\n-            return !windowStartTimes.contains(previousRightWindowStart) && previousRightWindowStart + windows.timeDifferenceMs() >= currentRecordTimestamp;\n+                                                        final long inputRecordTimestamp) {\n+            return !windowStartTimes.contains(previousRightWindowStart) && previousRightWindowStart + windows.timeDifferenceMs() >= inputRecordTimestamp;\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        // checks if the aggregate we found has records that fall into the current record's right window; if yes, the right window is not empty\n+        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long inputRecordTimestamp) {\n+            return rightWinAgg != null && rightWinAgg.timestamp() > inputRecordTimestamp;\n         }\n \n-        private void putAndForward(final Window window,\n-                                   final ValueAndTimestamp<Agg> valueAndTime,\n-                                   final K key,\n-                                   final V value,\n-                                   final long closeTime,\n-                                   final long timestamp) {\n+        private void updateWindowAndForward(final Window window,\n+                                            final ValueAndTimestamp<Agg> valueAndTime,\n+                                            final K key,\n+                                            final V value,\n+                                            final long closeTime,\n+                                            final long inputRecordTimestamp) {\n             final long windowStart = window.start();\n             final long windowEnd = window.end();\n             if (windowEnd > closeTime) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjM4OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481512388", "bodyText": "By the way, I think we should also check if the record is so old that even the latest window it could possibly create/affect would be dropped, and then not process the record at all. (ie basically check if the current record's right window would be dropped) We can record on the lateRecordDropSensor and log the message using the current record's left window.", "author": "ableegoldman", "createdAt": "2020-09-02T00:50:36Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -118,24 +118,20 @@ public void process(final K key, final V value) {\n             }\n \n             final long timestamp = context().timestamp();\n-            //don't process records that don't fall within a full sliding window\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+", "originalCommit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "99507f5d005023eec78a21b6c52cb4e228ee1434", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 23b415a0ba..1418c86f6d 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -118,8 +118,33 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             }\n \n             final long timestamp = context().timestamp();\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n             final long closeTime = observedStreamTime - windows.gracePeriodMs();\n \n+            if (timestamp + 1 + windows.timeDifferenceMs() <= closeTime) {\n+                log.warn(\n+                    \"Skipping record for expired window. \" +\n+                        \"key=[{}] \" +\n+                        \"topic=[{}] \" +\n+                        \"partition=[{}] \" +\n+                        \"offset=[{}] \" +\n+                        \"timestamp=[{}] \" +\n+                        \"window=[{},{}] \" +\n+                        \"expiration=[{}] \" +\n+                        \"streamTime=[{}]\",\n+                    key,\n+                    context().topic(),\n+                    context().partition(),\n+                    context().offset(),\n+                    context().timestamp(),\n+                    timestamp - windows.timeDifferenceMs(), timestamp,\n+                    closeTime,\n+                    observedStreamTime\n+                );\n+                lateRecordDropSensor.record();\n+                return;\n+            }\n+\n             if (timestamp < windows.timeDifferenceMs()) {\n                 processEarly(key, value, timestamp, closeTime);\n                 return;\n"}}, {"oid": "99507f5d005023eec78a21b6c52cb4e228ee1434", "url": "https://github.com/apache/kafka/commit/99507f5d005023eec78a21b6c52cb4e228ee1434", "message": "Sliding Windows structural updates", "committedDate": "2020-09-02T15:20:45Z", "type": "commit"}, {"oid": "99507f5d005023eec78a21b6c52cb4e228ee1434", "url": "https://github.com/apache/kafka/commit/99507f5d005023eec78a21b6c52cb4e228ee1434", "message": "Sliding Windows structural updates", "committedDate": "2020-09-02T15:20:45Z", "type": "forcePushed"}, {"oid": "c0461645e135237553a65ab7f43750b3f3ee8e5a", "url": "https://github.com/apache/kafka/commit/c0461645e135237553a65ab7f43750b3f3ee8e5a", "message": "add testing for early records", "committedDate": "2020-09-02T17:34:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI5NzY2OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482297669", "bodyText": "Wait...what's going on here? Aren't we just creating a new ValueAndTimestamp that's identical to the rightWinAgg? We don't need to make a copy, I assume", "author": "ableegoldman", "createdAt": "2020-09-02T18:45:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,127 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(rightWinAgg.value(), rightWinAgg.timestamp());", "originalCommit": "c0461645e135237553a65ab7f43750b3f3ee8e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMyNDQzNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482324434", "bodyText": "Yup, good catch. Must've been leftover from a cleanup", "author": "lct45", "createdAt": "2020-09-02T19:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI5NzY2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 1418c86f6d..65a86d482a 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -308,14 +308,12 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                                                     final ValueAndTimestamp<Agg> rightWinAgg,\n                                                     final K key) {\n             final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(rightWinAgg.value(), rightWinAgg.timestamp());\n-            final long windowStart = window.start();\n             windowStore.put(\n                 key,\n-                valueAndTime,\n-                windowStart);\n+                rightWinAgg,\n+                window.start());\n             tupleForwarder.maybeForward(\n-                new Windowed<K>(key, window),\n+                new Windowed<>(key, window),\n                 rightWinAgg.value(),\n                 null,\n                 rightWinAgg.timestamp());\n"}}, {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "url": "https://github.com/apache/kafka/commit/b250d7dc49daf1c98b307cd3367b0088b1952e5a", "message": "Simplify creating current right window", "committedDate": "2020-09-02T19:13:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2NDM5MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481764391", "bodyText": "nit: next is not a great name; maybe existingWindow instead?", "author": "mjsax", "createdAt": "2020-09-02T06:09:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -161,29 +157,31 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n                     windowStartTimes.add(next.key.window().start());", "originalCommit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwMjUzOA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483302538", "bodyText": "currentWindow is probably more traditional but existingWindow sounds good too", "author": "ableegoldman", "createdAt": "2020-09-03T23:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2NDM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcyOTQwMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483729402", "bodyText": "Well, currentWindows sound like the window of the current record, while this variable point to other windows, too.", "author": "mjsax", "createdAt": "2020-09-04T16:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2NDM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyODMzNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483828334", "bodyText": "Fair enough. I was thinking of current in the context of the while loop, but given that we refer to the \"current record\" elsewhere, currentWindow might be ambiguous", "author": "ableegoldman", "createdAt": "2020-09-04T20:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2NDM5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "99507f5d005023eec78a21b6c52cb4e228ee1434", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 23b415a0ba..1418c86f6d 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -171,7 +194,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                     } else if (endTime > timestamp && startTime <= timestamp) {\n                         rightWinAgg = next.value;\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (startTime == timestamp + 1){\n+                    } else if (startTime == timestamp + 1) {\n                         rightWinAlreadyCreated = true;\n                     }\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3MzA1Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483073056", "bodyText": "Not sure how this change relates to \"early records\"?", "author": "mjsax", "createdAt": "2020-09-03T15:37:47Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -228,13 +345,8 @@ private void putAndForward(final Window window,\n             if (windowEnd > closeTime) {\n                 //get aggregate from existing window\n                 final Agg oldAgg = getValueOrNull(valueAndTime);\n-                final Agg newAgg;\n-                // keep old aggregate if adding a right window, else add new record's value\n-                if (windowStart == timestamp + 1) {\n-                    newAgg = oldAgg;\n-                } else {\n-                    newAgg = aggregator.apply(key, value, oldAgg);\n-                }\n+                final Agg newAgg = aggregator.apply(key, value, oldAgg);", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNTg0NQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483715845", "bodyText": "I think it might've gotten pulled over when updating from the original PR", "author": "lct45", "createdAt": "2020-09-04T16:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3MzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyODA2MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483828060", "bodyText": "This was just from the semi-related cleanup of splitting putAndForward into a separate method for createRightWindow, which was done after the first PR was merged (hence the cleanup occurs in this PR). I think?", "author": "ableegoldman", "createdAt": "2020-09-04T20:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3MzA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -319,27 +328,29 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                 rightWinAgg.timestamp());\n         }\n \n-        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n-            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n+        // checks if the previous record falls into the current records left window; if yes, the left window is not empty, otherwise it is empty\n+        private boolean leftWindowNotEmpty(final Long previousRecordTimestamp, final long inputRecordTimestamp) {\n+            return previousRecordTimestamp != null && inputRecordTimestamp - windows.timeDifferenceMs() <= previousRecordTimestamp;\n         }\n \n-        // previous record's right window does not already exist and current record falls within previous record's right window\n+        // checks if the previous record's right window does not already exist and the current record falls within previous record's right window\n         private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n                                                         final long previousRightWindowStart,\n-                                                        final long currentRecordTimestamp) {\n-            return !windowStartTimes.contains(previousRightWindowStart) && previousRightWindowStart + windows.timeDifferenceMs() >= currentRecordTimestamp;\n+                                                        final long inputRecordTimestamp) {\n+            return !windowStartTimes.contains(previousRightWindowStart) && previousRightWindowStart + windows.timeDifferenceMs() >= inputRecordTimestamp;\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        // checks if the aggregate we found has records that fall into the current record's right window; if yes, the right window is not empty\n+        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long inputRecordTimestamp) {\n+            return rightWinAgg != null && rightWinAgg.timestamp() > inputRecordTimestamp;\n         }\n \n-        private void putAndForward(final Window window,\n-                                   final ValueAndTimestamp<Agg> valueAndTime,\n-                                   final K key,\n-                                   final V value,\n-                                   final long closeTime,\n-                                   final long timestamp) {\n+        private void updateWindowAndForward(final Window window,\n+                                            final ValueAndTimestamp<Agg> valueAndTime,\n+                                            final K key,\n+                                            final V value,\n+                                            final long closeTime,\n+                                            final long inputRecordTimestamp) {\n             final long windowStart = window.start();\n             final long windowEnd = window.end();\n             if (windowEnd > closeTime) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483074009", "bodyText": "Why do we need to check the timestamp?", "author": "mjsax", "createdAt": "2020-09-03T15:39:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n+        }\n+\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n+                                                        final long previousRightWindowStart,\n+                                                        final long currentRecordTimestamp) {\n+            return !windowStartTimes.contains(previousRightWindowStart) && previousRightWindowStart + windows.timeDifferenceMs() >= currentRecordTimestamp;\n         }\n \n-        private boolean isLeftWindow(final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> window) {\n-            return window.key.window().end() == window.value.timestamp();\n+        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n+            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNTMzNg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483715336", "bodyText": "In our scan for rightWinAgg , there's a possibility that we find a rightWinAgg that doesn't actually fall within the current record's right window. For example, if we have a record come in at 18, previous records at 16 and 10, we would find the window [11,21] (10's right window) when scanning for our rightWinAgg in processInOrder. [11,21] contains only 16, which is smaller than 18, our current record, indicating that the rightWinAgg is incorrect and the right window is in fact empty.", "author": "lct45", "createdAt": "2020-09-04T16:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0OTIwNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483749204", "bodyText": "Thanks. As above, maybe add a short comment? Can it be that we overload the term \"right window\"? For this case, rightWinAgg seems to be the aggregate of last window \"left of the current record\" (and it might contribute to the agg of the right window of the current record). However, it \"is\" not the \"right window of the current record\" itself?", "author": "mjsax", "createdAt": "2020-09-04T17:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1MjYwMw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483752603", "bodyText": "Just added a comment similar to above.\nAnd yeah, we definitely overload the term \"right window\". The rightWinAgg holds what will be in the current record's right window, if anything, but is not really the right window. A name change could be possible, something like previousWindow but I wonder if that would make using that aggregate to create the new record's right window more confusing.", "author": "lct45", "createdAt": "2020-09-04T17:10:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyNzUzMA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483827530", "bodyText": "I thought it was called rightWinAgg because it's the aggregate that goes in the current record's right window. Of course we had to find this aggregate from some other existing window, eg from the \"last window left of the current record\".", "author": "ableegoldman", "createdAt": "2020-09-04T20:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1MzQ0Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485053442", "bodyText": "I think the catch is that it's only sometimes the aggregate that goes in the current record's right window. Sometimes we don't use the value in rightWingAgg because the right window is empty/doesn't exist, but if there is a right window aggregate, it will be in rightWinAgg", "author": "lct45", "createdAt": "2020-09-08T16:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -203,10 +205,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             //create right window for previous record\n             if (previousRecordTimestamp != null) {\n                 final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n                     final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NzIzOA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483077238", "bodyText": "q: Should we rename currentTimestamp -> timestamp for consistency? (or maybe, rename timestamp to inputRecordTimestamp all over the place?", "author": "mjsax", "createdAt": "2020-09-03T15:43:54Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwNzI4OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483307289", "bodyText": "+1 to this", "author": "ableegoldman", "createdAt": "2020-09-03T23:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NzIzOA=="}], "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -203,10 +205,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             //create right window for previous record\n             if (previousRecordTimestamp != null) {\n                 final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n                     final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3ODAxOA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483078018", "bodyText": "Why do we do this check based on timestamps?", "author": "mjsax", "createdAt": "2020-09-03T15:44:59Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5NTcwMw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483695703", "bodyText": "If the previous record falls within the current record's left window, then it contains values other than just the current record. There is a scenario where we find a previous record just outside of the current record, which would indicate that the current record's left window only contains the current record.\nEX: if we have a record at 25, and previous records at 13 and 4 and with a time difference of 10, we find 4's right window at [5,15] in our scan. We log the maxRecordTimestamp of this window, which is 13, as 25's previous record. We don't actually want to create 13's right window though, even if it's the previous record, because 25 falls outside of [14,24].\nUsing the timestamps seemed like a simple litmus test to see if we found anything that falls within the window and was necessary after we found the previous record consistently by looking at the maxRecordTimestamp of a window.", "author": "lct45", "createdAt": "2020-09-04T15:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3ODAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0NjE2Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483746166", "bodyText": "Thanks. Should we add a comment?\n// checks if the previous record falls into the current records left window; if yes, the left window is not empty, otherwise it is empty\n\nOr something like this?", "author": "mjsax", "createdAt": "2020-09-04T16:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3ODAxOA=="}], "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -203,10 +205,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             //create right window for previous record\n             if (previousRecordTimestamp != null) {\n                 final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n                     final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3OTIyOQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483079229", "bodyText": "Same question as above about currentRecordTimestamp (It seems best to me, to use the same variable name for the same think throughout all methods.)", "author": "mjsax", "createdAt": "2020-09-03T15:46:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n+        }\n+\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n+                                                        final long previousRightWindowStart,\n+                                                        final long currentRecordTimestamp) {", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -203,10 +205,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             //create right window for previous record\n             if (previousRecordTimestamp != null) {\n                 final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n                     final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4MjA2MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483082060", "bodyText": "nit: Instead, they will fall within the [0, timeDifferenceMs] -> Instead, we will put them into the [0, timeDifferenceMs] window as a \"workaround\",", "author": "mjsax", "createdAt": "2020-09-03T15:50:56Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -203,10 +205,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             //create right window for previous record\n             if (previousRecordTimestamp != null) {\n                 final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n                     final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4NTA2Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483085063", "bodyText": "nit: flip both lines:\nfinal long startTime = next.key.window().start();\nwindowStartTimes.add(startTime);", "author": "mjsax", "createdAt": "2020-09-03T15:55:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -203,10 +205,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             //create right window for previous record\n             if (previousRecordTimestamp != null) {\n                 final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n                     final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483205168", "bodyText": "Not sure if I understand the last sentence: This will always be true for early records, as they all fall within [0, timeDifferenceMs]?\nAlso not sure how this comment relates to setting previousRecordTimestamp ?", "author": "mjsax", "createdAt": "2020-09-03T19:25:49Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwNTUwMQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483305501", "bodyText": "I think it means, for a generic out-of-order record, it's possible that the previous record's right window will have already been created (by whatever record (s) are later than the current one). But for an early record, if maxRecordTimestamp > timestamp, then we know that the previous record's right window must have already been created (by whatever record(s) are within the combined window but later than the current record).\nThis is relevant to setting previousRecordTimestamp because if maxRecordTimestamp >= timestamp, the previous record's right window has already been created. And if that's the case, we don't have to create it ourselves and thus we don't care about the previousRecordTimestamp\nDoes that sound right Leah?", "author": "ableegoldman", "createdAt": "2020-09-03T23:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwOTA4Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483309087", "bodyText": "Yeah that's right.\n\nBut for an early record, if maxRecordTimestamp > timestamp, we know that the previous record's right window must have already been created\n\nI think this is key - we know this because for any early record, it will always fall within the right window of the previous record (given there is one), since they both fall within the [0, timeDifferenceMs] window. It's hard to phrase clearly on the comment, I can add another line about the proof if that would be helful", "author": "lct45", "createdAt": "2020-09-03T23:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4NTMyNQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483685325", "bodyText": "Going back and re-reading this comments in the context of Matthias's later comment, it seems like maybe this one is unnecessary. Correct me if I'm wrong, but it feels like the statement if (windowMaxRecordTimestamp < timestamp) { previousRecordTimestamp = windowMaxRecordTimestamp; }\nis somewhat self explanatory. I also don't think I ever leverage the idea that if there is a record before the current record, then the previous record's right window has already been created. Below, I still check previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1). I think either the logic can be updated to leverage what the above comment indicates, or we can cut it out and keep the logic simple. WDYT?", "author": "lct45", "createdAt": "2020-09-04T15:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczOTc4Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483739783", "bodyText": "@ableegoldman WDYT?", "author": "mjsax", "createdAt": "2020-09-04T16:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzNTczMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483835732", "bodyText": "the statement if (windowMaxRecordTimestamp < timestamp) { previousRecordTimestamp = windowMaxRecordTimestamp; }is somewhat self explanatory\n\nI think that's fair. My concern was with the windowMaxRecordTimestamp > timestamp case -- in that situation, we don't know and can't know what the previousRecordTimestamp is, because all we save is the maxTimestamp of the combined window and therefore the information is lost. I just thought we should clarify that this is actually ok, because if windowMaxRecordTimestamp > timestamp then we must have already created the right window of the previous record. So I agree that the !windowStartTimes.contains(previousRecordTimestamp + 1) check would logically catch this, but I don't think we can remove either check:\nIf we remove the if (windowMaxRecordTimestamp < timestamp) { previousRecordTimestamp = windowMaxRecordTimestamp; } then we might set previousRecordTimestamp to a value that isn't actually the timestamp of a previous record, and we should make sure all variables are always accurate\nIf we remove the !windowStartTimes.contains(previousRecordTimestamp + 1) then we could miss a case where the previous record's right window was already created, but by a record out side of the combined window\nSo, I think the code itself is complete as is. But probably we can simplify the comments to make it more understandable -- it seems reasonable to remove the comment here entirely. Then maybe you could leave a brief comment down below where we create the previous record's right window saying \"if the previousRecordTimestamp is null, either there is no previous record or it's right window has already been created\"", "author": "ableegoldman", "createdAt": "2020-09-04T20:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzOTA2MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483839060", "bodyText": "Oh yeah you're right, I'd forgotten why we added that comment in the first place. What about something briefer like\nWe don't need to store previousRecordTimestamp if maxRecordTimestamp > timestamp because the previous record's right window (if there is a previous record) would have already been created by maxRecordTimestamp", "author": "lct45", "createdAt": "2020-09-04T20:51:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NDUxMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r484094512", "bodyText": "Ah, good call, that makes sense to me", "author": "ableegoldman", "createdAt": "2020-09-06T17:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}], "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -203,10 +205,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             //create right window for previous record\n             if (previousRecordTimestamp != null) {\n                 final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n                     final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNzEwNg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483207106", "bodyText": "nit: should we rename putAndForward to updateWindowAndForward?", "author": "mjsax", "createdAt": "2020-09-03T19:29:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -203,10 +205,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             //create right window for previous record\n             if (previousRecordTimestamp != null) {\n                 final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n                     final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxMDkxMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483210912", "bodyText": "Seem this can be a simple else? No need to verify the condition? (Maybe it's helpful to add a comment instead?)", "author": "mjsax", "createdAt": "2020-09-03T19:37:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwNjEwOQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483306109", "bodyText": "Maybe we can do an else throw IllegalStateException here as well. I guess a comment could achieve the same code clarify, but personally I think it's a good idea to have this sanity check.", "author": "ableegoldman", "createdAt": "2020-09-03T23:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxMDkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0MDAxNg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483740016", "bodyText": "SGTM.", "author": "mjsax", "createdAt": "2020-09-04T16:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxMDkxMg=="}], "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -203,10 +205,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             //create right window for previous record\n             if (previousRecordTimestamp != null) {\n                 final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n                     final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxNDgwNQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483214805", "bodyText": "Given, that we call processEarly only if 0 < timestamp < timeDifferenceMs, we know that timestamp - 2 * windows.timeDifferenceMs() would always be negative? Thus, we can just pass in zero here?\nIf this is correct, we might want to add a check at the beginning of this method:\nif (timestamp < 0 || timestamp >= timeDifferenceMs) {\n  throw new IllegalArgumentException(\"...\");\n}", "author": "mjsax", "createdAt": "2020-09-03T19:45:54Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4MTk1Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483681956", "bodyText": "Makes sense to me", "author": "lct45", "createdAt": "2020-09-04T15:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxNDgwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -203,10 +205,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             //create right window for previous record\n             if (previousRecordTimestamp != null) {\n                 final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n                     final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4OTQ2Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483289467", "bodyText": "Seems we don't need the if as this is the only valid case? Adding a comment might be helpful.\nIf you want to keep the if as a sanity check, we should add a final:\n} else {\n  throw new IllegalStateException(...):\n}", "author": "mjsax", "createdAt": "2020-09-03T22:36:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -161,29 +180,31 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n                     windowStartTimes.add(next.key.window().start());\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n                     } else if (endTime == timestamp) {\n                         leftWinAlreadyCreated = true;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n                     } else if (endTime > timestamp && startTime <= timestamp) {\n                         rightWinAgg = next.value;\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                    } else if (startTime == timestamp + 1) {", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwMjkzNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483302934", "bodyText": "It was my suggestion to explicitly check if (startTime == timestamp + 1) instead of just falling back to else, for code clarify and safety, so blame me. But +1 to adding the else throw IllegalStateException", "author": "ableegoldman", "createdAt": "2020-09-03T23:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4OTQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwODA5MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483308090", "bodyText": "Ah yeah, I do throw one in the updated version of this in the reverse iterator PR, but it hasn't gotten moved over here yet. I'll do that.", "author": "lct45", "createdAt": "2020-09-03T23:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4OTQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczNjI1Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483736252", "bodyText": "The suggest is not bad, but required to add the else-throw to make sense. Otherwise, an programming error could slip undetected.", "author": "mjsax", "createdAt": "2020-09-04T16:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4OTQ2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex 65a86d482a..7f578c4002 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -171,31 +171,33 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> existingWindow = iterator.next();\n+                    final long startTime = existingWindow.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n-                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+                    final long windowMaxRecordTimestamp = existingWindow.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = existingWindow.value;\n                         previousRecordTimestamp = windowMaxRecordTimestamp;\n-                    } else if (endTime == timestamp) {\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        if (windowMaxRecordTimestamp < timestamp) {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n                             previousRecordTimestamp = windowMaxRecordTimestamp;\n                         }\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (startTime == timestamp + 1) {\n+                        updateWindowAndForward(existingWindow.key.window(), existingWindow.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = existingWindow.value;\n+                        updateWindowAndForward(existingWindow.key.window(), existingWindow.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n             }\n"}}, {"oid": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "url": "https://github.com/apache/kafka/commit/6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "message": "Matthias's updates", "committedDate": "2020-09-04T17:15:14Z", "type": "commit"}, {"oid": "586621302e59977d8b6eb3ddf15714cc39c0df3b", "url": "https://github.com/apache/kafka/commit/586621302e59977d8b6eb3ddf15714cc39c0df3b", "message": "updated comments", "committedDate": "2020-09-08T16:35:39Z", "type": "commit"}, {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "url": "https://github.com/apache/kafka/commit/6821e92e2cfd4ee8d763cdf2569578682db6d463", "message": "Merge branch 'trunk' of github.com:apache/kafka into early-records", "committedDate": "2020-09-08T16:40:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyOTU5OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485129599", "bodyText": "nit: 1 -> 1L", "author": "mjsax", "createdAt": "2020-09-08T18:54:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -117,25 +117,44 @@ public void process(final K key, final V value) {\n                 return;\n             }\n \n-            final long timestamp = context().timestamp();\n-            //don't process records that don't fall within a full sliding window\n-            if (timestamp < windows.timeDifferenceMs()) {\n+            final long inputRecordTimestamp = context().timestamp();\n+            observedStreamTime = Math.max(observedStreamTime, inputRecordTimestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (inputRecordTimestamp + 1 + windows.timeDifferenceMs() <= closeTime) {", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6580b9f9670ac77220eeb29fd50733c73a532f2a", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex aec4fd7c69..23baf7250b 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -121,7 +121,7 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n             observedStreamTime = Math.max(observedStreamTime, inputRecordTimestamp);\n             final long closeTime = observedStreamTime - windows.gracePeriodMs();\n \n-            if (inputRecordTimestamp + 1 + windows.timeDifferenceMs() <= closeTime) {\n+            if (inputRecordTimestamp + 1L + windows.timeDifferenceMs() <= closeTime) {\n                 log.warn(\n                     \"Skipping record for expired window. \" +\n                         \"key=[{}] \" +\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTIwMQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485141201", "bodyText": "nit: fall between 0 < inputRecordTimestamp -> fall between 0 <= inputRecordTimestamp", "author": "mjsax", "createdAt": "2020-09-08T19:16:26Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n+                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n                 } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                final TimeWindow window = new TimeWindow(inputRecordTimestamp - windows.timeDifferenceMs(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n             }\n-            //create right window for new record\n-            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, inputRecordTimestamp)) {\n+                createCurrentRecordRightWindow(inputRecordTimestamp, rightWinAgg, key);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        /**\n+         * Created to handle records where 0 < inputRecordTimestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, we will put them into the [0, timeDifferenceMs]\n+         * window as a \"workaround\", and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n+            if (inputRecordTimestamp < 0 || inputRecordTimestamp >= windows.timeDifferenceMs()) {\n+                throw new IllegalArgumentException(\"Early record for sliding windows must fall between 0 < inputRecordTimestamp < timeDifferenceMs\");", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMTkzMQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485221931", "bodyText": "nit: log an error and include the inputRecordTimestamp", "author": "ableegoldman", "createdAt": "2020-09-08T22:06:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTIwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "6580b9f9670ac77220eeb29fd50733c73a532f2a", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex aec4fd7c69..23baf7250b 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -197,6 +197,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                     } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n                     } else {\n+                        log.warn(\n+                            \"Unexpected window with start {} found when processing record at {} in `KStreamSlidingWindowAggregate`.\",\n+                            startTime, inputRecordTimestamp\n+                        );\n                         throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTg5Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485141892", "bodyText": "nit: maxRecordTimestamp > timestamp -> maxRecordTimestamp >= timestamp\nnit: missing space: // We", "author": "mjsax", "createdAt": "2020-09-08T19:17:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n+                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n                 } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                final TimeWindow window = new TimeWindow(inputRecordTimestamp - windows.timeDifferenceMs(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n             }\n-            //create right window for new record\n-            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, inputRecordTimestamp)) {\n+                createCurrentRecordRightWindow(inputRecordTimestamp, rightWinAgg, key);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        /**\n+         * Created to handle records where 0 < inputRecordTimestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, we will put them into the [0, timeDifferenceMs]\n+         * window as a \"workaround\", and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n+            if (inputRecordTimestamp < 0 || inputRecordTimestamp >= windows.timeDifferenceMs()) {\n+                throw new IllegalArgumentException(\"Early record for sliding windows must fall between 0 < inputRecordTimestamp < timeDifferenceMs\");\n+            }\n+\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    0,\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    inputRecordTimestamp + 1)\n+            ) {\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = windowBeingProcessed;\n+                        //We don't need to store previousRecordTimestamp if maxRecordTimestamp > timestamp", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6580b9f9670ac77220eeb29fd50733c73a532f2a", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex aec4fd7c69..23baf7250b 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -197,6 +197,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                     } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n                     } else {\n+                        log.warn(\n+                            \"Unexpected window with start {} found when processing record at {} in `KStreamSlidingWindowAggregate`.\",\n+                            startTime, inputRecordTimestamp\n+                        );\n                         throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0OTY0MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485149641", "bodyText": "Why do we need to suppress?", "author": "mjsax", "createdAt": "2020-09-08T19:32:49Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -439,6 +442,185 @@ public void testJoin() {\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzNTg4MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485235880", "bodyText": "Without it, there are warnings with the transition from K, V to Long, ValueAndTimestamp when adding and updating the hash map that holds the results.", "author": "lct45", "createdAt": "2020-09-08T22:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0OTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzOTk5OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485239998", "bodyText": "That seems weird to me. Guessing it's ultimately due to the supplier.theCapturedProcessor().processed() we loop over. But then wouldn't we get the warning a bit earlier? \ud83e\udd37\u200d\u2640\ufe0f", "author": "ableegoldman", "createdAt": "2020-09-08T22:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0OTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0ODQ4Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485248486", "bodyText": "Yeah I do find it odd that there are no warnings earlier, it's something about the Map that's triggering them", "author": "lct45", "createdAt": "2020-09-08T23:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0OTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0OTA4Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485249087", "bodyText": "It's probably some weird Java thing where it lazily types the generics and doesn't force the cast until you put it in the map. (I just made that up, but @vvcephei  would probably know)", "author": "ableegoldman", "createdAt": "2020-09-08T23:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0OTY0MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMTA1Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485221052", "bodyText": "nit: log an error and include the relevant info (eg windowStart and inputRecordTimestamp at least). Same for the IllegalStateException in processEarly", "author": "ableegoldman", "createdAt": "2020-09-08T22:03:54Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6580b9f9670ac77220eeb29fd50733c73a532f2a", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex aec4fd7c69..23baf7250b 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -197,6 +197,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                     } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n                     } else {\n+                        log.warn(\n+                            \"Unexpected window with start {} found when processing record at {} in `KStreamSlidingWindowAggregate`.\",\n+                            startTime, inputRecordTimestamp\n+                        );\n                         throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMjk5Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485222996", "bodyText": "nit: this code is pretty self-explanatory now, so the comment isn't really adding anything", "author": "ableegoldman", "createdAt": "2020-09-08T22:09:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n+                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n                 } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                final TimeWindow window = new TimeWindow(inputRecordTimestamp - windows.timeDifferenceMs(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n             }\n-            //create right window for new record\n-            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, inputRecordTimestamp)) {\n+                createCurrentRecordRightWindow(inputRecordTimestamp, rightWinAgg, key);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        /**\n+         * Created to handle records where 0 < inputRecordTimestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, we will put them into the [0, timeDifferenceMs]\n+         * window as a \"workaround\", and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n+            if (inputRecordTimestamp < 0 || inputRecordTimestamp >= windows.timeDifferenceMs()) {\n+                throw new IllegalArgumentException(\"Early record for sliding windows must fall between 0 < inputRecordTimestamp < timeDifferenceMs\");\n+            }\n+\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    0,\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    inputRecordTimestamp + 1)\n+            ) {\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = windowBeingProcessed;\n+                        //We don't need to store previousRecordTimestamp if maxRecordTimestamp > timestamp\n+                        // because the previous record's right window (if there is a previous record)\n+                        // would have already been created by maxRecordTimestamp\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n+                    }\n+                }\n+            }\n+\n+            // If there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window. We can be sure that the combined\n+            // window only holds records that fall into the current record's right window for two reasons:\n+            // 1. If there were records earlier than the current record AND later than the current record, there would be a right window found\n+            // when we looked for right window agg.\n+            // 2. If there was only a record before the current record, we wouldn't need a right window for the current record and wouldn't update the\n+            // rightWinAgg value here, as the combinedWindow.value.timestamp() < inputRecordTimestamp\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > inputRecordTimestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6580b9f9670ac77220eeb29fd50733c73a532f2a", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\nindex aec4fd7c69..23baf7250b 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java\n\n@@ -197,6 +197,10 @@ public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProce\n                     } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n                     } else {\n+                        log.warn(\n+                            \"Unexpected window with start {} found when processing record at {} in `KStreamSlidingWindowAggregate`.\",\n+                            startTime, inputRecordTimestamp\n+                        );\n                         throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n"}}, {"oid": "6580b9f9670ac77220eeb29fd50733c73a532f2a", "url": "https://github.com/apache/kafka/commit/6580b9f9670ac77220eeb29fd50733c73a532f2a", "message": "Nit fixes", "committedDate": "2020-09-08T23:06:42Z", "type": "commit"}, {"oid": "7d4ca6a3b9ea899afa680ec852fdfdfb5e2f3d58", "url": "https://github.com/apache/kafka/commit/7d4ca6a3b9ea899afa680ec852fdfdfb5e2f3d58", "message": "log fixes", "committedDate": "2020-09-08T23:35:04Z", "type": "commit"}]}