{"pr_number": 7906, "pr_title": "KAFKA-9383: Expose consumer group metadata", "pr_createdAt": "2020-01-08T01:39:07Z", "pr_url": "https://github.com/apache/kafka/pull/7906", "timeline": [{"oid": "97d35b9f016b3766f721249752d485f901d29c24", "url": "https://github.com/apache/kafka/commit/97d35b9f016b3766f721249752d485f901d29c24", "message": "Expose consumer group metadata", "committedDate": "2020-01-08T01:27:35Z", "type": "commit"}, {"oid": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349", "url": "https://github.com/apache/kafka/commit/e761cfae1457d672fc2f895ddd4b1d07fd6a8349", "message": "minor improvement", "committedDate": "2020-01-08T01:46:33Z", "type": "commit"}, {"oid": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349", "url": "https://github.com/apache/kafka/commit/e761cfae1457d672fc2f895ddd4b1d07fd6a8349", "message": "minor improvement", "committedDate": "2020-01-08T01:46:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2MTUwOQ==", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364061509", "bodyText": "This is not introduced by this PR but: the fields can be declared final?", "author": "guozhangwang", "createdAt": "2020-01-08T04:40:47Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/ConsumerGroupMetadata.java", "diffHunk": "@@ -18,6 +18,10 @@\n \n import java.util.Optional;\n \n+/**\n+ * A metadata struct containing the consumer group information.\n+ * Note: Any change to this class is considered public and requires a KIP.\n+ */", "originalCommit": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1NzAxNw==", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364457017", "bodyText": "Yes, they could", "author": "abbccdda", "createdAt": "2020-01-08T21:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2MTUwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "928c95e56ed2e1a6b19e79de8ed69ab6217b9368", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/ConsumerGroupMetadata.java b/clients/src/main/java/org/apache/kafka/clients/consumer/ConsumerGroupMetadata.java\nindex abb18319bc..d628df423e 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/consumer/ConsumerGroupMetadata.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/ConsumerGroupMetadata.java\n\n@@ -23,10 +23,10 @@ import java.util.Optional;\n  * Note: Any change to this class is considered public and requires a KIP.\n  */\n public class ConsumerGroupMetadata {\n-    private String groupId;\n-    private int generationId;\n-    private String memberId;\n-    Optional<String> groupInstanceId;\n+    final private String groupId;\n+    final private int generationId;\n+    final private String memberId;\n+    final Optional<String> groupInstanceId;\n \n     public ConsumerGroupMetadata(String groupId, int generationId, String memberId, Optional<String> groupInstanceId) {\n         this.groupId = groupId;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2MjE1Mw==", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364062153", "bodyText": "Why we want to return a clone of the groupMetadata? If we can declare all the fields as final, and whenever we update we always create a new ConsumerGroupMetadata object, then I think we can safely return the cached object directly.", "author": "guozhangwang", "createdAt": "2020-01-08T04:45:05Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java", "diffHunk": "@@ -815,6 +820,15 @@ public boolean refreshCommittedOffsetsIfNeeded(Timer timer) {\n         return null;\n     }\n \n+    /**\n+     * Return the consumer group metadata.\n+     *\n+     * @return the current consumer group metadata\n+     */\n+    public ConsumerGroupMetadata groupMetadata() {\n+        return new ConsumerGroupMetadata(groupMetadata);", "originalCommit": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1NjY0OA==", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364456648", "bodyText": "Good point, I think we probably don't need to have this.", "author": "abbccdda", "createdAt": "2020-01-08T21:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2MjE1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "928c95e56ed2e1a6b19e79de8ed69ab6217b9368", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java\nindex 61270aecd5..f3f2f46fd0 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java\n\n@@ -826,7 +826,7 @@ public final class ConsumerCoordinator extends AbstractCoordinator {\n      * @return the current consumer group metadata\n      */\n     public ConsumerGroupMetadata groupMetadata() {\n-        return new ConsumerGroupMetadata(groupMetadata);\n+        return groupMetadata;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2Mjc2OQ==", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364062769", "bodyText": "Since this callback is not synchronized and nor does the getter groupMetadata(), we should declare this cached object volatile.", "author": "guozhangwang", "createdAt": "2020-01-08T04:49:23Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java", "diffHunk": "@@ -387,8 +392,8 @@ protected void onJoinComplete(int generation,\n         maybeUpdateJoinedSubscription(assignedPartitions);\n \n         // give the assignor a chance to update internal state based on the received assignment\n-        ConsumerGroupMetadata metadata = new ConsumerGroupMetadata(rebalanceConfig.groupId, generation, memberId, rebalanceConfig.groupInstanceId);\n-        assignor.onAssignment(assignment, metadata);\n+        groupMetadata = new ConsumerGroupMetadata(rebalanceConfig.groupId, generation, memberId, rebalanceConfig.groupInstanceId);", "originalCommit": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1OTI4Ng==", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364459286", "bodyText": "For normal consumer user, this callback should be executed on the same thread of the caller right? Why do we need to make it volatile?", "author": "abbccdda", "createdAt": "2020-01-08T21:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2Mjc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2OTk2Mw==", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364469963", "bodyText": "Well I was thinking two threads could be two threads, one calling consumer.groupMetadata and one calling consumer.poll which is creating a new object, but on a second thought this race condition maybe fine anyways since we cannot guarantee time-ordering if it happens.", "author": "guozhangwang", "createdAt": "2020-01-08T22:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2Mjc2OQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "928c95e56ed2e1a6b19e79de8ed69ab6217b9368", "url": "https://github.com/apache/kafka/commit/928c95e56ed2e1a6b19e79de8ed69ab6217b9368", "message": "remove copy constructor and make fields final", "committedDate": "2020-01-09T00:01:59Z", "type": "commit"}]}