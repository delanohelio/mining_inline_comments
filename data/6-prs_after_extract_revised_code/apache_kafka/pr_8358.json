{"pr_number": 8358, "pr_title": "KAFKA-9756: Process more than one record of one task at a time", "pr_createdAt": "2020-03-26T01:01:31Z", "pr_url": "https://github.com/apache/kafka/pull/8358", "timeline": [{"oid": "70ca574fd8e3f3bc2ca42b3bb56de8f936e77f07", "url": "https://github.com/apache/kafka/commit/70ca574fd8e3f3bc2ca42b3bb56de8f936e77f07", "message": "first pass", "committedDate": "2020-03-25T00:43:35Z", "type": "commit"}, {"oid": "8b33c3e798f4f63964df1f961210d0ab0975dc52", "url": "https://github.com/apache/kafka/commit/8b33c3e798f4f63964df1f961210d0ab0975dc52", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K9756-loop-tasks-order", "committedDate": "2020-03-25T05:02:12Z", "type": "commit"}, {"oid": "77e475e5ca63a0d57070b49b8366d60857b7b7d2", "url": "https://github.com/apache/kafka/commit/77e475e5ca63a0d57070b49b8366d60857b7b7d2", "message": "fix unit tests", "committedDate": "2020-03-25T23:15:08Z", "type": "commit"}, {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "url": "https://github.com/apache/kafka/commit/d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "message": "add unit tests", "committedDate": "2020-03-26T00:14:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1OTQxNg==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398259416", "bodyText": "This is the meat of the PR: measure the total process / punctuate / commit latency, in order to measure the corresponding ratio.", "author": "guozhangwang", "createdAt": "2020-03-26T01:02:31Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);", "originalCommit": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0286037701fdc8a2993a9953549974baa8f22b85", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\nindex 5a3079abb9..5c31d62a64 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n\n@@ -659,6 +660,8 @@ public class StreamThread extends Thread {\n              */\n             do {\n                 final int processed = taskManager.process(numIterations, now);\n+                final long processLatency = advanceNowAndComputeLatency();\n+                totalProcessLatency += processLatency;\n                 if (processed > 0) {\n                     // It makes no difference to the outcome of these metrics when we record \"0\",\n                     // so we can just avoid the method call when we didn't process anything.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1OTc3Mw==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398259773", "bodyText": "I removed this call intentionally, and defer that to the end of the current batch. Because if we are in the middle of a rebalance, even upon requested we do not guarantee the commit will happen right after that record of the task is processed anyways, so deferring this user-requested check to reduce overhead.", "author": "guozhangwang", "createdAt": "2020-03-26T01:03:49Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();", "originalCommit": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5Mzk0MQ==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398793941", "bodyText": "Now I'm wondering... why would a user request a commit?", "author": "vvcephei", "createdAt": "2020-03-26T18:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1OTc3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0286037701fdc8a2993a9953549974baa8f22b85", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\nindex 5a3079abb9..5c31d62a64 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n\n@@ -659,6 +660,8 @@ public class StreamThread extends Thread {\n              */\n             do {\n                 final int processed = taskManager.process(numIterations, now);\n+                final long processLatency = advanceNowAndComputeLatency();\n+                totalProcessLatency += processLatency;\n                 if (processed > 0) {\n                     // It makes no difference to the outcome of these metrics when we record \"0\",\n                     // so we can just avoid the method call when we didn't process anything.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1OTg3Mw==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398259873", "bodyText": "This func is inlined into runOnce.", "author": "guozhangwang", "createdAt": "2020-03-26T01:04:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -765,19 +796,6 @@ private void addRecordsToTasks(final ConsumerRecords<byte[], byte[]> records) {\n         }\n     }\n \n-    /**\n-     * @throws TaskMigratedException if the task producer got fenced (EOS only)\n-     */\n-    private boolean maybePunctuate() {", "originalCommit": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2MDEwNg==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398260106", "bodyText": "This is a minor fix: previously we need to call this because we process standbys AFTER processing actives and hence may be we need to commit again afterwards, but not we process standbys first, then active, so this can be removed.", "author": "guozhangwang", "createdAt": "2020-03-26T01:05:07Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);\n+                if (processed > 0) {\n+                    // It makes no difference to the outcome of these metrics when we record \"0\",\n+                    // so we can just avoid the method call when we didn't process anything.\n+                    processRateSensor.record(processed, now);\n+\n+                    // This metric is scaled to represent the _average_ processing time of _each_\n+                    // task. Note, it's hard to interpret this as defined, but we would need a KIP\n+                    // to change it to simply report the overall time spent processing all tasks.\n+                    final long processLatency = advanceNowAndComputeLatency();\n+                    processLatencySensor.record(processLatency / (double) processed, now);\n+                    totalProcessLatency += processLatency;\n+                }\n+\n+                final int punctuated = taskManager.punctuate();\n+                if (punctuated > 0) {\n+                    final long punctuateLatency = advanceNowAndComputeLatency();\n+                    punctuateSensor.record(punctuateLatency / (double) punctuated, now);\n+                    totalPunctuateLatency += punctuateLatency;\n                 }\n \n-                timeSinceLastPoll = Math.max(now - lastPollMs, 0);\n+                final int committed = maybeCommit();\n+                if (committed > 0) {\n+                    final long commitLatency = advanceNowAndComputeLatency();\n+                    commitSensor.record(commitLatency / (double) committed, now);\n \n-                if (maybePunctuate() || maybeCommit()) {\n-                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n-                } else if (timeSinceLastPoll > maxPollTimeMs / 2) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Committed all active tasks {} and standby tasks {} in {}ms\",\n+                            taskManager.activeTaskIds(), taskManager.standbyTaskIds(), commitLatency);\n+                    }\n+\n+                    totalCommitLatency += commitLatency;\n+                }\n+\n+                if (processed == 0) {\n+                    // if there is no records to be processed, exit after punctuate / commit\n+                    break;\n+                } else if (Math.max(now - lastPollMs, 0) > maxPollTimeMs / 2) {\n                     numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n                     break;\n-                } else if (processed > 0) {\n+                } else if (punctuated > 0 || committed > 0) {\n+                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n+                } else {\n                     numIterations++;\n                 }\n-            } while (processed > 0);\n-\n-            maybeCommit();", "originalCommit": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0286037701fdc8a2993a9953549974baa8f22b85", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\nindex 5a3079abb9..5c31d62a64 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n\n@@ -659,6 +660,8 @@ public class StreamThread extends Thread {\n              */\n             do {\n                 final int processed = taskManager.process(numIterations, now);\n+                final long processLatency = advanceNowAndComputeLatency();\n+                totalProcessLatency += processLatency;\n                 if (processed > 0) {\n                     // It makes no difference to the outcome of these metrics when we record \"0\",\n                     // so we can just avoid the method call when we didn't process anything.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2MDUwNg==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398260506", "bodyText": "There are also a minor fix here: we used to calculate the timeSinceLastPoll before we call maybePunctuate / maybeCommit, which may actually take a lot of time; this would cause us to be mistakenly more aggressive in timeSinceLastPoll > maxPollTimeMs / 2 since timeSinceLastPoll is actually larger than the recorded value, and hence more likely to be kicked out of the group.", "author": "guozhangwang", "createdAt": "2020-03-26T01:06:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);\n+                if (processed > 0) {\n+                    // It makes no difference to the outcome of these metrics when we record \"0\",\n+                    // so we can just avoid the method call when we didn't process anything.\n+                    processRateSensor.record(processed, now);\n+\n+                    // This metric is scaled to represent the _average_ processing time of _each_\n+                    // task. Note, it's hard to interpret this as defined, but we would need a KIP\n+                    // to change it to simply report the overall time spent processing all tasks.\n+                    final long processLatency = advanceNowAndComputeLatency();\n+                    processLatencySensor.record(processLatency / (double) processed, now);\n+                    totalProcessLatency += processLatency;\n+                }\n+\n+                final int punctuated = taskManager.punctuate();\n+                if (punctuated > 0) {\n+                    final long punctuateLatency = advanceNowAndComputeLatency();\n+                    punctuateSensor.record(punctuateLatency / (double) punctuated, now);\n+                    totalPunctuateLatency += punctuateLatency;\n                 }\n \n-                timeSinceLastPoll = Math.max(now - lastPollMs, 0);\n+                final int committed = maybeCommit();\n+                if (committed > 0) {\n+                    final long commitLatency = advanceNowAndComputeLatency();\n+                    commitSensor.record(commitLatency / (double) committed, now);\n \n-                if (maybePunctuate() || maybeCommit()) {\n-                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n-                } else if (timeSinceLastPoll > maxPollTimeMs / 2) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Committed all active tasks {} and standby tasks {} in {}ms\",\n+                            taskManager.activeTaskIds(), taskManager.standbyTaskIds(), commitLatency);\n+                    }\n+\n+                    totalCommitLatency += commitLatency;\n+                }\n+\n+                if (processed == 0) {\n+                    // if there is no records to be processed, exit after punctuate / commit\n+                    break;\n+                } else if (Math.max(now - lastPollMs, 0) > maxPollTimeMs / 2) {", "originalCommit": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0286037701fdc8a2993a9953549974baa8f22b85", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\nindex 5a3079abb9..5c31d62a64 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n\n@@ -659,6 +660,8 @@ public class StreamThread extends Thread {\n              */\n             do {\n                 final int processed = taskManager.process(numIterations, now);\n+                final long processLatency = advanceNowAndComputeLatency();\n+                totalProcessLatency += processLatency;\n                 if (processed > 0) {\n                     // It makes no difference to the outcome of these metrics when we record \"0\",\n                     // so we can just avoid the method call when we didn't process anything.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcwODI0Nw==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398708247", "bodyText": "Note I did not record sensor  for restoration; it is intentional since we will be moving that out of the thread here. Atm the restoration ratio can be inferred by 100% - other four.", "author": "guozhangwang", "createdAt": "2020-03-26T16:23:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);\n+                if (processed > 0) {\n+                    // It makes no difference to the outcome of these metrics when we record \"0\",\n+                    // so we can just avoid the method call when we didn't process anything.\n+                    processRateSensor.record(processed, now);\n+\n+                    // This metric is scaled to represent the _average_ processing time of _each_\n+                    // task. Note, it's hard to interpret this as defined, but we would need a KIP\n+                    // to change it to simply report the overall time spent processing all tasks.\n+                    final long processLatency = advanceNowAndComputeLatency();\n+                    processLatencySensor.record(processLatency / (double) processed, now);\n+                    totalProcessLatency += processLatency;\n+                }\n+\n+                final int punctuated = taskManager.punctuate();\n+                if (punctuated > 0) {\n+                    final long punctuateLatency = advanceNowAndComputeLatency();\n+                    punctuateSensor.record(punctuateLatency / (double) punctuated, now);\n+                    totalPunctuateLatency += punctuateLatency;\n                 }\n \n-                timeSinceLastPoll = Math.max(now - lastPollMs, 0);\n+                final int committed = maybeCommit();\n+                if (committed > 0) {\n+                    final long commitLatency = advanceNowAndComputeLatency();\n+                    commitSensor.record(commitLatency / (double) committed, now);\n \n-                if (maybePunctuate() || maybeCommit()) {\n-                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n-                } else if (timeSinceLastPoll > maxPollTimeMs / 2) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Committed all active tasks {} and standby tasks {} in {}ms\",\n+                            taskManager.activeTaskIds(), taskManager.standbyTaskIds(), commitLatency);\n+                    }\n+\n+                    totalCommitLatency += commitLatency;\n+                }\n+\n+                if (processed == 0) {\n+                    // if there is no records to be processed, exit after punctuate / commit\n+                    break;\n+                } else if (Math.max(now - lastPollMs, 0) > maxPollTimeMs / 2) {\n                     numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n                     break;\n-                } else if (processed > 0) {\n+                } else if (punctuated > 0 || committed > 0) {\n+                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n+                } else {\n                     numIterations++;\n                 }\n-            } while (processed > 0);\n-\n-            maybeCommit();\n+            } while (true);\n         }\n+\n+        final long runOnceLatency = pollLatency + restoreLatency + totalCommitLatency + totalProcessLatency + totalPunctuateLatency;\n+        processRatioSensor.record((double) totalProcessLatency / runOnceLatency);", "originalCommit": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg2ODcyNQ==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398868725", "bodyText": "Not sure about this. I think the motivation is reasonable, if we're going to change the metric, then it creates unnecessary thrashing to introduce it here.\nOTOH, even if we move restoration to another thread, that thread will still have a name, so the metric name itself wouldn't actually change, just the value of the thread name, which changes between every instance run anyway.", "author": "vvcephei", "createdAt": "2020-03-26T20:25:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcwODI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1MDU1NA==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398950554", "bodyText": "Here's a few considerations: 1) when we move that to another thread(s), then the restoration-ratio would basically be 100% of that thread(s), unless we separate the the restoreConsumer.poll call out of applying updates here, but in that case we'd probably introduce with different tags, 2) if we are moving it to a thread pool instead of a single thread, then there would be no thread-id in the tags, but some other ids.\nSo I decided to defer adding this metric until we've figured out exactly how we are going to restore in the other threads --- I'm not suggesting that we never add this metric, just defer it :)", "author": "guozhangwang", "createdAt": "2020-03-26T23:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcwODI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAyMTc1Mg==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r399021752", "bodyText": "Ok, sounds good.", "author": "vvcephei", "createdAt": "2020-03-27T03:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcwODI0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0286037701fdc8a2993a9953549974baa8f22b85", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\nindex 5a3079abb9..5c31d62a64 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n\n@@ -659,6 +660,8 @@ public class StreamThread extends Thread {\n              */\n             do {\n                 final int processed = taskManager.process(numIterations, now);\n+                final long processLatency = advanceNowAndComputeLatency();\n+                totalProcessLatency += processLatency;\n                 if (processed > 0) {\n                     // It makes no difference to the outcome of these metrics when we record \"0\",\n                     // so we can just avoid the method call when we didn't process anything.\n"}}, {"oid": "b2982363abcca81fbd64a0b9835ec28b619da1a9", "url": "https://github.com/apache/kafka/commit/b2982363abcca81fbd64a0b9835ec28b619da1a9", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K9756-loop-tasks-order", "committedDate": "2020-03-26T17:28:50Z", "type": "commit"}, {"oid": "153b7417674c9bdc6d4b0aaf9f5684c1a646ff11", "url": "https://github.com/apache/kafka/commit/153b7417674c9bdc6d4b0aaf9f5684c1a646ff11", "message": "should be INFO", "committedDate": "2020-03-26T19:07:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5MTcyNQ==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398791725", "bodyText": "Just to be sure it's not sliding by unnoticed, there may be some overhead in the taskManager.process call. When we do process some records (process > 0), this overhead is counted in totalProcessLatency, but when we didn't process records (process == 0), the overhead gets counted in totalPunctuateLatency. The \"solution\" would be to move final long processLatency = advanceNowAndComputeLatency(); and totalProcessLatency += processLatency; to immediately after the taskManager.process (i.e., unconditionally account for time spent), although the processLatencySensor recording needs to remain conditional.\nAlso, note there are knock-on implications to this question, since there also may be overhead to punctuate, and if punctuated <= 0, then we also don't account the time for that, and so forth with commit.", "author": "vvcephei", "createdAt": "2020-03-26T18:17:31Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);\n+                if (processed > 0) {\n+                    // It makes no difference to the outcome of these metrics when we record \"0\",\n+                    // so we can just avoid the method call when we didn't process anything.\n+                    processRateSensor.record(processed, now);\n+\n+                    // This metric is scaled to represent the _average_ processing time of _each_\n+                    // task. Note, it's hard to interpret this as defined, but we would need a KIP\n+                    // to change it to simply report the overall time spent processing all tasks.\n+                    final long processLatency = advanceNowAndComputeLatency();", "originalCommit": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0ODg1NQ==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398948855", "bodyText": "I noticed that when preparing the PR, and I was biting this with the hope to reduce calls to time.milliseonds inside advanceNowAndComputeLatency when processed / punctuated / committed == 0, with the assumption that the overhead is small and hence no need to worry.\nBut after thinking it twice as you brought it up as well, I think it might be better to not be stingy about time.milliseconds calls but rather trying to be more accurate in our latency recordings. So I will go ahead and change this.", "author": "guozhangwang", "createdAt": "2020-03-26T23:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5MTcyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "0286037701fdc8a2993a9953549974baa8f22b85", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\nindex 5a3079abb9..5c31d62a64 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n\n@@ -659,6 +660,8 @@ public class StreamThread extends Thread {\n              */\n             do {\n                 final int processed = taskManager.process(numIterations, now);\n+                final long processLatency = advanceNowAndComputeLatency();\n+                totalProcessLatency += processLatency;\n                 if (processed > 0) {\n                     // It makes no difference to the outcome of these metrics when we record \"0\",\n                     // so we can just avoid the method call when we didn't process anything.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4MjI4Mg==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398882282", "bodyText": "Can you elaborate on the need for this? Sensor#record already checks shouldRecord before doing anything. It's also already a no-op if you have nothing registered and no parents, although it does incur synchronization overhead in that case. However, it seems like that synchronization is necessary in the current Sensor implementation.", "author": "vvcephei", "createdAt": "2020-03-26T20:48:51Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -807,6 +807,12 @@ public static void maybeMeasureLatency(final Runnable actionToMeasure,\n         }\n     }\n \n+    public static void maybeMeasureLatency(final double elapsedNs, final Sensor sensor) {\n+        if (sensor.shouldRecord() && sensor.hasMetrics()) {\n+            sensor.record(elapsedNs);\n+        }\n+    }", "originalCommit": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1MDk0MA==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398950940", "bodyText": "I would not elaborate this because I realized you're right and it is not necessary :) Will fix.", "author": "guozhangwang", "createdAt": "2020-03-26T23:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4MjI4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "0286037701fdc8a2993a9953549974baa8f22b85", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java\nindex 7af473c848..ee372f73a0 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java\n\n@@ -807,12 +807,6 @@ public class StreamsMetricsImpl implements StreamsMetrics {\n         }\n     }\n \n-    public static void maybeMeasureLatency(final double elapsedNs, final Sensor sensor) {\n-        if (sensor.shouldRecord() && sensor.hasMetrics()) {\n-            sensor.record(elapsedNs);\n-        }\n-    }\n-\n     public static <T> T maybeMeasureLatency(final Supplier<T> actionToMeasure,\n                                             final Time time,\n                                             final Sensor sensor) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4Mzc4Mw==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398883783", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"The fraction of time stream thread is spending on processing active tasks.\";\n          \n          \n            \n                    \"The fraction of time the thread spent on processing active tasks.\";\n          \n      \n    \n    \n  \n\n(also applies to the others)", "author": "vvcephei", "createdAt": "2020-03-26T20:51:42Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/ThreadMetrics.java", "diffHunk": "@@ -83,6 +86,14 @@ private ThreadMetrics() {}\n         \"The average commit latency over all tasks assigned to one stream thread\";\n     private static final String COMMIT_OVER_TASKS_MAX_LATENCY_DESCRIPTION =\n         \"The maximum commit latency over all tasks assigned to one stream thread\";\n+    private static final String PROCESS_RATIO_DESCRIPTION =\n+        \"The fraction of time stream thread is spending on processing active tasks.\";", "originalCommit": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1NDk0Mw==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398954943", "bodyText": "Ack", "author": "guozhangwang", "createdAt": "2020-03-26T23:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4Mzc4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0286037701fdc8a2993a9953549974baa8f22b85", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/ThreadMetrics.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/ThreadMetrics.java\nindex b972181ff6..2854d8a422 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/ThreadMetrics.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/ThreadMetrics.java\n\n@@ -87,13 +87,13 @@ public class ThreadMetrics {\n     private static final String COMMIT_OVER_TASKS_MAX_LATENCY_DESCRIPTION =\n         \"The maximum commit latency over all tasks assigned to one stream thread\";\n     private static final String PROCESS_RATIO_DESCRIPTION =\n-        \"The fraction of time stream thread is spending on processing active tasks.\";\n+        \"The fraction of time the thread spent on processing active tasks.\";\n     private static final String PUNCTUATE_RATIO_DESCRIPTION =\n-        \"The fraction of time stream thread is spending on punctuating active tasks.\";\n+        \"The fraction of time the thread spent on punctuating active tasks.\";\n     private static final String POLL_RATIO_DESCRIPTION =\n-        \"The fraction of time stream thread is spending on polling records from consumer.\";\n+        \"The fraction of time the thread spent on polling records from consumer.\";\n     private static final String COMMIT_RATIO_DESCRIPTION =\n-        \"The fraction of time stream thread is spending on committing all tasks.\";\n+        \"The fraction of time the thread spent on committing all tasks.\";\n \n     public static Sensor createTaskSensor(final String threadId,\n                                           final StreamsMetricsImpl streamsMetrics) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4NDU5Nw==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398884597", "bodyText": "I'm suspicious of summing the various latencies, rather than just measuring the time from the start of the method until now, since it would hide any unexpected sources of overhead.", "author": "vvcephei", "createdAt": "2020-03-26T20:53:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);\n+                if (processed > 0) {\n+                    // It makes no difference to the outcome of these metrics when we record \"0\",\n+                    // so we can just avoid the method call when we didn't process anything.\n+                    processRateSensor.record(processed, now);\n+\n+                    // This metric is scaled to represent the _average_ processing time of _each_\n+                    // task. Note, it's hard to interpret this as defined, but we would need a KIP\n+                    // to change it to simply report the overall time spent processing all tasks.\n+                    final long processLatency = advanceNowAndComputeLatency();\n+                    processLatencySensor.record(processLatency / (double) processed, now);\n+                    totalProcessLatency += processLatency;\n+                }\n+\n+                final int punctuated = taskManager.punctuate();\n+                if (punctuated > 0) {\n+                    final long punctuateLatency = advanceNowAndComputeLatency();\n+                    punctuateSensor.record(punctuateLatency / (double) punctuated, now);\n+                    totalPunctuateLatency += punctuateLatency;\n                 }\n \n-                timeSinceLastPoll = Math.max(now - lastPollMs, 0);\n+                final int committed = maybeCommit();\n+                if (committed > 0) {\n+                    final long commitLatency = advanceNowAndComputeLatency();\n+                    commitSensor.record(commitLatency / (double) committed, now);\n \n-                if (maybePunctuate() || maybeCommit()) {\n-                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n-                } else if (timeSinceLastPoll > maxPollTimeMs / 2) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Committed all active tasks {} and standby tasks {} in {}ms\",\n+                            taskManager.activeTaskIds(), taskManager.standbyTaskIds(), commitLatency);\n+                    }\n+\n+                    totalCommitLatency += commitLatency;\n+                }\n+\n+                if (processed == 0) {\n+                    // if there is no records to be processed, exit after punctuate / commit\n+                    break;\n+                } else if (Math.max(now - lastPollMs, 0) > maxPollTimeMs / 2) {\n                     numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n                     break;\n-                } else if (processed > 0) {\n+                } else if (punctuated > 0 || committed > 0) {\n+                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n+                } else {\n                     numIterations++;\n                 }\n-            } while (processed > 0);\n-\n-            maybeCommit();\n+            } while (true);\n         }\n+\n+        final long runOnceLatency = pollLatency + restoreLatency + totalCommitLatency + totalProcessLatency + totalPunctuateLatency;", "originalCommit": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1MTA2MQ==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398951061", "bodyText": "Good point. Will fix.", "author": "guozhangwang", "createdAt": "2020-03-26T23:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4NDU5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0286037701fdc8a2993a9953549974baa8f22b85", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\nindex 5a3079abb9..5c31d62a64 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java\n\n@@ -659,6 +660,8 @@ public class StreamThread extends Thread {\n              */\n             do {\n                 final int processed = taskManager.process(numIterations, now);\n+                final long processLatency = advanceNowAndComputeLatency();\n+                totalProcessLatency += processLatency;\n                 if (processed > 0) {\n                     // It makes no difference to the outcome of these metrics when we record \"0\",\n                     // so we can just avoid the method call when we didn't process anything.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NDE1Mw==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398894153", "bodyText": "Not sure if there's a better way to put it, but I was a little surprised to see \"we would stop early\". I guess it didn't even occur to me that the task manager would block or something if there's no records to process.", "author": "vvcephei", "createdAt": "2020-03-26T21:08:53Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -1804,25 +1805,52 @@ public void shouldMaybeCommitAllActiveTasksThatNeedCommit() {\n     @Test\n     public void shouldProcessActiveTasks() {\n         final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n+        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n+\n+        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>();\n+        assignment.put(taskId00, taskId00Partitions);\n+        assignment.put(taskId01, taskId01Partitions);\n \n         expectRestoreToBeCompleted(consumer, changeLogReader);\n-        expect(activeTaskCreator.createTasks(anyObject(), eq(taskId00Assignment)))\n-            .andReturn(singletonList(task00)).anyTimes();\n+        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n+            .andReturn(Arrays.asList(task00, task01)).anyTimes();\n \n         replay(activeTaskCreator, consumer, changeLogReader);\n \n-        taskManager.handleAssignment(taskId00Assignment, emptyMap());\n+        taskManager.handleAssignment(assignment, emptyMap());\n         assertThat(taskManager.tryToCompleteRestoration(), is(true));\n \n         assertThat(task00.state(), is(Task.State.RUNNING));\n+        assertThat(task01.state(), is(Task.State.RUNNING));\n \n-        final TopicPartition partition = taskId00Partitions.iterator().next();\n         task00.addRecords(\n-            partition,\n-            singletonList(new ConsumerRecord<>(partition.topic(), partition.partition(), 0L, null, null))\n+            t1p0,\n+            Arrays.asList(\n+                getConsumerRecord(t1p0, 0L),\n+                getConsumerRecord(t1p0, 1L),\n+                getConsumerRecord(t1p0, 2L),\n+                getConsumerRecord(t1p0, 3L),\n+                getConsumerRecord(t1p0, 4L),\n+                getConsumerRecord(t1p0, 5L)\n+            )\n         );\n+        task01.addRecords(\n+            t1p1,\n+            Arrays.asList(\n+                getConsumerRecord(t1p1, 0L),\n+                getConsumerRecord(t1p1, 1L),\n+                getConsumerRecord(t1p1, 2L),\n+                getConsumerRecord(t1p1, 3L),\n+                getConsumerRecord(t1p1, 4L)\n+            )\n+        );\n+\n+        // check that we should be processing at most max num records\n+        assertThat(taskManager.process(3, 0L), is(6));\n \n-        assertThat(taskManager.process(0L), is(1));\n+        // check that if there's no records proccssible, we would stop early", "originalCommit": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1MjIwNQ==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398952205", "bodyText": "Oh maybe I did not put it clearly: let's say for a single task, if we call process(N) but there are only M < N records in the buffer, then of course we would process only M records.\nIf there are multiple tasks, say, 2, if we call process(N) and task1 has N1 > N and task2 has N2 < N, then we would process a total of N + N2 in a single call, and in that case we would not \"stop\" but continues to process; we would only break the loop when ALL tasks have no records to process. This test is just to verify that part.", "author": "guozhangwang", "createdAt": "2020-03-26T23:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NDE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAyMjkxNA==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r399022914", "bodyText": "Ah, ok... To be clear, I was only confused about the comment, not the behavior. I think the comment was \"obvious\" to me only because this is exactly what this PR is about. But coming back in a year, I'm sure I'll appreciate the comment.", "author": "vvcephei", "createdAt": "2020-03-27T04:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NDE1Mw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "7431c1ab6aa5182e734d70f51b38b53b469e3081", "url": "https://github.com/apache/kafka/commit/7431c1ab6aa5182e734d70f51b38b53b469e3081", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K9756-loop-tasks-order", "committedDate": "2020-03-26T23:12:59Z", "type": "commit"}, {"oid": "0286037701fdc8a2993a9953549974baa8f22b85", "url": "https://github.com/apache/kafka/commit/0286037701fdc8a2993a9953549974baa8f22b85", "message": "github comments", "committedDate": "2020-03-26T23:39:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1NTM2Nw==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398955367", "bodyText": "Just realized it should be INFO not DEBUG.", "author": "guozhangwang", "createdAt": "2020-03-26T23:40:34Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/ThreadMetrics.java", "diffHunk": "@@ -220,6 +231,70 @@ public static Sensor commitOverTasksSensor(final String threadId,\n         return commitOverTasksSensor;\n     }\n \n+    public static Sensor processRatioSensor(final String threadId,\n+                                            final StreamsMetricsImpl streamsMetrics) {\n+        final Sensor sensor =\n+            streamsMetrics.threadLevelSensor(threadId, PROCESS + RATIO_SUFFIX, Sensor.RecordingLevel.INFO);", "originalCommit": "0286037701fdc8a2993a9953549974baa8f22b85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "990ec8a34eb22dd13b0120c288f4161007f6ae46", "url": "https://github.com/apache/kafka/commit/990ec8a34eb22dd13b0120c288f4161007f6ae46", "message": "minor fix", "committedDate": "2020-03-27T05:51:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2NzA5OA==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r400467098", "bodyText": "Could you please add unit tests for the new sensors and metrics?", "author": "cadonna", "createdAt": "2020-03-30T20:17:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/ThreadMetrics.java", "diffHunk": "@@ -220,6 +231,70 @@ public static Sensor commitOverTasksSensor(final String threadId,\n         return commitOverTasksSensor;\n     }\n \n+    public static Sensor processRatioSensor(final String threadId,", "originalCommit": "990ec8a34eb22dd13b0120c288f4161007f6ae46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyNzEwMg==", "url": "https://github.com/apache/kafka/pull/8358#discussion_r400527102", "bodyText": "Yes, they are added in the follow-up PR.", "author": "guozhangwang", "createdAt": "2020-03-30T22:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2NzA5OA=="}], "type": "inlineReview", "revised_code": null}]}