{"pr_number": 8712, "pr_title": " KAFKA-10006: Don't create internal topics when LeaderNotAvailableException", "pr_createdAt": "2020-05-22T10:16:05Z", "pr_url": "https://github.com/apache/kafka/pull/8712", "timeline": [{"oid": "6b01ecdd8fa22d812b6f6590144c733b43e87060", "url": "https://github.com/apache/kafka/commit/6b01ecdd8fa22d812b6f6590144c733b43e87060", "message": "KAFKA-10006: do not attempt to create internal topics if got LeaderNotAvailableException", "committedDate": "2020-05-22T09:08:23Z", "type": "commit"}, {"oid": "e3fb9fdc1239d14d6b2eb9a33224f23e5ee7f052", "url": "https://github.com/apache/kafka/commit/e3fb9fdc1239d14d6b2eb9a33224f23e5ee7f052", "message": "KAFKA-10006: add tests", "committedDate": "2020-05-22T10:12:46Z", "type": "commit"}, {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb", "url": "https://github.com/apache/kafka/commit/608e52b86d40de8b4031894d7a513869a65dd6bb", "message": "KAFKA-10006: refactor", "committedDate": "2020-05-22T14:28:56Z", "type": "commit"}, {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb", "url": "https://github.com/apache/kafka/commit/608e52b86d40de8b4031894d7a513869a65dd6bb", "message": "KAFKA-10006: refactor", "committedDate": "2020-05-22T14:28:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4ODQ0OQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r429288449", "bodyText": "Try to simulate the LeaderNotAvailableException in the MockAdminClient, if the topic name isLeaderNotAvailableTopic.", "author": "showuon", "createdAt": "2020-05-22T14:41:48Z", "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "diffHunk": "@@ -330,6 +331,12 @@ synchronized public DescribeTopicsResult describeTopics(Collection<String> topic\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n+            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"\n+            if (requestedTopic.equals(\"LeaderNotAvailableTopic\")) {\n+                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n+                future.completeExceptionally(new LeaderNotAvailableException(\"The leader of Topic \" + requestedTopic + \" is not available.\"));", "originalCommit": "608e52b86d40de8b4031894d7a513869a65dd6bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDM2OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444554368", "bodyText": "Is it possible to use EasyMock instead of adding this to the actual MockAdminClient? I know it's kind of a pain to set up but I think it'll make the test a lot more clear. I did something similar in StreamsPartitionAssignorTest to mock the results of the listOffsets request", "author": "ableegoldman", "createdAt": "2020-06-23T23:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4ODQ0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "chunk": "diff --git a/clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java b/clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java\nindex 91e219ff58..3d8915149b 100644\n--- a/clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java\n+++ b/clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java\n\n@@ -331,8 +364,8 @@ public class MockAdminClient extends AdminClient {\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n-            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"\n-            if (requestedTopic.equals(\"LeaderNotAvailableTopic\")) {\n+            // try to simulate the leader not available situation\n+            if (requestedTopic.equals(LEADER_NOT_AVAILABLE_TOPIC)) {\n                 KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                 future.completeExceptionally(new LeaderNotAvailableException(\"The leader of Topic \" + requestedTopic + \" is not available.\"));\n                 topicDescriptions.put(requestedTopic, future);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4OTM4MA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r429289380", "bodyText": "If there's topic with LeaderNotAvailableException, we also need to retry.", "author": "showuon", "createdAt": "2020-05-22T14:43:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -247,11 +261,19 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else {\n+            } else if (!needRetryTopics.contains(topicName)) {\n                 topicsToCreate.add(topicName);\n             }\n         }\n \n         return topicsToCreate;\n     }\n+\n+    private boolean isNeedRetry(final Set<String> topicsNotReady) {\n+        return !topicsNotReady.isEmpty() || hasNeedRetryTopic();", "originalCommit": "608e52b86d40de8b4031894d7a513869a65dd6bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex 2552bf5b24..799e18215c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -261,7 +260,7 @@ public class InternalTopicManager {\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else if (!needRetryTopics.contains(topicName)) {\n+            } else if (!leaderNotAvailableTopics.contains(topicName)) {\n                 topicsToCreate.add(topicName);\n             }\n         }\n"}}, {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "url": "https://github.com/apache/kafka/commit/ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "message": "KAFKA-10006: refactor", "committedDate": "2020-05-25T02:25:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mjc1MQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436282751", "bodyText": "This should be declared final.", "author": "abbccdda", "createdAt": "2020-06-06T16:45:15Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -59,6 +59,9 @@ private InternalAdminClientConfig(final Map<?, ?> props) {\n \n     private final int retries;\n     private final long retryBackOffMs;\n+    private int remainingRetries;\n+\n+    private HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "originalCommit": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mzc0NQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283745", "bodyText": "Similar to this struct, it doesn't make sense to have a non-empty leaderNotAvailableTopics after each call to makeReady, I would prefer building it as local variable, cc @ableegoldman", "author": "abbccdda", "createdAt": "2020-06-06T16:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mjc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3OTUxNQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436479515", "bodyText": "Oh, Nice catch! You're correct, @abbccdda , it might have a non-empty leaderNotAvailableTopics after each call to makeReady. I changed it to using local variable. Thank you.", "author": "showuon", "createdAt": "2020-06-08T06:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mjc1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex 799e18215c..b1d64feba0 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -59,9 +54,6 @@ public class InternalTopicManager {\n \n     private final int retries;\n     private final long retryBackOffMs;\n-    private int remainingRetries;\n-\n-    private HashSet<String> leaderNotAvailableTopics = new HashSet<>();\n \n     public InternalTopicManager(final Admin adminClient, final StreamsConfig streamsConfig) {\n         this.adminClient = adminClient;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjkyMw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436282923", "bodyText": "This contains check is unnecessary.", "author": "abbccdda", "createdAt": "2020-06-06T16:47:21Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -195,20 +198,30 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n             final String topicName = topicFuture.getKey();\n             try {\n                 final TopicDescription topicDescription = topicFuture.getValue().get();\n-                existedTopicPartition.put(\n-                    topicFuture.getKey(),\n-                    topicDescription.partitions().size());\n+                existedTopicPartition.put(topicName, topicDescription.partitions().size());\n+                if (leaderNotAvailableTopics.contains(topicName)) {", "originalCommit": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDAyNw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436444027", "bodyText": "Good point! The remove method will return true/false for key found/not found. Fixed.", "author": "showuon", "createdAt": "2020-06-08T03:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjkyMw=="}], "type": "inlineReview", "revised_code": {"commit": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex 799e18215c..b1d64feba0 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -199,9 +194,7 @@ public class InternalTopicManager {\n             try {\n                 final TopicDescription topicDescription = topicFuture.getValue().get();\n                 existedTopicPartition.put(topicName, topicDescription.partitions().size());\n-                if (leaderNotAvailableTopics.contains(topicName)) {\n-                    leaderNotAvailableTopics.remove(topicName);\n-                }\n+                leaderNotAvailableTopics.remove(topicName);\n             } catch (final InterruptedException fatalException) {\n                 // this should not happen; if it ever happens it indicate a bug\n                 Thread.currentThread().interrupt();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MzQ3Mw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283473", "bodyText": "This is a personal preference, but I think we should not attempt to include a temporal variable as part of the class struct. We could change the internal function signatures to pass around remainingRetries (like validateTopics) instead.", "author": "abbccdda", "createdAt": "2020-06-06T16:54:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -100,11 +103,11 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         // have existed with the expected number of partitions, or some create topic returns fatal errors.\n         log.debug(\"Starting to validate internal topics {} in partition assignor.\", topics);\n \n-        int remainingRetries = retries;\n+        remainingRetries = retries;", "originalCommit": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2MDY5MQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436460691", "bodyText": "OK, fixed. Thanks.", "author": "showuon", "createdAt": "2020-06-08T05:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MzQ3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex 799e18215c..b1d64feba0 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -103,12 +95,13 @@ public class InternalTopicManager {\n         // have existed with the expected number of partitions, or some create topic returns fatal errors.\n         log.debug(\"Starting to validate internal topics {} in partition assignor.\", topics);\n \n-        remainingRetries = retries;\n+        int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n+        final HashSet<String> leaderNotAvailableTopics = new HashSet<>();\n \n-        while (shouldRetry(topicsNotReady) && remainingRetries >= 0) {\n-            topicsNotReady = validateTopics(topicsNotReady, topics);\n+        while (shouldRetry(topicsNotReady, leaderNotAvailableTopics) && remainingRetries >= 0) {\n+            topicsNotReady = validateTopics(topicsNotReady, topics, leaderNotAvailableTopics, remainingRetries);\n             newlyCreatedTopics.addAll(topicsNotReady);\n \n             if (!topicsNotReady.isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mzk2OQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283969", "bodyText": "This workaround is very hard to be found by other developers, as a minimum we should define a constant and make it part of MockAdminClient class", "author": "abbccdda", "createdAt": "2020-06-06T17:01:35Z", "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "diffHunk": "@@ -330,6 +331,12 @@ synchronized public DescribeTopicsResult describeTopics(Collection<String> topic\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n+            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"", "originalCommit": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NjU1Mg==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436446552", "bodyText": "Good suggestion. I put it as a constant. Thanks.", "author": "showuon", "createdAt": "2020-06-08T04:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mzk2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "chunk": "diff --git a/clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java b/clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java\nindex 91e219ff58..3d8915149b 100644\n--- a/clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java\n+++ b/clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java\n\n@@ -331,8 +364,8 @@ public class MockAdminClient extends AdminClient {\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n-            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"\n-            if (requestedTopic.equals(\"LeaderNotAvailableTopic\")) {\n+            // try to simulate the leader not available situation\n+            if (requestedTopic.equals(LEADER_NOT_AVAILABLE_TOPIC)) {\n                 KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n                 future.completeExceptionally(new LeaderNotAvailableException(\"The leader of Topic \" + requestedTopic + \" is not available.\"));\n                 topicDescriptions.put(requestedTopic, future);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDA0OQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436284049", "bodyText": "Testing against log message is error-prone and hard to maintain, I think just making sure the thrown exception type is expected should be sufficient.", "author": "abbccdda", "createdAt": "2020-06-06T17:02:40Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,49 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldLogWhenTopicLeaderNotAvailableAndThrowException() {\n+        final String topicLeaderNotAvailable = \"LeaderNotAvailableTopic\";\n+        mockAdminClient.addTopic(\n+            false,\n+            topicLeaderNotAvailable,\n+            Collections.singletonList(new TopicPartitionInfo(0, broker1, cluster, Collections.emptyList())),\n+            null);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topicLeaderNotAvailable, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(topicLeaderNotAvailable, internalTopicConfig);\n+\n+        LogCaptureAppender.setClassLoggerToDebug(InternalTopicManager.class);\n+        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(InternalTopicManager.class)) {\n+            final StreamsException exception = assertThrows(\n+                StreamsException.class,\n+                () -> internalTopicManager.makeReady(topicConfigMap));\n+\n+            final String expectedMessage = \"Could not create topics after 1 retries. This can happen if the Kafka cluster is temporary not available\";", "originalCommit": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NjkwNw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436446907", "bodyText": "Good suggestion. Remove the log message check and only verify the exception thrown. Thanks.", "author": "showuon", "createdAt": "2020-06-08T04:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDA0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\nindex 874a76db77..97f0a7848e 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n\n@@ -298,38 +298,23 @@ public class InternalTopicManagerTest {\n \n     @Test\n     public void shouldLogWhenTopicLeaderNotAvailableAndThrowException() {\n-        final String topicLeaderNotAvailable = \"LeaderNotAvailableTopic\";\n         mockAdminClient.addTopic(\n             false,\n-            topicLeaderNotAvailable,\n+            MockAdminClient.LEADER_NOT_AVAILABLE_TOPIC,\n             Collections.singletonList(new TopicPartitionInfo(0, broker1, cluster, Collections.emptyList())),\n             null);\n \n-        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topicLeaderNotAvailable, Collections.emptyMap());\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(MockAdminClient.LEADER_NOT_AVAILABLE_TOPIC, Collections.emptyMap());\n         internalTopicConfig.setNumberOfPartitions(1);\n \n         final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n-        topicConfigMap.put(topicLeaderNotAvailable, internalTopicConfig);\n+        topicConfigMap.put(MockAdminClient.LEADER_NOT_AVAILABLE_TOPIC, internalTopicConfig);\n \n         LogCaptureAppender.setClassLoggerToDebug(InternalTopicManager.class);\n         try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(InternalTopicManager.class)) {\n             final StreamsException exception = assertThrows(\n                 StreamsException.class,\n                 () -> internalTopicManager.makeReady(topicConfigMap));\n-\n-            final String expectedMessage = \"Could not create topics after 1 retries. This can happen if the Kafka cluster is temporary not available\";\n-            // should throw exception when leader keeps unavailable\n-            assertTrue(exception.getMessage().contains(expectedMessage));\n-\n-            final String logLeaderNotAvailable = \"The leader of Topic \" + topicLeaderNotAvailable + \" is not available\";\n-            // should log the leader not available\n-            assertThat(appender.getMessages(), hasItem(containsString(logLeaderNotAvailable)));\n-\n-            final String logCreateTopic = \"Going to create topic \" + topicLeaderNotAvailable;\n-            final String logTopicExistsException = \"TopicExistsException\";\n-            // should not attempt to create the topic when Leader not available\n-            assertThat(appender.getMessages(), not(hasItem(containsString(logCreateTopic))));\n-            assertThat(appender.getMessages(), not(hasItem(containsString(logTopicExistsException))));\n         }\n     }\n \n"}}, {"oid": "2f015fa945537b73725b48fd2554dc1327a41a80", "url": "https://github.com/apache/kafka/commit/2f015fa945537b73725b48fd2554dc1327a41a80", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into KAFKA-10006", "committedDate": "2020-06-08T03:16:27Z", "type": "commit"}, {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "url": "https://github.com/apache/kafka/commit/0567ecbc82c01b0c6e596fe5c28918f3b530a263", "message": "KAFKA-10006: address reviewer's comments", "committedDate": "2020-06-08T06:18:01Z", "type": "commit"}, {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "url": "https://github.com/apache/kafka/commit/0567ecbc82c01b0c6e596fe5c28918f3b530a263", "message": "KAFKA-10006: address reviewer's comments", "committedDate": "2020-06-08T06:18:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NTcyNA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444555724", "bodyText": "Can we give this a more descriptive name? It might be obvious to you, but I think someone just looking at this code for the first time would not get that this actually means topics that may or may not already exist.\nThat said, I'm struggling to think of a good alternative...maybe possiblyCreatedTopics or unknownTopics...any better ideas?", "author": "ableegoldman", "createdAt": "2020-06-23T23:05:58Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -98,9 +98,10 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n+        final HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "originalCommit": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDczOTc1OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444739758", "bodyText": "Good suggestion, I changed to tempUnknownTopics, because they are temporarily unknown topics for now. How do you think?", "author": "showuon", "createdAt": "2020-06-24T08:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NTcyNA=="}], "type": "inlineReview", "revised_code": {"commit": "f378c34d10c57d796412ac946f867e5787f93af0", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex b1d64feba0..411de4638c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -98,10 +98,10 @@ public class InternalTopicManager {\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n-        final HashSet<String> leaderNotAvailableTopics = new HashSet<>();\n+        final HashSet<String> tempUnknownTopics = new HashSet<>();\n \n-        while (shouldRetry(topicsNotReady, leaderNotAvailableTopics) && remainingRetries >= 0) {\n-            topicsNotReady = validateTopics(topicsNotReady, topics, leaderNotAvailableTopics, remainingRetries);\n+        while (shouldRetry(topicsNotReady, tempUnknownTopics) && remainingRetries >= 0) {\n+            topicsNotReady = validateTopics(topicsNotReady, topics, tempUnknownTopics, remainingRetries);\n             newlyCreatedTopics.addAll(topicsNotReady);\n \n             if (!topicsNotReady.isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NjU2OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444556568", "bodyText": "Can we just use !isEmpty for both sets?", "author": "ableegoldman", "createdAt": "2020-06-23T23:08:32Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -242,11 +256,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else {\n+            } else if (!leaderNotAvailableTopics.contains(topicName)) {\n                 topicsToCreate.add(topicName);\n             }\n         }\n \n         return topicsToCreate;\n     }\n+\n+    private boolean shouldRetry(final Set<String> topicsNotReady, final HashSet<String> leaderNotAvailableTopics) {\n+        // If there's topic with LeaderNotAvailableException, we still need retry\n+        return !topicsNotReady.isEmpty() || leaderNotAvailableTopics.size() > 0;", "originalCommit": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc0MTAzNw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444741037", "bodyText": "Good suggestion. Updated.", "author": "showuon", "createdAt": "2020-06-24T08:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NjU2OA=="}], "type": "inlineReview", "revised_code": {"commit": "f378c34d10c57d796412ac946f867e5787f93af0", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex b1d64feba0..411de4638c 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -256,16 +258,19 @@ public class InternalTopicManager {\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else if (!leaderNotAvailableTopics.contains(topicName)) {\n-                topicsToCreate.add(topicName);\n+            } else {\n+                // for the tempUnknownTopics, we'll check again later if retries > 0\n+                if (!tempUnknownTopics.contains(topicName)) {\n+                    topicsToCreate.add(topicName);\n+                }\n             }\n         }\n \n         return topicsToCreate;\n     }\n \n-    private boolean shouldRetry(final Set<String> topicsNotReady, final HashSet<String> leaderNotAvailableTopics) {\n+    private boolean shouldRetry(final Set<String> topicsNotReady, final HashSet<String> tempUnknownTopics) {\n         // If there's topic with LeaderNotAvailableException, we still need retry\n-        return !topicsNotReady.isEmpty() || leaderNotAvailableTopics.size() > 0;\n+        return !topicsNotReady.isEmpty() || !tempUnknownTopics.isEmpty();\n     }\n }\n"}}, {"oid": "f378c34d10c57d796412ac946f867e5787f93af0", "url": "https://github.com/apache/kafka/commit/f378c34d10c57d796412ac946f867e5787f93af0", "message": "KAFKA-10006: use EasyMock to rewrite the test, and remove the unneeded hack in MockAdminClient", "committedDate": "2020-06-24T14:07:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNTE5Ng==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445135196", "bodyText": "s/HashSet/Set?", "author": "abbccdda", "createdAt": "2020-06-24T19:54:53Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -98,9 +98,10 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n+        final HashSet<String> tempUnknownTopics = new HashSet<>();", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTQzNQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601435", "bodyText": "Fixed. Thanks.", "author": "showuon", "createdAt": "2020-06-25T14:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNTE5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "70d41212fe8a4d5055993c56e30c2342498e1664", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex 411de4638c..0bae0d4545 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -98,7 +98,7 @@ public class InternalTopicManager {\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n-        final HashSet<String> tempUnknownTopics = new HashSet<>();\n+        final Set<String> tempUnknownTopics = new HashSet<>();\n \n         while (shouldRetry(topicsNotReady, tempUnknownTopics) && remainingRetries >= 0) {\n             topicsNotReady = validateTopics(topicsNotReady, topics, tempUnknownTopics, remainingRetries);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNjE3Nw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445136177", "bodyText": "Could be merged with above else", "author": "abbccdda", "createdAt": "2020-06-24T19:56:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -243,10 +259,18 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     throw new StreamsException(errorMsg);\n                 }\n             } else {\n-                topicsToCreate.add(topicName);\n+                // for the tempUnknownTopics, we'll check again later if retries > 0", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTM4OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601388", "bodyText": "Fixed", "author": "showuon", "createdAt": "2020-06-25T14:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNjE3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "70d41212fe8a4d5055993c56e30c2342498e1664", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex 411de4638c..0bae0d4545 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -258,18 +259,16 @@ public class InternalTopicManager {\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else {\n+            } else if (!tempUnknownTopics.contains(topicName)) {\n                 // for the tempUnknownTopics, we'll check again later if retries > 0\n-                if (!tempUnknownTopics.contains(topicName)) {\n-                    topicsToCreate.add(topicName);\n-                }\n+                topicsToCreate.add(topicName);\n             }\n         }\n \n         return topicsToCreate;\n     }\n \n-    private boolean shouldRetry(final Set<String> topicsNotReady, final HashSet<String> tempUnknownTopics) {\n+    private boolean shouldRetry(final Set<String> topicsNotReady, final Set<String> tempUnknownTopics) {\n         // If there's topic with LeaderNotAvailableException, we still need retry\n         return !topicsNotReady.isEmpty() || !tempUnknownTopics.isEmpty();\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzE0Ng==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445137146", "bodyText": "Use 4 space format to align with other tests.", "author": "abbccdda", "createdAt": "2020-06-24T19:58:25Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +291,41 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldLogWhenTopicLeaderNotAvailableAndThrowException() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+                .andReturn(new MockDescribeTopicsResult(", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTM1Mg==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601352", "bodyText": "Nice catch! Fixed.", "author": "showuon", "createdAt": "2020-06-25T14:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzE0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "70d41212fe8a4d5055993c56e30c2342498e1664", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\nindex 905e8bb1e2..bbd663c229 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n\n@@ -308,9 +307,9 @@ public class InternalTopicManagerTest {\n \n         // simulate describeTopics got LeaderNotAvailableException\n         EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n-                .andReturn(new MockDescribeTopicsResult(\n-                        Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n-                .times(2);\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .times(2);\n \n         EasyMock.replay(admin);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3NzU0OQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445277549", "bodyText": "We could just pass in a boolean here to indicate whether there are remaining retries", "author": "abbccdda", "createdAt": "2020-06-25T02:46:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTMyNQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601325", "bodyText": "Updated.", "author": "showuon", "createdAt": "2020-06-25T14:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3NzU0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "70d41212fe8a4d5055993c56e30c2342498e1664", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex 411de4638c..0bae0d4545 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -181,8 +181,8 @@ public class InternalTopicManager {\n      */\n     // visible for testing\n     protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n-                                                    final HashSet<String> tempUnknownTopics,\n-                                                    final int remainingRetries) {\n+                                                    final Set<String> tempUnknownTopics,\n+                                                    final boolean hasRemainingRetries) {\n         final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n         allTopicsToDescribe.addAll(tempUnknownTopics);\n         log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", allTopicsToDescribe);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3Nzk2MQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445277961", "bodyText": "Could reduce the if-else block as:\nif (remainingRetries <= 0) {\n  // run out of retries, throw exception directly \n  throw new StreamsException(\n    String.format(\"The leader of the Topic %s is not available after %d retries.\", topicName, retries), cause);\n }\n log.debug(\"The leader of the Topic {} is not available, with {} retries left.\\n\" +\n   \"Error message was: {}\", topicName, remainingRetries, cause.toString());", "author": "abbccdda", "createdAt": "2020-06-25T02:48:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {\n+        final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n+        allTopicsToDescribe.addAll(tempUnknownTopics);\n+        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", allTopicsToDescribe);\n+\n+        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(allTopicsToDescribe);\n         final Map<String, KafkaFuture<TopicDescription>> futures = describeTopicsResult.values();\n \n         final Map<String, Integer> existedTopicPartition = new HashMap<>();\n         for (final Map.Entry<String, KafkaFuture<TopicDescription>> topicFuture : futures.entrySet()) {\n             final String topicName = topicFuture.getKey();\n             try {\n                 final TopicDescription topicDescription = topicFuture.getValue().get();\n-                existedTopicPartition.put(\n-                    topicFuture.getKey(),\n-                    topicDescription.partitions().size());\n+                existedTopicPartition.put(topicName, topicDescription.partitions().size());\n+                tempUnknownTopics.remove(topicName);\n             } catch (final InterruptedException fatalException) {\n                 // this should not happen; if it ever happens it indicate a bug\n                 Thread.currentThread().interrupt();\n                 log.error(INTERRUPTED_ERROR_MESSAGE, fatalException);\n                 throw new IllegalStateException(INTERRUPTED_ERROR_MESSAGE, fatalException);\n             } catch (final ExecutionException couldNotDescribeTopicException) {\n                 final Throwable cause = couldNotDescribeTopicException.getCause();\n-                if (cause instanceof UnknownTopicOrPartitionException ||\n-                    cause instanceof LeaderNotAvailableException) {\n-                    // This topic didn't exist or leader is not known yet, proceed to try to create it\n-                    log.debug(\"Topic {} is unknown or not found, hence not existed yet: {}\", topicName, cause.toString());\n+                if (cause instanceof UnknownTopicOrPartitionException) {\n+                    // This topic didn't exist, proceed to try to create it\n+                    log.debug(\"Topic {} is unknown or not found, hence not existed yet.\\n\" +\n+                        \"Error message was: {}\", topicName, cause.toString());\n+                } else if (cause instanceof LeaderNotAvailableException) {\n+                    tempUnknownTopics.add(topicName);\n+                    if (remainingRetries > 0) {", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTI3OQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601279", "bodyText": "Updated.", "author": "showuon", "createdAt": "2020-06-25T14:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3Nzk2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "70d41212fe8a4d5055993c56e30c2342498e1664", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex 411de4638c..0bae0d4545 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -181,8 +181,8 @@ public class InternalTopicManager {\n      */\n     // visible for testing\n     protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n-                                                    final HashSet<String> tempUnknownTopics,\n-                                                    final int remainingRetries) {\n+                                                    final Set<String> tempUnknownTopics,\n+                                                    final boolean hasRemainingRetries) {\n         final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n         allTopicsToDescribe.addAll(tempUnknownTopics);\n         log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", allTopicsToDescribe);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODQ1Nw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278457", "bodyText": "Why do we need allTopicsToDescribe? It seems only queried once locally.", "author": "abbccdda", "createdAt": "2020-06-25T02:50:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {\n+        final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n+        allTopicsToDescribe.addAll(tempUnknownTopics);", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYyNTExMg==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445625112", "bodyText": "The allTopicsToDescribe is for tempUnknownTopics to have chance to get described again, by the retries in makeReady method. In the makeReady, we want to know which topics existed and to validate it, and which topics not existed that needed to be created. But for the LeaderNotAvailabletopics, we can't know if topics existed or not. So, we need to merge topics(topics to validate) and tempUnknownTopics here to describe them all (again) here.\nThanks.", "author": "showuon", "createdAt": "2020-06-25T15:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODQ1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "70d41212fe8a4d5055993c56e30c2342498e1664", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex 411de4638c..0bae0d4545 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -181,8 +181,8 @@ public class InternalTopicManager {\n      */\n     // visible for testing\n     protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n-                                                    final HashSet<String> tempUnknownTopics,\n-                                                    final int remainingRetries) {\n+                                                    final Set<String> tempUnknownTopics,\n+                                                    final boolean hasRemainingRetries) {\n         final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n         allTopicsToDescribe.addAll(tempUnknownTopics);\n         log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", allTopicsToDescribe);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODY2Mg==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278662", "bodyText": "Similar here, we could reduce to Set", "author": "abbccdda", "createdAt": "2020-06-25T02:51:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -218,13 +231,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n     /**\n      * Check the existing topics to have correct number of partitions; and return the remaining topics that needs to be created\n      */\n-    private Set<String> validateTopics(final Set<String> topicsToValidate, final Map<String, InternalTopicConfig> topicsMap) {\n+    private Set<String> validateTopics(final Set<String> topicsToValidate,\n+                                       final Map<String, InternalTopicConfig> topicsMap,\n+                                       final HashSet<String> tempUnknownTopics,", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTIzOA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601238", "bodyText": "Fixed.", "author": "showuon", "createdAt": "2020-06-25T14:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODY2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "70d41212fe8a4d5055993c56e30c2342498e1664", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\nindex 411de4638c..0bae0d4545 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java\n\n@@ -233,14 +233,15 @@ public class InternalTopicManager {\n      */\n     private Set<String> validateTopics(final Set<String> topicsToValidate,\n                                        final Map<String, InternalTopicConfig> topicsMap,\n-                                       final HashSet<String> tempUnknownTopics,\n+                                       final Set<String> tempUnknownTopics,\n                                        final int remainingRetries) {\n         if (!topicsMap.keySet().containsAll(topicsToValidate)) {\n             throw new IllegalStateException(\"The topics map \" + topicsMap.keySet() + \" does not contain all the topics \" +\n                 topicsToValidate + \" trying to validate.\");\n         }\n \n-        final Map<String, Integer> existedTopicPartition = getNumPartitions(topicsToValidate, tempUnknownTopics, remainingRetries);\n+        final Map<String, Integer> existedTopicPartition =\n+            getNumPartitions(topicsToValidate, tempUnknownTopics, remainingRetries > 0);\n \n         final Set<String> topicsToCreate = new HashSet<>();\n         for (final String topicName : topicsToValidate) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODg2Mw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278863", "bodyText": "Could use Collections.emptySet() if reduced to Set", "author": "abbccdda", "createdAt": "2020-06-25T02:52:09Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -108,7 +111,8 @@ public void shouldReturnCorrectPartitionCounts() {\n             topic,\n             Collections.singletonList(new TopicPartitionInfo(0, broker1, singleReplica, Collections.emptyList())),\n             null);\n-        assertEquals(Collections.singletonMap(topic, 1), internalTopicManager.getNumPartitions(Collections.singleton(topic)));\n+        assertEquals(Collections.singletonMap(topic, 1),\n+                internalTopicManager.getNumPartitions(Collections.singleton(topic), new HashSet<String>(), 1));", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTIwNw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601207", "bodyText": "Updated. Thanks.", "author": "showuon", "createdAt": "2020-06-25T14:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODg2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "70d41212fe8a4d5055993c56e30c2342498e1664", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\nindex 905e8bb1e2..bbd663c229 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n\n@@ -112,7 +111,7 @@ public class InternalTopicManagerTest {\n             Collections.singletonList(new TopicPartitionInfo(0, broker1, singleReplica, Collections.emptyList())),\n             null);\n         assertEquals(Collections.singletonMap(topic, 1),\n-                internalTopicManager.getNumPartitions(Collections.singleton(topic), new HashSet<String>(), 1));\n+            internalTopicManager.getNumPartitions(Collections.singleton(topic), Collections.emptySet(), true));\n     }\n \n     @Test\n"}}, {"oid": "70d41212fe8a4d5055993c56e30c2342498e1664", "url": "https://github.com/apache/kafka/commit/70d41212fe8a4d5055993c56e30c2342498e1664", "message": "KAFKA-10006: address reviewer's comments", "committedDate": "2020-06-25T14:30:29Z", "type": "commit"}, {"oid": "70d41212fe8a4d5055993c56e30c2342498e1664", "url": "https://github.com/apache/kafka/commit/70d41212fe8a4d5055993c56e30c2342498e1664", "message": "KAFKA-10006: address reviewer's comments", "committedDate": "2020-06-25T14:30:29Z", "type": "forcePushed"}, {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00", "url": "https://github.com/apache/kafka/commit/9089b4bb8ddef924e45e19d7806343627f206b00", "message": "KAFKA-10006: fix the log flaw to count the tempUnkonwnTopics as topicsNotReady and add 2 more tests\n\n1. Return the topicsNotReady to makeReady including tempUnknownTopics, and not create topic to wait for next retry\n2. tempUnknownTopics will be created each retry since we count the tempUnknownTopics as part of topicsNotReady\n3. add 2 more tests to total test 3 cases:\n  3.1 shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound\n  3.2 shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess\n  3.3 shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable", "committedDate": "2020-06-27T02:02:24Z", "type": "commit"}, {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00", "url": "https://github.com/apache/kafka/commit/9089b4bb8ddef924e45e19d7806343627f206b00", "message": "KAFKA-10006: fix the log flaw to count the tempUnkonwnTopics as topicsNotReady and add 2 more tests\n\n1. Return the topicsNotReady to makeReady including tempUnknownTopics, and not create topic to wait for next retry\n2. tempUnknownTopics will be created each retry since we count the tempUnknownTopics as part of topicsNotReady\n3. add 2 more tests to total test 3 cases:\n  3.1 shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound\n  3.2 shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess\n  3.3 shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable", "committedDate": "2020-06-27T02:02:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMTk1Mw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447831953", "bodyText": "Better to be name as leaderUnavailableTopics to match the error code.", "author": "abbccdda", "createdAt": "2020-06-30T16:48:18Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -100,13 +100,19 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n \n         while (!topicsNotReady.isEmpty() && remainingRetries >= 0) {\n-            topicsNotReady = validateTopics(topicsNotReady, topics);\n+            final Set<String> tempUnknownTopics = new HashSet<>();", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5NTEyNA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448095124", "bodyText": "Well, this variable naming is actually suggested by @ableegoldman , and I also think the tempUnknownTopics is more descriptive. Is that OK for you?\n#8712 (comment)", "author": "showuon", "createdAt": "2020-07-01T03:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMTk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1NzM4MQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448457381", "bodyText": "Sure, I don't feel strong about reverting the naming once we already got a reason there.", "author": "abbccdda", "createdAt": "2020-07-01T15:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMTk1Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNDM3Mg==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447834372", "bodyText": "Could be simplified as topicManager.makeReady(Collections.singletonMap(leaderNotAvailableTopic, internalTopicConfig));", "author": "abbccdda", "createdAt": "2020-06-30T16:52:07Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMDk5NA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448100994", "bodyText": "good. Thanks.", "author": "showuon", "createdAt": "2020-07-01T03:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNDM3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4b57a606a3834323302b6d3d33ab95e5b88d183b", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\nindex 44d176d522..5e92393417 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n\n@@ -308,33 +309,30 @@ public class InternalTopicManagerTest {\n         final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n         topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n \n-        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(topic)))\n             .andReturn(new MockDescribeTopicsResult(\n-                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+                Collections.singletonMap(topic, topicDescriptionLeaderNotAvailableFuture)))\n             .once();\n         // return empty set for 1st time\n         EasyMock.expect(admin.createTopics(Collections.emptySet()))\n             .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n-\n-        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(topic)))\n             .andReturn(new MockDescribeTopicsResult(\n-                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+                Collections.singletonMap(topic, topicDescriptionUnknownTopicFuture)))\n             .once();\n         EasyMock.expect(admin.createTopics(Collections.singleton(\n-                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+                new NewTopic(topic, Optional.of(1), Optional.of((short) 1))\n             .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n                 Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n                 Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n                 Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n-            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(topic, topicCreationFuture))).once();\n \n         EasyMock.replay(admin);\n \n-        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topic, Collections.emptyMap());\n         internalTopicConfig.setNumberOfPartitions(1);\n-        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n-        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n-        topicManager.makeReady(topicConfigMap);\n+        topicManager.makeReady(Collections.singletonMap(topic, internalTopicConfig));\n \n         EasyMock.verify(admin);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447835891", "bodyText": "This test seems to be overlapping with shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound. I don't think we need both to return LeaderNotAvailable unless they are evaluating different scenarios.", "author": "abbccdda", "createdAt": "2020-06-30T16:54:25Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5OTM1OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448099358", "bodyText": "Yes, they are different scenarios. You can check below diagram for reference. (red and green for different cases)", "author": "showuon", "createdAt": "2020-07-01T03:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MDE5Nw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448460197", "bodyText": "Thanks for explaining! May I know what this software you uses to generate the graph?", "author": "abbccdda", "createdAt": "2020-07-01T15:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4NTIyNA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448685224", "bodyText": "Actually, I drew it by myself on the MS office powerpoint. haha", "author": "showuon", "createdAt": "2020-07-02T00:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "4b57a606a3834323302b6d3d33ab95e5b88d183b", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\nindex 44d176d522..5e92393417 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n\n@@ -308,33 +309,30 @@ public class InternalTopicManagerTest {\n         final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n         topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n \n-        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(topic)))\n             .andReturn(new MockDescribeTopicsResult(\n-                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+                Collections.singletonMap(topic, topicDescriptionLeaderNotAvailableFuture)))\n             .once();\n         // return empty set for 1st time\n         EasyMock.expect(admin.createTopics(Collections.emptySet()))\n             .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n-\n-        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(topic)))\n             .andReturn(new MockDescribeTopicsResult(\n-                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+                Collections.singletonMap(topic, topicDescriptionUnknownTopicFuture)))\n             .once();\n         EasyMock.expect(admin.createTopics(Collections.singleton(\n-                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+                new NewTopic(topic, Optional.of(1), Optional.of((short) 1))\n             .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n                 Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n                 Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n                 Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n-            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(topic, topicCreationFuture))).once();\n \n         EasyMock.replay(admin);\n \n-        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topic, Collections.emptyMap());\n         internalTopicConfig.setNumberOfPartitions(1);\n-        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n-        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n-        topicManager.makeReady(topicConfigMap);\n+        topicManager.makeReady(Collections.singletonMap(topic, internalTopicConfig));\n \n         EasyMock.verify(admin);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjM3Mw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447836373", "bodyText": "nit: if it will return topicDescriptionSuccessFuture, then we should not use leaderNotAvailableTopic", "author": "abbccdda", "createdAt": "2020-06-30T16:55:09Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMzMzMQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448103331", "bodyText": "good. Thanks.", "author": "showuon", "createdAt": "2020-07-01T04:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjM3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4b57a606a3834323302b6d3d33ab95e5b88d183b", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\nindex 44d176d522..5e92393417 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n\n@@ -308,33 +309,30 @@ public class InternalTopicManagerTest {\n         final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n         topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n \n-        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(topic)))\n             .andReturn(new MockDescribeTopicsResult(\n-                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+                Collections.singletonMap(topic, topicDescriptionLeaderNotAvailableFuture)))\n             .once();\n         // return empty set for 1st time\n         EasyMock.expect(admin.createTopics(Collections.emptySet()))\n             .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n-\n-        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(topic)))\n             .andReturn(new MockDescribeTopicsResult(\n-                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+                Collections.singletonMap(topic, topicDescriptionUnknownTopicFuture)))\n             .once();\n         EasyMock.expect(admin.createTopics(Collections.singleton(\n-                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+                new NewTopic(topic, Optional.of(1), Optional.of((short) 1))\n             .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n                 Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n                 Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n                 Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n-            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(topic, topicCreationFuture))).once();\n \n         EasyMock.replay(admin);\n \n-        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topic, Collections.emptyMap());\n         internalTopicConfig.setNumberOfPartitions(1);\n-        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n-        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n-        topicManager.makeReady(topicConfigMap);\n+        topicManager.makeReady(Collections.singletonMap(topic, internalTopicConfig));\n \n         EasyMock.verify(admin);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjg1Nw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447836857", "bodyText": "exception not used.", "author": "abbccdda", "createdAt": "2020-06-30T16:55:49Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionSuccessFuture)))\n+            .once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .times(2);\n+\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+\n+        final StreamsException exception = assertThrows(", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5OTU5OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448099598", "bodyText": "Nice catch!", "author": "showuon", "createdAt": "2020-07-01T03:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjg1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4b57a606a3834323302b6d3d33ab95e5b88d183b", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\nindex 44d176d522..5e92393417 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n\n@@ -308,33 +309,30 @@ public class InternalTopicManagerTest {\n         final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n         topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n \n-        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(topic)))\n             .andReturn(new MockDescribeTopicsResult(\n-                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+                Collections.singletonMap(topic, topicDescriptionLeaderNotAvailableFuture)))\n             .once();\n         // return empty set for 1st time\n         EasyMock.expect(admin.createTopics(Collections.emptySet()))\n             .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n-\n-        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(topic)))\n             .andReturn(new MockDescribeTopicsResult(\n-                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+                Collections.singletonMap(topic, topicDescriptionUnknownTopicFuture)))\n             .once();\n         EasyMock.expect(admin.createTopics(Collections.singleton(\n-                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+                new NewTopic(topic, Optional.of(1), Optional.of((short) 1))\n             .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n                 Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n                 Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n                 Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n-            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(topic, topicCreationFuture))).once();\n \n         EasyMock.replay(admin);\n \n-        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topic, Collections.emptyMap());\n         internalTopicConfig.setNumberOfPartitions(1);\n-        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n-        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n-        topicManager.makeReady(topicConfigMap);\n+        topicManager.makeReady(Collections.singletonMap(topic, internalTopicConfig));\n \n         EasyMock.verify(admin);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzODUyMA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447838520", "bodyText": "nit: we could set a final int for numRetries as:\n            put(StreamsConfig.adminClientPrefix(StreamsConfig.RETRIES_CONFIG), numRetries);\n\n\nand use (numRetries + 1) here to clearly indicate we are trying to go beyond the retry limit.", "author": "abbccdda", "createdAt": "2020-06-30T16:58:24Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionSuccessFuture)))\n+            .once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .times(2);", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMDkzMA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448100930", "bodyText": "good suggestion!", "author": "showuon", "createdAt": "2020-07-01T03:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzODUyMA=="}], "type": "inlineReview", "revised_code": {"commit": "4b57a606a3834323302b6d3d33ab95e5b88d183b", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\nindex 44d176d522..5e92393417 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java\n\n@@ -308,33 +309,30 @@ public class InternalTopicManagerTest {\n         final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n         topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n \n-        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(topic)))\n             .andReturn(new MockDescribeTopicsResult(\n-                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+                Collections.singletonMap(topic, topicDescriptionLeaderNotAvailableFuture)))\n             .once();\n         // return empty set for 1st time\n         EasyMock.expect(admin.createTopics(Collections.emptySet()))\n             .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n-\n-        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(topic)))\n             .andReturn(new MockDescribeTopicsResult(\n-                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+                Collections.singletonMap(topic, topicDescriptionUnknownTopicFuture)))\n             .once();\n         EasyMock.expect(admin.createTopics(Collections.singleton(\n-                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+                new NewTopic(topic, Optional.of(1), Optional.of((short) 1))\n             .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n                 Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n                 Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n                 Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n-            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(topic, topicCreationFuture))).once();\n \n         EasyMock.replay(admin);\n \n-        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topic, Collections.emptyMap());\n         internalTopicConfig.setNumberOfPartitions(1);\n-        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n-        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n-        topicManager.makeReady(topicConfigMap);\n+        topicManager.makeReady(Collections.singletonMap(topic, internalTopicConfig));\n \n         EasyMock.verify(admin);\n     }\n"}}, {"oid": "4b57a606a3834323302b6d3d33ab95e5b88d183b", "url": "https://github.com/apache/kafka/commit/4b57a606a3834323302b6d3d33ab95e5b88d183b", "message": "KAFKA-10006: address reviewer's comments\n\n1. simplifiy code\n2. use the existing topic name in tests, instead of creating a new one\n3. use numRetries to indicate we are trying to go beyond the retry limit", "committedDate": "2020-07-01T04:08:41Z", "type": "commit"}, {"oid": "de9be72f4ccfddd7dc2e2b5b4968f4ecdb1693b0", "url": "https://github.com/apache/kafka/commit/de9be72f4ccfddd7dc2e2b5b4968f4ecdb1693b0", "message": "KAFKA-10006: remove duplicate properties", "committedDate": "2020-07-02T00:32:20Z", "type": "commit"}]}