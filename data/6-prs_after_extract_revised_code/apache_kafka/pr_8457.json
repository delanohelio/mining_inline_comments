{"pr_number": 8457, "pr_title": "KAFKA-9842; Add test case for OffsetsForLeaderEpoch grouping in Fetcher", "pr_createdAt": "2020-04-09T21:01:17Z", "pr_url": "https://github.com/apache/kafka/pull/8457", "timeline": [{"oid": "201a4ec4651149aa0150f622915da4fe760628ab", "url": "https://github.com/apache/kafka/commit/201a4ec4651149aa0150f622915da4fe760628ab", "message": "KAFKA-9842; Add test case for OffsetsForLeaderEpoch grouping in Fetcher", "committedDate": "2020-04-09T20:59:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwMjc3NA==", "url": "https://github.com/apache/kafka/pull/8457#discussion_r407702774", "bodyText": "So here we are checking that the request sent from validateOffsetsIfNeeded only includes the partitions whose leader is the current node? If the match fails do we get a nice junit assertion failure, or some funky mockito stack trace?", "author": "mumrah", "createdAt": "2020-04-13T20:31:04Z", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetcherTest.java", "diffHunk": "@@ -3555,6 +3556,60 @@ public void testSubscriptionPositionUpdatedWithEpoch() {\n         assertOptional(subscriptions.position(tp0).offsetEpoch, value -> assertEquals(value.intValue(), 1));\n     }\n \n+    @Test\n+    public void testOffsetValidationRequestGrouping() {\n+        buildFetcher();\n+        assignFromUser(Utils.mkSet(tp0, tp1, tp2, tp3));\n+\n+        metadata.updateWithCurrentRequestVersion(TestUtils.metadataUpdateWith(\"dummy\", 3,\n+            Collections.emptyMap(), singletonMap(topicName, 4),\n+            tp -> 5), false, 0L);\n+\n+        for (TopicPartition tp : subscriptions.assignedPartitions()) {\n+            Metadata.LeaderAndEpoch leaderAndEpoch = new Metadata.LeaderAndEpoch(\n+                metadata.currentLeader(tp).leader, Optional.of(4));\n+            subscriptions.seekUnvalidated(tp,\n+                new SubscriptionState.FetchPosition(0, Optional.of(4), leaderAndEpoch));\n+        }\n+\n+        Set<TopicPartition> allRequestedPartitions = new HashSet<>();\n+\n+        for (Node node : metadata.fetch().nodes()) {\n+            apiVersions.update(node.idString(), NodeApiVersions.create());\n+\n+            Set<TopicPartition> expectedPartitions = subscriptions.assignedPartitions().stream()\n+                .filter(tp ->\n+                    metadata.currentLeader(tp).leader.equals(Optional.of(node)))\n+                .collect(Collectors.toSet());\n+\n+            assertTrue(expectedPartitions.stream().noneMatch(allRequestedPartitions::contains));\n+            assertTrue(expectedPartitions.size() > 0);\n+            allRequestedPartitions.addAll(expectedPartitions);\n+\n+            Map<TopicPartition, EpochEndOffset> endOffsets = expectedPartitions.stream().collect(Collectors.toMap(\n+                Function.identity(),\n+                tp -> new EpochEndOffset(Errors.NONE, 4, 0)\n+            ));\n+\n+            OffsetsForLeaderEpochResponse response = new OffsetsForLeaderEpochResponse(endOffsets);\n+            client.prepareResponseFrom(new MockClient.RequestMatcher() {\n+                @Override\n+                public boolean matches(AbstractRequest body) {\n+                    OffsetsForLeaderEpochRequest request = (OffsetsForLeaderEpochRequest) body;\n+                    return expectedPartitions.equals(request.epochsByTopicPartition().keySet());", "originalCommit": "201a4ec4651149aa0150f622915da4fe760628ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5MjQ4Ng==", "url": "https://github.com/apache/kafka/pull/8457#discussion_r407792486", "bodyText": "You would get a message like this:\nRequest matcher did not match next-in-line request {replica_id=-1,topics=[{topic=test,partitions=[{partition=2,current_leader_epoch=5,leader_epoch=4}]}]} with prepared response (type=OffsetsForLeaderEpochResponse, , throttleTimeMs=0, epochEndOffsetsByPartition={test-2=EpochEndOffset{error=NONE, leaderEpoch=4, endOffset=0}})\n\nwhich I think is reasonable.", "author": "hachikuji", "createdAt": "2020-04-14T00:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwMjc3NA=="}], "type": "inlineReview", "revised_code": null}]}