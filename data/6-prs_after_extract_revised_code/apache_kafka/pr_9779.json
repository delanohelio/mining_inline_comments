{"pr_number": 9779, "pr_title": "KAFKA-10767: Adding test cases for all, reverseAll and reverseRange for ThreadCache", "pr_createdAt": "2020-12-22T13:15:39Z", "pr_url": "https://github.com/apache/kafka/pull/9779", "timeline": [{"oid": "98b708e45f9a81fe597febf2cba9ca97d3feceaa", "url": "https://github.com/apache/kafka/commit/98b708e45f9a81fe597febf2cba9ca97d3feceaa", "message": "KAFKA-10767: Adding test cases for all, reverseAll and reverseRange for ThreadCache", "committedDate": "2021-02-19T12:31:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njc0MTE5OQ==", "url": "https://github.com/apache/kafka/pull/9779#discussion_r596741199", "bodyText": "nit: Could you please use assertThat(iterator.peekNextKey(), is(the Byte)) here?", "author": "cadonna", "createdAt": "2021-03-18T10:45:31Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java", "diffHunk": "@@ -243,6 +243,16 @@ public void shouldPeekNextKey() {\n         assertEquals(theByte, iterator.peekNextKey());\n     }\n \n+    @Test\n+    public void shouldPeekNextKeyReverseRange() {\n+        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final Bytes theByte = Bytes.wrap(new byte[]{1});\n+        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n+        assertEquals(theByte, iterator.peekNextKey());\n+        assertEquals(theByte, iterator.peekNextKey());", "originalCommit": "98b708e45f9a81fe597febf2cba9ca97d3feceaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzYxNzkzNQ==", "url": "https://github.com/apache/kafka/pull/9779#discussion_r597617935", "bodyText": "done", "author": "vamossagar12", "createdAt": "2021-03-19T11:51:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njc0MTE5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f39cbf17ae2d301c6d8c083b00a52b83b2264774", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java\nindex 1ec67d2842..c449de9d52 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java\n\n@@ -233,11 +237,24 @@ public class ThreadCacheTest {\n         assertArrayEquals(name1Byte.get(), cache.get(namespace2, nameByte).value());\n     }\n \n+    private ThreadCache setupThreadCache(final int first, final int last, final long entrySize, final boolean reverse) {\n+        final ThreadCache cache = new ThreadCache(logContext, entrySize, new MockStreamsMetrics(new Metrics()));\n+        cache.addDirtyEntryFlushListener(namespace, dirty -> { });\n+        int index = first;\n+        while ((!reverse && index < last) || (reverse && index >= last)) {\n+            cache.put(namespace, Bytes.wrap(bytes[index]), dirtyEntry(bytes[index]));\n+            if (!reverse)\n+                index++;\n+            else\n+                index--;\n+        }\n+        return cache;\n+    }\n+\n     @Test\n     public void shouldPeekNextKey() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache cache = setupThreadCache(0, 1, 10000L, false);\n         final Bytes theByte = Bytes.wrap(new byte[]{0});\n-        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, theByte, Bytes.wrap(new byte[]{1}));\n         assertEquals(theByte, iterator.peekNextKey());\n         assertEquals(theByte, iterator.peekNextKey());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njc0MTU5Mg==", "url": "https://github.com/apache/kafka/pull/9779#discussion_r596741592", "bodyText": "nit: see my comment about assertThat() above.", "author": "cadonna", "createdAt": "2021-03-18T10:46:05Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java", "diffHunk": "@@ -252,20 +262,43 @@ public void shouldGetSameKeyAsPeekNext() {\n         assertEquals(iterator.peekNextKey(), iterator.next().key);\n     }\n \n+    @Test\n+    public void shouldGetSameKeyAsPeekNextReverseRange() {\n+        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final Bytes theByte = Bytes.wrap(new byte[]{1});\n+        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n+        assertEquals(iterator.peekNextKey(), iterator.next().key);", "originalCommit": "98b708e45f9a81fe597febf2cba9ca97d3feceaa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f39cbf17ae2d301c6d8c083b00a52b83b2264774", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java\nindex 1ec67d2842..c449de9d52 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java\n\n@@ -245,67 +262,63 @@ public class ThreadCacheTest {\n \n     @Test\n     public void shouldPeekNextKeyReverseRange() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache cache = setupThreadCache(1, 1, 10000L, true);\n         final Bytes theByte = Bytes.wrap(new byte[]{1});\n-        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n-        assertEquals(theByte, iterator.peekNextKey());\n-        assertEquals(theByte, iterator.peekNextKey());\n+        assertThat(iterator.peekNextKey(), is(theByte));\n+        assertThat(iterator.peekNextKey(), is(theByte));\n     }\n \n     @Test\n     public void shouldGetSameKeyAsPeekNext() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache cache = setupThreadCache(0, 1, 10000L, false);\n         final Bytes theByte = Bytes.wrap(new byte[]{0});\n-        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, theByte, Bytes.wrap(new byte[]{1}));\n-        assertEquals(iterator.peekNextKey(), iterator.next().key);\n+        assertThat(iterator.peekNextKey(), is(iterator.next().key));\n     }\n \n     @Test\n     public void shouldGetSameKeyAsPeekNextReverseRange() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache cache = setupThreadCache(1, 1, 10000L, true);\n         final Bytes theByte = Bytes.wrap(new byte[]{1});\n-        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n-        assertEquals(iterator.peekNextKey(), iterator.next().key);\n+        assertThat(iterator.peekNextKey(), is(iterator.next().key));\n     }\n \n-    @Test\n-    public void shouldThrowIfNoPeekNextKey() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n-        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n+    private void shouldThrowIfNoPeekNextKey(final Supplier<ThreadCache.MemoryLRUCacheBytesIterator> methodUnderTest) {\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = methodUnderTest.get();\n         assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n     }\n \n+    @Test\n+    public void shouldThrowIfNoPeekNextKeyRange() {\n+        final ThreadCache cache = setupThreadCache(0, 0, 10000L, false);\n+        shouldThrowIfNoPeekNextKey(() -> cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})));\n+    }\n+\n     @Test\n     public void shouldThrowIfNoPeekNextKeyReverseRange() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n-        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n-        assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n+        final ThreadCache cache = setupThreadCache(-1, 0, 10000L, true);\n+        shouldThrowIfNoPeekNextKey(() -> cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})));\n     }\n \n     @Test\n     public void shouldReturnFalseIfNoNextKey() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache cache = setupThreadCache(0, 0, 10000L, false);\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n         assertFalse(iterator.hasNext());\n     }\n \n     @Test\n     public void shouldReturnFalseIfNoNextKeyReverseRange() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache cache = setupThreadCache(-1, 0, 10000L, true);\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n         assertFalse(iterator.hasNext());\n     }\n \n     @Test\n     public void shouldPeekAndIterateOverRange() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n-        final byte[][] bytes = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}};\n-        for (final byte[] aByte : bytes) {\n-            cache.put(namespace, Bytes.wrap(aByte), dirtyEntry(aByte));\n-        }\n+        final ThreadCache cache = setupThreadCache(0, 10, 10000L, false);\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{1}), Bytes.wrap(new byte[]{4}));\n         int bytesIndex = 1;\n         while (iterator.hasNext()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njc1NTcxNw==", "url": "https://github.com/apache/kafka/pull/9779#discussion_r596755717", "bodyText": "nit: could you try to deduplicate code here and in the other unit tests? Here for example, you could have one method like this:\n    private void shouldThrowIfNoPeekNextKey(final Supplier<MemoryLRUCacheBytesIterator> methodUnderTest) {\n        final ThreadCache.MemoryLRUCacheBytesIterator iterator = methodUnderTest.get();\n        assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n    }\n\nand then two public tests\n    @Test\n    public void shouldThrowIfNoPeekNextKeyRange() {\n        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n        shouldThrowIfNoPeekNextKey(() -> cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})));\n    }\n\n    @Test\n    public void shouldThrowIfNoPeekNextKeyReverseRange() {\n        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n        shouldThrowIfNoPeekNextKey(() -> cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})));\n    }\n\nAdmittedly, in this specific case, we would not win much but for other unit tests in this test class it may be worth. Try and then decide if it is worth or not.", "author": "cadonna", "createdAt": "2021-03-18T11:06:46Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java", "diffHunk": "@@ -252,20 +262,43 @@ public void shouldGetSameKeyAsPeekNext() {\n         assertEquals(iterator.peekNextKey(), iterator.next().key);\n     }\n \n+    @Test\n+    public void shouldGetSameKeyAsPeekNextReverseRange() {\n+        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final Bytes theByte = Bytes.wrap(new byte[]{1});\n+        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n+        assertEquals(iterator.peekNextKey(), iterator.next().key);\n+    }\n+\n     @Test\n     public void shouldThrowIfNoPeekNextKey() {\n         final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n         assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n     }\n \n+    @Test\n+    public void shouldThrowIfNoPeekNextKeyReverseRange() {\n+        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n+        assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n+    }\n+", "originalCommit": "98b708e45f9a81fe597febf2cba9ca97d3feceaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzYxODU2Ng==", "url": "https://github.com/apache/kafka/pull/9779#discussion_r597618566", "bodyText": "Done. This made sense. I have also added the logic to generate the ThreadCache in a separate method(setupThreadCache) . That reduced lot of duplicate code from a lot of methods", "author": "vamossagar12", "createdAt": "2021-03-19T11:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njc1NTcxNw=="}], "type": "inlineReview", "revised_code": {"commit": "f39cbf17ae2d301c6d8c083b00a52b83b2264774", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java\nindex 1ec67d2842..c449de9d52 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java\n\n@@ -245,67 +262,63 @@ public class ThreadCacheTest {\n \n     @Test\n     public void shouldPeekNextKeyReverseRange() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache cache = setupThreadCache(1, 1, 10000L, true);\n         final Bytes theByte = Bytes.wrap(new byte[]{1});\n-        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n-        assertEquals(theByte, iterator.peekNextKey());\n-        assertEquals(theByte, iterator.peekNextKey());\n+        assertThat(iterator.peekNextKey(), is(theByte));\n+        assertThat(iterator.peekNextKey(), is(theByte));\n     }\n \n     @Test\n     public void shouldGetSameKeyAsPeekNext() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache cache = setupThreadCache(0, 1, 10000L, false);\n         final Bytes theByte = Bytes.wrap(new byte[]{0});\n-        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, theByte, Bytes.wrap(new byte[]{1}));\n-        assertEquals(iterator.peekNextKey(), iterator.next().key);\n+        assertThat(iterator.peekNextKey(), is(iterator.next().key));\n     }\n \n     @Test\n     public void shouldGetSameKeyAsPeekNextReverseRange() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache cache = setupThreadCache(1, 1, 10000L, true);\n         final Bytes theByte = Bytes.wrap(new byte[]{1});\n-        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n-        assertEquals(iterator.peekNextKey(), iterator.next().key);\n+        assertThat(iterator.peekNextKey(), is(iterator.next().key));\n     }\n \n-    @Test\n-    public void shouldThrowIfNoPeekNextKey() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n-        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n+    private void shouldThrowIfNoPeekNextKey(final Supplier<ThreadCache.MemoryLRUCacheBytesIterator> methodUnderTest) {\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = methodUnderTest.get();\n         assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n     }\n \n+    @Test\n+    public void shouldThrowIfNoPeekNextKeyRange() {\n+        final ThreadCache cache = setupThreadCache(0, 0, 10000L, false);\n+        shouldThrowIfNoPeekNextKey(() -> cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})));\n+    }\n+\n     @Test\n     public void shouldThrowIfNoPeekNextKeyReverseRange() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n-        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n-        assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n+        final ThreadCache cache = setupThreadCache(-1, 0, 10000L, true);\n+        shouldThrowIfNoPeekNextKey(() -> cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})));\n     }\n \n     @Test\n     public void shouldReturnFalseIfNoNextKey() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache cache = setupThreadCache(0, 0, 10000L, false);\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n         assertFalse(iterator.hasNext());\n     }\n \n     @Test\n     public void shouldReturnFalseIfNoNextKeyReverseRange() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache cache = setupThreadCache(-1, 0, 10000L, true);\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n         assertFalse(iterator.hasNext());\n     }\n \n     @Test\n     public void shouldPeekAndIterateOverRange() {\n-        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n-        final byte[][] bytes = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}};\n-        for (final byte[] aByte : bytes) {\n-            cache.put(namespace, Bytes.wrap(aByte), dirtyEntry(aByte));\n-        }\n+        final ThreadCache cache = setupThreadCache(0, 10, 10000L, false);\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{1}), Bytes.wrap(new byte[]{4}));\n         int bytesIndex = 1;\n         while (iterator.hasNext()) {\n"}}, {"oid": "f39cbf17ae2d301c6d8c083b00a52b83b2264774", "url": "https://github.com/apache/kafka/commit/f39cbf17ae2d301c6d8c083b00a52b83b2264774", "message": "KAFKA-10767: Adding test cases for all, reverseAll and reverseRange for ThreadCache", "committedDate": "2021-03-19T11:51:29Z", "type": "commit"}, {"oid": "f39cbf17ae2d301c6d8c083b00a52b83b2264774", "url": "https://github.com/apache/kafka/commit/f39cbf17ae2d301c6d8c083b00a52b83b2264774", "message": "KAFKA-10767: Adding test cases for all, reverseAll and reverseRange for ThreadCache", "committedDate": "2021-03-19T11:51:29Z", "type": "forcePushed"}]}