{"pr_number": 8233, "pr_title": "KAFKA-9668: Iterating over KafkaStreams.getAllMetadata() results in ConcurrentModificationException", "pr_createdAt": "2020-03-05T22:24:58Z", "pr_url": "https://github.com/apache/kafka/pull/8233", "timeline": [{"oid": "51c76fedd9da8c27b667075d334dc8da9bed6489", "url": "https://github.com/apache/kafka/commit/51c76fedd9da8c27b667075d334dc8da9bed6489", "message": "KAFKA-9668: Iterating over KafkaStreams.getAllMetadata() results in ConcurrentModificationException\n\n`KafkaStreams.getAllMetadata()` returns `StreamsMetadataState.getAllMetadata()`. All the latter methods is `synchronized` it returns a reference to internal mutable state.  Not only does this break encapsulation, but it means any thread iterating over the returned collection when the metadata gets rebuilt will encounter a `ConcurrentModificationException`.\n\nThis change:\n * switches from clearing and rebuild `allMetadata` when `onChange` is called to building a new list and swapping this in. This is thread safe and has the benefit that the returned list is not empty during a rebuild: you either get the old or the new list.\n * removes synchronisation from `getAllMetadata` and `getLocalMetadata`. These are returning member variables. Synchronisation adds nothing.\n * changes `getAllMetadata` to wrap its return value in an unmodifiable wrapper to avoid breaking encapsulation.\n * changes the getters in `StreamsMetadata` to wrap their return values in unmodifiable wrapper to avoid breaking encapsulation.", "committedDate": "2020-03-05T22:22:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxMDc5NA==", "url": "https://github.com/apache/kafka/pull/8233#discussion_r388610794", "bodyText": "Why move the reset into the condition? if the passed in values are empty we should still set it to empty because the previous map may be out-dated right?", "author": "guozhangwang", "createdAt": "2020-03-05T22:45:42Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsMetadataState.java", "diffHunk": "@@ -316,10 +315,12 @@ private boolean hasPartitionsForAnyTopics(final List<String> topicNames, final S\n \n     private void rebuildMetadata(final Map<HostInfo, Set<TopicPartition>> activePartitionHostMap,\n                                  final Map<HostInfo, Set<TopicPartition>> standbyPartitionHostMap) {\n-        allMetadata.clear();\n         if (activePartitionHostMap.isEmpty() && standbyPartitionHostMap.isEmpty()) {\n+            allMetadata = Collections.emptyList();", "originalCommit": "51c76fedd9da8c27b667075d334dc8da9bed6489", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNjEwMA==", "url": "https://github.com/apache/kafka/pull/8233#discussion_r388626100", "bodyText": "Well, with this change you're always going to get either the old or new metadata from getAllMetadata.  Where as if I clear the list at the start of this method, then getAllMetadata can return empty.\nQuestion is: which is preferable?  I figured there's a strong possibility that at least some of the old metadata may still be correct - so why ditch it?", "author": "big-andy-coates", "createdAt": "2020-03-05T23:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxMDc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyODI2OQ==", "url": "https://github.com/apache/kafka/pull/8233#discussion_r388628269", "bodyText": "By returning empty we're forcing callers to handle this case. But if we return stale data, then it's no different to if they had called getAllMetadata a few ns earlier.", "author": "big-andy-coates", "createdAt": "2020-03-05T23:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxMDc5NA=="}], "type": "inlineReview", "revised_code": null}]}