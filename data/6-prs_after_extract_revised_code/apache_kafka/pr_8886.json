{"pr_number": 8886, "pr_title": "KAFKA-9891: fix corrupted StandbyTask state", "pr_createdAt": "2020-06-17T04:23:41Z", "pr_url": "https://github.com/apache/kafka/pull/8886", "timeline": [{"oid": "380e4fce3feca97d5144e5a5d443a2ea860a1488", "url": "https://github.com/apache/kafka/commit/380e4fce3feca97d5144e5a5d443a2ea860a1488", "message": "KAFKA-9891: fix corrupted StandbyTask state\n\nA StandbyTask must wipe its local state if EOS is enabled and no local\ncheckpoint file is found.", "committedDate": "2020-06-17T04:14:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzMzYyMg==", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441633622", "bodyText": "I'm sure this works, but something seems odd about listing checkpointed partitions to find ones that are not checkpointed. Maybe we need to encapsulate this search, or provide a more semantically appropriate \"list all changelog partitions\" method?", "author": "vvcephei", "createdAt": "2020-06-17T15:26:14Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -85,6 +85,21 @@ public void initializeMetadata() {}\n     public boolean initializeStateStores() {\n         log.trace(\"Initializing state stores\");\n         registerStateStores();\n+\n+        if (eosEnabled) {\n+            final Set<TopicPartition> partitionsToReinitialize = new HashSet<>();\n+            for (final TopicPartition partition : stateMgr.checkpointed().keySet()) {", "originalCommit": "380e4fce3feca97d5144e5a5d443a2ea860a1488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMzY2MQ==", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441813661", "bodyText": "Yeah, the fix is mainly for illustrating purpose atm. The problem is really, that the checkpoint file get's deleted for EOS before we reach this point in the code and thus we need to \"hack\" around it -- it would be cleaner if we could just check if a checkpoint exists of not...", "author": "mjsax", "createdAt": "2020-06-17T20:28:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzMzYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NjE1OQ==", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441876159", "bodyText": "I think checkpointed is just misleadingly named -- it's really more like checkpoint-able offsets IIUC", "author": "ableegoldman", "createdAt": "2020-06-17T22:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzMzYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxNzQ4MQ==", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441917481", "bodyText": "Not sure how to proceed? The naming issue might be a general problem, that we might want to fix in trunk/2.6? Is is worth to fix in 2.5?", "author": "mjsax", "createdAt": "2020-06-18T01:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzMzYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyMDA1Ng==", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441920056", "bodyText": "I'm fine with leaving the poorly-named method as is, since it's fixed in trunk. But maybe you could leave a comment explaining why this seemingly contradictory set of logic actually makes sense (it took me more than a second to understand this at least)", "author": "ableegoldman", "createdAt": "2020-06-18T01:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzMzYyMg=="}], "type": "inlineReview", "revised_code": {"commit": "67974712873ebf4f20705043d3221a9545bb47be", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java\nindex 2784543d33..d9378eb5ae 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java\n\n@@ -88,6 +88,7 @@ public class StandbyTask extends AbstractTask {\n \n         if (eosEnabled) {\n             final Set<TopicPartition> partitionsToReinitialize = new HashSet<>();\n+            // the state manager actually returns the next checkpoint to be written\n             for (final TopicPartition partition : stateMgr.checkpointed().keySet()) {\n                 if (!stateMgr.hadCheckpoint(partition)) {\n                     partitionsToReinitialize.add(partition);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzNTM5OQ==", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441635399", "bodyText": "should this be parameterized for both flavors of eos?", "author": "vvcephei", "createdAt": "2020-06-17T15:28:45Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Transformer;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.Stores;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.apache.kafka.test.TestUtils.waitForCondition;\n+\n+/**\n+ * An integration test to verify the conversion of a dirty-closed EOS\n+ * task towards a standby task is safe across restarts of the application.\n+ */\n+public class StandbyTaskEOSIntegrationTest {", "originalCommit": "380e4fce3feca97d5144e5a5d443a2ea860a1488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxNDE5NQ==", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441814195", "bodyText": "This PR is for 2.5, not trunk. I have another branch for trunk and there both cases are covered.", "author": "mjsax", "createdAt": "2020-06-17T20:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzNTM5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "555975b4992607c5a8ff1608fe4ce4ab2d39045e", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java b/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java\nindex ed8a73e54d..bc1c82f490 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java\n\n@@ -29,7 +29,6 @@ import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n import org.apache.kafka.streams.kstream.Transformer;\n import org.apache.kafka.streams.processor.ProcessorContext;\n-import org.apache.kafka.streams.state.KeyValueIterator;\n import org.apache.kafka.streams.state.KeyValueStore;\n import org.apache.kafka.streams.state.QueryableStoreTypes;\n import org.apache.kafka.streams.state.Stores;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzODQyOA==", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441638428", "bodyText": "I have always been, and continue to be, mystified about why we're 100% a-ok with having corrupted state stores in ALOS mode. I understand that there are some kinds of corruption that are unavoidable without some extra work in the stores, but this check is just explicitly ignoring detectable corruption, which seems a bit extreme. Can we remove this conditional? The rest of these checks seem to apply equally well under all execution semantic modes.", "author": "vvcephei", "createdAt": "2020-06-17T15:33:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -85,6 +85,21 @@ public void initializeMetadata() {}\n     public boolean initializeStateStores() {\n         log.trace(\"Initializing state stores\");\n         registerStateStores();\n+\n+        if (eosEnabled) {", "originalCommit": "380e4fce3feca97d5144e5a5d443a2ea860a1488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMjYxNw==", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441812617", "bodyText": "That is the tradeoff people buy in when using at-least-once. As long as state store recovery is expensive, it's not worth to change it IMHO. Also note, even if we wipe out the store for non-eos, the corrupted record might have been written into the changelog topic already, and thus, we would recover the corrupted state again, not gaining anything.", "author": "mjsax", "createdAt": "2020-06-17T20:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzODQyOA=="}], "type": "inlineReview", "revised_code": {"commit": "67974712873ebf4f20705043d3221a9545bb47be", "chunk": "diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java\nindex 2784543d33..d9378eb5ae 100644\n--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java\n+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java\n\n@@ -88,6 +88,7 @@ public class StandbyTask extends AbstractTask {\n \n         if (eosEnabled) {\n             final Set<TopicPartition> partitionsToReinitialize = new HashSet<>();\n+            // the state manager actually returns the next checkpoint to be written\n             for (final TopicPartition partition : stateMgr.checkpointed().keySet()) {\n                 if (!stateMgr.hadCheckpoint(partition)) {\n                     partitionsToReinitialize.add(partition);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDg2OA==", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441874868", "bodyText": "Could we put key 0 and key 1 as variables?", "author": "abbccdda", "createdAt": "2020-06-17T22:48:10Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Transformer;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.Stores;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.apache.kafka.test.TestUtils.waitForCondition;\n+\n+/**\n+ * An integration test to verify the conversion of a dirty-closed EOS\n+ * task towards a standby task is safe across restarts of the application.\n+ */\n+public class StandbyTaskEOSIntegrationTest {\n+\n+    private final AtomicBoolean skip = new AtomicBoolean(false);\n+\n+    private String appId;\n+    private String inputTopic;\n+    private String storeName;\n+    private String outputTopic;\n+\n+    @ClassRule\n+    public static final EmbeddedKafkaCluster CLUSTER = new EmbeddedKafkaCluster(3);\n+\n+    @Before\n+    public void createTopics() throws Exception {\n+        appId = \"standbyTest\";\n+        inputTopic = \"testInputTopic\";\n+        outputTopic = \"testOutputTopic\";\n+        storeName = \"dedupStore\";\n+        CLUSTER.deleteTopicsAndWait(inputTopic, outputTopic);\n+        CLUSTER.createTopic(inputTopic, 1, 3);\n+        CLUSTER.createTopic(outputTopic, 1, 3);\n+    }\n+\n+    @Test\n+    public void shouldWipeOutStandbyStateDirectoryIfCheckpointIsMissing() throws Exception {\n+        final String base = TestUtils.tempDirectory(appId).getPath();\n+\n+        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+            inputTopic,\n+            Collections.singletonList(\n+                new KeyValue<>(0, 0)\n+            ),\n+            TestUtils.producerConfig(\n+                CLUSTER.bootstrapServers(),\n+                IntegerSerializer.class,\n+                IntegerSerializer.class,\n+                new Properties()\n+            ),\n+            10L\n+        );\n+\n+        try (\n+            final KafkaStreams streamInstanceOne = buildWithDeduplicationTopology(base + \"-1\");\n+            final KafkaStreams streamInstanceTwo = buildWithDeduplicationTopology(base + \"-2\");\n+            final KafkaStreams streamInstanceOneRecovery = buildWithDeduplicationTopology(base + \"-1\")\n+        ) {\n+            // start first instance and wait for processing\n+            startApplicationAndWaitUntilRunning(Collections.singletonList(streamInstanceOne), Duration.ofSeconds(30));\n+            IntegrationTestUtils.waitUntilMinRecordsReceived(\n+                TestUtils.consumerConfig(\n+                    CLUSTER.bootstrapServers(),\n+                    IntegerDeserializer.class,\n+                    IntegerDeserializer.class\n+                ),\n+                outputTopic,\n+                1\n+            );\n+\n+            // start second instance and wait for standby replication\n+            startApplicationAndWaitUntilRunning(Collections.singletonList(streamInstanceTwo), Duration.ofSeconds(30));\n+            waitForCondition(\n+                () -> streamInstanceTwo.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    ).enableStaleStores()\n+                ).get(0) != null,", "originalCommit": "380e4fce3feca97d5144e5a5d443a2ea860a1488", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "555975b4992607c5a8ff1608fe4ce4ab2d39045e", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java b/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java\nindex ed8a73e54d..bc1c82f490 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java\n\n@@ -29,7 +29,6 @@ import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n import org.apache.kafka.streams.kstream.Transformer;\n import org.apache.kafka.streams.processor.ProcessorContext;\n-import org.apache.kafka.streams.state.KeyValueIterator;\n import org.apache.kafka.streams.state.KeyValueStore;\n import org.apache.kafka.streams.state.QueryableStoreTypes;\n import org.apache.kafka.streams.state.Stores;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMDY1OA==", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441900658", "bodyText": "Remove the debug statements", "author": "abbccdda", "createdAt": "2020-06-18T00:16:20Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Transformer;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.Stores;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.apache.kafka.test.TestUtils.waitForCondition;\n+\n+/**\n+ * An integration test to verify the conversion of a dirty-closed EOS\n+ * task towards a standby task is safe across restarts of the application.\n+ */\n+public class StandbyTaskEOSIntegrationTest {\n+\n+    private final AtomicBoolean skip = new AtomicBoolean(false);\n+\n+    private String appId;\n+    private String inputTopic;\n+    private String storeName;\n+    private String outputTopic;\n+\n+    @ClassRule\n+    public static final EmbeddedKafkaCluster CLUSTER = new EmbeddedKafkaCluster(3);\n+\n+    @Before\n+    public void createTopics() throws Exception {\n+        appId = \"standbyTest\";\n+        inputTopic = \"testInputTopic\";\n+        outputTopic = \"testOutputTopic\";\n+        storeName = \"dedupStore\";\n+        CLUSTER.deleteTopicsAndWait(inputTopic, outputTopic);\n+        CLUSTER.createTopic(inputTopic, 1, 3);\n+        CLUSTER.createTopic(outputTopic, 1, 3);\n+    }\n+\n+    @Test\n+    public void shouldWipeOutStandbyStateDirectoryIfCheckpointIsMissing() throws Exception {\n+        final String base = TestUtils.tempDirectory(appId).getPath();\n+\n+        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+            inputTopic,\n+            Collections.singletonList(\n+                new KeyValue<>(0, 0)\n+            ),\n+            TestUtils.producerConfig(\n+                CLUSTER.bootstrapServers(),\n+                IntegerSerializer.class,\n+                IntegerSerializer.class,\n+                new Properties()\n+            ),\n+            10L\n+        );\n+\n+        try (\n+            final KafkaStreams streamInstanceOne = buildWithDeduplicationTopology(base + \"-1\");\n+            final KafkaStreams streamInstanceTwo = buildWithDeduplicationTopology(base + \"-2\");\n+            final KafkaStreams streamInstanceOneRecovery = buildWithDeduplicationTopology(base + \"-1\")\n+        ) {\n+            // start first instance and wait for processing\n+            startApplicationAndWaitUntilRunning(Collections.singletonList(streamInstanceOne), Duration.ofSeconds(30));\n+            IntegrationTestUtils.waitUntilMinRecordsReceived(\n+                TestUtils.consumerConfig(\n+                    CLUSTER.bootstrapServers(),\n+                    IntegerDeserializer.class,\n+                    IntegerDeserializer.class\n+                ),\n+                outputTopic,\n+                1\n+            );\n+\n+            // start second instance and wait for standby replication\n+            startApplicationAndWaitUntilRunning(Collections.singletonList(streamInstanceTwo), Duration.ofSeconds(30));\n+            waitForCondition(\n+                () -> streamInstanceTwo.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    ).enableStaleStores()\n+                ).get(0) != null,\n+                120_000L, // use increased timeout to encounter for rebalancing time\n+                \"Could not get key from standby store\"\n+            );\n+            // sanity check that first instance is still active\n+            waitForCondition(\n+                () -> streamInstanceOne.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    )\n+                ).get(0) != null,\n+                \"Could not get key from main store\"\n+            );\n+\n+            // inject poison pill and wait for crash of first instance and recovery on second instance\n+            IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+                inputTopic,\n+                Collections.singletonList(\n+                    new KeyValue<>(1, 0)\n+                ),\n+                TestUtils.producerConfig(\n+                    CLUSTER.bootstrapServers(),\n+                    IntegerSerializer.class,\n+                    IntegerSerializer.class,\n+                    new Properties()\n+                ),\n+                10L\n+            );\n+            waitForCondition(\n+                () -> streamInstanceOne.state() == KafkaStreams.State.ERROR,\n+                \"Stream instance 1 did not go into error state\"\n+            );\n+            streamInstanceOne.close();\n+\n+            waitForCondition(\n+                () -> streamInstanceTwo.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.keyValueStore()\n+                    )\n+                ).get(0) != null,\n+                120_000L, // use increased timeout to encounter for rebalancing time\n+                \"Could not get key from recovered main store\"\n+            );\n+\n+            // \"restart\" first client and wait for standby recovery\n+            startApplicationAndWaitUntilRunning(\n+                Collections.singletonList(streamInstanceOneRecovery),\n+                Duration.ofSeconds(30)\n+            );\n+            waitForCondition(\n+                () -> streamInstanceOneRecovery.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    ).enableStaleStores()\n+                ).get(0) != null,\n+                \"Could not get key from recovered standby store\"\n+            );\n+            // sanity check that second instance is still active\n+            waitForCondition(\n+                () -> streamInstanceTwo.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.keyValueStore()\n+                    )\n+                ).get(0) != null,\n+                \"Could not get key from recovered main store\"\n+            );\n+\n+            streamInstanceTwo.close();\n+            waitForCondition(\n+                () -> streamInstanceOneRecovery.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    )\n+                ).get(0) != null,\n+                120_000L, // use increased timeout to encounter for rebalancing time\n+                \"Could not get key from recovered main store\"\n+            );\n+\n+            // re-inject poison pill and wait for crash of first instance\n+            skip.set(false);\n+            IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+                inputTopic,\n+                Collections.singletonList(\n+                    new KeyValue<>(1, 0)\n+                ),\n+                TestUtils.producerConfig(\n+                    CLUSTER.bootstrapServers(),\n+                    IntegerSerializer.class,\n+                    IntegerSerializer.class,\n+                    new Properties()\n+                ),\n+                10L\n+            );\n+            waitForCondition(\n+                () -> streamInstanceOneRecovery.state() == KafkaStreams.State.ERROR,\n+                \"Stream instance 1 did not go into error state\"\n+            );\n+        }\n+    }\n+\n+    private KafkaStreams buildWithDeduplicationTopology(final String stateDirPath) {\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        builder.addStateStore(Stores.keyValueStoreBuilder(\n+            Stores.persistentKeyValueStore(storeName),\n+            Serdes.Integer(),\n+            Serdes.Integer())\n+        );\n+        builder.<Integer, Integer>stream(inputTopic)\n+            .transform(\n+                () -> new Transformer<Integer, Integer, KeyValue<Integer, Integer>>() {\n+                    private KeyValueStore<Integer, Integer> store;\n+\n+                    @SuppressWarnings(\"unchecked\")\n+                    @Override\n+                    public void init(final ProcessorContext context) {\n+                        store = (KeyValueStore<Integer, Integer>) context.getStateStore(storeName);\n+\n+                        final KeyValueIterator<Integer, Integer> it = store.all();\n+                        System.err.println(\"mjsax: store content begin\");\n+                        while (it.hasNext()) {\n+                            final KeyValue<Integer, Integer> next = it.next();\n+                            System.err.println(\"mjsax: key/value -> \" + next.key + \"/\" + next.value);", "originalCommit": "380e4fce3feca97d5144e5a5d443a2ea860a1488", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "555975b4992607c5a8ff1608fe4ce4ab2d39045e", "chunk": "diff --git a/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java b/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java\nindex ed8a73e54d..bc1c82f490 100644\n--- a/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java\n+++ b/streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java\n\n@@ -29,7 +29,6 @@ import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n import org.apache.kafka.streams.kstream.Transformer;\n import org.apache.kafka.streams.processor.ProcessorContext;\n-import org.apache.kafka.streams.state.KeyValueIterator;\n import org.apache.kafka.streams.state.KeyValueStore;\n import org.apache.kafka.streams.state.QueryableStoreTypes;\n import org.apache.kafka.streams.state.Stores;\n"}}, {"oid": "555975b4992607c5a8ff1608fe4ce4ab2d39045e", "url": "https://github.com/apache/kafka/commit/555975b4992607c5a8ff1608fe4ce4ab2d39045e", "message": "Cleanup", "committedDate": "2020-06-18T01:29:16Z", "type": "commit"}, {"oid": "67974712873ebf4f20705043d3221a9545bb47be", "url": "https://github.com/apache/kafka/commit/67974712873ebf4f20705043d3221a9545bb47be", "message": "Github comments", "committedDate": "2020-06-18T01:52:44Z", "type": "commit"}]}