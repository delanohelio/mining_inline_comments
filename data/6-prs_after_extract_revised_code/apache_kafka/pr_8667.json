{"pr_number": 8667, "pr_title": "KAFKA-9994: Handle task migrated inside corruption path", "pr_createdAt": "2020-05-14T17:44:39Z", "pr_url": "https://github.com/apache/kafka/pull/8667", "timeline": [{"oid": "d2f26677f150951d9a6ae3d09ed6a058b936c050", "url": "https://github.com/apache/kafka/commit/d2f26677f150951d9a6ae3d09ed6a058b936c050", "message": "Handle task migrated inside corruption path", "committedDate": "2020-05-14T17:58:05Z", "type": "commit"}, {"oid": "d2f26677f150951d9a6ae3d09ed6a058b936c050", "url": "https://github.com/apache/kafka/commit/d2f26677f150951d9a6ae3d09ed6a058b936c050", "message": "Handle task migrated inside corruption path", "committedDate": "2020-05-14T17:58:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM0ODE0NQ==", "url": "https://github.com/apache/kafka/pull/8667#discussion_r425348145", "bodyText": "Should we also handle the corrupted tasks here (before this line), so that they can be already cleaned up before the next round? Or, alternatively, should we move taskManager.handleCorruption(e.corruptedTaskWithChangelogs()); to before the attempted commit (it looks like it could be outside the try block as well).", "author": "vvcephei", "createdAt": "2020-05-14T18:31:30Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -555,28 +555,35 @@ void runLoop() {\n             } catch (final TaskCorruptedException e) {\n                 log.warn(\"Detected the states of tasks \" + e.corruptedTaskWithChangelogs() + \" are corrupted. \" +\n                              \"Will close the task as dirty and re-create and bootstrap from scratch.\", e);\n-\n-                taskManager.commit(\n-                    taskManager.tasks()\n-                        .values()\n-                        .stream()\n-                        .filter(t -> t.state() == Task.State.RUNNING || t.state() == Task.State.RESTORING)\n-                        .filter(t -> !e.corruptedTaskWithChangelogs().containsKey(t.id()))\n-                        .collect(Collectors.toSet())\n-                );\n-                taskManager.handleCorruption(e.corruptedTaskWithChangelogs());\n+                try {\n+                    taskManager.commit(\n+                        taskManager.tasks()\n+                            .values()\n+                            .stream()\n+                            .filter(t -> t.state() == Task.State.RUNNING || t.state() == Task.State.RESTORING)\n+                            .filter(t -> !e.corruptedTaskWithChangelogs().containsKey(t.id()))\n+                            .collect(Collectors.toSet())\n+                    );\n+                    taskManager.handleCorruption(e.corruptedTaskWithChangelogs());\n+                } catch (final TaskMigratedException taskMigrated) {\n+                    handleTaskMigrated(taskMigrated);", "originalCommit": "d2f26677f150951d9a6ae3d09ed6a058b936c050", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM2NjE1MA==", "url": "https://github.com/apache/kafka/pull/8667#discussion_r425366150", "bodyText": "Good point, I was also thinking whether we should do the corruption logic no matter what. But if we hit a TaskMigrated, the taskManager.handleLostAll will wipe out all the task states dirty, which seems like a super-set of jobs for handleCorruption. If we failed the commit, maybe we should just skip the corruption logic?", "author": "abbccdda", "createdAt": "2020-05-14T19:03:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM0ODE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4NjI5Ng==", "url": "https://github.com/apache/kafka/pull/8667#discussion_r425386296", "bodyText": "Sounds legit. Thanks.", "author": "vvcephei", "createdAt": "2020-05-14T19:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM0ODE0NQ=="}], "type": "inlineReview", "revised_code": null}]}