{"pr_number": 9671, "pr_title": "KAFKA-10793: move handling of FindCoordinatorFuture to fix race condition", "pr_createdAt": "2020-12-02T02:43:04Z", "pr_url": "https://github.com/apache/kafka/pull/9671", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3NzY3Ng==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r534377676", "bodyText": "nit: I think it's better to just print the e.message in a single line.", "author": "guozhangwang", "createdAt": "2020-12-02T18:10:30Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -853,7 +844,7 @@ public void onSuccess(ClientResponse resp, RequestFuture<Void> future) {\n \n         @Override\n         public void onFailure(RuntimeException e, RequestFuture<Void> future) {\n-            clearFindCoordinatorFuture();\n+            log.debug(\"FindCoordinator request failed\", e);", "originalCommit": "baa2d0fcaa56868288ee6488f7e7736884152826", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4NjQ4Ng==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r537986486", "bodyText": "You mean like\nlog.debug(\"FindCoordinator request failed due to {}\", e.getMessage());\n\n?", "author": "ableegoldman", "createdAt": "2020-12-08T02:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3NzY3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NzA5OA==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r539567098", "bodyText": "if you just have\nlog.debug(\"FindCoordinator request failed due to {}\", e)\n\nThen e.toString would be called which would usually be e.name(): e.getMessage().", "author": "guozhangwang", "createdAt": "2020-12-09T19:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3NzY3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "797e4025177a78175b1b636c5bdb9b8dcd8ca1c9", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\nindex 1d2d7df51b..e7bf26bac5 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n\n@@ -844,7 +860,13 @@ public abstract class AbstractCoordinator implements Closeable {\n \n         @Override\n         public void onFailure(RuntimeException e, RequestFuture<Void> future) {\n-            log.debug(\"FindCoordinator request failed\", e);\n+            log.debug(\"FindCoordinator request failed due to {}\", e);\n+\n+            if (!(e instanceof RetriableException)) {\n+                // Remember the exception if fatal so we can ensure it gets thrown by the main thread\n+                fatalFindCoordinatorException = e;\n+            }\n+\n             super.onFailure(e, future);\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4MzQzNA==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r534383434", "bodyText": "The main reason for https://github.com/apache/kafka/pull/7312/files#diff-15efe9b844f78b686393b6c2e2ad61306c3473225742caed05c7edab9a138832R230-R234 is the following:\n\ninside ensureCoordinatorReady called by the main thread, we may break out of the loop at line 248 below, without knowing what's the final state of the future.\nand that future could be completed by the other thread (hb) later, and replaced by a new future object.\n\nIn that case, when the main thread calls ensureCoordinatorReady again, it will \"miss\" the previous future's contained fatal error.\nSo thinking about it again, I think we would still want to maintain the exception but only if it is a fatal one inside the handler (i.e. we do not probably need to register another listener just to bookkeep that exception, but just piggy-back this logic inside the handler listener directly), and then inside the while loop, we check if a previous future already gets a fatal exception and if yes, throw it to fail the whole client.", "author": "guozhangwang", "createdAt": "2020-12-02T18:19:28Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -235,11 +235,6 @@ protected synchronized boolean ensureCoordinatorReady(final Timer timer) {\n             return true;\n \n         do {\n-            if (findCoordinatorException != null && !(findCoordinatorException instanceof RetriableException)) {", "originalCommit": "baa2d0fcaa56868288ee6488f7e7736884152826", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk5MjAxMg==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r537992012", "bodyText": "Ok yeah that makes sense. Thanks", "author": "ableegoldman", "createdAt": "2020-12-08T02:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4MzQzNA=="}], "type": "inlineReview", "revised_code": {"commit": "797e4025177a78175b1b636c5bdb9b8dcd8ca1c9", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\nindex 1d2d7df51b..e7bf26bac5 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n\n@@ -235,6 +236,11 @@ public abstract class AbstractCoordinator implements Closeable {\n             return true;\n \n         do {\n+            if (fatalFindCoordinatorException != null) {\n+                final RuntimeException fatalException = fatalFindCoordinatorException;\n+                fatalFindCoordinatorException = null;\n+                throw fatalException;\n+            }\n             final RequestFuture<Void> future = lookupCoordinator();\n             client.poll(future, timer);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4MzU2Mw==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r534383563", "bodyText": "nit: extra space.", "author": "guozhangwang", "createdAt": "2020-12-02T18:19:39Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -248,18 +243,26 @@ protected synchronized boolean ensureCoordinatorReady(final Timer timer) {\n                 break;\n             }\n \n+            RuntimeException fatalException = null;\n+\n             if (future.failed()) {\n                 if (future.isRetriable()) {\n                     log.debug(\"Coordinator discovery failed, refreshing metadata\", future.exception());\n                     client.awaitMetadataUpdate(timer);\n-                } else\n-                    throw future.exception();\n+                } else {\n+                    log.info(\"FindCoordinator request hit fatal  exception\", fatalException);", "originalCommit": "baa2d0fcaa56868288ee6488f7e7736884152826", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "797e4025177a78175b1b636c5bdb9b8dcd8ca1c9", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\nindex 1d2d7df51b..e7bf26bac5 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n\n@@ -250,13 +256,13 @@ public abstract class AbstractCoordinator implements Closeable {\n                     log.debug(\"Coordinator discovery failed, refreshing metadata\", future.exception());\n                     client.awaitMetadataUpdate(timer);\n                 } else {\n-                    log.info(\"FindCoordinator request hit fatal  exception\", fatalException);\n+                    log.info(\"FindCoordinator request hit fatal exception\", fatalException);\n                     fatalException = future.exception();\n                 }\n             } else if (coordinator != null && client.isUnavailable(coordinator)) {\n                 // we found the coordinator, but the connection has failed, so mark\n                 // it dead and backoff before retrying discovery\n-                markCoordinatorUnknown();\n+                markCoordinatorUnknown(\"coordinator unavailable\");\n                 timer.sleep(rebalanceConfig.retryBackoffMs);\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4NjUzOA==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r534386538", "bodyText": "I think this is a better approach, but we need to be careful about the callee inside hb thread:\nif (findCoordinatorFuture != null || lookupCoordinator().failed())\n\ni.e. a hb thread sending a discover-coordinator request would also cause a future to be assigned, but that future would only be cleared by the main thread caller. Thinking about that for a sec I think this is okay, but maybe worth having a second pair of eyes over it.", "author": "guozhangwang", "createdAt": "2020-12-02T18:24:25Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -248,18 +243,26 @@ protected synchronized boolean ensureCoordinatorReady(final Timer timer) {\n                 break;\n             }\n \n+            RuntimeException fatalException = null;\n+\n             if (future.failed()) {\n                 if (future.isRetriable()) {\n                     log.debug(\"Coordinator discovery failed, refreshing metadata\", future.exception());\n                     client.awaitMetadataUpdate(timer);\n-                } else\n-                    throw future.exception();\n+                } else {\n+                    log.info(\"FindCoordinator request hit fatal  exception\", fatalException);\n+                    fatalException = future.exception();\n+                }\n             } else if (coordinator != null && client.isUnavailable(coordinator)) {\n                 // we found the coordinator, but the connection has failed, so mark\n                 // it dead and backoff before retrying discovery\n                 markCoordinatorUnknown();\n                 timer.sleep(rebalanceConfig.retryBackoffMs);\n             }\n+\n+            clearFindCoordinatorFuture();", "originalCommit": "baa2d0fcaa56868288ee6488f7e7736884152826", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk5MDczMQ==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r537990731", "bodyText": "Ah, good point...actually I think that's probably not ok for it to only ever be cleared in the main thread, since eg the main thread might be stuck in long processing while the hb threads should not be blocked from looking up the coordinator.\nSo, maybe we should also call clearFindCoordinatorFuture inside the hb thread in the if (findCoordinatorFuture != null || lookupCoordinator().failed()) block (if it did indeed finish and has failed) -- WDYT?", "author": "ableegoldman", "createdAt": "2020-12-08T02:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4NjUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2ODM3OA==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r539568378", "bodyText": "That makes sense, we can clearFindCoordinatorFuture inside the hb thread as well.", "author": "guozhangwang", "createdAt": "2020-12-09T19:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4NjUzOA=="}], "type": "inlineReview", "revised_code": {"commit": "797e4025177a78175b1b636c5bdb9b8dcd8ca1c9", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\nindex 1d2d7df51b..e7bf26bac5 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n\n@@ -250,13 +256,13 @@ public abstract class AbstractCoordinator implements Closeable {\n                     log.debug(\"Coordinator discovery failed, refreshing metadata\", future.exception());\n                     client.awaitMetadataUpdate(timer);\n                 } else {\n-                    log.info(\"FindCoordinator request hit fatal  exception\", fatalException);\n+                    log.info(\"FindCoordinator request hit fatal exception\", fatalException);\n                     fatalException = future.exception();\n                 }\n             } else if (coordinator != null && client.isUnavailable(coordinator)) {\n                 // we found the coordinator, but the connection has failed, so mark\n                 // it dead and backoff before retrying discovery\n-                markCoordinatorUnknown();\n+                markCoordinatorUnknown(\"coordinator unavailable\");\n                 timer.sleep(rebalanceConfig.retryBackoffMs);\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYyMzgxNQ==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r558623815", "bodyText": "The nested condition is a bit awkward, how about this:\nif (findCoordinatorFuture != null) {\n    // if it has failed, clear it so that hb thread can try discover again in the next loop in case main thread is busy\n    if (findCoordinatorFuture.failed()) {\n        clearFindCoordinatorFuture();\n    } \n\n    // backoff properly\n    AbstractCoordinator.this.wait(rebalanceConfig.retryBackoffMs);\n} else {\n    lookupCoordinator();\n}", "author": "guozhangwang", "createdAt": "2021-01-15T22:23:56Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -1342,10 +1351,17 @@ public void run() {\n                         long now = time.milliseconds();\n \n                         if (coordinatorUnknown()) {\n-                            if (findCoordinatorFuture != null || lookupCoordinator().failed())\n+                            if (findCoordinatorFuture != null || lookupCoordinator().failed()) {", "originalCommit": "5ef5f05b6daf001b68920a5480ac8ddf9ca68f8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwMDA3OA==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r560600078", "bodyText": "Sure yeah that's much better", "author": "ableegoldman", "createdAt": "2021-01-20T00:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYyMzgxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "797e4025177a78175b1b636c5bdb9b8dcd8ca1c9", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\nindex d10c46da08..e7bf26bac5 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n\n@@ -1351,21 +1368,22 @@ public abstract class AbstractCoordinator implements Closeable {\n                         long now = time.milliseconds();\n \n                         if (coordinatorUnknown()) {\n-                            if (findCoordinatorFuture != null || lookupCoordinator().failed()) {\n-                                if (findCoordinatorFuture != null && findCoordinatorFuture.failed()) {\n-                                    // if the future did complete and has failed, clear it so that the hb thread\n-                                    // can send a new FindCoordinator request in case the main thread is busy\n+                            if (findCoordinatorFuture != null) {\n+                                // if it has failed, clear it so that hb thread can try discover again in the next loop in case main thread is busy\n+                                if (findCoordinatorFuture.failed()) {\n                                     clearFindCoordinatorFuture();\n                                 }\n \n-                                // the immediate future check ensures that we backoff properly in the case that no\n-                                // brokers are available to connect to.\n+                                // backoff properly\n                                 AbstractCoordinator.this.wait(rebalanceConfig.retryBackoffMs);\n+                            } else {\n+                                lookupCoordinator();\n                             }\n                         } else if (heartbeat.sessionTimeoutExpired(now)) {\n                             // the session timeout has expired without seeing a successful heartbeat, so we should\n                             // probably make sure the coordinator is still healthy.\n-                            markCoordinatorUnknown();\n+                            markCoordinatorUnknown(\"session timed out without receiving a \"\n+                                    + \"heartbeat response\");\n                         } else if (heartbeat.pollTimeoutExpired(now)) {\n                             // the poll timeout has expired, which means that the foreground thread has stalled\n                             // in between calls to poll().\n"}}, {"oid": "797e4025177a78175b1b636c5bdb9b8dcd8ca1c9", "url": "https://github.com/apache/kafka/commit/797e4025177a78175b1b636c5bdb9b8dcd8ca1c9", "message": "logic refactoring", "committedDate": "2021-01-20T00:58:21Z", "type": "forcePushed"}, {"oid": "0ec29c4c98d219e9e030abe9cbb9ecb63737bcd2", "url": "https://github.com/apache/kafka/commit/0ec29c4c98d219e9e030abe9cbb9ecb63737bcd2", "message": "logic refactoring", "committedDate": "2021-01-20T19:32:21Z", "type": "forcePushed"}, {"oid": "a6022afc2a03a4c8f52311944c79db8756fc2dc8", "url": "https://github.com/apache/kafka/commit/a6022afc2a03a4c8f52311944c79db8756fc2dc8", "message": "move handling of future", "committedDate": "2021-01-20T23:59:53Z", "type": "commit"}, {"oid": "deec9a2fca29c661d0ad5bf8754aa936d8b6ed4e", "url": "https://github.com/apache/kafka/commit/deec9a2fca29c661d0ad5bf8754aa936d8b6ed4e", "message": "review suggestions", "committedDate": "2021-01-20T23:59:53Z", "type": "commit"}, {"oid": "84b39c6646597fe03650b3be500b4d958dde19d4", "url": "https://github.com/apache/kafka/commit/84b39c6646597fe03650b3be500b4d958dde19d4", "message": "find checkstyle, add comment", "committedDate": "2021-01-20T23:59:53Z", "type": "commit"}, {"oid": "3e5e9d2c0b5bc1a30a35df7e515880b475c1a5bb", "url": "https://github.com/apache/kafka/commit/3e5e9d2c0b5bc1a30a35df7e515880b475c1a5bb", "message": "logging suggestion", "committedDate": "2021-01-20T23:59:53Z", "type": "commit"}, {"oid": "bd921db0e23d7eb024106f53ab76bb10dcd9f2a9", "url": "https://github.com/apache/kafka/commit/bd921db0e23d7eb024106f53ab76bb10dcd9f2a9", "message": "logic refactoring", "committedDate": "2021-01-20T23:59:53Z", "type": "commit"}, {"oid": "bd921db0e23d7eb024106f53ab76bb10dcd9f2a9", "url": "https://github.com/apache/kafka/commit/bd921db0e23d7eb024106f53ab76bb10dcd9f2a9", "message": "logic refactoring", "committedDate": "2021-01-20T23:59:53Z", "type": "forcePushed"}, {"oid": "92777103e0c4637a0aac4cf1165ff4d71814091b", "url": "https://github.com/apache/kafka/commit/92777103e0c4637a0aac4cf1165ff4d71814091b", "message": "fix for hanging #testCoordinatorFailover", "committedDate": "2021-01-26T03:48:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDg5OTc3Ng==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r564899776", "bodyText": "I think the issue is spot-on! The logic here becomes a bit hard to understand for other readers now and I'd suggest update the cmment as:\n\"Clear the future so that after the backoff in the next iteration, if hb still sees coordinator unknown it will try re-discover the coordinator in case the main thread cannot\"\nOtherwise, LGTM.", "author": "guozhangwang", "createdAt": "2021-01-26T23:06:49Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -1359,10 +1368,15 @@ public void run() {\n                         long now = time.milliseconds();\n \n                         if (coordinatorUnknown()) {\n-                            if (findCoordinatorFuture != null || lookupCoordinator().failed())\n-                                // the immediate future check ensures that we backoff properly in the case that no\n-                                // brokers are available to connect to.\n+                            if (findCoordinatorFuture != null) {", "originalCommit": "92777103e0c4637a0aac4cf1165ff4d71814091b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDkwMjg0OA==", "url": "https://github.com/apache/kafka/pull/9671#discussion_r564902848", "bodyText": "SG", "author": "ableegoldman", "createdAt": "2021-01-26T23:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDg5OTc3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5d111d889e7b994b2c9d6f2d522dc032ff7237d9", "chunk": "diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\nindex a443624ceb..3eb86dbaee 100644\n--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java\n\n@@ -1369,7 +1369,8 @@ public abstract class AbstractCoordinator implements Closeable {\n \n                         if (coordinatorUnknown()) {\n                             if (findCoordinatorFuture != null) {\n-                                // clear it so that hb thread can try discover again in the next loop in case main thread cannot\n+                                // clear the future so that after the backoff, if the hb still sees coordinator unknown in\n+                                // the next iteration it will try to re-discover the coordinator in case the main thread cannot\n                                 clearFindCoordinatorFuture();\n \n                                 // backoff properly\n"}}, {"oid": "5d111d889e7b994b2c9d6f2d522dc032ff7237d9", "url": "https://github.com/apache/kafka/commit/5d111d889e7b994b2c9d6f2d522dc032ff7237d9", "message": "improve code comment", "committedDate": "2021-01-26T23:14:07Z", "type": "commit"}]}