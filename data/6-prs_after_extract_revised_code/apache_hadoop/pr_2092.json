{"pr_number": 2092, "pr_title": "HDFS-15429. mkdirs should work when parent dir is an internalDir and fallback configured.", "pr_createdAt": "2020-06-24T00:02:35Z", "pr_url": "https://github.com/apache/hadoop/pull/2092", "timeline": [{"oid": "89488c93ae8581d216d406fd028fa49f66dd2baf", "url": "https://github.com/apache/hadoop/commit/89488c93ae8581d216d406fd028fa49f66dd2baf", "message": "HDFS-15429. mkdirs should work when parent dir is an internalDir and fallback configured.", "committedDate": "2020-06-24T00:00:12Z", "type": "commit"}, {"oid": "c183308bde61b29c2c873af39961ee7c6cb6ea1f", "url": "https://github.com/apache/hadoop/commit/c183308bde61b29c2c873af39961ee7c6cb6ea1f", "message": "Added a test case and removed restriction on fallback tree creation when fallback does not have matching internal tree.", "committedDate": "2020-06-24T20:01:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2MjExNA==", "url": "https://github.com/apache/hadoop/pull/2092#discussion_r445862114", "bodyText": "Thanx @umamaheswararao for the work here,\n\n\nAre the changes here in viewFs.java covered anywhere in test? If not will be good to cover this change as well\n\n\nRegarding the IOE, we are logging the IOE and then throwing readOnlyMountTable(\"mkdir\", dir); instead of the actual exception. Is it intended? It actually suppress the actual reason, There is a difference in behavior between the implementation here and at ViewFileSystem, in case of exception there we handle it and don't throw readOnlyMountTable(\"mkdir\", dir); rather a response, though mkdirs and mkdir behave differently and returning false there still might work, but here a person can not fix the issue based on the end exception he receives.\n\n\nI think the createParent needs to be tackled, when the parent is there in the mount table, in that case we have to explicitly change it to true. I tried tweaking one of your test give a check :\n\n\n @ Test\n  public void testMkdirsOfDeepTreeWithFallbackLinkAndMountPathMatchingDirExist()\n      throws Exception {\n    Configuration conf = new Configuration();\n    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n    ConfigUtil.addLink(conf, \"/user1/hive\",\n        new Path(targetTestRoot.toString() + \"/\").toUri());\n    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n    fsTarget.mkdirs(fallbackTarget);\n    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n    AbstractFileSystem vfs = AbstractFileSystem.get(viewFsDefaultClusterUri,\n        conf);\n      //user1 does not exist in fallback\n      Path multipleLevelToInternalDir = new Path(\"/user1/test\");\n      Path test = Path.mergePaths(fallbackTarget, multipleLevelToInternalDir);\n      assertFalse(fsTarget.exists(test));\n      // Creating /user1/test\n    // Parent /user1 Exists.\n    assertNotNull(vfs.getFileStatus(new Path(\"/user1\")));\n\n    // Creating /user1/test should be success, with createParent false, as\n    // parent /user1 exists.\n      vfs.mkdir(multipleLevelToInternalDir,\n          FsPermission.getDirDefault(),false); // This throws Exception...\n      assertTrue(fsTarget.exists(test));\n\n  }", "author": "ayushtkn", "createdAt": "2020-06-25T21:58:39Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFs.java", "diffHunk": "@@ -1139,6 +1139,27 @@ public void mkdir(final Path dir, final FsPermission permission,\n       if (theInternalDir.isRoot() && dir == null) {\n         throw new FileAlreadyExistsException(\"/ already exits\");\n       }\n+\n+      if (this.fsState.getRootFallbackLink() != null) {\n+        AbstractFileSystem linkedFallbackFs =\n+            this.fsState.getRootFallbackLink().getTargetFileSystem();\n+        Path p = Path.getPathWithoutSchemeAndAuthority(\n+            new Path(theInternalDir.fullPath));\n+        String child = (InodeTree.SlashPath.equals(dir)) ?\n+            InodeTree.SlashPath.toString() :\n+            dir.getName();\n+        Path dirToCreate = new Path(p, child);\n+        try {\n+          linkedFallbackFs.mkdir(dirToCreate, permission, createParent);\n+        } catch (IOException e) {\n+          if (LOG.isDebugEnabled()) {\n+            StringBuilder msg = new StringBuilder(\"Failed to create {}\")\n+                .append(\" at fallback fs : {}\");\n+            LOG.debug(msg.toString(), dirToCreate, linkedFallbackFs.getUri());\n+          }\n+        }\n+      }\n+", "originalCommit": "c183308bde61b29c2c873af39961ee7c6cb6ea1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNTE0NA==", "url": "https://github.com/apache/hadoop/pull/2092#discussion_r445925144", "bodyText": "Thanks a lot @ayushtkn for review!\n\nYes, I agree somehow we kept Viewfs.java on lowlight, probably due t it's low usage :-) I have added tests.\na) This is a good point. I just checked that ViewFs#mkdir is already throwing IOE. I think we can just throw IOE out. So, that users would know what happened.\nb) Another missed was, even in positive case, I was not returning before. Added return after mkdir success.\nc) We always pass createParent as true here. We don't need to actually worry parent exist or not, because parent is exist in mount Internal dir, that's why it got resolved to InternalDirViewFS#mkdir. So, passing createParent as true always in fallback case.\nAdded tests to cover the cases with ViewFs#mkdir with createParentDir true or false, with one level and multipleLevels (means to check recursive creation. Both seems to be working.)\nLet's discuss if this behavior make sense to you.", "author": "umamaheswararao", "createdAt": "2020-06-26T01:41:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2MjExNA=="}], "type": "inlineReview", "revised_code": {"commit": "6900aa5c56355af00311c3da8f907661f98c9bcf", "chunk": "diff --git a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFs.java b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFs.java\nindex 3dd0d7753f9..c769003aacf 100644\n--- a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFs.java\n+++ b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFs.java\n\n@@ -1134,8 +1134,7 @@ public int getUriDefaultPort() {\n \n     @Override\n     public void mkdir(final Path dir, final FsPermission permission,\n-        final boolean createParent) throws AccessControlException,\n-        FileAlreadyExistsException {\n+        final boolean createParent) throws IOException {\n       if (theInternalDir.isRoot() && dir == null) {\n         throw new FileAlreadyExistsException(\"/ already exits\");\n       }\n"}}, {"oid": "6900aa5c56355af00311c3da8f907661f98c9bcf", "url": "https://github.com/apache/hadoop/commit/6900aa5c56355af00311c3da8f907661f98c9bcf", "message": "Fixed few issues and review comments. And added tests to cover ViewFs.java as well.", "committedDate": "2020-06-26T01:33:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1MTcwMA==", "url": "https://github.com/apache/hadoop/pull/2092#discussion_r445951700", "bodyText": "Remove space after @", "author": "ayushtkn", "createdAt": "2020-06-26T03:43:09Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsLinkFallback.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.AbstractFileSystem;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.hdfs.DFSConfigKeys;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.MiniDFSNNTopology;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+/**\n+ * Test for viewfs with LinkFallback mount table entries.\n+ */\n+public class TestViewFsLinkFallback {\n+  private static FileSystem fsDefault;\n+  private FileSystem fsTarget;\n+  private static MiniDFSCluster cluster;\n+  private static URI viewFsDefaultClusterUri;\n+  private Path targetTestRoot;\n+\n+  @BeforeClass\n+  public static void clusterSetupAtBeginning()\n+      throws IOException, URISyntaxException {\n+    int nameSpacesCount = 3;\n+    int dataNodesCount = 3;\n+    int fsIndexDefault = 0;\n+    Configuration conf = new Configuration();\n+    FileSystem[] fsHdfs = new FileSystem[nameSpacesCount];\n+    conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,\n+        true);\n+    cluster = new MiniDFSCluster.Builder(conf)\n+        .nnTopology(MiniDFSNNTopology.simpleFederatedTopology(\n+            nameSpacesCount))\n+        .numDataNodes(dataNodesCount)\n+        .build();\n+    cluster.waitClusterUp();\n+\n+    for (int i = 0; i < nameSpacesCount; i++) {\n+      fsHdfs[i] = cluster.getFileSystem(i);\n+    }\n+    fsDefault = fsHdfs[fsIndexDefault];\n+    viewFsDefaultClusterUri = new URI(FsConstants.VIEWFS_SCHEME,\n+        Constants.CONFIG_VIEWFS_DEFAULT_MOUNT_TABLE, \"/\", null, null);\n+\n+  }\n+\n+  @AfterClass\n+  public static void clusterShutdownAtEnd() throws Exception {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    fsTarget = fsDefault;\n+    initializeTargetTestRoot();\n+  }\n+\n+  private void initializeTargetTestRoot() throws IOException {\n+    targetTestRoot = fsDefault.makeQualified(new Path(\"/\"));\n+    for (FileStatus status : fsDefault.listStatus(targetTestRoot)) {\n+      fsDefault.delete(status.getPath(), true);\n+    }\n+  }\n+\n+  /**\n+   * Tests that directory making should be successful when the parent directory\n+   * is same as the existent fallback directory. The new dir should be created\n+   * in fallback instead failing.\n+   */\n+  @Test\n+  public void testMkdirOfLinkParentWithFallbackLinkWithSameMountDirectoryTree()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path dir1 = new Path(targetTestRoot,\n+        \"fallbackDir/user1/hive/warehouse/partition-0\");\n+    fsTarget.mkdirs(dir1);\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+    Path p = new Path(\"/user1/hive/warehouse/test\");\n+    Path test = Path.mergePaths(fallbackTarget, p);\n+    assertFalse(fsTarget.exists(test));\n+    vfs.mkdir(p, null, true);\n+    assertTrue(fsTarget.exists(test));\n+  }\n+\n+  /**\n+   * Tests that directory making should be successful when attempting to create\n+   * the root directory as it's already exist.\n+   */\n+  @Test\n+  public void testMkdirOfRootWithFallbackLinkAndMountWithSameDirTree()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n+    ConfigUtil\n+        .addLink(conf, \"/user1\", new Path(targetTestRoot.toString()).toUri());\n+    Path dir1 = new Path(targetTestRoot, \"fallbackDir/user1\");\n+    fsTarget.mkdirs(dir1);\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+    Path p = new Path(\"/\");\n+    Path test = Path.mergePaths(fallbackTarget, p);\n+    assertTrue(fsTarget.exists(test));\n+    vfs.mkdir(p, null, true);\n+    assertTrue(fsTarget.exists(test));\n+  }\n+\n+  /**\n+   * Tests the making of a new directory which is not matching to any of\n+   * internal directory under the root.\n+   */\n+  @Test\n+  public void testMkdirOfNewDirWithOutMatchingToMountOrFallbackDirTree()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+    // user2 does not exist in fallback\n+    Path p = new Path(\"/user2\");\n+    Path test = Path.mergePaths(fallbackTarget, p);\n+    assertFalse(fsTarget.exists(test));\n+    vfs.mkdir(p, null, true);\n+    assertTrue(fsTarget.exists(test));\n+  }\n+\n+  /**\n+   * Tests that when the parent dirs does not exist in fallback but the parent\n+   * dir is same as mount internal directory, then we create parent structure\n+   * (mount internal directory tree structure) in fallback.\n+   */\n+  @Test\n+  public void testMkdirWithFallbackLinkWithMountPathMatchingDirExist()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n+    ConfigUtil.addLink(conf, \"/user1/hive\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+    //user1 does not exist in fallback\n+    Path immediateLevelToInternalDir = new Path(\"/user1/test\");\n+    Path test = Path.mergePaths(fallbackTarget, immediateLevelToInternalDir);\n+    assertFalse(fsTarget.exists(test));\n+    vfs.mkdir(immediateLevelToInternalDir, null, true);\n+    assertTrue(fsTarget.exists(test));\n+  }\n+\n+  /**\n+   * Tests that when the parent dirs does not exist in fallback but the\n+   * immediate parent dir is not same as mount internal directory, then we\n+   * create parent structure (mount internal directory tree structure) in\n+   * fallback.\n+   */\n+  @Test\n+  public void testMkdirOfDeepTreeWithFallbackLinkAndMountPathMatchingDirExist()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n+    ConfigUtil.addLink(conf, \"/user1/hive\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+    //user1 does not exist in fallback\n+    Path multipleLevelToInternalDir = new Path(\"/user1/test/test\");\n+    Path test = Path.mergePaths(fallbackTarget, multipleLevelToInternalDir);\n+    assertFalse(fsTarget.exists(test));\n+    vfs.mkdir(multipleLevelToInternalDir, null, true);\n+    assertTrue(fsTarget.exists(test));\n+  }\n+\n+  /**\n+   * Tests that mkdir with createParent false should still create parent in\n+   * fallback when the same mount dir exist.\n+   */\n+  @ Test", "originalCommit": "6900aa5c56355af00311c3da8f907661f98c9bcf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e1f429b068b5910c9af6fda36df9410e24eeac35", "chunk": "diff --git a/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsLinkFallback.java b/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsLinkFallback.java\nindex 92c8478bfb0..330f04d0494 100644\n--- a/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsLinkFallback.java\n+++ b/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsLinkFallback.java\n\n@@ -228,7 +228,7 @@ public void testMkdirOfDeepTreeWithFallbackLinkAndMountPathMatchingDirExist()\n    * Tests that mkdir with createParent false should still create parent in\n    * fallback when the same mount dir exist.\n    */\n-  @ Test\n+  @Test\n   public void testMkdirShouldCreateParentDirInFallbackWhenMountDirExist()\n       throws Exception {\n     Configuration conf = new Configuration();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1MzQ2MA==", "url": "https://github.com/apache/hadoop/pull/2092#discussion_r445953460", "bodyText": "Break line after @test\n\nIf inteliiJ -\nFile -> Settings -> CodeStyle -> Java -> Wrapping and Braces -> Method annotations -> Change to Wrap Always", "author": "ayushtkn", "createdAt": "2020-06-26T03:51:43Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java", "diffHunk": "@@ -606,4 +602,166 @@ public void testLSOnLinkParentWhereMountLinkMatchesWithAFileUnderFallback()\n       }\n     }\n   }\n+\n+  /**\n+   * Tests that directory making should be successful when the parent directory\n+   * is same as the existent fallback directory. The new dir should be created\n+   * in fallback instead failing.\n+   */\n+  @Test\n+  public void testMkdirsOfLinkParentWithFallbackLinkWithSameMountDirectoryTree()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path dir1 = new Path(targetTestRoot,\n+        \"fallbackDir/user1/hive/warehouse/partition-0\");\n+    fsTarget.mkdirs(dir1);\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path p = new Path(\"/user1/hive/warehouse/test\");\n+      Path test = Path.mergePaths(fallbackTarget, p);\n+      assertFalse(fsTarget.exists(test));\n+      assertTrue(vfs.mkdirs(p));\n+      assertTrue(fsTarget.exists(test));\n+    }\n+  }\n+\n+  /**\n+   * Tests that directory making should be successful when attempting to create\n+   * the root directory as it's already exist.\n+   */\n+  @Test\n+  public void testMkdirsOfRootWithFallbackLinkAndMountWithSameDirTree()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n+    ConfigUtil\n+        .addLink(conf, \"/user1\", new Path(targetTestRoot.toString()).toUri());\n+    Path dir1 = new Path(targetTestRoot, \"fallbackDir/user1\");\n+    fsTarget.mkdirs(dir1);\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path p = new Path(\"/\");\n+      Path test = Path.mergePaths(fallbackTarget, p);\n+      assertTrue(fsTarget.exists(test));\n+      assertTrue(vfs.mkdirs(p));\n+      assertTrue(fsTarget.exists(test));\n+    }\n+  }\n+\n+  /**\n+   * Tests the making of a new directory which is not matching to any of\n+   * internal directory under the root.\n+   */\n+  @Test\n+  public void testMkdirsOfNewDirWithOutMatchingToMountOrFallbackDirTree()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      // user2 does not exist in fallback\n+      Path p = new Path(\"/user2\");\n+      Path test = Path.mergePaths(fallbackTarget, p);\n+      assertFalse(fsTarget.exists(test));\n+      assertTrue(vfs.mkdirs(p));\n+      assertTrue(fsTarget.exists(test));\n+    }\n+  }\n+\n+  /**\n+   * Tests that when the parent dirs does not exist in fallback but the parent\n+   * dir is same as mount internal directory, then we create parent structure\n+   * (mount internal directory tree structure) in fallback.\n+   */\n+  @Test\n+  public void testMkdirsWithFallbackLinkWithMountPathMatchingDirExist()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n+    ConfigUtil.addLink(conf, \"/user1/hive\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      //user1 does not exist in fallback\n+      Path immediateLevelToInternalDir = new Path(\"/user1/test\");\n+      Path test = Path.mergePaths(fallbackTarget, immediateLevelToInternalDir);\n+      assertFalse(fsTarget.exists(test));\n+      assertTrue(vfs.mkdirs(immediateLevelToInternalDir));\n+      assertTrue(fsTarget.exists(test));\n+    }\n+  }\n+\n+  /**\n+   * Tests that when the parent dirs does not exist in fallback but the\n+   * immediate parent dir is not same as mount internal directory, then we\n+   * create parent structure (mount internal directory tree structure) in\n+   * fallback.\n+   */\n+  @Test\n+  public void testMkdirsOfDeepTreeWithFallbackLinkAndMountPathMatchingDirExist()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n+    ConfigUtil.addLink(conf, \"/user1/hive\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      //user1 does not exist in fallback\n+      Path multipleLevelToInternalDir = new Path(\"/user1/test/test\");\n+      Path test = Path.mergePaths(fallbackTarget, multipleLevelToInternalDir);\n+      assertFalse(fsTarget.exists(test));\n+      assertTrue(vfs.mkdirs(multipleLevelToInternalDir));\n+      assertTrue(fsTarget.exists(test));\n+    }\n+  }\n+\n+  /**\n+   * Tests that mkdirs should return false when there is a problem with\n+   * fallbackfs.\n+   */\n+  @Test public void testMkdirsShouldReturnFalseWhenFallbackFSNotAvailable()", "originalCommit": "6900aa5c56355af00311c3da8f907661f98c9bcf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e1f429b068b5910c9af6fda36df9410e24eeac35", "chunk": "diff --git a/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java b/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java\nindex 78092488d3c..bec261cf3eb 100644\n--- a/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java\n+++ b/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java\n\n@@ -736,7 +736,8 @@ public void testMkdirsOfDeepTreeWithFallbackLinkAndMountPathMatchingDirExist()\n    * Tests that mkdirs should return false when there is a problem with\n    * fallbackfs.\n    */\n-  @Test public void testMkdirsShouldReturnFalseWhenFallbackFSNotAvailable()\n+  @Test\n+  public void testMkdirsShouldReturnFalseWhenFallbackFSNotAvailable()\n       throws Exception {\n     Configuration conf = new Configuration();\n     conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n"}}, {"oid": "e1f429b068b5910c9af6fda36df9410e24eeac35", "url": "https://github.com/apache/hadoop/commit/e1f429b068b5910c9af6fda36df9410e24eeac35", "message": "@Test annotation wrapped.", "committedDate": "2020-06-26T05:05:31Z", "type": "commit"}, {"oid": "b4708abc36a3e34fcd4c2c7f1abc67c57d5ba3a6", "url": "https://github.com/apache/hadoop/commit/b4708abc36a3e34fcd4c2c7f1abc67c57d5ba3a6", "message": "Minor formatting corrected.", "committedDate": "2020-06-26T08:23:06Z", "type": "commit"}]}