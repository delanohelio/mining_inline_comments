{"pr_number": 2396, "pr_title": "HADOOP-17313. FileSystem.get to support slow-to-instantiate FS clients.", "pr_createdAt": "2020-10-19T16:38:27Z", "pr_url": "https://github.com/apache/hadoop/pull/2396", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM2MDEyOA==", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r513360128", "bodyText": "typo?", "author": "mehakmeet", "createdAt": "2020-10-28T11:12:07Z", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java", "diffHunk": "@@ -336,4 +344,134 @@ public void testCacheIncludesURIUserInfo() throws Throwable {\n     assertNotEquals(keyA, new FileSystem.Cache.Key(\n         new URI(\"wasb://a:password@account.blob.core.windows.net\"), conf));\n   }\n+\n+\n+  /**\n+   * Single semaphore: no surplus FS instances will be created\n+   * and then discarded.\n+   */\n+  @Test\n+  public void testCacheSingleSemaphoredConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(1);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(0);\n+  }\n+\n+  /**\n+   * Dual semaphore: thread 2 will get as far as\n+   * blocking in the initialize() method while awaiting\n+   * thread 1 to complete its initialization.\n+   * <p></p>\n+   * The thread 2 FS instance will be discarded.\n+   * All other threads will block for a cache semaphore,\n+   * so when they are given an opportunity to proceed,\n+   * they will find that an FS instance exists.\n+   */\n+  @Test\n+  public void testCacheDualSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(2);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(1);\n+  }\n+\n+  /**\n+   * Construct the FS instances in a cache with effectively no\n+   * limit on the number of instances which can be created\n+   * simultaneously.\n+   * <p></p>\n+   * This is the effective state before HADOOP-17313.\n+   * <p></p>\n+   * All but one thread's FS instance will be discarded.\n+   */\n+  @Test\n+  public void testCacheLargeSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(999);\n+    int count = 10;\n+    createFileSystems(cache, count);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(count -1);\n+  }\n+\n+  /**\n+   * Create a cache with a given semaphore size.\n+   * @param semaphores number of semaphores\n+   * @return the cache.\n+   */\n+  private FileSystem.Cache semaphoredCache(final int semaphores) {\n+    final Configuration conf1 = new Configuration();\n+    conf1.setInt(FS_CREATION_PARALLEL_COUNT, semaphores);\n+    FileSystem.Cache cache = new FileSystem.Cache(conf1);\n+    return cache;\n+  }\n+\n+  /**\n+   * Attempt to create {@code count} filesystems in parallel,\n+   * then assert that they are all equal.\n+   * @param cache cache to use\n+   * @param count count of filesystems to instantiate\n+   */\n+  private void createFileSystems(final FileSystem.Cache cache, final int count)\n+      throws URISyntaxException, InterruptedException,\n+             java.util.concurrent.ExecutionException {\n+    final Configuration conf = new Configuration();\n+    conf.set(\"fs.blocking.impl\", BlockingInitializer.NAME);\n+    // only one instance can be created at a time.\n+    URI uri = new URI(\"blocking://a\");\n+    ListeningExecutorService pool =\n+        BlockingThreadPoolExecutorService.newInstance(count * 2, 0,\n+            10, TimeUnit.SECONDS,\n+            \"creation-threads\");\n+\n+    // submit a set of requests to create an FS instance.\n+    // the semaphore will block all but one, and that will block until\n+    // it is allowed to continue\n+    List<ListenableFuture<FileSystem>> futures = new ArrayList<>(count);\n+\n+    // acquire the semaphore so blocking all FS instances from\n+    // being initialized.\n+    Semaphore semaphore = BlockingInitializer.sem;\n+    semaphore.acquire();\n+\n+    // su", "originalCommit": "abd2ee20d0a4082e98a53df674206ab1b72f50b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQxMTE4OQ==", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r514411189", "bodyText": "cut", "author": "steveloughran", "createdAt": "2020-10-29T16:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM2MDEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "40f9e9892a1e2d3c6c42002a0d2025837b20e2aa", "chunk": "diff --git a/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java\nindex f4036aaddab..01abeaaf577 100644\n--- a/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java\n+++ b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java\n\n@@ -434,10 +434,9 @@ private void createFileSystems(final FileSystem.Cache cache, final int count)\n \n     // acquire the semaphore so blocking all FS instances from\n     // being initialized.\n-    Semaphore semaphore = BlockingInitializer.sem;\n+    Semaphore semaphore = BlockingInitializer.SEM;\n     semaphore.acquire();\n \n-    // su\n     for (int i = 0; i < count; i++) {\n       futures.add(pool.submit(\n           () -> cache.get(uri, conf)));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2NTYwOQ==", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r514165609", "bodyText": "Should we have this as @VisibleForTesting?", "author": "mehakmeet", "createdAt": "2020-10-29T10:48:05Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "diffHunk": "@@ -3517,33 +3546,86 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n       if (fs != null) {\n         return fs;\n       }\n-\n-      fs = createFileSystem(uri, conf);\n-      final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n-          SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n-          ShutdownHookManager.TIME_UNIT_DEFAULT);\n-      synchronized (this) { // refetch the lock again\n-        FileSystem oldfs = map.get(key);\n-        if (oldfs != null) { // a file system is created while lock is releasing\n-          fs.close(); // close the new file system\n-          return oldfs;  // return the old file system\n-        }\n-\n-        // now insert the new file system into the map\n-        if (map.isEmpty()\n-                && !ShutdownHookManager.get().isShutdownInProgress()) {\n-          ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n-              SHUTDOWN_HOOK_PRIORITY, timeout,\n-              ShutdownHookManager.TIME_UNIT_DEFAULT);\n+      // fs not yet created, acquire lock\n+      // to construct an instance.\n+      try (DurationInfo d =\n+              new DurationInfo(LOGGER, false, \"Acquiring creator semaphore for %s\",\n+                  uri)) {\n+        creatorPermits.acquire();\n+      } catch (InterruptedException e) {\n+        // acquisition was interrupted; convert to an IOE.\n+        throw (IOException)new InterruptedIOException(e.toString())\n+            .initCause(e);\n+      }\n+      FileSystem fsToClose = null;\n+      try {\n+        // See if FS was instantiated by another thread while waiting\n+        // for the permit.\n+        synchronized (this) {\n+          fs = map.get(key);\n         }\n-        fs.key = key;\n-        map.put(key, fs);\n-        if (conf.getBoolean(\n-            FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n-          toAutoClose.add(key);\n+        if (fs != null) {\n+          LOGGER.debug(\"Filesystem {} created while awaiting semaphore\", uri);\n+          return fs;\n         }\n-        return fs;\n+        // create the filesystem\n+        fs = createFileSystem(uri, conf);\n+        final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n+            SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n+            ShutdownHookManager.TIME_UNIT_DEFAULT);\n+        // any FS to close outside of the synchronized section\n+        synchronized (this) { // lock on the Cache object\n+\n+          // see if there is now an entry for the FS, which happens\n+          // if another thread's creation overlapped with this one.\n+          FileSystem oldfs = map.get(key);\n+          if (oldfs != null) {\n+            // a file system was created in a separate thread.\n+            // save the FS reference to close outside all locks,\n+            // and switch to returning the oldFS\n+            fsToClose = fs;\n+            fs = oldfs;\n+          } else {\n+            // register the clientFinalizer if needed and shutdown isn't\n+            // already active\n+            if (map.isEmpty()\n+                && !ShutdownHookManager.get().isShutdownInProgress()) {\n+              ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n+                  SHUTDOWN_HOOK_PRIORITY, timeout,\n+                  ShutdownHookManager.TIME_UNIT_DEFAULT);\n+            }\n+            // insert the new file system into the map\n+            fs.key = key;\n+            map.put(key, fs);\n+            if (conf.getBoolean(\n+                FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n+              toAutoClose.add(key);\n+            }\n+          }\n+        } // end of synchronized block\n+      } finally {\n+        // release the creator permit.\n+        creatorPermits.release();\n+      }\n+      if (fsToClose != null) {\n+        LOGGER.debug(\"Duplicate FS created for {}; discarding {}\",\n+            uri, fs);\n+        discardedInstances.incrementAndGet();\n+        // close the new file system\n+        // note this will briefly remove and reinstate \"fsToClose\" from\n+        // the map. It is done in a synchronized block so will not be\n+        // visible to others.\n+        fsToClose.close();\n       }\n+      return fs;\n+    }\n+\n+    /**\n+     * Get the count of discarded instances.\n+     * @return the new instance.\n+     */\n+    long getDiscardedInstances() {", "originalCommit": "abd2ee20d0a4082e98a53df674206ab1b72f50b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQxMjA0MQ==", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r514412041", "bodyText": "done", "author": "steveloughran", "createdAt": "2020-10-29T16:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2NTYwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "40f9e9892a1e2d3c6c42002a0d2025837b20e2aa", "chunk": "diff --git a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java\nindex c0440e2b138..e814b3da915 100644\n--- a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java\n+++ b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java\n\n@@ -3548,9 +3552,8 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n       }\n       // fs not yet created, acquire lock\n       // to construct an instance.\n-      try (DurationInfo d =\n-              new DurationInfo(LOGGER, false, \"Acquiring creator semaphore for %s\",\n-                  uri)) {\n+      try (DurationInfo d = new DurationInfo(LOGGER, false,\n+          \"Acquiring creator semaphore for %s\", uri)) {\n         creatorPermits.acquire();\n       } catch (InterruptedException e) {\n         // acquisition was interrupted; convert to an IOE.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2NTY4Mg==", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r514165682", "bodyText": "typo: \"aquire\" -> \"acquire\"", "author": "mehakmeet", "createdAt": "2020-10-29T10:48:15Z", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java", "diffHunk": "@@ -336,4 +344,134 @@ public void testCacheIncludesURIUserInfo() throws Throwable {\n     assertNotEquals(keyA, new FileSystem.Cache.Key(\n         new URI(\"wasb://a:password@account.blob.core.windows.net\"), conf));\n   }\n+\n+\n+  /**\n+   * Single semaphore: no surplus FS instances will be created\n+   * and then discarded.\n+   */\n+  @Test\n+  public void testCacheSingleSemaphoredConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(1);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(0);\n+  }\n+\n+  /**\n+   * Dual semaphore: thread 2 will get as far as\n+   * blocking in the initialize() method while awaiting\n+   * thread 1 to complete its initialization.\n+   * <p></p>\n+   * The thread 2 FS instance will be discarded.\n+   * All other threads will block for a cache semaphore,\n+   * so when they are given an opportunity to proceed,\n+   * they will find that an FS instance exists.\n+   */\n+  @Test\n+  public void testCacheDualSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(2);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(1);\n+  }\n+\n+  /**\n+   * Construct the FS instances in a cache with effectively no\n+   * limit on the number of instances which can be created\n+   * simultaneously.\n+   * <p></p>\n+   * This is the effective state before HADOOP-17313.\n+   * <p></p>\n+   * All but one thread's FS instance will be discarded.\n+   */\n+  @Test\n+  public void testCacheLargeSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(999);\n+    int count = 10;\n+    createFileSystems(cache, count);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(count -1);\n+  }\n+\n+  /**\n+   * Create a cache with a given semaphore size.\n+   * @param semaphores number of semaphores\n+   * @return the cache.\n+   */\n+  private FileSystem.Cache semaphoredCache(final int semaphores) {\n+    final Configuration conf1 = new Configuration();\n+    conf1.setInt(FS_CREATION_PARALLEL_COUNT, semaphores);\n+    FileSystem.Cache cache = new FileSystem.Cache(conf1);\n+    return cache;\n+  }\n+\n+  /**\n+   * Attempt to create {@code count} filesystems in parallel,\n+   * then assert that they are all equal.\n+   * @param cache cache to use\n+   * @param count count of filesystems to instantiate\n+   */\n+  private void createFileSystems(final FileSystem.Cache cache, final int count)\n+      throws URISyntaxException, InterruptedException,\n+             java.util.concurrent.ExecutionException {\n+    final Configuration conf = new Configuration();\n+    conf.set(\"fs.blocking.impl\", BlockingInitializer.NAME);\n+    // only one instance can be created at a time.\n+    URI uri = new URI(\"blocking://a\");\n+    ListeningExecutorService pool =\n+        BlockingThreadPoolExecutorService.newInstance(count * 2, 0,\n+            10, TimeUnit.SECONDS,\n+            \"creation-threads\");\n+\n+    // submit a set of requests to create an FS instance.\n+    // the semaphore will block all but one, and that will block until\n+    // it is allowed to continue\n+    List<ListenableFuture<FileSystem>> futures = new ArrayList<>(count);\n+\n+    // acquire the semaphore so blocking all FS instances from\n+    // being initialized.\n+    Semaphore semaphore = BlockingInitializer.sem;\n+    semaphore.acquire();\n+\n+    // su\n+    for (int i = 0; i < count; i++) {\n+      futures.add(pool.submit(\n+          () -> cache.get(uri, conf)));\n+    }\n+    // now let all blocked initializers free\n+    semaphore.release();\n+    // get that first FS\n+    FileSystem createdFS = futures.get(0).get();\n+    // verify all the others are the same instance\n+    for (int i = 1; i < count; i++) {\n+      FileSystem fs = futures.get(i).get();\n+      Assertions.assertThat(fs)\n+          .isSameAs(createdFS);\n+    }\n+  }\n+\n+  /**\n+   * An FS which blocks in initialize() until it can aquire the shared", "originalCommit": "abd2ee20d0a4082e98a53df674206ab1b72f50b2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "40f9e9892a1e2d3c6c42002a0d2025837b20e2aa", "chunk": "diff --git a/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java\nindex f4036aaddab..01abeaaf577 100644\n--- a/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java\n+++ b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java\n\n@@ -434,10 +434,9 @@ private void createFileSystems(final FileSystem.Cache cache, final int count)\n \n     // acquire the semaphore so blocking all FS instances from\n     // being initialized.\n-    Semaphore semaphore = BlockingInitializer.sem;\n+    Semaphore semaphore = BlockingInitializer.SEM;\n     semaphore.acquire();\n \n-    // su\n     for (int i = 0; i < count; i++) {\n       futures.add(pool.submit(\n           () -> cache.get(uri, conf)));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NTQzNg==", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r515755436", "bodyText": "What if close() throw IOException ?\nEven it has cached object, it will not return that.", "author": "surendralilhore", "createdAt": "2020-11-02T06:04:54Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "diffHunk": "@@ -3517,33 +3546,86 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n       if (fs != null) {\n         return fs;\n       }\n-\n-      fs = createFileSystem(uri, conf);\n-      final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n-          SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n-          ShutdownHookManager.TIME_UNIT_DEFAULT);\n-      synchronized (this) { // refetch the lock again\n-        FileSystem oldfs = map.get(key);\n-        if (oldfs != null) { // a file system is created while lock is releasing\n-          fs.close(); // close the new file system\n-          return oldfs;  // return the old file system\n-        }\n-\n-        // now insert the new file system into the map\n-        if (map.isEmpty()\n-                && !ShutdownHookManager.get().isShutdownInProgress()) {\n-          ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n-              SHUTDOWN_HOOK_PRIORITY, timeout,\n-              ShutdownHookManager.TIME_UNIT_DEFAULT);\n+      // fs not yet created, acquire lock\n+      // to construct an instance.\n+      try (DurationInfo d = new DurationInfo(LOGGER, false,\n+          \"Acquiring creator semaphore for %s\", uri)) {\n+        creatorPermits.acquire();\n+      } catch (InterruptedException e) {\n+        // acquisition was interrupted; convert to an IOE.\n+        throw (IOException)new InterruptedIOException(e.toString())\n+            .initCause(e);\n+      }\n+      FileSystem fsToClose = null;\n+      try {\n+        // See if FS was instantiated by another thread while waiting\n+        // for the permit.\n+        synchronized (this) {\n+          fs = map.get(key);\n         }\n-        fs.key = key;\n-        map.put(key, fs);\n-        if (conf.getBoolean(\n-            FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n-          toAutoClose.add(key);\n+        if (fs != null) {\n+          LOGGER.debug(\"Filesystem {} created while awaiting semaphore\", uri);\n+          return fs;\n         }\n-        return fs;\n+        // create the filesystem\n+        fs = createFileSystem(uri, conf);\n+        final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n+            SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n+            ShutdownHookManager.TIME_UNIT_DEFAULT);\n+        // any FS to close outside of the synchronized section\n+        synchronized (this) { // lock on the Cache object\n+\n+          // see if there is now an entry for the FS, which happens\n+          // if another thread's creation overlapped with this one.\n+          FileSystem oldfs = map.get(key);\n+          if (oldfs != null) {\n+            // a file system was created in a separate thread.\n+            // save the FS reference to close outside all locks,\n+            // and switch to returning the oldFS\n+            fsToClose = fs;\n+            fs = oldfs;\n+          } else {\n+            // register the clientFinalizer if needed and shutdown isn't\n+            // already active\n+            if (map.isEmpty()\n+                && !ShutdownHookManager.get().isShutdownInProgress()) {\n+              ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n+                  SHUTDOWN_HOOK_PRIORITY, timeout,\n+                  ShutdownHookManager.TIME_UNIT_DEFAULT);\n+            }\n+            // insert the new file system into the map\n+            fs.key = key;\n+            map.put(key, fs);\n+            if (conf.getBoolean(\n+                FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n+              toAutoClose.add(key);\n+            }\n+          }\n+        } // end of synchronized block\n+      } finally {\n+        // release the creator permit.\n+        creatorPermits.release();\n       }\n+      if (fsToClose != null) {\n+        LOGGER.debug(\"Duplicate FS created for {}; discarding {}\",\n+            uri, fs);\n+        discardedInstances.incrementAndGet();\n+        // close the new file system\n+        // note this will briefly remove and reinstate \"fsToClose\" from\n+        // the map. It is done in a synchronized block so will not be\n+        // visible to others.\n+        fsToClose.close();", "originalCommit": "fa4b65df4bd9118bb2caadc9d3b2e6756bf1dfc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyMzkzNQ==", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r518923935", "bodyText": "That is an interesting thought. I just left that code as is, but yes, it could fail\nLooking at FileSystem.close, the removal of the entry from the cache should be in a finally clause too, shouldn't it. ouch. Ignoring that for now.\nHow about I go to IOUtils.close() & catch and log on failures.", "author": "steveloughran", "createdAt": "2020-11-06T18:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NTQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU2MjI1NQ==", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r519562255", "bodyText": "Looking at FileSystem.close, the removal of the entry from the cache should be in a finally clause too, shouldn't it. ouch. Ignoring that for now.\n\nI feel not required, processDeleteOnExit() already catching the IOException.\n\nHow about I go to IOUtils.close() & catch and log on failures.\n\nI didn't get this, are you planning to use IOUtils.close() to close filesystem instance ?", "author": "surendralilhore", "createdAt": "2020-11-09T05:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NTQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgxOTkxNw==", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r519819917", "bodyText": "I feel not required, processDeleteOnExit() already catching the IOException.\n\nyes, but look at the subclasses", "author": "steveloughran", "createdAt": "2020-11-09T13:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NTQzNg=="}], "type": "inlineReview", "revised_code": {"commit": "40f9e9892a1e2d3c6c42002a0d2025837b20e2aa", "chunk": "diff --git a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java\nindex 522d9de9a29..e814b3da915 100644\n--- a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java\n+++ b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java\n\n@@ -3614,7 +3618,7 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n         // note this will briefly remove and reinstate \"fsToClose\" from\n         // the map. It is done in a synchronized block so will not be\n         // visible to others.\n-        fsToClose.close();\n+        IOUtils.cleanupWithLogger(LOGGER, fsToClose);\n       }\n       return fs;\n     }\n"}}, {"oid": "40f9e9892a1e2d3c6c42002a0d2025837b20e2aa", "url": "https://github.com/apache/hadoop/commit/40f9e9892a1e2d3c6c42002a0d2025837b20e2aa", "message": "HADOOP-17313. Better handling of close() in FileSystem.get()\n\nif, in FileSystem.get(), a superfluous instance is closed(), exceptions\nthere are swallowed.\n\nAlso: put the deregistration of the class from the cache into a finally\nblock, so even if a subclass's processDeleteOnExit code raises any exception,\nthe filesystem is removed from the cache\n\nChange-Id: I513215fe266bbad7a864481d0505cc9073a7c35a", "committedDate": "2020-11-17T15:20:12Z", "type": "forcePushed"}, {"oid": "5c41240ae3e5aba1375fcb1402ea0a08b6b646ee", "url": "https://github.com/apache/hadoop/commit/5c41240ae3e5aba1375fcb1402ea0a08b6b646ee", "message": "HADOOP-17313. Better handling of close() in FileSystem.get()\n\nif, in FileSystem.get(), a superfluous instance is closed(), exceptions\nthere are swallowed.\n\nAlso: put the deregistration of the class from the cache into a finally\nblock, so even if a subclass's processDeleteOnExit code raises any exception,\nthe filesystem is removed from the cache\n\nChange-Id: I513215fe266bbad7a864481d0505cc9073a7c35a", "committedDate": "2020-11-19T14:59:16Z", "type": "forcePushed"}, {"oid": "ae7695463ebcc5978523af20196feba423061d0b", "url": "https://github.com/apache/hadoop/commit/ae7695463ebcc5978523af20196feba423061d0b", "message": "HADOOP-17313. FileSystem.get to support slow-to-instantiate FS clients.\n\nAdds a semaphore to throttle the #of parallel clients which can be\ncreated simultaneously, set in \"fs.creation.parallel.count\".\n\nChange-Id: I794cecac4a23ae7e1aa376e16b4085ea5ae20086", "committedDate": "2020-11-23T15:52:01Z", "type": "commit"}, {"oid": "b64a1b39d57cbf0282ed486567663d08ca7b4915", "url": "https://github.com/apache/hadoop/commit/b64a1b39d57cbf0282ed486567663d08ca7b4915", "message": "HADOOP-17313. Semaphored FS instantiation.\n\n* Move FileSystem.close() outside the semaphored block, so\n  it does not hold up other threads.\n* Tests which use the count of discarded instances for their\n  assertions.\n\nChange-Id: I4dfaf6f2a327142048438b1bfa4c4517e595df50", "committedDate": "2020-11-23T15:52:01Z", "type": "commit"}, {"oid": "8e91d96bab9eccdb448cd48e6c4611fecfe1fa9d", "url": "https://github.com/apache/hadoop/commit/8e91d96bab9eccdb448cd48e6c4611fecfe1fa9d", "message": "HADOOP-17313: FileSystem caching.\n\n* Address Mehakmeet's comments\n* Checkstyles\n* And document in s3 performance file\n\nChange-Id: I9568f980f4e9917448a1d4d1c7c2d070a6f28bad", "committedDate": "2020-11-23T15:52:02Z", "type": "commit"}, {"oid": "788a73b34e567bc42ea05178e0c6060000be1e0d", "url": "https://github.com/apache/hadoop/commit/788a73b34e567bc42ea05178e0c6060000be1e0d", "message": "HADOOP-17313. Better handling of close() in FileSystem.get()\n\nif, in FileSystem.get(), a superfluous instance is closed(), exceptions\nthere are swallowed.\n\nAlso: put the deregistration of the class from the cache into a finally\nblock, so even if a subclass's processDeleteOnExit code raises any exception,\nthe filesystem is removed from the cache\n\nChange-Id: I513215fe266bbad7a864481d0505cc9073a7c35a", "committedDate": "2020-11-23T15:52:02Z", "type": "commit"}, {"oid": "788a73b34e567bc42ea05178e0c6060000be1e0d", "url": "https://github.com/apache/hadoop/commit/788a73b34e567bc42ea05178e0c6060000be1e0d", "message": "HADOOP-17313. Better handling of close() in FileSystem.get()\n\nif, in FileSystem.get(), a superfluous instance is closed(), exceptions\nthere are swallowed.\n\nAlso: put the deregistration of the class from the cache into a finally\nblock, so even if a subclass's processDeleteOnExit code raises any exception,\nthe filesystem is removed from the cache\n\nChange-Id: I513215fe266bbad7a864481d0505cc9073a7c35a", "committedDate": "2020-11-23T15:52:02Z", "type": "forcePushed"}]}