{"pr_number": 8699, "pr_title": "ISPN-11176 Xsite Max Idle", "pr_createdAt": "2020-09-17T16:11:32Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8699", "timeline": [{"oid": "2eb9d8811c5c6b3c12462c24ffb29de70460d51a", "url": "https://github.com/infinispan/infinispan/commit/2eb9d8811c5c6b3c12462c24ffb29de70460d51a", "message": "ISPN-12337 Clustered Expiration can deadlock with Pessimistic Tx on a non owner", "committedDate": "2020-09-17T19:54:29Z", "type": "forcePushed"}, {"oid": "fada47639ef487654143532eb32e0e84f62f40cc", "url": "https://github.com/infinispan/infinispan/commit/fada47639ef487654143532eb32e0e84f62f40cc", "message": "ISPN-12337 Clustered Expiration can deadlock with Pessimistic Tx on a non owner", "committedDate": "2020-09-21T14:02:12Z", "type": "forcePushed"}, {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7", "url": "https://github.com/infinispan/infinispan/commit/77ae2bce5a7f84055893424ebca447555505b7d7", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors", "committedDate": "2020-09-24T05:01:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA3OTg3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495079876", "bodyText": "since the method is exposed to users, I would check <0 instead.", "author": "pruivo", "createdAt": "2020-09-25T15:52:07Z", "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -1218,6 +1220,24 @@ public String toString() {\n       return \"Cache '\" + name + \"'@\" + (config != null && config.clustering().cacheMode().isClustered() ? getRpcManager().getAddress() : Util.hexIdHashCode(getCacheManager()));\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return touch(key, -1, touchEvenIfExpired, 0);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      return touch(key, segment, touchEvenIfExpired, 0);\n+   }\n+\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired, long flagBitSet) {\n+      if (segment == -1) {", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk4NTA3MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495985071", "bodyText": "Sure", "author": "wburns", "createdAt": "2020-09-28T14:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA3OTg3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "405a8b2b22032e146866a8f8dca8515df4882200", "chunk": "diff --git a/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java b/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\nindex 6348cd3447..273ddc6384 100644\n--- a/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\n+++ b/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\n\n@@ -1222,16 +1222,16 @@ public String toString() {\n \n    @Override\n    public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n-      return touch(key, -1, touchEvenIfExpired, 0);\n+      return touch(key, -1, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);\n    }\n \n    @Override\n    public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n-      return touch(key, segment, touchEvenIfExpired, 0);\n+      return touch(key, segment, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);\n    }\n \n    public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired, long flagBitSet) {\n-      if (segment == -1) {\n+      if (segment < 0) {\n          segment = keyPartitioner.getSegment(key);\n       }\n       TouchCommand command = commandsFactory.buildTouchCommand(key, segment, touchEvenIfExpired, flagBitSet);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MDIzOA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495080238", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return touch(key, -1, touchEvenIfExpired, 0);\n          \n          \n            \n                  return touch(key, -1, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);", "author": "pruivo", "createdAt": "2020-09-25T15:52:40Z", "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -1218,6 +1220,24 @@ public String toString() {\n       return \"Cache '\" + name + \"'@\" + (config != null && config.clustering().cacheMode().isClustered() ? getRpcManager().getAddress() : Util.hexIdHashCode(getCacheManager()));\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return touch(key, -1, touchEvenIfExpired, 0);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk4NTE1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495985155", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-09-28T14:32:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MDIzOA=="}], "type": "inlineReview", "revised_code": {"commit": "405a8b2b22032e146866a8f8dca8515df4882200", "chunk": "diff --git a/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java b/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\nindex 6348cd3447..273ddc6384 100644\n--- a/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\n+++ b/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\n\n@@ -1222,16 +1222,16 @@ public String toString() {\n \n    @Override\n    public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n-      return touch(key, -1, touchEvenIfExpired, 0);\n+      return touch(key, -1, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);\n    }\n \n    @Override\n    public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n-      return touch(key, segment, touchEvenIfExpired, 0);\n+      return touch(key, segment, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);\n    }\n \n    public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired, long flagBitSet) {\n-      if (segment == -1) {\n+      if (segment < 0) {\n          segment = keyPartitioner.getSegment(key);\n       }\n       TouchCommand command = commandsFactory.buildTouchCommand(key, segment, touchEvenIfExpired, flagBitSet);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MDUxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495080511", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return touch(key, segment, touchEvenIfExpired, 0);\n          \n          \n            \n                  return touch(key, segment, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);", "author": "pruivo", "createdAt": "2020-09-25T15:53:07Z", "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -1218,6 +1220,24 @@ public String toString() {\n       return \"Cache '\" + name + \"'@\" + (config != null && config.clustering().cacheMode().isClustered() ? getRpcManager().getAddress() : Util.hexIdHashCode(getCacheManager()));\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return touch(key, -1, touchEvenIfExpired, 0);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      return touch(key, segment, touchEvenIfExpired, 0);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk4NTIyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495985225", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-09-28T14:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MDUxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "405a8b2b22032e146866a8f8dca8515df4882200", "chunk": "diff --git a/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java b/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\nindex 6348cd3447..273ddc6384 100644\n--- a/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\n+++ b/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\n\n@@ -1222,16 +1222,16 @@ public String toString() {\n \n    @Override\n    public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n-      return touch(key, -1, touchEvenIfExpired, 0);\n+      return touch(key, -1, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);\n    }\n \n    @Override\n    public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n-      return touch(key, segment, touchEvenIfExpired, 0);\n+      return touch(key, segment, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);\n    }\n \n    public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired, long flagBitSet) {\n-      if (segment == -1) {\n+      if (segment < 0) {\n          segment = keyPartitioner.getSegment(key);\n       }\n       TouchCommand command = commandsFactory.buildTouchCommand(key, segment, touchEvenIfExpired, flagBitSet);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTI3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495081273", "bodyText": "use -1 as  segment?", "author": "pruivo", "createdAt": "2020-09-25T15:54:20Z", "path": "core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java", "diffHunk": "@@ -390,6 +392,26 @@ public void setAvailability(AvailabilityMode availabilityMode) {\n       throw new UnsupportedOperationException();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      int segment = keyPartitioner.getSegment(key);\n+      return touch(key, segment, touchEvenIfExpired);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTU1NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495081554", "bodyText": "ps. Objects.requireNonNull() isn't required here. the other method checks it.", "author": "pruivo", "createdAt": "2020-09-25T15:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk4NTUzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495985539", "bodyText": "I was just being consistent with the rest of the SimpleCacheImpl methods.", "author": "wburns", "createdAt": "2020-09-28T14:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAwOTc1NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496009754", "bodyText": "But now that I look again, I agree it isn't required.", "author": "wburns", "createdAt": "2020-09-28T15:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTI3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "405a8b2b22032e146866a8f8dca8515df4882200", "chunk": "diff --git a/core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java b/core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java\nindex b4ae59c0cc..e1989db756 100644\n--- a/core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java\n+++ b/core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java\n\n@@ -394,14 +394,15 @@ public void setAvailability(AvailabilityMode availabilityMode) {\n \n    @Override\n    public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n-      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n-      int segment = keyPartitioner.getSegment(key);\n-      return touch(key, segment, touchEvenIfExpired);\n+      return touch(key, -1, touchEvenIfExpired);\n    }\n \n    @Override\n    public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n       Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      if (segment < 0) {\n+         segment = keyPartitioner.getSegment(key);\n+      }\n       InternalCacheEntry<K, V> entry = dataContainer.peek(segment, key);\n       if (entry != null) {\n          long currentTime = timeService.wallClockTime();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4Mjk2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495082967", "bodyText": "check if segment is valid?\nofftopic, would be good to have an \"utility\" method like\nint requireValidSegment(Object k, int segment, KeyPartitioner p) {\n  return segment if segement in [0..numSegments] else p.getSegment(k)\n}", "author": "pruivo", "createdAt": "2020-09-25T15:57:01Z", "path": "core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java", "diffHunk": "@@ -390,6 +392,26 @@ public void setAvailability(AvailabilityMode availabilityMode) {\n       throw new UnsupportedOperationException();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      int segment = keyPartitioner.getSegment(key);\n+      return touch(key, segment, touchEvenIfExpired);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      InternalCacheEntry<K, V> entry = dataContainer.peek(segment, key);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAxNDQwMA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496014400", "bodyText": "I added a segment < 0 check.", "author": "wburns", "createdAt": "2020-09-28T15:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4Mjk2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "405a8b2b22032e146866a8f8dca8515df4882200", "chunk": "diff --git a/core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java b/core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java\nindex b4ae59c0cc..e1989db756 100644\n--- a/core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java\n+++ b/core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java\n\n@@ -394,14 +394,15 @@ public void setAvailability(AvailabilityMode availabilityMode) {\n \n    @Override\n    public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n-      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n-      int segment = keyPartitioner.getSegment(key);\n-      return touch(key, segment, touchEvenIfExpired);\n+      return touch(key, -1, touchEvenIfExpired);\n    }\n \n    @Override\n    public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n       Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      if (segment < 0) {\n+         segment = keyPartitioner.getSegment(key);\n+      }\n       InternalCacheEntry<K, V> entry = dataContainer.peek(segment, key);\n       if (entry != null) {\n          long currentTime = timeService.wallClockTime();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NDczNw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495084737", "bodyText": "question: is the flag bitset used?", "author": "pruivo", "createdAt": "2020-09-25T15:59:40Z", "path": "core/src/main/java/org/infinispan/commands/CommandsFactoryImpl.java", "diffHunk": "@@ -694,8 +695,8 @@ public CheckTransactionRpcCommand buildCheckTransactionRpcCommand(Collection<Glo\n    }\n \n    @Override\n-   public TouchCommand buildTouchCommand(Object key, int segment) {\n-      return new TouchCommand(cacheName, key, segment);\n+   public TouchCommand buildTouchCommand(Object key, int segment, boolean touchEvenIfExpired, long flagBitSet) {\n+      return new TouchCommand(key, segment, flagBitSet, touchEvenIfExpired);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5NjQ4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495996486", "bodyText": "Not currently, the idea was we may at some point want a LOCAL forced touch for example.", "author": "wburns", "createdAt": "2020-09-28T14:47:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NDczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5NzAyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496197025", "bodyText": "yeah, I was just worried if the user invokes the touch() with some weird flags (like, skip remote)", "author": "pruivo", "createdAt": "2020-09-28T19:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NDczNw=="}], "type": "inlineReview", "revised_code": {"commit": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "chunk": "diff --git a/core/src/main/java/org/infinispan/commands/CommandsFactoryImpl.java b/core/src/main/java/org/infinispan/commands/CommandsFactoryImpl.java\nindex b7e1e4992b..019e4c3950 100644\n--- a/core/src/main/java/org/infinispan/commands/CommandsFactoryImpl.java\n+++ b/core/src/main/java/org/infinispan/commands/CommandsFactoryImpl.java\n\n@@ -695,8 +695,8 @@ public CheckTransactionRpcCommand buildCheckTransactionRpcCommand(Collection<Glo\n    }\n \n    @Override\n-   public TouchCommand buildTouchCommand(Object key, int segment, boolean touchEvenIfExpired, long flagBitSet) {\n-      return new TouchCommand(key, segment, flagBitSet, touchEvenIfExpired);\n+   public TouchCommand buildTouchCommand(Object key, int segment) {\n+      return new TouchCommand(cacheName, key, segment);\n    }\n \n    @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4Nzg3MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495087871", "bodyText": "shouldn't be sent to the primary owner?", "author": "pruivo", "createdAt": "2020-09-25T16:05:03Z", "path": "core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java", "diffHunk": "@@ -257,6 +260,25 @@ private XSiteStatePushCommand newStatePushCommand(List<XSiteState> stateList) {\n       return defaultHandler.cache().clearAsync();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touchEntry(Object key) {\n+      int segment = clusteringDependentLogic.getCacheTopology().getSegment(key);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAwNDgyMA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496004820", "bodyText": "Hrmm, yeah this should invoke the touch command. Let me do that.", "author": "wburns", "createdAt": "2020-09-28T14:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4Nzg3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "405a8b2b22032e146866a8f8dca8515df4882200", "chunk": "diff --git a/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java b/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java\nindex 6a576ef708..40f6e05724 100644\n--- a/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java\n+++ b/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java\n\n@@ -262,21 +261,7 @@ private XSiteStatePushCommand newStatePushCommand(List<XSiteState> stateList) {\n \n    @Override\n    public CompletionStage<Boolean> touchEntry(Object key) {\n-      int segment = clusteringDependentLogic.getCacheTopology().getSegment(key);\n-      InternalCacheEntry<Object, Object> entry = dataContainer.peek(segment, key);\n-      long currentTime = timeService.wallClockTime();\n-      if (entry == null || entry.isExpired(currentTime)) {\n-         if (trace) {\n-            log.tracef(\"Entry was not found or is expired for key %s\", key);\n-         }\n-         return CompletableFutures.completedFalse();\n-      }\n-      // TODO: do we touch other nodes in this cluster?\n-      if (trace) {\n-         log.tracef(\"Entry was found and wasn't expired for key %s\", key);\n-      }\n-      dataContainer.touch(segment, key, currentTime);\n-      return CompletableFutures.completedTrue();\n+      return cache.getAdvancedCache().touch(key, false);\n    }\n \n    private CompletionStage<Void> invokeRemotelyInLocalSite(CacheRpcCommand command) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4OTE1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495089157", "bodyText": "can you revert this and remove the `componentRegistry' field? I know I'm complaining just to save 8 bytes eh eh", "author": "pruivo", "createdAt": "2020-09-25T16:07:25Z", "path": "core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java", "diffHunk": "@@ -126,9 +130,8 @@ public ClusteredCacheBackupReceiver(String cacheName) {\n    public void start() {\n       //it would be nice if we could inject bootstrap component\n       //this feels kind hacky but saves 3 fields in this class\n-      ComponentRegistry cr = cache.getAdvancedCache().getComponentRegistry();\n-      TransactionHandler txHandler = new TransactionHandler(cache, cr.getTransactionTable());\n-      defaultHandler = new DefaultHandler(txHandler, cr.getComponent(BlockingManager.class));\n+      TransactionHandler txHandler = new TransactionHandler(cache, componentRegistry.getTransactionTable());", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAwMDUxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496000511", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-09-28T14:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4OTE1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "405a8b2b22032e146866a8f8dca8515df4882200", "chunk": "diff --git a/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java b/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java\nindex 6a576ef708..40f6e05724 100644\n--- a/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java\n+++ b/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java\n\n@@ -130,8 +128,9 @@ public ClusteredCacheBackupReceiver(String cacheName) {\n    public void start() {\n       //it would be nice if we could inject bootstrap component\n       //this feels kind hacky but saves 3 fields in this class\n-      TransactionHandler txHandler = new TransactionHandler(cache, componentRegistry.getTransactionTable());\n-      defaultHandler = new DefaultHandler(txHandler, componentRegistry.getComponent(BlockingManager.class));\n+      ComponentRegistry cr = cache.getAdvancedCache().getComponentRegistry();\n+      TransactionHandler txHandler = new TransactionHandler(cache, cr.getTransactionTable());\n+      defaultHandler = new DefaultHandler(txHandler, cr.getComponent(BlockingManager.class));\n    }\n \n    @Override\n"}}, {"oid": "405a8b2b22032e146866a8f8dca8515df4882200", "url": "https://github.com/infinispan/infinispan/commit/405a8b2b22032e146866a8f8dca8515df4882200", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors", "committedDate": "2020-09-28T19:46:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5ODU5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496198591", "bodyText": "nit: no longer used. can be removed.", "author": "pruivo", "createdAt": "2020-09-28T19:59:30Z", "path": "core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java", "diffHunk": "@@ -111,7 +113,7 @@\n    @Inject InvocationContextFactory invocationContextFactory;\n    @Inject RpcManager rpcManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n-   @Inject ComponentRegistry componentRegistry;\n+   @Inject InternalDataContainer<Object, Object> dataContainer;", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java b/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java\nindex 40f6e05724..d58ae4b0ee 100644\n--- a/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java\n+++ b/core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java\n\n@@ -113,7 +112,6 @@\n    @Inject InvocationContextFactory invocationContextFactory;\n    @Inject RpcManager rpcManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n-   @Inject InternalDataContainer<Object, Object> dataContainer;\n \n    private final ByteString cacheName;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwMjM2MA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496202360", "bodyText": "is it ok to use 0 as a segment? shouldn't be -1 since 0 is valid? or split the entries per segment.\nAre you plan to use the segment in the future? currently isn't used and could be removed.", "author": "pruivo", "createdAt": "2020-09-28T20:07:07Z", "path": "core/src/main/java/org/infinispan/container/impl/DefaultDataContainer.java", "diffHunk": "@@ -233,4 +232,10 @@ public void cleanUp() {\n          evictionCache.cleanUp();\n       }\n    }\n+\n+\n+   @Override\n+   public void forEachSegment(ObjIntConsumer<PeekableTouchableMap<K, V>> segmentMapConsumer) {\n+      segmentMapConsumer.accept(entries, 0);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2Njk4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496766982", "bodyText": "The point is to iterate over all the various segmented maps of the container. I can't see having the API not have the segment.\nAnd the reason for 0 is because this container has a single map. This is inline with what the SingleSegmentKeyPartitioner does as well.", "author": "wburns", "createdAt": "2020-09-29T14:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwMjM2MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496204828", "bodyText": "I'm not sure if this is correct. setting isWrite = hasLock will skip the max-idle expiration check. is it intentional?\nIn a pessimisitc transaction, you can lock a key never write to it.", "author": "pruivo", "createdAt": "2020-09-28T20:12:03Z", "path": "core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java", "diffHunk": "@@ -84,7 +85,7 @@ public void init() {\n             }\n          } else if (isOwner || readEntry.isL1Entry()) {\n             if (readEntry.canExpire()) {\n-               CompletionStage<Boolean> expiredStage = expirationManager.handlePossibleExpiration(readEntry, segment, false);\n+               CompletionStage<Boolean> expiredStage = expirationManager.handlePossibleExpiration(readEntry, segment, hasLock);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2ODUwMw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496768503", "bodyText": "It doesn't skip the max-idle expiration check. What it does is change the flags on the cache that the remove (max idle | lifespan) expired command is invoked on. For pessimistic transactions if it already has the lock we can't fire the expiration command and get a lock as it is already held.\nhttps://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/expiration/impl/TxClusterExpirationManager.java#L37", "author": "wburns", "createdAt": "2020-09-29T14:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwNjk1NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496906954", "bodyText": "I'm looking at https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java#L261\nin pessimistic cache, checkExpiredMaxIdle(ice, segment) isn't invoked because isWrite==true", "author": "pruivo", "createdAt": "2020-09-29T17:15:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwNzk3NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496907974", "bodyText": "That is because the entry wasn't expired. In this case we don't want to touch the entry on a write as it will be overwritten anyways.", "author": "wburns", "createdAt": "2020-09-29T17:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMTE0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496931146", "bodyText": "yeah, but a get+force_write_lock doesn't mean the key will be written in the transaction. Not sure if I'm making my concern clear...", "author": "pruivo", "createdAt": "2020-09-29T17:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQxMzM3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r497413376", "bodyText": "I made the following test: https://github.com/pruivo/infinispan/blob/8d5d98492df393c344fe2707dcd12dcf7498464f/core/src/test/java/org/infinispan/expiration/impl/MaxIdlePessimisticTxTest.java\n\ntx read + rollback, touches the key (it makes senses IMO)\ntx write + rollback, doesn't touch the key (it should IMO)\ntx read on expired key +  rollback, StackOverflowException (bug!) org.infinispan.expiration.impl.ClusterExpirationManager.entryExpiredInMemory\ntx write on expired key +  rollback, it is fine!", "author": "pruivo", "createdAt": "2020-09-30T10:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxMTIyMA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498311220", "bodyText": "So I am changing my mind on #2. Originally max idle didn't block the user read operation, but now it does so I don't believe it makes any sense any longer.\n#3 is because we need to pass the hasLock variable on a read when using Pessimistic tx with WRITE_LOCK flag present. So it isn't just any tx read :)", "author": "wburns", "createdAt": "2020-10-01T14:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}], "type": "inlineReview", "revised_code": {"commit": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "chunk": "diff --git a/core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java b/core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java\nindex e95de5a98b..088e3fac08 100644\n--- a/core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java\n+++ b/core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java\n\n@@ -85,7 +84,7 @@ public void init() {\n             }\n          } else if (isOwner || readEntry.isL1Entry()) {\n             if (readEntry.canExpire()) {\n-               CompletionStage<Boolean> expiredStage = expirationManager.handlePossibleExpiration(readEntry, segment, hasLock);\n+               CompletionStage<Boolean> expiredStage = expirationManager.handlePossibleExpiration(readEntry, segment, false);\n                if (CompletionStages.isCompletedSuccessfully(expiredStage)) {\n                   Boolean expired = CompletionStages.join(expiredStage);\n                   handleExpiredEntryContextAddition(expired, ctx, readEntry, key, isOwner);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNTQ0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496205446", "bodyText": "segment=0 here too. same comment as somewhere above :)", "author": "pruivo", "createdAt": "2020-09-28T20:13:17Z", "path": "core/src/main/java/org/infinispan/container/offheap/OffHeapDataContainer.java", "diffHunk": "@@ -107,4 +108,9 @@ public int sizeIncludingExpired() {\n    public void clear() {\n       map.clear();\n    }\n+\n+   @Override\n+   public void forEachSegment(ObjIntConsumer<PeekableTouchableMap<WrappedBytes, WrappedBytes>> segmentMapConsumer) {\n+      segmentMapConsumer.accept(map, 0);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2ODc1NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496768754", "bodyText": "I think 0 is the correct value as this is what we do for other cases when we don't have segmentation.", "author": "wburns", "createdAt": "2020-09-29T14:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNTQ0Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNjM5MA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496206390", "bodyText": "typo:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               private Map<String, TopologyIracVersion> getVectorFunctiton(Integer s,\n          \n          \n            \n               private Map<String, TopologyIracVersion> getVectorFunction(Integer s,", "author": "pruivo", "createdAt": "2020-09-28T20:15:15Z", "path": "core/src/main/java/org/infinispan/container/versioning/irac/DefaultIracVersionGenerator.java", "diffHunk": "@@ -112,6 +118,15 @@ public void removeTombstone(Object key) {\n       }\n    }\n \n+   private Map<String, TopologyIracVersion> getVectorFunctiton(Integer s,", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/main/java/org/infinispan/container/versioning/irac/DefaultIracVersionGenerator.java b/core/src/main/java/org/infinispan/container/versioning/irac/DefaultIracVersionGenerator.java\nindex 326a321a5b..91367d2457 100644\n--- a/core/src/main/java/org/infinispan/container/versioning/irac/DefaultIracVersionGenerator.java\n+++ b/core/src/main/java/org/infinispan/container/versioning/irac/DefaultIracVersionGenerator.java\n\n@@ -118,7 +118,7 @@ public void removeTombstone(Object key) {\n       }\n    }\n \n-   private Map<String, TopologyIracVersion> getVectorFunctiton(Integer s,\n+   private Map<String, TopologyIracVersion> getVectorFunction(Integer s,\n                                                                Map<String, TopologyIracVersion> versions) {\n       if (versions == null) {\n          return Collections.singletonMap(localSite, TopologyIracVersion.newVersion(topologyId));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwODY5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496208691", "bodyText": "hmm, I thought the cache stored in ComponentRegistry didn't have any encoding...", "author": "pruivo", "createdAt": "2020-09-28T20:20:02Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -99,6 +88,9 @@ public void start() {\n                   expWakeUpInt, expWakeUpInt, TimeUnit.MILLISECONDS);\n          }\n       }\n+      // Data container entries are retrieved directly, so we don't need to worry about an encodings\n+      this.cache = AbstractDelegatingCache.unwrapCache(cacheRef.wired()).getAdvancedCache();", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MDgzMw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496770833", "bodyText": "It used to, believe it still does. This was just moved over from the ClusterExpirationManager as they both use the cache instance now.", "author": "wburns", "createdAt": "2020-09-29T14:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwODY5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "chunk": "diff --git a/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java b/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java\nindex 8826e8c1de..18ba9b01d7 100644\n--- a/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java\n+++ b/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java\n\n@@ -88,9 +99,6 @@ public void start() {\n                   expWakeUpInt, expWakeUpInt, TimeUnit.MILLISECONDS);\n          }\n       }\n-      // Data container entries are retrieved directly, so we don't need to worry about an encodings\n-      this.cache = AbstractDelegatingCache.unwrapCache(cacheRef.wired()).getAdvancedCache();\n-      this.cacheName = cache.getName();\n    }\n \n    @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMjYyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496212621", "bodyText": "why? this will trigger unnecessary replication and xsite replications.", "author": "pruivo", "createdAt": "2020-09-28T20:27:56Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java", "diffHunk": "@@ -592,8 +593,11 @@ public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredComm\n          } else if (trace) {\n             log.trace(\"Cannot remove entry as its lifespan or value do not match\");\n          }\n-      } else if (trace) {\n-         log.trace(\"Nothing to remove since the entry doesn't exist in the context or it is already removed\");\n+      } else {\n+         if (trace) {\n+            log.trace(\"Nothing to remove since the entry doesn't exist in the context or it is already removed - assume command was successful\");", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MTY3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496771679", "bodyText": "We don't want to let something like an eviction to cause the expiration command to fail. If the value isn't present we have to assume it can be expired.", "author": "wburns", "createdAt": "2020-09-29T14:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMjYyMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNDI0MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496214241", "bodyText": "why returning Boolean.FALSE? it is something I'm not used to seeing very often.", "author": "pruivo", "createdAt": "2020-09-28T20:30:59Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java", "diffHunk": "@@ -1115,6 +1119,32 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n       return returns;\n    }\n \n+   @Override\n+   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n+      int segment = command.getSegment();\n+      Object key = command.getKey();\n+      InternalCacheEntry<?, ?> ice = dataContainer.peek(segment, key);\n+      if (ice == null) {\n+         if (trace) {\n+            log.tracef(\"Entry was not in the container to touch for key %s\", key);\n+         }\n+         return Boolean.FALSE;", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MTk5MA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496771990", "bodyText": "It will be boxed anyways, may as well be explicit :)", "author": "wburns", "createdAt": "2020-09-29T14:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNDI0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "chunk": "diff --git a/core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java b/core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java\nindex 1db940691e..66f5da1604 100644\n--- a/core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java\n+++ b/core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java\n\n@@ -1119,32 +1118,6 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n       return returns;\n    }\n \n-   @Override\n-   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n-      int segment = command.getSegment();\n-      Object key = command.getKey();\n-      InternalCacheEntry<?, ?> ice = dataContainer.peek(segment, key);\n-      if (ice == null) {\n-         if (trace) {\n-            log.tracef(\"Entry was not in the container to touch for key %s\", key);\n-         }\n-         return Boolean.FALSE;\n-      }\n-      long currentTime = timeService.wallClockTime();\n-\n-      if (command.isTouchEvenIfExpired() || !ice.isExpired(currentTime)) {\n-         boolean touched = dataContainer.touch(segment, key, currentTime);\n-         if (trace) {\n-            log.tracef(\"Entry was touched: %s for key %s.\", touched, key);\n-         }\n-         return touched;\n-      }\n-      if (trace) {\n-         log.tracef(\"Entry was expired for key %s and we could not touch it.\", key);\n-      }\n-      return Boolean.FALSE;\n-   }\n-\n    private void updateStoreFlags(FlagAffectedCommand command, MVCCEntry e) {\n       if (command.hasAnyFlag(FlagBitSets.SKIP_SHARED_CACHE_STORE)) {\n          e.setSkipSharedStore();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496215548", "bodyText": "I'm wondering if we could invoke touch() directly to avoid multiple gets (get segment map and get key twice)", "author": "pruivo", "createdAt": "2020-09-28T20:33:34Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java", "diffHunk": "@@ -1115,6 +1119,32 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n       return returns;\n    }\n \n+   @Override\n+   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n+      int segment = command.getSegment();\n+      Object key = command.getKey();\n+      InternalCacheEntry<?, ?> ice = dataContainer.peek(segment, key);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MzAyMw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496773023", "bodyText": "No, unfortunately. We don't want to touch in the case of isTouchEvenIfExpired is false. We could have different code paths where if this is true we just call peek if you really wanted though.", "author": "wburns", "createdAt": "2020-09-29T14:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwODc0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496908742", "bodyText": "isTouchEvenIfExpired could be a parameter :)", "author": "pruivo", "createdAt": "2020-09-29T17:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxMDA1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496910052", "bodyText": "Hrmm? It is in the TouchCommand.", "author": "wburns", "createdAt": "2020-09-29T17:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMDQ1NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496930454", "bodyText": "I mean DataContainer.touch(segment, key, currentTime,command.isTouchEvenIfExpired())", "author": "pruivo", "createdAt": "2020-09-29T17:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzNjY0NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496936644", "bodyText": "Hrmm, sure, that could work.", "author": "wburns", "createdAt": "2020-09-29T18:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA=="}], "type": "inlineReview", "revised_code": {"commit": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "chunk": "diff --git a/core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java b/core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java\nindex 1db940691e..66f5da1604 100644\n--- a/core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java\n+++ b/core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java\n\n@@ -1119,32 +1118,6 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n       return returns;\n    }\n \n-   @Override\n-   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n-      int segment = command.getSegment();\n-      Object key = command.getKey();\n-      InternalCacheEntry<?, ?> ice = dataContainer.peek(segment, key);\n-      if (ice == null) {\n-         if (trace) {\n-            log.tracef(\"Entry was not in the container to touch for key %s\", key);\n-         }\n-         return Boolean.FALSE;\n-      }\n-      long currentTime = timeService.wallClockTime();\n-\n-      if (command.isTouchEvenIfExpired() || !ice.isExpired(currentTime)) {\n-         boolean touched = dataContainer.touch(segment, key, currentTime);\n-         if (trace) {\n-            log.tracef(\"Entry was touched: %s for key %s.\", touched, key);\n-         }\n-         return touched;\n-      }\n-      if (trace) {\n-         log.tracef(\"Entry was expired for key %s and we could not touch it.\", key);\n-      }\n-      return Boolean.FALSE;\n-   }\n-\n    private void updateStoreFlags(FlagAffectedCommand command, MVCCEntry e) {\n       if (command.hasAnyFlag(FlagBitSets.SKIP_SHARED_CACHE_STORE)) {\n          e.setSkipSharedStore();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNzI1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496217252", "bodyText": "hmmm, I still think it should use the IracMetadata stored in the context's CacheEntry\nEven if \"this key\" isn't changed, the segment version will always move.", "author": "pruivo", "createdAt": "2020-09-28T20:36:49Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java", "diffHunk": "@@ -194,7 +189,13 @@ private void visitKey(Object key, WriteCommand command) {\n       if (getOwnership(segment) != Ownership.PRIMARY) {\n          return;\n       }\n-      IracMetadata metadata = iracVersionGenerator.generateNewMetadata(segment);\n+      IracMetadata metadata;\n+      // RemoveExpired should lose to any other conflicting write\n+      if (command instanceof RemoveExpiredCommand) {\n+         metadata = iracVersionGenerator.generateMetadataWithCurrentVersion(segment);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzNDQ3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496834475", "bodyText": "I have done a mixture, because unfortunately with eviction it is possible the entry is not in the container as well.", "author": "wburns", "createdAt": "2020-09-29T15:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNzI1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java b/core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java\nindex 53a8733f58..bb4cc04f69 100644\n--- a/core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java\n+++ b/core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java\n\n@@ -184,15 +186,23 @@ private boolean skipCommand(InvocationContext ctx, FlagAffectedCommand command)\n     * <p>\n     * The primary owner generates a new {@link IracMetadata} and stores it in the {@link WriteCommand}.\n     */\n-   private void visitKey(Object key, WriteCommand command) {\n+   private void visitKey(InvocationContext ctx, Object key, WriteCommand command) {\n       int segment = getSegment(command, key);\n       if (getOwnership(segment) != Ownership.PRIMARY) {\n          return;\n       }\n-      IracMetadata metadata;\n+      IracMetadata metadata = null;\n       // RemoveExpired should lose to any other conflicting write\n       if (command instanceof RemoveExpiredCommand) {\n-         metadata = iracVersionGenerator.generateMetadataWithCurrentVersion(segment);\n+         CacheEntry<?, ?> ce = ctx.lookupEntry(key);\n+         PrivateMetadata pm = ce.getInternalMetadata();\n+         if (pm != null) {\n+            metadata = pm.iracMetadata();\n+         }\n+\n+         if (metadata == null) {\n+            metadata = iracVersionGenerator.generateMetadataWithCurrentVersion(segment);\n+         }\n       } else {\n          metadata = iracVersionGenerator.generateNewMetadata(segment);\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTI1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496219259", "bodyText": "Use the handleExpiredReturn field and the rCommand\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                           return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);\n          \n          \n            \n                           return invokeNextThenAccept(rCtx, rCommand, handleExpiredReturn);", "author": "pruivo", "createdAt": "2020-09-28T20:40:44Z", "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -51,6 +56,38 @@ Object invokeNextAndWaitForCrossSite(TxInvocationContext<?> ctx, VisitableComman\n       return invokeNextThenApply(ctx, command, stage::thenReturn);\n    }\n \n+   @Override\n+   public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredCommand command) {\n+      if (skipXSiteBackup(command) || !command.isMaxIdle()) {\n+         return invokeNext(ctx, command);\n+      }\n+      // Max idle command shouldn't fail as the timestamps are updated on access, however the remote site may have\n+      // a read that we aren't aware of - so we must synchronously remove the entry if expired on the remote site\n+      // and if it isn't expired on the remote site we must update the access time locally here\n+      int segment = command.getSegment();\n+      DistributionInfo dInfo = clusteringDependentLogic.getCacheTopology().getSegmentDistribution(segment);\n+      // Only require primary to check remote site and add to irac queue - If primary dies then a backup will end up\n+      // doing the same as promoted primary - We also don't add tracked up to backup as we don't care if the\n+      // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n+      if (dInfo.isPrimary()) {\n+         CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n+         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {\n+            if ((Boolean) rv) {\n+               return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NDE4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496774186", "bodyText": "Did you want me to make the lambda an object as well? :D I personally don't think it is worth it as this shouldn't happen that often.", "author": "wburns", "createdAt": "2020-09-29T14:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NDc1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496774751", "bodyText": "Oh you mention that below :)", "author": "wburns", "createdAt": "2020-09-29T14:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTI1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java b/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java\nindex 5645750e87..9a155c215b 100644\n--- a/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java\n+++ b/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java\n\n@@ -71,17 +72,19 @@ public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredComm\n       // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n       if (dInfo.isPrimary()) {\n          CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n-         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {\n-            if ((Boolean) rv) {\n-               return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);\n-            }\n-            command.fail();\n-            return rv;\n-         });\n+         return asyncValue(expired).thenApply(ctx, command, handleBackupMaxIdle);\n       }\n       return invokeNext(ctx, command);\n    }\n \n+   private Object handleBackupMaxIdle(InvocationContext rCtx, RemoveExpiredCommand rCommand, Object rv) {\n+      if ((Boolean) rv) {\n+         return invokeNextThenAccept(rCtx, rCommand, handleExpiredReturn);\n+      }\n+      rCommand.fail();\n+      return rv;\n+   }\n+\n    private void handleExpiredReturn(InvocationContext context, RemoveExpiredCommand command, Object returnValue) {\n       if (command.isSuccessful()) {\n          iracManager.trackUpdatedKey(command.getKey(), command.getCommandInvocationId());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTM1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496219355", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        command.fail();\n          \n          \n            \n                        rCommand.fail();", "author": "pruivo", "createdAt": "2020-09-28T20:40:56Z", "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -51,6 +56,38 @@ Object invokeNextAndWaitForCrossSite(TxInvocationContext<?> ctx, VisitableComman\n       return invokeNextThenApply(ctx, command, stage::thenReturn);\n    }\n \n+   @Override\n+   public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredCommand command) {\n+      if (skipXSiteBackup(command) || !command.isMaxIdle()) {\n+         return invokeNext(ctx, command);\n+      }\n+      // Max idle command shouldn't fail as the timestamps are updated on access, however the remote site may have\n+      // a read that we aren't aware of - so we must synchronously remove the entry if expired on the remote site\n+      // and if it isn't expired on the remote site we must update the access time locally here\n+      int segment = command.getSegment();\n+      DistributionInfo dInfo = clusteringDependentLogic.getCacheTopology().getSegmentDistribution(segment);\n+      // Only require primary to check remote site and add to irac queue - If primary dies then a backup will end up\n+      // doing the same as promoted primary - We also don't add tracked up to backup as we don't care if the\n+      // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n+      if (dInfo.isPrimary()) {\n+         CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n+         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {\n+            if ((Boolean) rv) {\n+               return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);\n+            }\n+            command.fail();", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java b/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java\nindex 5645750e87..9a155c215b 100644\n--- a/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java\n+++ b/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java\n\n@@ -71,17 +72,19 @@ public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredComm\n       // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n       if (dInfo.isPrimary()) {\n          CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n-         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {\n-            if ((Boolean) rv) {\n-               return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);\n-            }\n-            command.fail();\n-            return rv;\n-         });\n+         return asyncValue(expired).thenApply(ctx, command, handleBackupMaxIdle);\n       }\n       return invokeNext(ctx, command);\n    }\n \n+   private Object handleBackupMaxIdle(InvocationContext rCtx, RemoveExpiredCommand rCommand, Object rv) {\n+      if ((Boolean) rv) {\n+         return invokeNextThenAccept(rCtx, rCommand, handleExpiredReturn);\n+      }\n+      rCommand.fail();\n+      return rv;\n+   }\n+\n    private void handleExpiredReturn(InvocationContext context, RemoveExpiredCommand command, Object returnValue) {\n       if (command.isSuccessful()) {\n          iracManager.trackUpdatedKey(command.getKey(), command.getCommandInvocationId());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTYwNw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496219607", "bodyText": "this lambda could be cached", "author": "pruivo", "createdAt": "2020-09-28T20:41:27Z", "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -51,6 +56,38 @@ Object invokeNextAndWaitForCrossSite(TxInvocationContext<?> ctx, VisitableComman\n       return invokeNextThenApply(ctx, command, stage::thenReturn);\n    }\n \n+   @Override\n+   public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredCommand command) {\n+      if (skipXSiteBackup(command) || !command.isMaxIdle()) {\n+         return invokeNext(ctx, command);\n+      }\n+      // Max idle command shouldn't fail as the timestamps are updated on access, however the remote site may have\n+      // a read that we aren't aware of - so we must synchronously remove the entry if expired on the remote site\n+      // and if it isn't expired on the remote site we must update the access time locally here\n+      int segment = command.getSegment();\n+      DistributionInfo dInfo = clusteringDependentLogic.getCacheTopology().getSegmentDistribution(segment);\n+      // Only require primary to check remote site and add to irac queue - If primary dies then a backup will end up\n+      // doing the same as promoted primary - We also don't add tracked up to backup as we don't care if the\n+      // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n+      if (dInfo.isPrimary()) {\n+         CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n+         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4MDA3MA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496780070", "bodyText": "I personally don't think it is worth it given how infrequently it should be called, but I can add it in.", "author": "wburns", "createdAt": "2020-09-29T14:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTYwNw=="}], "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java b/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java\nindex 5645750e87..9a155c215b 100644\n--- a/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java\n+++ b/core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java\n\n@@ -71,17 +72,19 @@ public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredComm\n       // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n       if (dInfo.isPrimary()) {\n          CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n-         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {\n-            if ((Boolean) rv) {\n-               return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);\n-            }\n-            command.fail();\n-            return rv;\n-         });\n+         return asyncValue(expired).thenApply(ctx, command, handleBackupMaxIdle);\n       }\n       return invokeNext(ctx, command);\n    }\n \n+   private Object handleBackupMaxIdle(InvocationContext rCtx, RemoveExpiredCommand rCommand, Object rv) {\n+      if ((Boolean) rv) {\n+         return invokeNextThenAccept(rCtx, rCommand, handleExpiredReturn);\n+      }\n+      rCommand.fail();\n+      return rv;\n+   }\n+\n    private void handleExpiredReturn(InvocationContext context, RemoveExpiredCommand command, Object returnValue) {\n       if (command.isSuccessful()) {\n          iracManager.trackUpdatedKey(command.getKey(), command.getCommandInvocationId());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMzUxNA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496223514", "bodyText": "unused", "author": "pruivo", "createdAt": "2020-09-28T20:49:02Z", "path": "core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java", "diffHunk": "@@ -52,6 +56,9 @@\n    @Inject Configuration config;\n    @Inject EventLogManager eventLogManager;\n    @Inject RpcManager rpcManager;\n+   @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   @Inject Executor nonBlockingExecutor;", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java b/core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java\nindex a536824d0e..200dad99ec 100644\n--- a/core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java\n+++ b/core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java\n\n@@ -56,8 +53,6 @@\n    @Inject Configuration config;\n    @Inject EventLogManager eventLogManager;\n    @Inject RpcManager rpcManager;\n-   @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n-   @Inject Executor nonBlockingExecutor;\n    @Inject InternalDataContainer<Object, Object> dataContainer;\n \n    public DefaultTakeOfflineManager(String cacheName) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMzg1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496223857", "bodyText": "you could have created a touchAll() and avoid some lambdas :)", "author": "pruivo", "createdAt": "2020-09-28T20:49:42Z", "path": "core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java", "diffHunk": "@@ -197,6 +204,10 @@ public void siteOnline() {\n       @Override\n       public void siteOffline() {\n          getEventLogger().info(EventLogCategory.CLUSTER, MESSAGES.siteOffline(siteName));\n+         log.debug(\"Touching all in memory entries as a site has gone offline\");\n+         long currentTimeMillis = timeService.wallClockTime();\n+         dataContainer.forEachSegment((map, segment) ->", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4MTkyMg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496781922", "bodyText": "Hrmm, yeah we can add that to the PeekableTouchableMap interface :)", "author": "wburns", "createdAt": "2020-09-29T14:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMzg1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java b/core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java\nindex a536824d0e..200dad99ec 100644\n--- a/core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java\n+++ b/core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java\n\n@@ -206,8 +201,7 @@ public void siteOffline() {\n          getEventLogger().info(EventLogCategory.CLUSTER, MESSAGES.siteOffline(siteName));\n          log.debug(\"Touching all in memory entries as a site has gone offline\");\n          long currentTimeMillis = timeService.wallClockTime();\n-         dataContainer.forEachSegment((map, segment) ->\n-                 map.forEach((k, v) -> map.touchKey(k, currentTimeMillis)));\n+         dataContainer.forEachSegment((map, segment) -> map.touchAll(currentTimeMillis));\n       }\n \n       @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNDUxNg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496224516", "bodyText": "is this intentional? couldn't just invoke touch(key, -1, touchEvenIfExpired)", "author": "pruivo", "createdAt": "2020-09-28T20:51:01Z", "path": "core/src/test/java/org/infinispan/functional/decorators/FunctionalAdvancedCache.java", "diffHunk": "@@ -282,6 +282,16 @@ public void start() {\n       cache.start();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      return cache.touch(key, segment, touchEvenIfExpired);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return null;", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5OTQwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496799409", "bodyText": "I changed it.", "author": "wburns", "createdAt": "2020-09-29T15:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNDUxNg=="}], "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/test/java/org/infinispan/functional/decorators/FunctionalAdvancedCache.java b/core/src/test/java/org/infinispan/functional/decorators/FunctionalAdvancedCache.java\nindex 154edb21a7..9494acfcd7 100644\n--- a/core/src/test/java/org/infinispan/functional/decorators/FunctionalAdvancedCache.java\n+++ b/core/src/test/java/org/infinispan/functional/decorators/FunctionalAdvancedCache.java\n\n@@ -289,7 +289,7 @@ public void start() {\n \n    @Override\n    public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n-      return null;\n+      return cache.touch(key, -1, touchEvenIfExpired);\n    }\n \n    ////////////////////////////////////////////////////////////////////////////\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNjk5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496226991", "bodyText": "why checking \"k\"?", "author": "pruivo", "createdAt": "2020-09-28T20:55:50Z", "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMDM4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496800389", "bodyText": "Refactoring mistake, thought I had removed it.", "author": "wburns", "createdAt": "2020-09-29T15:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNjk5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java b/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\nindex b0c376398d..ce58ddeaff 100644\n--- a/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\n+++ b/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\n\n@@ -14,6 +14,8 @@\n import org.infinispan.configuration.cache.CacheMode;\n import org.infinispan.configuration.cache.ConfigurationBuilder;\n import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.container.impl.InternalDataContainer;\n import org.infinispan.distribution.MagicKey;\n import org.infinispan.test.TestingUtil;\n import org.infinispan.transaction.LockingMode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNzI4Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496227287", "bodyText": "shouldn't check if backupCache also returns null?", "author": "pruivo", "createdAt": "2020-09-28T20:56:21Z", "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));\n+      eventuallyEquals(\"v\", () -> backup(LON).get(key));\n+\n+      // Now expire the entry\n+      timeService.advance(TimeUnit.SECONDS.toMillis(2));\n+      assertNull(cache.get(key));", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMDg4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496800889", "bodyText": "Sure", "author": "wburns", "createdAt": "2020-09-29T15:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNzI4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java b/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\nindex b0c376398d..ce58ddeaff 100644\n--- a/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\n+++ b/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\n\n@@ -14,6 +14,8 @@\n import org.infinispan.configuration.cache.CacheMode;\n import org.infinispan.configuration.cache.ConfigurationBuilder;\n import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.container.impl.InternalDataContainer;\n import org.infinispan.distribution.MagicKey;\n import org.infinispan.test.TestingUtil;\n import org.infinispan.transaction.LockingMode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNzQ4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496227486", "bodyText": "InterruptedExceptionnever thrown", "author": "pruivo", "createdAt": "2020-09-28T20:56:43Z", "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java b/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\nindex b0c376398d..ce58ddeaff 100644\n--- a/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\n+++ b/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\n\n@@ -14,6 +14,8 @@\n import org.infinispan.configuration.cache.CacheMode;\n import org.infinispan.configuration.cache.ConfigurationBuilder;\n import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.container.impl.InternalDataContainer;\n import org.infinispan.distribution.MagicKey;\n import org.infinispan.test.TestingUtil;\n import org.infinispan.transaction.LockingMode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNzU1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496227553", "bodyText": "InterruptedExceptionnever thrown", "author": "pruivo", "createdAt": "2020-09-28T20:56:50Z", "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));\n+      eventuallyEquals(\"v\", () -> backup(LON).get(key));\n+\n+      // Now expire the entry\n+      timeService.advance(TimeUnit.SECONDS.toMillis(2));\n+      assertNull(cache.get(key));\n+\n+      // TODO: check for the touch command being invoked on the remote site for lifespan = false\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testMaxIdleWithRecentAccess(boolean readFromWrittenSite, boolean readOnAccessedSite) throws InterruptedException {", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java b/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\nindex b0c376398d..ce58ddeaff 100644\n--- a/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\n+++ b/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\n\n@@ -14,6 +14,8 @@\n import org.infinispan.configuration.cache.CacheMode;\n import org.infinispan.configuration.cache.ConfigurationBuilder;\n import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.container.impl.InternalDataContainer;\n import org.infinispan.distribution.MagicKey;\n import org.infinispan.test.TestingUtil;\n import org.infinispan.transaction.LockingMode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMDYwMA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496230600", "bodyText": "actually, I would inspect the DataContainer to ensure the InternalCacheEntry's lastUsed is the expected value", "author": "pruivo", "createdAt": "2020-09-28T21:02:40Z", "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));\n+      eventuallyEquals(\"v\", () -> backup(LON).get(key));\n+\n+      // Now expire the entry\n+      timeService.advance(TimeUnit.SECONDS.toMillis(2));\n+      assertNull(cache.get(key));\n+\n+      // TODO: check for the touch command being invoked on the remote site for lifespan = false", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMzY2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496803669", "bodyText": "Yeah, that is what I meant by it actually.", "author": "wburns", "createdAt": "2020-09-29T15:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMDYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNTM5OA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496815398", "bodyText": "I moved it up a bit before the expiration to verify the last access was correct.", "author": "wburns", "createdAt": "2020-09-29T15:29:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMDYwMA=="}], "type": "inlineReview", "revised_code": {"commit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "chunk": "diff --git a/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java b/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\nindex b0c376398d..ce58ddeaff 100644\n--- a/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\n+++ b/core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java\n\n@@ -14,6 +14,8 @@\n import org.infinispan.configuration.cache.CacheMode;\n import org.infinispan.configuration.cache.ConfigurationBuilder;\n import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.container.impl.InternalDataContainer;\n import org.infinispan.distribution.MagicKey;\n import org.infinispan.test.TestingUtil;\n import org.infinispan.transaction.LockingMode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMjk2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496232961", "bodyText": "what does sync/async mean here? the xsite is async only in this class.", "author": "pruivo", "createdAt": "2020-09-28T21:07:15Z", "path": "core/src/test/java/org/infinispan/xsite/irac/Irac3SitesConflictTest.java", "diffHunk": "@@ -30,32 +37,159 @@\n    private static final int CLUSTER_SIZE = 3;\n    private final List<ManualIracManager> iracManagerList;\n \n+   private ConfigMode configMode;\n+\n+   public Irac3SitesConflictTest configMode(ConfigMode configMode) {\n+      this.configMode = configMode;\n+      return this;\n+   }\n+\n+   private enum ConfigMode {\n+      NON_TX,\n+      PESSIMISTIC_TX,\n+      OPTIMISTIC_TX_RC,\n+      OPTIMISTIC_TX_RR,\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<Irac3SitesConflictTest> tests = new ArrayList<>();\n+      for (ConfigMode configMode : ConfigMode.values()) {\n+         tests.add(new Irac3SitesConflictTest().configMode(configMode));\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"configMode\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{configMode};\n+   }\n+\n    protected Irac3SitesConflictTest() {\n       this.iracManagerList = new ArrayList<>(N_SITES * CLUSTER_SIZE);\n    }\n \n    public void testPutIfAbsent(Method method) {\n-      doTest(method, TestOperation.PUT_IF_ABSENT);\n+      doTest(method, new TestOperationInterop(TestOperation.PUT_IF_ABSENT));\n    }\n \n    public void testPut(Method method) {\n-      doTest(method, TestOperation.PUT);\n+      doTest(method, new TestOperationInterop(TestOperation.PUT));\n    }\n \n    public void testReplace(Method method) {\n-      doTest(method, TestOperation.REPLACE);\n+      doTest(method, new TestOperationInterop(TestOperation.REPLACE));\n    }\n \n    public void testConditionalReplace(Method method) {\n-      doTest(method, TestOperation.REPLACE_CONDITIONAL);\n+      doTest(method, new TestOperationInterop(TestOperation.REPLACE_CONDITIONAL));\n    }\n \n    public void testRemove(Method method) {\n-      doTest(method, TestOperation.REMOVE);\n+      doTest(method, new TestOperationInterop(TestOperation.REMOVE));\n    }\n \n    public void testConditionalRemove(Method method) {\n-      doTest(method, TestOperation.REMOVE_CONDITIONAL);\n+      doTest(method, new TestOperationInterop(TestOperation.REMOVE_CONDITIONAL));\n+   }\n+\n+   // TODO: need to do this still?\n+   //   public void testMaxIdleExpirationASync(Method method) {", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMTg3Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496801877", "bodyText": "I meant the remove expired command itself. The test waits for its completion. If it didn't then we could have a remove expired and other puts running concurrently.", "author": "wburns", "createdAt": "2020-09-29T15:15:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMjk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyOTMxMg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496929312", "bodyText": "I'm not sure if it matters. the IracManager is blocking everything until the end. You don't have the remove/put going to the other sites.", "author": "pruivo", "createdAt": "2020-09-29T17:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMjk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMjc3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496932773", "bodyText": "It shouldn't block the invoking thread. It returns a CompletionStage.", "author": "wburns", "createdAt": "2020-09-29T17:57:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMjk2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "chunk": "diff --git a/core/src/test/java/org/infinispan/xsite/irac/Irac3SitesConflictTest.java b/core/src/test/java/org/infinispan/xsite/irac/Irac3SitesConflictTest.java\nindex b0fa35f81e..a2c935dc90 100644\n--- a/core/src/test/java/org/infinispan/xsite/irac/Irac3SitesConflictTest.java\n+++ b/core/src/test/java/org/infinispan/xsite/irac/Irac3SitesConflictTest.java\n\n@@ -104,21 +103,7 @@ public void testConditionalRemove(Method method) {\n //   }\n //\n    public void testMaxIdleExpirationSync(Method method) {\n-      doTest(method, new RemoveExpiredOperation(replaceTimeService()));\n-   }\n-\n-   private ControlledTimeService replaceTimeService() {\n-      ControlledTimeService timeService = new ControlledTimeService();\n-      for (int i = 0; i < N_SITES; i++) {\n-         String siteName = siteName(i);\n-         for (int j = 0; j < CLUSTER_SIZE; ++j) {\n-            Cache<?, ?> c = cache(siteName, j);\n-            // Max idle requires all caches to show it as expired to be removed.\n-            TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n-         }\n-      }\n-\n-      return timeService;\n+      doTest(method, new RemoveExpiredOperation());\n    }\n \n    interface IracTestOperation {\n"}}, {"oid": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "url": "https://github.com/infinispan/infinispan/commit/65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "message": "rework comments", "committedDate": "2020-09-29T15:51:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNTI4MA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496915280", "bodyText": "can be removed. it is available in super class", "author": "pruivo", "createdAt": "2020-09-29T17:29:02Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -70,21 +63,16 @@\n     */\n    private static final int MAX_CONCURRENT_EXPIRATIONS = 100;\n \n-   @Inject protected ComponentRef<AdvancedCache<K, V>> cacheRef;\n    @Inject protected RpcManager rpcManager;\n    @Inject protected DistributionManager distributionManager;\n \n-   protected AdvancedCache<K, V> cache;\n    private Address localAddress;\n    private long timeout;\n    private String cacheName;", "originalCommit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "294f4f142999a94e8e025ae1b1aea1c89452f429", "chunk": "diff --git a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\nindex 3de84c8137..cc80577ad7 100644\n--- a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n+++ b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n\n@@ -68,7 +68,6 @@\n \n    private Address localAddress;\n    private long timeout;\n-   private String cacheName;\n \n    @Override\n    public void start() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMjcxNA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496922714", "bodyText": "why do you need to wait for the remote operation? can't you return touchedLocally directly?", "author": "pruivo", "createdAt": "2020-09-29T17:41:11Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/ClusteringInterceptor.java", "diffHunk": "@@ -34,6 +48,120 @@\n    @Inject protected InternalDataContainer dataContainer;\n    @Inject protected DistributionManager distributionManager;\n \n+   protected LocalizedCacheTopology checkTopologyId(TopologyAffectedCommand command) {\n+      LocalizedCacheTopology cacheTopology = distributionManager.getCacheTopology();\n+      int currentTopologyId = cacheTopology.getTopologyId();\n+      int cmdTopology = command.getTopologyId();\n+      if (command instanceof FlagAffectedCommand && ((((FlagAffectedCommand) command).hasAnyFlag(FlagBitSets.SKIP_OWNERSHIP_CHECK | FlagBitSets.CACHE_MODE_LOCAL)))) {\n+         getLog().tracef(\"Skipping topology check for command %s\", command);\n+         return cacheTopology;\n+      }\n+      if (trace) {\n+         getLog().tracef(\"Current topology %d, command topology %d\", currentTopologyId, cmdTopology);\n+      }\n+      if (cmdTopology >= 0 && currentTopologyId != cmdTopology) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n+      }\n+      return cacheTopology;\n+   }\n+\n+   private static abstract class AbstractTouchResponseCollector extends ValidResponseCollector<Boolean> {\n+      @Override\n+      protected Boolean addTargetNotFound(Address sender) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n+      }\n+\n+      @Override\n+      protected Boolean addException(Address sender, Exception exception) {\n+         if (exception instanceof CacheException) {\n+            throw (CacheException) exception;\n+         }\n+         throw new CacheException(exception);\n+      }\n+\n+      @Override\n+      protected final Boolean addValidResponse(Address sender, ValidResponse response) {\n+         return (Boolean) response.getResponseValue();\n+      }\n+\n+      abstract Boolean addBooleanResponse(Address sender, Boolean response);\n+   }\n+\n+   private static class ScatteredTouchResponseCollector extends AbstractTouchResponseCollector {\n+\n+      private static final ScatteredTouchResponseCollector INSTANCE = new ScatteredTouchResponseCollector();\n+\n+      @Override\n+      public Boolean finish() {\n+         // No other node was touched\n+         return Boolean.FALSE;\n+      }\n+\n+      @Override\n+      protected Boolean addBooleanResponse(Address sender, Boolean response) {\n+         if (response == Boolean.TRUE) {\n+            // Return early if any node touched the value - as SCATTERED only exists on a single backup!\n+            // TODO: what if the read was when one of the backups or primary died?\n+            return Boolean.TRUE;\n+         }\n+         return null;\n+      }\n+   }\n+\n+   private static class TouchResponseCollector extends AbstractTouchResponseCollector {\n+\n+      private static final TouchResponseCollector INSTANCE = new TouchResponseCollector();\n+\n+      @Override\n+      public Boolean finish() {\n+         // If all were touched, then the value isn't expired\n+         return Boolean.TRUE;\n+      }\n+\n+      @Override\n+      protected Boolean addBooleanResponse(Address sender, Boolean response) {\n+         if (response == Boolean.FALSE) {\n+            // Return early if any value wasn't touched!\n+            return Boolean.FALSE;\n+         }\n+         return null;\n+      }\n+   }\n+\n+   @Override\n+   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n+      if (isLocalModeForced(command)) {\n+         return invokeNext(ctx, command);\n+      }\n+      LocalizedCacheTopology cacheTopology = checkTopologyId(command);\n+      DistributionInfo info = cacheTopology.getSegmentDistribution(command.getSegment());\n+\n+      if (info.isPrimary()) {\n+         boolean isScattered = cacheConfiguration.clustering().cacheMode().isScattered();\n+         // Scattered any node could be a backup, so we have to touch all members\n+         List<Address> owners = isScattered ? cacheTopology.getActualMembers() : info.readOwners();\n+         AbstractTouchResponseCollector collector = isScattered ? ScatteredTouchResponseCollector.INSTANCE :\n+               TouchResponseCollector.INSTANCE;\n+         CompletionStage<Boolean> remoteInvocation = rpcManager.invokeCommand(owners, command, collector,\n+               rpcManager.getSyncRpcOptions());\n+         return invokeNextThenApply(ctx, command, (rCtx, rCommand, rValue) -> {\n+            Boolean touchedLocally = (Boolean) rValue;\n+            Boolean collectedResponse = collector.addBooleanResponse(null, touchedLocally);\n+            if (collectedResponse != null) {\n+               return asyncValue(remoteInvocation.thenApply(ignore -> touchedLocally));", "originalCommit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzNDU0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496934549", "bodyText": "It needs to be sync to maintain the cluster max idle guarantees that if a node goes down after a touch that it won't expire early.", "author": "wburns", "createdAt": "2020-09-29T18:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMjcxNA=="}], "type": "inlineReview", "revised_code": {"commit": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "chunk": "diff --git a/core/src/main/java/org/infinispan/interceptors/impl/ClusteringInterceptor.java b/core/src/main/java/org/infinispan/interceptors/impl/ClusteringInterceptor.java\nindex c7f595677f..d51c16d7d1 100644\n--- a/core/src/main/java/org/infinispan/interceptors/impl/ClusteringInterceptor.java\n+++ b/core/src/main/java/org/infinispan/interceptors/impl/ClusteringInterceptor.java\n\n@@ -48,120 +34,6 @@\n    @Inject protected InternalDataContainer dataContainer;\n    @Inject protected DistributionManager distributionManager;\n \n-   protected LocalizedCacheTopology checkTopologyId(TopologyAffectedCommand command) {\n-      LocalizedCacheTopology cacheTopology = distributionManager.getCacheTopology();\n-      int currentTopologyId = cacheTopology.getTopologyId();\n-      int cmdTopology = command.getTopologyId();\n-      if (command instanceof FlagAffectedCommand && ((((FlagAffectedCommand) command).hasAnyFlag(FlagBitSets.SKIP_OWNERSHIP_CHECK | FlagBitSets.CACHE_MODE_LOCAL)))) {\n-         getLog().tracef(\"Skipping topology check for command %s\", command);\n-         return cacheTopology;\n-      }\n-      if (trace) {\n-         getLog().tracef(\"Current topology %d, command topology %d\", currentTopologyId, cmdTopology);\n-      }\n-      if (cmdTopology >= 0 && currentTopologyId != cmdTopology) {\n-         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n-      }\n-      return cacheTopology;\n-   }\n-\n-   private static abstract class AbstractTouchResponseCollector extends ValidResponseCollector<Boolean> {\n-      @Override\n-      protected Boolean addTargetNotFound(Address sender) {\n-         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n-      }\n-\n-      @Override\n-      protected Boolean addException(Address sender, Exception exception) {\n-         if (exception instanceof CacheException) {\n-            throw (CacheException) exception;\n-         }\n-         throw new CacheException(exception);\n-      }\n-\n-      @Override\n-      protected final Boolean addValidResponse(Address sender, ValidResponse response) {\n-         return (Boolean) response.getResponseValue();\n-      }\n-\n-      abstract Boolean addBooleanResponse(Address sender, Boolean response);\n-   }\n-\n-   private static class ScatteredTouchResponseCollector extends AbstractTouchResponseCollector {\n-\n-      private static final ScatteredTouchResponseCollector INSTANCE = new ScatteredTouchResponseCollector();\n-\n-      @Override\n-      public Boolean finish() {\n-         // No other node was touched\n-         return Boolean.FALSE;\n-      }\n-\n-      @Override\n-      protected Boolean addBooleanResponse(Address sender, Boolean response) {\n-         if (response == Boolean.TRUE) {\n-            // Return early if any node touched the value - as SCATTERED only exists on a single backup!\n-            // TODO: what if the read was when one of the backups or primary died?\n-            return Boolean.TRUE;\n-         }\n-         return null;\n-      }\n-   }\n-\n-   private static class TouchResponseCollector extends AbstractTouchResponseCollector {\n-\n-      private static final TouchResponseCollector INSTANCE = new TouchResponseCollector();\n-\n-      @Override\n-      public Boolean finish() {\n-         // If all were touched, then the value isn't expired\n-         return Boolean.TRUE;\n-      }\n-\n-      @Override\n-      protected Boolean addBooleanResponse(Address sender, Boolean response) {\n-         if (response == Boolean.FALSE) {\n-            // Return early if any value wasn't touched!\n-            return Boolean.FALSE;\n-         }\n-         return null;\n-      }\n-   }\n-\n-   @Override\n-   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n-      if (isLocalModeForced(command)) {\n-         return invokeNext(ctx, command);\n-      }\n-      LocalizedCacheTopology cacheTopology = checkTopologyId(command);\n-      DistributionInfo info = cacheTopology.getSegmentDistribution(command.getSegment());\n-\n-      if (info.isPrimary()) {\n-         boolean isScattered = cacheConfiguration.clustering().cacheMode().isScattered();\n-         // Scattered any node could be a backup, so we have to touch all members\n-         List<Address> owners = isScattered ? cacheTopology.getActualMembers() : info.readOwners();\n-         AbstractTouchResponseCollector collector = isScattered ? ScatteredTouchResponseCollector.INSTANCE :\n-               TouchResponseCollector.INSTANCE;\n-         CompletionStage<Boolean> remoteInvocation = rpcManager.invokeCommand(owners, command, collector,\n-               rpcManager.getSyncRpcOptions());\n-         return invokeNextThenApply(ctx, command, (rCtx, rCommand, rValue) -> {\n-            Boolean touchedLocally = (Boolean) rValue;\n-            Boolean collectedResponse = collector.addBooleanResponse(null, touchedLocally);\n-            if (collectedResponse != null) {\n-               return asyncValue(remoteInvocation.thenApply(ignore -> touchedLocally));\n-            }\n-            return asyncValue(remoteInvocation);\n-         });\n-      } else if (ctx.isOriginLocal()) {\n-         // Send to the primary owner\n-         CompletionStage<ValidResponse> remoteInvocation = rpcManager.invokeCommand(info.primary(), command,\n-               SingleResponseCollector.validOnly(), rpcManager.getSyncRpcOptions());\n-         return asyncValue(remoteInvocation)\n-               .thenApply(ctx, command, (rCtx, rCommand, rResponse) -> ((ValidResponse) rResponse).getResponseValue());\n-      }\n-      return invokeNext(ctx, command);\n-   }\n-\n    protected static SuccessfulResponse getSuccessfulResponseOrFail(Map<Address, Response> responseMap, CompletableFuture<?> future, Consumer<Response> cacheNotFound) {\n       Iterator<Map.Entry<Address, Response>> it = responseMap.entrySet().iterator();\n       if (!it.hasNext()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNDI5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496924293", "bodyText": "I'm going to take some time to think about this... not 100% convinced eh eh\nalso, you could check iracVersionGenerator.getTombstone(key); before invoking the \"generate\" method", "author": "pruivo", "createdAt": "2020-09-29T17:43:43Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java", "diffHunk": "@@ -189,12 +186,26 @@ private boolean skipCommand(InvocationContext ctx, FlagAffectedCommand command)\n     * <p>\n     * The primary owner generates a new {@link IracMetadata} and stores it in the {@link WriteCommand}.\n     */\n-   private void visitKey(Object key, WriteCommand command) {\n+   private void visitKey(InvocationContext ctx, Object key, WriteCommand command) {\n       int segment = getSegment(command, key);\n       if (getOwnership(segment) != Ownership.PRIMARY) {\n          return;\n       }\n-      IracMetadata metadata = iracVersionGenerator.generateNewMetadata(segment);\n+      IracMetadata metadata = null;\n+      // RemoveExpired should lose to any other conflicting write\n+      if (command instanceof RemoveExpiredCommand) {\n+         CacheEntry<?, ?> ce = ctx.lookupEntry(key);\n+         PrivateMetadata pm = ce.getInternalMetadata();\n+         if (pm != null) {\n+            metadata = pm.iracMetadata();\n+         }\n+\n+         if (metadata == null) {\n+            metadata = iracVersionGenerator.generateMetadataWithCurrentVersion(segment);", "originalCommit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzNDc1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496934757", "bodyText": "Sure, I trust you on it ;)", "author": "wburns", "createdAt": "2020-09-29T18:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNDI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQzNTU2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r497435565", "bodyText": "I'm writing a test to make sure it is correct... but now I have a question. why do you need to send the remove to the remote site?\norg.infinispan.xsite.irac.IracManager#checkAndTrackExpiration() already makes sure the key is expired everywhere. You can avoid sending the remove expired to the remote site and let them expired the key locally when they access it (or by the expiration reaper?).\nAm I missing something?", "author": "pruivo", "createdAt": "2020-09-30T11:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNDI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNDgzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498304835", "bodyText": "We technically don't have to, but it seemed better for us just to send a single IRAC remove expired command instead of waiting for the other site to see the value is expired then ask the original site if it is expired synchronously again.", "author": "wburns", "createdAt": "2020-10-01T14:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNDI5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "chunk": "diff --git a/core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java b/core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java\nindex bb4cc04f69..53a8733f58 100644\n--- a/core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java\n+++ b/core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java\n\n@@ -186,23 +184,15 @@ private boolean skipCommand(InvocationContext ctx, FlagAffectedCommand command)\n     * <p>\n     * The primary owner generates a new {@link IracMetadata} and stores it in the {@link WriteCommand}.\n     */\n-   private void visitKey(InvocationContext ctx, Object key, WriteCommand command) {\n+   private void visitKey(Object key, WriteCommand command) {\n       int segment = getSegment(command, key);\n       if (getOwnership(segment) != Ownership.PRIMARY) {\n          return;\n       }\n-      IracMetadata metadata = null;\n+      IracMetadata metadata;\n       // RemoveExpired should lose to any other conflicting write\n       if (command instanceof RemoveExpiredCommand) {\n-         CacheEntry<?, ?> ce = ctx.lookupEntry(key);\n-         PrivateMetadata pm = ce.getInternalMetadata();\n-         if (pm != null) {\n-            metadata = pm.iracMetadata();\n-         }\n-\n-         if (metadata == null) {\n-            metadata = iracVersionGenerator.generateMetadataWithCurrentVersion(segment);\n-         }\n+         metadata = iracVersionGenerator.generateMetadataWithCurrentVersion(segment);\n       } else {\n          metadata = iracVersionGenerator.generateNewMetadata(segment);\n       }\n"}}, {"oid": "294f4f142999a94e8e025ae1b1aea1c89452f429", "url": "https://github.com/infinispan/infinispan/commit/294f4f142999a94e8e025ae1b1aea1c89452f429", "message": "second review comments", "committedDate": "2020-10-01T17:17:46Z", "type": "forcePushed"}, {"oid": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "url": "https://github.com/infinispan/infinispan/commit/09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "message": "second review comments", "committedDate": "2020-10-01T17:19:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc2NTg3MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498765871", "bodyText": "shouldn't touchEvenIfExpired be  false here?", "author": "pruivo", "createdAt": "2020-10-02T11:30:05Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -269,11 +261,11 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata, Privat\n     * or not, that is if it couldn't be touched - we assumed expired (as it was removed in some way).\n     * @param entry the entry to check expiration and touch\n     * @param segment the segment the entry maps to\n+    * @param currentTime the current time in milliseconds\n     * @return whether the entry was expired or not\n     */\n-   protected CompletionStage<Boolean> checkExpiredMaxIdle(InternalCacheEntry entry, int segment) {\n-      TouchCommand touchCommand = cf.running().buildTouchCommand(entry.getKey(), segment);\n-      CompletionStage<Boolean> future = (CompletionStage) touchCommand.invokeAsync(componentRegistry);\n+   protected CompletionStage<Boolean> checkExpiredMaxIdle(InternalCacheEntry entry, int segment, long currentTime) {\n+      CompletionStage<Boolean> future = cache.touch(entry.getKey(), segment, true);", "originalCommit": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NTEyNA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498845124", "bodyText": "No, it is to cover the edge case of the entry expiring between when we check and then actually touching. We just don't want to touch for things like the xsite max idle check.", "author": "wburns", "createdAt": "2020-10-02T14:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc2NTg3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "chunk": "diff --git a/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java b/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java\nindex 5e956410db..18ba9b01d7 100644\n--- a/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java\n+++ b/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java\n\n@@ -261,11 +269,11 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata, Privat\n     * or not, that is if it couldn't be touched - we assumed expired (as it was removed in some way).\n     * @param entry the entry to check expiration and touch\n     * @param segment the segment the entry maps to\n-    * @param currentTime the current time in milliseconds\n     * @return whether the entry was expired or not\n     */\n-   protected CompletionStage<Boolean> checkExpiredMaxIdle(InternalCacheEntry entry, int segment, long currentTime) {\n-      CompletionStage<Boolean> future = cache.touch(entry.getKey(), segment, true);\n+   protected CompletionStage<Boolean> checkExpiredMaxIdle(InternalCacheEntry entry, int segment) {\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(entry.getKey(), segment);\n+      CompletionStage<Boolean> future = (CompletionStage) touchCommand.invokeAsync(componentRegistry);\n       return future.thenApply(touched -> !touched);\n    }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc5NTk1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498795952", "bodyText": "Actually, the comments are wrong (same comments, in all tests) :) my bad!\nNot sure you notice, but there is a test missing:\npruivo@1cdac79#diff-5932593a9461e5deec52370525a2cf35R144", "author": "pruivo", "createdAt": "2020-10-02T12:41:05Z", "path": "core/src/test/java/org/infinispan/expiration/impl/MaxIdlePessimisticTxTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.infinispan.expiration.impl;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.infinispan.test.TestingUtil.k;\n+import static org.infinispan.test.TestingUtil.replaceComponent;\n+import static org.infinispan.test.TestingUtil.v;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertFalse;\n+import static org.testng.AssertJUnit.assertNull;\n+import static org.testng.AssertJUnit.assertTrue;\n+import static org.testng.AssertJUnit.fail;\n+\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.context.Flag;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.interceptors.locking.ClusteringDependentLogic;\n+import org.infinispan.test.MultipleCacheManagersTest;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test to verify clustered max idle in a pessimistic transaction\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+@Test(groups = \"functional\", testName = \"expiration.impl.MaxIdlePessimisticTxTest\")\n+public class MaxIdlePessimisticTxTest extends MultipleCacheManagersTest {\n+\n+   private static final int NUM_NODES = 3;\n+   private static final long MAX_IDLE = 10;\n+   private final ControlledTimeService timeService = new ControlledTimeService();\n+\n+   public void testWriteLock(Method method) throws Exception {\n+      final String key = k(method);\n+      final String value = v(method, 0);\n+      final String value2 = v(method, 1);\n+\n+\n+      Cache<String, String> cache = findNonOwnerCache(key);\n+      cache.put(key, value, -1, TimeUnit.SECONDS, MAX_IDLE, TimeUnit.MILLISECONDS);\n+\n+      long lastWallClock = timeService.wallClockTime();\n+      timeService.advance(MAX_IDLE - 1);\n+\n+      assertNotExpired(key);\n+      assertLastUsed(key, lastWallClock);\n+\n+      cache.getAdvancedCache().getTransactionManager().begin();\n+      assertEquals(value, cache.put(key, value2, -1, TimeUnit.SECONDS, MAX_IDLE, TimeUnit.MILLISECONDS));\n+      assertEquals(value2, cache.get(key));\n+      // rollback the transaction\n+      cache.getAdvancedCache().getTransactionManager().rollback();\n+\n+      lastWallClock = timeService.wallClockTime();\n+      assertNotExpired(key);\n+      assertLastUsed(key, lastWallClock);\n+\n+      // if the tx didn't touch the key, this advance should expire it", "originalCommit": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NjQzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498846431", "bodyText": "Not sure you notice, but there is a test missing:\npruivo@1cdac79#diff-5932593a9461e5deec52370525a2cf35R144\n\nWeird, I copied the file directly, must have had two commits before?", "author": "wburns", "createdAt": "2020-10-02T14:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc5NTk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0ODg1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498848853", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // if the tx didn't touch the key, this advance should expire it\n          \n          \n            \n                  // the tx touches the key, this advance should not expire it", "author": "pruivo", "createdAt": "2020-10-02T14:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc5NTk1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e6ea97a47274016c08f1a5e9c83f184ba02a5638", "chunk": "diff --git a/core/src/test/java/org/infinispan/expiration/impl/MaxIdlePessimisticTxTest.java b/core/src/test/java/org/infinispan/expiration/impl/MaxIdlePessimisticTxTest.java\nindex 1643744ddd..79a3607859 100644\n--- a/core/src/test/java/org/infinispan/expiration/impl/MaxIdlePessimisticTxTest.java\n+++ b/core/src/test/java/org/infinispan/expiration/impl/MaxIdlePessimisticTxTest.java\n\n@@ -67,7 +67,7 @@ public void testWriteLock(Method method) throws Exception {\n       assertNotExpired(key);\n       assertLastUsed(key, lastWallClock);\n \n-      // if the tx didn't touch the key, this advance should expire it\n+      // the tx touches the key, this advance should not expire it\n       timeService.advance(2);\n       assertNotExpired(key);\n       assertLastUsed(key, lastWallClock);\n"}}, {"oid": "e6ea97a47274016c08f1a5e9c83f184ba02a5638", "url": "https://github.com/infinispan/infinispan/commit/e6ea97a47274016c08f1a5e9c83f184ba02a5638", "message": "fixing hibernate test failures - touch now can delay completion on same thread", "committedDate": "2020-10-02T14:55:50Z", "type": "forcePushed"}, {"oid": "3690b0019376055e1eb1fa8fbe762f1d70f791be", "url": "https://github.com/infinispan/infinispan/commit/3690b0019376055e1eb1fa8fbe762f1d70f791be", "message": "Comment tweak, add in missing test and fix hibernate tests", "committedDate": "2020-10-02T14:56:30Z", "type": "forcePushed"}, {"oid": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "url": "https://github.com/infinispan/infinispan/commit/7f23a1c66f11c1b07bb9f283c358f17b4695c955", "message": "ISPN-11176 XSite Max Idle\n\n* Implements check other site upon max idle expiration found\n* Refreshes all entry access times upon site loss", "committedDate": "2020-10-05T15:53:50Z", "type": "commit"}, {"oid": "b6622335944dee7cc64b17febdf1515c5648434f", "url": "https://github.com/infinispan/infinispan/commit/b6622335944dee7cc64b17febdf1515c5648434f", "message": "ISPN-12337 Clustered Expiration can deadlock with Pessimistic Tx on a non owner", "committedDate": "2020-10-05T15:53:50Z", "type": "commit"}, {"oid": "9e8119e800120347114017874f58eecaa2fc69fa", "url": "https://github.com/infinispan/infinispan/commit/9e8119e800120347114017874f58eecaa2fc69fa", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors", "committedDate": "2020-10-05T17:11:22Z", "type": "commit"}, {"oid": "9e8119e800120347114017874f58eecaa2fc69fa", "url": "https://github.com/infinispan/infinispan/commit/9e8119e800120347114017874f58eecaa2fc69fa", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors", "committedDate": "2020-10-05T17:11:22Z", "type": "forcePushed"}]}