{"pr_number": 7997, "pr_title": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking t\u2026", "pr_createdAt": "2020-03-04T21:00:03Z", "pr_url": "https://github.com/infinispan/infinispan/pull/7997", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNDYzMg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r388224632", "bodyText": "@danberindei @wburns WDYT to adding a default implemntation to ReplicableCommand that returns false? It will remove a fair bit of boilerplate.", "author": "ryanemerson", "createdAt": "2020-03-05T11:06:07Z", "path": "core/src/main/java/org/infinispan/commands/functional/AbstractWriteManyCommand.java", "diffHunk": "@@ -88,7 +88,7 @@ public boolean isConditional() {\n \n    @Override\n    public boolean canBlock() {\n-      return true;\n+      return false;", "originalCommit": "75e1aa23af44388a3ba79e94f33f6c3ae072392b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMwMzg0NA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r388303844", "bodyText": "I had debated about it, but didn't try it. I can see how it feels. I was debating about even deprecating the method as well.", "author": "wburns", "createdAt": "2020-03-05T13:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNDYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MTYyMA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r388451620", "bodyText": "Deprecating it sounds good. At the very least it gives us the option to remove it in 12 even if we're not ready to do that.", "author": "ryanemerson", "createdAt": "2020-03-05T17:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNDYzMg=="}], "type": "inlineReview", "revised_code": {"commit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "chunk": "diff --git a/core/src/main/java/org/infinispan/commands/functional/AbstractWriteManyCommand.java b/core/src/main/java/org/infinispan/commands/functional/AbstractWriteManyCommand.java\nindex a65b526083..cf4214d7fe 100644\n--- a/core/src/main/java/org/infinispan/commands/functional/AbstractWriteManyCommand.java\n+++ b/core/src/main/java/org/infinispan/commands/functional/AbstractWriteManyCommand.java\n\n@@ -86,11 +86,6 @@ public boolean isConditional() {\n       return false;\n    }\n \n-   @Override\n-   public boolean canBlock() {\n-      return false;\n-   }\n-\n    @Override\n    public void fail() {\n       throw new UnsupportedOperationException();\n"}}, {"oid": "0574783db675921d696b4434abe2784dba696582", "url": "https://github.com/infinispan/infinispan/commit/0574783db675921d696b4434abe2784dba696582", "message": "test fixes", "committedDate": "2020-03-05T16:56:58Z", "type": "forcePushed"}, {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "url": "https://github.com/infinispan/infinispan/commit/57a1afb12cb3453e6a61fcd43788102311d3ab3f", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-10T17:00:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMTExMw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394121113", "bodyText": "Is this really needed? The configuration is in a string, so we shouldn't block to read it, and there's no resolver to allow includes from external resources.\nOff-topic, ParserRegistry.parse(String) could avoid wrapping the ByteArrayInputStream in a BufferedInputStream. I would have suggested using factory.createXMLStreamReader(new StringReader(configString)), but then I read its implementation and it would do even more extra work.", "author": "danberindei", "createdAt": "2020-03-18T05:58:46Z", "path": "core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java", "diffHunk": "@@ -196,13 +198,16 @@ void start() {\n \n    CompletableFuture<Void> createCacheLocally(String name, CacheState state) {\n       log.debugf(\"Create cache %s\", name);\n-      Configuration configuration = buildConfiguration(name, state);\n-      return localConfigurationManager.createCache(name, state.getTemplate(), configuration, state.getFlags());\n+      CompletionStage<Configuration> configurationStage = buildConfiguration(name, state);\n+      return configurationStage.thenCompose(configuration -> localConfigurationManager.createCache(name, state.getTemplate(), configuration, state.getFlags()))\n+            .toCompletableFuture();\n    }\n \n-   private Configuration buildConfiguration(String name, CacheState state) {\n-      ConfigurationBuilderHolder builderHolder = parserRegistry.parse(state.getConfiguration());\n-      return builderHolder.getNamedConfigurationBuilders().get(name).build(configurationManager.getGlobalConfiguration());\n+   private CompletionStage<Configuration> buildConfiguration(String name, CacheState state) {\n+      return CompletableFuture.supplyAsync(() -> {\n+         ConfigurationBuilderHolder builderHolder = parserRegistry.parse(state.getConfiguration());\n+         return builderHolder.getNamedConfigurationBuilders().get(name).build(configurationManager.getGlobalConfiguration());\n+      }, blockingExecutor);", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMzNzg2Nw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394337867", "bodyText": "It was detected by block hound as blocking. I can take a closer look later today.", "author": "wburns", "createdAt": "2020-03-18T13:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMTExMw=="}], "type": "inlineReview", "revised_code": {"commit": "b3bd615b4121bde9fd9c99c662669841ac5a27d7", "chunk": "diff --git a/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java b/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java\nindex 5333b04c83..72e5d36a53 100644\n--- a/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java\n+++ b/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java\n\n@@ -197,17 +207,14 @@ void start() {\n    }\n \n    CompletableFuture<Void> createCacheLocally(String name, CacheState state) {\n-      log.debugf(\"Create cache %s\", name);\n-      CompletionStage<Configuration> configurationStage = buildConfiguration(name, state);\n-      return configurationStage.thenCompose(configuration -> localConfigurationManager.createCache(name, state.getTemplate(), configuration, state.getFlags()))\n-            .toCompletableFuture();\n+      log.debugf(\"Starting cache %s from global state\", name);\n+      Configuration configuration = buildConfiguration(name, state);\n+      return localConfigurationManager.createCache(name, state.getTemplate(), configuration, state.getFlags());\n    }\n \n-   private CompletionStage<Configuration> buildConfiguration(String name, CacheState state) {\n-      return CompletableFuture.supplyAsync(() -> {\n-         ConfigurationBuilderHolder builderHolder = parserRegistry.parse(state.getConfiguration());\n-         return builderHolder.getNamedConfigurationBuilders().get(name).build(configurationManager.getGlobalConfiguration());\n-      }, blockingExecutor);\n+   private Configuration buildConfiguration(String name, CacheState state) {\n+      ConfigurationBuilderHolder builderHolder = parserRegistry.parse(state.getConfiguration());\n+      return builderHolder.getNamedConfigurationBuilders().get(name).build(configurationManager.getGlobalConfiguration());\n    }\n \n    @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjIyNw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394122227", "bodyText": "Is/should there be a way to use the non-blocking executor for users of ClusterExecutor that know their callback is non-blocking? Maybe internal code should be sending commands anyway?", "author": "danberindei", "createdAt": "2020-03-18T06:02:55Z", "path": "core/src/main/java/org/infinispan/manager/DefaultCacheManager.java", "diffHunk": "@@ -1140,7 +1140,8 @@ public ClusterExecutor executor() {\n       if (transport != null) {\n          long time = configurationManager.getGlobalConfiguration().transport().distributedSyncTimeout();\n          return ClusterExecutors.allSubmissionExecutor(null, this, transport, time, TimeUnit.MILLISECONDS,\n-               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.REMOTE_COMMAND_EXECUTOR),\n+               // This can run arbitrary code, including user - assume it is blocking\n+               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.BLOCKING_EXECUTOR),", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0MjA1OA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394342058", "bodyText": "I was debating about this. We should probably do something though. I think having a separate JIRA is probably best. https://issues.redhat.com/browse/ISPN-11482", "author": "wburns", "createdAt": "2020-03-18T13:24:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjIyNw=="}], "type": "inlineReview", "revised_code": {"commit": "bf6f39a2d3909b5ea4a8484447c8da5678e7f926", "chunk": "diff --git a/core/src/main/java/org/infinispan/manager/DefaultCacheManager.java b/core/src/main/java/org/infinispan/manager/DefaultCacheManager.java\nindex 26d7cab705..10fbe95e92 100644\n--- a/core/src/main/java/org/infinispan/manager/DefaultCacheManager.java\n+++ b/core/src/main/java/org/infinispan/manager/DefaultCacheManager.java\n\n@@ -1140,12 +1138,14 @@ public ClusterExecutor executor() {\n       if (transport != null) {\n          long time = configurationManager.getGlobalConfiguration().transport().distributedSyncTimeout();\n          return ClusterExecutors.allSubmissionExecutor(null, this, transport, time, TimeUnit.MILLISECONDS,\n-               // This can run arbitrary code, including user - assume it is blocking\n-               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.BLOCKING_EXECUTOR),\n+               // This can run arbitrary code, including user - such commands can block\n+               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.NON_BLOCKING_EXECUTOR),\n                globalComponentRegistry.getComponent(ScheduledExecutorService.class, KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR));\n       } else {\n          return ClusterExecutors.allSubmissionExecutor(null, this, null,\n-               TransportConfiguration.DISTRIBUTED_SYNC_TIMEOUT.getDefaultValue(), TimeUnit.MILLISECONDS, ForkJoinPool.commonPool(),\n+               TransportConfiguration.DISTRIBUTED_SYNC_TIMEOUT.getDefaultValue(), TimeUnit.MILLISECONDS,\n+               // This can run arbitrary code, including user - such commands can block\n+               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.NON_BLOCKING_EXECUTOR),\n                globalComponentRegistry.getComponent(ScheduledExecutorService.class, KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR));\n       }\n    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjkzNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394122936", "bodyText": "I was hoping that the result of canBlock() would already be ignored, and it would be the command's job to submit a task to the blocking executor if needed. Maybe in the next version, then :)", "author": "danberindei", "createdAt": "2020-03-18T06:05:45Z", "path": "core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java", "diffHunk": "@@ -61,6 +61,7 @@ public boolean isReturnValueExpected() {\n \n    @Override\n    public boolean canBlock() {\n+      // These commands can be arbitrary user commands - so be careful about them blocking", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0Mjg2OQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394342869", "bodyText": "Hrmm, I think I understand now. You mean inside the invokeAsync directly. I can make a new JIRA to do that as it will inflate this probably a bit.", "author": "wburns", "createdAt": "2020-03-18T13:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0NDcyMQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394344721", "bodyText": "https://issues.redhat.com/browse/ISPN-11483", "author": "wburns", "createdAt": "2020-03-18T13:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjkzNg=="}], "type": "inlineReview", "revised_code": {"commit": "bf6f39a2d3909b5ea4a8484447c8da5678e7f926", "chunk": "diff --git a/core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java b/core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java\nindex 9b510b685d..6f5702893b 100644\n--- a/core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java\n+++ b/core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java\n\n@@ -61,7 +61,7 @@ public boolean isReturnValueExpected() {\n \n    @Override\n    public boolean canBlock() {\n-      // These commands can be arbitrary user commands - so be careful about them blocking\n-      return true;\n+      // Note that it is highly possible that a user command could block, and some internal Infinispan ones already do\n+      return false;\n    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzE0Mg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394127142", "bodyText": "So we assume any ReplicableCommand is blocking?", "author": "danberindei", "createdAt": "2020-03-18T06:21:51Z", "path": "core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java", "diffHunk": "@@ -135,7 +135,7 @@ private void handleReplicableCommand(Address origin, ReplicableCommand command,\n          //we must/can run in this thread\n          runnable.run();\n       } else {\n-         remoteCommandsExecutor.execute(runnable);\n+         blockingExecutor.execute(runnable);", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0NDk2NA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394344964", "bodyText": "Why do you say that, sorry? It should only do this if canBlock was true.", "author": "wburns", "createdAt": "2020-03-18T13:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MDA0NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394690045", "bodyText": "Sorry, I was only looking at the diff and I forgot that ReplicableCommand has canBlock(), I thought it was in CacheRpcCommand.", "author": "danberindei", "createdAt": "2020-03-18T23:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzE0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "553b36dca7563b374d719d761567263767d83f4b", "chunk": "diff --git a/core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java b/core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java\nindex a951d57d51..772dfe6ca0 100644\n--- a/core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java\n+++ b/core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java\n\n@@ -135,7 +135,7 @@ private void handleReplicableCommand(Address origin, ReplicableCommand command,\n          //we must/can run in this thread\n          runnable.run();\n       } else {\n-         blockingExecutor.execute(runnable);\n+         remoteCommandsExecutor.execute(runnable);\n       }\n    }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzgyMQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394127821", "bodyText": "I would assume the unlock method can't block, so it's just for symmetry", "author": "danberindei", "createdAt": "2020-03-18T06:24:35Z", "path": "core/src/main/java/org/infinispan/topology/ClusterTopologyManagerImpl.java", "diffHunk": "@@ -179,17 +179,29 @@ public void start() {\n    @Stop(priority = 100)\n    public void stop() {\n       // Stop blocking cache topology commands.\n-      updateLock.lock();\n+      acquireUpdateLock();\n       try {\n          clusterManagerStatus = ClusterManagerStatus.STOPPING;\n          joinViewFuture.stop();\n       } finally {\n-         updateLock.unlock();\n+         releaseUpdateLock();\n       }\n \n       cacheManagerNotifier.removeListener(viewListener);\n    }\n \n+   // This method is here to augment with blockhound as we allow it to block, but don't want the calls\n+   // inside the lock to block - Do not move or rename without updating the reference\n+   private void acquireUpdateLock() {\n+      updateLock.lock();\n+   }\n+\n+   // This method is here to augment with blockhound as we allow it to block, but don't want the calls\n+   // inside the lock to block - Do not move or rename without updating the reference", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0NTY5NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394345695", "bodyText": "Sure, let me try removing actually. I don't quite remember ;)", "author": "wburns", "createdAt": "2020-03-18T13:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MDMzNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394690336", "bodyText": "I wanted to keep the method so acquire/release is symmetric, I just wanted to remove the comment and the exception in the blockhound integration.", "author": "danberindei", "createdAt": "2020-03-18T23:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzgyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3bd615b4121bde9fd9c99c662669841ac5a27d7", "chunk": "diff --git a/core/src/main/java/org/infinispan/topology/ClusterTopologyManagerImpl.java b/core/src/main/java/org/infinispan/topology/ClusterTopologyManagerImpl.java\nindex 89f5cae900..688204711a 100644\n--- a/core/src/main/java/org/infinispan/topology/ClusterTopologyManagerImpl.java\n+++ b/core/src/main/java/org/infinispan/topology/ClusterTopologyManagerImpl.java\n\n@@ -184,7 +184,7 @@ public void stop() {\n          clusterManagerStatus = ClusterManagerStatus.STOPPING;\n          joinViewFuture.stop();\n       } finally {\n-         releaseUpdateLock();\n+         updateLock.unlock();\n       }\n \n       cacheManagerNotifier.removeListener(viewListener);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyODA4MA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394128080", "bodyText": "Doesn't add anything IMO", "author": "danberindei", "createdAt": "2020-03-18T06:25:30Z", "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -47,6 +48,10 @@ public void applyTo(BlockHound.Builder builder) {\n \n          // This shouldn't block long when held - but it is a write lock which can be delayed\n          builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+\n+         // Let the lock acquisition be blocking", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0NTk4OQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394345989", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-03-18T13:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyODA4MA=="}], "type": "inlineReview", "revised_code": {"commit": "b3bd615b4121bde9fd9c99c662669841ac5a27d7", "chunk": "diff --git a/core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java b/core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java\nindex 290c7b726c..c887a10297 100644\n--- a/core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java\n+++ b/core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java\n\n@@ -49,9 +53,9 @@ public void applyTo(BlockHound.Builder builder) {\n          // This shouldn't block long when held - but it is a write lock which can be delayed\n          builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n \n-         // Let the lock acquisition be blocking\n+         builder.allowBlockingCallsInside(TransactionTable.class.getName(), \"calculateMinTopologyId\");\n+\n          builder.allowBlockingCallsInside(ClusterTopologyManagerImpl.class.getName(), \"acquireUpdateLock\");\n-         builder.allowBlockingCallsInside(ClusterTopologyManagerImpl.class.getName(), \"releaseUpdateLock\");\n       }\n       // This invokes the actual runnable - we have to make sure it doesn't block as normal\n       builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394130931", "bodyText": "Assuming this is just for the Thread.sleep() call, I think it would be better to add an executor parameter to TestingUtil.delayed() and to inject the non-blocking executor in ReplListenerInterceptor.", "author": "danberindei", "createdAt": "2020-03-18T06:35:57Z", "path": "core/src/test/java/org/infinispan/util/CoreTestBlockHoundIntegration.java", "diffHunk": "@@ -67,6 +73,10 @@ private static void allowTestsToBlock(BlockHound.Builder builder) {\n       CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, NotifierLatch.class);\n \n       CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, TestBlocking.class);\n+\n+      CommonsBlockHoundIntegration.allowMethodsToBlock(builder, Class.forName(ReplListener.class.getName() + \"$ReplListenerInterceptor\"), false);", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0ODczMA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394348730", "bodyText": "Actually am not sure why I didn't just add TestingUtil#sleepThread to the exception list. Let me try that instead.", "author": "wburns", "createdAt": "2020-03-18T13:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3NDIwNw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394474207", "bodyText": "Ah it was because of logCommand that acquires a lock. I think I will leave it as is for now.", "author": "wburns", "createdAt": "2020-03-18T16:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3NDQ1MA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394474450", "bodyText": "But I can also add TestingUtil#sleepThread as okay to block though too.", "author": "wburns", "createdAt": "2020-03-18T16:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4ODIxOA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394688218", "bodyText": "+1 to add TestingUtil#sleepThread", "author": "danberindei", "createdAt": "2020-03-18T23:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5ODI0NA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395898244", "bodyText": "Seems to work fine without the ReplListenerInterceptor exception now.", "author": "danberindei", "createdAt": "2020-03-20T21:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3bd615b4121bde9fd9c99c662669841ac5a27d7", "chunk": "diff --git a/core/src/test/java/org/infinispan/util/CoreTestBlockHoundIntegration.java b/core/src/test/java/org/infinispan/util/CoreTestBlockHoundIntegration.java\nindex 10ad355866..461b07a921 100644\n--- a/core/src/test/java/org/infinispan/util/CoreTestBlockHoundIntegration.java\n+++ b/core/src/test/java/org/infinispan/util/CoreTestBlockHoundIntegration.java\n\n@@ -74,6 +74,8 @@ private static void allowTestsToBlock(BlockHound.Builder builder) throws ClassNo\n \n       CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, TestBlocking.class);\n \n+      builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepThread\");\n+\n       CommonsBlockHoundIntegration.allowMethodsToBlock(builder, Class.forName(ReplListener.class.getName() + \"$ReplListenerInterceptor\"), false);\n       // This uses a lambda callback to invoke some methods - which aren't public\n       CommonsBlockHoundIntegration.allowMethodsToBlock(builder, Class.forName(InboundRpcSequencerAction.class.getName() + \"$SequencerPerCacheInboundInvocationHandler\"), false);\n"}}, {"oid": "b3bd615b4121bde9fd9c99c662669841ac5a27d7", "url": "https://github.com/infinispan/infinispan/commit/b3bd615b4121bde9fd9c99c662669841ac5a27d7", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-18T16:35:03Z", "type": "forcePushed"}, {"oid": "ad99dea5d1406aa6bf894efe861566804ae9f1e6", "url": "https://github.com/infinispan/infinispan/commit/ad99dea5d1406aa6bf894efe861566804ae9f1e6", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-18T16:53:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394686285", "bodyText": "No longer necessary?", "author": "danberindei", "createdAt": "2020-03-18T22:58:04Z", "path": "core/src/main/java/org/infinispan/manager/DefaultCacheManager.java", "diffHunk": "@@ -1139,11 +1138,14 @@ public ClusterExecutor executor() {\n       if (transport != null) {\n          long time = configurationManager.getGlobalConfiguration().transport().distributedSyncTimeout();\n          return ClusterExecutors.allSubmissionExecutor(null, this, transport, time, TimeUnit.MILLISECONDS,\n-               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.REMOTE_COMMAND_EXECUTOR),\n+               // This can run arbitrary code, including user - such commands can block", "originalCommit": "4730be1a23e42918e2f831d1bbff89fd1f778649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcwMDE2MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394700161", "bodyText": "No, I more put it here because it can block :)", "author": "wburns", "createdAt": "2020-03-18T23:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyMzU4MA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395123580", "bodyText": "Should it be using the non-blocking executor then?", "author": "danberindei", "createdAt": "2020-03-19T15:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyNzg5NA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395127894", "bodyText": "Unfortunately until the other JIRA is fixed, we don't have a great solution. And cluster executor isn't that widely used afaik. But we should hopefully get it fixed before people use  it like this.", "author": "wburns", "createdAt": "2020-03-19T15:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0NTM4Nw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395545387", "bodyText": "Unfortunately I think the few users of cluster executor may be doing exactly blocking cache operations, because there's no way to return a value asynchronously.\nI'm starting to think that the proper solution is\n\nchange PersistenceManagerImpl to detect if it is a blocking thread and run it inline and if non blocking thread to run the command in a blocking thread.\n\nIn fact, I would go even further, and change continueOnCPUExecutor to also continue on the caller thread if the caller thread was blocking. Otherwise, for cluster executor tasks doing cache.put(k1, v1), where the put requires 1 store operation to read the previous value and 1 store operation to store the value, the store read would happen on the task's initial blocking thread, but the store write would need another blocking thread. If the size of the blocking thread pool is N and you have N simultaneous tasks like this, there's no free thread to process the store writes.", "author": "danberindei", "createdAt": "2020-03-20T10:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0ODAzNA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395748034", "bodyText": "Just an FYI but the only way currently we have to detect if it is a blocking thread is to check the thread name, which is quite brittle.\nAlso your put case, I don't see how the read and write would need concurrent blocking threads. The read would be done before then the write would be done afterwards, synchronously.", "author": "wburns", "createdAt": "2020-03-20T16:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNDU2NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395824565", "bodyText": "Just an FYI but the only way currently we have to detect if it is a blocking thread is to check the thread name, which is quite brittle.\n\nCan't we do !(Thread.currentThread() instanceof ISPNNonBlockingThread)?\n\nAlso your put case, I don't see how the read and write would need concurrent blocking threads. The read would be done before then the write would be done afterwards, synchronously.\n\nIf the cluster executor task does a blocking cache.put(k, v), it needs a (blocking) thread for the entire duration of the cache operation. The read would run on the same thread, but then continueOnCPUExecutor() would submit a task to the non-blocking executor, and the next PersistenceManagerImpl call would submit a task to the blocking executor.", "author": "danberindei", "createdAt": "2020-03-20T18:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNDM4Mw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395834383", "bodyText": "Can't we do !(Thread.currentThread() instanceof ISPNNonBlockingThread)?\n\nNo, unfortunately. This would include user threads, jgroups etc.\n\nIf the cluster executor task does a blocking cache.put(k, v), it needs a (blocking) thread for the entire duration of the cache operation. The read would run on the same thread, but then continueOnCPUExecutor() would submit a task to the non-blocking executor, and the next PersistenceManagerImpl call would submit a task to the blocking executor.\n\nOh, okay you were not referring to the read then write. I agree if a blocking operation is invoked on a blocking thread then yes it would use more than 1.", "author": "wburns", "createdAt": "2020-03-20T18:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "5c0b1da5ebdf26ebdae76312f643f4c659c29e3b", "chunk": "diff --git a/core/src/main/java/org/infinispan/manager/DefaultCacheManager.java b/core/src/main/java/org/infinispan/manager/DefaultCacheManager.java\nindex 10fbe95e92..09c47505e3 100644\n--- a/core/src/main/java/org/infinispan/manager/DefaultCacheManager.java\n+++ b/core/src/main/java/org/infinispan/manager/DefaultCacheManager.java\n\n@@ -1139,12 +1139,14 @@ public ClusterExecutor executor() {\n          long time = configurationManager.getGlobalConfiguration().transport().distributedSyncTimeout();\n          return ClusterExecutors.allSubmissionExecutor(null, this, transport, time, TimeUnit.MILLISECONDS,\n                // This can run arbitrary code, including user - such commands can block\n+               // This should be remedied in https://issues.redhat.com/browse/ISPN-11482\n                globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.NON_BLOCKING_EXECUTOR),\n                globalComponentRegistry.getComponent(ScheduledExecutorService.class, KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR));\n       } else {\n          return ClusterExecutors.allSubmissionExecutor(null, this, null,\n                TransportConfiguration.DISTRIBUTED_SYNC_TIMEOUT.getDefaultValue(), TimeUnit.MILLISECONDS,\n                // This can run arbitrary code, including user - such commands can block\n+               // This should be remedied in https://issues.redhat.com/browse/ISPN-11482\n                globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.NON_BLOCKING_EXECUTOR),\n                globalComponentRegistry.getComponent(ScheduledExecutorService.class, KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR));\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394687218", "bodyText": "Since you created a separate ISPN-11483, we should return true here for now.", "author": "danberindei", "createdAt": "2020-03-18T23:00:45Z", "path": "core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java", "diffHunk": "@@ -61,6 +61,7 @@ public boolean isReturnValueExpected() {\n \n    @Override\n    public boolean canBlock() {\n-      return true;\n+      // Note that it is highly possible that a user command could block, and some internal Infinispan ones already do\n+      return false;", "originalCommit": "4730be1a23e42918e2f831d1bbff89fd1f778649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcwMDE3OQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394700179", "bodyText": "The problem is we invoke some commands that invoke stores and it causes issues.", "author": "wburns", "createdAt": "2020-03-18T23:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyNDM2MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395124361", "bodyText": "Please add a comment to explain why you're returning false even though it can block.", "author": "danberindei", "createdAt": "2020-03-19T15:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyNzUwNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395127506", "bodyText": "Sure I forgot to put the JIRA in the comments.", "author": "wburns", "createdAt": "2020-03-19T15:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2MTM0MA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395561340", "bodyText": "Maybe I'm missing something, but that JIRA is a bit confusing to me. The subject is \"Provide way for ClusterExecutor to use non blocking thread\", but we are already using a non-blocking thread by returning false here.", "author": "danberindei", "createdAt": "2020-03-20T10:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA=="}], "type": "inlineReview", "revised_code": {"commit": "5c0b1da5ebdf26ebdae76312f643f4c659c29e3b", "chunk": "diff --git a/core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java b/core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java\nindex 6f5702893b..bbc8d2860d 100644\n--- a/core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java\n+++ b/core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java\n\n@@ -62,6 +62,7 @@ public boolean isReturnValueExpected() {\n    @Override\n    public boolean canBlock() {\n       // Note that it is highly possible that a user command could block, and some internal Infinispan ones already do\n+      // This should be remedied with https://issues.redhat.com/browse/ISPN-11482\n       return false;\n    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4Nzk5MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394687991", "bodyText": "Temporary?", "author": "danberindei", "createdAt": "2020-03-18T23:03:04Z", "path": "core/src/test/java/org/infinispan/stream/DistributedSequentialNonRehashStreamTest.java", "diffHunk": "@@ -10,7 +10,7 @@\n  * Verifies stream tests work when rehash is disabled on a sequential stream\n  */\n @Test(groups = \"functional\", testName = \"streams.DistributedSequentialNonRehashStreamTest\")\n-@InCacheMode({ CacheMode.DIST_SYNC, CacheMode.SCATTERED_SYNC })\n+@InCacheMode({ /*CacheMode.DIST_SYNC,*/ CacheMode.SCATTERED_SYNC })", "originalCommit": "4730be1a23e42918e2f831d1bbff89fd1f778649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5OTkzMA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394699930", "bodyText": "I am not sure how this got in here.... I didn't even look at that class, lol.", "author": "wburns", "createdAt": "2020-03-18T23:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4Nzk5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "bf6f39a2d3909b5ea4a8484447c8da5678e7f926", "chunk": "diff --git a/core/src/test/java/org/infinispan/stream/DistributedSequentialNonRehashStreamTest.java b/core/src/test/java/org/infinispan/stream/DistributedSequentialNonRehashStreamTest.java\nindex 9ffe48bbd7..db7d2b2c6c 100644\n--- a/core/src/test/java/org/infinispan/stream/DistributedSequentialNonRehashStreamTest.java\n+++ b/core/src/test/java/org/infinispan/stream/DistributedSequentialNonRehashStreamTest.java\n\n@@ -10,7 +10,7 @@\n  * Verifies stream tests work when rehash is disabled on a sequential stream\n  */\n @Test(groups = \"functional\", testName = \"streams.DistributedSequentialNonRehashStreamTest\")\n-@InCacheMode({ /*CacheMode.DIST_SYNC,*/ CacheMode.SCATTERED_SYNC })\n+@InCacheMode({ CacheMode.DIST_SYNC, CacheMode.SCATTERED_SYNC })\n public class DistributedSequentialNonRehashStreamTest extends DistributedStreamTest {\n \n    @Override\n"}}, {"oid": "bf6f39a2d3909b5ea4a8484447c8da5678e7f926", "url": "https://github.com/infinispan/infinispan/commit/bf6f39a2d3909b5ea4a8484447c8da5678e7f926", "message": "ISPN-11489 TransactionCoordinator updated for non blocking", "committedDate": "2020-03-19T15:50:32Z", "type": "forcePushed"}, {"oid": "5c0b1da5ebdf26ebdae76312f643f4c659c29e3b", "url": "https://github.com/infinispan/infinispan/commit/5c0b1da5ebdf26ebdae76312f643f4c659c29e3b", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-19T18:13:38Z", "type": "forcePushed"}, {"oid": "ddd733c194568ba62d020813de25ad5507acdb8d", "url": "https://github.com/infinispan/infinispan/commit/ddd733c194568ba62d020813de25ad5507acdb8d", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-19T19:02:46Z", "type": "forcePushed"}, {"oid": "97976107c069b2923c52a869eb6a0e60c53a4691", "url": "https://github.com/infinispan/infinispan/commit/97976107c069b2923c52a869eb6a0e60c53a4691", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T04:15:07Z", "type": "forcePushed"}, {"oid": "5ae68c59a1ff3b403e6cd10242709031b2122866", "url": "https://github.com/infinispan/infinispan/commit/5ae68c59a1ff3b403e6cd10242709031b2122866", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T04:22:12Z", "type": "forcePushed"}, {"oid": "21db4dfaa4eeca00d7ead811823205962d364414", "url": "https://github.com/infinispan/infinispan/commit/21db4dfaa4eeca00d7ead811823205962d364414", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T04:40:16Z", "type": "forcePushed"}, {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "url": "https://github.com/infinispan/infinispan/commit/fdefde6f70556b8d6666f4038d0085bfadeffb0b", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T12:42:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2NjgzMg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395466832", "bodyText": "Still using ctx here", "author": "danberindei", "createdAt": "2020-03-20T07:14:55Z", "path": "core/src/main/java/org/infinispan/cache/impl/InvocationHelper.java", "diffHunk": "@@ -238,7 +248,7 @@ private Transaction getOngoingTransaction() {\n             throw CompletableFutures.asCompletionException(e);\n          }\n          return result;\n-      });\n+      }, blockingExecutor), nonBlockingExecutor, ctx).toCompletableFuture();", "originalCommit": "21db4dfaa4eeca00d7ead811823205962d364414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0MTU0Mw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395741543", "bodyText": "Yeah forgot to fix, I can change it.", "author": "wburns", "createdAt": "2020-03-20T16:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2NjgzMg=="}], "type": "inlineReview", "revised_code": {"commit": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "chunk": "diff --git a/core/src/main/java/org/infinispan/cache/impl/InvocationHelper.java b/core/src/main/java/org/infinispan/cache/impl/InvocationHelper.java\nindex 88b186dfda..05e8316f7b 100644\n--- a/core/src/main/java/org/infinispan/cache/impl/InvocationHelper.java\n+++ b/core/src/main/java/org/infinispan/cache/impl/InvocationHelper.java\n\n@@ -248,7 +248,7 @@ private Transaction getOngoingTransaction() {\n             throw CompletableFutures.asCompletionException(e);\n          }\n          return result;\n-      }, blockingExecutor), nonBlockingExecutor, ctx).toCompletableFuture();\n+      }, blockingExecutor), nonBlockingExecutor, ctx.getLockOwner()).toCompletableFuture();\n    }\n \n    private Transaction tryBegin() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NjI4NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395596285", "bodyText": "I would prefer to make the prepare exception the cause and the rollback exception suppressed. I'd also rename innerT to rollbackThrowable and t to prepareThrowable.", "author": "danberindei", "createdAt": "2020-03-20T12:12:22Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,121 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, t) -> {\n+         if (t != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(t);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, innerT) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (innerT != null) {\n+                  innerT.addSuppressed(t);\n+                  xe.initCause(innerT);", "originalCommit": "21db4dfaa4eeca00d7ead811823205962d364414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0MDk3Mg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395740972", "bodyText": "I am fine with renaming. Technically rollback would be suppressing the prepare if this was a try/finally block instead, which is why I did it like I did.", "author": "wburns", "createdAt": "2020-03-20T16:10:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NjI4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java b/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\nindex 7932907af5..318fdff11c 100644\n--- a/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\n+++ b/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\n\n@@ -191,18 +191,13 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n    }\n \n    public CompletionStage<Void> rollback(LocalTransaction localTransaction) {\n-      try {\n-         return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),\n-               (ignore, t) -> {\n-                  if (t != null) {\n-                     return handleRollbackFailure(t, localTransaction);\n-                  }\n-                  return CompletableFutures.completedNull();\n-               });\n-\n-      } catch (Throwable e) {\n-         return handleRollbackFailure(e, localTransaction);\n-      }\n+      return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),\n+            (ignore, t) -> {\n+               if (t != null) {\n+                  return handleRollbackFailure(t, localTransaction);\n+               }\n+               return CompletableFutures.completedNull();\n+            });\n    }\n \n    private <T> CompletionStage<T> handleRollbackFailure(Throwable t, LocalTransaction localTransaction) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3NjI5Mw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395676293", "bodyText": "AFAICT handleRollbackFailure and handleCommitFailure don't need to return a CompletionStage", "author": "danberindei", "createdAt": "2020-03-20T14:33:00Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,121 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, t) -> {\n+         if (t != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(t);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, innerT) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (innerT != null) {\n+                  innerT.addSuppressed(t);\n+                  xe.initCause(innerT);\n+               } else {\n+                  xe.initCause(t);\n+               }\n+               return CompletableFutures.completedExceptionFuture(xe);\n+            });\n+         }\n          if (localTransaction.isReadOnly()) {\n             if (trace) log.tracef(\"Readonly transaction: %s\", localTransaction.getGlobalTransaction());\n             // force a cleanup to release any objects held.  Some TMs don't call commit if it is a READ ONLY tx.  See ISPN-845\n-            commitInternal(ctx);\n-            return XA_RDONLY;\n+            return commitInternal(ctx)\n+                  .thenApply(XA_RDONLY_APPLY);\n          } else {\n             txTable.running().localTransactionPrepared(localTransaction);\n-            return XA_OK;\n+            return XA_OKAY_STAGE;\n          }\n-      } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n-         else\n-            log.errorProcessingPrepare(e);\n-\n-         //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n-         //after prepare failed.\n-         rollback(localTransaction);\n-         // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n-         XAException xe = new XAException(XAException.XA_RBROLLBACK);\n-         xe.initCause(e);\n-         throw xe;\n-      }\n+      });\n    }\n \n-   public boolean commit(LocalTransaction localTransaction, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Boolean> commit(LocalTransaction localTransaction, boolean isOnePhase) {\n       if (trace) log.tracef(\"Committing transaction %s\", localTransaction.getGlobalTransaction());\n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       if (isOnePhaseCommit(localTransaction) || isOnePhase) {\n-         validateNotMarkedForRollback(localTransaction);\n+         CompletionStage<Boolean> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+         if (markRollbackStage != null) {\n+            return markRollbackStage;\n+         }\n \n          if (trace) log.trace(\"Doing an 1PC prepare call on the interceptor chain\");\n          List<WriteCommand> modifications = localTransaction.getModifications();\n          PrepareCommand command = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), modifications, true);\n          try {\n-            invoker.running().invoke(ctx, command);\n+            return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n+                  (ignore, t) -> {\n+                     if (t != null) {\n+                        return handleCommitFailure(t, true, ctx);\n+                     }\n+                     return CompletableFutures.completedTrue();\n+                  });\n          } catch (Throwable e) {\n-            handleCommitFailure(e, true, ctx);\n+            return handleCommitFailure(e, true, ctx);\n          }\n-         return true;\n       } else if (!localTransaction.isReadOnly()) {\n-         commitInternal(ctx);\n+         return commitInternal(ctx);\n       }\n-      return false;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   public void rollback(LocalTransaction localTransaction) throws XAException {\n+   public CompletionStage<Void> rollback(LocalTransaction localTransaction) {\n       try {\n-         rollbackInternal(icf.running().createTxInvocationContext(localTransaction));\n+         return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),\n+               (ignore, t) -> {\n+                  if (t != null) {\n+                     return handleRollbackFailure(t, localTransaction);\n+                  }\n+                  return CompletableFutures.completedNull();\n+               });\n+\n       } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while rolling back, probably because we're shutting down.\");\n-         else\n-            log.errorRollingBack(e);\n-\n-         final Transaction transaction = localTransaction.getTransaction();\n-         //this might be possible if the cache has stopped and TM still holds a reference to the XAResource\n-         if (transaction != null) {\n-            txTable.running().failureCompletingTransaction(transaction);\n-         }\n-         XAException xe = new XAException(XAException.XAER_RMERR);\n-         xe.initCause(e);\n-         throw xe;\n+         return handleRollbackFailure(e, localTransaction);\n+      }\n+   }\n+\n+   private <T> CompletionStage<T> handleRollbackFailure(Throwable t, LocalTransaction localTransaction) {", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTczODEyOA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395738128", "bodyText": "They don't, but the users of it require it to be a CompletionStage, so less code overall. :)", "author": "wburns", "createdAt": "2020-03-20T16:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3NjI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNjE3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395826171", "bodyText": "If you return void and throw the exception directly, the callers can use handle instead of handleAndCompose", "author": "danberindei", "createdAt": "2020-03-20T18:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3NjI5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java b/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\nindex 7932907af5..318fdff11c 100644\n--- a/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\n+++ b/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\n\n@@ -191,18 +191,13 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n    }\n \n    public CompletionStage<Void> rollback(LocalTransaction localTransaction) {\n-      try {\n-         return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),\n-               (ignore, t) -> {\n-                  if (t != null) {\n-                     return handleRollbackFailure(t, localTransaction);\n-                  }\n-                  return CompletableFutures.completedNull();\n-               });\n-\n-      } catch (Throwable e) {\n-         return handleRollbackFailure(e, localTransaction);\n-      }\n+      return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),\n+            (ignore, t) -> {\n+               if (t != null) {\n+                  return handleRollbackFailure(t, localTransaction);\n+               }\n+               return CompletableFutures.completedNull();\n+            });\n    }\n \n    private <T> CompletionStage<T> handleRollbackFailure(Throwable t, LocalTransaction localTransaction) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4MjQ0Mw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395682443", "bodyText": "AsyncInterceptorChain.invokeAsync() catches exceptions, so we don't nee the try..catch any more.", "author": "danberindei", "createdAt": "2020-03-20T14:42:22Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,121 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, t) -> {\n+         if (t != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(t);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, innerT) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (innerT != null) {\n+                  innerT.addSuppressed(t);\n+                  xe.initCause(innerT);\n+               } else {\n+                  xe.initCause(t);\n+               }\n+               return CompletableFutures.completedExceptionFuture(xe);\n+            });\n+         }\n          if (localTransaction.isReadOnly()) {\n             if (trace) log.tracef(\"Readonly transaction: %s\", localTransaction.getGlobalTransaction());\n             // force a cleanup to release any objects held.  Some TMs don't call commit if it is a READ ONLY tx.  See ISPN-845\n-            commitInternal(ctx);\n-            return XA_RDONLY;\n+            return commitInternal(ctx)\n+                  .thenApply(XA_RDONLY_APPLY);\n          } else {\n             txTable.running().localTransactionPrepared(localTransaction);\n-            return XA_OK;\n+            return XA_OKAY_STAGE;\n          }\n-      } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n-         else\n-            log.errorProcessingPrepare(e);\n-\n-         //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n-         //after prepare failed.\n-         rollback(localTransaction);\n-         // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n-         XAException xe = new XAException(XAException.XA_RBROLLBACK);\n-         xe.initCause(e);\n-         throw xe;\n-      }\n+      });\n    }\n \n-   public boolean commit(LocalTransaction localTransaction, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Boolean> commit(LocalTransaction localTransaction, boolean isOnePhase) {\n       if (trace) log.tracef(\"Committing transaction %s\", localTransaction.getGlobalTransaction());\n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       if (isOnePhaseCommit(localTransaction) || isOnePhase) {\n-         validateNotMarkedForRollback(localTransaction);\n+         CompletionStage<Boolean> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+         if (markRollbackStage != null) {\n+            return markRollbackStage;\n+         }\n \n          if (trace) log.trace(\"Doing an 1PC prepare call on the interceptor chain\");\n          List<WriteCommand> modifications = localTransaction.getModifications();\n          PrepareCommand command = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), modifications, true);\n          try {\n-            invoker.running().invoke(ctx, command);\n+            return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n+                  (ignore, t) -> {\n+                     if (t != null) {\n+                        return handleCommitFailure(t, true, ctx);\n+                     }\n+                     return CompletableFutures.completedTrue();\n+                  });\n          } catch (Throwable e) {\n-            handleCommitFailure(e, true, ctx);\n+            return handleCommitFailure(e, true, ctx);\n          }\n-         return true;\n       } else if (!localTransaction.isReadOnly()) {\n-         commitInternal(ctx);\n+         return commitInternal(ctx);\n       }\n-      return false;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   public void rollback(LocalTransaction localTransaction) throws XAException {\n+   public CompletionStage<Void> rollback(LocalTransaction localTransaction) {\n       try {", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc1MTI2NA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395751264", "bodyText": "oh whoops meant to remove that. Trying to keep all the related exceptions in the CompletionStage chain.", "author": "wburns", "createdAt": "2020-03-20T16:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4MjQ0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java b/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\nindex 7932907af5..318fdff11c 100644\n--- a/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\n+++ b/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\n\n@@ -191,18 +191,13 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n    }\n \n    public CompletionStage<Void> rollback(LocalTransaction localTransaction) {\n-      try {\n-         return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),\n-               (ignore, t) -> {\n-                  if (t != null) {\n-                     return handleRollbackFailure(t, localTransaction);\n-                  }\n-                  return CompletableFutures.completedNull();\n-               });\n-\n-      } catch (Throwable e) {\n-         return handleRollbackFailure(e, localTransaction);\n-      }\n+      return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),\n+            (ignore, t) -> {\n+               if (t != null) {\n+                  return handleRollbackFailure(t, localTransaction);\n+               }\n+               return CompletableFutures.completedNull();\n+            });\n    }\n \n    private <T> CompletionStage<T> handleRollbackFailure(Throwable t, LocalTransaction localTransaction) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NTkxOA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395685918", "bodyText": "The exception will be wrapped in a CompletionException anyway, so I don't think we need this exceptionally call. Same for afterCompletion.", "author": "danberindei", "createdAt": "2020-03-20T14:47:32Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionTable.java", "diffHunk": "@@ -888,35 +892,31 @@ private void updateLastPrunedTxId(final long txId, Address address) {\n       }\n    }\n \n-   public int beforeCompletion(LocalTransaction localTransaction) {\n+   public CompletionStage<Integer> beforeCompletion(LocalTransaction localTransaction) {\n       if (trace)\n          log.tracef(\"beforeCompletion called for %s\", localTransaction);\n-      try {\n-         txCoordinator.prepare(localTransaction);\n-      } catch (XAException e) {\n-         throw new CacheException(\"Could not prepare. \", e);//todo shall we just swallow this exception?\n-      }\n-      return 0;\n+      return txCoordinator.prepare(localTransaction)\n+            .exceptionally(t -> {\n+                  throw new CacheException(\"Could not prepare. \", t);", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc1MzgyNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395753826", "bodyText": "I was trying to keep the exceptions the same as before. I wasn't sure if we unwrapped it and then checked it later.", "author": "wburns", "createdAt": "2020-03-20T16:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NTkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc1Mzk5OQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395753999", "bodyText": "I think we can evaluate changing this later if we want to integrate this today.", "author": "wburns", "createdAt": "2020-03-20T16:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NTkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1MTA2NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395851065", "bodyText": "Ok", "author": "danberindei", "createdAt": "2020-03-20T19:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NTkxOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5NTI0OQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395695249", "bodyText": "Could use CompletableFutures.COMPLETED_NULL.thenComposeAsync(...) to avoid the double wrapping the result.\nMaybe it's worth adding a static method in CompletableFutures.", "author": "danberindei", "createdAt": "2020-03-20T15:00:44Z", "path": "core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java", "diffHunk": "@@ -57,23 +66,23 @@ public TransactionXaAdapter(XaTransactionTable txTable) {\n     */\n    @Override\n    public int prepare(Xid externalXid) throws XAException {\n-      return txTable.prepare(externalXid);\n+      return joinAndRethrowXAException(CompletableFuture.supplyAsync(() -> txTable.prepare(externalXid), executor));", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MDYwOQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395760609", "bodyText": "Ah, good one. Yeah, I thought there was a better way. Let me fix this. We may want it in CompletionStages though.", "author": "wburns", "createdAt": "2020-03-20T16:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5NTI0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java b/core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java\nindex 0c98a09590..8b480460be 100644\n--- a/core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java\n+++ b/core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java\n\n@@ -66,7 +67,8 @@ public TransactionXaAdapter(XaTransactionTable txTable, Executor executor) {\n     */\n    @Override\n    public int prepare(Xid externalXid) throws XAException {\n-      return joinAndRethrowXAException(CompletableFuture.supplyAsync(() -> txTable.prepare(externalXid), executor));\n+      return joinAndRethrowXAException(CompletableFutures.completedNull()\n+            .thenComposeAsync(ignore -> txTable.prepare(externalXid), executor));\n    }\n \n    /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwMjg5MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395702891", "bodyText": "Nitpicking, but I would prefer wrapping before prepareStage, or even\n  return prepareStage.thenCompose(ignore -> txCoordinator.commit(localTransaction, false))\n                     .thenApply(committedInOnePhase -> {", "author": "danberindei", "createdAt": "2020-03-20T15:12:15Z", "path": "core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java", "diffHunk": "@@ -100,32 +104,47 @@ public int getLocalTxCount() {\n       return xid2LocalTx.size();\n    }\n \n-   public int prepare(Xid externalXid) throws XAException {\n+   public CompletionStage<Integer> prepare(Xid externalXid) {\n       Xid xid = convertXid(externalXid);\n       LocalXaTransaction localTransaction = getLocalTransactionAndValidate(xid);\n+      if (localTransaction == null) {\n+         return CompletableFutures.completedExceptionFuture(new XAException(XAException.XAER_NOTA));\n+      }\n       return txCoordinator.prepare(localTransaction);\n    }\n \n-   public void commit(Xid externalXid, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Void> commit(Xid externalXid, boolean isOnePhase) {\n       Xid xid = convertXid(externalXid);\n       LocalXaTransaction localTransaction = getLocalTransactionAndValidate(xid);\n-      boolean committedInOnePhase;\n+      if (localTransaction == null) {\n+         return CompletableFutures.completedExceptionFuture(new XAException(XAException.XAER_NOTA));\n+      }\n+      CompletionStage<?> prepareStage;\n       if (isOnePhase) {\n          //isOnePhase being true means that we're the only participant in the distributed transaction and TM does the\n          //1PC optimization. We run a 2PC though, as running only 1PC has a high chance of leaving the cluster in\n          //inconsistent state.\n-         txCoordinator.prepare(localTransaction);\n+         prepareStage = txCoordinator.prepare(localTransaction);\n+      } else {\n+         prepareStage = CompletableFutures.completedNull();\n       }\n-      committedInOnePhase = txCoordinator.commit(localTransaction, false);\n-      forgetSuccessfullyCompletedTransaction(recoveryManager, localTransaction.getXid(), localTransaction,\n-            committedInOnePhase);\n+      CompletionStage<Boolean> commitStage = prepareStage\n+            .thenCompose(ignore -> txCoordinator.commit(localTransaction, false));", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2NTQ4Nw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395765487", "bodyText": "Changed to the suggested code.", "author": "wburns", "createdAt": "2020-03-20T16:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwMjg5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java b/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java\nindex 0660714cad..ccc5c999bb 100644\n--- a/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java\n+++ b/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java\n\n@@ -106,7 +112,7 @@ public int getLocalTxCount() {\n \n    public CompletionStage<Integer> prepare(Xid externalXid) {\n       Xid xid = convertXid(externalXid);\n-      LocalXaTransaction localTransaction = getLocalTransactionAndValidate(xid);\n+      LocalXaTransaction localTransaction = getLocalTransaction(xid);\n       if (localTransaction == null) {\n          return CompletableFutures.completedExceptionFuture(new XAException(XAException.XAER_NOTA));\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwNjI1Mg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395706252", "bodyText": "Since we know 100% xe is not a CompletionException, I would find throw new CompletionException(xe) clearer.", "author": "danberindei", "createdAt": "2020-03-20T15:17:04Z", "path": "core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java", "diffHunk": "@@ -153,23 +172,23 @@ void end(LocalXaTransaction localTransaction) {\n          log.tracef(\"end called on tx %s(%s)\", localTransaction.getGlobalTransaction(), cacheName);\n    }\n \n-   void forget(Xid externalXid) throws XAException {\n+   CompletionStage<Void> forget(Xid externalXid) {\n       Xid xid = convertXid(externalXid);\n       if (trace)\n          log.tracef(\"forget called for xid %s\", xid);\n-      try {\n-         if (isRecoveryEnabled()) {\n-            recoveryManager.removeRecoveryInformation(null, xid, true, null, false);\n-         } else {\n-            if (trace)\n-               log.trace(\"Recovery not enabled\");\n-         }\n-      } catch (Exception e) {\n-         log.warnExceptionRemovingRecovery(e);\n-         XAException xe = new XAException(XAException.XAER_RMERR);\n-         xe.initCause(e);\n-         throw xe;\n+      if (isRecoveryEnabled()) {\n+         return recoveryManager.removeRecoveryInformation(null, xid, null, false)\n+               .exceptionally(t -> {\n+                  log.warnExceptionRemovingRecovery(t);\n+                  XAException xe = new XAException(XAException.XAER_RMERR);\n+                  xe.initCause(t);\n+                  throw CompletableFutures.asCompletionException(xe);", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MDk3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395760971", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-03-20T16:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwNjI1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java b/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java\nindex 0660714cad..ccc5c999bb 100644\n--- a/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java\n+++ b/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java\n\n@@ -182,7 +187,7 @@ void end(LocalXaTransaction localTransaction) {\n                   log.warnExceptionRemovingRecovery(t);\n                   XAException xe = new XAException(XAException.XAER_RMERR);\n                   xe.initCause(t);\n-                  throw CompletableFutures.asCompletionException(xe);\n+                  throw new CompletionException(xe);\n                });\n       } else {\n          if (trace)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwODEwOA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395708108", "bodyText": "The name is outdated, there's no validation, so I would suggest inlining the method.", "author": "danberindei", "createdAt": "2020-03-20T15:19:38Z", "path": "core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java", "diffHunk": "@@ -180,20 +199,21 @@ private void forgetSuccessfullyCompletedTransaction(RecoveryManager recoveryMana\n          LocalXaTransaction localTransaction, boolean committedInOnePhase) {\n       final GlobalTransaction gtx = localTransaction.getGlobalTransaction();\n       if (isRecoveryEnabled()) {\n-         recoveryManager.removeRecoveryInformation(localTransaction.getRemoteLocksAcquired(), xid, false, gtx,\n+         // TODO: this should call a different method that doesn't receive an ack\n+         recoveryManager.removeRecoveryInformation(localTransaction.getRemoteLocksAcquired(), xid, gtx,\n                partitionHandlingManager.isTransactionPartiallyCommitted(gtx));\n          removeLocalTransaction(localTransaction);\n       } else {\n          releaseLocksForCompletedTransaction(localTransaction, committedInOnePhase);\n       }\n    }\n \n-   private LocalXaTransaction getLocalTransactionAndValidate(Xid xid) throws XAException {\n+   private LocalXaTransaction getLocalTransactionAndValidate(Xid xid) {", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjI3Nw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395762277", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-03-20T16:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwODEwOA=="}], "type": "inlineReview", "revised_code": {"commit": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java b/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java\nindex 0660714cad..ccc5c999bb 100644\n--- a/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java\n+++ b/core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java\n\n@@ -207,14 +212,4 @@ private void forgetSuccessfullyCompletedTransaction(RecoveryManager recoveryMana\n          releaseLocksForCompletedTransaction(localTransaction, committedInOnePhase);\n       }\n    }\n-\n-   private LocalXaTransaction getLocalTransactionAndValidate(Xid xid) {\n-      LocalXaTransaction localTransaction = getLocalTransaction(xid);\n-      if (localTransaction == null) {\n-         if (trace)\n-            log.tracef(\"no tx found for %s\", xid);\n-         return null;\n-      }\n-      return localTransaction;\n-   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcxNDYyNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395714626", "bodyText": "I think it's safe to remove the local recovery info in the caller thread and then return the stage.\nSlightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there the GlobalTransaction is not available.", "author": "danberindei", "createdAt": "2020-03-20T15:29:18Z", "path": "core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java", "diffHunk": "@@ -128,38 +130,43 @@ public RecoveryIterator getPreparedTransactionsFromCluster() {\n    }\n \n    @Override\n-   public void removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, boolean sync, GlobalTransaction gtx,\n+   public CompletionStage<Void> removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, GlobalTransaction gtx,\n                                          boolean fromCluster) {\n       log.tracef(\"Forgetting tx information for %s\", gtx);\n       //todo make sure this gets broad casted or at least flushed\n       if (rpcManager != null && !fromCluster) {\n          TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(xid, gtx);\n-         sendTxCompletionNotification(lockOwners, ftc, sync);\n+         return sendTxCompletionNotification(lockOwners, ftc)\n+               .thenRun(() -> removeRecoveryInformation(xid));", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2NDQ1MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395764451", "bodyText": "I can try that.", "author": "wburns", "createdAt": "2020-03-20T16:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcxNDYyNg=="}], "type": "inlineReview", "revised_code": {"commit": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java b/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java\nindex d0c4286225..09a66dc2c8 100644\n--- a/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java\n+++ b/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java\n\n@@ -136,8 +136,8 @@ public RecoveryIterator getPreparedTransactionsFromCluster() {\n       //todo make sure this gets broad casted or at least flushed\n       if (rpcManager != null && !fromCluster) {\n          TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(xid, gtx);\n-         return sendTxCompletionNotification(lockOwners, ftc)\n-               .thenRun(() -> removeRecoveryInformation(xid));\n+         removeRecoveryInformation(xid);\n+         return sendTxCompletionNotification(lockOwners, ftc);\n       } else {\n          removeRecoveryInformation(xid);\n          return CompletableFutures.completedNull();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyNTAwNQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395725005", "bodyText": "IMO this is too abstract, it wouldn't be much longer if everything was inlined:\n      GlobalTransaction gtx = localTx.getGlobalTransaction();\n      if (commit) {\n         localTx.clearLookedUpEntries();\n         return txCoordinator.prepare(localTx, true)\n                             .thenCompose(ignore -> txCoordinator.commit(localTx, false))\n                             .thenCompose(ignore -> removeRecoveryInformation(null, xid, gtx, false))\n                             .thenApply(ignore -> \"Commit successful!\")\n                             .exceptionally(t -> {\n                                log.warnCouldNotCommitLocalTx(localTx, t);\n                                return \"Could not commit transaction \" + xid + \" : \" + t.getMessage();\n                             });\n      } else {\n         return txCoordinator.rollback(localTx)\n                             .thenCompose(ignore -> removeRecoveryInformation(null, xid, gtx, false))\n                             .thenApply(ignore -> \"Rollback successful\")\n                             .exceptionally(t -> {\n                                log.warnCouldNotRollbackLocalTx(localTx, t);\n                                return \"Could not rollback transaction \" + xid + \" : \" + t.getMessage();\n                             });\n      }", "author": "danberindei", "createdAt": "2020-03-20T15:45:29Z", "path": "core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java", "diffHunk": "@@ -305,26 +312,29 @@ public String forceTransactionCompletion(Xid xid, boolean commit) {\n       }\n    }\n \n-   private String completeTransaction(LocalTransaction localTx, boolean commit, Xid xid) {\n+   private CompletionStage<String> completeTransaction(LocalTransaction localTx, boolean commit, Xid xid) {\n+      CompletionStage<?> stage;\n+      Function<Throwable, String> errorTranslation;", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2Mzk2MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395763961", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-03-20T16:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyNTAwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java b/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java\nindex d0c4286225..09a66dc2c8 100644\n--- a/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java\n+++ b/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java\n\n@@ -313,28 +313,26 @@ public RecoveryAwareRemoteTransaction getPreparedTransaction(Xid xid) {\n    }\n \n    private CompletionStage<String> completeTransaction(LocalTransaction localTx, boolean commit, Xid xid) {\n-      CompletionStage<?> stage;\n-      Function<Throwable, String> errorTranslation;\n+      GlobalTransaction gtx = localTx.getGlobalTransaction();\n       if (commit) {\n-            localTx.clearLookedUpEntries();\n-            stage = txCoordinator.prepare(localTx, true)\n-                  .thenCompose(ignore -> txCoordinator.commit(localTx, false));\n-            errorTranslation = t -> {\n-               log.warnCouldNotCommitLocalTx(localTx, t);\n-               return \"Could not commit transaction \" + xid + \" : \" + t.getMessage();\n-            };\n+         localTx.clearLookedUpEntries();\n+         return txCoordinator.prepare(localTx, true)\n+               .thenCompose(ignore -> txCoordinator.commit(localTx, false))\n+               .thenCompose(ignore -> removeRecoveryInformation(null, xid, gtx, false))\n+               .thenApply(ignore -> \"Commit successful!\")\n+               .exceptionally(t -> {\n+                  log.warnCouldNotCommitLocalTx(localTx, t);\n+                  return \"Could not commit transaction \" + xid + \" : \" + t.getMessage();\n+               });\n       } else {\n-         stage = txCoordinator.rollback(localTx);\n-         errorTranslation = t -> {\n-            log.warnCouldNotRollbackLocalTx(localTx, t);\n-            return \"Could not rollback transaction \" + xid + \" : \" + t.getMessage();\n-         };\n+         return txCoordinator.rollback(localTx)\n+               .thenCompose(ignore -> removeRecoveryInformation(null, xid, gtx, false))\n+               .thenApply(ignore -> \"Rollback successful\")\n+               .exceptionally(t -> {\n+                  log.warnCouldNotRollbackLocalTx(localTx, t);\n+                  return \"Could not rollback transaction \" + xid + \" : \" + t.getMessage();\n+               });\n       }\n-      return stage.thenCompose(ignore ->\n-         removeRecoveryInformation(null, xid, localTx.getGlobalTransaction(), false)\n-               .thenApply(ignore2 -> commit ? \"Commit successful!\" : \"Rollback successful\")\n-      ).exceptionally(errorTranslation);\n-\n    }\n \n    @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTczMzQxNQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395733415", "bodyText": "It's so weird that it wasn't a problem before, I have to debug the test to see how it's passing on master :)", "author": "danberindei", "createdAt": "2020-03-20T15:58:10Z", "path": "core/src/test/java/org/infinispan/commands/GetAllCommandNodeCrashTest.java", "diffHunk": "@@ -41,6 +43,7 @@ public void test() throws Exception {\n       cache(2).put(key, \"value\");\n \n       ControlledRpcManager rpcManager = ControlledRpcManager.replaceRpcManager(cache(2));\n+      rpcManager.excludeCommands(StateResponseCommand.class, StateTransferStartCommand.class);", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjkxMA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395762910", "bodyText": "Yeah, I agree. But I wasn't quite sure what was going on.", "author": "wburns", "createdAt": "2020-03-20T16:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTczMzQxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "553b36dca7563b374d719d761567263767d83f4b", "chunk": "diff --git a/core/src/test/java/org/infinispan/commands/GetAllCommandNodeCrashTest.java b/core/src/test/java/org/infinispan/commands/GetAllCommandNodeCrashTest.java\nindex e839effbdd..1df6c97a96 100644\n--- a/core/src/test/java/org/infinispan/commands/GetAllCommandNodeCrashTest.java\n+++ b/core/src/test/java/org/infinispan/commands/GetAllCommandNodeCrashTest.java\n\n@@ -43,7 +41,6 @@ public void test() throws Exception {\n       cache(2).put(key, \"value\");\n \n       ControlledRpcManager rpcManager = ControlledRpcManager.replaceRpcManager(cache(2));\n-      rpcManager.excludeCommands(StateResponseCommand.class, StateTransferStartCommand.class);\n \n       CountDownLatch blockTopologyUpdate = new CountDownLatch(1);\n       StateConsumer stateConsumerMock = spy(extractComponent(cache(2), StateConsumer.class));\n"}}, {"oid": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "url": "https://github.com/infinispan/infinispan/commit/f1610673eb296c5cb60579b40ce1b024044ed2f4", "message": "rework comments", "committedDate": "2020-03-20T16:51:56Z", "type": "forcePushed"}, {"oid": "d02878704874e5aee0840e227a8a1d1d554321cd", "url": "https://github.com/infinispan/infinispan/commit/d02878704874e5aee0840e227a8a1d1d554321cd", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T16:58:47Z", "type": "forcePushed"}, {"oid": "7010d9595ad27759c856085b70a23cdb08037080", "url": "https://github.com/infinispan/infinispan/commit/7010d9595ad27759c856085b70a23cdb08037080", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T17:01:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395825226", "bodyText": "No need for handleAndCompose", "author": "danberindei", "createdAt": "2020-03-20T18:40:04Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,116 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, prepareThrowable) -> {\n+         if (prepareThrowable != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(prepareThrowable);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, rollbackThrowable) -> {", "originalCommit": "7010d9595ad27759c856085b70a23cdb08037080", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNTIyOQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395835229", "bodyText": "Not sure, why. We need to handle the case when it was not an error to wrap it with an XAException still. And we want to still catch the rollback exception to supress or rethrow that.", "author": "wburns", "createdAt": "2020-03-20T18:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0MjIyMQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395842221", "bodyText": "Yes, but none of those need to return a CompletionStage, so you can use handle instead of handleAndCompose.", "author": "danberindei", "createdAt": "2020-03-20T19:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0NTM3MA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395845370", "bodyText": "I was trying to keep all the exceptions as bare XAException. If I do the other I would have to use CompletionException wrapping XAException and all callers would have to pay attention to that including TransactionXAAdapter, but I can do that.", "author": "wburns", "createdAt": "2020-03-20T19:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0ODMzMQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395848331", "bodyText": "Actually I don't feel comfortable changing this right now. I can revisit later if we need.", "author": "wburns", "createdAt": "2020-03-20T19:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1MDQzOQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395850439", "bodyText": "I was trying to keep all the exceptions as bare XAException. If I do the other I would have to use CompletionException wrapping XAException and all callers would have to pay attention to that including TransactionXAAdapter, but I can do that.\n\nNot sure what you mean. When you do CompletableFuture.join() it will wrap the exception in a CompletionStage anyway, so you have to be prepared to extract the exception with CompletableFutures.extractException.\nBut I'm ok with revisiting this later.", "author": "danberindei", "createdAt": "2020-03-20T19:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg=="}], "type": "inlineReview", "revised_code": {"commit": "3173ad9f37dea0b47869ebe53bfb4a52ad870b61", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java b/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\nindex 9ccd1a6269..3a6a871d4a 100644\n--- a/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\n+++ b/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\n\n@@ -173,17 +173,13 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n          if (trace) log.trace(\"Doing an 1PC prepare call on the interceptor chain\");\n          List<WriteCommand> modifications = localTransaction.getModifications();\n          PrepareCommand command = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), modifications, true);\n-         try {\n-            return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n-                  (ignore, t) -> {\n-                     if (t != null) {\n-                        return handleCommitFailure(t, true, ctx);\n-                     }\n-                     return CompletableFutures.completedTrue();\n-                  });\n-         } catch (Throwable e) {\n-            return handleCommitFailure(e, true, ctx);\n-         }\n+         return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n+               (ignore, t) -> {\n+                  if (t != null) {\n+                     return handleCommitFailure(t, true, ctx);\n+                  }\n+                  return CompletableFutures.completedTrue();\n+               });\n       } else if (!localTransaction.isReadOnly()) {\n          return commitInternal(ctx);\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTU5NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395825595", "bodyText": "No need for try..catch", "author": "danberindei", "createdAt": "2020-03-20T18:40:46Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,116 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, prepareThrowable) -> {\n+         if (prepareThrowable != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(prepareThrowable);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, rollbackThrowable) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (rollbackThrowable != null) {\n+                  rollbackThrowable.addSuppressed(prepareThrowable);\n+                  xe.initCause(rollbackThrowable);\n+               } else {\n+                  xe.initCause(prepareThrowable);\n+               }\n+               return CompletableFutures.completedExceptionFuture(xe);\n+            });\n+         }\n          if (localTransaction.isReadOnly()) {\n             if (trace) log.tracef(\"Readonly transaction: %s\", localTransaction.getGlobalTransaction());\n             // force a cleanup to release any objects held.  Some TMs don't call commit if it is a READ ONLY tx.  See ISPN-845\n-            commitInternal(ctx);\n-            return XA_RDONLY;\n+            return commitInternal(ctx)\n+                  .thenApply(XA_RDONLY_APPLY);\n          } else {\n             txTable.running().localTransactionPrepared(localTransaction);\n-            return XA_OK;\n+            return XA_OKAY_STAGE;\n          }\n-      } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n-         else\n-            log.errorProcessingPrepare(e);\n-\n-         //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n-         //after prepare failed.\n-         rollback(localTransaction);\n-         // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n-         XAException xe = new XAException(XAException.XA_RBROLLBACK);\n-         xe.initCause(e);\n-         throw xe;\n-      }\n+      });\n    }\n \n-   public boolean commit(LocalTransaction localTransaction, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Boolean> commit(LocalTransaction localTransaction, boolean isOnePhase) {\n       if (trace) log.tracef(\"Committing transaction %s\", localTransaction.getGlobalTransaction());\n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       if (isOnePhaseCommit(localTransaction) || isOnePhase) {\n-         validateNotMarkedForRollback(localTransaction);\n+         CompletionStage<Boolean> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+         if (markRollbackStage != null) {\n+            return markRollbackStage;\n+         }\n \n          if (trace) log.trace(\"Doing an 1PC prepare call on the interceptor chain\");\n          List<WriteCommand> modifications = localTransaction.getModifications();\n          PrepareCommand command = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), modifications, true);\n          try {\n-            invoker.running().invoke(ctx, command);\n+            return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n+                  (ignore, t) -> {\n+                     if (t != null) {\n+                        return handleCommitFailure(t, true, ctx);\n+                     }\n+                     return CompletableFutures.completedTrue();\n+                  });\n          } catch (Throwable e) {\n-            handleCommitFailure(e, true, ctx);\n+            return handleCommitFailure(e, true, ctx);", "originalCommit": "7010d9595ad27759c856085b70a23cdb08037080", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNTQ0MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395835441", "bodyText": "+1, yeah I didn't go back and double check I removed all of them.", "author": "wburns", "createdAt": "2020-03-20T19:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTU5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3173ad9f37dea0b47869ebe53bfb4a52ad870b61", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java b/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\nindex 9ccd1a6269..3a6a871d4a 100644\n--- a/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\n+++ b/core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java\n\n@@ -173,17 +173,13 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n          if (trace) log.trace(\"Doing an 1PC prepare call on the interceptor chain\");\n          List<WriteCommand> modifications = localTransaction.getModifications();\n          PrepareCommand command = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), modifications, true);\n-         try {\n-            return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n-                  (ignore, t) -> {\n-                     if (t != null) {\n-                        return handleCommitFailure(t, true, ctx);\n-                     }\n-                     return CompletableFutures.completedTrue();\n-                  });\n-         } catch (Throwable e) {\n-            return handleCommitFailure(e, true, ctx);\n-         }\n+         return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n+               (ignore, t) -> {\n+                  if (t != null) {\n+                     return handleCommitFailure(t, true, ctx);\n+                  }\n+                  return CompletableFutures.completedTrue();\n+               });\n       } else if (!localTransaction.isReadOnly()) {\n          return commitInternal(ctx);\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzMTkzMg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395831932", "bodyText": "Could have moved more common code here, e.g.\n  return CompletionStages.join(CompletableFutures.completedNull()\n        .thenComposeAsync(consumer, executor));", "author": "danberindei", "createdAt": "2020-03-20T18:53:29Z", "path": "core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java", "diffHunk": "@@ -177,4 +191,16 @@ public boolean equals(Object o) {\n    private boolean isFlag(int value, int flag) {\n       return (value & flag) != 0;\n    }\n+\n+   private <T> T joinAndRethrowXAException(CompletionStage<T> stage) throws XAException {\n+      try {\n+         return CompletionStages.join(stage);", "originalCommit": "7010d9595ad27759c856085b70a23cdb08037080", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNTc0MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395835741", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-03-20T19:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzMTkzMg=="}], "type": "inlineReview", "revised_code": {"commit": "3173ad9f37dea0b47869ebe53bfb4a52ad870b61", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java b/core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java\nindex 8b480460be..75e71698a6 100644\n--- a/core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java\n+++ b/core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java\n\n@@ -192,9 +189,10 @@ private boolean isFlag(int value, int flag) {\n       return (value & flag) != 0;\n    }\n \n-   private <T> T joinAndRethrowXAException(CompletionStage<T> stage) throws XAException {\n+   private <T> T runAsyncAndJoinRethrowingXAException(Function<Void, CompletionStage<T>> function) throws XAException {\n       try {\n-         return CompletionStages.join(stage);\n+         return CompletionStages.join(CompletableFutures.<Void>completedNull()\n+               .thenComposeAsync(function, executor));\n       } catch (CompletionException e) {\n          Throwable cause = e.getCause();\n          if (cause instanceof XAException) {\n"}}, {"oid": "3173ad9f37dea0b47869ebe53bfb4a52ad870b61", "url": "https://github.com/infinispan/infinispan/commit/3173ad9f37dea0b47869ebe53bfb4a52ad870b61", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T19:09:21Z", "type": "forcePushed"}, {"oid": "514d861666a6c3e1d7f874a41c3abb8b6c1b38e8", "url": "https://github.com/infinispan/infinispan/commit/514d861666a6c3e1d7f874a41c3abb8b6c1b38e8", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T19:11:06Z", "type": "forcePushed"}, {"oid": "6030cc125086a6b25768497a0e33d56fa849c4fe", "url": "https://github.com/infinispan/infinispan/commit/6030cc125086a6b25768497a0e33d56fa849c4fe", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T19:12:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0NTU4OA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395845588", "bodyText": "Don't need to wait for the tx completion responses before removing the local info here either, although since removing the local info is expensive you could still send the command first.", "author": "danberindei", "createdAt": "2020-03-20T19:22:31Z", "path": "core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java", "diffHunk": "@@ -128,38 +129,43 @@ public RecoveryIterator getPreparedTransactionsFromCluster() {\n    }\n \n    @Override\n-   public void removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, boolean sync, GlobalTransaction gtx,\n+   public CompletionStage<Void> removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, GlobalTransaction gtx,\n                                          boolean fromCluster) {\n       log.tracef(\"Forgetting tx information for %s\", gtx);\n       //todo make sure this gets broad casted or at least flushed\n       if (rpcManager != null && !fromCluster) {\n          TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(xid, gtx);\n-         sendTxCompletionNotification(lockOwners, ftc, sync);\n+         removeRecoveryInformation(xid);\n+         return sendTxCompletionNotification(lockOwners, ftc);\n+      } else {\n+         removeRecoveryInformation(xid);\n+         return CompletableFutures.completedNull();\n       }\n-      removeRecoveryInformation(xid);\n    }\n \n    @Override\n-   public void removeRecoveryInformationFromCluster(Collection<Address> where, long internalId, boolean sync) {\n+   public CompletionStage<Void> removeRecoveryInformationFromCluster(Collection<Address> where, long internalId) {\n       if (rpcManager != null) {\n          TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(internalId);\n-         sendTxCompletionNotification(where, ftc, sync);\n+         CompletionStage<Void> stage = sendTxCompletionNotification(where, ftc);\n+         return stage.thenRun(() -> removeRecoveryInformation(internalId));", "originalCommit": "6030cc125086a6b25768497a0e33d56fa849c4fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0Nzc4Nw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395847787", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-03-20T19:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0NTU4OA=="}], "type": "inlineReview", "revised_code": {"commit": "553b36dca7563b374d719d761567263767d83f4b", "chunk": "diff --git a/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java b/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java\nindex 5e100435d0..4120a213e3 100644\n--- a/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java\n+++ b/core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java\n\n@@ -135,8 +135,9 @@ public RecoveryIterator getPreparedTransactionsFromCluster() {\n       //todo make sure this gets broad casted or at least flushed\n       if (rpcManager != null && !fromCluster) {\n          TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(xid, gtx);\n+         CompletionStage<Void> stage = sendTxCompletionNotification(lockOwners, ftc);\n          removeRecoveryInformation(xid);\n-         return sendTxCompletionNotification(lockOwners, ftc);\n+         return stage;\n       } else {\n          removeRecoveryInformation(xid);\n          return CompletableFutures.completedNull();\n"}}, {"oid": "553b36dca7563b374d719d761567263767d83f4b", "url": "https://github.com/infinispan/infinispan/commit/553b36dca7563b374d719d761567263767d83f4b", "message": "ISPN-11489 TransactionCoordinator updated for non blocking", "committedDate": "2020-03-20T20:54:58Z", "type": "commit"}, {"oid": "b352ff46b2be9073a02be60700a174287da92915", "url": "https://github.com/infinispan/infinispan/commit/b352ff46b2be9073a02be60700a174287da92915", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-20T20:54:58Z", "type": "commit"}, {"oid": "0caa5b70c4753a36e746f2d70097f26e762a0fb6", "url": "https://github.com/infinispan/infinispan/commit/0caa5b70c4753a36e746f2d70097f26e762a0fb6", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T20:54:59Z", "type": "commit"}, {"oid": "0caa5b70c4753a36e746f2d70097f26e762a0fb6", "url": "https://github.com/infinispan/infinispan/commit/0caa5b70c4753a36e746f2d70097f26e762a0fb6", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T20:54:59Z", "type": "forcePushed"}]}