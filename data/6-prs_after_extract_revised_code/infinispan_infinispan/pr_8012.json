{"pr_number": 8012, "pr_title": "ISPN-11435 The server sometimes doesn't start all the caches", "pr_createdAt": "2020-03-07T14:58:20Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8012", "timeline": [{"oid": "693f45aee7823f287fe6678402e625260ee73459", "url": "https://github.com/infinispan/infinispan/commit/693f45aee7823f287fe6678402e625260ee73459", "message": "ISPN-11435 DefaultCacheManager should start all defined caches\n\nHotRodServer tries to pre-start all defined caches,\nbut this should happen everywhere, not just in the server.\n\nApplications/tests that want to start caches individually\ncan use the DefaultCacheManager constructors with a start\nparameter.", "committedDate": "2020-03-09T14:38:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc3NzY5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8012#discussion_r389777693", "bodyText": "This comment is no longer valid since you've moved things around", "author": "tristantarrant", "createdAt": "2020-03-09T15:44:11Z", "path": "core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java", "diffHunk": "@@ -107,24 +109,32 @@ void start() {\n          }\n       }\n \n+      // Install the listener\n+      GlobalConfigurationStateListener stateCacheListener = new GlobalConfigurationStateListener(this);\n+      getStateCache().addListener(stateCacheListener, new ScopeFilter(CACHE_SCOPE));\n+\n       // Initialize caches which are present in the initial state. We do this before installing the listener.", "originalCommit": "693f45aee7823f287fe6678402e625260ee73459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxNDQxNg==", "url": "https://github.com/infinispan/infinispan/pull/8012#discussion_r389814416", "bodyText": "True. I'm changing the listener to include the current state and I'm removing the explicit iteration.", "author": "danberindei", "createdAt": "2020-03-09T16:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc3NzY5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "cd1f3846b40da3e55781e9757bff5fc8c0f15733", "chunk": "diff --git a/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java b/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java\nindex 689136b2d4..4b10da8359 100644\n--- a/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java\n+++ b/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java\n\n@@ -106,35 +115,26 @@ void start() {\n                   persistedConfigurations.remove(cacheName);\n                }\n             }\n+            CompletionStages.join(createCacheLocally(cacheName, cacheState));\n          }\n-      }\n-\n-      // Install the listener\n-      GlobalConfigurationStateListener stateCacheListener = new GlobalConfigurationStateListener(this);\n-      getStateCache().addListener(stateCacheListener, new ScopeFilter(CACHE_SCOPE));\n-\n-      // Initialize caches which are present in the initial state. We do this before installing the listener.\n-      log.debugf(\"Starting caches from global state: %s\", getStateCache().keySet());\n-      for (Map.Entry<ScopedState, Object> e : getStateCache().entrySet()) {\n-         if (CACHE_SCOPE.equals(e.getKey().getScope())) {\n-            String cacheName = e.getKey().getName();\n-            CacheState cacheState = (CacheState) e.getValue();\n-            uncheckedAwait(createCacheLocally(cacheName, cacheState));\n+      });\n+\n+      // Create caches that are in the local persistent state but not in the global state\n+      persistedConfigurations.forEach((cacheName, configuration) -> {\n+         Configuration staticConfiguration = cacheManager.getCacheConfiguration(cacheName);\n+         if (staticConfiguration != null) {\n+            if (!staticConfiguration.matches(configuration)) {\n+               throw CONFIG.incompatiblePersistedConfiguration(cacheName, configuration, staticConfiguration);\n+            } else {\n+               // The cache configuration matches, we can skip it when iterating the ones from the local state\n+               persistedConfigurations.remove(cacheName);\n+            }\n          }\n-      }\n \n-      // Load any persistent caches that are not in the state cache\n-      log.debugf(\"Starting caches from local persisted state: %s\", persistedConfigurations.keySet());\n-      List<CompletableFuture<Configuration>> all = persistedConfigurations.entrySet().stream().map((entry) ->\n-            // The cache configuration was permanent, it still needs to be\n-            getOrCreateCache(entry.getKey(), entry.getValue(), EnumSet.noneOf(CacheContainerAdmin.AdminFlag.class))\n-      ).collect(Collectors.toList());\n-      uncheckedAwait(CompletableFutures.sequence(all));\n-\n-      Set<String> staticCacheNames = new HashSet<>(configurationManager.getDefinedCaches());\n-      staticCacheNames.removeAll(cacheManager.getCacheNames());\n-      log.debugf(\"Starting statically defined caches: %s\", staticCacheNames);\n-      cacheManager.startCaches(staticCacheNames.toArray(new String[0]));\n+         // The cache configuration was permanent, it still needs to be\n+         EnumSet<CacheContainerAdmin.AdminFlag> adminFlags = EnumSet.noneOf(CacheContainerAdmin.AdminFlag.class);\n+         CompletionStages.join(getOrCreateCache(cacheName, configuration, adminFlags));\n+      });\n    }\n \n    public Cache<ScopedState, Object> getStateCache() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwNzM1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8012#discussion_r389807359", "bodyText": "Why are you not starting the static caches before the persisted ones ?", "author": "tristantarrant", "createdAt": "2020-03-09T16:28:42Z", "path": "core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java", "diffHunk": "@@ -107,24 +109,32 @@ void start() {\n          }\n       }\n \n+      // Install the listener\n+      GlobalConfigurationStateListener stateCacheListener = new GlobalConfigurationStateListener(this);\n+      getStateCache().addListener(stateCacheListener, new ScopeFilter(CACHE_SCOPE));\n+\n       // Initialize caches which are present in the initial state. We do this before installing the listener.\n+      log.debugf(\"Starting caches from global state: %s\", getStateCache().keySet());\n       for (Map.Entry<ScopedState, Object> e : getStateCache().entrySet()) {\n          if (CACHE_SCOPE.equals(e.getKey().getScope())) {\n             String cacheName = e.getKey().getName();\n             CacheState cacheState = (CacheState) e.getValue();\n             uncheckedAwait(createCacheLocally(cacheName, cacheState));\n          }\n       }\n-      // Install the listener\n-      GlobalConfigurationStateListener stateCacheListener = new GlobalConfigurationStateListener(this);\n-      getStateCache().addListener(stateCacheListener, new ScopeFilter(CACHE_SCOPE));\n \n-      // Tell the LocalConfigurationManager that it can load any persistent caches\n+      // Load any persistent caches that are not in the state cache\n+      log.debugf(\"Starting caches from local persisted state: %s\", persistedConfigurations.keySet());\n       List<CompletableFuture<Configuration>> all = persistedConfigurations.entrySet().stream().map((entry) ->\n             // The cache configuration was permanent, it still needs to be\n             getOrCreateCache(entry.getKey(), entry.getValue(), EnumSet.noneOf(CacheContainerAdmin.AdminFlag.class))\n       ).collect(Collectors.toList());\n       uncheckedAwait(CompletableFutures.sequence(all));\n+\n+      Set<String> staticCacheNames = new HashSet<>(configurationManager.getDefinedCaches());", "originalCommit": "693f45aee7823f287fe6678402e625260ee73459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxNjM5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8012#discussion_r389816391", "bodyText": "It was a shortcut to avoid starting a cache with an incompatible configuration, since we already check compatibility for caches from local persistent state. But I'm now convinced that I need to replicate the compatibility check for statically defined caches anyway.", "author": "danberindei", "createdAt": "2020-03-09T16:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwNzM1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "cd1f3846b40da3e55781e9757bff5fc8c0f15733", "chunk": "diff --git a/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java b/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java\nindex 689136b2d4..4b10da8359 100644\n--- a/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java\n+++ b/core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java\n\n@@ -106,35 +115,26 @@ void start() {\n                   persistedConfigurations.remove(cacheName);\n                }\n             }\n+            CompletionStages.join(createCacheLocally(cacheName, cacheState));\n          }\n-      }\n-\n-      // Install the listener\n-      GlobalConfigurationStateListener stateCacheListener = new GlobalConfigurationStateListener(this);\n-      getStateCache().addListener(stateCacheListener, new ScopeFilter(CACHE_SCOPE));\n-\n-      // Initialize caches which are present in the initial state. We do this before installing the listener.\n-      log.debugf(\"Starting caches from global state: %s\", getStateCache().keySet());\n-      for (Map.Entry<ScopedState, Object> e : getStateCache().entrySet()) {\n-         if (CACHE_SCOPE.equals(e.getKey().getScope())) {\n-            String cacheName = e.getKey().getName();\n-            CacheState cacheState = (CacheState) e.getValue();\n-            uncheckedAwait(createCacheLocally(cacheName, cacheState));\n+      });\n+\n+      // Create caches that are in the local persistent state but not in the global state\n+      persistedConfigurations.forEach((cacheName, configuration) -> {\n+         Configuration staticConfiguration = cacheManager.getCacheConfiguration(cacheName);\n+         if (staticConfiguration != null) {\n+            if (!staticConfiguration.matches(configuration)) {\n+               throw CONFIG.incompatiblePersistedConfiguration(cacheName, configuration, staticConfiguration);\n+            } else {\n+               // The cache configuration matches, we can skip it when iterating the ones from the local state\n+               persistedConfigurations.remove(cacheName);\n+            }\n          }\n-      }\n \n-      // Load any persistent caches that are not in the state cache\n-      log.debugf(\"Starting caches from local persisted state: %s\", persistedConfigurations.keySet());\n-      List<CompletableFuture<Configuration>> all = persistedConfigurations.entrySet().stream().map((entry) ->\n-            // The cache configuration was permanent, it still needs to be\n-            getOrCreateCache(entry.getKey(), entry.getValue(), EnumSet.noneOf(CacheContainerAdmin.AdminFlag.class))\n-      ).collect(Collectors.toList());\n-      uncheckedAwait(CompletableFutures.sequence(all));\n-\n-      Set<String> staticCacheNames = new HashSet<>(configurationManager.getDefinedCaches());\n-      staticCacheNames.removeAll(cacheManager.getCacheNames());\n-      log.debugf(\"Starting statically defined caches: %s\", staticCacheNames);\n-      cacheManager.startCaches(staticCacheNames.toArray(new String[0]));\n+         // The cache configuration was permanent, it still needs to be\n+         EnumSet<CacheContainerAdmin.AdminFlag> adminFlags = EnumSet.noneOf(CacheContainerAdmin.AdminFlag.class);\n+         CompletionStages.join(getOrCreateCache(cacheName, configuration, adminFlags));\n+      });\n    }\n \n    public Cache<ScopedState, Object> getStateCache() {\n"}}, {"oid": "cd1f3846b40da3e55781e9757bff5fc8c0f15733", "url": "https://github.com/infinispan/infinispan/commit/cd1f3846b40da3e55781e9757bff5fc8c0f15733", "message": "f", "committedDate": "2020-03-10T17:02:52Z", "type": "forcePushed"}, {"oid": "237c6aa7a7a6eeb326e167a16c41ecbee6744ec1", "url": "https://github.com/infinispan/infinispan/commit/237c6aa7a7a6eeb326e167a16c41ecbee6744ec1", "message": "ISPN-11435 DefaultCacheManager should start all defined caches\n\nHotRodServer tries to pre-start all defined caches,\nbut this should happen everywhere, not just in the server.\n\nApplications/tests that want to start caches individually\ncan use the DefaultCacheManager constructors with a start\nparameter.", "committedDate": "2020-03-11T10:34:52Z", "type": "forcePushed"}, {"oid": "2d8a8e99b5be996153cfc346fd639ba4a4ff3ae2", "url": "https://github.com/infinispan/infinispan/commit/2d8a8e99b5be996153cfc346fd639ba4a4ff3ae2", "message": "ISPN-11435 DefaultCacheManager should start all defined caches\n\nHotRodServer tries to pre-start all defined caches,\nbut this should happen everywhere, not just in the server.\n\nCaches are started on a single thread, to avoid overloading\nthe blocking thread pool.\n\nApplications/tests that want to start caches individually\nhave to define the caches after starting the DefaultCacheManager.", "committedDate": "2020-03-11T10:35:46Z", "type": "forcePushed"}, {"oid": "f603ff8d88efbefb200af5365b00e6e4f42831fc", "url": "https://github.com/infinispan/infinispan/commit/f603ff8d88efbefb200af5365b00e6e4f42831fc", "message": "ISPN-11435 DefaultCacheManager should start all defined caches\n\nHotRodServer tries to pre-start all defined caches,\nbut this should happen everywhere, not just in the server.\n\nCaches are started on a single thread, to avoid overloading\nthe blocking thread pool.\n\nApplications/tests that want to start caches individually\nhave to define the caches after starting the DefaultCacheManager.", "committedDate": "2020-03-11T15:42:24Z", "type": "commit"}, {"oid": "f603ff8d88efbefb200af5365b00e6e4f42831fc", "url": "https://github.com/infinispan/infinispan/commit/f603ff8d88efbefb200af5365b00e6e4f42831fc", "message": "ISPN-11435 DefaultCacheManager should start all defined caches\n\nHotRodServer tries to pre-start all defined caches,\nbut this should happen everywhere, not just in the server.\n\nCaches are started on a single thread, to avoid overloading\nthe blocking thread pool.\n\nApplications/tests that want to start caches individually\nhave to define the caches after starting the DefaultCacheManager.", "committedDate": "2020-03-11T15:42:24Z", "type": "forcePushed"}]}