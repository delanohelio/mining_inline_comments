{"pr_number": 8611, "pr_title": "ISPN-12095 CLI: Add support for cluster backup/restore", "pr_createdAt": "2020-08-06T13:40:40Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8611", "timeline": [{"oid": "dbe49a7bb71fdf20f2286ede10545c62128fe11c", "url": "https://github.com/infinispan/infinispan/commit/dbe49a7bb71fdf20f2286ede10545c62128fe11c", "message": "ISPN-12095 Documentation", "committedDate": "2020-08-06T13:55:03Z", "type": "forcePushed"}, {"oid": "dae0ee6c6b6101f9db10fcf7fe50971cbfec9a6a", "url": "https://github.com/infinispan/infinispan/commit/dae0ee6c6b6101f9db10fcf7fe50971cbfec9a6a", "message": "ISPN-12095 Documentation", "committedDate": "2020-08-07T14:46:06Z", "type": "forcePushed"}, {"oid": "8bd6348143a5feaf94e99a8862e0cd28484a260c", "url": "https://github.com/infinispan/infinispan/commit/8bd6348143a5feaf94e99a8862e0cd28484a260c", "message": "ISPN-12095 Documentation", "committedDate": "2020-08-11T08:57:22Z", "type": "forcePushed"}, {"oid": "88d07667dda1b00b522a03b21be08960f454b36c", "url": "https://github.com/infinispan/infinispan/commit/88d07667dda1b00b522a03b21be08960f454b36c", "message": "ISPN-12095 Documentation", "committedDate": "2020-08-12T09:51:58Z", "type": "forcePushed"}, {"oid": "864d02978dd6e35fcbac37cc3197bf88ebd267a9", "url": "https://github.com/infinispan/infinispan/commit/864d02978dd6e35fcbac37cc3197bf88ebd267a9", "message": "ISPN-11723 Documentation updates", "committedDate": "2020-08-12T11:41:23Z", "type": "forcePushed"}, {"oid": "0ba74d25a48e893a48ae7cbaf6f40f3f6e8f8a8c", "url": "https://github.com/infinispan/infinispan/commit/0ba74d25a48e893a48ae7cbaf6f40f3f6e8f8a8c", "message": "ISPN-11723 Documentation updates", "committedDate": "2020-08-12T15:02:02Z", "type": "forcePushed"}, {"oid": "cc72678162c07d75647ec9d77b3b61bcb0663dba", "url": "https://github.com/infinispan/infinispan/commit/cc72678162c07d75647ec9d77b3b61bcb0663dba", "message": "ISPN-12095 Documentation", "committedDate": "2020-08-18T10:55:53Z", "type": "forcePushed"}, {"oid": "b31e8b1c727cf38eaf75e0c0ef8b4ebbd3592ab2", "url": "https://github.com/infinispan/infinispan/commit/b31e8b1c727cf38eaf75e0c0ef8b4ebbd3592ab2", "message": "ISPN-12095 Documentation", "committedDate": "2020-08-20T13:45:51Z", "type": "forcePushed"}, {"oid": "38cc7f55306b8b596c11d60826c6cc9298f4f000", "url": "https://github.com/infinispan/infinispan/commit/38cc7f55306b8b596c11d60826c6cc9298f4f000", "message": "ISPN-12095 Documentation", "committedDate": "2020-08-20T15:02:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0OTY5NA==", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482949694", "bodyText": "the cast can't fail ?", "author": "karesti", "createdAt": "2020-09-03T12:46:18Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Backup.java", "diffHunk": "@@ -0,0 +1,221 @@\n+package org.infinispan.cli.commands;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.aesh.io.FileResource;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.completers.BackupCompleter;\n+import org.infinispan.cli.completers.CacheCompleter;\n+import org.infinispan.cli.completers.CacheConfigurationCompleter;\n+import org.infinispan.cli.completers.CounterCompleter;\n+import org.infinispan.cli.completers.SchemaCompleter;\n+import org.infinispan.cli.completers.TaskCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Backup.CMD, description = \"Manages container backup creation and restoration\", activator = ConnectionActivator.class,\n+      groupCommands = {Backup.Create.class, Backup.Delete.class, Backup.Get.class, Backup.ListBackups.class, Backup.Restore.class})\n+public class Backup extends CliCommand {\n+\n+   public static final String CMD = \"backup\";\n+   public static final String CACHES = \"caches\";\n+   public static final String CACHE_CONFIGS = \"cache-configs\";\n+   public static final String COUNTERS = \"counters\";\n+   public static final String PROTO_SCHEMAS = \"proto-schemas\";\n+   public static final String SCRIPTS = \"scripts\";\n+   public static final String[] ALL_RESOURCE_TYPES = new String[]{CACHES, CACHE_CONFIGS, COUNTERS, PROTO_SCHEMAS, SCRIPTS};\n+\n+   @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   public static Map<String, List<String>> createResourceMap(CommandInputLine cmd) {\n+      Map<String, List<String>> resourceMap = new HashMap<>();\n+      for (String resource : Backup.ALL_RESOURCE_TYPES) {\n+         if (cmd.hasArg(resource)) {\n+            resourceMap.put(resource, cmd.argAs(resource));\n+         }\n+      }\n+      return resourceMap;\n+   }\n+\n+   @CommandDefinition(name = Delete.CMD, description = \"Delete a backup on the server\", activator = ConnectionActivator.class)\n+   public static class Delete extends AbstractBackupCommand {\n+      public static final String CMD = \"delete\";\n+\n+      @Argument(description = \"The name of the backup\", completer = BackupCompleter.class, required = true)\n+      String name;\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         return invocation.execute(\n+               new CommandInputLine(Backup.CMD)\n+                     .arg(TYPE, CMD)\n+                     .arg(NAME, name)\n+         );\n+      }\n+   }\n+\n+   @CommandDefinition(name = Get.CMD, description = \"Get a backup from the server\", activator = ConnectionActivator.class)\n+   public static class Get extends AbstractBackupCommand {\n+      public static final String CMD = \"get\";\n+      public static final String NO_CONTENT = \"no-content\";\n+\n+      @Argument(description = \"The name of the backup\", completer = BackupCompleter.class, required = true)\n+      String name;\n+\n+      @Option(description = \"No content is downloaded, but the command only returns once the backup has finished\", hasValue = false, name = NO_CONTENT)\n+      boolean noContent;\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         return invocation.execute(\n+               new CommandInputLine(Backup.CMD)\n+                     .arg(TYPE, CMD)\n+                     .arg(NAME, name)\n+                     .option(NO_CONTENT, noContent)\n+         );\n+      }\n+   }\n+\n+   @CommandDefinition(name = ListBackups.CMD, description = \"List all backups on the server\", activator = ConnectionActivator.class)\n+   public static class ListBackups extends AbstractBackupCommand {\n+      public static final String CMD = \"ls\";\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         return invocation.execute(\n+               new CommandInputLine(Backup.CMD)\n+                     .arg(TYPE, CMD)\n+         );\n+      }\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Create a backup on the server\", activator = ConnectionActivator.class)\n+   public static class Create extends AbstractResourceCommand {\n+      public static final String CMD = \"create\";\n+      public static final String DIR = \"dir\";\n+\n+      @Option(shortName = 'd', description = \"The directory on the server to be used for creating and storing the backup\")\n+      String dir;\n+\n+      @Option(shortName = 'n', description = \"The name of the backup\")\n+      String name;\n+\n+      public Create() {\n+         super(CMD);\n+      }\n+\n+      @Override\n+      protected void additionalArgs(CommandInputLine cmd) {\n+         cmd.option(DIR, dir)\n+               .option(NAME, name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = Restore.CMD, description = \"Restore a backup\", activator = ConnectionActivator.class)\n+   public static class Restore extends AbstractResourceCommand {\n+      public static final String CMD = \"restore\";\n+      public static final String UPLOAD_BACKUP = \"upload-backup\";\n+\n+      @Argument(description = \"The path of the backup file \", completer = FileOptionCompleter.class, required = true)\n+      Resource path;\n+\n+      @Option(shortName = 'u', description = \"Indicates that the path is a local file which must be uploaded to the server\", hasValue = false, name = UPLOAD_BACKUP)\n+      boolean upload;\n+\n+      public Restore() {\n+         super(CMD);\n+      }\n+\n+      @Override\n+      protected void additionalArgs(CommandInputLine cmd) {\n+         if (!upload && !((FileResource) path).getFile().isAbsolute())", "originalCommit": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3NDMzMA==", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482974330", "bodyText": "I don't think so, the only other implementation is PipelineResource which returns \"\" or false for all methods. Unfortunately it's not possible to use FileResource directly as the variable type, because aesh does not know how to set the value, resulting in a NPE being thrown.", "author": "ryanemerson", "createdAt": "2020-09-03T13:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0OTY5NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MTQxMg==", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482951412", "bodyText": "javadoc ?", "author": "karesti", "createdAt": "2020-09-03T12:49:07Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/completers/BackupCompleter.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package org.infinispan.cli.completers;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+\n+import org.infinispan.cli.Context;\n+import org.infinispan.cli.connection.Connection;\n+\n+/**\n+ * @author Ryan Emerson", "originalCommit": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b650b494886e8151273811969091be0d066cb5a", "chunk": "diff --git a/cli/cli-client/src/main/java/org/infinispan/cli/completers/BackupCompleter.java b/cli/cli-client/src/main/java/org/infinispan/cli/completers/BackupCompleter.java\nindex ffbf9074c0..16cdfb5f9e 100644\n--- a/cli/cli-client/src/main/java/org/infinispan/cli/completers/BackupCompleter.java\n+++ b/cli/cli-client/src/main/java/org/infinispan/cli/completers/BackupCompleter.java\n\n@@ -7,6 +7,8 @@\n import org.infinispan.cli.connection.Connection;\n \n /**\n+ * A {@link org.aesh.command.completer.OptionCompleter} for Backup files that are available on the server.\n+ *\n  * @author Ryan Emerson\n  * @since 12.0\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MTQ5OQ==", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482951499", "bodyText": "javadoc ?", "author": "karesti", "createdAt": "2020-09-03T12:49:15Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/completers/SchemaCompleter.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package org.infinispan.cli.completers;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import org.infinispan.cli.Context;\n+import org.infinispan.cli.connection.Connection;\n+import org.infinispan.cli.resources.ContainerResource;\n+\n+/**\n+ * @author Ryan Emerson", "originalCommit": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b650b494886e8151273811969091be0d066cb5a", "chunk": "diff --git a/cli/cli-client/src/main/java/org/infinispan/cli/completers/SchemaCompleter.java b/cli/cli-client/src/main/java/org/infinispan/cli/completers/SchemaCompleter.java\nindex 44f40415b7..b93216956e 100644\n--- a/cli/cli-client/src/main/java/org/infinispan/cli/completers/SchemaCompleter.java\n+++ b/cli/cli-client/src/main/java/org/infinispan/cli/completers/SchemaCompleter.java\n\n@@ -9,6 +9,8 @@\n import org.infinispan.cli.resources.ContainerResource;\n \n /**\n+ * A {@link org.aesh.command.completer.OptionCompleter} for proto schemas that are available on the server.\n+ *\n  * @author Ryan Emerson\n  * @since 12.0\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NDQzNg==", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482954436", "bodyText": "shouldn't this have a line break at the end ?", "author": "karesti", "createdAt": "2020-09-03T12:53:53Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "diffHunk": "@@ -247,6 +257,60 @@ public String execute(List<CommandInputLine> commands) throws IOException {\n                }\n                break;\n             }\n+            case Backup.CMD: {\n+               String container = getActiveContainer().getName();\n+               RestCacheManagerClient manager = this.client.cacheManager(container);\n+               responseMode = ResponseMode.BODY;\n+               String backupName;\n+               switch (command.arg(CliCommand.TYPE)) {\n+                  case Backup.Create.CMD:\n+                     backupName = command.optionOrDefault(Backup.NAME, () -> {\n+                        // If the backup name has not been specified generate one based upon the Infinispan version and timestamp\n+                        LocalDateTime now = LocalDateTime.now();\n+                        return String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS\\n\", Version.getBrandName(), now);\n+                     });\n+\n+                     sb.append(\"Creating backup '\").append(backupName).append(\"'\");", "originalCommit": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MDgyOA==", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482960828", "bodyText": "It's unnecessary, as the return value of execute(commands) is written via writeln(). \n  \n    \n      infinispan/cli/cli-client/src/main/java/org/infinispan/cli/impl/ContextImpl.java\n    \n    \n        Lines 221 to 224\n      in\n      fa05280\n    \n    \n    \n    \n\n        \n          \n           String response = connection.execute(commands); \n        \n\n        \n          \n           if (response != null && !response.isEmpty()) { \n        \n\n        \n          \n              shell.writeln(response); \n        \n\n        \n          \n           }", "author": "ryanemerson", "createdAt": "2020-09-03T13:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NDQzNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NDU3NA==", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482954574", "bodyText": "same, line break ?", "author": "karesti", "createdAt": "2020-09-03T12:54:06Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "diffHunk": "@@ -247,6 +257,60 @@ public String execute(List<CommandInputLine> commands) throws IOException {\n                }\n                break;\n             }\n+            case Backup.CMD: {\n+               String container = getActiveContainer().getName();\n+               RestCacheManagerClient manager = this.client.cacheManager(container);\n+               responseMode = ResponseMode.BODY;\n+               String backupName;\n+               switch (command.arg(CliCommand.TYPE)) {\n+                  case Backup.Create.CMD:\n+                     backupName = command.optionOrDefault(Backup.NAME, () -> {\n+                        // If the backup name has not been specified generate one based upon the Infinispan version and timestamp\n+                        LocalDateTime now = LocalDateTime.now();\n+                        return String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS\\n\", Version.getBrandName(), now);\n+                     });\n+\n+                     sb.append(\"Creating backup '\").append(backupName).append(\"'\");\n+                     String directory = command.arg(Backup.Create.DIR);\n+                     response = manager.createBackup(backupName, directory, Backup.createResourceMap(command));\n+                     break;\n+                  case Backup.Delete.CMD:\n+                     backupName = command.arg(Backup.NAME);\n+                     sb.append(\"Deleting backup '\").append(backupName).append(\"'\");", "originalCommit": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTI2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482955261", "bodyText": "line break ?", "author": "karesti", "createdAt": "2020-09-03T12:55:03Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "diffHunk": "@@ -247,6 +257,60 @@ public String execute(List<CommandInputLine> commands) throws IOException {\n                }\n                break;\n             }\n+            case Backup.CMD: {\n+               String container = getActiveContainer().getName();\n+               RestCacheManagerClient manager = this.client.cacheManager(container);\n+               responseMode = ResponseMode.BODY;\n+               String backupName;\n+               switch (command.arg(CliCommand.TYPE)) {\n+                  case Backup.Create.CMD:\n+                     backupName = command.optionOrDefault(Backup.NAME, () -> {\n+                        // If the backup name has not been specified generate one based upon the Infinispan version and timestamp\n+                        LocalDateTime now = LocalDateTime.now();\n+                        return String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS\\n\", Version.getBrandName(), now);\n+                     });\n+\n+                     sb.append(\"Creating backup '\").append(backupName).append(\"'\");\n+                     String directory = command.arg(Backup.Create.DIR);\n+                     response = manager.createBackup(backupName, directory, Backup.createResourceMap(command));\n+                     break;\n+                  case Backup.Delete.CMD:\n+                     backupName = command.arg(Backup.NAME);\n+                     sb.append(\"Deleting backup '\").append(backupName).append(\"'\");\n+                     response = manager.deleteBackup(backupName);\n+                     break;\n+                  case Backup.Get.CMD:\n+                     boolean skipBody = command.boolOption(Backup.Get.NO_CONTENT);\n+                     responseMode = skipBody ? ResponseMode.QUIET : ResponseMode.FILE;\n+                     backupName = command.arg(Backup.NAME);\n+                     sb.append(\"Downloading backup '\").append(backupName).append(\"'\\n\");\n+                     // Poll the backup's availability every 500 milliseconds with a maximum of 100 attempts\n+                     response = Flowable.timer(500, TimeUnit.MILLISECONDS, Schedulers.trampoline())\n+                           .repeat(100)\n+                           .flatMapSingle(Void -> Single.fromCompletionStage(manager.getBackup(backupName, skipBody)))\n+                           .takeUntil(rsp -> rsp.getStatus() != 202)\n+                           .lastOrErrorStage();\n+                     break;\n+                  case Backup.ListBackups.CMD:\n+                     sb.append(String.join(\"\\n\", getBackupNames(container)));\n+                     break;\n+                  case Backup.Restore.CMD:\n+                     Map<String, List<String>> resources = Backup.createResourceMap(command);\n+                     Boolean upload = command.argAs(Backup.Restore.UPLOAD_BACKUP);\n+                     FileResource resource = command.argAs(Backup.Restore.PATH);\n+                     if (upload != null && upload) {\n+                        File file = resource.getFile();\n+                        sb.append(\"Uploading backup '\").append(file.getName()).append(\"' and restoring\");", "originalCommit": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTM3OA==", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482955378", "bodyText": "line break ?", "author": "karesti", "createdAt": "2020-09-03T12:55:14Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "diffHunk": "@@ -247,6 +257,60 @@ public String execute(List<CommandInputLine> commands) throws IOException {\n                }\n                break;\n             }\n+            case Backup.CMD: {\n+               String container = getActiveContainer().getName();\n+               RestCacheManagerClient manager = this.client.cacheManager(container);\n+               responseMode = ResponseMode.BODY;\n+               String backupName;\n+               switch (command.arg(CliCommand.TYPE)) {\n+                  case Backup.Create.CMD:\n+                     backupName = command.optionOrDefault(Backup.NAME, () -> {\n+                        // If the backup name has not been specified generate one based upon the Infinispan version and timestamp\n+                        LocalDateTime now = LocalDateTime.now();\n+                        return String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS\\n\", Version.getBrandName(), now);\n+                     });\n+\n+                     sb.append(\"Creating backup '\").append(backupName).append(\"'\");\n+                     String directory = command.arg(Backup.Create.DIR);\n+                     response = manager.createBackup(backupName, directory, Backup.createResourceMap(command));\n+                     break;\n+                  case Backup.Delete.CMD:\n+                     backupName = command.arg(Backup.NAME);\n+                     sb.append(\"Deleting backup '\").append(backupName).append(\"'\");\n+                     response = manager.deleteBackup(backupName);\n+                     break;\n+                  case Backup.Get.CMD:\n+                     boolean skipBody = command.boolOption(Backup.Get.NO_CONTENT);\n+                     responseMode = skipBody ? ResponseMode.QUIET : ResponseMode.FILE;\n+                     backupName = command.arg(Backup.NAME);\n+                     sb.append(\"Downloading backup '\").append(backupName).append(\"'\\n\");\n+                     // Poll the backup's availability every 500 milliseconds with a maximum of 100 attempts\n+                     response = Flowable.timer(500, TimeUnit.MILLISECONDS, Schedulers.trampoline())\n+                           .repeat(100)\n+                           .flatMapSingle(Void -> Single.fromCompletionStage(manager.getBackup(backupName, skipBody)))\n+                           .takeUntil(rsp -> rsp.getStatus() != 202)\n+                           .lastOrErrorStage();\n+                     break;\n+                  case Backup.ListBackups.CMD:\n+                     sb.append(String.join(\"\\n\", getBackupNames(container)));\n+                     break;\n+                  case Backup.Restore.CMD:\n+                     Map<String, List<String>> resources = Backup.createResourceMap(command);\n+                     Boolean upload = command.argAs(Backup.Restore.UPLOAD_BACKUP);\n+                     FileResource resource = command.argAs(Backup.Restore.PATH);\n+                     if (upload != null && upload) {\n+                        File file = resource.getFile();\n+                        sb.append(\"Uploading backup '\").append(file.getName()).append(\"' and restoring\");\n+                        response = manager.restore(file, resources);\n+                     } else {\n+                        String path = resource.getAbsolutePath();\n+                        sb.append(\"Restoring from backup '\").append(path).append(\"'\");", "originalCommit": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "8b650b494886e8151273811969091be0d066cb5a", "url": "https://github.com/infinispan/infinispan/commit/8b650b494886e8151273811969091be0d066cb5a", "message": "ISPN-12095 CLI: Add support for cluster backup/restore", "committedDate": "2020-09-03T13:25:22Z", "type": "commit"}, {"oid": "1460d136d5081d4212ad2fd43c81dfe289d76299", "url": "https://github.com/infinispan/infinispan/commit/1460d136d5081d4212ad2fd43c81dfe289d76299", "message": "ISPN-12095 Documentation", "committedDate": "2020-09-03T13:25:22Z", "type": "commit"}, {"oid": "1460d136d5081d4212ad2fd43c81dfe289d76299", "url": "https://github.com/infinispan/infinispan/commit/1460d136d5081d4212ad2fd43c81dfe289d76299", "message": "ISPN-12095 Documentation", "committedDate": "2020-09-03T13:25:22Z", "type": "forcePushed"}]}