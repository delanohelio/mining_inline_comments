{"pr_number": 8129, "pr_title": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "pr_createdAt": "2020-03-31T10:14:13Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8129", "timeline": [{"oid": "3321164f16317c08f7404514fd20fa5b52d3e164", "url": "https://github.com/infinispan/infinispan/commit/3321164f16317c08f7404514fd20fa5b52d3e164", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-03-31T10:14:42Z", "type": "forcePushed"}, {"oid": "5781343b1f04b53900c78da8caba1bf452374b86", "url": "https://github.com/infinispan/infinispan/commit/5781343b1f04b53900c78da8caba1bf452374b86", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-01T08:25:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0ODIxOA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401448218", "bodyText": "If/Else to avoid unnecessary assignment?", "author": "ryanemerson", "createdAt": "2020-04-01T08:39:48Z", "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -400,9 +400,16 @@ V mergeInternal(K key, V value, BiFunction<? super V, ? super V, ? extends V> re\n       assertKeyNotNull(key);\n       assertValueNotNull(value);\n       assertFunctionNotNull(remappingFunction);\n+      DataConversion keyDataConversion = getKeyDataConversion();\n+      DataConversion valueDataConversion = getValueDataConversion();\n+      if (remappingFunction instanceof BiFunctionMapper) {\n+         BiFunctionMapper biFunctionMapper = (BiFunctionMapper) remappingFunction;\n+         keyDataConversion = biFunctionMapper.getKeyDataConversion();\n+         valueDataConversion = biFunctionMapper.getValueDataConversion();\n+      }", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1NjAxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402256011", "bodyText": "I am not really happy with that if, but it's an underlying issue with functional commands and DataConversion objects, I will address it in another JIRA: https://issues.redhat.com/browse/ISPN-11584", "author": "gustavonalle", "createdAt": "2020-04-02T11:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0ODIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc3Mjk3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402772975", "bodyText": "What about compute, computeIfPresent, and computeIfAbsent?", "author": "danberindei", "createdAt": "2020-04-03T06:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0ODIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5MDMxMw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402890313", "bodyText": "compute doesn't use Functional commands, so it should be fine", "author": "gustavonalle", "createdAt": "2020-04-03T09:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0ODIxOA=="}], "type": "inlineReview", "revised_code": {"commit": "1b4b413869c7311ed37698c92bea52da19475315", "chunk": "diff --git a/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java b/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\nindex 441d5f6fcc..378ea0c21d 100644\n--- a/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\n+++ b/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java\n\n@@ -400,12 +400,16 @@ V mergeInternal(K key, V value, BiFunction<? super V, ? super V, ? extends V> re\n       assertKeyNotNull(key);\n       assertValueNotNull(value);\n       assertFunctionNotNull(remappingFunction);\n-      DataConversion keyDataConversion = getKeyDataConversion();\n-      DataConversion valueDataConversion = getValueDataConversion();\n+      DataConversion keyDataConversion;\n+      DataConversion valueDataConversion;\n+      //TODO: Correctly propagate DataConversion objects https://issues.redhat.com/browse/ISPN-11584\n       if (remappingFunction instanceof BiFunctionMapper) {\n          BiFunctionMapper biFunctionMapper = (BiFunctionMapper) remappingFunction;\n          keyDataConversion = biFunctionMapper.getKeyDataConversion();\n          valueDataConversion = biFunctionMapper.getValueDataConversion();\n+      } else {\n+         keyDataConversion = getKeyDataConversion();\n+         valueDataConversion = getValueDataConversion();\n       }\n       ReadWriteKeyCommand<K, V, V> command = commandsFactory.buildReadWriteKeyCommand(key,\n             new MergeFunction<>(value, remappingFunction, metadata), keyPartitioner.getSegment(key),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MTYzMg==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401451632", "bodyText": "Redundant comment", "author": "ryanemerson", "createdAt": "2020-04-01T08:45:38Z", "path": "core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java", "diffHunk": "@@ -32,12 +33,26 @@ public V apply(EntryView.ReadWriteEntryView<K, V> entry) {\n       try {\n          V merged = value;\n          if (entry.find().isPresent()) {\n-            merged = remappingFunction.apply(entry.get(), value);\n+            V t = entry.get();\n+            if (remappingFunction instanceof BiFunctionMapper) {\n+               BiFunctionMapper mapper = (BiFunctionMapper) this.remappingFunction;\n+               Object toStorage = mapper.getValueDataConversion().toStorage(t);\n+               merged = remappingFunction.apply((V) toStorage, value);\n+//               merged = remappingFunction.apply((V)fromStorage, value);", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1b4b413869c7311ed37698c92bea52da19475315", "chunk": "diff --git a/core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java b/core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java\nindex ceb6bfc485..ba232cf486 100644\n--- a/core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java\n+++ b/core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java\n\n@@ -38,21 +38,18 @@ public V apply(EntryView.ReadWriteEntryView<K, V> entry) {\n                BiFunctionMapper mapper = (BiFunctionMapper) this.remappingFunction;\n                Object toStorage = mapper.getValueDataConversion().toStorage(t);\n                merged = remappingFunction.apply((V) toStorage, value);\n-//               merged = remappingFunction.apply((V)fromStorage, value);\n             } else {\n                merged = remappingFunction.apply(t, value);\n             }\n          }\n          if (merged == null) {\n             entry.set(merged);\n+         } else if (remappingFunction instanceof BiFunctionMapper) {\n+            BiFunctionMapper mapper = (BiFunctionMapper) this.remappingFunction;\n+            Object fromStorage = mapper.getValueDataConversion().fromStorage(merged);\n+            entry.set((V) fromStorage, metadata);\n          } else {\n-            if (remappingFunction instanceof BiFunctionMapper) {\n-               BiFunctionMapper mapper = (BiFunctionMapper) this.remappingFunction;\n-               Object fromStorage = mapper.getValueDataConversion().fromStorage(merged);\n-               entry.set((V) fromStorage, metadata);\n-            } else {\n-               entry.set(merged, metadata);\n-            }\n+            entry.set(merged, metadata);\n          }\n          return merged;\n       } catch (Exception ex) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MjM4MA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401452380", "bodyText": "else if?", "author": "ryanemerson", "createdAt": "2020-04-01T08:46:51Z", "path": "core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java", "diffHunk": "@@ -32,12 +33,26 @@ public V apply(EntryView.ReadWriteEntryView<K, V> entry) {\n       try {\n          V merged = value;\n          if (entry.find().isPresent()) {\n-            merged = remappingFunction.apply(entry.get(), value);\n+            V t = entry.get();\n+            if (remappingFunction instanceof BiFunctionMapper) {\n+               BiFunctionMapper mapper = (BiFunctionMapper) this.remappingFunction;\n+               Object toStorage = mapper.getValueDataConversion().toStorage(t);\n+               merged = remappingFunction.apply((V) toStorage, value);\n+//               merged = remappingFunction.apply((V)fromStorage, value);\n+            } else {\n+               merged = remappingFunction.apply(t, value);\n+            }\n          }\n          if (merged == null) {\n             entry.set(merged);\n          } else {\n-            entry.set(merged, metadata);\n+            if (remappingFunction instanceof BiFunctionMapper) {", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1b4b413869c7311ed37698c92bea52da19475315", "chunk": "diff --git a/core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java b/core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java\nindex ceb6bfc485..ba232cf486 100644\n--- a/core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java\n+++ b/core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java\n\n@@ -38,21 +38,18 @@ public V apply(EntryView.ReadWriteEntryView<K, V> entry) {\n                BiFunctionMapper mapper = (BiFunctionMapper) this.remappingFunction;\n                Object toStorage = mapper.getValueDataConversion().toStorage(t);\n                merged = remappingFunction.apply((V) toStorage, value);\n-//               merged = remappingFunction.apply((V)fromStorage, value);\n             } else {\n                merged = remappingFunction.apply(t, value);\n             }\n          }\n          if (merged == null) {\n             entry.set(merged);\n+         } else if (remappingFunction instanceof BiFunctionMapper) {\n+            BiFunctionMapper mapper = (BiFunctionMapper) this.remappingFunction;\n+            Object fromStorage = mapper.getValueDataConversion().fromStorage(merged);\n+            entry.set((V) fromStorage, metadata);\n          } else {\n-            if (remappingFunction instanceof BiFunctionMapper) {\n-               BiFunctionMapper mapper = (BiFunctionMapper) this.remappingFunction;\n-               Object fromStorage = mapper.getValueDataConversion().fromStorage(merged);\n-               entry.set((V) fromStorage, metadata);\n-            } else {\n-               entry.set(merged, metadata);\n-            }\n+            entry.set(merged, metadata);\n          }\n          return merged;\n       } catch (Exception ex) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MzAxNQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401453015", "bodyText": "Method is never used.", "author": "ryanemerson", "createdAt": "2020-04-01T08:47:53Z", "path": "commons/all/src/main/java/org/infinispan/commons/dataconversion/MediaType.java", "diffHunk": "@@ -245,6 +245,12 @@ public boolean hasStringType() {\n       return classType != null && classType.equals(String.class.getName());\n    }\n \n+   public boolean isBinary() {", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1NDY0MA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402254640", "bodyText": "It will be used very soon in https://issues.redhat.com/browse/ISPN-11424", "author": "gustavonalle", "createdAt": "2020-04-02T11:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjU5NDc1NA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402594754", "bodyText": "Shouldn't it be in another PR then?", "author": "danberindei", "createdAt": "2020-04-02T20:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5MTA0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402891045", "bodyText": "I can remove it and add it later, np", "author": "gustavonalle", "createdAt": "2020-04-03T09:52:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MzAxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "chunk": "diff --git a/commons/all/src/main/java/org/infinispan/commons/dataconversion/MediaType.java b/commons/all/src/main/java/org/infinispan/commons/dataconversion/MediaType.java\nindex 2761aa1352..9b33cb02fd 100644\n--- a/commons/all/src/main/java/org/infinispan/commons/dataconversion/MediaType.java\n+++ b/commons/all/src/main/java/org/infinispan/commons/dataconversion/MediaType.java\n\n@@ -245,12 +245,6 @@ public boolean hasStringType() {\n       return classType != null && classType.equals(String.class.getName());\n    }\n \n-   public boolean isBinary() {\n-      String customType = getClassType();\n-      if (customType == null) return !this.match(MediaType.APPLICATION_OBJECT);\n-      return \"ByteArray\".equals(customType);\n-   }\n-\n    @Override\n    public boolean equals(Object o) {\n       if (this == o) return true;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1NDUyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401454525", "bodyText": "We should remove org.infinispan.server.core.dataconversion.ProtostreamTranscoder and update it's usage to this class.", "author": "ryanemerson", "createdAt": "2020-04-01T08:50:14Z", "path": "core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package org.infinispan.encoding;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OBJECT;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OCTET_STREAM;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_PROTOSTREAM;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_UNKNOWN;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN;\n+import static org.infinispan.commons.dataconversion.StandardConversions.convertTextToObject;\n+import static org.infinispan.commons.dataconversion.StandardConversions.decodeOctetStream;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.Optional;\n+\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.dataconversion.OneToManyTranscoder;\n+import org.infinispan.commons.dataconversion.StandardConversions;\n+import org.infinispan.commons.marshall.WrappedByteArray;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.ProtobufUtil;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * Transcode between application/x-protostream and commons formats\n+ *\n+ * @since 10.0\n+ */\n+public class ProtostreamTranscoder extends OneToManyTranscoder {", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1NTQ1OA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402255458", "bodyText": "Ops, forgot about it", "author": "gustavonalle", "createdAt": "2020-04-02T11:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1NDUyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "chunk": "diff --git a/core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java b/core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java\nindex 4411d2b8c4..3dc7058f8b 100644\n--- a/core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java\n+++ b/core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java\n\n@@ -19,6 +19,7 @@\n import org.infinispan.commons.dataconversion.MediaType;\n import org.infinispan.commons.dataconversion.OneToManyTranscoder;\n import org.infinispan.commons.dataconversion.StandardConversions;\n+import org.infinispan.commons.marshall.MarshallingException;\n import org.infinispan.commons.marshall.WrappedByteArray;\n import org.infinispan.commons.util.Util;\n import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1NTA0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401455049", "bodyText": "It would nice to keep these inline as @Inject @ComponentName to be consistent with other classes.", "author": "ryanemerson", "createdAt": "2020-04-01T08:51:11Z", "path": "core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java", "diffHunk": "@@ -29,26 +32,35 @@\n @DefaultFactoryFor(classes = {EncoderRegistry.class})\n public class EncoderRegistryFactory extends AbstractComponentFactory implements AutoInstantiableFactory {\n    // Must not start the global marshaller or it will be too late for modules to register their externalizers\n-   @Inject @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)\n+   @Inject\n+   @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1b4b413869c7311ed37698c92bea52da19475315", "chunk": "diff --git a/core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java b/core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java\nindex d2d796c87a..38da4b3b09 100644\n--- a/core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java\n+++ b/core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java\n\n@@ -32,23 +32,19 @@\n @DefaultFactoryFor(classes = {EncoderRegistry.class})\n public class EncoderRegistryFactory extends AbstractComponentFactory implements AutoInstantiableFactory {\n    // Must not start the global marshaller or it will be too late for modules to register their externalizers\n-   @Inject\n-   @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)\n+   @Inject @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)\n    ComponentRef<StreamingMarshaller> globalMarshaller;\n-   @Inject\n-   @ComponentName(KnownComponentNames.PERSISTENCE_MARSHALLER)\n+   @Inject @ComponentName(KnownComponentNames.PERSISTENCE_MARSHALLER)\n    PersistenceMarshaller persistenceMarshaller;\n-   @Inject\n-   EmbeddedCacheManager embeddedCacheManager;\n-\n-   @Inject\n-   SerializationContextRegistry ctxRegistry;\n+   @Inject EmbeddedCacheManager embeddedCacheManager;\n+   @Inject SerializationContextRegistry ctxRegistry;\n \n    @Override\n    public Object construct(String componentName) {\n       ClassLoader classLoader = globalConfiguration.classLoader();\n       EncoderRegistryImpl encoderRegistry = new EncoderRegistryImpl();\n       ClassWhiteList classWhiteList = embeddedCacheManager.getClassWhiteList();\n+      // TODO Move registration to GlobalMarshaller ISPN-9622\n       String messageName = PersistenceContextInitializer.getFqTypeName(MarshallableUserObject.class);\n       ctxRegistry.addMarshaller(SerializationContextRegistry.MarshallerType.GLOBAL, new MarshallableUserObject.Marshaller(messageName, persistenceMarshaller.getUserMarshaller()));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2MDQ5NA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401460494", "bodyText": "This registration ultimately has been moved to the Refactored GlobalMarshaller on my branch ... can you add a comment so I don't forget to remove it here:\n// TODO Move registration to GlobalMarshaller ISPN-9622", "author": "ryanemerson", "createdAt": "2020-04-01T08:59:59Z", "path": "core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java", "diffHunk": "@@ -29,26 +32,35 @@\n @DefaultFactoryFor(classes = {EncoderRegistry.class})\n public class EncoderRegistryFactory extends AbstractComponentFactory implements AutoInstantiableFactory {\n    // Must not start the global marshaller or it will be too late for modules to register their externalizers\n-   @Inject @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)\n+   @Inject\n+   @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)\n    ComponentRef<StreamingMarshaller> globalMarshaller;\n-   @Inject @ComponentName(KnownComponentNames.PERSISTENCE_MARSHALLER)\n+   @Inject\n+   @ComponentName(KnownComponentNames.PERSISTENCE_MARSHALLER)\n    PersistenceMarshaller persistenceMarshaller;\n-   @Inject EmbeddedCacheManager embeddedCacheManager;\n+   @Inject\n+   EmbeddedCacheManager embeddedCacheManager;\n+\n+   @Inject\n+   SerializationContextRegistry ctxRegistry;\n \n    @Override\n    public Object construct(String componentName) {\n+      ClassLoader classLoader = globalConfiguration.classLoader();\n       EncoderRegistryImpl encoderRegistry = new EncoderRegistryImpl();\n       ClassWhiteList classWhiteList = embeddedCacheManager.getClassWhiteList();\n+      String messageName = PersistenceContextInitializer.getFqTypeName(MarshallableUserObject.class);\n+      ctxRegistry.addMarshaller(SerializationContextRegistry.MarshallerType.GLOBAL, new MarshallableUserObject.Marshaller(messageName, persistenceMarshaller.getUserMarshaller()));", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1b4b413869c7311ed37698c92bea52da19475315", "chunk": "diff --git a/core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java b/core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java\nindex d2d796c87a..38da4b3b09 100644\n--- a/core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java\n+++ b/core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java\n\n@@ -32,23 +32,19 @@\n @DefaultFactoryFor(classes = {EncoderRegistry.class})\n public class EncoderRegistryFactory extends AbstractComponentFactory implements AutoInstantiableFactory {\n    // Must not start the global marshaller or it will be too late for modules to register their externalizers\n-   @Inject\n-   @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)\n+   @Inject @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)\n    ComponentRef<StreamingMarshaller> globalMarshaller;\n-   @Inject\n-   @ComponentName(KnownComponentNames.PERSISTENCE_MARSHALLER)\n+   @Inject @ComponentName(KnownComponentNames.PERSISTENCE_MARSHALLER)\n    PersistenceMarshaller persistenceMarshaller;\n-   @Inject\n-   EmbeddedCacheManager embeddedCacheManager;\n-\n-   @Inject\n-   SerializationContextRegistry ctxRegistry;\n+   @Inject EmbeddedCacheManager embeddedCacheManager;\n+   @Inject SerializationContextRegistry ctxRegistry;\n \n    @Override\n    public Object construct(String componentName) {\n       ClassLoader classLoader = globalConfiguration.classLoader();\n       EncoderRegistryImpl encoderRegistry = new EncoderRegistryImpl();\n       ClassWhiteList classWhiteList = embeddedCacheManager.getClassWhiteList();\n+      // TODO Move registration to GlobalMarshaller ISPN-9622\n       String messageName = PersistenceContextInitializer.getFqTypeName(MarshallableUserObject.class);\n       ctxRegistry.addMarshaller(SerializationContextRegistry.MarshallerType.GLOBAL, new MarshallableUserObject.Marshaller(messageName, persistenceMarshaller.getUserMarshaller()));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2Mzk5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401463993", "bodyText": "I think you can re-use CountMarshallingPojo here and just configure the org.infinispan.test.TestDataSCI", "author": "ryanemerson", "createdAt": "2020-04-01T09:05:57Z", "path": "core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java", "diffHunk": "@@ -67,12 +70,68 @@ public void testEvictPrimitiveKeyCustomValue() {\n             expectedReads++; // unmarshall old value if overwritten\n          expectedWrites++; // just the value\n       }\n-      assertEquals(expectedWrites, EvictionPojo.Externalizer.writes.get());\n-      assertEquals(expectedReads, EvictionPojo.Externalizer.reads.get());\n+      assertEquals(expectedWrites, EvictionPojoMarshaller.writes.get());\n+      assertEquals(expectedReads, EvictionPojoMarshaller.reads.get());\n+   }\n+\n+   static class EvictionPojoMarshaller implements org.infinispan.protostream.MessageMarshaller<EvictionPojo> {", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1b4b413869c7311ed37698c92bea52da19475315", "chunk": "diff --git a/core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java b/core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java\nindex ae7d43f004..6329afd510 100644\n--- a/core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java\n+++ b/core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java\n\n@@ -54,100 +45,23 @@ public void testEvictCustomKeyValue() {\n \n       assertEquals(CACHE_SIZE, cache.getAdvancedCache().getDataContainer().size());\n \n-      assertEquals(expectedWrites, EvictionPojoMarshaller.writes.get());\n-      assertEquals(expectedReads, EvictionPojoMarshaller.reads.get());\n+      assertEquals(expectedWrites, CountMarshallingPojo.getMarshallCount());\n+      assertEquals(expectedReads, CountMarshallingPojo.getUnmarshallCount());\n    }\n \n    public void testEvictPrimitiveKeyCustomValue() {\n-      EvictionPojoMarshaller.resetStats();\n+      CountMarshallingPojo.reset();\n       int expectedWrites = 0;\n       int expectedReads = 0;\n       for (int i = 0; i < CACHE_SIZE * 2; i++) {\n-         EvictionPojo p1 = new EvictionPojo();\n-         p1.i = (int) Util.random(2000);\n+         CountMarshallingPojo p1 = new CountMarshallingPojo((int) Util.random(2000));\n          Object old = cache.put(i, p1);\n          if (old != null)\n             expectedReads++; // unmarshall old value if overwritten\n          expectedWrites++; // just the value\n       }\n-      assertEquals(expectedWrites, EvictionPojoMarshaller.writes.get());\n-      assertEquals(expectedReads, EvictionPojoMarshaller.reads.get());\n+      assertEquals(expectedWrites, CountMarshallingPojo.getMarshallCount());\n+      assertEquals(expectedReads, CountMarshallingPojo.getUnmarshallCount());\n    }\n \n-   static class EvictionPojoMarshaller implements org.infinispan.protostream.MessageMarshaller<EvictionPojo> {\n-      static AtomicInteger writes = new AtomicInteger();\n-      static AtomicInteger reads = new AtomicInteger();\n-\n-      public static void resetStats() {\n-         reads.set(0);\n-         writes.set(0);\n-      }\n-\n-      @Override\n-      public EvictionPojo readFrom(ProtoStreamReader reader) throws IOException {\n-         EvictionPojo o = new EvictionPojo();\n-         o.i = reader.readInt(\"i\");\n-         reads.incrementAndGet();\n-         return o;\n-      }\n-\n-      @Override\n-      public void writeTo(ProtoStreamWriter writer, EvictionPojo evictionPojo) throws IOException {\n-         writer.writeInt(\"i\", evictionPojo.i);\n-         writes.incrementAndGet();\n-      }\n-\n-      @Override\n-      public Class<? extends EvictionPojo> getJavaClass() {\n-         return EvictionPojo.class;\n-      }\n-\n-      @Override\n-      public String getTypeName() {\n-         return \"EvictionPojo\";\n-      }\n-   }\n-\n-   static class ContextInitializer implements SerializationContextInitializer {\n-      @Override\n-      public String getProtoFileName() {\n-         return EvictionPojo.class.getName();\n-      }\n-\n-      @Override\n-      public String getProtoFile() throws UncheckedIOException {\n-         return \"message EvictionPojo {optional int32 i=1;}\";\n-      }\n-\n-      @Override\n-      public void registerSchema(SerializationContext serCtx) {\n-         serCtx.registerProtoFiles(fromString(getProtoFileName(), getProtoFile()));\n-      }\n-\n-      @Override\n-      public void registerMarshallers(SerializationContext serCtx) {\n-         serCtx.registerMarshaller(new EvictionPojoMarshaller());\n-      }\n-   }\n-\n-   public static class EvictionPojo {\n-      @ProtoField(number = 1, defaultValue = \"0\")\n-      int i;\n-\n-      @Override\n-      public boolean equals(Object o) {\n-         if (this == o) return true;\n-         if (o == null || getClass() != o.getClass()) return false;\n-         EvictionPojo pojo = (EvictionPojo) o;\n-         return i == pojo.i;\n-      }\n-\n-      @Override\n-      public int hashCode() {\n-         int result;\n-         result = i;\n-         return result;\n-      }\n-\n-   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzAwNA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401467004", "bodyText": "This made me think of ProtoStream support and then I saw that you created https://issues.redhat.com/browse/IPROTO-134 \ud83d\ude42", "author": "ryanemerson", "createdAt": "2020-04-01T09:11:00Z", "path": "core/src/test/java/org/infinispan/eviction/impl/protostream/PrimitiveArrayCtx.java", "diffHunk": "@@ -0,0 +1,222 @@\n+package org.infinispan.eviction.impl.protostream;\n+\n+import static org.infinispan.protostream.FileDescriptorSource.fromString;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.protostream.MessageMarshaller;\n+import org.infinispan.protostream.SerializationContext;\n+import org.infinispan.protostream.SerializationContextInitializer;\n+\n+/**\n+ * Adds support for primitive and primitive wrapper arrays.\n+ */\n+public class PrimitiveArrayCtx implements SerializationContextInitializer {", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1ODcxOA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402258718", "bodyText": "Yes, I added this as a workaround in the tests only, to force Protostream to support it  \ud83d\ude04", "author": "gustavonalle", "createdAt": "2020-04-02T12:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MzA1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402863055", "bodyText": "Couldn't we just change the test so it doesn't use primitive arrays? :)\nMost cache operations won't work with primitive array keys, because the equals() implementation is wrong, and many cache operations also require equals() to work for values, so I would rather prohibit primitive array keys and values instead of adding special support in protostream.", "author": "danberindei", "createdAt": "2020-04-03T09:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5MjMzMg==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402892332", "bodyText": "Woudn't those primitive arrays marshalled form be wrapped in WrappedByteArray, so the equal and hashcode work?", "author": "gustavonalle", "createdAt": "2020-04-03T09:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MzAwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404543005", "bodyText": "Yes, but that would mean primitive arrays would work or would not work depending on the cache encoding, and I would rather they work or not work the same way in any configuration.", "author": "danberindei", "createdAt": "2020-04-07T05:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYyMjAyMA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404622020", "bodyText": "Right, I see your point. But this was a very old test and I was just making it pass by offering an alternative that works on protostream. Protostream as a marshaller should support it IMO since every other marshaller in the world does :)\nOn the Infinispan side, we could document the limitation or even throw an exception if someone tries to store those arrays? In either case, I wouldn't want the change to be hidden inside this PR instead of a separate JIRA to get more visibility, as this is a breaking change", "author": "gustavonalle", "createdAt": "2020-04-07T08:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NDMwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r405144309", "bodyText": "I agree, I over-reacted a bit to the IPROTO-134 comment because I don't want to add a new feature just to keep an old test working.\nPersonally I'd like to throw an exception, but we can also explore non-byte array wrappers.", "author": "danberindei", "createdAt": "2020-04-07T22:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzAwNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzkxNg==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401467916", "bodyText": "Why do we now get an IllegalArgumentException? I must have missed this change.", "author": "ryanemerson", "createdAt": "2020-04-01T09:12:31Z", "path": "core/src/test/java/org/infinispan/marshall/MarshalledValueSingleNodeTest.java", "diffHunk": "@@ -20,12 +19,12 @@ protected EmbeddedCacheManager createCacheManager() throws Exception {\n       return cm;\n    }\n \n-   @Test(expectedExceptions = MarshallingException.class)\n+   @Test(expectedExceptions = IllegalArgumentException.class)", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4ODMzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402288335", "bodyText": "Because protostream throws it when it can't marshall something. Before this PR, the GlobalMarshaller used to throw MarshallingException for this case", "author": "gustavonalle", "createdAt": "2020-04-02T12:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMwMDc3MA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402300770", "bodyText": "Maybe we should wrap this inside ProtoStreamTranscoder#marshall with a MarshallingException and a message. Something like \"Transcoder failed to marshall class %s\".", "author": "ryanemerson", "createdAt": "2020-04-02T13:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzkxNg=="}], "type": "inlineReview", "revised_code": {"commit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "chunk": "diff --git a/core/src/test/java/org/infinispan/marshall/MarshalledValueSingleNodeTest.java b/core/src/test/java/org/infinispan/marshall/MarshalledValueSingleNodeTest.java\nindex 7ae0cbac10..35f0beeb40 100644\n--- a/core/src/test/java/org/infinispan/marshall/MarshalledValueSingleNodeTest.java\n+++ b/core/src/test/java/org/infinispan/marshall/MarshalledValueSingleNodeTest.java\n\n@@ -19,12 +20,12 @@ protected EmbeddedCacheManager createCacheManager() throws Exception {\n       return cm;\n    }\n \n-   @Test(expectedExceptions = IllegalArgumentException.class)\n+   @Test(expectedExceptions = MarshallingException.class)\n    public void testNonMarshallableValue() {\n       cache.put(\"Hello\", new Object());\n    }\n \n-   @Test(expectedExceptions = IllegalArgumentException.class)\n+   @Test(expectedExceptions = MarshallingException.class)\n    public void testNonMarshallableKey() {\n       cache.put(new Object(), \"Hello\");\n    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2ODg2Ng==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401468866", "bodyText": "Why add the extra variable?", "author": "ryanemerson", "createdAt": "2020-04-01T09:14:08Z", "path": "core/src/test/java/org/infinispan/marshall/core/StoreAsBinaryTest.java", "diffHunk": "@@ -412,7 +411,8 @@ public void testEntrySetValueFromEntryCollections() {\n       m.put(key3, value3);\n       cache(0, \"replSync\").putAll(m);\n \n-      Set<Map.Entry<Object, Object>> entries = cache(0, \"replSync\").entrySet();\n+      Cache<Object, Object> replSync = cache(0, \"replSync\");", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NjQwOA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404546408", "bodyText": "I liked the extra variable, there's a lot of repetition in this test :)", "author": "danberindei", "createdAt": "2020-04-07T05:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2ODg2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "1b4b413869c7311ed37698c92bea52da19475315", "chunk": "diff --git a/core/src/test/java/org/infinispan/marshall/core/StoreAsBinaryTest.java b/core/src/test/java/org/infinispan/marshall/core/StoreAsBinaryTest.java\nindex 78ab4d6976..eff6773a9d 100644\n--- a/core/src/test/java/org/infinispan/marshall/core/StoreAsBinaryTest.java\n+++ b/core/src/test/java/org/infinispan/marshall/core/StoreAsBinaryTest.java\n\n@@ -411,8 +411,7 @@ public void testEntrySetValueFromEntryCollections() {\n       m.put(key3, value3);\n       cache(0, \"replSync\").putAll(m);\n \n-      Cache<Object, Object> replSync = cache(0, \"replSync\");\n-      Set<Map.Entry<Object, Object>> entries = replSync.entrySet();\n+      Set<Map.Entry<Object, Object>> entries = cache(0, \"replSync\").entrySet();\n       String newString = \"new-value\";\n \n       for (Map.Entry<Object, Object> entry : entries) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3NTc3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401475775", "bodyText": "Nitpick, could you split the array over multiple lines like in the other @AutoProtoSchemaBuilder", "author": "ryanemerson", "createdAt": "2020-04-01T09:25:16Z", "path": "multimap/src/test/java/org/infinispan/multimap/impl/MultimapSCI.java", "diffHunk": "@@ -3,10 +3,11 @@\n import org.infinispan.protostream.SerializationContextInitializer;\n import org.infinispan.protostream.annotations.AutoProtoSchemaBuilder;\n import org.infinispan.test.TestDataSCI;\n+import org.infinispan.test.data.Person;\n \n @AutoProtoSchemaBuilder(\n       dependsOn = TestDataSCI.class,\n-      includeClasses = SuperPerson.class,\n+      includeClasses = {Person.class, SuperPerson.class},", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1b4b413869c7311ed37698c92bea52da19475315", "chunk": "diff --git a/multimap/src/test/java/org/infinispan/multimap/impl/MultimapSCI.java b/multimap/src/test/java/org/infinispan/multimap/impl/MultimapSCI.java\nindex d2c076040d..b69c4837f6 100644\n--- a/multimap/src/test/java/org/infinispan/multimap/impl/MultimapSCI.java\n+++ b/multimap/src/test/java/org/infinispan/multimap/impl/MultimapSCI.java\n\n@@ -7,7 +7,10 @@\n \n @AutoProtoSchemaBuilder(\n       dependsOn = TestDataSCI.class,\n-      includeClasses = {Person.class, SuperPerson.class},\n+      includeClasses = {\n+            Person.class,\n+            SuperPerson.class\n+      },\n       schemaFileName = \"test.multimap.proto\",\n       schemaFilePath = \"proto/generated\",\n       schemaPackageName = \"org.infinispan.test.multimap\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3NjgyMA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401476820", "bodyText": "Is this for this PR?", "author": "ryanemerson", "createdAt": "2020-04-01T09:26:48Z", "path": "query/src/main/java/org/infinispan/query/impl/massindex/IndexWorker.java", "diffHunk": "@@ -67,42 +61,38 @@\n \n    @Override\n    public Void apply(EmbeddedCacheManager embeddedCacheManager) {\n-      Cache<Object, Object> cache = embeddedCacheManager.getCache(cacheName).getAdvancedCache().withStorageMediaType();\n-      AdvancedCache<Object, Object> unwrapped = SecurityActions.getUnwrappedCache(cache).getAdvancedCache();\n-      StorageType storageType = unwrapped.getCacheConfiguration().memory().storageType();\n-      if (storageType == StorageType.OBJECT) {\n-         cache = unwrapped.withWrapping(ByteArrayWrapper.class, IdentityWrapper.class);\n-      } else {\n-         cache = cache;  //todo [anistor] why not `unwrapped` instead ? do we need security for mass indexing ?\n-      }\n+      AdvancedCache<Object, Object> cache = SecurityActions.getUnwrappedCache(embeddedCacheManager.getCache(cacheName)).getAdvancedCache();\n+      DataConversion valueDataConversion = cache.getValueDataConversion();\n+      Wrapper valueWrapper = valueDataConversion.getWrapper();\n+      boolean valueFilterable = valueWrapper.isFilterable();\n \n-      SearchIntegrator searchIntegrator = ComponentRegistryUtils.getSearchIntegrator(unwrapped);\n-      KeyTransformationHandler keyTransformationHandler = ComponentRegistryUtils.getKeyTransformationHandler(unwrapped);\n-      TimeService timeService = ComponentRegistryUtils.getTimeService(unwrapped);\n+      AdvancedCache<Object, Object> reindexCache = valueFilterable ? cache.withStorageMediaType() : cache;\n+\n+      SearchIntegrator searchIntegrator = ComponentRegistryUtils.getSearchIntegrator(cache);\n+      KeyTransformationHandler keyTransformationHandler = ComponentRegistryUtils.getKeyTransformationHandler(cache);\n+      TimeService timeService = ComponentRegistryUtils.getTimeService(cache);\n \n       IndexUpdater indexUpdater = new IndexUpdater(searchIntegrator, keyTransformationHandler, timeService);\n-      ClusteringDependentLogic clusteringDependentLogic = SecurityActions.getClusteringDependentLogic(unwrapped);\n+      ClusteringDependentLogic clusteringDependentLogic = SecurityActions.getClusteringDependentLogic(cache);\n       KeyPartitioner keyPartitioner = ComponentRegistryUtils.getKeyPartitioner(cache);\n \n-      DataConversion keyDataConversion = unwrapped.getKeyDataConversion();\n-      DataConversion valueDataConversion = unwrapped.getValueDataConversion();\n-\n       if (keys == null || keys.size() == 0) {\n          preIndex(indexUpdater);\n          if (!skipIndex) {\n-            KeyValueFilter filter = getFilter(clusteringDependentLogic, keyDataConversion);\n-            try (Stream<CacheEntry<Object, Object>> stream = cache.getAdvancedCache().withFlags(Flag.CACHE_MODE_LOCAL)\n+            KeyValueFilter filter = getFilter(clusteringDependentLogic, reindexCache.getKeyDataConversion());\n+            try (Stream<CacheEntry<Object, Object>> stream = reindexCache.getAdvancedCache().withFlags(Flag.CACHE_MODE_LOCAL)\n                   .cacheEntrySet().stream()) {\n                Iterator<CacheEntry<Object, Object>> iterator = stream.filter(CacheFilters.predicate(filter)).iterator();\n-               Wrapper wrapper = unwrapped.getValueDataConversion().getWrapper();\n                while (iterator.hasNext()) {\n                   CacheEntry<Object, Object> next = iterator.next();\n-                  Object value = extractValue(next.getValue(), valueDataConversion);\n-                  Object storedKey = keyDataConversion.toStorage(next.getKey());\n-                  int segment = keyPartitioner.getSegment(storedKey);\n-                  if (value instanceof byte[] && storageType != OBJECT) {\n-                     value = wrapper.wrap(value);\n+                  Object key = next.getKey();\n+                  Object storedKey = reindexCache.getKeyDataConversion().toStorage(key);\n+                  Object value = next.getValue();\n+                  // TODO: Way to grab a cache without unwrapping? cache.withStoreMediaType(boolean unwrap)", "originalCommit": "5781343b1f04b53900c78da8caba1bf452374b86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2MDAyOA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402260028", "bodyText": "let me check if this is still needed", "author": "gustavonalle", "createdAt": "2020-04-02T12:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3NjgyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMzNTA3NA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402335074", "bodyText": "For now, I will just remove this TODO and handle it in the next PR", "author": "gustavonalle", "createdAt": "2020-04-02T13:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3NjgyMA=="}], "type": "inlineReview", "revised_code": {"commit": "1b4b413869c7311ed37698c92bea52da19475315", "chunk": "diff --git a/query/src/main/java/org/infinispan/query/impl/massindex/IndexWorker.java b/query/src/main/java/org/infinispan/query/impl/massindex/IndexWorker.java\nindex 15febcd884..aa71b7e923 100644\n--- a/query/src/main/java/org/infinispan/query/impl/massindex/IndexWorker.java\n+++ b/query/src/main/java/org/infinispan/query/impl/massindex/IndexWorker.java\n\n@@ -88,7 +88,6 @@ public Void apply(EmbeddedCacheManager embeddedCacheManager) {\n                   Object key = next.getKey();\n                   Object storedKey = reindexCache.getKeyDataConversion().toStorage(key);\n                   Object value = next.getValue();\n-                  // TODO: Way to grab a cache without unwrapping? cache.withStoreMediaType(boolean unwrap)\n                   if (valueFilterable) {\n                      value = valueWrapper.wrap(value);\n                   }\n"}}, {"oid": "1b4b413869c7311ed37698c92bea52da19475315", "url": "https://github.com/infinispan/infinispan/commit/1b4b413869c7311ed37698c92bea52da19475315", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-02T13:11:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMwNDY2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402304662", "bodyText": "We should move this and ProtoStreamTextTranscoderTest.java to core as well.", "author": "ryanemerson", "createdAt": "2020-04-02T13:17:52Z", "path": "server/core/src/test/java/org/infinispan/server/core/dataconversion/ProtostreamJsonTranscoderTest.java", "diffHunk": "@@ -6,6 +6,7 @@\n import java.nio.charset.StandardCharsets;\n \n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.encoding.ProtostreamTranscoder;", "originalCommit": "1b4b413869c7311ed37698c92bea52da19475315", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "chunk": "diff --git a/server/core/src/test/java/org/infinispan/server/core/dataconversion/ProtostreamJsonTranscoderTest.java b/core/src/test/java/org/infinispan/dataconversion/ProtostreamJsonTranscoderTest.java\nsimilarity index 98%\nrename from server/core/src/test/java/org/infinispan/server/core/dataconversion/ProtostreamJsonTranscoderTest.java\nrename to core/src/test/java/org/infinispan/dataconversion/ProtostreamJsonTranscoderTest.java\nindex 28b57d45d9..ff49948213 100644\n--- a/server/core/src/test/java/org/infinispan/server/core/dataconversion/ProtostreamJsonTranscoderTest.java\n+++ b/core/src/test/java/org/infinispan/dataconversion/ProtostreamJsonTranscoderTest.java\n\n@@ -1,4 +1,4 @@\n-package org.infinispan.server.core.dataconversion;\n+package org.infinispan.dataconversion;\n \n import static org.testng.Assert.assertEquals;\n import static org.testng.Assert.assertTrue;\n"}}, {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "url": "https://github.com/infinispan/infinispan/commit/12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-02T14:17:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402804769", "bodyText": "Is this is needed at all? All the constructors already have a storageMediaType parameter.", "author": "danberindei", "createdAt": "2020-04-03T07:58:56Z", "path": "core/src/main/java/org/infinispan/encoding/DataConversion.java", "diffHunk": "@@ -166,28 +173,17 @@ public void injectDependencies(@ComponentName(KnownComponentNames.CACHE_NAME) St\n       }\n       boolean internalCache = icr.isInternalCache(cacheName);\n       boolean embeddedMode = Configurations.isEmbeddedMode(gcr);\n-      this.storageMediaType = getStorageMediaType(configuration, embeddedMode, internalCache);\n+      this.storageMediaType = getStorageMediaType(configuration, embeddedMode, internalCache, persistenceMarshaller);", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwNjM0OA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402906348", "bodyText": "This was added to avoid requiring caches to configure a storage media type, and to assume sensible defaults. We can discuss if this config should be mandatory or not, but this is out of scope for this PR", "author": "gustavonalle", "createdAt": "2020-04-03T10:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0ODg3Nw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404548877", "bodyText": "IIUC injectDependencies() is only called on the remote nodes, not on the origin node. But storageMediaType is not transient, so the value coming from the origin node should be good enough. Or if injectDependencies() is also called on the origin node, then we don't need to initialize it in the constructor.\nOr were you thinking about a cache that is configured with one storage media type on node A and another storage media type on node B? I'm pretty sure that would break lots of other things, because we don't transcode values in non-functional commands.\nI'm fine with splitting it in a separate JIRA btw, since you're just adding a parameter here, but I would like to clarify it at some point.", "author": "danberindei", "createdAt": "2020-04-07T05:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc3MzAyMg==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404773022", "bodyText": "Here's where the DataConversion is injected: \n  \n    \n      infinispan/core/src/main/java/org/infinispan/cache/impl/EncoderCache.java\n    \n    \n        Lines 122 to 125\n      in\n      db04d4a\n    \n    \n    \n    \n\n        \n          \n           public void wireRealCache() { \n        \n\n        \n          \n              componentRegistry.wireDependencies(keyDataConversion, false); \n        \n\n        \n          \n              componentRegistry.wireDependencies(valueDataConversion, false); \n        \n\n        \n          \n              componentRegistry.wireDependencies(cache, false);", "author": "gustavonalle", "createdAt": "2020-04-07T12:35:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NTY3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r405145679", "bodyText": "I was wrong, injectDependencies() is called, it just skips most of the initialization, including that of storageMediaType (see line 167).\nReading that code again, the initialization is skipped only for the DataConversion.DEFAULT_* static instances, so you are right, the storageMediaType is recomputed.\nSpeaking of the static instances, however, the line this.encoderRegistry = encoderRegistry; should be moved below the if so that they stay constant.", "author": "danberindei", "createdAt": "2020-04-07T22:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM4NzAwMg==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r405387002", "bodyText": "One more thing: since we only wire the dependency into DataConversion instances, but we never register them in the component registry, I suggest changing @Scope(NAMED_CACHE) to @Scope(NONE).", "author": "danberindei", "createdAt": "2020-04-08T09:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzMzkxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r405433911", "bodyText": "Moving the this.encoderRegistry = encoderRegistry below the if breaks a bunch of stuff, since the registry can be used in convertToRequestFormat()", "author": "gustavonalle", "createdAt": "2020-04-08T10:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzOTIyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r406039229", "bodyText": "@gustavonalle the if should only apply to the static instances like DataConversion.DEFAULT_KEY. The encoder registry is a component, so 2 nodes running in the same JVM will overwrite each other's encoderRegistry reference, which I don't think is correct.", "author": "danberindei", "createdAt": "2020-04-09T08:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0NzM4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r406047385", "bodyText": "AFAICT, the same encoder registry instance is inject in all data conversions of all caches, it's a cache manager level component. If you have 2 nodes in the same JVM, I suppose each node will have a different one, but they won't mix?\nok, I understood what you meant, let me see if I can change it...", "author": "gustavonalle", "createdAt": "2020-04-09T08:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3ODMxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r406078319", "bodyText": "Actually, I won't do this for this PR, as it's unrelated.\nhttps://issues.redhat.com/browse/ISPN-11620", "author": "gustavonalle", "createdAt": "2020-04-09T09:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY1ODI5OA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r406658298", "bodyText": "Excellent, I was actually testing my changes locally and came to the same conclusion: a DataConversion instance should only convert between the storage type and the request type, the transcoder lookup should be elsewhere.", "author": "danberindei", "createdAt": "2020-04-10T08:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402807711", "bodyText": "IMO if the cache has a user marshaller and the storage type is not OBJECT, then the cache should already be initialized with the user marshaller's media type as the storage type, we shouldn't do this check only when the DataConversion is shipped to another node and has its dependencies injected.", "author": "danberindei", "createdAt": "2020-04-03T08:02:25Z", "path": "core/src/main/java/org/infinispan/encoding/DataConversion.java", "diffHunk": "@@ -120,9 +120,12 @@ public void overrideWrapper(Class<? extends Wrapper> newWrapper, ComponentRegist\n    /**\n     * Obtain the configured {@link MediaType} for this instance, or assume sensible defaults.\n     */\n-   private MediaType getStorageMediaType(Configuration configuration, boolean embeddedMode, boolean internalCache) {\n+   private MediaType getStorageMediaType(Configuration configuration, boolean embeddedMode, boolean internalCache, PersistenceMarshaller persistenceMarshaller) {\n       EncodingConfiguration encodingConfiguration = configuration.encoding();\n       ContentTypeConfiguration contentTypeConfiguration = isKey ? encodingConfiguration.keyDataType() : encodingConfiguration.valueDataType();\n+      Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+      MediaType mediaType = userMarshaller.mediaType();", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwOTE2OA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402909168", "bodyText": "Could you clarify? The DataConversion is initialized when the cache is initialized, it's a component. Also the information about storage type, request type, transcoder, etc is part of the DataConversion", "author": "gustavonalle", "createdAt": "2020-04-03T10:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU1MjUwOA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404552508", "bodyText": "I meant the user marshaller and the storage type must be in sync. I don't see any point in allowing a cache to be configured with both\n<value media-type=\"application/x-protostream\"/>\nand\n<serialization marshaller=\"org.infinispan.jboss.marshalling.core.JBossUserMarshaller\"/>\n\nit's a component.\n\nExactly. There is a DataConversion component, but most of the injectDependencies() logic is skipped for that instance because the same class is trying to be 2 things at the same time.", "author": "danberindei", "createdAt": "2020-04-07T05:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNDMzNg==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404604336", "bodyText": "The pair <value media-type=\"application/x-protostream\"/> and <serialization marshaller=\"org.infinispan.jboss.marshalling.core.JBossUserMarshaller\"/> is possible. The later is cache-manager scoped, the former cache scope config.\nIt means the cache will store protobuf and a transcoder that is able to convert between application/x-jboss-marshaller <=> application/x-java-object is registered. This transcoder can be used whenever another cache needs that conversion", "author": "gustavonalle", "createdAt": "2020-04-07T07:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYyNTcyOA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404625728", "bodyText": "Good point, I was thinking of the user marshaller as a purely \"to/from storage\" thing, but it's obvious now that it could also be a \"to/from request\" thing.\nHowever, PersistenceManagerImpl.createUserMarshaller() ignores the cache's storage media type, so storageMediaType will always be set to the user marshaller's media type.\nAnd it also made me realize that the <value media-type=\"X\"/> configuration serves a dual purpose. It was even more complicated before, but with your changes IIUC\n\nWith <binary/>, the storage type is X, and the default request type is application/x-java-object.\nWith <object/>, the storage type is application/x-java-object, and the default request type is X.", "author": "danberindei", "createdAt": "2020-04-07T08:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYyNTgyNw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404625827", "bodyText": "Going back to your initial point, injectDependencies() should be always called when the cache is created, otherwise I fear for the transcoding stuff \ud83d\ude04\nAn alternative to what was done here, that aligns with your suggestion, is to move this logic to configuration time, more precisely, if a cache is heap (OBJECT) and don't have a MediaType configured, let's set the key/value mediatype to the \"user marshaller\". I will try doing that.", "author": "gustavonalle", "createdAt": "2020-04-07T08:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYzNTczNw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404635737", "bodyText": "<value media-type=\"X\"/>\n\nThis has a single purpose, define the format of the values in the cache. This is configuration and cannot be changed at runtime. If not specified, a best guess will be made, e.g., indexed server caches will be protobuf otherwise there's no way of having query to work.\nThe request type will be app/x-java-object by default, and it's changeable at runtime, that's how the server deals with multiple request formats in REST, for example.\nI will rather say what is planned for the BINARY/OFF_HEAP/OBJECT trio after the last PR which is https://issues.redhat.com/browse/ISPN-11424:\n\nBINARY and OBJECT disappears\nOFF_HEAP is a flag on/off to specify if data will be stored in heap or not\nif off_heap=true for a cache, then we check the media type: it it's not byte[] based format, we throw an exception.\n\nSo we're left only with the mediatype and a flag heap/off-heap", "author": "gustavonalle", "createdAt": "2020-04-07T08:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgxMzYxNw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404813617", "bodyText": "@danberindei WRT:\n\nIMO if the cache has a user marshaller and the storage type is not OBJECT, then the cache should already be initialized with the user marshaller's media type as the storage type\n\nI was not able to set the MediaType of the cache at configuration time, since the user marshaller is initialized at runtime and doesn't necessary follow the <serialization> configuration.\nWRT:\n\nBut please have another look at the user marshaller and whether its media type can override the cache's media type with the current code\n\nWhen the DataConversion is initialized, it gives priority to the configured MediaType:\nhttps://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/encoding/DataConversion.java#L126-L128", "author": "gustavonalle", "createdAt": "2020-04-07T13:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI3NTA0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r405275046", "bodyText": "<value media-type=\"X\"/> [...] has a single purpose, define the format of the values in the cache.\n\nSorry you had to spell that out again, I read \"user marshaller can be used both ways\" and I jumped to \"content type configuration can also be used both ways\". I guess I couldn't accept that the encoding configuration would be simply ignored for caches with OBJECT storage :)\n\nWhen the DataConversion is initialized, it gives priority to the configured MediaType:\n\nI missed that too!\n\nI was not able to set the MediaType of the cache at configuration time\n\nIf you mean during ConfigurationBuilder.build() then I agree, we can't query the user marshaller at that time.\nMy thinking was that the storage type could be computed in InternalCacheFactory.buildEncodingCache(), so it doesn't have to be recomputed every time the DataConversion instance is sent to another node.", "author": "danberindei", "createdAt": "2020-04-08T05:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM5NjA2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r405396067", "bodyText": "Let me try that", "author": "gustavonalle", "createdAt": "2020-04-08T09:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1NDM0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r405454346", "bodyText": "It didn't work: during InternalCacheFactory.buildEncodingCache() the persistence marshaller is null in the registry", "author": "gustavonalle", "createdAt": "2020-04-08T11:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyMDczOQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r406120739", "bodyText": "Yeah, the component registry is not yet bootstrapped there. But the persistence marshaller is a global component, so it doesn't need the cache component registry.\nHere's how I would like it to work: c864043\nLet me know if you want to include my suggestions here, otherwise I can integrate your PR as is and open a separate PR.", "author": "danberindei", "createdAt": "2020-04-09T10:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyMjI2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r406122267", "bodyText": "Cool, let's separate from this PR please", "author": "gustavonalle", "createdAt": "2020-04-09T10:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMTAzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402811035", "bodyText": "Missing whitespace", "author": "danberindei", "createdAt": "2020-04-03T08:06:17Z", "path": "core/src/main/java/org/infinispan/encoding/DataConversion.java", "diffHunk": "@@ -131,8 +134,11 @@ private MediaType getStorageMediaType(Configuration configuration, boolean embed\n       if (!embeddedMode && configuration.indexing().enabled() && contentTypeConfiguration.mediaType() == null) {\n          return MediaType.APPLICATION_PROTOSTREAM;\n       }\n+      if(internalCache) return MediaType.APPLICATION_OBJECT;", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "chunk": "diff --git a/core/src/main/java/org/infinispan/encoding/DataConversion.java b/core/src/main/java/org/infinispan/encoding/DataConversion.java\nindex f224c47717..98ac6979d7 100644\n--- a/core/src/main/java/org/infinispan/encoding/DataConversion.java\n+++ b/core/src/main/java/org/infinispan/encoding/DataConversion.java\n\n@@ -134,7 +134,7 @@ private MediaType getStorageMediaType(Configuration configuration, boolean embed\n       if (!embeddedMode && configuration.indexing().enabled() && contentTypeConfiguration.mediaType() == null) {\n          return MediaType.APPLICATION_PROTOSTREAM;\n       }\n-      if(internalCache) return MediaType.APPLICATION_OBJECT;\n+      if (internalCache) return MediaType.APPLICATION_OBJECT;\n \n       if (embeddedMode) {\n          return heap ? MediaType.APPLICATION_OBJECT : mediaType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMzgwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402813809", "bodyText": "There seems to be a disconnect between marshall and unmarshall... marshall decides whether to wrap the byte array (whatever that means) based on the wrapped parameter, while unmarshall decides whether the byte array is wrapped or not based on the type parameter. At the very least this deserves a comment to explain the difference. /cc @ryanemerson", "author": "danberindei", "createdAt": "2020-04-03T08:09:22Z", "path": "core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java", "diffHunk": "@@ -113,19 +114,27 @@ public Object transcode(Object content, MediaType contentType, MediaType destina\n    }\n \n    private byte[] marshall(Object decoded, MediaType destinationType) throws IOException {\n-      Optional<String> wrappedParam = destinationType.getParameter(\"wrapped\");\n-      if (!wrappedParam.isPresent() || !wrappedParam.get().equals(\"false\"))\n-         return ProtobufUtil.toWrappedByteArray(ctx(), decoded);\n-      return ProtobufUtil.toByteArray(ctx(), decoded);\n+      try {\n+         Optional<String> wrappedParam = destinationType.getParameter(\"wrapped\");\n+         if (!wrappedParam.isPresent() || !wrappedParam.get().equals(\"false\"))\n+            return ProtobufUtil.toWrappedByteArray(ctx(), decoded);\n+         return ProtobufUtil.toByteArray(ctx(), decoded);\n+      } catch (IllegalArgumentException iae) {\n+         throw new MarshallingException(iae.getMessage());\n+      }\n    }\n \n    private Object unmarshall(byte[] bytes, MediaType destinationType) throws IOException {\n-      String type = destinationType.getClassType();\n-      if (type == null) {\n-         return ProtobufUtil.fromWrappedByteArray(ctx(), bytes);\n+      try {\n+         String type = destinationType.getClassType();\n+         if (type == null) {", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxMjc1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402912752", "bodyText": "When producing protobuf from Something, it's possible to serialize to the protobuf wire format directly or to serialize using a message wrapper containing the protobuf payload, aka  org.infinispan.protostream.WrappedMessage\nThis is used in RemoteQuery, that needs to serialize to those two formats (user payload and query structure itself)\nAFAICT, when umarshalling, it will automatically work \ud83d\ude04\nI will add some test/doc to this", "author": "gustavonalle", "createdAt": "2020-04-03T10:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMzgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU1MzUyNA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404553524", "bodyText": "\ud83d\udc4d\nI don't doubt this feature is needed, I just wanted an explanation of how the wrapped and type parameters work together.", "author": "danberindei", "createdAt": "2020-04-07T05:59:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMzgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMDQxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404610411", "bodyText": "Hope it makes sense now?  ;)", "author": "gustavonalle", "createdAt": "2020-04-07T07:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMzgwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "chunk": "diff --git a/core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java b/core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java\nindex 3dc7058f8b..d589acd037 100644\n--- a/core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java\n+++ b/core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java\n\n@@ -113,22 +121,27 @@ public Object transcode(Object content, MediaType contentType, MediaType destina\n       }\n    }\n \n+   private boolean isWrapped(MediaType mediaType) {\n+      Optional<String> wrappedParam = mediaType.getParameter(\"wrapped\");\n+      return (!wrappedParam.isPresent() || !wrappedParam.get().equals(\"false\"));\n+   }\n+\n    private byte[] marshall(Object decoded, MediaType destinationType) throws IOException {\n       try {\n-         Optional<String> wrappedParam = destinationType.getParameter(\"wrapped\");\n-         if (!wrappedParam.isPresent() || !wrappedParam.get().equals(\"false\"))\n-            return ProtobufUtil.toWrappedByteArray(ctx(), decoded);\n+         if (isWrapped(destinationType)) return ProtobufUtil.toWrappedByteArray(ctx(), decoded);\n          return ProtobufUtil.toByteArray(ctx(), decoded);\n       } catch (IllegalArgumentException iae) {\n          throw new MarshallingException(iae.getMessage());\n       }\n    }\n \n-   private Object unmarshall(byte[] bytes, MediaType destinationType) throws IOException {\n+   private Object unmarshall(byte[] bytes, MediaType contentType, MediaType destinationType) throws IOException {\n       try {\n          String type = destinationType.getClassType();\n+         boolean wrapped = isWrapped(contentType);\n          if (type == null) {\n-            return ProtobufUtil.fromWrappedByteArray(ctx(), bytes);\n+            if(wrapped) return ProtobufUtil.fromWrappedByteArray(ctx(), bytes);\n+            throw logger.missingTypeForUnwrappedPayload();\n          }\n          Class<?> destination = Util.loadClass(type, classLoader);\n          return ProtobufUtil.fromByteArray(ctx(), bytes, destination);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNjY4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402816681", "bodyText": "What storage type does the cache injected in components have, if not the storage media type?", "author": "danberindei", "createdAt": "2020-04-03T08:12:38Z", "path": "core/src/main/java/org/infinispan/interceptors/distribution/DistributionBulkInterceptor.java", "diffHunk": "@@ -70,7 +70,7 @@ public Object visitEntrySetCommand(InvocationContext ctx, EntrySetCommand comman\n       protected final FlagAffectedCommand command;\n \n       private BackingEntrySet(Cache cache, CacheSet<CacheEntry<K, V>> entrySet, FlagAffectedCommand command) {\n-         super(cache);\n+         super(cache.getAdvancedCache().withStorageMediaType());", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5ODU2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402898565", "bodyText": ".withStorageMediaType() changes the request media type, not the storage media type; this call is simply giving to the interceptor a cache instance that will not try to convert from whatever is stored", "author": "gustavonalle", "createdAt": "2020-04-03T10:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNjY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU1NDU5NA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404554594", "bodyText": "Sorry, I bungled my question.\nI meant why wouldn't the cache injected in components already have the request media type == the storage media type, so that it doesn't do any conversion? The media type of the EncoderCache wrapper is going to be passed as a parameter anyway.", "author": "danberindei", "createdAt": "2020-04-07T06:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNjY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMjM2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404612365", "bodyText": "By default, all caches have a request type of application/x-java-object. This was added in the previous issue https://issues.redhat.com/browse/ISPN-11446\nSome components (query, interceptors, etc) need to operate on the data as stored, that's why this decoration was creted", "author": "gustavonalle", "createdAt": "2020-04-07T08:00:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNjY4MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0NTkyOA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402845928", "bodyText": "A method would be clearer IMO", "author": "danberindei", "createdAt": "2020-04-03T08:46:28Z", "path": "core/src/test/java/org/infinispan/dataconversion/DataConversionTest.java", "diffHunk": "@@ -65,11 +66,12 @@ public void testReadUnencoded() {\n       withCacheManager(new CacheManagerCallable(\n             createCacheManager(TestDataSCI.INSTANCE, cfg)) {\n          @Override\n-         public void call() throws IOException, InterruptedException {\n+         public void call() {\n             cm.getClassWhiteList().addClasses(Person.class);\n             Cache<String, Person> cache = cm.getCache();\n \n-            Marshaller marshaller = cache.getAdvancedCache().getComponentRegistry().getInternalMarshaller();\n+            DataConversion conversion = cache.getAdvancedCache().getValueDataConversion();\n+            Function<Object, byte[]> asStored = s -> (byte[]) conversion.convert(s, APPLICATION_OBJECT, APPLICATION_PROTOSTREAM);", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "chunk": "diff --git a/core/src/test/java/org/infinispan/dataconversion/DataConversionTest.java b/core/src/test/java/org/infinispan/dataconversion/DataConversionTest.java\nindex b48d14eada..54bc28c9b8 100644\n--- a/core/src/test/java/org/infinispan/dataconversion/DataConversionTest.java\n+++ b/core/src/test/java/org/infinispan/dataconversion/DataConversionTest.java\n\n@@ -65,14 +64,18 @@ public void testReadUnencoded() {\n \n       withCacheManager(new CacheManagerCallable(\n             createCacheManager(TestDataSCI.INSTANCE, cfg)) {\n+\n+         private final DataConversion conversion = cm.getCache().getAdvancedCache().getValueDataConversion();\n+\n+         public Object asStored(Object object) {\n+            return conversion.convert(object, APPLICATION_OBJECT, APPLICATION_PROTOSTREAM);\n+         }\n+\n          @Override\n          public void call() {\n             cm.getClassWhiteList().addClasses(Person.class);\n             Cache<String, Person> cache = cm.getCache();\n \n-            DataConversion conversion = cache.getAdvancedCache().getValueDataConversion();\n-            Function<Object, byte[]> asStored = s -> (byte[]) conversion.convert(s, APPLICATION_OBJECT, APPLICATION_PROTOSTREAM);\n-\n             Person value = new Person();\n             cache.put(\"1\", value);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MDgyMA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402850820", "bodyText": "\"16 more\" suddenly doesn't seem that important :)\nIMO we should remove these comments, I'd rather replace the constants in the code (e.g. line 217) with calculations to explain how we got the 144 or 104 bytes of overhead, or maybe a link to another place where the overhead is explained.", "author": "danberindei", "createdAt": "2020-04-03T08:51:58Z", "path": "core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java", "diffHunk": "@@ -142,7 +142,7 @@ protected void createCacheManagers() throws Throwable {\n             memoryConfigurationBuilder.size(SIZE);\n             break;\n          case BINARY:\n-            // 64 bytes per entry, however tests that add metadata require 16 more even\n+            // 144 bytes per entry, however tests that add metadata require 16 more even", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA4NjM1NA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r403086354", "bodyText": "I am not sure about the magic numbers from OFF_HEAP, but I will document the ones from BINARY", "author": "gustavonalle", "createdAt": "2020-04-03T15:28:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MDgyMA=="}], "type": "inlineReview", "revised_code": {"commit": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "chunk": "diff --git a/core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java b/core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java\nindex e52711f6f7..e7818dc783 100644\n--- a/core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java\n+++ b/core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java\n\n@@ -142,8 +147,7 @@ protected void createCacheManagers() throws Throwable {\n             memoryConfigurationBuilder.size(SIZE);\n             break;\n          case BINARY:\n-            // 144 bytes per entry, however tests that add metadata require 16 more even\n-            memoryConfigurationBuilder.evictionType(EvictionType.MEMORY).size(convertAmountForStorage(SIZE) + 16);\n+            memoryConfigurationBuilder.evictionType(EvictionType.MEMORY).size(convertAmountForStorage(SIZE) + MORTAL_ENTRY_OVERHEAD);\n             break;\n          case OFF_HEAP:\n             // Each entry takes up 63 bytes total for our tests, however tests that add expiration require 16 more\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MTE3Mg==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402851172", "bodyText": "putIfAbsent isn't functional, as the method name implies.", "author": "danberindei", "createdAt": "2020-04-03T08:52:19Z", "path": "core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java", "diffHunk": "@@ -261,11 +261,11 @@ public void testExceptionOnInsert() {\n \n    public void testExceptionOnInsertFunctional() {\n       for (int i = 0; i < SIZE; ++i) {\n-         cache(0).computeIfAbsent(i, k -> SIZE);\n+         cache(0).putIfAbsent(i * 4096, SIZE * 4096);", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5OTQ1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402899453", "bodyText": "This change seems wrong \ud83d\ude04, looks like  bad copy and paste", "author": "gustavonalle", "createdAt": "2020-04-03T10:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MTE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwNTY1OA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r403005658", "bodyText": "No, in fact intellij suggested it and I applied...", "author": "gustavonalle", "createdAt": "2020-04-03T13:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MTE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU1OTYwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404559605", "bodyText": "Good guy IntelliJ!\nHowever, since you mentioned ComputeCommand is not really a functional command, maybe the test name was never correct :))", "author": "danberindei", "createdAt": "2020-04-07T06:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MTE3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "chunk": "diff --git a/core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java b/core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java\nindex e52711f6f7..e7818dc783 100644\n--- a/core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java\n+++ b/core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java\n\n@@ -261,11 +266,11 @@ public void testExceptionOnInsert() {\n \n    public void testExceptionOnInsertFunctional() {\n       for (int i = 0; i < SIZE; ++i) {\n-         cache(0).putIfAbsent(i * 4096, SIZE * 4096);\n+         cache(0).computeIfAbsent(i, k -> SIZE);\n       }\n \n       try {\n-         cache(0).putIfAbsent(-1, SIZE);\n+         cache(0).computeIfAbsent(-1, k -> SIZE);\n          fail(\"Should have thrown an exception!\");\n       } catch (Throwable t) {\n          Exceptions.assertException(ContainerFullException.class, getMostNestedSuppressedThrowable(t));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MzY3OA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402853678", "bodyText": "Why keep the random number?\nBut the bigger problem is that CountMarshallingPojo uses static fields for the marshall count, and it breaks when 2 of the many tests that use it run in parallel. Either it should have a custom raw marshaller, with a different marshaller instance in each test, or it should have a test name field and it should maintain a map of marshall counts per test.", "author": "danberindei", "createdAt": "2020-04-03T08:55:04Z", "path": "core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java", "diffHunk": "@@ -22,97 +18,50 @@\n \n    private static final int CACHE_SIZE = 128;\n \n-\n    @Override\n    protected EmbeddedCacheManager createCacheManager() throws Exception {\n       ConfigurationBuilder cfg = new ConfigurationBuilder();\n       cfg.memory().size(CACHE_SIZE).evictionType(EvictionType.COUNT).storageType(StorageType.BINARY)\n             .expiration().wakeUpInterval(100L)\n             .locking().useLockStriping(false) // to minimise chances of deadlock in the unit test\n             .build();\n-      cacheManager = TestCacheManagerFactory.createCacheManager(cfg);\n+      cacheManager = TestCacheManagerFactory.createCacheManager(TestDataSCI.INSTANCE, cfg);\n       cache = cacheManager.getCache();\n       return cacheManager;\n    }\n \n    public void testEvictCustomKeyValue() {\n-      EvictionPojo.Externalizer.resetStats();\n+      CountMarshallingPojo.reset();\n       int expectedWrites = 0;\n       int expectedReads = 0;\n       for (int i = 0; i < CACHE_SIZE * 2; i++) {\n-         EvictionPojo p1 = new EvictionPojo();\n-         p1.i = (int) Util.random(2000);\n-         EvictionPojo p2 = new EvictionPojo();\n-         p2.i = 24;\n+         CountMarshallingPojo p1 = new CountMarshallingPojo((int) Util.random(2000));", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMDA3OA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402900078", "bodyText": "I did not write this test, I was just migrating it to protostream, but I can change it no problem", "author": "gustavonalle", "createdAt": "2020-04-03T10:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MzY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA5MTA5NQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r403091095", "bodyText": "In fact @ryanemerson suggested the CountMarshallingPojo, I had my own private one, I will just go back to that then", "author": "gustavonalle", "createdAt": "2020-04-03T15:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MzY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU2MDQ0NA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404560444", "bodyText": "I would have rather you fixed CountMarshallingPojo, because it's already used in multiple tests anyway, but know what you mean :)", "author": "danberindei", "createdAt": "2020-04-07T06:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MzY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NjE0MA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404656140", "bodyText": "I've created https://issues.redhat.com/browse/ISPN-11604 so that the issue isn't forgotten.", "author": "ryanemerson", "createdAt": "2020-04-07T09:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MzY3OA=="}], "type": "inlineReview", "revised_code": {"commit": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "chunk": "diff --git a/core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java b/core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java\nindex 6329afd510..61d94ae1e6 100644\n--- a/core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java\n+++ b/core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java\n\n@@ -25,18 +31,20 @@ protected EmbeddedCacheManager createCacheManager() throws Exception {\n             .expiration().wakeUpInterval(100L)\n             .locking().useLockStriping(false) // to minimise chances of deadlock in the unit test\n             .build();\n-      cacheManager = TestCacheManagerFactory.createCacheManager(TestDataSCI.INSTANCE, cfg);\n+      cacheManager = TestCacheManagerFactory.createCacheManager(new ContextInitializer(), cfg);\n       cache = cacheManager.getCache();\n       return cacheManager;\n    }\n \n    public void testEvictCustomKeyValue() {\n-      CountMarshallingPojo.reset();\n+      EvictionPojoMarshaller.resetStats();\n       int expectedWrites = 0;\n       int expectedReads = 0;\n       for (int i = 0; i < CACHE_SIZE * 2; i++) {\n-         CountMarshallingPojo p1 = new CountMarshallingPojo((int) Util.random(2000));\n-         CountMarshallingPojo p2 = new CountMarshallingPojo(24);\n+         EvictionPojo p1 = new EvictionPojo();\n+         p1.i = (int) Util.random(2000);\n+         EvictionPojo p2 = new EvictionPojo();\n+         p2.i = 24;\n          Object old = cache.put(p1, p2);\n          if (old != null)\n             expectedReads++; // unmarshall old value if overwritten\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2NTIzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402865239", "bodyText": "A static method would be clearer IMO, it's always applied directly.", "author": "danberindei", "createdAt": "2020-04-03T09:08:22Z", "path": "core/src/test/java/org/infinispan/persistence/LocalModePassivationTest.java", "diffHunk": "@@ -68,6 +73,13 @@ protected EmbeddedCacheManager createCacheManager() throws Exception {\n       return TestCacheManagerFactory.createCacheManager(builder);\n    }\n \n+   private static BiFunction<Cache<?, ?>, Object, WrappedByteArray> TO_DATA_CONTAINER =", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "chunk": "diff --git a/core/src/test/java/org/infinispan/persistence/LocalModePassivationTest.java b/core/src/test/java/org/infinispan/persistence/LocalModePassivationTest.java\nindex cf81915a5e..9d4d0a1392 100644\n--- a/core/src/test/java/org/infinispan/persistence/LocalModePassivationTest.java\n+++ b/core/src/test/java/org/infinispan/persistence/LocalModePassivationTest.java\n\n@@ -73,13 +70,6 @@ protected EmbeddedCacheManager createCacheManager() throws Exception {\n       return TestCacheManagerFactory.createCacheManager(builder);\n    }\n \n-   private static BiFunction<Cache<?, ?>, Object, WrappedByteArray> TO_DATA_CONTAINER =\n-         (cache, object) -> (WrappedByteArray) cache.getAdvancedCache().getValueDataConversion().toStorage(object);\n-\n-   private static BiFunction<Cache<?, ?>, WrappedByteArray, Object> FROM_DATA_CONTAINER =\n-         (cache, wrapped) ->  cache.getAdvancedCache().getValueDataConversion().fromStorage(wrapped);\n-\n-\n    public void testStoreAndLoad() throws Exception {\n       final int numKeys = 300;\n       for (int i = 0; i < numKeys; i++) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2OTM1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402869352", "bodyText": "Please reformat only changed lines!\nI've seen quite a few whitespace changes on unmodified lines like this, but this jumped to me because I have Chained method calls / Align when multiline enabled in IntelliJ, and if you have it disabled, formatting the entire file changes the indent of all my lines.", "author": "danberindei", "createdAt": "2020-04-03T09:14:13Z", "path": "jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java", "diffHunk": "@@ -220,8 +228,8 @@ public V get(final K key) {\n       // ReadWriteMap.evalMany is not that useful since it forces us to transfer keys\n       List<? extends SimpleEntry<? extends K, CompletableFuture<R>>> list =\n             keys.stream()\n-                .map(k -> new SimpleEntry<>(k, map.eval(k, function)))\n-                .collect(Collectors.toList());\n+                  .map(k -> new SimpleEntry<>(k, map.eval(k, function)))\n+                  .collect(Collectors.toList());", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMTgwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402901809", "bodyText": "Maybe you could check the Intellij style and update it? https://issues.redhat.com/browse/ISPN-11588", "author": "gustavonalle", "createdAt": "2020-04-03T10:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2OTM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU2MTM0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404561349", "bodyText": "One day :)", "author": "danberindei", "createdAt": "2020-04-07T06:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2OTM1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "chunk": "diff --git a/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java b/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java\nindex 586af2e5c0..28f9822f12 100644\n--- a/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java\n+++ b/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java\n\n@@ -228,8 +228,8 @@ public V get(final K key) {\n       // ReadWriteMap.evalMany is not that useful since it forces us to transfer keys\n       List<? extends SimpleEntry<? extends K, CompletableFuture<R>>> list =\n             keys.stream()\n-                  .map(k -> new SimpleEntry<>(k, map.eval(k, function)))\n-                  .collect(Collectors.toList());\n+                .map(k -> new SimpleEntry<>(k, map.eval(k, function)))\n+                .collect(Collectors.toList());\n \n       // Wait for all the eval operations to finish before checking for exceptions\n       AggregateCompletionStage<Void> stage = CompletionStages.aggregateCompletionStage();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MDU5Nw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402870597", "bodyText": "-1", "author": "danberindei", "createdAt": "2020-04-03T09:16:28Z", "path": "jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java", "diffHunk": "@@ -534,11 +543,12 @@ public void removeAll(Set<? extends K> keys) {\n             // does not block the commit of other, already persisted entries\n             AggregateCompletionStage<Void> stage = CompletionStages.aggregateCompletionStage();\n             keys.stream()\n-                .map(k -> rwMapSkipCacheLoad.eval(k, Remove.getInstance()))\n-                .forEach(stage::dependsOn);\n+                  .map(k -> rwMapSkipCacheLoad.eval(k, Remove.getInstance()))\n+                  .forEach(stage::dependsOn);\n             CompletionStages.join(stage.freeze());\n          } else {\n-            rwMapSkipCacheLoad.evalMany(keys, Remove.getInstance()).forEach(b -> {});\n+            rwMapSkipCacheLoad.evalMany(keys, Remove.getInstance()).forEach(b -> {\n+            });", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMTkzNA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402901934", "bodyText": "Maybe you could check the Intellij style and update it? https://issues.redhat.com/browse/ISPN-11588", "author": "gustavonalle", "createdAt": "2020-04-03T10:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MDU5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "chunk": "diff --git a/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java b/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java\nindex 586af2e5c0..28f9822f12 100644\n--- a/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java\n+++ b/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java\n\n@@ -543,12 +542,11 @@ public void removeAll(Set<? extends K> keys) {\n             // does not block the commit of other, already persisted entries\n             AggregateCompletionStage<Void> stage = CompletionStages.aggregateCompletionStage();\n             keys.stream()\n-                  .map(k -> rwMapSkipCacheLoad.eval(k, Remove.getInstance()))\n-                  .forEach(stage::dependsOn);\n+                .map(k -> rwMapSkipCacheLoad.eval(k, Remove.getInstance()))\n+                .forEach(stage::dependsOn);\n             CompletionStages.join(stage.freeze());\n          } else {\n-            rwMapSkipCacheLoad.evalMany(keys, Remove.getInstance()).forEach(b -> {\n-            });\n+            rwMapSkipCacheLoad.evalMany(keys, Remove.getInstance()).forEach(b -> {});\n          }\n       } catch (CompletionException e) {\n          throw Exceptions.launderException(e);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3NjI4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402876286", "bodyText": "Is this really necessary? I thought JCache doesn't allow the user to override the data conversion.\nAlso the field/parameter names should include Conversion, key and value is a bit confusing.", "author": "danberindei", "createdAt": "2020-04-03T09:26:27Z", "path": "jcache/embedded/src/main/java/org/infinispan/jcache/embedded/functions/Invoke.java", "diffHunk": "@@ -28,13 +29,17 @@\n    private final EntryProcessor<K, V, R> processor;\n    private final Object[] arguments;\n    private final boolean storeByReference;\n+   private final DataConversion key;\n+   private final DataConversion value;\n    private PersistenceMarshaller marshaller;\n    private ExpiryPolicy expiryPolicy;\n \n-   public Invoke(EntryProcessor<K, V, R> processor, Object[] arguments, boolean storeByReference) {\n+   public Invoke(EntryProcessor<K, V, R> processor, Object[] arguments, boolean storeByReference, DataConversion key, DataConversion value) {", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNDMyNw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402914327", "bodyText": "hmm, I could try to grab from the cache directly during entry processing, let me try", "author": "gustavonalle", "createdAt": "2020-04-03T10:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3NjI4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjEzMA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r403436130", "bodyText": "Indeed, this is not needed \ud83d\udc4d", "author": "gustavonalle", "createdAt": "2020-04-04T07:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3NjI4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5528d136c3e035fce9395fe4d787a0e3c4492cbb", "chunk": "diff --git a/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/functions/Invoke.java b/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/functions/Invoke.java\nindex eb6b9051db..e53879d296 100644\n--- a/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/functions/Invoke.java\n+++ b/jcache/embedded/src/main/java/org/infinispan/jcache/embedded/functions/Invoke.java\n\n@@ -23,28 +24,24 @@\n import org.infinispan.jcache.Expiration;\n import org.infinispan.jcache.embedded.Durations;\n import org.infinispan.jcache.embedded.ExternalizerIds;\n-import org.infinispan.marshall.persistence.PersistenceMarshaller;\n \n public class Invoke<K, V, R> implements Function<EntryView.ReadWriteEntryView<K, V>, R>, InjectableComponent {\n    private final EntryProcessor<K, V, R> processor;\n    private final Object[] arguments;\n    private final boolean storeByReference;\n-   private final DataConversion key;\n-   private final DataConversion value;\n-   private PersistenceMarshaller marshaller;\n    private ExpiryPolicy expiryPolicy;\n+   private DataConversion valueDataConversion;\n \n-   public Invoke(EntryProcessor<K, V, R> processor, Object[] arguments, boolean storeByReference, DataConversion key, DataConversion value) {\n+   public Invoke(EntryProcessor<K, V, R> processor, Object[] arguments, boolean storeByReference) {\n       this.processor = processor;\n       this.arguments = arguments;\n       this.storeByReference = storeByReference;\n-      this.key = key;\n-      this.value = value;\n    }\n \n    @Override\n    public void inject(ComponentRegistry registry) {\n-      this.marshaller = registry.getPersistenceMarshaller();\n+      AdvancedCache<?, ?> advancedCache = registry.getCache().wired().getAdvancedCache();\n+      this.valueDataConversion = advancedCache.getValueDataConversion();\n       this.expiryPolicy = registry.getComponent(ExpiryPolicy.class);\n    }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3ODM0NA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402878344", "bodyText": "What's the expected media type for a Lucene cache? Couldn't you test for that instead of !APPLICATION_UNKNOWN?", "author": "danberindei", "createdAt": "2020-04-03T09:29:59Z", "path": "lucene/lucene-directory/src/main/java/org/infinispan/lucene/directory/DirectoryBuilder.java", "diffHunk": "@@ -42,8 +43,12 @@ public static BuildContext newDirectoryInstance(Cache<?, ?> metadataCache, Cache\n     * Search\n     */\n    private static Cache<?, ?> decorateCache(Cache<?, ?> cache) {\n-      if (cache == null) return null;\n-      return cache.getAdvancedCache().withStorageMediaType();\n+      if(cache == null) return null;\n+      if(cache.getAdvancedCache().getValueDataConversion().getStorageMediaType().equals(MediaType.APPLICATION_UNKNOWN)) {", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5Njg0MA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402896840", "bodyText": "The user can create/configure Lucene caches, so there is no way of knowing.\nIn any case, Lucene caches are being removed on #8137.", "author": "gustavonalle", "createdAt": "2020-04-03T10:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3ODM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU2NTIzMA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404565230", "bodyText": "I meant e.g. org.infinispan.query.impl.LifecycleManager#getDefaultLuceneCacheConfig uses MediaType.APPLICATION_OBJECT_TYPE, shouldn't you say that the cache is custom if the media type is != APPLICATION_OBJECT_TYPE?\nIn practice the result may be the same, but the comment isn't very clear to me.", "author": "danberindei", "createdAt": "2020-04-07T06:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3ODM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MjUyMg==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404852522", "bodyText": "if I disable transcoding when mediaType != APPLICATION_OBJECT_TYPE it will break Lucene caches that are configured with OFF_HEAP/BINARY.\nBut Lucene caches are literally hours ahead of being removed from master, so I will not try changing this :)", "author": "gustavonalle", "createdAt": "2020-04-07T14:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3ODM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI3MzQ4NA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r405273484", "bodyText": "Ok :)", "author": "danberindei", "createdAt": "2020-04-08T05:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3ODM0NA=="}], "type": "inlineReview", "revised_code": {"commit": "bdf6d3b0b0d7bac76261bdec531f6423b53e864c", "chunk": "diff --git a/lucene/lucene-directory/src/main/java/org/infinispan/lucene/directory/DirectoryBuilder.java b/lucene/lucene-directory/src/main/java/org/infinispan/lucene/directory/DirectoryBuilder.java\ndeleted file mode 100644\nindex e584fb3370..0000000000\n--- a/lucene/lucene-directory/src/main/java/org/infinispan/lucene/directory/DirectoryBuilder.java\n+++ /dev/null\n\n@@ -1,64 +0,0 @@\n-package org.infinispan.lucene.directory;\n-\n-import java.util.Arrays;\n-import java.util.Objects;\n-\n-import org.infinispan.Cache;\n-import org.infinispan.commons.dataconversion.MediaType;\n-import org.infinispan.configuration.cache.CacheMode;\n-import org.infinispan.configuration.cache.ClusteringConfiguration;\n-import org.infinispan.lucene.impl.DirectoryBuilderImpl;\n-import org.infinispan.lucene.logging.Log;\n-import org.infinispan.util.logging.LogFactory;\n-\n-/**\n- * Builder class to create instances of the {@link org.apache.lucene.store.Directory} implementation which stored data\n- * in the data grid.\n- */\n-public final class DirectoryBuilder {\n-\n-   private static final Log log = LogFactory.getLog(DirectoryBuilder.class, Log.class);\n-\n-\n-   private DirectoryBuilder() {\n-      //not to be created\n-   }\n-\n-   /**\n-    * Starting point to create a Directory instance.\n-    *\n-    * @param metadataCache  contains the metadata of stored elements\n-    * @param chunksCache    cache containing the bulk of the index; this is the larger part of data\n-    * @param distLocksCache cache to store locks; should be replicated and not using a persistent CacheStore\n-    * @param indexName      identifies the index; you can store different indexes in the same set of caches using\n-    *                       different identifiers\n-    */\n-   public static BuildContext newDirectoryInstance(Cache<?, ?> metadataCache, Cache<?, ?> chunksCache, Cache<?, ?> distLocksCache, String indexName) {\n-      validateIndexCaches(indexName, metadataCache, chunksCache, distLocksCache);\n-      return new DirectoryBuilderImpl(decorateCache(metadataCache), decorateCache(chunksCache), decorateCache(distLocksCache), indexName);\n-   }\n-\n-   /**\n-    * Make sure no transcoding is done for the internal lucene caches, since the default config is defined by Hibernate\n-    * Search\n-    */\n-   private static Cache<?, ?> decorateCache(Cache<?, ?> cache) {\n-      if(cache == null) return null;\n-      if(cache.getAdvancedCache().getValueDataConversion().getStorageMediaType().equals(MediaType.APPLICATION_UNKNOWN)) {\n-         // This is a custom defined lucene, disable transcoding\n-         cache = cache.getAdvancedCache().withStorageMediaType();\n-      }\n-      return cache;\n-   }\n-\n-   private static void validateIndexCaches(String indexName, Cache<?, ?>... caches) {\n-      Arrays.stream(caches).filter(Objects::nonNull).forEach(cache -> {\n-         ClusteringConfiguration clusteringConfiguration = cache.getCacheConfiguration().clustering();\n-         CacheMode cacheMode = clusteringConfiguration.cacheMode();\n-         if (cacheMode.isClustered() && !cacheMode.isSynchronous()) {\n-            throw log.cannotStoreIndexOnAsyncCaches(indexName, cache.getName(), cacheMode);\n-         }\n-      });\n-   }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3OTc3MA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402879770", "bodyText": "Missing whitespace (also on line 401)\nAlso, the javadoc of Wrapper.isFilterable() says true if the wrapped format is suitable to be indexed or filtered, thus avoiding extra unwrapping, but here you're doing the unwrapping in the true case. Maybe the javadoc is referring to something else?", "author": "danberindei", "createdAt": "2020-04-03T09:32:39Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -398,15 +394,19 @@ private void performSearchWork(Work work, TransactionContext transactionContext)\n    }\n \n    private Object extractValue(Object storedValue) {\n-      return valueDataConversion.extractIndexable(storedValue);\n+      return this.cache.getValueDataConversion().extractIndexable(storedValue);\n    }\n \n    private Object extractKey(Object storedKey) {\n-      return keyDataConversion.extractIndexable(storedKey);\n+      if(storedKey == null) return null;\n+      DataConversion valueDataConversion = cache.getValueDataConversion();\n+      boolean protoWrapper = valueDataConversion.getWrapper().isFilterable();\n+      if(protoWrapper) return cache.getKeyDataConversion().getWrapper().unwrap(storedKey);", "originalCommit": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ5NzMwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r403497305", "bodyText": "I am not unwrapping the value (that is filterable), but the key in this method. Let me see if I can simplify this, I agree it's convoluted", "author": "gustavonalle", "createdAt": "2020-04-04T17:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3OTc3MA=="}], "type": "inlineReview", "revised_code": {"commit": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "chunk": "diff --git a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\nindex 356b354842..cd622b21cc 100644\n--- a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n+++ b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n\n@@ -398,10 +398,10 @@ private Object extractValue(Object storedValue) {\n    }\n \n    private Object extractKey(Object storedKey) {\n-      if(storedKey == null) return null;\n+      if (storedKey == null) return null;\n       DataConversion valueDataConversion = cache.getValueDataConversion();\n       boolean protoWrapper = valueDataConversion.getWrapper().isFilterable();\n-      if(protoWrapper) return cache.getKeyDataConversion().getWrapper().unwrap(storedKey);\n+      if (protoWrapper) return cache.getKeyDataConversion().getWrapper().unwrap(storedKey);\n       return this.cache.getKeyDataConversion().extractIndexable(storedKey);\n    }\n \n"}}, {"oid": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "url": "https://github.com/infinispan/infinispan/commit/1d12f712af659235ec9ff67c71228eeb15cf6dbc", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-03T19:54:15Z", "type": "forcePushed"}, {"oid": "41a3cf5ff301aacb69ab51896c92c604daac206d", "url": "https://github.com/infinispan/infinispan/commit/41a3cf5ff301aacb69ab51896c92c604daac206d", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-03T21:15:17Z", "type": "forcePushed"}, {"oid": "5528d136c3e035fce9395fe4d787a0e3c4492cbb", "url": "https://github.com/infinispan/infinispan/commit/5528d136c3e035fce9395fe4d787a0e3c4492cbb", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-04T10:13:40Z", "type": "forcePushed"}, {"oid": "ed738330b13776a9fef301d73171c1071523b961", "url": "https://github.com/infinispan/infinispan/commit/ed738330b13776a9fef301d73171c1071523b961", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-04T13:56:27Z", "type": "forcePushed"}, {"oid": "cca724dd7c14f22677656589edc431b818577817", "url": "https://github.com/infinispan/infinispan/commit/cca724dd7c14f22677656589edc431b818577817", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-05T19:39:15Z", "type": "forcePushed"}, {"oid": "a2811525c3f1eb2b39749b5f69fc8ab3a2d5a30f", "url": "https://github.com/infinispan/infinispan/commit/a2811525c3f1eb2b39749b5f69fc8ab3a2d5a30f", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-06T11:45:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTY4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404611689", "bodyText": "Here too, if the cache injected in components has request media type == storage media type, then the conversion isn't necessary.\nEdit: You would still have to convert the value to the request media type, but I would rather make that conversion explicit here instead of converting the key back and forth.", "author": "danberindei", "createdAt": "2020-04-07T07:59:11Z", "path": "query/src/main/java/org/infinispan/query/clustered/commandworkers/CQLazyFetcher.java", "diffHunk": "@@ -31,7 +31,7 @@ Object extractValue(DocumentExtractor extractor, int docIndex) {\n       }\n       if (projection == null) {\n          Object key = extractKey(extractor, docIndex);\n-         return cache.get(key);\n+         return cache.get(fromStorage(key));", "originalCommit": "a2811525c3f1eb2b39749b5f69fc8ab3a2d5a30f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1OTE5OQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404859199", "bodyText": "This cache has the default request type, but the QueryInterceptor now indexes keys in the storage format. I did that change because it was always indexing the key in the request format, which is inefficient, since the QueryInterceptor was already receiving the key in the storage format (and was converting back again).", "author": "gustavonalle", "createdAt": "2020-04-07T14:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI4MTg1NA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r405281854", "bodyText": "I agree 100% that QueryInterceptor should index the key in the storage format.\nMy assertion was that the Cache instance should not have the default request type, in fact it should not be an EncoderCache instance at all.", "author": "danberindei", "createdAt": "2020-04-08T06:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQwMDMxOA==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r405400318", "bodyText": "let me see if I can make a non-encoded cache arrive to this command, can't make any promises  :)", "author": "gustavonalle", "createdAt": "2020-04-08T09:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNzg4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r405507889", "bodyText": "ok, I changed it", "author": "gustavonalle", "createdAt": "2020-04-08T13:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTY4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "15c662a69c03e260563a1ee75c05bb7d0aef245e", "chunk": "diff --git a/query/src/main/java/org/infinispan/query/clustered/commandworkers/CQLazyFetcher.java b/query/src/main/java/org/infinispan/query/clustered/commandworkers/CQLazyFetcher.java\nindex 0e958cdf8b..ef0981cf7a 100644\n--- a/query/src/main/java/org/infinispan/query/clustered/commandworkers/CQLazyFetcher.java\n+++ b/query/src/main/java/org/infinispan/query/clustered/commandworkers/CQLazyFetcher.java\n\n@@ -31,7 +31,7 @@ Object extractValue(DocumentExtractor extractor, int docIndex) {\n       }\n       if (projection == null) {\n          Object key = extractKey(extractor, docIndex);\n-         return cache.get(fromStorage(key));\n+         return cache.get(key);\n       }\n       return projection;\n    }\n"}}, {"oid": "bdf6d3b0b0d7bac76261bdec531f6423b53e864c", "url": "https://github.com/infinispan/infinispan/commit/bdf6d3b0b0d7bac76261bdec531f6423b53e864c", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-08T09:39:05Z", "type": "forcePushed"}, {"oid": "15c662a69c03e260563a1ee75c05bb7d0aef245e", "url": "https://github.com/infinispan/infinispan/commit/15c662a69c03e260563a1ee75c05bb7d0aef245e", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-08T13:03:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0MjI1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r406042255", "bodyText": "Can you make use of one of the POJOs in TestDataSCI, say Key or Person. That way we don't need yet another test class and SerializationContextInitializer implementation.\nWhen I originally made ProtoStream the default I managed to remove a lot of duplicated code from the testsuite by removing internal test classes like these. So it would be great if we could stick to the already provided ones. This is a trivial Pojo, so it should work correctly unlike CountMarshallingPojo \ud83d\ude05", "author": "ryanemerson", "createdAt": "2020-04-09T08:30:38Z", "path": "core/src/test/java/org/infinispan/dataconversion/ProtostreamTranscoderTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.dataconversion;\n+\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OBJECT;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_PROTOSTREAM;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.io.IOException;\n+\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.encoding.ProtostreamTranscoder;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.protostream.ProtobufUtil;\n+import org.infinispan.protostream.SerializationContext;\n+import org.infinispan.protostream.SerializationContextInitializer;\n+import org.infinispan.protostream.annotations.AutoProtoSchemaBuilder;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.test.dataconversion.AbstractTranscoderTest;\n+import org.mockito.Mockito;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+@Test(groups = \"functional\", testName = \"query.remote.impl.ProtostreamTranscoderTest\")\n+public class ProtostreamTranscoderTest extends AbstractTranscoderTest {\n+\n+   protected String dataSrc;\n+   private SerializationContext ctx = createCtx();\n+\n+   static final MediaType UNWRAPPED_PROTOSTREAM = APPLICATION_PROTOSTREAM.withParameter(\"wrapped\", \"false\");\n+   static final MediaType TYPED_OBJECT = APPLICATION_OBJECT.withParameter(\"type\", UserObject.class.getName());\n+\n+\n+   @BeforeClass(alwaysRun = true)\n+   public void setUp() {\n+      dataSrc = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\";\n+      SerializationContextRegistry registry = Mockito.mock(SerializationContextRegistry.class);\n+      Mockito.when(registry.getGlobalCtx()).thenReturn(ctx);\n+      transcoder = new ProtostreamTranscoder(registry, ProtostreamTranscoderTest.class.getClassLoader());\n+      supportedMediaTypes = transcoder.getSupportedMediaTypes();\n+   }\n+\n+   private SerializationContext createCtx() {\n+      SerializationContext ctx = ProtobufUtil.newSerializationContext();\n+      TestContextInitializer.INSTANCE.registerSchema(ctx);\n+      TestContextInitializer.INSTANCE.registerMarshallers(ctx);\n+      return ctx;\n+   }\n+\n+\n+   @Test\n+   @Override\n+   public void testTranscoderTranscode() throws Exception {\n+      Object transcoded = transcoder.transcode(dataSrc, TEXT_PLAIN, APPLICATION_PROTOSTREAM);\n+      assertTrue(transcoded instanceof byte[], \"Must be byte[]\");\n+\n+      Object transcodedBack = transcoder.transcode(transcoded, APPLICATION_PROTOSTREAM, TEXT_PLAIN);\n+\n+      // Must be String as byte[] as sent over the wire by hotrod\n+      assertTrue(transcodedBack instanceof byte[], \"Must be instance of byte[]\");\n+      assertEquals(dataSrc, new String((byte[]) transcodedBack, TEXT_PLAIN.getCharset().name()), \"Must be equal strings\");\n+   }\n+\n+   @Test\n+   public void testWrappedMessage() throws IOException {\n+      UserObject input = new UserObject(\"value\");\n+\n+      // Produces MessageWrapped and unwrapped payloads\n+      byte[] wrapped = (byte[]) transcoder.transcode(input, APPLICATION_OBJECT, APPLICATION_PROTOSTREAM);\n+      byte[] unwrapped = (byte[]) transcoder.transcode(input, APPLICATION_OBJECT, UNWRAPPED_PROTOSTREAM);\n+\n+      assertEquals(input, ProtobufUtil.fromWrappedByteArray(ctx, wrapped));\n+      assertEquals(input, ProtobufUtil.fromByteArray(ctx, unwrapped, UserObject.class));\n+\n+      // Convert from MessageWrapped back to object\n+      Object fromWrapped = transcoder.transcode(wrapped, APPLICATION_PROTOSTREAM, APPLICATION_OBJECT);\n+      assertEquals(input, fromWrapped);\n+\n+      // Convert from unwrapped payload back to object, specifying the object type\n+      Object fromUnWrappedWithType = transcoder.transcode(unwrapped, UNWRAPPED_PROTOSTREAM, TYPED_OBJECT);\n+      assertEquals(input, fromUnWrappedWithType);\n+\n+      // Should throw exception if trying to convert from unwrapped without passing the type\n+      try {\n+         transcoder.transcode(unwrapped, UNWRAPPED_PROTOSTREAM, APPLICATION_OBJECT);\n+         Assert.fail(\"should not convert from unwrapped without type\");\n+      } catch (MarshallingException ignored) {\n+      }\n+   }\n+\n+   @AutoProtoSchemaBuilder(\n+         includeClasses = {UserObject.class},\n+         schemaFileName = \"dataconversion.commons.proto\",\n+         schemaFilePath = \"proto/generated\",\n+         schemaPackageName = \"org.infinispan.dataconversion\")\n+   interface TestContextInitializer extends SerializationContextInitializer {\n+      TestContextInitializer INSTANCE = new TestContextInitializerImpl();\n+   }\n+\n+   static class UserObject {", "originalCommit": "15c662a69c03e260563a1ee75c05bb7d0aef245e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1NzUyMw==", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r406057523", "bodyText": "Done", "author": "gustavonalle", "createdAt": "2020-04-09T08:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0MjI1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2ea06795523bb66e349c84181c6729fe2e537a53", "chunk": "diff --git a/core/src/test/java/org/infinispan/dataconversion/ProtostreamTranscoderTest.java b/core/src/test/java/org/infinispan/dataconversion/ProtostreamTranscoderTest.java\nindex 020aa37774..7adb4542e7 100644\n--- a/core/src/test/java/org/infinispan/dataconversion/ProtostreamTranscoderTest.java\n+++ b/core/src/test/java/org/infinispan/dataconversion/ProtostreamTranscoderTest.java\n\n@@ -15,10 +15,8 @@\n import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n import org.infinispan.protostream.ProtobufUtil;\n import org.infinispan.protostream.SerializationContext;\n-import org.infinispan.protostream.SerializationContextInitializer;\n-import org.infinispan.protostream.annotations.AutoProtoSchemaBuilder;\n-import org.infinispan.protostream.annotations.ProtoFactory;\n-import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.test.TestDataSCI;\n+import org.infinispan.test.data.Person;\n import org.infinispan.test.dataconversion.AbstractTranscoderTest;\n import org.mockito.Mockito;\n import org.testng.Assert;\n"}}, {"oid": "2ea06795523bb66e349c84181c6729fe2e537a53", "url": "https://github.com/infinispan/infinispan/commit/2ea06795523bb66e349c84181c6729fe2e537a53", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-09T08:56:37Z", "type": "commit"}, {"oid": "2ea06795523bb66e349c84181c6729fe2e537a53", "url": "https://github.com/infinispan/infinispan/commit/2ea06795523bb66e349c84181c6729fe2e537a53", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "committedDate": "2020-04-09T08:56:37Z", "type": "forcePushed"}]}