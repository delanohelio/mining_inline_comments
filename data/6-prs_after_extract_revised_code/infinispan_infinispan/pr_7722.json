{"pr_number": 7722, "pr_title": "ISPN-11020 Max Idle Take 2", "pr_createdAt": "2020-01-08T15:11:04Z", "pr_url": "https://github.com/infinispan/infinispan/pull/7722", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMTUyNA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r364331524", "bodyText": "useless blank line", "author": "tristantarrant", "createdAt": "2020-01-08T16:44:45Z", "path": "core/src/main/java/org/infinispan/commands/write/TouchCommand.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package org.infinispan.commands.write;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.infinispan.commands.CommandInvocationId;\n+import org.infinispan.commands.Visitor;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.context.InvocationContext;\n+import org.infinispan.context.impl.FlagBitSets;\n+\n+public class TouchCommand extends AbstractDataWriteCommand {\n+   public static final byte COMMAND_ID = 61;\n+\n+   public TouchCommand() {\n+   }\n+\n+   public TouchCommand(Object key, int segment, long flagsBitSet, CommandInvocationId commandInvocationId) {\n+      super(key, segment, flagsBitSet, commandInvocationId);\n+   }\n+\n+   @Override\n+   public byte getCommandId() {\n+      return COMMAND_ID;\n+   }\n+\n+   @Override\n+   public boolean isSuccessful() {\n+      return true;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      output.writeObject(key);\n+      UnsignedNumeric.writeUnsignedInt(output, segment);\n+      output.writeLong(FlagBitSets.copyWithoutRemotableFlags(getFlagsBitSet()));\n+      CommandInvocationId.writeTo(output, commandInvocationId);\n+   }\n+\n+   @Override\n+   public void readFrom(ObjectInput input) throws IOException, ClassNotFoundException {\n+      key = input.readObject();\n+      segment = UnsignedNumeric.readUnsignedInt(input);\n+      setFlagsBitSet(input.readLong());\n+      commandInvocationId = CommandInvocationId.readFrom(input);\n+   }\n+\n+   @Override\n+   public boolean isConditional() {\n+      return false;\n+   }\n+\n+   @Override\n+   public ValueMatcher getValueMatcher() {\n+      return ValueMatcher.MATCH_NON_NULL;\n+   }\n+\n+   @Override\n+   public void setValueMatcher(ValueMatcher valueMatcher) {\n+", "originalCommit": "1b970affd9a25527dd7e266223aae75c7dc19a49", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b1888638147bead249485fafa1934f42a39bf563", "chunk": "diff --git a/core/src/main/java/org/infinispan/commands/write/TouchCommand.java b/core/src/main/java/org/infinispan/commands/write/TouchCommand.java\nindex 29b16aedf0..997e3aa63e 100644\n--- a/core/src/main/java/org/infinispan/commands/write/TouchCommand.java\n+++ b/core/src/main/java/org/infinispan/commands/write/TouchCommand.java\n\n@@ -57,14 +57,10 @@ public ValueMatcher getValueMatcher() {\n    }\n \n    @Override\n-   public void setValueMatcher(ValueMatcher valueMatcher) {\n-\n-   }\n+   public void setValueMatcher(ValueMatcher valueMatcher) { }\n \n    @Override\n-   public void fail() {\n-\n-   }\n+   public void fail() { }\n \n    @Override\n    public Object acceptVisitor(InvocationContext ctx, Visitor visitor) throws Throwable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMTU5Ng==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r364331596", "bodyText": "useless blank line", "author": "tristantarrant", "createdAt": "2020-01-08T16:44:54Z", "path": "core/src/main/java/org/infinispan/commands/write/TouchCommand.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package org.infinispan.commands.write;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.infinispan.commands.CommandInvocationId;\n+import org.infinispan.commands.Visitor;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.context.InvocationContext;\n+import org.infinispan.context.impl.FlagBitSets;\n+\n+public class TouchCommand extends AbstractDataWriteCommand {\n+   public static final byte COMMAND_ID = 61;\n+\n+   public TouchCommand() {\n+   }\n+\n+   public TouchCommand(Object key, int segment, long flagsBitSet, CommandInvocationId commandInvocationId) {\n+      super(key, segment, flagsBitSet, commandInvocationId);\n+   }\n+\n+   @Override\n+   public byte getCommandId() {\n+      return COMMAND_ID;\n+   }\n+\n+   @Override\n+   public boolean isSuccessful() {\n+      return true;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      output.writeObject(key);\n+      UnsignedNumeric.writeUnsignedInt(output, segment);\n+      output.writeLong(FlagBitSets.copyWithoutRemotableFlags(getFlagsBitSet()));\n+      CommandInvocationId.writeTo(output, commandInvocationId);\n+   }\n+\n+   @Override\n+   public void readFrom(ObjectInput input) throws IOException, ClassNotFoundException {\n+      key = input.readObject();\n+      segment = UnsignedNumeric.readUnsignedInt(input);\n+      setFlagsBitSet(input.readLong());\n+      commandInvocationId = CommandInvocationId.readFrom(input);\n+   }\n+\n+   @Override\n+   public boolean isConditional() {\n+      return false;\n+   }\n+\n+   @Override\n+   public ValueMatcher getValueMatcher() {\n+      return ValueMatcher.MATCH_NON_NULL;\n+   }\n+\n+   @Override\n+   public void setValueMatcher(ValueMatcher valueMatcher) {\n+\n+   }\n+\n+   @Override\n+   public void fail() {\n+", "originalCommit": "1b970affd9a25527dd7e266223aae75c7dc19a49", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b1888638147bead249485fafa1934f42a39bf563", "chunk": "diff --git a/core/src/main/java/org/infinispan/commands/write/TouchCommand.java b/core/src/main/java/org/infinispan/commands/write/TouchCommand.java\nindex 29b16aedf0..997e3aa63e 100644\n--- a/core/src/main/java/org/infinispan/commands/write/TouchCommand.java\n+++ b/core/src/main/java/org/infinispan/commands/write/TouchCommand.java\n\n@@ -57,14 +57,10 @@ public ValueMatcher getValueMatcher() {\n    }\n \n    @Override\n-   public void setValueMatcher(ValueMatcher valueMatcher) {\n-\n-   }\n+   public void setValueMatcher(ValueMatcher valueMatcher) { }\n \n    @Override\n-   public void fail() {\n-\n-   }\n+   public void fail() { }\n \n    @Override\n    public Object acceptVisitor(InvocationContext ctx, Visitor visitor) throws Throwable {\n"}}, {"oid": "b1888638147bead249485fafa1934f42a39bf563", "url": "https://github.com/infinispan/infinispan/commit/b1888638147bead249485fafa1934f42a39bf563", "message": "Scattered cache should now be fixed as well", "committedDate": "2020-01-08T19:32:06Z", "type": "forcePushed"}, {"oid": "34151fbf91e83d4357cd45c08dbf9fb37908c87f", "url": "https://github.com/infinispan/infinispan/commit/34151fbf91e83d4357cd45c08dbf9fb37908c87f", "message": "ISPN-11020 Max Idle Take 2\n\n* Now send a touch command on every read for max idle entries", "committedDate": "2020-01-08T20:43:06Z", "type": "forcePushed"}, {"oid": "e40b3f37121be2447c82453c6c8f7df7e786f7ce", "url": "https://github.com/infinispan/infinispan/commit/e40b3f37121be2447c82453c6c8f7df7e786f7ce", "message": "Adding in failover tests and fixed a couple bugs\n\nHow do we handle pessimistic locking though?", "committedDate": "2020-01-09T05:52:19Z", "type": "forcePushed"}, {"oid": "9009240eff2612279ea4d2f8f91a5bc0749aa7b6", "url": "https://github.com/infinispan/infinispan/commit/9009240eff2612279ea4d2f8f91a5bc0749aa7b6", "message": "different touch approach", "committedDate": "2020-01-10T20:25:16Z", "type": "forcePushed"}, {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf", "url": "https://github.com/infinispan/infinispan/commit/59b1abc3f530e038139b47a0889f3a373d756dbf", "message": "ISPN-11020 Max Idle Take 2\n\n* Now send a touch command on every read for max idle entries", "committedDate": "2020-01-10T21:54:43Z", "type": "commit"}, {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf", "url": "https://github.com/infinispan/infinispan/commit/59b1abc3f530e038139b47a0889f3a373d756dbf", "message": "ISPN-11020 Max Idle Take 2\n\n* Now send a touch command on every read for max idle entries", "committedDate": "2020-01-10T21:54:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyOTQ2MQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365729461", "bodyText": "I'd call it canExpireMaxIdle() to match the existing method canExpire().", "author": "danberindei", "createdAt": "2020-01-13T10:22:59Z", "path": "core/src/main/java/org/infinispan/container/entries/InternalCacheEntry.java", "diffHunk": "@@ -24,6 +24,13 @@\n     */\n    boolean canExpire();\n \n+   /**\n+    * @return true if this entry can expire via max idle, false otherwise\n+    */\n+   default boolean isMaxIdleExpirable() {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMDc3Mw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365830773", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-01-13T14:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyOTQ2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/container/entries/InternalCacheEntry.java b/core/src/main/java/org/infinispan/container/entries/InternalCacheEntry.java\nindex 5d9a13d72a..a11488c76a 100644\n--- a/core/src/main/java/org/infinispan/container/entries/InternalCacheEntry.java\n+++ b/core/src/main/java/org/infinispan/container/entries/InternalCacheEntry.java\n\n@@ -27,7 +27,7 @@\n    /**\n     * @return true if this entry can expire via max idle, false otherwise\n     */\n-   default boolean isMaxIdleExpirable() {\n+   default boolean canExpireMaxIdle() {\n       return false;\n    }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMDgxMg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365730812", "bodyText": "Please inline the method and replace the if (expiredStage != null) check with if (ice.canExpire())", "author": "danberindei", "createdAt": "2020-01-13T10:26:04Z", "path": "core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java", "diffHunk": "@@ -109,28 +109,9 @@ private void handleExpiredEntryContextAddition(Boolean expired, InvocationContex\n       }\n    }\n \n-   private CompletionStage<Boolean> handlePossibleExpiredEntry(InternalCacheEntry ice, boolean write) {\n+   private CompletionStage<Boolean> handlePossibleExpiredEntry(InternalCacheEntry ice, int segment, boolean isWrite) {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNTI5OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365835299", "bodyText": "Sure :)", "author": "wburns", "createdAt": "2020-01-13T14:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMDgxMg=="}], "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java b/core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java\nindex 41bfe2958c..8618b46bbf 100644\n--- a/core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java\n+++ b/core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java\n\n@@ -109,13 +108,6 @@ private void handleExpiredEntryContextAddition(Boolean expired, InvocationContex\n       }\n    }\n \n-   private CompletionStage<Boolean> handlePossibleExpiredEntry(InternalCacheEntry ice, int segment, boolean isWrite) {\n-      if (ice.canExpire()) {\n-         return expirationManager.handlePossibleExpiration(ice, segment, isWrite);\n-      }\n-      return null;\n-   }\n-\n    private void addReadEntryToContext(InvocationContext ctx, CacheEntry cacheEntry, Object key) {\n       // With repeatable read, we need to create a RepeatableReadEntry as internal cache entries are mutable\n       // Otherwise we can store the InternalCacheEntry directly in the context\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMTk5Mg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365731992", "bodyText": "There's no point in having the parameters in the javadoc if they don't have a description, all we get is complaints from IntelliJ.", "author": "danberindei", "createdAt": "2020-01-13T10:28:52Z", "path": "core/src/main/java/org/infinispan/container/impl/InternalDataContainer.java", "diffHunk": "@@ -60,6 +60,15 @@\n     */\n    InternalCacheEntry<K, V> peek(int segment, Object k);\n \n+   /**\n+    *\n+    * @param segment\n+    * @param k\n+    * @param currentTimeMillis", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTQ3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365839471", "bodyText": "Updated, just didn't get around to it is all.", "author": "wburns", "createdAt": "2020-01-13T14:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMTk5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/container/impl/InternalDataContainer.java b/core/src/main/java/org/infinispan/container/impl/InternalDataContainer.java\nindex bf6948043e..b1669d3bf4 100644\n--- a/core/src/main/java/org/infinispan/container/impl/InternalDataContainer.java\n+++ b/core/src/main/java/org/infinispan/container/impl/InternalDataContainer.java\n\n@@ -61,11 +61,12 @@\n    InternalCacheEntry<K, V> peek(int segment, Object k);\n \n    /**\n-    *\n-    * @param segment\n-    * @param k\n-    * @param currentTimeMillis\n-    * @return true if the entry timestamp was updated\n+    * Touches an entry in the data container. This will update the last access time of the entry as well as count this\n+    * as a access for eviction based recency.\n+    * @param segment segment for the key\n+    * @param k key under which entry is stored\n+    * @param currentTimeMillis the current time in milliseconds to touch the entry with\n+    * @return true if the entry timestamp was touched\n     */\n    boolean touch(int segment, Object k, long currentTimeMillis);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczNDQ4OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365734489", "bodyText": "I think you need CompletableFutures.extractException.\nAnd I'd merge thenApply and exceptionally into a single handle.", "author": "danberindei", "createdAt": "2020-01-13T10:34:36Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\nindex f697fe2860..8f0a28d321 100644\n--- a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n+++ b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n\n@@ -411,39 +411,37 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry ice, int segment) {\n       Object key = ice.getKey();\n-      return attemptTouch(key, segment)\n-            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n-            .exceptionally(t -> {\n-               if (t instanceof OutdatedTopologyException) {\n-                  if (trace) {\n-                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+      return attemptTouchAndReturnIfExpired(key, segment)\n+            .handle((expired, t) -> {\n+               if (t != null) {\n+                  Throwable innerT = CompletableFutures.extractException(t);\n+                  if (innerT instanceof OutdatedTopologyException) {\n+                     if (trace) {\n+                        log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                     }\n+                     return attemptTouchAndReturnIfExpired(key, segment);\n                   }\n-                  return attemptTouch(key, segment);\n+                  return CompletableFutures.<Boolean>completedExceptionFuture(t);\n+               } else {\n+                  return CompletableFuture.completedFuture(expired);\n                }\n-               return CompletableFutures.completedExceptionFuture(t);\n             })\n             .thenCompose(Function.identity());\n    }\n \n-   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+   private CompletionStage<Boolean> attemptTouchAndReturnIfExpired(Object key, int segment) {\n       LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n-      DistributionInfo di = lct.getSegmentDistribution(segment);\n \n-      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n-      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n       TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n       touchCommand.setTopologyId(lct.getTopologyId());\n-      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n-            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n-            rpcManager.getSyncRpcOptions());\n+\n+      CompletionStage<Boolean> remoteStage = invokeTouchCommandRemotely(touchCommand, lct, segment);\n       touchCommand.init(componentRegistry, false);\n       CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n \n       return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n-         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n-         // then the value is not expired\n          if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n             return Boolean.FALSE;\n          }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0Mzk4Mg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365743982", "bodyText": "Should inline", "author": "danberindei", "createdAt": "2020-01-13T10:56:43Z", "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -270,11 +296,48 @@ public boolean containsKey(Object key) {\n \n       @Override\n       public CompletableFuture<V> getAsync(K key) {\n-         try {\n-            return CompletableFuture.completedFuture(get(key));\n-         } catch (Throwable t) {\n-            return CompletableFutures.completedExceptionFuture(t);\n+         return getCacheEntryAsync(key)\n+               .thenApply(ice -> ice != null ? ice.getValue() : null);\n+      }\n+\n+      private InternalCacheEntry<K, V> internalPeekCacheEntry(Object key, int segment) {\n+         assertKeyNotNull(key);\n+         checkCanRun(cache, cache.getName());\n+         return getDataContainer().peek(segment, key);\n+      }\n+\n+      @Override\n+      public CacheEntry<K, V> getCacheEntry(Object key) {\n+         return syncGet(key);\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         return asyncGet(key);", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java b/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\nindex 6b0026b71d..57998d555f 100644\n--- a/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\n+++ b/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\n\n@@ -307,36 +293,43 @@ public boolean containsKey(Object key) {\n       }\n \n       @Override\n-      public CacheEntry<K, V> getCacheEntry(Object key) {\n-         return syncGet(key);\n-      }\n-\n-      @Override\n-      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n-         return asyncGet(key);\n-      }\n-\n-      private CompletableFuture<CacheEntry<K, V>> asyncGet(Object key) {\n+      public InternalCacheEntry<K, V> getCacheEntry(Object key) {\n          int segment = keyPartitioner.getSegment(key);\n          InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n          if (ice != null) {\n             if (ice.canExpire()) {\n                CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n-               if (CompletionStages.isCompletedSuccessfully(stage)) {\n-                  return CompletableFutures.completedNull();\n-               } else {\n-                  return stage.thenApply(expired -> {\n-                     if (expired == Boolean.TRUE) {\n-                        return null;\n-                     }\n-                     return (CacheEntry<K, V>) ice;\n-                  }).toCompletableFuture();\n+               if (CompletionStages.join(stage)) {\n+                  ice = null;\n                }\n             }\n          }\n+         return ice;\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         int segment = keyPartitioner.getSegment(key);\n+         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n          if (ice == null) {\n             return CompletableFutures.completedNull();\n          }\n+         if (ice.canExpire()) {\n+            CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n+            if (CompletionStages.isCompletedSuccessfully(stage)) {\n+               if (CompletionStages.join(stage)) {\n+                  return CompletableFutures.completedNull();\n+               }\n+               return CompletableFuture.completedFuture(ice);\n+            } else {\n+               return stage.thenApply(expired -> {\n+                  if (expired == Boolean.TRUE) {\n+                     return null;\n+                  }\n+                  return (CacheEntry<K, V>) ice;\n+               }).toCompletableFuture();\n+            }\n+         }\n          return CompletableFuture.completedFuture(ice);\n       }\n    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NDI3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365744271", "bodyText": "Could inline syncGet() in getCacheEntry() and use that here.", "author": "danberindei", "createdAt": "2020-01-13T10:57:22Z", "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -242,21 +250,39 @@ public void wireRealCache() {\n        */\n       protected void internalWire(T cache) {\n          componentRegistry = cache.componentRegistry;\n+         expirationManager = cache.expirationManager;\n+         keyPartitioner = cache.keyPartitioner;\n          wireRealCache();\n       }\n \n+      @Override\n+      public InternalDataContainer<K, V> getDataContainer() {\n+         return (InternalDataContainer<K, V>) super.getDataContainer();\n+      }\n+\n       @Override\n       public V get(Object key) {\n-         assertKeyNotNull(key);\n-         checkCanRun(cache, cache.getName());\n-         // TODO: what should we do here? - This needs to be fixed in https://issues.redhat.com/browse/ISPN-11124\n-         InternalCacheEntry<K, V> ice = getDataContainer().get(key);\n+         InternalCacheEntry<K, V> ice = syncGet(key);", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java b/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\nindex 6b0026b71d..57998d555f 100644\n--- a/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\n+++ b/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\n\n@@ -262,27 +262,13 @@ protected void internalWire(T cache) {\n \n       @Override\n       public V get(Object key) {\n-         InternalCacheEntry<K, V> ice = syncGet(key);\n+         InternalCacheEntry<K, V> ice = getCacheEntry(key);\n          if (ice != null) {\n             return ice.getValue();\n          }\n          return null;\n       }\n \n-      InternalCacheEntry<K, V> syncGet(Object key) {\n-         int segment = keyPartitioner.getSegment(key);\n-         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n-         if (ice != null) {\n-            if (ice.canExpire()) {\n-               CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n-               if (CompletionStages.join(stage)) {\n-                  ice = null;\n-               }\n-            }\n-         }\n-         return ice;\n-      }\n-\n       @Override\n       public V getOrDefault(Object key, V defaultValue) {\n          V value = get(key);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NTQxNQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365745415", "bodyText": "ice isn't modified, so you could move this if at the top", "author": "danberindei", "createdAt": "2020-01-13T11:00:10Z", "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -270,11 +296,48 @@ public boolean containsKey(Object key) {\n \n       @Override\n       public CompletableFuture<V> getAsync(K key) {\n-         try {\n-            return CompletableFuture.completedFuture(get(key));\n-         } catch (Throwable t) {\n-            return CompletableFutures.completedExceptionFuture(t);\n+         return getCacheEntryAsync(key)\n+               .thenApply(ice -> ice != null ? ice.getValue() : null);\n+      }\n+\n+      private InternalCacheEntry<K, V> internalPeekCacheEntry(Object key, int segment) {\n+         assertKeyNotNull(key);\n+         checkCanRun(cache, cache.getName());\n+         return getDataContainer().peek(segment, key);\n+      }\n+\n+      @Override\n+      public CacheEntry<K, V> getCacheEntry(Object key) {\n+         return syncGet(key);\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         return asyncGet(key);\n+      }\n+\n+      private CompletableFuture<CacheEntry<K, V>> asyncGet(Object key) {\n+         int segment = keyPartitioner.getSegment(key);\n+         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n+         if (ice != null) {\n+            if (ice.canExpire()) {\n+               CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n+               if (CompletionStages.isCompletedSuccessfully(stage)) {\n+                  return CompletableFutures.completedNull();\n+               } else {\n+                  return stage.thenApply(expired -> {\n+                     if (expired == Boolean.TRUE) {\n+                        return null;\n+                     }\n+                     return (CacheEntry<K, V>) ice;\n+                  }).toCompletableFuture();\n+               }\n+            }\n+         }\n+         if (ice == null) {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java b/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\nindex 6b0026b71d..57998d555f 100644\n--- a/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\n+++ b/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\n\n@@ -307,36 +293,43 @@ public boolean containsKey(Object key) {\n       }\n \n       @Override\n-      public CacheEntry<K, V> getCacheEntry(Object key) {\n-         return syncGet(key);\n-      }\n-\n-      @Override\n-      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n-         return asyncGet(key);\n-      }\n-\n-      private CompletableFuture<CacheEntry<K, V>> asyncGet(Object key) {\n+      public InternalCacheEntry<K, V> getCacheEntry(Object key) {\n          int segment = keyPartitioner.getSegment(key);\n          InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n          if (ice != null) {\n             if (ice.canExpire()) {\n                CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n-               if (CompletionStages.isCompletedSuccessfully(stage)) {\n-                  return CompletableFutures.completedNull();\n-               } else {\n-                  return stage.thenApply(expired -> {\n-                     if (expired == Boolean.TRUE) {\n-                        return null;\n-                     }\n-                     return (CacheEntry<K, V>) ice;\n-                  }).toCompletableFuture();\n+               if (CompletionStages.join(stage)) {\n+                  ice = null;\n                }\n             }\n          }\n+         return ice;\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         int segment = keyPartitioner.getSegment(key);\n+         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n          if (ice == null) {\n             return CompletableFutures.completedNull();\n          }\n+         if (ice.canExpire()) {\n+            CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n+            if (CompletionStages.isCompletedSuccessfully(stage)) {\n+               if (CompletionStages.join(stage)) {\n+                  return CompletableFutures.completedNull();\n+               }\n+               return CompletableFuture.completedFuture(ice);\n+            } else {\n+               return stage.thenApply(expired -> {\n+                  if (expired == Boolean.TRUE) {\n+                     return null;\n+                  }\n+                  return (CacheEntry<K, V>) ice;\n+               }).toCompletableFuture();\n+            }\n+         }\n          return CompletableFuture.completedFuture(ice);\n       }\n    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NjQ5Mg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365746492", "bodyText": "Forgot to check if the entry was expired or not", "author": "danberindei", "createdAt": "2020-01-13T11:02:54Z", "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -270,11 +296,48 @@ public boolean containsKey(Object key) {\n \n       @Override\n       public CompletableFuture<V> getAsync(K key) {\n-         try {\n-            return CompletableFuture.completedFuture(get(key));\n-         } catch (Throwable t) {\n-            return CompletableFutures.completedExceptionFuture(t);\n+         return getCacheEntryAsync(key)\n+               .thenApply(ice -> ice != null ? ice.getValue() : null);\n+      }\n+\n+      private InternalCacheEntry<K, V> internalPeekCacheEntry(Object key, int segment) {\n+         assertKeyNotNull(key);\n+         checkCanRun(cache, cache.getName());\n+         return getDataContainer().peek(segment, key);\n+      }\n+\n+      @Override\n+      public CacheEntry<K, V> getCacheEntry(Object key) {\n+         return syncGet(key);\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         return asyncGet(key);\n+      }\n+\n+      private CompletableFuture<CacheEntry<K, V>> asyncGet(Object key) {\n+         int segment = keyPartitioner.getSegment(key);\n+         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n+         if (ice != null) {\n+            if (ice.canExpire()) {\n+               CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n+               if (CompletionStages.isCompletedSuccessfully(stage)) {\n+                  return CompletableFutures.completedNull();", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MzQxOQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365843419", "bodyText": "Oops :)", "author": "wburns", "createdAt": "2020-01-13T14:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NjQ5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java b/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\nindex 6b0026b71d..57998d555f 100644\n--- a/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\n+++ b/core/src/main/java/org/infinispan/factories/InternalCacheFactory.java\n\n@@ -307,36 +293,43 @@ public boolean containsKey(Object key) {\n       }\n \n       @Override\n-      public CacheEntry<K, V> getCacheEntry(Object key) {\n-         return syncGet(key);\n-      }\n-\n-      @Override\n-      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n-         return asyncGet(key);\n-      }\n-\n-      private CompletableFuture<CacheEntry<K, V>> asyncGet(Object key) {\n+      public InternalCacheEntry<K, V> getCacheEntry(Object key) {\n          int segment = keyPartitioner.getSegment(key);\n          InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n          if (ice != null) {\n             if (ice.canExpire()) {\n                CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n-               if (CompletionStages.isCompletedSuccessfully(stage)) {\n-                  return CompletableFutures.completedNull();\n-               } else {\n-                  return stage.thenApply(expired -> {\n-                     if (expired == Boolean.TRUE) {\n-                        return null;\n-                     }\n-                     return (CacheEntry<K, V>) ice;\n-                  }).toCompletableFuture();\n+               if (CompletionStages.join(stage)) {\n+                  ice = null;\n                }\n             }\n          }\n+         return ice;\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         int segment = keyPartitioner.getSegment(key);\n+         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n          if (ice == null) {\n             return CompletableFutures.completedNull();\n          }\n+         if (ice.canExpire()) {\n+            CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n+            if (CompletionStages.isCompletedSuccessfully(stage)) {\n+               if (CompletionStages.join(stage)) {\n+                  return CompletableFutures.completedNull();\n+               }\n+               return CompletableFuture.completedFuture(ice);\n+            } else {\n+               return stage.thenApply(expired -> {\n+                  if (expired == Boolean.TRUE) {\n+                     return null;\n+                  }\n+                  return (CacheEntry<K, V>) ice;\n+               }).toCompletableFuture();\n+            }\n+         }\n          return CompletableFuture.completedFuture(ice);\n       }\n    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NzQ2OA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365747468", "bodyText": "Maybe it's worth extracting some of this logic into a method createTouchResponseCollector(CacheMode, LocalizedCacheTopology)?", "author": "danberindei", "createdAt": "2020-01-13T11:05:28Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MzgxMg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365843812", "bodyText": "Sure, I can do that.", "author": "wburns", "createdAt": "2020-01-13T14:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NzQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0NDA4NQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365844085", "bodyText": "I will change it slightly though as I should be able to encapsulate everything returning a CompletionStage<Boolean> even.", "author": "wburns", "createdAt": "2020-01-13T14:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NzQ2OA=="}], "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\nindex f697fe2860..8f0a28d321 100644\n--- a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n+++ b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n\n@@ -411,39 +411,37 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry ice, int segment) {\n       Object key = ice.getKey();\n-      return attemptTouch(key, segment)\n-            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n-            .exceptionally(t -> {\n-               if (t instanceof OutdatedTopologyException) {\n-                  if (trace) {\n-                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+      return attemptTouchAndReturnIfExpired(key, segment)\n+            .handle((expired, t) -> {\n+               if (t != null) {\n+                  Throwable innerT = CompletableFutures.extractException(t);\n+                  if (innerT instanceof OutdatedTopologyException) {\n+                     if (trace) {\n+                        log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                     }\n+                     return attemptTouchAndReturnIfExpired(key, segment);\n                   }\n-                  return attemptTouch(key, segment);\n+                  return CompletableFutures.<Boolean>completedExceptionFuture(t);\n+               } else {\n+                  return CompletableFuture.completedFuture(expired);\n                }\n-               return CompletableFutures.completedExceptionFuture(t);\n             })\n             .thenCompose(Function.identity());\n    }\n \n-   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+   private CompletionStage<Boolean> attemptTouchAndReturnIfExpired(Object key, int segment) {\n       LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n-      DistributionInfo di = lct.getSegmentDistribution(segment);\n \n-      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n-      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n       TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n       touchCommand.setTopologyId(lct.getTopologyId());\n-      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n-            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n-            rpcManager.getSyncRpcOptions());\n+\n+      CompletionStage<Boolean> remoteStage = invokeTouchCommandRemotely(touchCommand, lct, segment);\n       touchCommand.init(componentRegistry, false);\n       CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n \n       return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n-         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n-         // then the value is not expired\n          if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n             return Boolean.FALSE;\n          }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0ODI3OA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365748278", "bodyText": "The first part is probably better suited in the super method's javadoc.", "author": "danberindei", "createdAt": "2020-01-13T11:07:38Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n+            rpcManager.getSyncRpcOptions());\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n+\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\nindex f697fe2860..8f0a28d321 100644\n--- a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n+++ b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n\n@@ -411,39 +411,37 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry ice, int segment) {\n       Object key = ice.getKey();\n-      return attemptTouch(key, segment)\n-            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n-            .exceptionally(t -> {\n-               if (t instanceof OutdatedTopologyException) {\n-                  if (trace) {\n-                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+      return attemptTouchAndReturnIfExpired(key, segment)\n+            .handle((expired, t) -> {\n+               if (t != null) {\n+                  Throwable innerT = CompletableFutures.extractException(t);\n+                  if (innerT instanceof OutdatedTopologyException) {\n+                     if (trace) {\n+                        log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                     }\n+                     return attemptTouchAndReturnIfExpired(key, segment);\n                   }\n-                  return attemptTouch(key, segment);\n+                  return CompletableFutures.<Boolean>completedExceptionFuture(t);\n+               } else {\n+                  return CompletableFuture.completedFuture(expired);\n                }\n-               return CompletableFutures.completedExceptionFuture(t);\n             })\n             .thenCompose(Function.identity());\n    }\n \n-   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+   private CompletionStage<Boolean> attemptTouchAndReturnIfExpired(Object key, int segment) {\n       LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n-      DistributionInfo di = lct.getSegmentDistribution(segment);\n \n-      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n-      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n       TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n       touchCommand.setTopologyId(lct.getTopologyId());\n-      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n-            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n-            rpcManager.getSyncRpcOptions());\n+\n+      CompletionStage<Boolean> remoteStage = invokeTouchCommandRemotely(touchCommand, lct, segment);\n       touchCommand.init(componentRegistry, false);\n       CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n \n       return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n-         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n-         // then the value is not expired\n          if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n             return Boolean.FALSE;\n          }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1NDI5MA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365754290", "bodyText": "If one of the backup owners dies, a rebalance is started, but for a while there are multiple owners.\nIf the primary owner dies, for a while there is no primary owner, then a new primary owner is selected and it backs up to the next node + invalidates the other owners.\nInvalidation commands triggered by regular writes are also sent asynchronously (and in batches), so it's quite common to have more than 1 backup owner.\nSee also the scattered package javadoc", "author": "danberindei", "createdAt": "2020-01-13T11:24:03Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n+            rpcManager.getSyncRpcOptions());\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n+\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n+         // then the value is not expired\n+         if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            return Boolean.FALSE;\n+         }\n+         return Boolean.TRUE;\n+      });\n+   }\n \n-      if (trace) {\n-         log.tracef(\"Asking all read owners %s for key: %s - for latest access time\", info.readOwners(), key);\n+   private static abstract class AbstractTouchResponseCollector extends ValidResponseCollector<Boolean> {\n+      @Override\n+      protected Boolean addTargetNotFound(Address sender) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n       }\n \n-      // Need to gather last access times\n-      RetrieveLastAccessCommand rlac = cf.running().buildRetrieveLastAccessCommand(key, value, segment);\n-      rlac.setTopologyId(topology.getTopologyId());\n-\n-      // In scattered cache read owners will only contain primary\n-      return rpcManager.invokeCommand(info.readOwners(), rlac, new MaxResponseCollector<>(access),\n-            rpcManager.getSyncRpcOptions()).toCompletableFuture();\n+      @Override\n+      protected Boolean addException(Address sender, Exception exception) {\n+         if (exception instanceof CacheException) {\n+            throw (CacheException) exception;\n+         }\n+         throw new CacheException(exception);\n+      }\n    }\n \n-   static class MaxResponseCollector<T extends Comparable<T>> extends ValidResponseCollector<T> {\n-      T highest;\n-\n-      MaxResponseCollector(T highest) {\n-         this.highest = highest;\n-      }\n+   private static class ScatteredTouchResponseCollector extends AbstractTouchResponseCollector {\n \n       @Override\n-      public T finish() {\n-         return highest;\n+      public Boolean finish() {\n+         // No other node was touched\n+         return Boolean.FALSE;\n       }\n \n       @Override\n-      protected T addValidResponse(Address sender, ValidResponse response) {\n-         T value = (T) response.getResponseValue();\n-         if (trace) {\n-            log.tracef(\"Received response %s from %s when requesting access time for max idle\", value, sender);\n-         }\n-         if (value != null && (highest == null || highest.compareTo(value) < 0)) {\n-            highest = value;\n+      protected Boolean addValidResponse(Address sender, ValidResponse response) {\n+         Boolean touched = (Boolean) response.getResponseValue();\n+         if (touched == Boolean.TRUE) {\n+            // Return early if any node touched the value - as SCATTERED only exists on a single backup!\n+            // TODO: what if the read was when one of the backups or primary died?", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\nindex f697fe2860..8f0a28d321 100644\n--- a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n+++ b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n\n@@ -411,39 +411,37 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry ice, int segment) {\n       Object key = ice.getKey();\n-      return attemptTouch(key, segment)\n-            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n-            .exceptionally(t -> {\n-               if (t instanceof OutdatedTopologyException) {\n-                  if (trace) {\n-                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+      return attemptTouchAndReturnIfExpired(key, segment)\n+            .handle((expired, t) -> {\n+               if (t != null) {\n+                  Throwable innerT = CompletableFutures.extractException(t);\n+                  if (innerT instanceof OutdatedTopologyException) {\n+                     if (trace) {\n+                        log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                     }\n+                     return attemptTouchAndReturnIfExpired(key, segment);\n                   }\n-                  return attemptTouch(key, segment);\n+                  return CompletableFutures.<Boolean>completedExceptionFuture(t);\n+               } else {\n+                  return CompletableFuture.completedFuture(expired);\n                }\n-               return CompletableFutures.completedExceptionFuture(t);\n             })\n             .thenCompose(Function.identity());\n    }\n \n-   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+   private CompletionStage<Boolean> attemptTouchAndReturnIfExpired(Object key, int segment) {\n       LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n-      DistributionInfo di = lct.getSegmentDistribution(segment);\n \n-      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n-      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n       TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n       touchCommand.setTopologyId(lct.getTopologyId());\n-      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n-            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n-            rpcManager.getSyncRpcOptions());\n+\n+      CompletionStage<Boolean> remoteStage = invokeTouchCommandRemotely(touchCommand, lct, segment);\n       touchCommand.init(componentRegistry, false);\n       CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n \n       return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n-         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n-         // then the value is not expired\n          if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n             return Boolean.FALSE;\n          }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365764249", "bodyText": "I'd rather not return early, because you'd leave touch commands floating around, making tests less deterministic, while the scenario is hopefully really uncommon.", "author": "danberindei", "createdAt": "2020-01-13T11:51:08Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n+            rpcManager.getSyncRpcOptions());\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n+\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n+         // then the value is not expired\n+         if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            return Boolean.FALSE;\n+         }\n+         return Boolean.TRUE;\n+      });\n+   }\n \n-      if (trace) {\n-         log.tracef(\"Asking all read owners %s for key: %s - for latest access time\", info.readOwners(), key);\n+   private static abstract class AbstractTouchResponseCollector extends ValidResponseCollector<Boolean> {\n+      @Override\n+      protected Boolean addTargetNotFound(Address sender) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n       }\n \n-      // Need to gather last access times\n-      RetrieveLastAccessCommand rlac = cf.running().buildRetrieveLastAccessCommand(key, value, segment);\n-      rlac.setTopologyId(topology.getTopologyId());\n-\n-      // In scattered cache read owners will only contain primary\n-      return rpcManager.invokeCommand(info.readOwners(), rlac, new MaxResponseCollector<>(access),\n-            rpcManager.getSyncRpcOptions()).toCompletableFuture();\n+      @Override\n+      protected Boolean addException(Address sender, Exception exception) {\n+         if (exception instanceof CacheException) {\n+            throw (CacheException) exception;\n+         }\n+         throw new CacheException(exception);\n+      }\n    }\n \n-   static class MaxResponseCollector<T extends Comparable<T>> extends ValidResponseCollector<T> {\n-      T highest;\n-\n-      MaxResponseCollector(T highest) {\n-         this.highest = highest;\n-      }\n+   private static class ScatteredTouchResponseCollector extends AbstractTouchResponseCollector {\n \n       @Override\n-      public T finish() {\n-         return highest;\n+      public Boolean finish() {\n+         // No other node was touched\n+         return Boolean.FALSE;\n       }\n \n       @Override\n-      protected T addValidResponse(Address sender, ValidResponse response) {\n-         T value = (T) response.getResponseValue();\n-         if (trace) {\n-            log.tracef(\"Received response %s from %s when requesting access time for max idle\", value, sender);\n-         }\n-         if (value != null && (highest == null || highest.compareTo(value) < 0)) {\n-            highest = value;\n+      protected Boolean addValidResponse(Address sender, ValidResponse response) {\n+         Boolean touched = (Boolean) response.getResponseValue();\n+         if (touched == Boolean.TRUE) {\n+            // Return early if any node touched the value - as SCATTERED only exists on a single backup!\n+            // TODO: what if the read was when one of the backups or primary died?\n+            return Boolean.TRUE;\n          }\n          return null;\n       }\n+   }\n \n+   private static class TouchResponseCollector extends AbstractTouchResponseCollector {\n       @Override\n-      protected T addTargetNotFound(Address sender) {\n-         // We don't care about a node leaving\n-         return null;\n+      public Boolean finish() {\n+         // If all were touched, then the value isn't expired\n+         return Boolean.TRUE;\n       }\n \n       @Override\n-      protected T addException(Address sender, Exception exception) {\n-         throw ResponseCollectors.wrapRemoteException(sender, exception);\n+      protected Boolean addValidResponse(Address sender, ValidResponse response) {\n+         Boolean touched = (Boolean) response.getResponseValue();\n+         if (touched == Boolean.FALSE) {\n+            // Return early if any value wasn't touched!", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0OTUxNA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365849514", "bodyText": "which scenario? this would be quite common when using max idle with scattered cache.", "author": "wburns", "createdAt": "2020-01-13T14:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2MTYzNw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365861637", "bodyText": "This is the disc response collector, not the scattered one.\nI was thinking it would be uncommon to have an operation that tries to expire an entry and finds another operation already expired/updated/removed the entry, because expirations themselves shouldn't be very common.", "author": "danberindei", "createdAt": "2020-01-13T15:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2MzY3Nw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365863677", "bodyText": "To clarify this is ran on access, not expiration - so it would increase the frequency a bit more.\nThe other benefit of returning early is technically the collector is stateless, which would allow for a singleton impl, I just forgot to do that.", "author": "wburns", "createdAt": "2020-01-13T15:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMTk0Mg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365931942", "bodyText": "True, you don't need two concurrent expirations to get a false, just one expiration and a regular read, but still I'm not 100% sold on having those touch commands floating around.", "author": "danberindei", "createdAt": "2020-01-13T17:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\nindex f697fe2860..8f0a28d321 100644\n--- a/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n+++ b/core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java\n\n@@ -411,39 +411,37 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry ice, int segment) {\n       Object key = ice.getKey();\n-      return attemptTouch(key, segment)\n-            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n-            .exceptionally(t -> {\n-               if (t instanceof OutdatedTopologyException) {\n-                  if (trace) {\n-                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+      return attemptTouchAndReturnIfExpired(key, segment)\n+            .handle((expired, t) -> {\n+               if (t != null) {\n+                  Throwable innerT = CompletableFutures.extractException(t);\n+                  if (innerT instanceof OutdatedTopologyException) {\n+                     if (trace) {\n+                        log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                     }\n+                     return attemptTouchAndReturnIfExpired(key, segment);\n                   }\n-                  return attemptTouch(key, segment);\n+                  return CompletableFutures.<Boolean>completedExceptionFuture(t);\n+               } else {\n+                  return CompletableFuture.completedFuture(expired);\n                }\n-               return CompletableFutures.completedExceptionFuture(t);\n             })\n             .thenCompose(Function.identity());\n    }\n \n-   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+   private CompletionStage<Boolean> attemptTouchAndReturnIfExpired(Object key, int segment) {\n       LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n-      DistributionInfo di = lct.getSegmentDistribution(segment);\n \n-      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n-      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n       TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n       touchCommand.setTopologyId(lct.getTopologyId());\n-      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n-            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n-            rpcManager.getSyncRpcOptions());\n+\n+      CompletionStage<Boolean> remoteStage = invokeTouchCommandRemotely(touchCommand, lct, segment);\n       touchCommand.init(componentRegistry, false);\n       CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n \n       return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n-         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n-         // then the value is not expired\n          if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n             return Boolean.FALSE;\n          }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2ODI0OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365768249", "bodyText": "Please add a javadoc and explain the return value.", "author": "danberindei", "createdAt": "2020-01-13T12:01:58Z", "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -1,55 +1,44 @@\n-package org.infinispan.commands.remote.expiration;\n+package org.infinispan.expiration.impl;\n \n import java.io.IOException;\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n import java.util.concurrent.CompletableFuture;\n \n import org.infinispan.commands.InitializableCommand;\n-import org.infinispan.commands.SegmentSpecificCommand;\n import org.infinispan.commands.TopologyAffectedCommand;\n import org.infinispan.commands.remote.BaseRpcCommand;\n import org.infinispan.commons.io.UnsignedNumeric;\n-import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.commons.time.TimeService;\n import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.distribution.DistributionManager;\n import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.statetransfer.OutdatedTopologyException;\n import org.infinispan.util.ByteString;\n import org.infinispan.util.concurrent.CompletableFutures;\n \n-/**\n- * Command that will update the last access time for an entry given the specific time\n- * @author wburns\n- * @since 9.3\n- */\n-public class UpdateLastAccessCommand extends BaseRpcCommand implements InitializableCommand, TopologyAffectedCommand, SegmentSpecificCommand {\n+public class TouchCommand extends BaseRpcCommand implements InitializableCommand, TopologyAffectedCommand {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java b/core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java\nindex b9d681da9d..47e3749a84 100644\n--- a/core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java\n+++ b/core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java\n\n@@ -11,12 +11,20 @@\n import org.infinispan.commons.io.UnsignedNumeric;\n import org.infinispan.commons.time.TimeService;\n import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.distribution.DistributionInfo;\n import org.infinispan.distribution.DistributionManager;\n+import org.infinispan.distribution.LocalizedCacheTopology;\n import org.infinispan.factories.ComponentRegistry;\n import org.infinispan.statetransfer.OutdatedTopologyException;\n import org.infinispan.util.ByteString;\n import org.infinispan.util.concurrent.CompletableFutures;\n \n+/**\n+ * This command can be invoked to update a cache entry's recent access. This can involve updating its last access\n+ * with max idle as well as recent eviction access times.\n+ * <p>\n+ * This command returns a Boolean that is whether this command was able to touch the value or not.\n+ */\n public class TouchCommand extends BaseRpcCommand implements InitializableCommand, TopologyAffectedCommand {\n    public static final byte COMMAND_ID = 66;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NTEwNQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365775105", "bodyText": "I'd expect TouchCommand and a method named touchEntry to use the same convention for the return value.\nI suggest moving thenApply(touched -> !touched) outside the method.", "author": "danberindei", "createdAt": "2020-01-13T12:20:46Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -252,22 +260,36 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata) {\n             cacheNotifier.notifyCacheEntryExpired(key, value, metadata, null)));\n    }\n \n-   protected Long localLastAccess(Object key, Object value, int segment) {\n-      InternalCacheEntry ice = dataContainer.running().peek(segment, key);\n-      if (ice != null && (value == null || value.equals(ice.getValue())) &&\n-            !ice.isExpired(timeService.wallClockTime())) {\n-         return ice.getLastUsed();\n+   @Override\n+   public CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> ice, int segment, boolean isWrite) {\n+      long currentTime = timeService.wallClockTime();\n+      if (ice.isExpired(currentTime)) {\n+         if (trace) {\n+            log.tracef(\"Retrieved entry for key %s was expired locally, attempting expiration removal\", ice.getKey());\n+         }\n+         CompletableFuture<Boolean> expiredStage = entryExpiredInMemory(ice, currentTime, isWrite);\n+         if (trace) {\n+            expiredStage = expiredStage.thenApply(expired -> {\n+               if (expired == Boolean.FALSE) {\n+                  log.tracef(\"Retrieved entry for key %s was found to not be expired.\", ice.getKey());\n+               } else {\n+                  log.tracef(\"Retrieved entry for key %s was confirmed to be expired.\", ice.getKey());\n+               }\n+               return expired;\n+            });\n+         }\n+         return expiredStage;\n+      } else if (!isWrite && ice.isMaxIdleExpirable()) {\n+         return touchEntry(ice, segment);\n       }\n-      return null;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long lastAccess = localLastAccess(key, value, segment);\n-      if (lastAccess != null) {\n-         return CompletableFuture.completedFuture(lastAccess);\n-      }\n-      return CompletableFutures.completedNull();\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry entry, int segment) {\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(entry.getKey(), segment);\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Boolean> future = (CompletableFuture) touchCommand.invokeAsync();\n+      return future.thenApply(touched -> !touched);", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg1MzM4Mg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365853382", "bodyText": "I renamed the method.", "author": "wburns", "createdAt": "2020-01-13T15:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NTEwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java b/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java\nindex 800b105682..7ed3e419e1 100644\n--- a/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java\n+++ b/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java\n\n@@ -279,13 +279,21 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata) {\n             });\n          }\n          return expiredStage;\n-      } else if (!isWrite && ice.isMaxIdleExpirable()) {\n-         return touchEntry(ice, segment);\n+      } else if (!isWrite && ice.canExpireMaxIdle()) {\n+         return touchEntryAndReturnIfExpired(ice, segment);\n       }\n       return CompletableFutures.completedFalse();\n    }\n \n-   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry entry, int segment) {\n+   /**\n+    * Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n+    * then the value is not expired. Note this is different then the touch command's response normally as that mentions\n+    * if it was touched or not\n+    * @param entry\n+    * @param segment\n+    * @return\n+    */\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry entry, int segment) {\n       TouchCommand touchCommand = cf.running().buildTouchCommand(entry.getKey(), segment);\n       touchCommand.init(componentRegistry, false);\n       CompletableFuture<Boolean> future = (CompletableFuture) touchCommand.invokeAsync();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NTIyMA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365775220", "bodyText": "Missing javadoc", "author": "danberindei", "createdAt": "2020-01-13T12:21:01Z", "path": "core/src/main/java/org/infinispan/expiration/impl/InternalExpirationManager.java", "diffHunk": "@@ -73,15 +73,5 @@ default void handleInStoreExpiration(MarshallableEntry<K, V> marshalledEntry) {\n       CompletionStages.join(handleInStoreExpirationInternal(marshalledEntry));\n    }\n \n-   /**\n-    * Retrieves the last access time for the given key in the data container if it is using max idle.\n-    * If the entry is not in the container or it is expired it will return null.\n-    * If the entry is present but cannot expire via max idle, it will return -1\n-    * If the entry is present and can expire via max idle but hasn't it will return a number > 0\n-    * @param key the key to retrieve the access time for\n-    * @param value the value to match if desired (this can be null)\n-    * @param segment the segment for the given key\n-    * @return the last access time if available\n-    */\n-   CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment);\n+   CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> entry, int segment, boolean isWrite);", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/main/java/org/infinispan/expiration/impl/InternalExpirationManager.java b/core/src/main/java/org/infinispan/expiration/impl/InternalExpirationManager.java\nindex 5c4489a2e0..227976a32b 100644\n--- a/core/src/main/java/org/infinispan/expiration/impl/InternalExpirationManager.java\n+++ b/core/src/main/java/org/infinispan/expiration/impl/InternalExpirationManager.java\n\n@@ -73,5 +73,13 @@ default void handleInStoreExpiration(MarshallableEntry<K, V> marshalledEntry) {\n       CompletionStages.join(handleInStoreExpirationInternal(marshalledEntry));\n    }\n \n+   /**\n+    * Handles processing for an entry that may be expired. This will remove the entry if it is expired, otherwise may\n+    * touch if it uses max idle. The return stage will contain whether the entry was actually expired or not\n+    * @param entry entry that may be expired\n+    * @param segment the segment of the entry\n+    * @param isWrite whether the command that saw the expired value was a write or not\n+    * @return a stage that when complete will return if the entry was expired\n+    */\n    CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> entry, int segment, boolean isWrite);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NzQ5Nw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365777497", "bodyText": "MultipleCacheManagersTest#getKeyForCache(org.infinispan.Cache<?,?>, org.infinispan.Cache<?,?>...)", "author": "danberindei", "createdAt": "2020-01-13T12:27:04Z", "path": "core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java", "diffHunk": "@@ -340,4 +341,49 @@ public void testWriteExpiredEntry() throws InterruptedException {\n          ts2.advance(secondOneMilliAdvanced);\n       }\n    }\n+\n+   public void testMaxIdleReadNodeDiesPrimary() {\n+      testMaxIdleNodeDies(c -> {\n+         if (cacheMode.isScattered()) {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3NzQ2OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365877469", "bodyText": "Ah nice, wasn't aware of that.", "author": "wburns", "createdAt": "2020-01-13T15:50:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NzQ5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java b/core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java\nindex 7fda983ba7..c79d34c2c5 100644\n--- a/core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java\n+++ b/core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java\n\n@@ -343,21 +343,11 @@ public void testWriteExpiredEntry() throws InterruptedException {\n    }\n \n    public void testMaxIdleReadNodeDiesPrimary() {\n-      testMaxIdleNodeDies(c -> {\n-         if (cacheMode.isScattered()) {\n-            return new MagicKey(c);\n-         }\n-         return new MagicKey(c, cache0);\n-      });\n+      testMaxIdleNodeDies(c -> getKeyForCache(c, cache0));\n    }\n \n    public void testMaxIdleReadNodeDiesBackup() {\n-      testMaxIdleNodeDies(c -> {\n-         if (cacheMode.isScattered()) {\n-            return new MagicKey(cache0);\n-         }\n-         return new MagicKey(cache0, c);\n-      });\n+      testMaxIdleNodeDies(c -> getKeyForCache(cache0, c));\n    }\n \n    private void testMaxIdleNodeDies(Function<Cache<?, ?>, MagicKey> keyToUseFunction) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTA2MA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365779060", "bodyText": "killMember(3) calls waitForNoRebalance(caches), I think you need to block the rebalance and test expiration during the rebalance as well.", "author": "danberindei", "createdAt": "2020-01-13T12:30:54Z", "path": "core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java", "diffHunk": "@@ -340,4 +341,49 @@ public void testWriteExpiredEntry() throws InterruptedException {\n          ts2.advance(secondOneMilliAdvanced);\n       }\n    }\n+\n+   public void testMaxIdleReadNodeDiesPrimary() {\n+      testMaxIdleNodeDies(c -> {\n+         if (cacheMode.isScattered()) {\n+            return new MagicKey(c);\n+         }\n+         return new MagicKey(c, cache0);\n+      });\n+   }\n+\n+   public void testMaxIdleReadNodeDiesBackup() {\n+      testMaxIdleNodeDies(c -> {\n+         if (cacheMode.isScattered()) {\n+            return new MagicKey(cache0);\n+         }\n+         return new MagicKey(cache0, c);\n+      });\n+   }\n+\n+   private void testMaxIdleNodeDies(Function<Cache<?, ?>, MagicKey> keyToUseFunction) {\n+      addClusterEnabledCacheManager(TestDataSCI.INSTANCE, configurationBuilder);\n+      waitForClusterToForm();\n+\n+      Cache<Object, String> cache3 = cache(3);\n+\n+      ControlledTimeService ts4 = new ControlledTimeService();\n+      TestingUtil.replaceComponent(manager(3), TimeService.class, ts4, true);\n+\n+      MagicKey key = keyToUseFunction.apply(cache3);\n+\n+      // We always write to cache3 so that scattered uses it as a backup if the key isn't owned by it\n+      cache3.put(key, \"max-idle\", -1, TimeUnit.MILLISECONDS, 100, TimeUnit.MILLISECONDS);\n+\n+      long justbeforeExpiration = 99;\n+      incrementAllTimeServices(justbeforeExpiration, TimeUnit.MILLISECONDS);\n+      ts4.advance(justbeforeExpiration);\n+\n+      assertNotNull(cache3.get(key));\n+\n+      killMember(3);", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3OTA5Nw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365879097", "bodyText": "Yeah, this test wasn't trying to test that out yet. It was more to make sure after node failure that the timestamp is still good.", "author": "wburns", "createdAt": "2020-01-13T15:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTA2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3OTM5Nw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365879397", "bodyText": "@danberindei is there an example test I can use that you recommend that blocks rebalance? I find getting a test correct with that can be quite annoying.", "author": "wburns", "createdAt": "2020-01-13T15:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTA2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NTE2MA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365945160", "bodyText": "There are many tests that block a rebalance, in different ways, depending on the scenario they want to test.\nSome block the StateResponseCommand so that the they block the insertion of particular keys. Some only block the CacheTopologyControlCommand(REBALANCE_PHASE_CONFIRM) commands so the cache stays in a particular topology phase (usually READ_OLD_WRITE_ALL) after state transfer has finished.\nSome block the sender side, with ControlledRpcManager or ControlledTransport. Some block the receiver side, with many impls of InboundInvocationHandler, PerCacheInboundInvocationHandler, LocalTopologyManagerImpl, StateProviderImpl, or StateConsumerImpl.", "author": "danberindei", "createdAt": "2020-01-13T17:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTA2MA=="}], "type": "inlineReview", "revised_code": {"commit": "6d679ec786cf71ea2163fbd859004470d7aab136", "chunk": "diff --git a/core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java b/core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java\nindex 7fda983ba7..c79d34c2c5 100644\n--- a/core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java\n+++ b/core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java\n\n@@ -343,21 +343,11 @@ public void testWriteExpiredEntry() throws InterruptedException {\n    }\n \n    public void testMaxIdleReadNodeDiesPrimary() {\n-      testMaxIdleNodeDies(c -> {\n-         if (cacheMode.isScattered()) {\n-            return new MagicKey(c);\n-         }\n-         return new MagicKey(c, cache0);\n-      });\n+      testMaxIdleNodeDies(c -> getKeyForCache(c, cache0));\n    }\n \n    public void testMaxIdleReadNodeDiesBackup() {\n-      testMaxIdleNodeDies(c -> {\n-         if (cacheMode.isScattered()) {\n-            return new MagicKey(cache0);\n-         }\n-         return new MagicKey(cache0, c);\n-      });\n+      testMaxIdleNodeDies(c -> getKeyForCache(cache0, c));\n    }\n \n    private void testMaxIdleNodeDies(Function<Cache<?, ?>, MagicKey> keyToUseFunction) {\n"}}, {"oid": "6d679ec786cf71ea2163fbd859004470d7aab136", "url": "https://github.com/infinispan/infinispan/commit/6d679ec786cf71ea2163fbd859004470d7aab136", "message": "some rework comments", "committedDate": "2020-01-13T15:54:26Z", "type": "commit"}, {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "url": "https://github.com/infinispan/infinispan/commit/a3f4aed51defa848a5ffade45f95bda2c7fcc086", "message": "hibernate fixes", "committedDate": "2020-01-13T17:08:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNjA2NQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365926065", "bodyText": "I was thinking more along the lines of checkExpiredMaxIdle()", "author": "danberindei", "createdAt": "2020-01-13T17:19:36Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,105 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry ice, int segment) {", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MDMxMw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r366950313", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-01-15T15:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNjA2NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyODQ2Ng==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365928466", "bodyText": "extra space", "author": "danberindei", "createdAt": "2020-01-13T17:24:50Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,105 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouchAndReturnIfExpired(key, segment)\n+            .handle((expired, t) -> {\n+               if (t != null) {\n+                  Throwable innerT = CompletableFutures.extractException(t);\n+                  if (innerT instanceof OutdatedTopologyException) {\n+                     if (trace) {\n+                        log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                     }\n+                     return attemptTouchAndReturnIfExpired(key, segment);\n+                  }\n+                  return CompletableFutures.<Boolean>completedExceptionFuture(t);\n+               } else {\n+                  return CompletableFuture.completedFuture(expired);\n+               }\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouchAndReturnIfExpired(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n \n-      if (trace) {\n-         log.tracef(\"Asking all read owners %s for key: %s - for latest access time\", info.readOwners(), key);\n-      }\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n \n-      // Need to gather last access times\n-      RetrieveLastAccessCommand rlac = cf.running().buildRetrieveLastAccessCommand(key, value, segment);\n-      rlac.setTopologyId(topology.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = invokeTouchCommandRemotely(touchCommand, lct, segment);\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n \n-      // In scattered cache read owners will only contain primary\n-      return rpcManager.invokeCommand(info.readOwners(), rlac, new MaxResponseCollector<>(access),\n-            rpcManager.getSyncRpcOptions()).toCompletableFuture();\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            return Boolean.FALSE;\n+         }\n+         return Boolean.TRUE;\n+      });\n    }\n \n-   static class MaxResponseCollector<T extends Comparable<T>> extends ValidResponseCollector<T> {\n-      T highest;\n+   private CompletionStage<Boolean> invokeTouchCommandRemotely(TouchCommand touchCommand, LocalizedCacheTopology lct,\n+         int segment) {\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+      // Scattered any node could be a backup, so we have to touch all members\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMzE3NA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365933174", "bodyText": "Empty tags", "author": "danberindei", "createdAt": "2020-01-13T17:34:58Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -252,22 +260,44 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata) {\n             cacheNotifier.notifyCacheEntryExpired(key, value, metadata, null)));\n    }\n \n-   protected Long localLastAccess(Object key, Object value, int segment) {\n-      InternalCacheEntry ice = dataContainer.running().peek(segment, key);\n-      if (ice != null && (value == null || value.equals(ice.getValue())) &&\n-            !ice.isExpired(timeService.wallClockTime())) {\n-         return ice.getLastUsed();\n+   @Override\n+   public CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> ice, int segment, boolean isWrite) {\n+      long currentTime = timeService.wallClockTime();\n+      if (ice.isExpired(currentTime)) {\n+         if (trace) {\n+            log.tracef(\"Retrieved entry for key %s was expired locally, attempting expiration removal\", ice.getKey());\n+         }\n+         CompletableFuture<Boolean> expiredStage = entryExpiredInMemory(ice, currentTime, isWrite);\n+         if (trace) {\n+            expiredStage = expiredStage.thenApply(expired -> {\n+               if (expired == Boolean.FALSE) {\n+                  log.tracef(\"Retrieved entry for key %s was found to not be expired.\", ice.getKey());\n+               } else {\n+                  log.tracef(\"Retrieved entry for key %s was confirmed to be expired.\", ice.getKey());\n+               }\n+               return expired;\n+            });\n+         }\n+         return expiredStage;\n+      } else if (!isWrite && ice.canExpireMaxIdle()) {\n+         return touchEntryAndReturnIfExpired(ice, segment);\n       }\n-      return null;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long lastAccess = localLastAccess(key, value, segment);\n-      if (lastAccess != null) {\n-         return CompletableFuture.completedFuture(lastAccess);\n-      }\n-      return CompletableFutures.completedNull();\n+   /**\n+    * Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n+    * then the value is not expired. Note this is different then the touch command's response normally as that mentions\n+    * if it was touched or not\n+    * @param entry\n+    * @param segment\n+    * @return", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMzU3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365933571", "bodyText": "IMO we shouldn't mention remote invocations here, just the first part, since ExpirationManagerImpl doesn't go remotely.", "author": "danberindei", "createdAt": "2020-01-13T17:35:43Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -252,22 +260,44 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata) {\n             cacheNotifier.notifyCacheEntryExpired(key, value, metadata, null)));\n    }\n \n-   protected Long localLastAccess(Object key, Object value, int segment) {\n-      InternalCacheEntry ice = dataContainer.running().peek(segment, key);\n-      if (ice != null && (value == null || value.equals(ice.getValue())) &&\n-            !ice.isExpired(timeService.wallClockTime())) {\n-         return ice.getLastUsed();\n+   @Override\n+   public CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> ice, int segment, boolean isWrite) {\n+      long currentTime = timeService.wallClockTime();\n+      if (ice.isExpired(currentTime)) {\n+         if (trace) {\n+            log.tracef(\"Retrieved entry for key %s was expired locally, attempting expiration removal\", ice.getKey());\n+         }\n+         CompletableFuture<Boolean> expiredStage = entryExpiredInMemory(ice, currentTime, isWrite);\n+         if (trace) {\n+            expiredStage = expiredStage.thenApply(expired -> {\n+               if (expired == Boolean.FALSE) {\n+                  log.tracef(\"Retrieved entry for key %s was found to not be expired.\", ice.getKey());\n+               } else {\n+                  log.tracef(\"Retrieved entry for key %s was confirmed to be expired.\", ice.getKey());\n+               }\n+               return expired;\n+            });\n+         }\n+         return expiredStage;\n+      } else if (!isWrite && ice.canExpireMaxIdle()) {\n+         return touchEntryAndReturnIfExpired(ice, segment);\n       }\n-      return null;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long lastAccess = localLastAccess(key, value, segment);\n-      if (lastAccess != null) {\n-         return CompletableFuture.completedFuture(lastAccess);\n-      }\n-      return CompletableFutures.completedNull();\n+   /**\n+    * Response is whether the value should be treated as expired - thus if both local and remote were able to touch", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNTUxNQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365935515", "bodyText": "I prefer saying a stage that will complete with {@code true} if the entry was expired and {@code false} otherwise.\nAlso duplicated in the main comment (The return stage will contain whether the entry was actually expired or not)", "author": "danberindei", "createdAt": "2020-01-13T17:39:47Z", "path": "core/src/main/java/org/infinispan/expiration/impl/InternalExpirationManager.java", "diffHunk": "@@ -74,14 +74,12 @@ default void handleInStoreExpiration(MarshallableEntry<K, V> marshalledEntry) {\n    }\n \n    /**\n-    * Retrieves the last access time for the given key in the data container if it is using max idle.\n-    * If the entry is not in the container or it is expired it will return null.\n-    * If the entry is present but cannot expire via max idle, it will return -1\n-    * If the entry is present and can expire via max idle but hasn't it will return a number > 0\n-    * @param key the key to retrieve the access time for\n-    * @param value the value to match if desired (this can be null)\n-    * @param segment the segment for the given key\n-    * @return the last access time if available\n+    * Handles processing for an entry that may be expired. This will remove the entry if it is expired, otherwise may\n+    * touch if it uses max idle. The return stage will contain whether the entry was actually expired or not\n+    * @param entry entry that may be expired\n+    * @param segment the segment of the entry\n+    * @param isWrite whether the command that saw the expired value was a write or not\n+    * @return a stage that when complete will return if the entry was expired", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNzI0NA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365937244", "bodyText": "can suggests to me that it is parametrized and can do each independently. I'd rather say\nThis command updates a cache entry's last access timestamp. If eviction is enabled, it will also update the recency information.", "author": "danberindei", "createdAt": "2020-01-13T17:43:23Z", "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.expiration.impl;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.infinispan.commands.InitializableCommand;\n+import org.infinispan.commands.TopologyAffectedCommand;\n+import org.infinispan.commands.remote.BaseRpcCommand;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.distribution.DistributionInfo;\n+import org.infinispan.distribution.DistributionManager;\n+import org.infinispan.distribution.LocalizedCacheTopology;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.statetransfer.OutdatedTopologyException;\n+import org.infinispan.util.ByteString;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+/**\n+ * This command can be invoked to update a cache entry's recent access. This can involve updating its last access", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNzk1OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365937959", "bodyText": "I think you can answer the question now :)", "author": "danberindei", "createdAt": "2020-01-13T17:44:50Z", "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.expiration.impl;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.infinispan.commands.InitializableCommand;\n+import org.infinispan.commands.TopologyAffectedCommand;\n+import org.infinispan.commands.remote.BaseRpcCommand;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.distribution.DistributionInfo;\n+import org.infinispan.distribution.DistributionManager;\n+import org.infinispan.distribution.LocalizedCacheTopology;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.statetransfer.OutdatedTopologyException;\n+import org.infinispan.util.ByteString;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+/**\n+ * This command can be invoked to update a cache entry's recent access. This can involve updating its last access\n+ * with max idle as well as recent eviction access times.\n+ * <p>\n+ * This command returns a Boolean that is whether this command was able to touch the value or not.\n+ */\n+public class TouchCommand extends BaseRpcCommand implements InitializableCommand, TopologyAffectedCommand {\n+   public static final byte COMMAND_ID = 66;\n+\n+   private Object key;\n+   private int segment;\n+   private int topologyId = -1;\n+\n+   private InternalDataContainer internalDataContainer;\n+   private TimeService timeService;\n+   private DistributionManager distributionManager;\n+\n+   // Only here for CommandIdUniquenessTest\n+   private TouchCommand() { super(null); }\n+\n+   public TouchCommand(ByteString cacheName) {\n+      super(cacheName);\n+   }\n+\n+   public TouchCommand(ByteString cacheName, Object key, int segment) {\n+      super(cacheName);\n+      this.key = key;\n+      this.segment = segment;\n+   }\n+\n+   @Override\n+   public byte getCommandId() {\n+      return COMMAND_ID;\n+   }\n+\n+   @Override\n+   public boolean isReturnValueExpected() {\n+      return true;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      output.writeObject(key);\n+      UnsignedNumeric.writeUnsignedInt(output, segment);\n+   }\n+\n+   @Override\n+   public void readFrom(ObjectInput input) throws IOException, ClassNotFoundException {\n+      key = input.readObject();\n+      segment = UnsignedNumeric.readUnsignedInt(input);\n+   }\n+\n+   @Override\n+   public void init(ComponentRegistry componentRegistry, boolean isRemote) {\n+      internalDataContainer = componentRegistry.getInternalDataContainer().running();\n+      timeService = componentRegistry.getTimeService();\n+      // Invalidation cache doesn't set topology id - so we don't want to throw OTE in invokeAsync\n+      if (!componentRegistry.getConfiguration().clustering().cacheMode().isInvalidation()) {\n+         distributionManager = componentRegistry.getDistributionManager();\n+      }\n+   }\n+\n+   @Override\n+   public int getTopologyId() {\n+      return topologyId;\n+   }\n+\n+   @Override\n+   public void setTopologyId(int topologyId) {\n+      this.topologyId = topologyId;\n+   }\n+\n+   @Override\n+   public CompletableFuture<Object> invokeAsync() {\n+      boolean touched = internalDataContainer.touch(segment, key, timeService.wallClockTime());\n+      // Hibernate currently disables clustered expiration manager, which means we can have a topology id of -1\n+      // when using a clustered cache mode\n+      if (distributionManager != null && topologyId != -1) {\n+         LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+         int currentTopologyId = lct.getTopologyId();\n+         if (currentTopologyId != topologyId) {\n+            return CompletableFutures.completedExceptionFuture(OutdatedTopologyException.RETRY_NEXT_TOPOLOGY);\n+         }\n+         DistributionInfo di = lct.getSegmentDistribution(segment);\n+         // If our node is a write owner but not read owner, that means we may not have the value yet - so we just\n+         // say we were touched anyways\n+         // TODO: is this is an issue with concurrent state response and not touching the new value?", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}