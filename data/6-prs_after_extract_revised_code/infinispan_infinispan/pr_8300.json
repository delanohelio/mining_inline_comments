{"pr_number": 8300, "pr_title": "ISPN-10446 Protobuf resource", "pr_createdAt": "2020-05-09T13:08:55Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8300", "timeline": [{"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "url": "https://github.com/infinispan/infinispan/commit/a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "message": "ISPN-10446 Protobuf Schema endpoint doc", "committedDate": "2020-05-11T22:05:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NDMwMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423564300", "bodyText": "This lookup should be done in the constructor, as it does not depend on the request: we are always returning in the same format", "author": "gustavonalle", "createdAt": "2020-05-12T08:42:44Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1NzcyOA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423857728", "bodyText": "it does depend when authz is enabled with the subject ...", "author": "karesti", "createdAt": "2020-05-12T16:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NDMwMA=="}], "type": "inlineReview", "revised_code": {"commit": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex 17b1f512d5..2509f6c7ab 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -1,12 +1,15 @@\n package org.infinispan.rest.resources;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODY4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423568685", "bodyText": "This should be non-blocking. I reckon it should be similar to \n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 221\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           return Flowable.fromIterable(cachesHealth.entrySet()) \n        \n    \n  \n\n or at least wrap it in an executor", "author": "gustavonalle", "createdAt": "2020-05-12T08:49:00Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NzMyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424257325", "bodyText": "done", "author": "karesti", "createdAt": "2020-05-13T08:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMTYzNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424411636", "bodyText": "This is not fixed yet. It needs to be done using the blocking executor, because this cache is persisted. To be honest (not for this PR) the server/rest module needs blockhound added to find these automatically.", "author": "wburns", "createdAt": "2020-05-13T12:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODY4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex 17b1f512d5..2509f6c7ab 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -1,12 +1,15 @@\n package org.infinispan.rest.resources;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzMyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423577325", "bodyText": "The REST server should return code 204 (HttpResponseStatus.NO_CONTENT) for POST without a response body", "author": "gustavonalle", "createdAt": "2020-05-12T09:01:58Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwMjg5Mg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424402892", "bodyText": "I have changed this dealing POST and PUT (create and update)", "author": "karesti", "createdAt": "2020-05-13T12:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzMyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex 17b1f512d5..2509f6c7ab 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -1,12 +1,15 @@\n package org.infinispan.rest.resources;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3Nzg1NA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423577854", "bodyText": "No need to return a body if the validation is success: it should simply return code 204 (see above)", "author": "gustavonalle", "createdAt": "2020-05-12T09:02:50Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);\n+      return cache.putAsync(schemaName, contents.asString())\n+            .thenCompose(r -> cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX))\n+            .thenApply(validationError -> {\n+               String validation = \"success\";", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex 17b1f512d5..2509f6c7ab 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -1,12 +1,15 @@\n package org.infinispan.rest.resources;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MDE1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423580153", "bodyText": "It'd be better to report errors in the same format as other resources. This is how query reports it:\n{\n    \"error\":{\n        \"message\":\"Invalid search request\",\n        \"cause\":\"org.infinispan.ParseException...\"\n    }\n}\nmessage is a user friendly description of the error and cause is the output of exception.stackTrace() where applicable.\nThere is already the class org.infinispan.query.remote.json.JsonQueryErrorResult for this format, I think we should move it to the rest module and reuse for non-query resources", "author": "gustavonalle", "createdAt": "2020-05-12T09:06:24Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);\n+      return cache.putAsync(schemaName, contents.asString())\n+            .thenCompose(r -> cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX))\n+            .thenApply(validationError -> {\n+               String validation = \"success\";\n+               if(validationError != null) {\n+                  validation = validationError.toString();\n+                  builder.status(HttpResponseStatus.BAD_REQUEST);\n+               }\n+               String json = String.format(\"{validation:%s}\", validation);", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMTUyNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424411526", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-13T12:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MDE1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex 17b1f512d5..2509f6c7ab 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -1,12 +1,15 @@\n package org.infinispan.rest.resources;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MzcxMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423583710", "bodyText": "Nitpick: \"accept\" header is not used in PUT requests", "author": "gustavonalle", "createdAt": "2020-05-12T09:12:02Z", "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.Test;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   public void getEmptySchemas() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(\"[ ]\", jsonNode.toPrettyString());\n+   }\n+\n+   @Test\n+   public void getNotFoundProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/error\")\n+            .content(new StringContentProvider(errorProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "chunk": "diff --git a/server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java b/server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java\nindex 31492bc6d1..fe390260d6 100644\n--- a/server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java\n+++ b/server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java\n\n@@ -5,9 +5,16 @@\n import org.eclipse.jetty.client.api.ContentResponse;\n import org.eclipse.jetty.client.util.StringContentProvider;\n import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.BeforeMethod;\n import org.testng.annotations.Test;\n \n+import javax.security.auth.Subject;\n+import java.security.PrivilegedAction;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n import static org.infinispan.commons.util.Util.getResourceAsString;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NDA3MA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423584070", "bodyText": ".accept can be removed", "author": "gustavonalle", "createdAt": "2020-05-12T09:12:37Z", "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.Test;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   public void getEmptySchemas() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(\"[ ]\", jsonNode.toPrettyString());\n+   }\n+\n+   @Test\n+   public void getNotFoundProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/error\")\n+            .content(new StringContentProvider(errorProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      String validation = \"java.lang.IllegalStateException:\"\n+            + \" Syntax error in error.proto at 3:8: unexpected label: messoge\";\n+\n+      ResponseAssertion.assertThat(response).isBadRequest();\n+      ResponseAssertion.assertThat(response).hasReturnedText(\"{validation:\" + validation + \"}\");\n+\n+      checkListProtobufEndpointUrl(\"error.proto\", validation);\n+   }\n+\n+   @Test\n+   public void crudCorrectProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1ODgwNA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424258804", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-13T08:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NDA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "chunk": "diff --git a/server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java b/server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java\nindex 31492bc6d1..fe390260d6 100644\n--- a/server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java\n+++ b/server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java\n\n@@ -5,9 +5,16 @@\n import org.eclipse.jetty.client.api.ContentResponse;\n import org.eclipse.jetty.client.util.StringContentProvider;\n import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.BeforeMethod;\n import org.testng.annotations.Test;\n \n+import javax.security.auth.Subject;\n+import java.security.PrivilegedAction;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n import static org.infinispan.commons.util.Util.getResourceAsString;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NzQ1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423587451", "bodyText": "PUT and POST should have different behaviours:  POST will return CONFLICT if the entity with the same name already exists, while PUT will replace the entity. Take a look at how the CacheResource handles both methods:\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/BaseCacheResource.java\n    \n    \n         Line 82\n      in\n      6d78de6\n    \n    \n    \n    \n\n        \n          \n           CompletionStage<RestResponse> putValueToCache(RestRequest request) { \n        \n    \n  \n\n\nWe should either discern between the two verbs, or support just the PUT", "author": "gustavonalle", "createdAt": "2020-05-12T09:17:55Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMTYyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424411629", "bodyText": "I'm doing this", "author": "karesti", "createdAt": "2020-05-13T12:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NzQ1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex 17b1f512d5..2509f6c7ab 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -1,12 +1,15 @@\n package org.infinispan.rest.resources;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4OTIyNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423589227", "bodyText": "I am conflicted between /v2/protobuf or /v2/schema for the REST endpoint path. WDYT @anistor?", "author": "gustavonalle", "createdAt": "2020-05-12T09:20:34Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5NzYwMw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423597603", "bodyText": "@gustavonalle I know the question isn't for me but I'd be in favour of /v2/schema for consistency with the CLI as that is the command you use to upload .proto files.", "author": "oraNod", "createdAt": "2020-05-12T09:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4OTIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwOTcwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423609705", "bodyText": "Allright!!!", "author": "karesti", "createdAt": "2020-05-12T09:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4OTIyNw=="}], "type": "inlineReview", "revised_code": {"commit": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex 17b1f512d5..2509f6c7ab 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -1,12 +1,15 @@\n package org.infinispan.rest.resources;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n"}}, {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "url": "https://github.com/infinispan/infinispan/commit/5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "message": "ISPN-10446 Protobuf Schema endpoint doc", "committedDate": "2020-05-13T22:00:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424954224", "bodyText": "@wburns this is not ok ?", "author": "karesti", "createdAt": "2020-05-14T08:19:50Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "originalCommit": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMDE4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425110189", "bodyText": "No, unfortunately the iterator returned from cache.entrySet() is blocking. This is why normally the ClusterPublisher is used as it allows for non blocking \"iteration\". But unfortunately without the new API, there is no easy way to do it with media type conversions.\nI think the simplest way for now is just to delegate this call to the blocking thread pool.", "author": "wburns", "createdAt": "2020-05-14T12:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMDU4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425110586", "bodyText": "That is unless the PROTOBUF_METADATA_CACHE_NAME cache doesn't do any media type conversions, then you can just use the ClusterPublisherManager directly.", "author": "wburns", "createdAt": "2020-05-14T12:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMzE2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425113161", "bodyText": "ClusterPublisherManager does not work with EncoderCache instances?", "author": "gustavonalle", "createdAt": "2020-05-14T12:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMzgxMg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425113812", "bodyText": "It is not exposed via an EncoderCache in any way. It is solely a component currently.", "author": "wburns", "createdAt": "2020-05-14T12:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNTYxNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425115616", "bodyText": "The problem is I was expecting to effectively expose this from the new API, so I didn't add anything for out internal use. Maybe we should add an internal method only somewhere. The issue with ClusterPublisherManager is that the API of it is probably unwieldy to power users and we normally hide a lot of that from the user.", "author": "wburns", "createdAt": "2020-05-14T12:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNTk0MQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425115941", "bodyText": "So this one should be changed as well?\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 221\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           return Flowable.fromIterable(cachesHealth.entrySet())", "author": "gustavonalle", "createdAt": "2020-05-14T12:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNjYzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425116635", "bodyText": "So this one should be changed as well?\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 221\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           return Flowable.fromIterable(cachesHealth.entrySet()) \n        \n    \n  \n\n\n\nI have to check the cachesHealth configuration. If it can be distributed or have a store, then yes it needs to be changed.", "author": "wburns", "createdAt": "2020-05-14T13:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNzE4Nw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425117187", "bodyText": "Oh actually cachesHealth is just a HashMap :) However, \n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 214\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           cacheNames.removeAll(internalCacheRegistry.getInternalCacheNames()); \n        \n    \n  \n\n can block as mentioned in the comment.", "author": "wburns", "createdAt": "2020-05-14T13:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNzM5Ng==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425117396", "bodyText": "As I mentioned if we add blockhound to server/rest we won't have to conjecture about these and it will just fail the test if it blocks :)", "author": "wburns", "createdAt": "2020-05-14T13:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUwNDU0OA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425504548", "bodyText": "Check out #8323", "author": "wburns", "createdAt": "2020-05-15T00:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}], "type": "inlineReview", "revised_code": {"commit": "e1840b65f3b8a36d580ed1b39f6b7b4df67ab906", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex 2509f6c7ab..b24059e5bc 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -9,7 +9,6 @@\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n-import org.infinispan.query.remote.json.JsonQueryErrorResult;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n"}}, {"oid": "e1840b65f3b8a36d580ed1b39f6b7b4df67ab906", "url": "https://github.com/infinispan/infinispan/commit/e1840b65f3b8a36d580ed1b39f6b7b4df67ab906", "message": "ISPN-10446 Protobuf Schema Resource docs", "committedDate": "2020-05-14T08:25:39Z", "type": "forcePushed"}, {"oid": "f3fcdcae4b986f3179ef1336635cc43558d6d91f", "url": "https://github.com/infinispan/infinispan/commit/f3fcdcae4b986f3179ef1336635cc43558d6d91f", "message": "ISPN-10446 Protobuf Schema Resource docs", "committedDate": "2020-05-15T08:22:57Z", "type": "forcePushed"}, {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589", "url": "https://github.com/infinispan/infinispan/commit/76cff2bac32cd828189959a2fa2caddd2b478589", "message": "ISPN-10446 Protobuf Schema Resource docs", "committedDate": "2020-05-15T14:00:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDY1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425940655", "bodyText": "Nitpick: extra spaces.", "author": "wburns", "createdAt": "2020-05-15T17:17:28Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MTc3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426571775", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T11:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MzUzNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425943537", "bodyText": "I find .collect(Collectors.toSet()) is more succinct.", "author": "wburns", "createdAt": "2020-05-15T17:23:28Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MTQzNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426571437", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T11:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MzUzNw=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjEwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946105", "bodyText": "This is another blocking call here. Unfortunately, the more I look at this it should really be done using BlockingManager#blockingPublisher on the Flowable.fromIterable(cache.entrySet()) and then doing non blocking calls aftwerds.", "author": "wburns", "createdAt": "2020-05-15T17:28:25Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MDkyNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425960927", "bodyText": "But I guess we can leave this as is for now. This whole chunk will need to be redone to use a ClusterPublisher at some point anyways.", "author": "wburns", "createdAt": "2020-05-15T17:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjEwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjM1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946359", "bodyText": "It appears we are never using the value, so just cache.keySet() should be good.", "author": "wburns", "createdAt": "2020-05-15T17:28:56Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4MTEzMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426581130", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T12:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjM1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjQ3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946479", "bodyText": "This seems a bit odd that we are collecting into a Set to then sort and then collect it into a List. can we not just use http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Flowable.html#sorted-java.util.Comparator- and then collect that into a List that is finally mapped to the response?", "author": "wburns", "createdAt": "2020-05-15T17:29:11Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4MzgzMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426583830", "bodyText": "yes", "author": "karesti", "createdAt": "2020-05-18T12:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjQ3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjU4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946589", "bodyText": "Nitpick: extra spaces.", "author": "wburns", "createdAt": "2020-05-15T17:29:24Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946917", "bodyText": "I am not sure how error handling is done on the rest side, but when returning a CompletionStage, I would normally expect this exception to be in the Stage.", "author": "wburns", "createdAt": "2020-05-15T17:30:04Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4NTY0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426585647", "bodyText": "the exception is catchd in the BaseHttpRequestHandler\nI'm following other examples\nwe should maybe talk about the overral design on this ?", "author": "karesti", "createdAt": "2020-05-18T12:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5ODUyMw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426698523", "bodyText": "Sorry I don't see how BaseHttpRequestHandler can be possibly handling this. The handleError is only invoked from 2 places checking CompletionStage results. If a method can return a CompletionStage, it should not be throwing an exception that is from user input. It should only be from bugs in our code.", "author": "wburns", "createdAt": "2020-05-18T15:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNjAwNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426706006", "bodyText": "It is caught at RestDispatcherImpl#dispatch btw.", "author": "wburns", "createdAt": "2020-05-18T15:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNzY2MA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426707660", "bodyText": "can we deal this in another PR and talk about it with @gustavonalle ? because I'm not adding anything new and IMO this is another PR more global subject", "author": "karesti", "createdAt": "2020-05-18T15:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwODQ4Mw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426708483", "bodyText": "So I guess this code is okay, however it smells to me as we talked before at the F2F when the return type of a method is CompletionStage that any exceptions an invoker should be able to receive should be encapsulated in the Stage.", "author": "wburns", "createdAt": "2020-05-18T15:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0MTIzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426741231", "bodyText": "BaseHttpRequestHandler#handleError should handle uncaught exceptions from the resources, and also log it\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/BaseHttpRequestHandler.java\n    \n    \n         Line 33\n      in\n      1f25924\n    \n    \n    \n    \n\n        \n          \n           getLogger().errorWhileResponding(responseException); \n        \n    \n  \n\n\nCould you please open a separate JIRA on how to align the error handling with what was discussed?", "author": "gustavonalle", "createdAt": "2020-05-18T16:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc1ODEzNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426758137", "bodyText": "is this JIRA not enough ? https://issues.redhat.com/browse/ISPN-11853", "author": "karesti", "createdAt": "2020-05-18T16:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzQyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425947421", "bodyText": "CompletableFutures.completedNull() instead.", "author": "wburns", "createdAt": "2020-05-15T17:31:02Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4NjM3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426586375", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T12:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzQyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzU2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425947561", "bodyText": "Nitpick: spacing on if blocks are missing here and a few below.", "author": "wburns", "createdAt": "2020-05-15T17:31:21Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4NTkzOA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426585938", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T12:24:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzU2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjE1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425952152", "bodyText": "Util.EMPTY_BYTE_ARRAY", "author": "wburns", "createdAt": "2020-05-15T17:40:20Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3ODcyMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426578720", "bodyText": "k", "author": "karesti", "createdAt": "2020-05-18T12:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjE1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425952404", "bodyText": "Do we want to at least log the exception?", "author": "wburns", "createdAt": "2020-05-15T17:40:50Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MzE3NA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426573174", "bodyText": "I change this launching an exception, but should not be happening\nit's uneven across resources now, sometimes we launch a throw new RestResponseException(e); and others just catch", "author": "karesti", "createdAt": "2020-05-18T12:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NTU2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426695569", "bodyText": "I understand that different failures may be propagated. But I think we should at least log an exception instead of just catching it and making it impossible to debug.", "author": "wburns", "createdAt": "2020-05-18T15:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNDA1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426704059", "bodyText": "And sorry the previous code doing this should at least log the error as a trace as well. We should not be swallowing exceptions, except for in very rare cases (especially when we can be reporting an error to the user).", "author": "wburns", "createdAt": "2020-05-18T15:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwOTI1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426709251", "bodyText": "there is a global issue concerning logging in the REST resources.\nCan we discuss this too with @gustavonalle so we can do some follow up PR on error handling and logging strategy, please?", "author": "karesti", "createdAt": "2020-05-18T15:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMTc4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426711782", "bodyText": "There is an error JSON document to report errors, the query endpoint is using it", "author": "gustavonalle", "createdAt": "2020-05-18T15:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMzEyMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426713120", "bodyText": "Some endpoints are not implementing this to handle JsonProcessingException as it is very unlikely (impossible?) this error would be thrown since the JSON is mapped via Jackson based on always the same class", "author": "gustavonalle", "createdAt": "2020-05-18T15:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMzA2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426733069", "bodyText": "I don't think just adding a single trace message needs another PR... And I have heard many a developer say something is very unlikely to impossible, including myself, and it ends up  happening. So I would rather have at least a trace message when I am completely ignoring a checked Exception.", "author": "wburns", "createdAt": "2020-05-18T16:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0MzQ4OA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426743488", "bodyText": "Ok, I agree adding log won't hurt  \ud83d\ude04", "author": "gustavonalle", "createdAt": "2020-05-18T16:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzcwMw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425953703", "bodyText": "Unfortunately this isn't quite a record class. Please make a constructor with final fields.", "author": "wburns", "createdAt": "2020-05-15T17:43:22Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return builder.contentType(APPLICATION_JSON).entity(detailsResponse).build();\n+               } else {\n+                  return builder.build();\n+               }\n+            });\n+   }\n+\n+   private boolean isOkOrCreated(NettyRestResponse.Builder builder) {\n+      return builder.getHttpStatus() == HttpResponseStatus.CREATED || builder.getHttpStatus() == HttpResponseStatus.OK;\n+   }\n+\n+   private CompletionStage<RestResponse> getSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      return restCacheManager.getPrivilegedInternalEntry(cache, schemaName, true).thenApply(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         if(entry == null) {\n+            responseBuilder.status(HttpResponseStatus.NOT_FOUND.code());\n+         } else {\n+            responseBuilder.status(HttpResponseStatus.OK.code());\n+            responseBuilder.contentType(MediaType.TEXT_PLAIN);\n+            responseBuilder.entity(entry.getValue());\n+         }\n+         return responseBuilder.build();\n+      });\n+   }\n+\n+   private CompletionStage<RestResponse> deleteSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      AdvancedCache<Object, Object> protobufCache = restCacheManager.getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return restCacheManager.getPrivilegedInternalEntry(protobufCache, schemaName, true).thenCompose(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         responseBuilder.status(HttpResponseStatus.NOT_FOUND);\n+\n+         if (entry instanceof InternalCacheEntry) {\n+               responseBuilder.status(HttpResponseStatus.NO_CONTENT.code());\n+               return restCacheManager.remove(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, schemaName,\n+                     MediaType.MATCH_ALL, request)\n+                     .thenApply(v -> responseBuilder.build());\n+         }\n+         return CompletableFuture.completedFuture(responseBuilder.build());\n+      });\n+   }\n+\n+   private ValidationError createErrorContent(String schemaName, String cause) {\n+      String message = \"Schema \" + schemaName + \" has errors\";\n+      ValidationError validationError = new ValidationError();\n+      validationError.message = message;\n+      validationError.cause = cause;\n+      return validationError;\n+   }\n+\n+   private String checkMandatorySchemaName(RestRequest request) {\n+      String schemaName = request.variables().get(\"schemaName\");\n+      if (schemaName == null)\n+         throw new NoKeyException(\"schemaName\");\n+      return schemaName.endsWith(ProtobufMetadataManager.PROTO_KEY_SUFFIX) ? schemaName : schemaName + ProtobufMetadataManager.PROTO_KEY_SUFFIX;\n+   }\n+\n+   static class ValidationError {", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MDA4NA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425960084", "bodyText": "Or does Jackson not like that?", "author": "wburns", "createdAt": "2020-05-15T17:55:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3NzcxNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426577716", "bodyText": "all the other classes are done like this and I recall it is related", "author": "karesti", "createdAt": "2020-05-18T12:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzcwMw=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NDEyMw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425954123", "bodyText": "Same here re: final and constructor.", "author": "wburns", "createdAt": "2020-05-15T17:44:12Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return builder.contentType(APPLICATION_JSON).entity(detailsResponse).build();\n+               } else {\n+                  return builder.build();\n+               }\n+            });\n+   }\n+\n+   private boolean isOkOrCreated(NettyRestResponse.Builder builder) {\n+      return builder.getHttpStatus() == HttpResponseStatus.CREATED || builder.getHttpStatus() == HttpResponseStatus.OK;\n+   }\n+\n+   private CompletionStage<RestResponse> getSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      return restCacheManager.getPrivilegedInternalEntry(cache, schemaName, true).thenApply(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         if(entry == null) {\n+            responseBuilder.status(HttpResponseStatus.NOT_FOUND.code());\n+         } else {\n+            responseBuilder.status(HttpResponseStatus.OK.code());\n+            responseBuilder.contentType(MediaType.TEXT_PLAIN);\n+            responseBuilder.entity(entry.getValue());\n+         }\n+         return responseBuilder.build();\n+      });\n+   }\n+\n+   private CompletionStage<RestResponse> deleteSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      AdvancedCache<Object, Object> protobufCache = restCacheManager.getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return restCacheManager.getPrivilegedInternalEntry(protobufCache, schemaName, true).thenCompose(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         responseBuilder.status(HttpResponseStatus.NOT_FOUND);\n+\n+         if (entry instanceof InternalCacheEntry) {\n+               responseBuilder.status(HttpResponseStatus.NO_CONTENT.code());\n+               return restCacheManager.remove(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, schemaName,\n+                     MediaType.MATCH_ALL, request)\n+                     .thenApply(v -> responseBuilder.build());\n+         }\n+         return CompletableFuture.completedFuture(responseBuilder.build());\n+      });\n+   }\n+\n+   private ValidationError createErrorContent(String schemaName, String cause) {\n+      String message = \"Schema \" + schemaName + \" has errors\";\n+      ValidationError validationError = new ValidationError();\n+      validationError.message = message;\n+      validationError.cause = cause;\n+      return validationError;\n+   }\n+\n+   private String checkMandatorySchemaName(RestRequest request) {\n+      String schemaName = request.variables().get(\"schemaName\");\n+      if (schemaName == null)\n+         throw new NoKeyException(\"schemaName\");\n+      return schemaName.endsWith(ProtobufMetadataManager.PROTO_KEY_SUFFIX) ? schemaName : schemaName + ProtobufMetadataManager.PROTO_KEY_SUFFIX;\n+   }\n+\n+   static class ValidationError {\n+      public String message;\n+      public String cause;\n+   }\n+   static class ProtoSchema {", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425959905", "bodyText": "Nitpick: Might as well put it on the line above to save some indention.", "author": "wburns", "createdAt": "2020-05-15T17:55:27Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3ODQ0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426578447", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T12:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NjUwMw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426696503", "bodyText": "This wasn't updated?", "author": "wburns", "createdAt": "2020-05-18T15:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwODE0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426708142", "bodyText": "it was, but maybe I understood wrong what you meant by indention", "author": "karesti", "createdAt": "2020-05-18T15:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMzQ1MA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426713450", "bodyText": "ok now I got it", "author": "karesti", "createdAt": "2020-05-18T15:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex d783aa651d..4ecbddd38a 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -6,11 +6,13 @@\n import io.reactivex.rxjava3.core.Flowable;\n import org.infinispan.AdvancedCache;\n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n import org.infinispan.container.entries.InternalCacheEntry;\n import org.infinispan.query.remote.ProtobufMetadataManager;\n import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n import org.infinispan.rest.cachemanager.RestCacheManager;\n import org.infinispan.rest.framework.ContentSource;\n import org.infinispan.rest.framework.ResourceHandler;\n"}}, {"oid": "2fe5ecd91149890924a4f7dfe286a17608f9b185", "url": "https://github.com/infinispan/infinispan/commit/2fe5ecd91149890924a4f7dfe286a17608f9b185", "message": "ISPN-10446 Protobuf Schema Resource docs", "committedDate": "2020-05-18T11:54:28Z", "type": "forcePushed"}, {"oid": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "url": "https://github.com/infinispan/infinispan/commit/c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-18T12:12:58Z", "type": "forcePushed"}, {"oid": "84f7a2ae2908befdcf8d86ed2bec21f139fd06ed", "url": "https://github.com/infinispan/infinispan/commit/84f7a2ae2908befdcf8d86ed2bec21f139fd06ed", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-18T12:25:42Z", "type": "forcePushed"}, {"oid": "c1b6422ae172d82d06ee66cbc4d8027ede610440", "url": "https://github.com/infinispan/infinispan/commit/c1b6422ae172d82d06ee66cbc4d8027ede610440", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-18T15:36:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMjA1OA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426732058", "bodyText": "This is more like what I would expect. However you didn't fix the indentation on the following lines as they can all now be moved 3 spaces to the left. Or however IntelliJ says the formatter wants :)", "author": "wburns", "createdAt": "2020-05-18T15:58:35Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+      return putSchema.thenCompose(r -> {", "originalCommit": "c1b6422ae172d82d06ee66cbc4d8027ede610440", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2MTUxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426761511", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T16:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMjA1OA=="}], "type": "inlineReview", "revised_code": {"commit": "2f8f983aa6ed9ebc9be583903a7b0f292b4ce285", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex 41b8a5087a..76de532e5f 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -142,7 +142,6 @@ public Invocations getInvocations() {\n                   protoSchema.name = schemaName;\n                   if(validationError != null) {\n                      protoSchema.error = createErrorContent(schemaName, (String) validationError);\n-                     builder.status(HttpResponseStatus.BAD_REQUEST);\n                   }\n                   byte[] detailsResponse = Util.EMPTY_BYTE_ARRAY;\n                   try {\n"}}, {"oid": "2f8f983aa6ed9ebc9be583903a7b0f292b4ce285", "url": "https://github.com/infinispan/infinispan/commit/2f8f983aa6ed9ebc9be583903a7b0f292b4ce285", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-18T16:36:29Z", "type": "forcePushed"}, {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "url": "https://github.com/infinispan/infinispan/commit/c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-18T16:46:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMzIwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427113209", "bodyText": "We need to rename this to /v2/schemas to conform with the other resources:\n/v2/counters/, /v2/caches/, /v2/tasks and so on.\n@oraNod also need to change all the doc references", "author": "gustavonalle", "createdAt": "2020-05-19T08:15:06Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)", "originalCommit": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MDYwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427170605", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-19T09:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMzIwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "97b1a46f3c2e3dc4354279def36838ff97bb58da", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex 3b7215b3b0..a2ba3344d1 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -54,11 +54,11 @@ public ProtobufResource(InvocationHelper invocationHelper) {\n    public Invocations getInvocations() {\n       return new Invocations.Builder()\n             // Key related operations\n-            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n-            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n-            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n-            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n-            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .invocation().methods(GET).path(\"/v2/schemas\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schemas/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schemas/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schemas/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schemas/{schemaName}\").handleWith(this::deleteSchema)\n             .create();\n    }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427118544", "bodyText": "This will cause a PUT for a totally new schema to return 404...\nPUT should create the schema if it does not exist or replace if it already exists.", "author": "gustavonalle", "createdAt": "2020-05-19T08:23:35Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);", "originalCommit": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2ODk2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427168962", "bodyText": "but if someone has deleted the schema and you are creating it at the same time again ?", "author": "karesti", "createdAt": "2020-05-19T09:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MDAzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427170031", "bodyText": "? You mean concurrent requests, one with PUT and another with DELETE?", "author": "gustavonalle", "createdAt": "2020-05-19T09:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4MDQ4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427180485", "bodyText": "for me you use POST to create a total new schema. And then put to modify schemas. this way the action from the user is clear. if you try to modify an already existing schema but the schema does not exist anymore, you get to know", "author": "karesti", "createdAt": "2020-05-19T10:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NTMzMg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427185332", "bodyText": "nope, PUT should be like AddOrReplace", "author": "gustavonalle", "createdAt": "2020-05-19T10:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NTg1MA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427185850", "bodyText": "More info: https://tools.ietf.org/html/rfc2616#page-55", "author": "gustavonalle", "createdAt": "2020-05-19T10:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}], "type": "inlineReview", "revised_code": {"commit": "97b1a46f3c2e3dc4354279def36838ff97bb58da", "chunk": "diff --git a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\nindex 3b7215b3b0..a2ba3344d1 100644\n--- a/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n+++ b/server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java\n\n@@ -54,11 +54,11 @@ public ProtobufResource(InvocationHelper invocationHelper) {\n    public Invocations getInvocations() {\n       return new Invocations.Builder()\n             // Key related operations\n-            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n-            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n-            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n-            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n-            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .invocation().methods(GET).path(\"/v2/schemas\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schemas/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schemas/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schemas/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schemas/{schemaName}\").handleWith(this::deleteSchema)\n             .create();\n    }\n \n"}}, {"oid": "97b1a46f3c2e3dc4354279def36838ff97bb58da", "url": "https://github.com/infinispan/infinispan/commit/97b1a46f3c2e3dc4354279def36838ff97bb58da", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-19T10:02:52Z", "type": "forcePushed"}, {"oid": "eecbb918fa56160b1f49d3d775065d8f27766f9a", "url": "https://github.com/infinispan/infinispan/commit/eecbb918fa56160b1f49d3d775065d8f27766f9a", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-19T15:39:01Z", "type": "forcePushed"}, {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c", "url": "https://github.com/infinispan/infinispan/commit/65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-19T15:39:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNTgzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427415831", "bodyText": "Should change the name of this method (and updateNonExistingSchema) considering that PUT now means \"create or update\". I'd just replace update with put.", "author": "danberindei", "createdAt": "2020-05-19T15:58:53Z", "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.security.auth.Subject;\n+import java.security.PrivilegedAction;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   @BeforeMethod(alwaysRun = true)\n+   @Override\n+   public void createBeforeMethod() {\n+      //Clear schema cache to avoid conflicts between methods\n+      Subject.doAs(ADMIN_USER, (PrivilegedAction<Void>) () -> {\n+         cacheManagers.get(0).getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME).clear();\n+         return null;\n+      });\n+   }\n+\n+   public void listSchemasWhenEmpty() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(0, jsonNode.size());\n+   }\n+\n+   @Test\n+   public void getNotExistingSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void updateNonExistingSchema() throws Exception {\n+      String person = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = updateSchema(\"person\", person);\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = addSchema(\"error\", errorProto);\n+\n+      String cause = \"java.lang.IllegalStateException:\"\n+            + \" Syntax error in error.proto at 3:8: unexpected label: messoge\";\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContent());\n+      assertEquals(\"error.proto\", jsonNode.get(\"name\").asText());\n+      assertEquals(\"Schema error.proto has errors\", jsonNode.get(\"error\").get(\"message\").asText());\n+      assertEquals(cause, jsonNode.get(\"error\").get(\"cause\").asText());\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/error\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"error.proto\");\n+\n+      checkListProtobufEndpointUrl(\"error.proto\", cause);\n+   }\n+\n+   @Test\n+   public void crudSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      // Create\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(\"null\", jsonNode.get(\"error\").asText());\n+\n+      // Read\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/person.proto\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Update\n+      response = updateSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      // Delete\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.DELETE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void createTwiceSchema() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isConflicted();\n+   }\n+\n+   @Test\n+   public void addAndGetListOrderedByName() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      addSchema(\"users\", personProto);\n+      addSchema(\"people\", personProto);\n+      addSchema(\"dancers\", personProto);\n+\n+      String url = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      ContentResponse response = client.newRequest(url)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(3, jsonNode.size());\n+      assertEquals(\"dancers.proto\", jsonNode.get(0).get(\"name\").asText());\n+      assertEquals(\"people.proto\", jsonNode.get(1).get(\"name\").asText());\n+      assertEquals(\"users.proto\", jsonNode.get(2).get(\"name\").asText());\n+   }\n+\n+   private ContentResponse addSchema(String schemaName, String schemaContent)\n+         throws InterruptedException, TimeoutException, ExecutionException {\n+      return callAPI(schemaName, schemaContent, HttpMethod.POST);\n+   }\n+\n+   private ContentResponse updateSchema(String schemaName, String schemaContent)", "originalCommit": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzcxNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427443716", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-19T16:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNTgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0MzI4NA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427543284", "bodyText": "I believe this was missed, however I won't stop this from integrating it.", "author": "wburns", "createdAt": "2020-05-19T19:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNTgzMQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "url": "https://github.com/infinispan/infinispan/commit/98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-19T16:38:58Z", "type": "commit"}, {"oid": "98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "url": "https://github.com/infinispan/infinispan/commit/98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-19T16:38:58Z", "type": "forcePushed"}]}