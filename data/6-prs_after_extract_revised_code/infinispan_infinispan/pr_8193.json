{"pr_number": 8193, "pr_title": "ISPN-11632 Address comments in ISPN-10457", "pr_createdAt": "2020-04-13T18:28:14Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8193", "timeline": [{"oid": "9803878003f281ea1cc92ae65955cdc84edf7644", "url": "https://github.com/infinispan/infinispan/commit/9803878003f281ea1cc92ae65955cdc84edf7644", "message": "ISPN-11632 Address comments in ISPN-10457", "committedDate": "2020-05-01T14:10:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxNTA4OA==", "url": "https://github.com/infinispan/infinispan/pull/8193#discussion_r438715088", "bodyText": "IntelliJ says the type parameters are not needed", "author": "danberindei", "createdAt": "2020-06-11T11:22:11Z", "path": "core/src/main/java/org/infinispan/filter/CacheFilters.java", "diffHunk": "@@ -51,14 +52,42 @@ private CacheFilters() { }\n     * @param converter the converter to utilize\n     * @param <K> key type\n     * @param <V> value type\n-    * @param <C> convertered value type\n+    * @param <C> converted value type\n     * @return function based on the converter\n     */\n    public static <K, V, C> Function<CacheEntry<K, V>, CacheEntry<K, C>> function(\n            Converter<? super K, ? super V, C> converter) {\n       return new ConverterAsCacheEntryFunction<>(converter);\n    }\n \n+   /**\n+    * Creates a new {@link Function} using the provided filter convert. The {@link KeyValueFilterConverter#filterAndConvert(Object, Object, Metadata)}\n+    * is invoked for every passed in CacheEntry. When a null value is returned from the filter converter instead of\n+    * a null {@link CacheEntry} being returned, we instead return the {@link NullCacheEntry} as a sign of it. This\n+    * allows this {@link Function} to be used in cases when a null value cannot be returned, such as reactive streams.\n+    * <p>\n+    * The {@link #notNullCacheEntryPredicate()} can be used to filter these values if needed.\n+    * @param filterConverter the filter converter to utilize\n+    * @param <K> key type\n+    * @param <V> value type\n+    * @param <C> converted value type\n+    * @return function based on the filter converter\n+    */\n+   public static <K, V, C> Function<CacheEntry<K, V>, CacheEntry<K, C>> converterToFunction(KeyValueFilterConverter<? super K, ? super V, C> filterConverter) {\n+      return new FilterConverterAsCacheEntryFunction<K, V, C>(filterConverter);", "originalCommit": "9803878003f281ea1cc92ae65955cdc84edf7644", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4b4fddcb177c246c1811cdcce75299ba0d5f3d68", "chunk": "diff --git a/core/src/main/java/org/infinispan/filter/CacheFilters.java b/core/src/main/java/org/infinispan/filter/CacheFilters.java\nindex 47fbd50283..791316ae82 100644\n--- a/core/src/main/java/org/infinispan/filter/CacheFilters.java\n+++ b/core/src/main/java/org/infinispan/filter/CacheFilters.java\n\n@@ -74,7 +74,7 @@ private CacheFilters() { }\n     * @return function based on the filter converter\n     */\n    public static <K, V, C> Function<CacheEntry<K, V>, CacheEntry<K, C>> converterToFunction(KeyValueFilterConverter<? super K, ? super V, C> filterConverter) {\n-      return new FilterConverterAsCacheEntryFunction<K, V, C>(filterConverter);\n+      return new FilterConverterAsCacheEntryFunction<>(filterConverter);\n    }\n \n    /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNjQ0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8193#discussion_r438736442", "bodyText": "Wouldn't something like this also work, while being easier to read?\n      currentStage = currentStage.thenCompose(ignore ->\n            Flowable.fromPublisher(p)\n                  .startWith(Completable.defer(() -> Completable.fromCompletionStage(handler.delayProcessing())))\n                  .filter(ice -> handler.markKeyAsProcessing(ice.getKey()) != QueueingSegmentListener.REMOVED)\n                  .concatMapSingle(ice -> Single.fromCompletionStage(\n                        raiseEventForInitialTransfer(generatedId, ice, l.clustered(), kc, kv)))\n                  // Only request up to 20 at a time\n                  .rebatchRequests(20)\n                  // Ignore the actual values\n                  .ignoreElements()\n                  // Make sure there are no more delays for processing after all the events have been raised\n                  .andThen(Completable.defer(() -> Completable.fromCompletionStage(handler.delayProcessing())))\n                  .toCompletionStage(null)\n      );\nI'm not 100% sure whether startWith is enough, or whether delay is still needed at that step. In any case, please add a short comment to explain what it's doing.", "author": "danberindei", "createdAt": "2020-06-11T12:09:19Z", "path": "core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java", "diffHunk": "@@ -1111,36 +1108,36 @@ public boolean isNotificationAllowed(FlagAffectedCommand cmd, List<CacheEntryLis\n    }\n \n    private CompletionStage<Void> handlePublisher(CompletionStage<Void> currentStage,\n-         Queue<IntermediateOperation> intermediateOperations, QueueingSegmentListener<K, V, ? extends Event<K, V>> handler,\n+         Collection<IntermediateOperation<?, ?, ?, ?>> intermediateOperations, QueueingSegmentListener<K, V, ? extends Event<K, V>> handler,\n          UUID generatedId, Listener l, Function<Object, Object> kc, Function<Object, Object> kv) {\n       SegmentCompletionPublisher<CacheEntry<K, V>> publisher = publisherManager.running().entryPublisher(\n             null, null, null, true,\n             // TODO: do we really need EXACTLY_ONCE? AT_LEAST_ONCE should be fine I think\n             DeliveryGuarantee.EXACTLY_ONCE, config.clustering().stateTransfer().chunkSize(),\n             intermediateOperations.isEmpty() ? PublisherTransformers.identity() : new CacheIntermediatePublisher(intermediateOperations));\n \n-      io.reactivex.rxjava3.functions.Function<Object, ? extends Publisher<Void>> itemDelayFunction = ice -> {\n-         CompletionStage<Void> delay = handler.delayProcessing();\n-         if (CompletionStages.isCompletedSuccessfully(delay)) {\n-            return Flowable.empty();\n-         }\n-         return Completable.fromCompletionStage(delay).toFlowable();\n-      };\n+      io.reactivex.rxjava3.functions.Function<Object, ? extends Publisher<Void>> itemDelayFunction = ice ->\n+         RxJavaInterop.voidCompletionStageToFlowable(handler.delayProcessing());\n+\n       Publisher<CacheEntry<K, V>> p = s -> publisher.subscribe(s, handler);\n-      currentStage = Flowable.fromPublisher(p)\n-            .delaySubscription(Completable.fromCompletionStage(currentStage).toFlowable())\n-            .delay(itemDelayFunction)\n-            .filter(ice -> handler.markKeyAsProcessing(ice.getKey()) != QueueingSegmentListener.REMOVED)\n-            .delay(ice -> Completable.fromCompletionStage(raiseEventForInitialTransfer(generatedId, ice, l.clustered(),\n-                  kc, kv)).toFlowable())\n-            // Only request up to 20 at a time\n-            .rebatchRequests(20)\n-            .count()\n-            .toFlowable()\n-            // Make sure there are no more delays for processing after we have retrieved all values\n-            .delay(itemDelayFunction)\n-            .ignoreElements()\n-            .toCompletionStage(null);\n+\n+      currentStage = currentStage.thenCompose(ignore ->", "originalCommit": "9803878003f281ea1cc92ae65955cdc84edf7644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc1NDYzMg==", "url": "https://github.com/infinispan/infinispan/pull/8193#discussion_r438754632", "bodyText": "The concatMapSingle would have to be tweaked for sure. I can look into the others though.", "author": "wburns", "createdAt": "2020-06-11T12:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNjQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc1OTU0MA==", "url": "https://github.com/infinispan/infinispan/pull/8193#discussion_r438759540", "bodyText": "And startWith and andThen should both work.", "author": "wburns", "createdAt": "2020-06-11T12:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNjQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MjY5Nw==", "url": "https://github.com/infinispan/infinispan/pull/8193#discussion_r438762697", "bodyText": "I have converted all but the concatMapSingle since it would need to be\n.concatMapSingle(ice -> Single.fromCompletionStage(raiseEventForInitialTransfer(generatedId, ice, l.clustered(), kc, kv).thenApply(ignore2 -> ice)))\nTBH I wish there was just a delayStage(Function<Object, CompletionStage<?>) method or something similar.", "author": "wburns", "createdAt": "2020-06-11T12:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNjQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NjIwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8193#discussion_r438776209", "bodyText": "Right, I didn't realize that raiseEventForInitialTransfer's CompletionStage yields null so can't be converted to a Single.\nI do have one small extra request: please move raiseEventForInitialTransfer to the next line, the current formatting makes it look like l.clustered() is a parameter of delay().", "author": "danberindei", "createdAt": "2020-06-11T13:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNjQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3ODYxNA==", "url": "https://github.com/infinispan/infinispan/pull/8193#discussion_r438778614", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-06-11T13:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNjQ0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4b4fddcb177c246c1811cdcce75299ba0d5f3d68", "chunk": "diff --git a/core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java b/core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java\nindex 5b37b96ea1..b7632e801f 100644\n--- a/core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java\n+++ b/core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java\n\n@@ -1116,26 +1118,21 @@ public boolean isNotificationAllowed(FlagAffectedCommand cmd, List<CacheEntryLis\n             DeliveryGuarantee.EXACTLY_ONCE, config.clustering().stateTransfer().chunkSize(),\n             intermediateOperations.isEmpty() ? PublisherTransformers.identity() : new CacheIntermediatePublisher(intermediateOperations));\n \n-      io.reactivex.rxjava3.functions.Function<Object, ? extends Publisher<Void>> itemDelayFunction = ice ->\n-         RxJavaInterop.voidCompletionStageToFlowable(handler.delayProcessing());\n+      Completable delayCompletable = Completable.defer(() -> Completable.fromCompletionStage(handler.delayProcessing()));\n \n       Publisher<CacheEntry<K, V>> p = s -> publisher.subscribe(s, handler);\n \n       currentStage = currentStage.thenCompose(ignore ->\n             Flowable.fromPublisher(p)\n-                  .delay(itemDelayFunction)\n+                  .startWith(delayCompletable)\n                   .filter(ice -> handler.markKeyAsProcessing(ice.getKey()) != QueueingSegmentListener.REMOVED)\n                   .delay(ice -> RxJavaInterop.voidCompletionStageToFlowable(raiseEventForInitialTransfer(generatedId, ice,\n                         l.clustered(), kc, kv)))\n                   // Only request up to 20 at a time\n                   .rebatchRequests(20)\n-                  // Here as we need to publish down a value for the final delay to work\n-                  .count()\n-                  // Unfortunately we can't delay the Single via another Publisher/Single - so we have to use Flowable\n-                  .toFlowable()\n-                  // Make sure there are no more delays for processing after we have retrieved all values\n-                  .delay(itemDelayFunction)\n                   .ignoreElements()\n+                  // Make sure there are no more delays for processing after we have retrieved all values\n+                  .andThen(delayCompletable)\n                   .toCompletionStage(null)\n       );\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0Mzc1MA==", "url": "https://github.com/infinispan/infinispan/pull/8193#discussion_r438743750", "bodyText": "Please also change the other methods below\nE.g.\n      Flowable<?> innerPublisher = Flowable.fromPublisher(objectPublisher);\n      for (IntermediateOperation<?, ?, ?, ?> intOp : intOps) {\n         innerPublisher = intOp.mapFlowable((Flowable) innerPublisher);\n      }\nstill has 2 unchecked warnings, but IMO it's clearer why those warnings cannot be avoided: because the type system can't express a chain of IntermediateOperations mapping Object -> X -> Y -> ... -> R).", "author": "danberindei", "createdAt": "2020-06-11T12:24:18Z", "path": "core/src/main/java/org/infinispan/stream/impl/CacheIntermediatePublisher.java", "diffHunk": "@@ -26,9 +25,9 @@\n  * @param <R>\n  */\n public final class CacheIntermediatePublisher<R> implements ModifiedValueFunction<Publisher<Object>, Publisher<R>>, InjectableComponent {\n-   private final Queue<IntermediateOperation> intOps;\n+   private final Iterable<IntermediateOperation<?, ?, ?, ?>> intOps;\n \n-   public CacheIntermediatePublisher(Queue<IntermediateOperation> intOps) {\n+   public CacheIntermediatePublisher(Iterable<IntermediateOperation<?, ?, ?, ?>> intOps) {", "originalCommit": "9803878003f281ea1cc92ae65955cdc84edf7644", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4b4fddcb177c246c1811cdcce75299ba0d5f3d68", "chunk": "diff --git a/core/src/main/java/org/infinispan/stream/impl/CacheIntermediatePublisher.java b/core/src/main/java/org/infinispan/stream/impl/CacheIntermediatePublisher.java\nindex 590e331560..c3e01e32ac 100644\n--- a/core/src/main/java/org/infinispan/stream/impl/CacheIntermediatePublisher.java\n+++ b/core/src/main/java/org/infinispan/stream/impl/CacheIntermediatePublisher.java\n\n@@ -34,8 +34,8 @@ public CacheIntermediatePublisher(Iterable<IntermediateOperation<?, ?, ?, ?>> in\n    @Override\n    public Publisher<R> apply(Publisher<Object> objectPublisher) {\n       Flowable<Object> innerPublisher = Flowable.fromPublisher(objectPublisher);\n-      for (IntermediateOperation intOp : intOps) {\n-         innerPublisher = intOp.mapFlowable(innerPublisher);\n+      for (IntermediateOperation<?, ?, ?, ?> intOp : intOps) {\n+         innerPublisher = intOp.mapFlowable((Flowable) innerPublisher);\n       }\n       return (Publisher<R>) innerPublisher;\n    }\n"}}, {"oid": "4b4fddcb177c246c1811cdcce75299ba0d5f3d68", "url": "https://github.com/infinispan/infinispan/commit/4b4fddcb177c246c1811cdcce75299ba0d5f3d68", "message": "ISPN-11632 Address comments in ISPN-10457", "committedDate": "2020-06-11T13:03:12Z", "type": "forcePushed"}, {"oid": "9fab93fff2113826cb4f3a8a9f6df2d771502608", "url": "https://github.com/infinispan/infinispan/commit/9fab93fff2113826cb4f3a8a9f6df2d771502608", "message": "ISPN-11632 Address comments in ISPN-10457", "committedDate": "2020-06-11T13:29:41Z", "type": "commit"}, {"oid": "9fab93fff2113826cb4f3a8a9f6df2d771502608", "url": "https://github.com/infinispan/infinispan/commit/9fab93fff2113826cb4f3a8a9f6df2d771502608", "message": "ISPN-11632 Address comments in ISPN-10457", "committedDate": "2020-06-11T13:29:41Z", "type": "forcePushed"}]}