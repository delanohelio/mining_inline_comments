{"pr_number": 8766, "pr_title": "ISPN-8241 Refactor RocksDB clearThreshold", "pr_createdAt": "2020-10-09T18:57:05Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8766", "timeline": [{"oid": "91ae9d6cab7a4c9a0d16f57eafe5c1c1258990e4", "url": "https://github.com/infinispan/infinispan/commit/91ae9d6cab7a4c9a0d16f57eafe5c1c1258990e4", "message": "ISPN-8241 Refactor RocksDB clearThreshold", "committedDate": "2020-10-13T18:53:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIwNTAzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r504205039", "bodyText": "This cannot use the clearThreshold here. You can end up deleting the db could include entries that aren't in the IntSet. All we can do is iterate over the entries.", "author": "wburns", "createdAt": "2020-10-13T19:31:25Z", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -741,36 +741,32 @@ RocksDB open(Path location, DBOptions options) throws RocksDBException {\n             boolean destroyDatabase = false;\n             try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n                RocksIterator optionalIterator = wrapIterator(db, readOptions, -1);\n-               if (optionalIterator != null && (configuration.clearThreshold() > 0 || segments == null)) {\n-                  try (RocksIterator it = optionalIterator) {\n-                     for (it.seekToFirst(); it.isValid(); it.next()) {\n-                        byte[] keyBytes = it.key();\n-                        if (segments != null) {\n-                           Object key = unmarshall(keyBytes);\n-                           int segment = keyPartitioner.getSegment(key);\n-                           if (segments.contains(segment)) {\n-                              db.delete(defaultColumnFamilyHandle, keyBytes);\n-                           }\n-                        } else {\n-                           db.delete(defaultColumnFamilyHandle, keyBytes);\n-                           count++;\n-\n-                           if (count > configuration.clearThreshold()) {\n-                              destroyDatabase = true;\n-                              break;\n+               if (optionalIterator != null) {\n+                  if (segments == null) {\n+                     deleteRange(defaultColumnFamilyHandle, optionalIterator);\n+                  } else {\n+                     if (configuration.clearThreshold() > 0) {", "originalCommit": "91ae9d6cab7a4c9a0d16f57eafe5c1c1258990e4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b34db95a6b106075ca4771c1cc543bc77cfd446c", "chunk": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 7ee86af49f..c163b09dd4 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n\n@@ -737,44 +740,25 @@ RocksDB open(Path location, DBOptions options) throws RocksDBException {\n \n       CompletionStage<Void> clear(IntSet segments) {\n          return blockingManager.runBlocking(() -> {\n-            long count = 0;\n-            boolean destroyDatabase = false;\n-            try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n-               RocksIterator optionalIterator = wrapIterator(db, readOptions, -1);\n-               if (optionalIterator != null) {\n-                  if (segments == null) {\n-                     deleteRange(defaultColumnFamilyHandle, optionalIterator);\n-                  } else {\n-                     if (configuration.clearThreshold() > 0) {\n-                        try (RocksIterator it = optionalIterator) {\n-                           for (it.seekToFirst(); it.isValid(); it.next()) {\n-                              byte[] keyBytes = it.key();\n-                              Object key = unmarshall(keyBytes);\n-                              int segment = keyPartitioner.getSegment(key);\n-                              if (segments.contains(segment)) {\n-                                 db.delete(defaultColumnFamilyHandle, keyBytes);\n-                              }\n-                              count++;\n-                              if (count > configuration.clearThreshold()) {\n-                                 destroyDatabase = true;\n-                                 break;\n-                              }\n+            if (segments == null) {\n+               deleteRange(defaultColumnFamilyHandle);\n+            } else {\n+               try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n+                  RocksIterator optionalIterator = wrapIterator(db, readOptions, -1);\n+                  if (optionalIterator != null) {\n+                     try (RocksIterator it = optionalIterator) {\n+                        for (it.seekToFirst(); it.isValid(); it.next()) {\n+                           byte[] keyBytes = it.key();\n+                           Object key = unmarshall(keyBytes);\n+                           int segment = keyPartitioner.getSegment(key);\n+                           if (segments.contains(segment)) {\n+                              db.delete(defaultColumnFamilyHandle, keyBytes);\n                            }\n-                        } catch (RocksDBException e) {\n-                           throw e;\n                         }\n-                     } else {\n-                        destroyDatabase = true;\n+                     } catch (RocksDBException e) {\n+                        throw e;\n                      }\n                   }\n-               }\n-            } catch (Exception e) {\n-               throw new PersistenceException(e);\n-            }\n-\n-            if (destroyDatabase) {\n-               try {\n-                  reinitAllDatabases();\n                } catch (Exception e) {\n                   throw new PersistenceException(e);\n                }\n"}}, {"oid": "b34db95a6b106075ca4771c1cc543bc77cfd446c", "url": "https://github.com/infinispan/infinispan/commit/b34db95a6b106075ca4771c1cc543bc77cfd446c", "message": "ISPN-8241 Refactor RocksDB clearThreshold", "committedDate": "2020-10-13T21:18:23Z", "type": "forcePushed"}, {"oid": "b3f7a17621c08868dd906a520a88aa763e920064", "url": "https://github.com/infinispan/infinispan/commit/b3f7a17621c08868dd906a520a88aa763e920064", "message": "ISPN-8241 Refactor RocksDB clearThreshold", "committedDate": "2020-10-13T21:32:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI1NDc3MA==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r509254770", "bodyText": "This is equivalent to new byte[] {(byte) 0xff}, it creates an array with a single byte element.", "author": "danberindei", "createdAt": "2020-10-21T12:57:19Z", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -78,6 +77,9 @@\n    private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass(), Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n+   private static final byte[] BEGIN_KEY = new byte[0];\n+   private static final byte[] END_KEY = new byte[] {(byte) 0xffffffff};", "originalCommit": "b3f7a17621c08868dd906a520a88aa763e920064", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c1f637a3d390214f130c71f9977e8e87686d24be", "chunk": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 54e3c12230..3081f44373 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n\n@@ -77,8 +77,8 @@\n    private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass(), Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n-   private static final byte[] BEGIN_KEY = new byte[0];\n-   private static final byte[] END_KEY = new byte[] {(byte) 0xffffffff};\n+   private static final byte[] BEGIN_KEY = createAndFillArray(1, (byte) 0x00);\n+   private static final byte[] END_KEY = createAndFillArray(128, (byte) 0xff);\n \n    static final String DATABASE_PROPERTY_NAME_WITH_SUFFIX = \"database.\";\n    static final String COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX = \"data.\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ1MjM4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r509452389", "bodyText": "I would suggest changing this method as it is really just clearing all entries for this column family handle.", "author": "wburns", "createdAt": "2020-10-21T17:01:31Z", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -1077,4 +993,18 @@ private void putExpireDbData(ExpiryEntry entry) throws RocksDBException {\n          expiredDb.put(expiryBytes, entry.keyBytes);\n       }\n    }\n+\n+   /*\n+    * Instead of iterate in RocksIterator we use the first and last byte array\n+    */\n+   private void deleteRange(ColumnFamilyHandle handle) {", "originalCommit": "b3f7a17621c08868dd906a520a88aa763e920064", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c1f637a3d390214f130c71f9977e8e87686d24be", "chunk": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 54e3c12230..3081f44373 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n\n@@ -997,14 +989,27 @@ private void putExpireDbData(ExpiryEntry entry) throws RocksDBException {\n    /*\n     * Instead of iterate in RocksIterator we use the first and last byte array\n     */\n-   private void deleteRange(ColumnFamilyHandle handle) {\n+   private void clearColumnFamily(ColumnFamilyHandle handle) {\n       try {\n          // when the data under a segment was removed, the handle will be null\n          if (handle != null) {\n             db.deleteRange(handle, BEGIN_KEY, END_KEY);\n+            try (ReadOptions iteratorOptions = new ReadOptions().setFillCache(false)) {\n+               try (RocksIterator it = db.newIterator(handle, iteratorOptions)) {\n+                  for (it.seekToFirst(); it.isValid(); it.next()) {\n+                     db.delete(handle, it.key());\n+                  }\n+               }\n+            }\n          }\n       } catch (RocksDBException e) {\n          throw new PersistenceException(e);\n       }\n    }\n+\n+   private static byte[] createAndFillArray(int length, byte value) {\n+      byte[] array = new byte[length];\n+      Arrays.fill(array, value);\n+      return array;\n+   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ1NDQ5NQ==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r509454495", "bodyText": "This is testing clear.", "author": "wburns", "createdAt": "2020-10-21T17:05:03Z", "path": "persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java", "diffHunk": "@@ -155,4 +157,53 @@ public void testSegmentsRemovedAndAdded() {\n \n       assertTrue(store.contains(key));\n    }\n+\n+   // deleteRange uses a magic begin and end key. we assert that everything was removed\n+   public void testDeleteRange() {", "originalCommit": "b3f7a17621c08868dd906a520a88aa763e920064", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c1f637a3d390214f130c71f9977e8e87686d24be", "chunk": "diff --git a/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java b/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\nindex 1afb4af2a1..d1aa285e45 100644\n--- a/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\n+++ b/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\n\n@@ -127,83 +136,81 @@ public void testConcurrentWrite() throws InterruptedException {\n       if (!finished.await(30, TimeUnit.SECONDS)) {\n          fail(\"Test should have finished!\");\n       }\n-      assertEquals(written.get(), (1 << THREADS) - 1, \"pre\");\n+      assertEquals(\"pre\", (1 << THREADS) - 1, written.get());\n    }\n \n    /**\n     * Test to make sure that when segments are added or removed that there are no issues\n     */\n    public void testSegmentsRemovedAndAdded() {\n-      Object key = \"first-key\";\n-      Object value = \"some-value\";\n-      int segment = keyPartitioner.getSegment(key);\n+      int segment1 = keyPartitioner.getSegment(KEY_1);\n+      MarshallableEntry me1 = marshallableEntryFactory.create(KEY_1, \"value1\");\n+      store.write(me1);\n+      assertTrue(join(store.containsKey(segment1, KEY_1)));\n+\n+      int segment2 = keyPartitioner.getSegment(KEY_2);\n+      AssertJUnit.assertTrue(segment1 != segment2);\n+      MarshallableEntry me2 = marshallableEntryFactory.create(KEY_2, \"value2\");\n+      store.write(me2);\n+      assertTrue(join(store.containsKey(segment2, KEY_2)));\n+      assertEquals(Arrays.asList(KEY_1, KEY_2), listKeys(null));\n \n-      InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-      MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n+      store.removeSegments(immutableSet(segment1));\n \n-      store.write(me);\n+      assertEquals(0, (long) join(store.size(immutableSet(segment1))));\n \n-      assertTrue(store.contains(key));\n+      assertFalse(join(store.containsKey(segment1, KEY_1)));\n+      assertEmpty(immutableSet(segment1));\n \n-      // Now remove the segment that held our key\n-      CompletionStages.join(store.removeSegments(IntSets.immutableSet(segment)));\n+      assertTrue(join(store.containsKey(segment2, KEY_2)));\n+      assertEquals(1, (long) join(store.size(immutableSet(segment2))));\n \n-      assertFalse(store.contains(key));\n+      assertEquals(singletonList(KEY_2), listKeys(null));\n \n       // Now add the segment back\n-      CompletionStages.join(store.addSegments(IntSets.immutableSet(segment)));\n+      join(store.addSegments(immutableSet(segment1)));\n \n-      store.write(me);\n+      store.write(me1);\n \n-      assertTrue(store.contains(key));\n+      assertTrue(store.contains(KEY_1));\n+      assertEquals(Arrays.asList(KEY_1, KEY_2), listKeys(null));\n    }\n \n-   // deleteRange uses a magic begin and end key. we assert that everything was removed\n-   public void testDeleteRange() {\n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         String value = \"value-\" + i;\n-         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n-         store.write(me);\n-         assertTrue(store.contains(key));\n-      }\n+   public void testClear() {\n+      MarshallableEntry me1 = marshallableEntryFactory.create(KEY_1, \"value\");\n+      store.write(1, me1);\n+      assertTrue(join(store.containsKey(1, KEY_1)));\n+\n+      // clear() uses RockDB's DeleteRange call internally\n+      // Create a fake key that is after the end key of this DeleteRange call\n+      // A custom marshaller could in theory create the same kind of key, but this is simpler\n+      // because we don't need to unmarshal the key\n+      int keySize = 10000;\n+      byte[] keyBytes = new byte[keySize];\n+      Arrays.fill(keyBytes, (byte) 0xff);\n+      byte[] valueBytes = new byte[0];\n+      MarshallableEntry me2 = marshallableEntryFactory.create(ByteBufferImpl.create(keyBytes), ByteBufferImpl.create(valueBytes));\n+      store.write(1, me2);\n+\n+      // Because key2 cannot be unmarshalled, we cannot confirm the write with contains(key2) or even with size()\n \n       store.clear();\n \n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         boolean contains = store.contains(key);\n-         assertFalse(contains);\n-      }\n+      assertFalse(join(store.containsKey(1, KEY_1)));\n+\n+      assertEmpty(null);\n    }\n \n-   // deleteRange uses a magic begin and end key. we assert that only the data from the give segment was removed\n-   public void testDeleteRangeForGivenSegment() {\n-      int segmentUnderTest = 1;\n-      List<String> keysInTheSegment = new ArrayList<>();\n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         String value = \"value-\" + i;\n-         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n-         int segmentFromKey = store.getKeyPartitioner().getSegment(entry.getKey());\n-         if (segmentFromKey == segmentUnderTest) {\n-            keysInTheSegment.add(key);\n-         }\n-         store.write(me);\n-      }\n+   private void assertEmpty(IntSet segments) {\n+      assertEquals(0, (long) join(store.size(segments)));\n \n-      store.removeSegments(IntSets.immutableSet(segmentUnderTest));\n+      assertEquals(Collections.emptyList(), listKeys(segments));\n+   }\n \n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         boolean contains = store.contains(key);\n-         if (keysInTheSegment.contains(key)) {\n-            assertFalse(contains);\n-         } else {\n-            assertTrue(contains);\n-         }\n-      }\n+   private List<Object> listKeys(IntSet segments) {\n+      return Flowable.fromPublisher(store.publishEntries(segments, null, true))\n+                     .map(MarshallableEntry::getKey)\n+                     .toSortedList()\n+                     .blockingGet();\n    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ1NDcyNg==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r509454726", "bodyText": "This is testing removeSegments", "author": "wburns", "createdAt": "2020-10-21T17:05:26Z", "path": "persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java", "diffHunk": "@@ -155,4 +157,53 @@ public void testSegmentsRemovedAndAdded() {\n \n       assertTrue(store.contains(key));\n    }\n+\n+   // deleteRange uses a magic begin and end key. we assert that everything was removed\n+   public void testDeleteRange() {\n+      for (int i = 0; i < 100; i++) {\n+         String key = \"key-\" + i;\n+         String value = \"value-\" + i;\n+         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n+         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n+         store.write(me);\n+         assertTrue(store.contains(key));\n+      }\n+\n+      store.clear();\n+\n+      for (int i = 0; i < 100; i++) {\n+         String key = \"key-\" + i;\n+         boolean contains = store.contains(key);\n+         assertFalse(contains);\n+      }\n+   }\n+\n+   // deleteRange uses a magic begin and end key. we assert that only the data from the give segment was removed\n+   public void testDeleteRangeForGivenSegment() {", "originalCommit": "b3f7a17621c08868dd906a520a88aa763e920064", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c1f637a3d390214f130c71f9977e8e87686d24be", "chunk": "diff --git a/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java b/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\nindex 1afb4af2a1..d1aa285e45 100644\n--- a/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\n+++ b/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\n\n@@ -127,83 +136,81 @@ public void testConcurrentWrite() throws InterruptedException {\n       if (!finished.await(30, TimeUnit.SECONDS)) {\n          fail(\"Test should have finished!\");\n       }\n-      assertEquals(written.get(), (1 << THREADS) - 1, \"pre\");\n+      assertEquals(\"pre\", (1 << THREADS) - 1, written.get());\n    }\n \n    /**\n     * Test to make sure that when segments are added or removed that there are no issues\n     */\n    public void testSegmentsRemovedAndAdded() {\n-      Object key = \"first-key\";\n-      Object value = \"some-value\";\n-      int segment = keyPartitioner.getSegment(key);\n+      int segment1 = keyPartitioner.getSegment(KEY_1);\n+      MarshallableEntry me1 = marshallableEntryFactory.create(KEY_1, \"value1\");\n+      store.write(me1);\n+      assertTrue(join(store.containsKey(segment1, KEY_1)));\n+\n+      int segment2 = keyPartitioner.getSegment(KEY_2);\n+      AssertJUnit.assertTrue(segment1 != segment2);\n+      MarshallableEntry me2 = marshallableEntryFactory.create(KEY_2, \"value2\");\n+      store.write(me2);\n+      assertTrue(join(store.containsKey(segment2, KEY_2)));\n+      assertEquals(Arrays.asList(KEY_1, KEY_2), listKeys(null));\n \n-      InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-      MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n+      store.removeSegments(immutableSet(segment1));\n \n-      store.write(me);\n+      assertEquals(0, (long) join(store.size(immutableSet(segment1))));\n \n-      assertTrue(store.contains(key));\n+      assertFalse(join(store.containsKey(segment1, KEY_1)));\n+      assertEmpty(immutableSet(segment1));\n \n-      // Now remove the segment that held our key\n-      CompletionStages.join(store.removeSegments(IntSets.immutableSet(segment)));\n+      assertTrue(join(store.containsKey(segment2, KEY_2)));\n+      assertEquals(1, (long) join(store.size(immutableSet(segment2))));\n \n-      assertFalse(store.contains(key));\n+      assertEquals(singletonList(KEY_2), listKeys(null));\n \n       // Now add the segment back\n-      CompletionStages.join(store.addSegments(IntSets.immutableSet(segment)));\n+      join(store.addSegments(immutableSet(segment1)));\n \n-      store.write(me);\n+      store.write(me1);\n \n-      assertTrue(store.contains(key));\n+      assertTrue(store.contains(KEY_1));\n+      assertEquals(Arrays.asList(KEY_1, KEY_2), listKeys(null));\n    }\n \n-   // deleteRange uses a magic begin and end key. we assert that everything was removed\n-   public void testDeleteRange() {\n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         String value = \"value-\" + i;\n-         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n-         store.write(me);\n-         assertTrue(store.contains(key));\n-      }\n+   public void testClear() {\n+      MarshallableEntry me1 = marshallableEntryFactory.create(KEY_1, \"value\");\n+      store.write(1, me1);\n+      assertTrue(join(store.containsKey(1, KEY_1)));\n+\n+      // clear() uses RockDB's DeleteRange call internally\n+      // Create a fake key that is after the end key of this DeleteRange call\n+      // A custom marshaller could in theory create the same kind of key, but this is simpler\n+      // because we don't need to unmarshal the key\n+      int keySize = 10000;\n+      byte[] keyBytes = new byte[keySize];\n+      Arrays.fill(keyBytes, (byte) 0xff);\n+      byte[] valueBytes = new byte[0];\n+      MarshallableEntry me2 = marshallableEntryFactory.create(ByteBufferImpl.create(keyBytes), ByteBufferImpl.create(valueBytes));\n+      store.write(1, me2);\n+\n+      // Because key2 cannot be unmarshalled, we cannot confirm the write with contains(key2) or even with size()\n \n       store.clear();\n \n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         boolean contains = store.contains(key);\n-         assertFalse(contains);\n-      }\n+      assertFalse(join(store.containsKey(1, KEY_1)));\n+\n+      assertEmpty(null);\n    }\n \n-   // deleteRange uses a magic begin and end key. we assert that only the data from the give segment was removed\n-   public void testDeleteRangeForGivenSegment() {\n-      int segmentUnderTest = 1;\n-      List<String> keysInTheSegment = new ArrayList<>();\n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         String value = \"value-\" + i;\n-         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n-         int segmentFromKey = store.getKeyPartitioner().getSegment(entry.getKey());\n-         if (segmentFromKey == segmentUnderTest) {\n-            keysInTheSegment.add(key);\n-         }\n-         store.write(me);\n-      }\n+   private void assertEmpty(IntSet segments) {\n+      assertEquals(0, (long) join(store.size(segments)));\n \n-      store.removeSegments(IntSets.immutableSet(segmentUnderTest));\n+      assertEquals(Collections.emptyList(), listKeys(segments));\n+   }\n \n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         boolean contains = store.contains(key);\n-         if (keysInTheSegment.contains(key)) {\n-            assertFalse(contains);\n-         } else {\n-            assertTrue(contains);\n-         }\n-      }\n+   private List<Object> listKeys(IntSet segments) {\n+      return Flowable.fromPublisher(store.publishEntries(segments, null, true))\n+                     .map(MarshallableEntry::getKey)\n+                     .toSortedList()\n+                     .blockingGet();\n    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI4NzEyMg==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r509287122", "bodyText": "This is inherited from the old code, but using wrapIterator complicates things unnecessarily, this is in NonSegmentedRocksDBHandler so we know the iterator is always non-null.", "author": "danberindei", "createdAt": "2020-10-21T13:33:58Z", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -737,48 +739,25 @@ RocksDB open(Path location, DBOptions options) throws RocksDBException {\n \n       CompletionStage<Void> clear(IntSet segments) {\n          return blockingManager.runBlocking(() -> {\n-            long count = 0;\n-            boolean destroyDatabase = false;\n-            try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n-               RocksIterator optionalIterator = wrapIterator(db, readOptions, -1);\n-               if (optionalIterator != null && (configuration.clearThreshold() > 0 || segments == null)) {\n-                  try (RocksIterator it = optionalIterator) {\n-                     for (it.seekToFirst(); it.isValid(); it.next()) {\n-                        byte[] keyBytes = it.key();\n-                        if (segments != null) {\n+            if (segments == null) {\n+               deleteRange(defaultColumnFamilyHandle);\n+            } else {\n+               try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n+                  RocksIterator optionalIterator = wrapIterator(db, readOptions, -1);", "originalCommit": "b3f7a17621c08868dd906a520a88aa763e920064", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c1f637a3d390214f130c71f9977e8e87686d24be", "chunk": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 54e3c12230..3081f44373 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n\n@@ -740,22 +740,17 @@ RocksDB open(Path location, DBOptions options) throws RocksDBException {\n       CompletionStage<Void> clear(IntSet segments) {\n          return blockingManager.runBlocking(() -> {\n             if (segments == null) {\n-               deleteRange(defaultColumnFamilyHandle);\n+               clearColumnFamily(defaultColumnFamilyHandle);\n             } else {\n                try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n-                  RocksIterator optionalIterator = wrapIterator(db, readOptions, -1);\n-                  if (optionalIterator != null) {\n-                     try (RocksIterator it = optionalIterator) {\n-                        for (it.seekToFirst(); it.isValid(); it.next()) {\n-                           byte[] keyBytes = it.key();\n-                           Object key = unmarshall(keyBytes);\n-                           int segment = keyPartitioner.getSegment(key);\n-                           if (segments.contains(segment)) {\n-                              db.delete(defaultColumnFamilyHandle, keyBytes);\n-                           }\n+                  try (RocksIterator it = db.newIterator(defaultColumnFamilyHandle, readOptions)) {\n+                     for (it.seekToFirst(); it.isValid(); it.next()) {\n+                        byte[] keyBytes = it.key();\n+                        Object key = unmarshall(keyBytes);\n+                        int segment = keyPartitioner.getSegment(key);\n+                        if (segments.contains(segment)) {\n+                           db.delete(defaultColumnFamilyHandle, keyBytes);\n                         }\n-                     } catch (RocksDBException e) {\n-                        throw e;\n                      }\n                   }\n                } catch (Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI5NzU3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r509297576", "bodyText": "The name doesn't sound right, because it can't delete a range, only all the entries in the column family.", "author": "danberindei", "createdAt": "2020-10-21T13:46:18Z", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -1077,4 +993,18 @@ private void putExpireDbData(ExpiryEntry entry) throws RocksDBException {\n          expiredDb.put(expiryBytes, entry.keyBytes);\n       }\n    }\n+\n+   /*\n+    * Instead of iterate in RocksIterator we use the first and last byte array\n+    */\n+   private void deleteRange(ColumnFamilyHandle handle) {", "originalCommit": "b3f7a17621c08868dd906a520a88aa763e920064", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c1f637a3d390214f130c71f9977e8e87686d24be", "chunk": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 54e3c12230..3081f44373 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n\n@@ -997,14 +989,27 @@ private void putExpireDbData(ExpiryEntry entry) throws RocksDBException {\n    /*\n     * Instead of iterate in RocksIterator we use the first and last byte array\n     */\n-   private void deleteRange(ColumnFamilyHandle handle) {\n+   private void clearColumnFamily(ColumnFamilyHandle handle) {\n       try {\n          // when the data under a segment was removed, the handle will be null\n          if (handle != null) {\n             db.deleteRange(handle, BEGIN_KEY, END_KEY);\n+            try (ReadOptions iteratorOptions = new ReadOptions().setFillCache(false)) {\n+               try (RocksIterator it = db.newIterator(handle, iteratorOptions)) {\n+                  for (it.seekToFirst(); it.isValid(); it.next()) {\n+                     db.delete(handle, it.key());\n+                  }\n+               }\n+            }\n          }\n       } catch (RocksDBException e) {\n          throw new PersistenceException(e);\n       }\n    }\n+\n+   private static byte[] createAndFillArray(int length, byte value) {\n+      byte[] array = new byte[length];\n+      Arrays.fill(array, value);\n+      return array;\n+   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMwMTYyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r509301621", "bodyText": "The test doesn't explicitly use DeleteRange, so I'd call it testClear instead.", "author": "danberindei", "createdAt": "2020-10-21T13:49:29Z", "path": "persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java", "diffHunk": "@@ -155,4 +157,53 @@ public void testSegmentsRemovedAndAdded() {\n \n       assertTrue(store.contains(key));\n    }\n+\n+   // deleteRange uses a magic begin and end key. we assert that everything was removed\n+   public void testDeleteRange() {", "originalCommit": "b3f7a17621c08868dd906a520a88aa763e920064", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c1f637a3d390214f130c71f9977e8e87686d24be", "chunk": "diff --git a/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java b/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\nindex 1afb4af2a1..d1aa285e45 100644\n--- a/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\n+++ b/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\n\n@@ -127,83 +136,81 @@ public void testConcurrentWrite() throws InterruptedException {\n       if (!finished.await(30, TimeUnit.SECONDS)) {\n          fail(\"Test should have finished!\");\n       }\n-      assertEquals(written.get(), (1 << THREADS) - 1, \"pre\");\n+      assertEquals(\"pre\", (1 << THREADS) - 1, written.get());\n    }\n \n    /**\n     * Test to make sure that when segments are added or removed that there are no issues\n     */\n    public void testSegmentsRemovedAndAdded() {\n-      Object key = \"first-key\";\n-      Object value = \"some-value\";\n-      int segment = keyPartitioner.getSegment(key);\n+      int segment1 = keyPartitioner.getSegment(KEY_1);\n+      MarshallableEntry me1 = marshallableEntryFactory.create(KEY_1, \"value1\");\n+      store.write(me1);\n+      assertTrue(join(store.containsKey(segment1, KEY_1)));\n+\n+      int segment2 = keyPartitioner.getSegment(KEY_2);\n+      AssertJUnit.assertTrue(segment1 != segment2);\n+      MarshallableEntry me2 = marshallableEntryFactory.create(KEY_2, \"value2\");\n+      store.write(me2);\n+      assertTrue(join(store.containsKey(segment2, KEY_2)));\n+      assertEquals(Arrays.asList(KEY_1, KEY_2), listKeys(null));\n \n-      InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-      MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n+      store.removeSegments(immutableSet(segment1));\n \n-      store.write(me);\n+      assertEquals(0, (long) join(store.size(immutableSet(segment1))));\n \n-      assertTrue(store.contains(key));\n+      assertFalse(join(store.containsKey(segment1, KEY_1)));\n+      assertEmpty(immutableSet(segment1));\n \n-      // Now remove the segment that held our key\n-      CompletionStages.join(store.removeSegments(IntSets.immutableSet(segment)));\n+      assertTrue(join(store.containsKey(segment2, KEY_2)));\n+      assertEquals(1, (long) join(store.size(immutableSet(segment2))));\n \n-      assertFalse(store.contains(key));\n+      assertEquals(singletonList(KEY_2), listKeys(null));\n \n       // Now add the segment back\n-      CompletionStages.join(store.addSegments(IntSets.immutableSet(segment)));\n+      join(store.addSegments(immutableSet(segment1)));\n \n-      store.write(me);\n+      store.write(me1);\n \n-      assertTrue(store.contains(key));\n+      assertTrue(store.contains(KEY_1));\n+      assertEquals(Arrays.asList(KEY_1, KEY_2), listKeys(null));\n    }\n \n-   // deleteRange uses a magic begin and end key. we assert that everything was removed\n-   public void testDeleteRange() {\n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         String value = \"value-\" + i;\n-         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n-         store.write(me);\n-         assertTrue(store.contains(key));\n-      }\n+   public void testClear() {\n+      MarshallableEntry me1 = marshallableEntryFactory.create(KEY_1, \"value\");\n+      store.write(1, me1);\n+      assertTrue(join(store.containsKey(1, KEY_1)));\n+\n+      // clear() uses RockDB's DeleteRange call internally\n+      // Create a fake key that is after the end key of this DeleteRange call\n+      // A custom marshaller could in theory create the same kind of key, but this is simpler\n+      // because we don't need to unmarshal the key\n+      int keySize = 10000;\n+      byte[] keyBytes = new byte[keySize];\n+      Arrays.fill(keyBytes, (byte) 0xff);\n+      byte[] valueBytes = new byte[0];\n+      MarshallableEntry me2 = marshallableEntryFactory.create(ByteBufferImpl.create(keyBytes), ByteBufferImpl.create(valueBytes));\n+      store.write(1, me2);\n+\n+      // Because key2 cannot be unmarshalled, we cannot confirm the write with contains(key2) or even with size()\n \n       store.clear();\n \n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         boolean contains = store.contains(key);\n-         assertFalse(contains);\n-      }\n+      assertFalse(join(store.containsKey(1, KEY_1)));\n+\n+      assertEmpty(null);\n    }\n \n-   // deleteRange uses a magic begin and end key. we assert that only the data from the give segment was removed\n-   public void testDeleteRangeForGivenSegment() {\n-      int segmentUnderTest = 1;\n-      List<String> keysInTheSegment = new ArrayList<>();\n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         String value = \"value-\" + i;\n-         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n-         int segmentFromKey = store.getKeyPartitioner().getSegment(entry.getKey());\n-         if (segmentFromKey == segmentUnderTest) {\n-            keysInTheSegment.add(key);\n-         }\n-         store.write(me);\n-      }\n+   private void assertEmpty(IntSet segments) {\n+      assertEquals(0, (long) join(store.size(segments)));\n \n-      store.removeSegments(IntSets.immutableSet(segmentUnderTest));\n+      assertEquals(Collections.emptyList(), listKeys(segments));\n+   }\n \n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         boolean contains = store.contains(key);\n-         if (keysInTheSegment.contains(key)) {\n-            assertFalse(contains);\n-         } else {\n-            assertTrue(contains);\n-         }\n-      }\n+   private List<Object> listKeys(IntSet segments) {\n+      return Flowable.fromPublisher(store.publishEntries(segments, null, true))\n+                     .map(MarshallableEntry::getKey)\n+                     .toSortedList()\n+                     .blockingGet();\n    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMwNDM1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r509304351", "bodyText": "On the on hand, 100 keys is way too much. On the other hand, all 100 keys start with the protostream prefix + the same bytes of \"key-\". We need to test a key that has more 0xff bytes than the last key in our DeleteRange call.", "author": "danberindei", "createdAt": "2020-10-21T13:51:43Z", "path": "persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java", "diffHunk": "@@ -155,4 +157,53 @@ public void testSegmentsRemovedAndAdded() {\n \n       assertTrue(store.contains(key));\n    }\n+\n+   // deleteRange uses a magic begin and end key. we assert that everything was removed\n+   public void testDeleteRange() {\n+      for (int i = 0; i < 100; i++) {", "originalCommit": "b3f7a17621c08868dd906a520a88aa763e920064", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c1f637a3d390214f130c71f9977e8e87686d24be", "chunk": "diff --git a/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java b/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\nindex 1afb4af2a1..d1aa285e45 100644\n--- a/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\n+++ b/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\n\n@@ -127,83 +136,81 @@ public void testConcurrentWrite() throws InterruptedException {\n       if (!finished.await(30, TimeUnit.SECONDS)) {\n          fail(\"Test should have finished!\");\n       }\n-      assertEquals(written.get(), (1 << THREADS) - 1, \"pre\");\n+      assertEquals(\"pre\", (1 << THREADS) - 1, written.get());\n    }\n \n    /**\n     * Test to make sure that when segments are added or removed that there are no issues\n     */\n    public void testSegmentsRemovedAndAdded() {\n-      Object key = \"first-key\";\n-      Object value = \"some-value\";\n-      int segment = keyPartitioner.getSegment(key);\n+      int segment1 = keyPartitioner.getSegment(KEY_1);\n+      MarshallableEntry me1 = marshallableEntryFactory.create(KEY_1, \"value1\");\n+      store.write(me1);\n+      assertTrue(join(store.containsKey(segment1, KEY_1)));\n+\n+      int segment2 = keyPartitioner.getSegment(KEY_2);\n+      AssertJUnit.assertTrue(segment1 != segment2);\n+      MarshallableEntry me2 = marshallableEntryFactory.create(KEY_2, \"value2\");\n+      store.write(me2);\n+      assertTrue(join(store.containsKey(segment2, KEY_2)));\n+      assertEquals(Arrays.asList(KEY_1, KEY_2), listKeys(null));\n \n-      InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-      MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n+      store.removeSegments(immutableSet(segment1));\n \n-      store.write(me);\n+      assertEquals(0, (long) join(store.size(immutableSet(segment1))));\n \n-      assertTrue(store.contains(key));\n+      assertFalse(join(store.containsKey(segment1, KEY_1)));\n+      assertEmpty(immutableSet(segment1));\n \n-      // Now remove the segment that held our key\n-      CompletionStages.join(store.removeSegments(IntSets.immutableSet(segment)));\n+      assertTrue(join(store.containsKey(segment2, KEY_2)));\n+      assertEquals(1, (long) join(store.size(immutableSet(segment2))));\n \n-      assertFalse(store.contains(key));\n+      assertEquals(singletonList(KEY_2), listKeys(null));\n \n       // Now add the segment back\n-      CompletionStages.join(store.addSegments(IntSets.immutableSet(segment)));\n+      join(store.addSegments(immutableSet(segment1)));\n \n-      store.write(me);\n+      store.write(me1);\n \n-      assertTrue(store.contains(key));\n+      assertTrue(store.contains(KEY_1));\n+      assertEquals(Arrays.asList(KEY_1, KEY_2), listKeys(null));\n    }\n \n-   // deleteRange uses a magic begin and end key. we assert that everything was removed\n-   public void testDeleteRange() {\n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         String value = \"value-\" + i;\n-         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n-         store.write(me);\n-         assertTrue(store.contains(key));\n-      }\n+   public void testClear() {\n+      MarshallableEntry me1 = marshallableEntryFactory.create(KEY_1, \"value\");\n+      store.write(1, me1);\n+      assertTrue(join(store.containsKey(1, KEY_1)));\n+\n+      // clear() uses RockDB's DeleteRange call internally\n+      // Create a fake key that is after the end key of this DeleteRange call\n+      // A custom marshaller could in theory create the same kind of key, but this is simpler\n+      // because we don't need to unmarshal the key\n+      int keySize = 10000;\n+      byte[] keyBytes = new byte[keySize];\n+      Arrays.fill(keyBytes, (byte) 0xff);\n+      byte[] valueBytes = new byte[0];\n+      MarshallableEntry me2 = marshallableEntryFactory.create(ByteBufferImpl.create(keyBytes), ByteBufferImpl.create(valueBytes));\n+      store.write(1, me2);\n+\n+      // Because key2 cannot be unmarshalled, we cannot confirm the write with contains(key2) or even with size()\n \n       store.clear();\n \n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         boolean contains = store.contains(key);\n-         assertFalse(contains);\n-      }\n+      assertFalse(join(store.containsKey(1, KEY_1)));\n+\n+      assertEmpty(null);\n    }\n \n-   // deleteRange uses a magic begin and end key. we assert that only the data from the give segment was removed\n-   public void testDeleteRangeForGivenSegment() {\n-      int segmentUnderTest = 1;\n-      List<String> keysInTheSegment = new ArrayList<>();\n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         String value = \"value-\" + i;\n-         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n-         int segmentFromKey = store.getKeyPartitioner().getSegment(entry.getKey());\n-         if (segmentFromKey == segmentUnderTest) {\n-            keysInTheSegment.add(key);\n-         }\n-         store.write(me);\n-      }\n+   private void assertEmpty(IntSet segments) {\n+      assertEquals(0, (long) join(store.size(segments)));\n \n-      store.removeSegments(IntSets.immutableSet(segmentUnderTest));\n+      assertEquals(Collections.emptyList(), listKeys(segments));\n+   }\n \n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         boolean contains = store.contains(key);\n-         if (keysInTheSegment.contains(key)) {\n-            assertFalse(contains);\n-         } else {\n-            assertTrue(contains);\n-         }\n-      }\n+   private List<Object> listKeys(IntSet segments) {\n+      return Flowable.fromPublisher(store.publishEntries(segments, null, true))\n+                     .map(MarshallableEntry::getKey)\n+                     .toSortedList()\n+                     .blockingGet();\n    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNjQ0OA==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r509936448", "bodyText": "There's already a testSegmentsRemovedAndAdded method, we should improve that, and again we don't need 100 keys.", "author": "danberindei", "createdAt": "2020-10-22T07:25:42Z", "path": "persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java", "diffHunk": "@@ -155,4 +157,53 @@ public void testSegmentsRemovedAndAdded() {\n \n       assertTrue(store.contains(key));\n    }\n+\n+   // deleteRange uses a magic begin and end key. we assert that everything was removed\n+   public void testDeleteRange() {\n+      for (int i = 0; i < 100; i++) {\n+         String key = \"key-\" + i;\n+         String value = \"value-\" + i;\n+         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n+         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n+         store.write(me);\n+         assertTrue(store.contains(key));\n+      }\n+\n+      store.clear();\n+\n+      for (int i = 0; i < 100; i++) {\n+         String key = \"key-\" + i;\n+         boolean contains = store.contains(key);\n+         assertFalse(contains);\n+      }\n+   }\n+\n+   // deleteRange uses a magic begin and end key. we assert that only the data from the give segment was removed\n+   public void testDeleteRangeForGivenSegment() {", "originalCommit": "b3f7a17621c08868dd906a520a88aa763e920064", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c1f637a3d390214f130c71f9977e8e87686d24be", "chunk": "diff --git a/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java b/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\nindex 1afb4af2a1..d1aa285e45 100644\n--- a/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\n+++ b/persistence/rocksdb/src/test/java/org/infinispan/persistence/rocksdb/RocksDBStoreTest.java\n\n@@ -127,83 +136,81 @@ public void testConcurrentWrite() throws InterruptedException {\n       if (!finished.await(30, TimeUnit.SECONDS)) {\n          fail(\"Test should have finished!\");\n       }\n-      assertEquals(written.get(), (1 << THREADS) - 1, \"pre\");\n+      assertEquals(\"pre\", (1 << THREADS) - 1, written.get());\n    }\n \n    /**\n     * Test to make sure that when segments are added or removed that there are no issues\n     */\n    public void testSegmentsRemovedAndAdded() {\n-      Object key = \"first-key\";\n-      Object value = \"some-value\";\n-      int segment = keyPartitioner.getSegment(key);\n+      int segment1 = keyPartitioner.getSegment(KEY_1);\n+      MarshallableEntry me1 = marshallableEntryFactory.create(KEY_1, \"value1\");\n+      store.write(me1);\n+      assertTrue(join(store.containsKey(segment1, KEY_1)));\n+\n+      int segment2 = keyPartitioner.getSegment(KEY_2);\n+      AssertJUnit.assertTrue(segment1 != segment2);\n+      MarshallableEntry me2 = marshallableEntryFactory.create(KEY_2, \"value2\");\n+      store.write(me2);\n+      assertTrue(join(store.containsKey(segment2, KEY_2)));\n+      assertEquals(Arrays.asList(KEY_1, KEY_2), listKeys(null));\n \n-      InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-      MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n+      store.removeSegments(immutableSet(segment1));\n \n-      store.write(me);\n+      assertEquals(0, (long) join(store.size(immutableSet(segment1))));\n \n-      assertTrue(store.contains(key));\n+      assertFalse(join(store.containsKey(segment1, KEY_1)));\n+      assertEmpty(immutableSet(segment1));\n \n-      // Now remove the segment that held our key\n-      CompletionStages.join(store.removeSegments(IntSets.immutableSet(segment)));\n+      assertTrue(join(store.containsKey(segment2, KEY_2)));\n+      assertEquals(1, (long) join(store.size(immutableSet(segment2))));\n \n-      assertFalse(store.contains(key));\n+      assertEquals(singletonList(KEY_2), listKeys(null));\n \n       // Now add the segment back\n-      CompletionStages.join(store.addSegments(IntSets.immutableSet(segment)));\n+      join(store.addSegments(immutableSet(segment1)));\n \n-      store.write(me);\n+      store.write(me1);\n \n-      assertTrue(store.contains(key));\n+      assertTrue(store.contains(KEY_1));\n+      assertEquals(Arrays.asList(KEY_1, KEY_2), listKeys(null));\n    }\n \n-   // deleteRange uses a magic begin and end key. we assert that everything was removed\n-   public void testDeleteRange() {\n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         String value = \"value-\" + i;\n-         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n-         store.write(me);\n-         assertTrue(store.contains(key));\n-      }\n+   public void testClear() {\n+      MarshallableEntry me1 = marshallableEntryFactory.create(KEY_1, \"value\");\n+      store.write(1, me1);\n+      assertTrue(join(store.containsKey(1, KEY_1)));\n+\n+      // clear() uses RockDB's DeleteRange call internally\n+      // Create a fake key that is after the end key of this DeleteRange call\n+      // A custom marshaller could in theory create the same kind of key, but this is simpler\n+      // because we don't need to unmarshal the key\n+      int keySize = 10000;\n+      byte[] keyBytes = new byte[keySize];\n+      Arrays.fill(keyBytes, (byte) 0xff);\n+      byte[] valueBytes = new byte[0];\n+      MarshallableEntry me2 = marshallableEntryFactory.create(ByteBufferImpl.create(keyBytes), ByteBufferImpl.create(valueBytes));\n+      store.write(1, me2);\n+\n+      // Because key2 cannot be unmarshalled, we cannot confirm the write with contains(key2) or even with size()\n \n       store.clear();\n \n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         boolean contains = store.contains(key);\n-         assertFalse(contains);\n-      }\n+      assertFalse(join(store.containsKey(1, KEY_1)));\n+\n+      assertEmpty(null);\n    }\n \n-   // deleteRange uses a magic begin and end key. we assert that only the data from the give segment was removed\n-   public void testDeleteRangeForGivenSegment() {\n-      int segmentUnderTest = 1;\n-      List<String> keysInTheSegment = new ArrayList<>();\n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         String value = \"value-\" + i;\n-         InternalCacheEntry entry = TestInternalCacheEntryFactory.create(key, value);\n-         MarshallableEntry me = MarshalledEntryUtil.create(entry, getMarshaller());\n-         int segmentFromKey = store.getKeyPartitioner().getSegment(entry.getKey());\n-         if (segmentFromKey == segmentUnderTest) {\n-            keysInTheSegment.add(key);\n-         }\n-         store.write(me);\n-      }\n+   private void assertEmpty(IntSet segments) {\n+      assertEquals(0, (long) join(store.size(segments)));\n \n-      store.removeSegments(IntSets.immutableSet(segmentUnderTest));\n+      assertEquals(Collections.emptyList(), listKeys(segments));\n+   }\n \n-      for (int i = 0; i < 100; i++) {\n-         String key = \"key-\" + i;\n-         boolean contains = store.contains(key);\n-         if (keysInTheSegment.contains(key)) {\n-            assertFalse(contains);\n-         } else {\n-            assertTrue(contains);\n-         }\n-      }\n+   private List<Object> listKeys(IntSet segments) {\n+      return Flowable.fromPublisher(store.publishEntries(segments, null, true))\n+                     .map(MarshallableEntry::getKey)\n+                     .toSortedList()\n+                     .blockingGet();\n    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNjg0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r509936842", "bodyText": "The deprecation needs to be added in the builder and XSD as well, and the parser needs to ignore it.", "author": "danberindei", "createdAt": "2020-10-22T07:26:24Z", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/configuration/RocksDBStoreConfiguration.java", "diffHunk": "@@ -105,6 +105,11 @@ public int expiryQueueSize() {\n       return expiration.expiryQueueSize();\n    }\n \n+   /**\n+    * @deprecated clearThreshold is no longer being used.\n+    * @return the configured clear threshold\n+    */\n+   @Deprecated", "originalCommit": "b3f7a17621c08868dd906a520a88aa763e920064", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIxNjU3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8766#discussion_r510216576", "bodyText": "I updated my dan_ISPN-8241_RocksDBStore branch with some changes to ignore the element if the schema version is < 12 or to throw an exception otherwise.", "author": "danberindei", "createdAt": "2020-10-22T14:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNjg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c1f637a3d390214f130c71f9977e8e87686d24be", "chunk": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/configuration/RocksDBStoreConfiguration.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/configuration/RocksDBStoreConfiguration.java\nindex efa3743914..b36ee3f0fd 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/configuration/RocksDBStoreConfiguration.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/configuration/RocksDBStoreConfiguration.java\n\n@@ -106,7 +106,7 @@ public int expiryQueueSize() {\n    }\n \n    /**\n-    * @deprecated clearThreshold is no longer being used.\n+    * @deprecated Since 12.0, no longer used. Will be removed in 15.0\n     * @return the configured clear threshold\n     */\n    @Deprecated\n"}}, {"oid": "b4152bfae4fd766694255161053c655a0d382312", "url": "https://github.com/infinispan/infinispan/commit/b4152bfae4fd766694255161053c655a0d382312", "message": "ISPN-8241 Refactor RocksDB clearThreshold", "committedDate": "2020-10-22T16:23:47Z", "type": "commit"}, {"oid": "c1f637a3d390214f130c71f9977e8e87686d24be", "url": "https://github.com/infinispan/infinispan/commit/c1f637a3d390214f130c71f9977e8e87686d24be", "message": "ISPN-8241 Deprecate RocksDB clearThreshold\n\nRocksDBStore now uses DeleteRange to clear the database or a\ncolumn family.", "committedDate": "2020-10-22T16:26:17Z", "type": "forcePushed"}, {"oid": "0359a01dd18140ee6cf0384919922103b7699406", "url": "https://github.com/infinispan/infinispan/commit/0359a01dd18140ee6cf0384919922103b7699406", "message": "ISPN-8241 Deprecate RocksDB clearThreshold\n\nRocksDBStore now uses DeleteRange to clear the database or a\ncolumn family.", "committedDate": "2020-10-22T18:29:34Z", "type": "commit"}, {"oid": "0359a01dd18140ee6cf0384919922103b7699406", "url": "https://github.com/infinispan/infinispan/commit/0359a01dd18140ee6cf0384919922103b7699406", "message": "ISPN-8241 Deprecate RocksDB clearThreshold\n\nRocksDBStore now uses DeleteRange to clear the database or a\ncolumn family.", "committedDate": "2020-10-22T18:29:34Z", "type": "forcePushed"}]}